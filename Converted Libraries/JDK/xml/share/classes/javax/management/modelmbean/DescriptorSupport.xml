<?xml version="1.0" encoding="UTF-8"?>
    <source package="javax.management.modelmbean">
        <import package="com.sun.jmx.defaults.JmxProperties.MODELMBEAN_LOGGER"/>
        <import package="com.sun.jmx.mbeanserver.Util.cast"/>
        <import package="com.sun.jmx.mbeanserver.GetPropertyAction"/>
        <import package="com.sun.jmx.mbeanserver.Util"/>
        <import package="java.io.IOException"/>
        <import package="java.io.ObjectInputStream"/>
        <import package="java.io.ObjectOutputStream"/>
        <import package="java.io.ObjectStreamField"/>
        <import package="java.lang.reflect.Constructor"/>
        <import package="java.security.AccessController"/>
        <import package="java.util.HashMap"/>
        <import package="java.util.Iterator"/>
        <import package="java.util.Map"/>
        <import package="java.util.Set"/>
        <import package="java.util.SortedMap"/>
        <import package="java.util.StringTokenizer"/>
        <import package="java.util.TreeMap"/>
        <import package="java.util.logging.Level"/>
        <import package="javax.management.Descriptor"/>
        <import package="javax.management.ImmutableDescriptor"/>
        <import package="javax.management.MBeanException"/>
        <import package="javax.management.RuntimeOperationsException"/>
        <import package="sun.reflect.misc.ReflectUtil"/>
        <class name="DescriptorSupport" line="62">
            <comment line="84">
                serialVersionUID not constant                
            </comment>
            <comment line="89">
                Serialization compatibility stuff:
                 Two serial forms are supported in this class. The selected form depends
                 on system property &quot;jmx.serial.form&quot;:
                  - &quot;1.0&quot; for JMX 1.0
                  - any other value for JMX 1.1 and higher
                
                 Serial version for old serial form                
            </comment>
            <comment line="97">
                Serial version for new serial form                
            </comment>
            <comment line="100">
                Serializable fields in old serial form                
            </comment>
            <comment line="107">
                Serializable fields in new serial form                
            </comment>
            <comment line="113">
                Actual serial version and serial form                
            </comment>
            <comment line="140">
                END Serialization compatibility stuff                
            </comment>
            <comment line="143">
                Spec says that field names are case-insensitive, but that case
                is preserved.  This means that we need to be able to map from a
                name that may differ in case to the actual name that is used in
                the HashMap.  Thus, descriptorMap is a TreeMap with a Comparator
                that ignores case.
                
                Previous versions of this class had a field called &quot;descriptor&quot;
                of type HashMap where the keys were directly Strings.  This is
                hard to reconcile with the required semantics, so we fabricate
                that field virtually during serialization and deserialization
                but keep the real information in descriptorMap.                
            </comment>
            <comment line="513">
                Implementation of the Descriptor interface                
            </comment>
            <comment line="961">
                worker routine for isValid()
                 name is not null
                 descriptorType is not null
                 getMethod and setMethod are not null
                 persistPeriod is numeric
                 currencyTimeLimit is numeric
                 lastUpdatedTimeStamp is numeric
                 visibility is 1-4
                 severity is 0-6
                 log is T or F
                 role is not null
                 class is not null
                 lastReturnedTimeStamp is numeric                
            </comment>
            <comment line="1145">
                Quote the string so that it will be acceptable to the (String)
                 constructor.  Since the parsing code in that constructor is fairly
                 stupid, we&apos;re obliged to quote apparently innocuous characters like
                 space, &lt;, and &gt;.  In a future version, we should rewrite the parser
                 and only quote &quot; plus either \ or &amp; (depending on the quote syntax).                
            </comment>
            <comment line="1224">
                Parse a field value from the XML produced by toXMLString().
                 Given a descriptor XML containing &lt;field name=&quot;nnn&quot; value=&quot;vvv&quot;&gt;,
                 the argument to this method will be &quot;vvv&quot; (a string including the
                 containing quote characters).  If vvv begins and ends with parentheses,
                 then it may contain:
                 - the characters &quot;null&quot;, in which case the result is null;
                 - a value of the form &quot;some.class.namexxx&quot;, in which case the
                 result is equivalent to `new some.class.name(&quot;xxx&quot;)&apos;;
                 - some other string, in which case the result is that string,
                 without the parentheses.                
            </comment>
            <comment line="1333">
                utility to convert to int, returns -2 if bogus.                
            </comment>
            <implements interface="javax.management.Descriptor"/>
            <javadoc line="62">
                This class represents the metadata set for a ModelMBean element.  A
                  descriptor is part of the ModelMBeanInfo,
                  ModelMBeanNotificationInfo, ModelMBeanAttributeInfo,
                  ModelMBeanConstructorInfo, and ModelMBeanParameterInfo.
                  &lt;P&gt;
                  A descriptor consists of a collection of fields.  Each field is in
                  fieldname=fieldvalue format.  Field names are not case sensitive,
                  case will be preserved on field values.
                  &lt;P&gt;
                  All field names and values are not predefined. New fields can be
                  defined and added by any program.  Some fields have been predefined
                  for consistency of implementation and support by the
                  ModelMBeanInfo, ModelMBeanAttributeInfo, ModelMBeanConstructorInfo,
                  ModelMBeanNotificationInfo, ModelMBeanOperationInfo and ModelMBean
                  classes.
                  &lt;p&gt;The &lt;b&gt;serialVersionUID&lt;/b&gt; of this class is &lt;code&gt;-6292969195866300415L&lt;/code&gt;.                
                <since>
                    1.5                    
                </since>
            </javadoc>
            <declaration name="oldSerialVersionUID" type="long" line="95"/>
            <declaration name="newSerialVersionUID" type="long" line="98"/>
            <declaration name="oldSerialPersistentFields" type="ObjectStreamField[]" line="101"/>
            <declaration name="newSerialPersistentFields" type="ObjectStreamField[]" line="108"/>
            <declaration name="serialVersionUID" type="long" line="114"/>
            <declaration name="serialPersistentFields" type="ObjectStreamField[]" line="115"/>
            <javadoc line="115">
                @serialField descriptor HashMap The collection of fields representing this descriptor                
            </javadoc>
            <declaration name="serialForm" type="String" line="119"/>
            <scope line="120">
                <declaration name="form" type="String" line="121"/>
                <declaration name="compat" type="boolean" line="122"/>
                <scope line="123">
                    <declaration name="act" type="GetPropertyAction" line="124"/>
                </scope>
                <scope line="127"/>
                <scope line="131"/>
                <scope line="134"/>
            </scope>
            <declaration name="descriptorMap" type="SortedMap&lt;String,Object&gt;" line="154"/>
            <declaration name="currClass" type="String" line="156"/>
            <javadoc line="159">
                Descriptor default constructor.
                  Default initial descriptor size is 20.  It will grow as needed.&lt;br&gt;
                  Note that the created empty descriptor is not a valid descriptor
                  (the method {@link #isValid isValid} returns &lt;CODE&gt;false&lt;/CODE&gt;)                
            </javadoc>
            <method name="DescriptorSupport" type="constructor" line="165">
                <scope line="166"/>
            </method>
            <javadoc line="174">
                Descriptor constructor.  Takes as parameter the initial
                  capacity of the Map that stores the descriptor fields.
                  Capacity will grow as needed.&lt;br&gt; Note that the created empty
                  descriptor is not a valid descriptor (the method {@link #isValid isValid} returns &lt;CODE&gt;false&lt;/CODE&gt;).                
                <param>
                    initNumFields The initial capacity of the Map that
                      stores the descriptor fields.                    
                </param>
                <exception>
                    RuntimeOperationsException for illegal value for
                      initNumFields (&lt;= 0)                    
                </exception>
                <exception>
                    MBeanException Wraps a distributed communication Exception.                    
                </exception>
            </javadoc>
            <method name="DescriptorSupport" type="constructor" line="189">
                <params>
                    <param name="initNumFields" type="int"/>
                </params>
                <scope line="190"/>
                <scope line="196">
                    <scope line="197"/>
                    <declaration name="msg" type="String" line="203"/>
                    <declaration name="iae" type="RuntimeException" line="205"/>
                </scope>
            </method>
            <javadoc line="211">
                Descriptor constructor taking a Descriptor as parameter.
                  Creates a new descriptor initialized to the values of the
                  descriptor passed in parameter.                
                <param>
                    inDescr the descriptor to be used to initialize the
                      constructed descriptor. If it is null or contains no descriptor
                      fields, an empty Descriptor will be created.                    
                </param>
            </javadoc>
            <method name="DescriptorSupport" type="constructor" line="220">
                <params>
                    <param name="inDescr" type="DescriptorSupport"/>
                </params>
                <scope line="221"/>
            </method>
            <javadoc line="233">
                &lt;p&gt;Descriptor constructor taking an XML String.&lt;/p&gt;
                  &lt;p&gt;The format of the XML string is not defined, but an
                  implementation must ensure that the string returned by{@link #toXMLString() toXMLString()} on an existing
                  descriptor can be used to instantiate an equivalent
                  descriptor using this constructor.&lt;/p&gt;
                  &lt;p&gt;In this implementation, all field values will be created
                  as Strings.  If the field values are not Strings, the
                  programmer will have to reset or convert these fields
                  correctly.&lt;/p&gt;                
                <param>
                    inStr An XML-formatted string used to populate this
                      Descriptor.  The format is not defined, but any
                      implementation must ensure that the string returned by
                      method {@link #toXMLString toXMLString} on an existing
                      descriptor can be used to instantiate an equivalent
                      descriptor when instantiated using this constructor.                    
                </param>
                <exception>
                    RuntimeOperationsException If the String inStr
                      passed in parameter is null                    
                </exception>
                <exception>
                    XMLParseException XML parsing problem while parsing
                      the input String                    
                </exception>
                <exception>
                    MBeanException Wraps a distributed communication Exception.                    
                </exception>
            </javadoc>
            <method name="DescriptorSupport" type="constructor" line="267">
                <params>
                    <param name="inStr" type="String"/>
                </params>
                <comment line="261">
                    At some stage we should rewrite this code to be cleverer.  Using
                    a StringTokenizer as we do means, first, that we accept a lot of
                    bogus strings without noticing they are bogus, and second, that we
                    split the string being parsed at characters like &gt; even if they                    
                </comment>
                <comment line="269">
                    parse an XML-formatted string and populate internal                    
                </comment>
                <comment line="293">
                    parse xmlstring into structures                    
                </comment>
                <comment line="295">
                    create dummy descriptor: should have same size
                     as number of fields in xmlstring
                     loop through structures and put them in descriptor                    
                </comment>
                <comment line="307">
                    loop through tokens                    
                </comment>
                <comment line="332">
                    want kw=value, eg, name=&quot;myname&quot; value=&quot;myvalue&quot;                    
                </comment>
                <comment line="341">
                    xml parse exception                    
                </comment>
                <comment line="346">
                    xml parse exception                    
                </comment>
                <comment line="352">
                    while tokens                    
                </comment>
                <scope line="270"/>
                <scope line="275">
                    <scope line="276"/>
                    <declaration name="msg" type="String" line="281"/>
                    <declaration name="iae" type="RuntimeException" line="282"/>
                </scope>
                <declaration name="lowerInStr" type="String" line="286"/>
                <scope line="288"/>
                <declaration name="st" type="StringTokenizer" line="298"/>
                <declaration name="inFld" type="boolean" line="300"/>
                <declaration name="inDesc" type="boolean" line="301"/>
                <declaration name="fieldName" type="String" line="302"/>
                <declaration name="fieldValue" type="String" line="303"/>
                <scope line="306">
                    <declaration name="tok" type="String" line="307"/>
                    <scope line="309"/>
                    <scope line="311">
                        <scope line="312">
                            <declaration name="fieldValueObject" type="Object" line="316"/>
                        </scope>
                    </scope>
                    <scope line="323"/>
                    <scope line="325"/>
                    <scope line="330">
                        <declaration name="eq_separator" type="int" line="332"/>
                        <scope line="333">
                            <declaration name="kwPart" type="String" line="334"/>
                            <declaration name="valPart" type="String" line="335"/>
                            <scope line="340">
                                <declaration name="msg" type="String" line="341"/>
                            </scope>
                        </scope>
                        <scope line="345">
                            <declaration name="msg" type="String" line="346"/>
                        </scope>
                    </scope>
                </scope>
                <scope line="352"/>
            </method>
            <javadoc line="359">
                Constructor taking field names and field values.  Neither array
                  can be null.                
                <param>
                    fieldNames String array of field names.  No elements of
                      this array can be null.                    
                </param>
                <param>
                    fieldValues Object array of the corresponding field
                      values.  Elements of the array can be null. The
                      <code>fieldValue</code> must be valid for the
                      <code>fieldName</code> (as defined in method {@link #isValidisValid})
                      <p>Note: array sizes of parameters should match. If both arrays
                      are empty, then an empty descriptor is created.</p>                    
                </param>
                <exception>
                    RuntimeOperationsException for illegal value for
                      field Names or field Values.  The array lengths must be equal.
                      If the descriptor construction fails for any reason, this
                      exception will be thrown.                    
                </exception>
            </javadoc>
            <method name="DescriptorSupport" type="constructor" line="381">
                <params>
                    <param name="fieldNames" type="String[]"/>
                    <param name="fieldValues" type="Object[]"/>
                </params>
                <comment line="404">
                                        
                </comment>
                <comment line="407">
                    setField will throw an exception if a fieldName is be null.
                     the fieldName and fieldValue will be validated in setField.                    
                </comment>
                <scope line="382"/>
                <scope line="389">
                    <scope line="390"/>
                    <declaration name="msg" type="String" line="397"/>
                    <declaration name="iae" type="RuntimeException" line="399"/>
                </scope>
                <scope line="405"/>
                <scope line="410"/>
            </method>
            <javadoc line="417">
                Constructor taking fields in the &lt;i&gt;fieldName=fieldValue&lt;/i&gt;
                  format.                
                <param>
                    fields String array with each element containing a
                      field name and value.  If this array is null or empty, then the
                      default constructor will be executed. Null strings or empty
                      strings will be ignored.
                      <p>All field values should be Strings.  If the field values are
                      not Strings, the programmer will have to reset or convert these
                      fields correctly.
                      <p>Note: Each string should be of the form
                      <i>fieldName=fieldValue</i>.  The field name
                      ends at the first {@code =} character; for example if the String
                      is {@code a=b=c} then the field name is {@code a} and its value
                      is {@code b=c}.                    
                </param>
                <exception>
                    RuntimeOperationsException for illegal value for
                      field Names or field Values.  The field must contain an
                      "=". "=fieldValue", "fieldName", and "fieldValue" are illegal.
                      FieldName cannot be null.  "fieldName=" will cause the value to
                      be null.  If the descriptor construction fails for any reason,
                      this exception will be thrown.                    
                </exception>
            </javadoc>
            <method name="DescriptorSupport" type="constructor" line="445">
                <params>
                    <param name="fields" type="String"/>
                </params>
                <comment line="464">
                    illegal if no = or is first character                    
                </comment>
                <comment line="480">
                    = is not in last character                    
                </comment>
                <scope line="446"/>
                <scope line="457">
                    <scope line="458"/>
                    <declaration name="eq_separator" type="int" line="461"/>
                    <scope line="462">
                        <scope line="464"/>
                        <declaration name="msg" type="String" line="471"/>
                        <declaration name="iae" type="RuntimeException" line="472"/>
                    </scope>
                    <declaration name="fieldName" type="String" line="476"/>
                    <declaration name="fieldValue" type="String" line="477"/>
                    <scope line="478"/>
                    <scope line="483">
                        <scope line="484"/>
                        <declaration name="msg" type="String" line="491"/>
                        <declaration name="iae" type="RuntimeException" line="492"/>
                    </scope>
                </scope>
                <scope line="498"/>
            </method>
            <method name="init" type="void" line="505">
                <params>
                    <param name="initMap" type="Map<String,?>"/>
                </params>
            </method>
            <method name="getFieldValue" type="Object" line="516">
                <params>
                    <param name="fieldName" type="String"/>
                </params>
                <scope line="518">
                    <scope line="519"/>
                    <declaration name="msg" type="String" line="525"/>
                    <declaration name="iae" type="RuntimeException" line="526"/>
                </scope>
                <declaration name="retValue" type="Object" line="529"/>
                <scope line="530"/>
            </method>
            <method name="setField" type="void" line="540">
                <params>
                    <param name="fieldName" type="String"/>
                    <param name="fieldValue" type="Object"/>
                </params>
                <comment line="543">
                    field name cannot be null or empty                    
                </comment>
                <comment line="578">
                    Since we do not remove any existing entry with this name,
                     the field will preserve whatever case it had, ignoring
                     any difference there might be in fieldName.                    
                </comment>
                <scope line="543">
                    <scope line="544"/>
                    <declaration name="msg" type="String" line="551"/>
                    <declaration name="iae" type="RuntimeException" line="552"/>
                </scope>
                <scope line="556">
                    <scope line="557"/>
                    <declaration name="msg" type="String" line="564"/>
                    <declaration name="iae" type="RuntimeException" line="566"/>
                </scope>
                <scope line="570"/>
            </method>
            <method name="getFields" type="String[]" line="583">
                <scope line="584"/>
                <declaration name="numberOfEntries" type="int" line="589"/>
                <declaration name="responseFields" type="String[]" line="591"/>
                <declaration name="returnedSet" type="Set&lt;Map.Entry&lt;String,Object&gt;&gt;" line="592"/>
                <declaration name="i" type="int" line="594"/>
                <scope line="596"/>
                <scope line="602">
                    <declaration name="currElement" type="Map.Entry&lt;String,Object&gt;" line="603"/>
                    <scope line="605">
                        <scope line="606"/>
                    </scope>
                    <scope line="611">
                        <declaration name="currValue" type="Object" line="612"/>
                        <scope line="613"/>
                        <scope line="615">
                            <scope line="616"/>
                            <scope line="619"/>
                        </scope>
                    </scope>
                </scope>
                <scope line="628"/>
            </method>
            <method name="getFieldNames" type="String[]" line="637">
                <scope line="638"/>
                <declaration name="numberOfEntries" type="int" line="643"/>
                <declaration name="responseFields" type="String[]" line="645"/>
                <declaration name="returnedSet" type="Set&lt;Map.Entry&lt;String,Object&gt;&gt;" line="646"/>
                <declaration name="i" type="int" line="648"/>
                <scope line="650"/>
                <scope line="658">
                    <declaration name="currElement" type="Map.Entry&lt;String,Object&gt;" line="659"/>
                    <scope line="661">
                        <scope line="662"/>
                    </scope>
                    <scope line="667"/>
                </scope>
                <scope line="672"/>
            </method>
            <method name="getFieldValues" type="Object[]" line="682">
                <params>
                    <param name="fieldNames" type="String"/>
                </params>
                <comment line="689">
                    if fieldNames == null return all values
                     if fieldNames is String[0] return no values                    
                </comment>
                <scope line="683"/>
                <declaration name="numberOfEntries" type="int" line="691"/>
                <declaration name="responseFields" type="Object[]" line="693"/>
                <declaration name="i" type="int" line="695"/>
                <scope line="697"/>
                <scope line="704"/>
                <scope line="707">
                    <scope line="708">
                        <scope line="709"/>
                        <scope line="711"/>
                    </scope>
                </scope>
                <scope line="717"/>
            </method>
            <method name="setFields" type="void" line="728">
                <params>
                    <param name="fieldNames" type="String[]"/>
                    <param name="fieldValues" type="Object[]"/>
                </params>
                <scope line="730"/>
                <scope line="737">
                    <scope line="738"/>
                    <declaration name="msg" type="String" line="745"/>
                    <declaration name="iae" type="RuntimeException" line="746"/>
                </scope>
                <scope line="750">
                    <scope line="751">
                        <scope line="752"/>
                        <declaration name="msg" type="String" line="758"/>
                        <declaration name="iae" type="RuntimeException" line="759"/>
                    </scope>
                </scope>
                <scope line="764"/>
            </method>
            <javadoc line="771">
                Returns a new Descriptor which is a duplicate of the Descriptor.                
                <exception>
                    RuntimeOperationsException for illegal value for
                      field Names or field Values.  If the descriptor construction
                      fails for any reason, this exception will be thrown.                    
                </exception>
            </javadoc>
            <method name="clone" type="Object" line="780">
                <scope line="781"/>
            </method>
            <method name="removeField" type="void" line="789">
                <params>
                    <param name="fieldName" type="String"/>
                </params>
                <scope line="790"/>
            </method>
            <javadoc line="797">
                Compares this descriptor to the given object.  The objects are equal if
                  the given object is also a Descriptor, and if the two Descriptors have
                  the same field names (possibly differing in case) and the same
                  associated values.  The respective values for a field in the two
                  Descriptors are equal if the following conditions hold:&lt;/p&gt;
                  &lt;ul&gt;
                  &lt;li&gt;If one value is null then the other must be too.&lt;/li&gt;
                  &lt;li&gt;If one value is a primitive array then the other must be a primitive
                  array of the same type with the same elements.&lt;/li&gt;
                  &lt;li&gt;If one value is an object array then the other must be too and{@link java.util.Arrays#deepEquals(Object[],Object[]) Arrays.deepEquals}must return true.&lt;/li&gt;
                  &lt;li&gt;Otherwise {@link Object#equals(Object)} must return true.&lt;/li&gt;
                  &lt;/ul&gt;                
                <param>
                    o the object to compare with.                    
                </param>
                <return>
                    {@code true} if the objects are the same; {@code false}otherwise.                    
                </return>
            </javadoc>
            <method name="equals" type="boolean" line="823">
                <params>
                    <param name="o" type="Object"/>
                </params>
                <comment line="821">
                    Note: this Javadoc is copied from javax.management.Descriptor
                           due to 6369229.                    
                </comment>
            </method>
            <javadoc line="833">
                &lt;p&gt;Returns the hash code value for this descriptor.  The hash
                  code is computed as the sum of the hash codes for each field in
                  the descriptor.  The hash code of a field with name {@code n}and value {@code v} is {@code n.toLowerCase().hashCode() ^ h}.
                  Here {@code h} is the hash code of {@code v}, computed as
                  follows:&lt;/p&gt;
                  &lt;ul&gt;
                  &lt;li&gt;If {@code v} is null then {@code h} is 0.&lt;/li&gt;
                  &lt;li&gt;If {@code v} is a primitive array then {@code h} is computed using
                  the appropriate overloading of {@code java.util.Arrays.hashCode}.&lt;/li&gt;
                  &lt;li&gt;If {@code v} is an object array then {@code h} is computed using{@link java.util.Arrays#deepHashCode(Object[]) Arrays.deepHashCode}.&lt;/li&gt;
                  &lt;li&gt;Otherwise {@code h} is {@code v.hashCode()}.&lt;/li&gt;
                  &lt;/ul&gt;                
                <return>
                    A hash code value for this object.                    
                </return>
            </javadoc>
            <method name="hashCode" type="int" line="856">
                <comment line="854">
                    Note: this Javadoc is copied from javax.management.Descriptor
                           due to 6369229.                    
                </comment>
                <comment line="859">
                    descriptorMap is sorted with a comparator that ignores cases.                    
                </comment>
                <declaration name="size" type="int" line="857"/>
            </method>
            <javadoc line="865">
                Returns true if all of the fields have legal values given their
                  names.
                  &lt;P&gt;
                  This implementation does not support  interoperating with a directory
                  or lookup service. Thus, conforming to the specification, no checking is
                  done on the &lt;i&gt;&quot;export&quot;&lt;/i&gt; field.
                  &lt;P&gt;
                  Otherwise this implementation returns false if:
                  &lt;P&gt;
                  &lt;UL&gt;
                  &lt;LI&gt; name and descriptorType fieldNames are not defined, or
                  null, or empty, or not String
                  &lt;LI&gt; class, role, getMethod, setMethod fieldNames, if defined,
                  are null or not String
                  &lt;LI&gt; persistPeriod, currencyTimeLimit, lastUpdatedTimeStamp,
                  lastReturnedTimeStamp if defined, are null, or not a Numeric
                  String or not a Numeric Value &gt;= -1
                  &lt;LI&gt; log fieldName, if defined, is null, or not a Boolean or
                  not a String with value &quot;t&quot;, &quot;f&quot;, &quot;true&quot;, &quot;false&quot;. These String
                  values must not be case sensitive.
                  &lt;LI&gt; visibility fieldName, if defined, is null, or not a
                  Numeric String or a not Numeric Value &gt;= 1 and &amp;lt;= 4
                  &lt;LI&gt; severity fieldName, if defined, is null, or not a Numeric
                  String or not a Numeric Value &gt;= 0 and &amp;lt;= 6&lt;br&gt;
                  &lt;LI&gt; persistPolicy fieldName, if defined, is null, or not one of
                  the following strings:&lt;br&gt;
                  &quot;OnUpdate&quot;, &quot;OnTimer&quot;, &quot;NoMoreOftenThan&quot;, &quot;OnUnregister&quot;, &quot;Always&quot;,
                  &quot;Never&quot;. These String values must not be case sensitive.&lt;br&gt;
                  &lt;/UL&gt;                
                <exception>
                    RuntimeOperationsException If the validity checking
                      fails for any reason, this exception will be thrown.                    
                </exception>
            </javadoc>
            <method name="isValid" type="boolean" line="900">
                <comment line="907">
                    verify that the descriptor is valid, by iterating over each field...                    
                </comment>
                <comment line="911">
                    null descriptor, not valid                    
                </comment>
                <comment line="919">
                    must have a name and descriptor type field                    
                </comment>
                <comment line="928">
                    According to the descriptor type we validate the fields contained                    
                </comment>
                <comment line="933">
                    validate the field valued...                    
                </comment>
                <comment line="951">
                    fell through, all fields OK                    
                </comment>
                <scope line="901"/>
                <declaration name="returnedSet" type="Set&lt;Map.Entry&lt;String,Object&gt;&gt;" line="908"/>
                <scope line="910">
                    <scope line="911"/>
                </scope>
                <declaration name="thisName" type="String" line="919"/>
                <declaration name="thisDescType" type="String" line="920"/>
                <scope line="923"/>
                <scope line="929">
                    <scope line="930">
                        <scope line="931">
                            <scope line="934"/>
                            <scope line="936">
                                <scope line="937"/>
                            </scope>
                        </scope>
                    </scope>
                </scope>
                <scope line="951"/>
            </method>
            <method name="validateField" type="boolean" line="975">
                <params>
                    <param name="fldName" type="String"/>
                    <param name="fldValue" type="Object"/>
                </params>
                <comment line="1051">
                    default to true, it is a field we aren&apos;t validating (user etc.)                    
                </comment>
                <declaration name="SfldValue" type="String" line="978"/>
                <declaration name="isAString" type="boolean" line="979"/>
                <scope line="980"/>
                <declaration name="nameOrDescriptorType" type="boolean" line="985"/>
                <scope line="992"/>
                <scope line="998">
                    <declaration name="v" type="long" line="999"/>
                    <scope line="1000"/>
                    <scope line="1002"/>
                </scope>
                <scope line="1010">
                    <declaration name="v" type="long" line="1012"/>
                    <scope line="1013"/>
                    <scope line="1015"/>
                </scope>
                <scope line="1020"/>
                <scope line="1031">
                    <declaration name="v" type="long" line="1033"/>
                    <scope line="1034"/>
                    <scope line="1036"/>
                </scope>
                <scope line="1041"/>
            </method>
            <javadoc line="1056">
                &lt;p&gt;Returns an XML String representing the descriptor.&lt;/p&gt;
                  &lt;p&gt;The format is not defined, but an implementation must
                  ensure that the string returned by this method can be
                  used to build an equivalent descriptor when instantiated
                  using the constructor {@link #DescriptorSupport(String)DescriptorSupport(String inStr)}.&lt;/p&gt;
                  &lt;p&gt;Fields which are not String objects will have toString()
                  called on them to create the value. The value will be
                  enclosed in parentheses.  It is not guaranteed that you can
                  reconstruct these objects unless they have been
                  specifically set up to support toString() in a meaningful
                  format and have a matching constructor that accepts a
                  String in the same format.&lt;/p&gt;
                  &lt;p&gt;If the descriptor is empty the following String is
                  returned: &amp;lt;Descriptor&amp;gt;&amp;lt;/Descriptor&amp;gt;&lt;/p&gt;                
                <return>
                    the XML string.                    
                </return>
                <exception>
                    RuntimeOperationsException for illegal value for
                      field Names or field Values.  If the XML formatted string
                      construction fails for any reason, this exception will be
                      thrown.                    
                </exception>
            </javadoc>
            <method name="toXMLString" type="String" line="1083">
                <comment line="1091">
                    Set valueString to non-null if and only if this is a string that
                    cannot be confused with the encoding of an object.  If it
                    could be so confused (surrounded by parentheses) then we
                    call makeFieldValue as for any non-String object and end                    
                </comment>
                <declaration name="buf" type="StringBuilder" line="1084"/>
                <declaration name="returnedSet" type="Set&lt;Map.Entry&lt;String,Object&gt;&gt;" line="1085"/>
                <scope line="1086">
                    <declaration name="name" type="String" line="1087"/>
                    <declaration name="value" type="Object" line="1088"/>
                    <declaration name="valueString" type="String" line="1089"/>
                    <scope line="1095">
                        <declaration name="svalue" type="String" line="1096"/>
                    </scope>
                </scope>
            </method>
            <declaration name="entities" type="String[]" line="1109"/>
            <declaration name="entityToCharMap" type="Map&lt;String,Character&gt;" line="1120"/>
            <declaration name="charToEntityMap" type="String[]" line="1122"/>
            <scope line="1124">
                <declaration name="maxChar" type="char" line="1125"/>
                <scope line="1126">
                    <declaration name="c" type="char" line="1127"/>
                </scope>
                <scope line="1132">
                    <declaration name="c" type="char" line="1133"/>
                    <declaration name="entity" type="String" line="1134"/>
                </scope>
            </scope>
            <method name="isMagic" type="boolean" line="1140">
                <params>
                    <param name="c" type="char"/>
                </params>
            </method>
            <method name="quote" type="String" line="1151">
                <params>
                    <param name="s" type="String"/>
                </params>
                <declaration name="found" type="boolean" line="1152"/>
                <scope line="1153">
                    <scope line="1154"/>
                </scope>
                <declaration name="buf" type="StringBuilder" line="1161"/>
                <scope line="1162">
                    <declaration name="c" type="char" line="1163"/>
                </scope>
            </method>
            <method name="unquote" type="String" line="1172">
                <params>
                    <param name="s" type="String"/>
                </params>
                <declaration name="buf" type="StringBuilder" line="1175"/>
                <declaration name="len" type="int" line="1176"/>
                <scope line="1177">
                    <declaration name="c" type="char" line="1178"/>
                    <declaration name="semi" type="int" line="1179"/>
                    <declaration name="quoted" type="Character" line="1180"/>
                    <scope line="1184"/>
                </scope>
            </method>
            <javadoc line="1193">
                Make the string that will go inside &quot;...&quot; for a value that is not
                  a plain String.                
                <throws>
                    RuntimeOperationsException if the value cannot be encoded.                    
                </throws>
            </javadoc>
            <method name="makeFieldValue" type="String" line="1198">
                <params>
                    <param name="value" type="Object"/>
                </params>
                <comment line="1214">
                    OK: we&apos;ll pretend the constructor is there
                     too bad if it&apos;s not: we&apos;ll find out when we try to
                     reconstruct the DescriptorSupport                    
                </comment>
                <declaration name="valueClass" type="Class&lt;?&gt;" line="1202"/>
                <scope line="1203"/>
                <scope line="1205">
                    <declaration name="msg" type="String" line="1206"/>
                    <declaration name="iae" type="RuntimeException" line="1209"/>
                </scope>
                <scope line="1212"/>
                <declaration name="quotedValueString" type="String" line="1218"/>
            </method>
            <method name="parseQuotedFieldValue" type="Object" line="1236">
                <params>
                    <param name="s" type="String"/>
                </params>
                <comment line="1245">
                    compatibility: old code didn&apos;t include class name                    
                </comment>
                <declaration name="slash" type="int" line="1242"/>
                <scope line="1243"/>
                <declaration name="className" type="String" line="1247"/>
                <declaration name="constr" type="Constructor&lt;?&gt;" line="1248"/>
                <scope line="1249">
                    <declaration name="contextClassLoader" type="ClassLoader" line="1250"/>
                    <scope line="1252"/>
                    <declaration name="c" type="Class&lt;?&gt;" line="1255"/>
                </scope>
                <scope line="1258"/>
                <declaration name="arg" type="String" line="1262"/>
                <scope line="1263"/>
                <scope line="1265">
                    <declaration name="msg" type="String" line="1266"/>
                </scope>
            </method>
            <javadoc line="1273">
                Returns &lt;pv&gt;a human readable string representing the
                  descriptor&lt;/pv&gt;.  The string will be in the format of
                  &quot;fieldName=fieldValue,fieldName2=fieldValue2,...&quot;&lt;br&gt;
                  If there are no fields in the descriptor, then an empty String
                  is returned.&lt;br&gt;
                  If a fieldValue is an object then the toString() method is
                  called on it and its returned value is used as the value for
                  the field enclosed in parenthesis.                
                <exception>
                    RuntimeOperationsException for illegal value for
                      field Names or field Values.  If the descriptor string fails
                      for any reason, this exception will be thrown.                    
                </exception>
            </javadoc>
            <method name="toString" type="String" line="1290">
                <scope line="1291"/>
                <declaration name="respStr" type="String" line="1297"/>
                <declaration name="fields" type="String[]" line="1298"/>
                <scope line="1300">
                    <scope line="1301"/>
                </scope>
                <scope line="1309"/>
                <scope line="1315">
                    <scope line="1316"/>
                    <scope line="1318"/>
                </scope>
                <scope line="1323"/>
            </method>
            <method name="toNumeric" type="long" line="1334">
                <params>
                    <param name="inStr" type="String"/>
                </params>
                <scope line="1335"/>
                <scope line="1337"/>
            </method>
            <javadoc line="1343">
                Deserializes a {@link DescriptorSupport} from an {@link ObjectInputStream}.                
            </javadoc>
            <method name="readObject" type="void" line="1348">
                <params>
                    <param name="in" type="ObjectInputStream"/>
                </params>
                <declaration name="fields" type="ObjectInputStream.GetField" line="1349"/>
                <declaration name="descriptor" type="Map&lt;String,Object&gt;" line="1350"/>
                <scope line="1352"/>
            </method>
            <javadoc line="1358">
                Serializes a {@link DescriptorSupport} to an {@link ObjectOutputStream}.                
            </javadoc>
            <method name="writeObject" type="void" line="1372">
                <params>
                    <param name="out" type="ObjectOutputStream"/>
                </params>
                <comment line="1362">
                    If you set jmx.serial.form to &quot;1.2.0&quot; or &quot;1.2.1&quot;, then we are
                    bug-compatible with those versions.  Specifically, field names
                    are forced to lower-case before being written.  This
                    contradicts the spec, which, though it does not mention
                    serialization explicitly, does say that the case of field names
                    is preserved.  But in 1.2.0 and 1.2.1, this requirement was not
                    met.  Instead, field names in the descriptor map were forced to
                    lower case.  Those versions expect this to have happened to a
                    descriptor they deserialize and e.g. getFieldValue will not
                    find a field whose name is spelt with a different case.                    
                </comment>
                <comment line="1379">
                    Purge the field &quot;targetObject&quot; from the DescriptorSupport before
                     serializing since the referenced object is typically not
                     serializable.  We do this here rather than purging the &quot;descriptor&quot;
                     variable below because that HashMap doesn&apos;t do case-insensitivity.
                     See CR 6332962.                    
                </comment>
                <declaration name="fields" type="ObjectOutputStream.PutField" line="1373"/>
                <declaration name="compat" type="boolean" line="1374"/>
                <declaration name="startMap" type="SortedMap&lt;String,Object&gt;" line="1384"/>
                <scope line="1385"/>
                <declaration name="descriptor" type="HashMap&lt;String,Object&gt;" line="1390"/>
                <scope line="1392"/>
            </method>
        </class>
    </source>