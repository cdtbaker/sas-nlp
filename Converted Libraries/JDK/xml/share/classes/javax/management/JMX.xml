<?xml version="1.0" encoding="UTF-8"?>
    <source package="javax.management">
        <import package="com.sun.jmx.mbeanserver.Introspector"/>
        <import package="java.lang.reflect.InvocationHandler"/>
        <import package="java.lang.reflect.Proxy"/>
        <class name="JMX" line="5">
            <javadoc line="5">
                Static methods from the JMX API.  There are no instances of this class.                
                <since>
                    1.6                    
                </since>
            </javadoc>
            <declaration name="proof" type="JMX" line="10"/>
            <method name="JMX" type="constructor" line="11"/>
            <declaration name="DEFAULT_VALUE_FIELD" type="String" line="13"/>
            <javadoc line="13">
                The name of the &lt;a href=&quot;Descriptor.html#defaultValue&quot;&gt;{@codedefaultValue}&lt;/a&gt; field.                
            </javadoc>
            <declaration name="IMMUTABLE_INFO_FIELD" type="String" line="17"/>
            <javadoc line="17">
                The name of the &lt;a href=&quot;Descriptor.html#immutableInfo&quot;&gt;{@codeimmutableInfo}&lt;/a&gt; field.                
            </javadoc>
            <declaration name="INTERFACE_CLASS_NAME_FIELD" type="String" line="21"/>
            <javadoc line="21">
                The name of the &lt;a href=&quot;Descriptor.html#interfaceClassName&quot;&gt;{@codeinterfaceClassName}&lt;/a&gt; field.                
            </javadoc>
            <declaration name="LEGAL_VALUES_FIELD" type="String" line="25"/>
            <javadoc line="25">
                The name of the &lt;a href=&quot;Descriptor.html#legalValues&quot;&gt;{@codelegalValues}&lt;/a&gt; field.                
            </javadoc>
            <declaration name="MAX_VALUE_FIELD" type="String" line="29"/>
            <javadoc line="29">
                The name of the &lt;a href=&quot;Descriptor.html#maxValue&quot;&gt;{@codemaxValue}&lt;/a&gt; field.                
            </javadoc>
            <declaration name="MIN_VALUE_FIELD" type="String" line="33"/>
            <javadoc line="33">
                The name of the &lt;a href=&quot;Descriptor.html#minValue&quot;&gt;{@codeminValue}&lt;/a&gt; field.                
            </javadoc>
            <declaration name="MXBEAN_FIELD" type="String" line="37"/>
            <javadoc line="37">
                The name of the &lt;a href=&quot;Descriptor.html#mxbean&quot;&gt;{@codemxbean}&lt;/a&gt; field.                
            </javadoc>
            <declaration name="OPEN_TYPE_FIELD" type="String" line="41"/>
            <javadoc line="41">
                The name of the &lt;a href=&quot;Descriptor.html#openType&quot;&gt;{@codeopenType}&lt;/a&gt; field.                
            </javadoc>
            <declaration name="ORIGINAL_TYPE_FIELD" type="String" line="45"/>
            <javadoc line="45">
                The name of the &lt;a href=&quot;Descriptor.html#originalType&quot;&gt;{@codeoriginalType}&lt;/a&gt; field.                
            </javadoc>
            <javadoc line="49">
                &lt;p&gt;Make a proxy for a Standard MBean in a local or remote
                  MBean Server.&lt;/p&gt;
                  &lt;p&gt;If you have an MBean Server {@code mbs} containing an MBean
                  with {@link ObjectName} {@code name}, and if the MBean&apos;s
                  management interface is described by the Java interface{@code MyMBean}, you can construct a proxy for the MBean like
                  this:&lt;/p&gt;
                  &lt;pre&gt;
                  MyMBean proxy = JMX.newMBeanProxy(mbs, name, MyMBean.class);
                  &lt;/pre&gt;
                  &lt;p&gt;Suppose, for example, {@code MyMBean} looks like this:&lt;/p&gt;
                  &lt;pre&gt;
                  public interface MyMBean {
                  public String getSomeAttribute();
                  public void setSomeAttribute(String value);
                  public void someOperation(String param1, int param2);
                  }
                  &lt;/pre&gt;
                  &lt;p&gt;Then you can execute:&lt;/p&gt;
                  &lt;ul&gt;
                  &lt;li&gt;{@code proxy.getSomeAttribute()} which will result in a
                  call to {@code mbs.}{@link MBeanServerConnection#getAttributegetAttribute}{@code (name, &quot;SomeAttribute&quot;)}.
                  &lt;li&gt;{@code proxy.setSomeAttribute(&quot;whatever&quot;)} which will result
                  in a call to {@code mbs.}{@link MBeanServerConnection#setAttributesetAttribute}{@code (name, new Attribute(&quot;SomeAttribute&quot;, &quot;whatever&quot;))}.
                  &lt;li&gt;{@code proxy.someOperation(&quot;param1&quot;, 2)} which will be
                  translated into a call to {@code mbs.}{@link MBeanServerConnection#invoke invoke}{@code (name, &quot;someOperation&quot;, &lt;etc&gt;)}.
                  &lt;/ul&gt;
                  &lt;p&gt;The object returned by this method is a{@link Proxy} whose {@code InvocationHandler} is an{@link MBeanServerInvocationHandler}.&lt;/p&gt;
                  &lt;p&gt;This method is equivalent to {@link #newMBeanProxy(MBeanServerConnection,ObjectName,Class,boolean) newMBeanProxy(connection, objectName, interfaceClass,
                  false)}.&lt;/p&gt;                
                <param>
                    connection the MBean server to forward to.                    
                </param>
                <param>
                    objectName the name of the MBean within{@code connection} to forward to.                    
                </param>
                <param>
                    interfaceClass the management interface that the MBean
                      exports, which will also be implemented by the returned proxy.                    
                </param>
                <param>
                    <T>
                      allows the compiler to know that if the {@codeinterfaceClass} parameter is {@code MyMBean.class}, for
                      example, then the return type is {@code MyMBean}.                    
                </param>
                <return>
                    the new proxy instance.                    
                </return>
            </javadoc>
            <method name="newMBeanProxy" type="T" line="88">
                <params>
                    <param name="connection" type="MBeanServerConnection"/>
                    <param name="objectName" type="ObjectName"/>
                    <param name="interfaceClass" type="Class<T>"/>
                </params>
            </method>
            <javadoc line="91">
                &lt;p&gt;Make a proxy for a Standard MBean in a local or remote MBean
                  Server that may also support the methods of {@link NotificationEmitter}.&lt;/p&gt;
                  &lt;p&gt;This method behaves the same as {@link #newMBeanProxy(MBeanServerConnection,ObjectName,Class)}, but
                  additionally, if {@code notificationEmitter} is {@codetrue}, then the MBean is assumed to be a {@link NotificationBroadcaster} or {@link NotificationEmitter} and the
                  returned proxy will implement {@link NotificationEmitter} as
                  well as {@code interfaceClass}.  A call to {@link NotificationBroadcaster#addNotificationListener} on the proxy
                  will result in a call to {@link MBeanServerConnection#addNotificationListener(ObjectName,NotificationListener,NotificationFilter,Object)}, and
                  likewise for the other methods of {@link NotificationBroadcaster} and {@link NotificationEmitter}.&lt;/p&gt;                
                <param>
                    connection the MBean server to forward to.                    
                </param>
                <param>
                    objectName the name of the MBean within{@code connection} to forward to.                    
                </param>
                <param>
                    interfaceClass the management interface that the MBean
                      exports, which will also be implemented by the returned proxy.                    
                </param>
                <param>
                    notificationEmitter make the returned proxy
                      implement {@link NotificationEmitter} by forwarding its methods
                      via {@code connection}.                    
                </param>
                <param>
                    <T>
                      allows the compiler to know that if the {@codeinterfaceClass} parameter is {@code MyMBean.class}, for
                      example, then the return type is {@code MyMBean}.                    
                </param>
                <return>
                    the new proxy instance.                    
                </return>
            </javadoc>
            <method name="newMBeanProxy" type="T" line="112">
                <params>
                    <param name="connection" type="MBeanServerConnection"/>
                    <param name="objectName" type="ObjectName"/>
                    <param name="interfaceClass" type="Class<T>"/>
                    <param name="notificationEmitter" type="boolean"/>
                </params>
            </method>
            <javadoc line="115">
                &lt;p&gt;Make a proxy for an MXBean in a local or remote
                  MBean Server.&lt;/p&gt;
                  &lt;p&gt;If you have an MBean Server {@code mbs} containing an
                  MXBean with {@link ObjectName} {@code name}, and if the
                  MXBean&apos;s management interface is described by the Java
                  interface {@code MyMXBean}, you can construct a proxy for
                  the MXBean like this:&lt;/p&gt;
                  &lt;pre&gt;
                  MyMXBean proxy = JMX.newMXBeanProxy(mbs, name, MyMXBean.class);
                  &lt;/pre&gt;
                  &lt;p&gt;Suppose, for example, {@code MyMXBean} looks like this:&lt;/p&gt;
                  &lt;pre&gt;
                  public interface MyMXBean {
                  public String getSimpleAttribute();
                  public void setSimpleAttribute(String value);
                  public {@link java.lang.management.MemoryUsage} getMappedAttribute();
                  public void setMappedAttribute(MemoryUsage memoryUsage);
                  public MemoryUsage someOperation(String param1, MemoryUsage param2);
                  }
                  &lt;/pre&gt;
                  &lt;p&gt;Then:&lt;/p&gt;
                  &lt;ul&gt;
                  &lt;li&gt;&lt;p&gt;{@code proxy.getSimpleAttribute()} will result in a
                  call to {@code mbs.}{@link MBeanServerConnection#getAttributegetAttribute}{@code (name, &quot;SimpleAttribute&quot;)}.&lt;/p&gt;
                  &lt;li&gt;&lt;p&gt;{@code proxy.setSimpleAttribute(&quot;whatever&quot;)} will result
                  in a call to {@code mbs.}{@link MBeanServerConnection#setAttribute setAttribute}&lt;code&gt;(name,
                  new Attribute(&quot;SimpleAttribute&quot;, &quot;whatever&quot;))&lt;/code&gt;.&lt;p&gt;
                  &lt;p&gt;Because {@code String} is a &lt;em&gt;simple type&lt;/em&gt;, in the
                  sense of {@link javax.management.openmbean.SimpleType}, it
                  is not changed in the context of an MXBean.  The MXBean
                  proxy behaves the same as a Standard MBean proxy (see{@link #newMBeanProxy(MBeanServerConnection,ObjectName,Class) newMBeanProxy}) for the attribute {@codeSimpleAttribute}.&lt;/p&gt;
                  &lt;li&gt;&lt;p&gt;{@code proxy.getMappedAttribute()} will result in a call
                  to {@code mbs.getAttribute(&quot;MappedAttribute&quot;)}.  The MXBean
                  mapping rules mean that the actual type of the attribute {@codeMappedAttribute} will be {@link javax.management.openmbean.CompositeData CompositeData} and
                  that is what the {@code mbs.getAttribute} call will return.
                  The proxy will then convert the {@code CompositeData} back into
                  the expected type {@code MemoryUsage} using the MXBean mapping
                  rules.&lt;/p&gt;
                  &lt;li&gt;&lt;p&gt;Similarly, {@code proxy.setMappedAttribute(memoryUsage)}will convert the {@code MemoryUsage} argument into a {@codeCompositeData} before calling {@code mbs.setAttribute}.&lt;/p&gt;
                  &lt;li&gt;&lt;p&gt;{@code proxy.someOperation(&quot;whatever&quot;, memoryUsage)}will convert the {@code MemoryUsage} argument into a {@codeCompositeData} and call {@code mbs.invoke}.  The value returned
                  by {@code mbs.invoke} will be also be a {@code CompositeData},
                  and the proxy will convert this into the expected type {@codeMemoryUsage} using the MXBean mapping rules.&lt;/p&gt;
                  &lt;/ul&gt;
                  &lt;p&gt;The object returned by this method is a{@link Proxy} whose {@code InvocationHandler} is an{@link MBeanServerInvocationHandler}.&lt;/p&gt;
                  &lt;p&gt;This method is equivalent to {@link #newMXBeanProxy(MBeanServerConnection,ObjectName,Class,boolean) newMXBeanProxy(connection, objectName, interfaceClass,
                  false)}.&lt;/p&gt;                
                <param>
                    connection the MBean server to forward to.                    
                </param>
                <param>
                    objectName the name of the MBean within{@code connection} to forward to.                    
                </param>
                <param>
                    interfaceClass the MXBean interface,
                      which will also be implemented by the returned proxy.                    
                </param>
                <param>
                    <T>
                      allows the compiler to know that if the {@codeinterfaceClass} parameter is {@code MyMXBean.class}, for
                      example, then the return type is {@code MyMXBean}.                    
                </param>
                <return>
                    the new proxy instance.                    
                </return>
            </javadoc>
            <method name="newMXBeanProxy" type="T" line="171">
                <params>
                    <param name="connection" type="MBeanServerConnection"/>
                    <param name="objectName" type="ObjectName"/>
                    <param name="interfaceClass" type="Class<T>"/>
                </params>
            </method>
            <javadoc line="174">
                &lt;p&gt;Make a proxy for an MXBean in a local or remote MBean
                  Server that may also support the methods of {@link NotificationEmitter}.&lt;/p&gt;
                  &lt;p&gt;This method behaves the same as {@link #newMXBeanProxy(MBeanServerConnection,ObjectName,Class)}, but
                  additionally, if {@code notificationEmitter} is {@codetrue}, then the MXBean is assumed to be a {@link NotificationBroadcaster} or {@link NotificationEmitter} and the
                  returned proxy will implement {@link NotificationEmitter} as
                  well as {@code interfaceClass}.  A call to {@link NotificationBroadcaster#addNotificationListener} on the proxy
                  will result in a call to {@link MBeanServerConnection#addNotificationListener(ObjectName,NotificationListener,NotificationFilter,Object)}, and
                  likewise for the other methods of {@link NotificationBroadcaster} and {@link NotificationEmitter}.&lt;/p&gt;                
                <param>
                    connection the MBean server to forward to.                    
                </param>
                <param>
                    objectName the name of the MBean within{@code connection} to forward to.                    
                </param>
                <param>
                    interfaceClass the MXBean interface,
                      which will also be implemented by the returned proxy.                    
                </param>
                <param>
                    notificationEmitter make the returned proxy
                      implement {@link NotificationEmitter} by forwarding its methods
                      via {@code connection}.                    
                </param>
                <param>
                    <T>
                      allows the compiler to know that if the {@codeinterfaceClass} parameter is {@code MyMXBean.class}, for
                      example, then the return type is {@code MyMXBean}.                    
                </param>
                <return>
                    the new proxy instance.                    
                </return>
            </javadoc>
            <method name="newMXBeanProxy" type="T" line="195">
                <params>
                    <param name="connection" type="MBeanServerConnection"/>
                    <param name="objectName" type="ObjectName"/>
                    <param name="interfaceClass" type="Class<T>"/>
                    <param name="notificationEmitter" type="boolean"/>
                </params>
                <scope line="196"/>
                <scope line="199"/>
                <declaration name="handler" type="InvocationHandler" line="202"/>
                <declaration name="interfaces" type="Class&lt;?&gt;[]" line="203"/>
                <scope line="204"/>
                <declaration name="proxy" type="Object" line="208"/>
            </method>
            <javadoc line="211">
                &lt;p&gt;Test whether an interface is an MXBean interface.
                  An interface is an MXBean interface if it is annotated{@link MXBean &amp;#64;MXBean} or {@code @MXBean(true)}or if it does not have an {@code @MXBean} annotation
                  and its name ends with &quot;{@code MXBean}&quot;.&lt;/p&gt;                
                <param>
                    interfaceClass The candidate interface.                    
                </param>
                <return>
                    true if {@code interfaceClass} is an interface and
                      meets the conditions described.                    
                </return>
                <throws>
                    NullPointerException if {@code interfaceClass} is null.                    
                </throws>
            </javadoc>
            <method name="isMXBeanInterface" type="boolean" line="220">
                <params>
                    <param name="interfaceClass" type="Class<?>"/>
                </params>
                <declaration name="a" type="MXBean" line="222"/>
            </method>
        </class>
    </source>