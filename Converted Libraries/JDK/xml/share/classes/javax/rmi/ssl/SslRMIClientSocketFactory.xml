<?xml version="1.0" encoding="UTF-8"?>
    <source package="javax.rmi.ssl">
        <import package="java.io.IOException"/>
        <import package="java.io.Serializable"/>
        <import package="java.net.Socket"/>
        <import package="java.rmi.server.RMIClientSocketFactory"/>
        <import package="java.util.StringTokenizer"/>
        <import package="javax.net.SocketFactory"/>
        <import package="javax.net.ssl.SSLSocket"/>
        <import package="javax.net.ssl.SSLSocketFactory"/>
        <class name="SslRMIClientSocketFactory" line="37">
            <comment line="193">
                We use a static field because:
                
                    SSLSocketFactory.getDefault() always returns the same object
                    (at least on Sun&apos;s implementation), and we want to make sure
                    that the Javadoc &amp; the implementation stay in sync.
                
                 If someone needs to have different SslRMIClientSocketFactory factories
                 with different underlying SSLSocketFactory objects using different key
                 and trust stores, he can always do so by subclassing this class and
                 overriding createSocket(String host, int port).                
            </comment>
            <implements interface="RMIClientSocketFactory"/>
            <implements interface="Serializable"/>
            <javadoc line="37">
                &lt;p&gt;An &lt;code&gt;SslRMIClientSocketFactory&lt;/code&gt; instance is used by the RMI
                  runtime in order to obtain client sockets for RMI calls via SSL.&lt;/p&gt;
                  &lt;p&gt;This class implements &lt;code&gt;RMIClientSocketFactory&lt;/code&gt; over
                  the Secure Sockets Layer (SSL) or Transport Layer Security (TLS)
                  protocols.&lt;/p&gt;
                  &lt;p&gt;This class creates SSL sockets using the default
                  &lt;code&gt;SSLSocketFactory&lt;/code&gt; (see {@link SSLSocketFactory#getDefault}).  All instances of this class are
                  functionally equivalent.  In particular, they all share the same
                  truststore, and the same keystore when client authentication is
                  required by the server.  This behavior can be modified in
                  subclasses by overriding the {@link #createSocket(String,int)}method; in that case, {@link #equals(Object) equals} and {@link #hashCode() hashCode} may also need to be overridden.&lt;/p&gt;
                  &lt;p&gt;If the system property
                  &lt;code&gt;javax.rmi.ssl.client.enabledCipherSuites&lt;/code&gt; is specified,
                  the {@link #createSocket(String,int)} method will call {@link SSLSocket#setEnabledCipherSuites(String[])} before returning the
                  socket.  The value of this system property is a string that is a
                  comma-separated list of SSL/TLS cipher suites to enable.&lt;/p&gt;
                  &lt;p&gt;If the system property
                  &lt;code&gt;javax.rmi.ssl.client.enabledProtocols&lt;/code&gt; is specified,
                  the {@link #createSocket(String,int)} method will call {@link SSLSocket#setEnabledProtocols(String[])} before returning the
                  socket.  The value of this system property is a string that is a
                  comma-separated list of SSL/TLS protocol versions to enable.&lt;/p&gt;                
                <see>
                    javax.net.ssl.SSLSocketFactory                    
                </see>
                <see>
                    javax.rmi.ssl.SslRMIServerSocketFactory                    
                </see>
                <since>
                    1.5                    
                </since>
            </javadoc>
            <javadoc line="76">
                &lt;p&gt;Creates a new &lt;code&gt;SslRMIClientSocketFactory&lt;/code&gt;.&lt;/p&gt;                
            </javadoc>
            <method name="SslRMIClientSocketFactory" type="constructor" line="79">
                <comment line="81">
                    We don&apos;t force the initialization of the default SSLSocketFactory
                     at construction time - because the RMI client socket factory is
                     created on the server side, where that initialization is a priori
                     meaningless, unless both server and client run in the same JVM.
                     We could possibly override readObject() to force this initialization,
                     but it might not be a good idea to actually mix this with possible
                     deserialization problems.
                     So contrarily to what we do for the server side, the initialization
                     of the SSLSocketFactory will be delayed until the first time
                     createSocket() is called - note that the default SSLSocketFactory
                     might already have been initialized anyway if someone in the JVM
                     already called SSLSocketFactory.getDefault().                    
                </comment>
            </method>
            <javadoc line="95">
                &lt;p&gt;Creates an SSL socket.&lt;/p&gt;
                  &lt;p&gt;If the system property
                  &lt;code&gt;javax.rmi.ssl.client.enabledCipherSuites&lt;/code&gt; is
                  specified, this method will call {@link SSLSocket#setEnabledCipherSuites(String[])} before returning
                  the socket. The value of this system property is a string that
                  is a comma-separated list of SSL/TLS cipher suites to
                  enable.&lt;/p&gt;
                  &lt;p&gt;If the system property
                  &lt;code&gt;javax.rmi.ssl.client.enabledProtocols&lt;/code&gt; is
                  specified, this method will call {@link SSLSocket#setEnabledProtocols(String[])} before returning the
                  socket. The value of this system property is a string that is a
                  comma-separated list of SSL/TLS protocol versions to
                  enable.&lt;/p&gt;                
            </javadoc>
            <method name="createSocket" type="Socket" line="114">
                <params>
                    <param name="host" type="String"/>
                    <param name="port" type="int"/>
                </params>
                <comment line="116">
                    Retrieve the SSLSocketFactory                    
                </comment>
                <comment line="119">
                    Create the SSLSocket                    
                </comment>
                <comment line="123">
                    Set the SSLSocket Enabled Cipher Suites                    
                </comment>
                <comment line="141">
                    Set the SSLSocket Enabled Protocols                    
                </comment>
                <comment line="159">
                    Return the preconfigured SSLSocket                    
                </comment>
                <declaration name="sslSocketFactory" type="SocketFactory" line="117"/>
                <declaration name="sslSocket" type="SSLSocket" line="120"/>
                <declaration name="enabledCipherSuites" type="String" line="124"/>
                <scope line="126">
                    <declaration name="st" type="StringTokenizer" line="127"/>
                    <declaration name="tokens" type="int" line="128"/>
                    <declaration name="enabledCipherSuitesList" type="String" line="129"/>
                    <scope line="130"/>
                    <scope line="133"/>
                    <scope line="135"/>
                </scope>
                <declaration name="enabledProtocols" type="String" line="142"/>
                <scope line="144">
                    <declaration name="st" type="StringTokenizer" line="145"/>
                    <declaration name="tokens" type="int" line="146"/>
                    <declaration name="enabledProtocolsList" type="String" line="147"/>
                    <scope line="148"/>
                    <scope line="151"/>
                    <scope line="153"/>
                </scope>
            </method>
            <javadoc line="163">
                &lt;p&gt;Indicates whether some other object is &quot;equal to&quot; this one.&lt;/p&gt;
                  &lt;p&gt;Because all instances of this class are functionally equivalent
                  (they all use the default
                  &lt;code&gt;SSLSocketFactory&lt;/code&gt;), this method simply returns
                  &lt;code&gt;this.getClass().equals(obj.getClass())&lt;/code&gt;.&lt;/p&gt;
                  &lt;p&gt;A subclass should override this method (as well
                  as {@link #hashCode()}) if its instances are not all
                  functionally equivalent.&lt;/p&gt;                
            </javadoc>
            <method name="equals" type="boolean" line="175">
                <params>
                    <param name="obj" type="Object"/>
                </params>
            </method>
            <javadoc line="181">
                &lt;p&gt;Returns a hash code value for this
                  &lt;code&gt;SslRMIClientSocketFactory&lt;/code&gt;.&lt;/p&gt;                
                <return>
                    a hash code value for this
                      &lt;code&gt;SslRMIClientSocketFactory&lt;/code&gt;.                    
                </return>
            </javadoc>
            <method name="hashCode" type="int" line="188"/>
            <declaration name="defaultSocketFactory" type="SocketFactory" line="203"/>
            <method name="getDefaultClientSocketFactory" type="SocketFactory" line="205"/>
            <declaration name="serialVersionUID" type="long" line="211"/>
        </class>
    </source>