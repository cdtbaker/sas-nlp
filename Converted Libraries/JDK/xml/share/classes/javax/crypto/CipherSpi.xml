<?xml version="1.0" encoding="UTF-8"?>
    <source package="javax.crypto">
        <import package="java.util.StringTokenizer"/>
        <import package="java.util.NoSuchElementException"/>
        <import package="java.security.AlgorithmParameters"/>
        <import package="java.security.Provider"/>
        <import package="java.security.Key"/>
        <import package="java.security.SecureRandom"/>
        <import package="java.security.NoSuchAlgorithmException"/>
        <import package="java.security.NoSuchProviderException"/>
        <import package="java.security.InvalidKeyException"/>
        <import package="java.security.InvalidAlgorithmParameterException"/>
        <import package="java.security.ProviderException"/>
        <import package="java.security.spec.AlgorithmParameterSpec"/>
        <import package="java.nio.ByteBuffer"/>
        <class name="CipherSpi" line="43">
            <comment line="725">
                copied from sun.security.jca.JCAUtil
                 will be changed to reference that method once that code has been
                 integrated and promoted                
            </comment>
            <javadoc line="43">
                This class defines the &lt;i&gt;Service Provider Interface&lt;/i&gt; (&lt;b&gt;SPI&lt;/b&gt;)
                  for the &lt;code&gt;Cipher&lt;/code&gt; class.
                  All the abstract methods in this class must be implemented by each
                  cryptographic service provider who wishes to supply the implementation
                  of a particular cipher algorithm.
                  &lt;p&gt;In order to create an instance of &lt;code&gt;Cipher&lt;/code&gt;, which
                  encapsulates an instance of this &lt;code&gt;CipherSpi&lt;/code&gt; class, an
                  application calls one of the{@link Cipher#getInstance(java.lang.String) getInstance}factory methods of the{@link Cipher Cipher} engine class and specifies the requested
                  &lt;i&gt;transformation&lt;/i&gt;.
                  Optionally, the application may also specify the name of a provider.
                  &lt;p&gt;A &lt;i&gt;transformation&lt;/i&gt; is a string that describes the operation (or
                  set of operations) to be performed on the given input, to produce some
                  output. A transformation always includes the name of a cryptographic
                  algorithm (e.g., &lt;i&gt;DES&lt;/i&gt;), and may be followed by a feedback mode and
                  padding scheme.
                  &lt;p&gt; A transformation is of the form:&lt;p&gt;
                  &lt;ul&gt;
                  &lt;li&gt;&quot;&lt;i&gt;algorithm/mode/padding&lt;/i&gt;&quot; or
                  &lt;p&gt;
                  &lt;li&gt;&quot;&lt;i&gt;algorithm&lt;/i&gt;&quot;
                  &lt;/ul&gt;
                  &lt;P&gt; (in the latter case,
                  provider-specific default values for the mode and padding scheme are used).
                  For example, the following is a valid transformation:&lt;p&gt;
                  &lt;pre&gt;
                  Cipher c = Cipher.getInstance(&quot;&lt;i&gt;DES/CBC/PKCS5Padding&lt;/i&gt;&quot;);
                  &lt;/pre&gt;
                  &lt;p&gt;A provider may supply a separate class for each combination
                  of &lt;i&gt;algorithm/mode/padding&lt;/i&gt;, or may decide to provide more generic
                  classes representing sub-transformations corresponding to
                  &lt;i&gt;algorithm&lt;/i&gt; or &lt;i&gt;algorithm/mode&lt;/i&gt; or &lt;i&gt;algorithm//padding&lt;/i&gt;
                  (note the double slashes),
                  in which case the requested mode and/or padding are set automatically by
                  the &lt;code&gt;getInstance&lt;/code&gt; methods of &lt;code&gt;Cipher&lt;/code&gt;, which invoke
                  the {@link #engineSetMode(java.lang.String) engineSetMode} and{@link #engineSetPadding(java.lang.String) engineSetPadding}methods of the provider&apos;s subclass of &lt;code&gt;CipherSpi&lt;/code&gt;.
                  &lt;p&gt;A &lt;code&gt;Cipher&lt;/code&gt; property in a provider master class may have one of
                  the following formats:
                  &lt;ul&gt;
                  &lt;li&gt;
                  &lt;pre&gt;
                  // provider&apos;s subclass of &quot;CipherSpi&quot; implements &quot;algName&quot; with
                  // pluggable mode and padding
                  &lt;code&gt;Cipher.&lt;/code&gt;&lt;i&gt;algName&lt;/i&gt;
                  &lt;/pre&gt;
                  &lt;li&gt;
                  &lt;pre&gt;
                  // provider&apos;s subclass of &quot;CipherSpi&quot; implements &quot;algName&quot; in the
                  // specified &quot;mode&quot;, with pluggable padding
                  &lt;code&gt;Cipher.&lt;/code&gt;&lt;i&gt;algName/mode&lt;/i&gt;
                  &lt;/pre&gt;
                  &lt;li&gt;
                  &lt;pre&gt;
                  // provider&apos;s subclass of &quot;CipherSpi&quot; implements &quot;algName&quot; with the
                  // specified &quot;padding&quot;, with pluggable mode
                  &lt;code&gt;Cipher.&lt;/code&gt;&lt;i&gt;algName//padding&lt;/i&gt;
                  &lt;/pre&gt;
                  &lt;li&gt;
                  &lt;pre&gt;
                  // provider&apos;s subclass of &quot;CipherSpi&quot; implements &quot;algName&quot; with the
                  // specified &quot;mode&quot; and &quot;padding&quot;
                  &lt;code&gt;Cipher.&lt;/code&gt;&lt;i&gt;algName/mode/padding&lt;/i&gt;
                  &lt;/pre&gt;
                  &lt;/ul&gt;
                  &lt;p&gt;For example, a provider may supply a subclass of &lt;code&gt;CipherSpi&lt;/code&gt;
                  that implements &lt;i&gt;DES/ECB/PKCS5Padding&lt;/i&gt;, one that implements
                  &lt;i&gt;DES/CBC/PKCS5Padding&lt;/i&gt;, one that implements
                  &lt;i&gt;DES/CFB/PKCS5Padding&lt;/i&gt;, and yet another one that implements
                  &lt;i&gt;DES/OFB/PKCS5Padding&lt;/i&gt;. That provider would have the following
                  &lt;code&gt;Cipher&lt;/code&gt; properties in its master class:&lt;p&gt;
                  &lt;ul&gt;
                  &lt;li&gt;
                  &lt;pre&gt;
                  &lt;code&gt;Cipher.&lt;/code&gt;&lt;i&gt;DES/ECB/PKCS5Padding&lt;/i&gt;
                  &lt;/pre&gt;
                  &lt;li&gt;
                  &lt;pre&gt;
                  &lt;code&gt;Cipher.&lt;/code&gt;&lt;i&gt;DES/CBC/PKCS5Padding&lt;/i&gt;
                  &lt;/pre&gt;
                  &lt;li&gt;
                  &lt;pre&gt;
                  &lt;code&gt;Cipher.&lt;/code&gt;&lt;i&gt;DES/CFB/PKCS5Padding&lt;/i&gt;
                  &lt;/pre&gt;
                  &lt;li&gt;
                  &lt;pre&gt;
                  &lt;code&gt;Cipher.&lt;/code&gt;&lt;i&gt;DES/OFB/PKCS5Padding&lt;/i&gt;
                  &lt;/pre&gt;
                  &lt;/ul&gt;
                  &lt;p&gt;Another provider may implement a class for each of the above modes
                  (i.e., one class for &lt;i&gt;ECB&lt;/i&gt;, one for &lt;i&gt;CBC&lt;/i&gt;, one for &lt;i&gt;CFB&lt;/i&gt;,
                  and one for &lt;i&gt;OFB&lt;/i&gt;), one class for &lt;i&gt;PKCS5Padding&lt;/i&gt;,
                  and a generic &lt;i&gt;DES&lt;/i&gt; class that subclasses from &lt;code&gt;CipherSpi&lt;/code&gt;.
                  That provider would have the following
                  &lt;code&gt;Cipher&lt;/code&gt; properties in its master class:&lt;p&gt;
                  &lt;ul&gt;
                  &lt;li&gt;
                  &lt;pre&gt;
                  &lt;code&gt;Cipher.&lt;/code&gt;&lt;i&gt;DES&lt;/i&gt;
                  &lt;/pre&gt;
                  &lt;/ul&gt;
                  &lt;p&gt;The &lt;code&gt;getInstance&lt;/code&gt; factory method of the &lt;code&gt;Cipher&lt;/code&gt;
                  engine class follows these rules in order to instantiate a provider&apos;s
                  implementation of &lt;code&gt;CipherSpi&lt;/code&gt; for a
                  transformation of the form &quot;&lt;i&gt;algorithm&lt;/i&gt;&quot;:
                  &lt;ol&gt;
                  &lt;li&gt;
                  Check if the provider has registered a subclass of &lt;code&gt;CipherSpi&lt;/code&gt;
                  for the specified &quot;&lt;i&gt;algorithm&lt;/i&gt;&quot;.
                  &lt;p&gt;If the answer is YES, instantiate this
                  class, for whose mode and padding scheme default values (as supplied by
                  the provider) are used.
                  &lt;p&gt;If the answer is NO, throw a &lt;code&gt;NoSuchAlgorithmException&lt;/code&gt;
                  exception.
                  &lt;/ol&gt;
                  &lt;p&gt;The &lt;code&gt;getInstance&lt;/code&gt; factory method of the &lt;code&gt;Cipher&lt;/code&gt;
                  engine class follows these rules in order to instantiate a provider&apos;s
                  implementation of &lt;code&gt;CipherSpi&lt;/code&gt; for a
                  transformation of the form &quot;&lt;i&gt;algorithm/mode/padding&lt;/i&gt;&quot;:
                  &lt;ol&gt;
                  &lt;li&gt;
                  Check if the provider has registered a subclass of &lt;code&gt;CipherSpi&lt;/code&gt;
                  for the specified &quot;&lt;i&gt;algorithm/mode/padding&lt;/i&gt;&quot; transformation.
                  &lt;p&gt;If the answer is YES, instantiate it.
                  &lt;p&gt;If the answer is NO, go to the next step.&lt;p&gt;
                  &lt;li&gt;
                  Check if the provider has registered a subclass of &lt;code&gt;CipherSpi&lt;/code&gt;
                  for the sub-transformation &quot;&lt;i&gt;algorithm/mode&lt;/i&gt;&quot;.
                  &lt;p&gt;If the answer is YES, instantiate it, and call
                  &lt;code&gt;engineSetPadding(&lt;i&gt;padding&lt;/i&gt;)&lt;/code&gt; on the new instance.
                  &lt;p&gt;If the answer is NO, go to the next step.&lt;p&gt;
                  &lt;li&gt;
                  Check if the provider has registered a subclass of &lt;code&gt;CipherSpi&lt;/code&gt;
                  for the sub-transformation &quot;&lt;i&gt;algorithm//padding&lt;/i&gt;&quot; (note the double
                  slashes).
                  &lt;p&gt;If the answer is YES, instantiate it, and call
                  &lt;code&gt;engineSetMode(&lt;i&gt;mode&lt;/i&gt;)&lt;/code&gt; on the new instance.
                  &lt;p&gt;If the answer is NO, go to the next step.&lt;p&gt;
                  &lt;li&gt;
                  Check if the provider has registered a subclass of &lt;code&gt;CipherSpi&lt;/code&gt;
                  for the sub-transformation &quot;&lt;i&gt;algorithm&lt;/i&gt;&quot;.
                  &lt;p&gt;If the answer is YES, instantiate it, and call
                  &lt;code&gt;engineSetMode(&lt;i&gt;mode&lt;/i&gt;)&lt;/code&gt; and
                  &lt;code&gt;engineSetPadding(&lt;i&gt;padding&lt;/i&gt;)&lt;/code&gt; on the new instance.
                  &lt;p&gt;If the answer is NO, throw a &lt;code&gt;NoSuchAlgorithmException&lt;/code&gt;
                  exception.
                  &lt;/ol&gt;                
                <author>
                    Jan Luehe                    
                </author>
                <see>
                    KeyGenerator                    
                </see>
                <see>
                    SecretKey                    
                </see>
                <since>
                    1.4                    
                </since>
            </javadoc>
            <method name="engineSetMode" type="void" line="232"/>
            <javadoc line="232">
                Sets the mode of this cipher.                
                <param>
                    mode the cipher mode                    
                </param>
                <exception>
                    NoSuchAlgorithmException if the requested cipher mode does
                      not exist                    
                </exception>
            </javadoc>
            <method name="engineSetPadding" type="void" line="243"/>
            <javadoc line="243">
                Sets the padding mechanism of this cipher.                
                <param>
                    padding the padding mechanism                    
                </param>
                <exception>
                    NoSuchPaddingException if the requested padding mechanism
                      does not exist                    
                </exception>
            </javadoc>
            <method name="engineGetBlockSize" type="int" line="254"/>
            <javadoc line="254">
                Returns the block size (in bytes).                
                <return>
                    the block size (in bytes), or 0 if the underlying algorithm is
                      not a block cipher                    
                </return>
            </javadoc>
            <method name="engineGetOutputSize" type="int" line="262"/>
            <javadoc line="262">
                Returns the length in bytes that an output buffer would
                  need to be in order to hold the result of the next &lt;code&gt;update&lt;/code&gt;
                  or &lt;code&gt;doFinal&lt;/code&gt; operation, given the input length
                  &lt;code&gt;inputLen&lt;/code&gt; (in bytes).
                  &lt;p&gt;This call takes into account any unprocessed (buffered) data from a
                  previous &lt;code&gt;update&lt;/code&gt; call, padding, and AEAD tagging.
                  &lt;p&gt;The actual output length of the next &lt;code&gt;update&lt;/code&gt; or
                  &lt;code&gt;doFinal&lt;/code&gt; call may be smaller than the length returned by
                  this method.                
                <param>
                    inputLen the input length (in bytes)                    
                </param>
                <return>
                    the required output buffer size (in bytes)                    
                </return>
            </javadoc>
            <method name="engineGetIV" type="byte[]" line="281"/>
            <javadoc line="281">
                Returns the initialization vector (IV) in a new buffer.
                  &lt;p&gt; This is useful in the context of password-based encryption or
                  decryption, where the IV is derived from a user-provided passphrase.                
                <return>
                    the initialization vector in a new buffer, or null if the
                      underlying algorithm does not use an IV, or if the IV has not yet
                      been set.                    
                </return>
            </javadoc>
            <method name="engineGetParameters" type="AlgorithmParameters" line="293"/>
            <javadoc line="293">
                Returns the parameters used with this cipher.
                  &lt;p&gt;The returned parameters may be the same that were used to initialize
                  this cipher, or may contain a combination of default and random
                  parameter values used by the underlying cipher implementation if this
                  cipher requires algorithm parameters but was not initialized with any.                
                <return>
                    the parameters used with this cipher, or null if this cipher
                      does not use any parameters.                    
                </return>
            </javadoc>
            <method name="engineInit" type="void" line="306"/>
            <javadoc line="306">
                Initializes this cipher with a key and a source
                  of randomness.
                  &lt;p&gt;The cipher is initialized for one of the following four operations:
                  encryption, decryption, key wrapping or key unwrapping, depending on
                  the value of &lt;code&gt;opmode&lt;/code&gt;.
                  &lt;p&gt;If this cipher requires any algorithm parameters that cannot be
                  derived from the given &lt;code&gt;key&lt;/code&gt;, the underlying cipher
                  implementation is supposed to generate the required parameters itself
                  (using provider-specific default or random values) if it is being
                  initialized for encryption or key wrapping, and raise an
                  &lt;code&gt;InvalidKeyException&lt;/code&gt; if it is being
                  initialized for decryption or key unwrapping.
                  The generated parameters can be retrieved using{@link #engineGetParameters() engineGetParameters} or{@link #engineGetIV() engineGetIV} (if the parameter is an IV).
                  &lt;p&gt;If this cipher requires algorithm parameters that cannot be
                  derived from the input parameters, and there are no reasonable
                  provider-specific default values, initialization will
                  necessarily fail.
                  &lt;p&gt;If this cipher (including its underlying feedback or padding scheme)
                  requires any random bytes (e.g., for parameter generation), it will get
                  them from &lt;code&gt;random&lt;/code&gt;.
                  &lt;p&gt;Note that when a Cipher object is initialized, it loses all
                  previously-acquired state. In other words, initializing a Cipher is
                  equivalent to creating a new instance of that Cipher and initializing
                  it.                
                <param>
                    opmode the operation mode of this cipher (this is one of
                      the following:
                      <code>ENCRYPT_MODE</code>, <code>DECRYPT_MODE</code>,
                      <code>WRAP_MODE</code> or <code>UNWRAP_MODE</code>)                    
                </param>
                <param>
                    key the encryption key                    
                </param>
                <param>
                    random the source of randomness                    
                </param>
                <exception>
                    InvalidKeyException if the given key is inappropriate for
                      initializing this cipher, or requires
                      algorithm parameters that cannot be
                      determined from the given key.                    
                </exception>
            </javadoc>
            <method name="engineInit" type="void" line="355"/>
            <javadoc line="355">
                Initializes this cipher with a key, a set of
                  algorithm parameters, and a source of randomness.
                  &lt;p&gt;The cipher is initialized for one of the following four operations:
                  encryption, decryption, key wrapping or key unwrapping, depending on
                  the value of &lt;code&gt;opmode&lt;/code&gt;.
                  &lt;p&gt;If this cipher requires any algorithm parameters and
                  &lt;code&gt;params&lt;/code&gt; is null, the underlying cipher implementation is
                  supposed to generate the required parameters itself (using
                  provider-specific default or random values) if it is being
                  initialized for encryption or key wrapping, and raise an
                  &lt;code&gt;InvalidAlgorithmParameterException&lt;/code&gt; if it is being
                  initialized for decryption or key unwrapping.
                  The generated parameters can be retrieved using{@link #engineGetParameters() engineGetParameters} or{@link #engineGetIV() engineGetIV} (if the parameter is an IV).
                  &lt;p&gt;If this cipher requires algorithm parameters that cannot be
                  derived from the input parameters, and there are no reasonable
                  provider-specific default values, initialization will
                  necessarily fail.
                  &lt;p&gt;If this cipher (including its underlying feedback or padding scheme)
                  requires any random bytes (e.g., for parameter generation), it will get
                  them from &lt;code&gt;random&lt;/code&gt;.
                  &lt;p&gt;Note that when a Cipher object is initialized, it loses all
                  previously-acquired state. In other words, initializing a Cipher is
                  equivalent to creating a new instance of that Cipher and initializing
                  it.                
                <param>
                    opmode the operation mode of this cipher (this is one of
                      the following:
                      <code>ENCRYPT_MODE</code>, <code>DECRYPT_MODE</code>,
                      <code>WRAP_MODE</code> or <code>UNWRAP_MODE</code>)                    
                </param>
                <param>
                    key the encryption key                    
                </param>
                <param>
                    params the algorithm parameters                    
                </param>
                <param>
                    random the source of randomness                    
                </param>
                <exception>
                    InvalidKeyException if the given key is inappropriate for
                      initializing this cipher                    
                </exception>
                <exception>
                    InvalidAlgorithmParameterException if the given algorithm
                      parameters are inappropriate for this cipher,
                      or if this cipher requires
                      algorithm parameters and <code>params</code> is null.                    
                </exception>
            </javadoc>
            <method name="engineInit" type="void" line="408"/>
            <javadoc line="408">
                Initializes this cipher with a key, a set of
                  algorithm parameters, and a source of randomness.
                  &lt;p&gt;The cipher is initialized for one of the following four operations:
                  encryption, decryption, key wrapping or key unwrapping, depending on
                  the value of &lt;code&gt;opmode&lt;/code&gt;.
                  &lt;p&gt;If this cipher requires any algorithm parameters and
                  &lt;code&gt;params&lt;/code&gt; is null, the underlying cipher implementation is
                  supposed to generate the required parameters itself (using
                  provider-specific default or random values) if it is being
                  initialized for encryption or key wrapping, and raise an
                  &lt;code&gt;InvalidAlgorithmParameterException&lt;/code&gt; if it is being
                  initialized for decryption or key unwrapping.
                  The generated parameters can be retrieved using{@link #engineGetParameters() engineGetParameters} or{@link #engineGetIV() engineGetIV} (if the parameter is an IV).
                  &lt;p&gt;If this cipher requires algorithm parameters that cannot be
                  derived from the input parameters, and there are no reasonable
                  provider-specific default values, initialization will
                  necessarily fail.
                  &lt;p&gt;If this cipher (including its underlying feedback or padding scheme)
                  requires any random bytes (e.g., for parameter generation), it will get
                  them from &lt;code&gt;random&lt;/code&gt;.
                  &lt;p&gt;Note that when a Cipher object is initialized, it loses all
                  previously-acquired state. In other words, initializing a Cipher is
                  equivalent to creating a new instance of that Cipher and initializing
                  it.                
                <param>
                    opmode the operation mode of this cipher (this is one of
                      the following:
                      <code>ENCRYPT_MODE</code>, <code>DECRYPT_MODE</code>,
                      <code>WRAP_MODE</code> or <code>UNWRAP_MODE</code>)                    
                </param>
                <param>
                    key the encryption key                    
                </param>
                <param>
                    params the algorithm parameters                    
                </param>
                <param>
                    random the source of randomness                    
                </param>
                <exception>
                    InvalidKeyException if the given key is inappropriate for
                      initializing this cipher                    
                </exception>
                <exception>
                    InvalidAlgorithmParameterException if the given algorithm
                      parameters are inappropriate for this cipher,
                      or if this cipher requires
                      algorithm parameters and <code>params</code> is null.                    
                </exception>
            </javadoc>
            <method name="engineUpdate" type="byte[]" line="461"/>
            <javadoc line="461">
                Continues a multiple-part encryption or decryption operation
                  (depending on how this cipher was initialized), processing another data
                  part.
                  &lt;p&gt;The first &lt;code&gt;inputLen&lt;/code&gt; bytes in the &lt;code&gt;input&lt;/code&gt;
                  buffer, starting at &lt;code&gt;inputOffset&lt;/code&gt; inclusive, are processed,
                  and the result is stored in a new buffer.                
                <param>
                    input the input buffer                    
                </param>
                <param>
                    inputOffset the offset in <code>input</code> where the input
                      starts                    
                </param>
                <param>
                    inputLen the input length                    
                </param>
                <return>
                    the new buffer with the result, or null if the underlying
                      cipher is a block cipher and the input data is too short to result in a
                      new block.                    
                </return>
            </javadoc>
            <method name="engineUpdate" type="int" line="482"/>
            <javadoc line="482">
                Continues a multiple-part encryption or decryption operation
                  (depending on how this cipher was initialized), processing another data
                  part.
                  &lt;p&gt;The first &lt;code&gt;inputLen&lt;/code&gt; bytes in the &lt;code&gt;input&lt;/code&gt;
                  buffer, starting at &lt;code&gt;inputOffset&lt;/code&gt; inclusive, are processed,
                  and the result is stored in the &lt;code&gt;output&lt;/code&gt; buffer, starting at
                  &lt;code&gt;outputOffset&lt;/code&gt; inclusive.
                  &lt;p&gt;If the &lt;code&gt;output&lt;/code&gt; buffer is too small to hold the result,
                  a &lt;code&gt;ShortBufferException&lt;/code&gt; is thrown.                
                <param>
                    input the input buffer                    
                </param>
                <param>
                    inputOffset the offset in <code>input</code> where the input
                      starts                    
                </param>
                <param>
                    inputLen the input length                    
                </param>
                <param>
                    output the buffer for the result                    
                </param>
                <param>
                    outputOffset the offset in <code>output</code> where the result
                      is stored                    
                </param>
                <return>
                    the number of bytes stored in <code>output</code>                    
                </return>
                <exception>
                    ShortBufferException if the given output buffer is too small
                      to hold the result                    
                </exception>
            </javadoc>
            <javadoc line="513">
                Continues a multiple-part encryption or decryption operation
                  (depending on how this cipher was initialized), processing another data
                  part.
                  &lt;p&gt;All &lt;code&gt;input.remaining()&lt;/code&gt; bytes starting at
                  &lt;code&gt;input.position()&lt;/code&gt; are processed. The result is stored
                  in the output buffer.
                  Upon return, the input buffer&apos;s position will be equal
                  to its limit; its limit will not have changed. The output buffer&apos;s
                  position will have advanced by n, where n is the value returned
                  by this method; the output buffer&apos;s limit will not have changed.
                  &lt;p&gt;If &lt;code&gt;output.remaining()&lt;/code&gt; bytes are insufficient to
                  hold the result, a &lt;code&gt;ShortBufferException&lt;/code&gt; is thrown.
                  &lt;p&gt;Subclasses should consider overriding this method if they can
                  process ByteBuffers more efficiently than byte arrays.                
                <param>
                    input the input ByteBuffer                    
                </param>
                <param>
                    output the output ByteByffer                    
                </param>
                <return>
                    the number of bytes stored in <code>output</code>                    
                </return>
                <exception>
                    ShortBufferException if there is insufficient space in the
                      output buffer                    
                </exception>
                <throws>
                    NullPointerException if either parameter is <CODE>null</CODE>                    
                </throws>
                <since>
                    1.5                    
                </since>
            </javadoc>
            <method name="engineUpdate" type="int" line="544">
                <params>
                    <param name="input" type="ByteBuffer"/>
                    <param name="output" type="ByteBuffer"/>
                </params>
                <comment line="549">
                    never thrown for engineUpdate()                    
                </comment>
                <comment line="552">
                    never thrown for engineUpdate()                    
                </comment>
                <scope line="545"/>
                <scope line="547"/>
                <scope line="550"/>
            </method>
            <method name="engineDoFinal" type="byte[]" line="556"/>
            <javadoc line="556">
                Encrypts or decrypts data in a single-part operation,
                  or finishes a multiple-part operation.
                  The data is encrypted or decrypted, depending on how this cipher was
                  initialized.
                  &lt;p&gt;The first &lt;code&gt;inputLen&lt;/code&gt; bytes in the &lt;code&gt;input&lt;/code&gt;
                  buffer, starting at &lt;code&gt;inputOffset&lt;/code&gt; inclusive, and any input
                  bytes that may have been buffered during a previous &lt;code&gt;update&lt;/code&gt;
                  operation, are processed, with padding (if requested) being applied.
                  If an AEAD mode such as GCM/CCM is being used, the authentication
                  tag is appended in the case of encryption, or verified in the
                  case of decryption.
                  The result is stored in a new buffer.
                  &lt;p&gt;Upon finishing, this method resets this cipher object to the state
                  it was in when previously initialized via a call to
                  &lt;code&gt;engineInit&lt;/code&gt;.
                  That is, the object is reset and available to encrypt or decrypt
                  (depending on the operation mode that was specified in the call to
                  &lt;code&gt;engineInit&lt;/code&gt;) more data.
                  &lt;p&gt;Note: if any exception is thrown, this cipher object may need to
                  be reset before it can be used again.                
                <param>
                    input the input buffer                    
                </param>
                <param>
                    inputOffset the offset in <code>input</code> where the input
                      starts                    
                </param>
                <param>
                    inputLen the input length                    
                </param>
                <return>
                    the new buffer with the result                    
                </return>
                <exception>
                    IllegalBlockSizeException if this cipher is a block cipher,
                      no padding has been requested (only in encryption mode), and the total
                      input length of the data processed by this cipher is not a multiple of
                      block size; or if this encryption algorithm is unable to
                      process the input data provided.                    
                </exception>
                <exception>
                    BadPaddingException if this cipher is in decryption mode,
                      and (un)padding has been requested, but the decrypted data is not
                      bounded by the appropriate padding bytes                    
                </exception>
                <exception>
                    AEADBadTagException if this cipher is decrypting in an
                      AEAD mode (such as GCM/CCM), and the received authentication tag
                      does not match the calculated value                    
                </exception>
            </javadoc>
            <method name="engineDoFinal" type="int" line="604"/>
            <javadoc line="604">
                Encrypts or decrypts data in a single-part operation,
                  or finishes a multiple-part operation.
                  The data is encrypted or decrypted, depending on how this cipher was
                  initialized.
                  &lt;p&gt;The first &lt;code&gt;inputLen&lt;/code&gt; bytes in the &lt;code&gt;input&lt;/code&gt;
                  buffer, starting at &lt;code&gt;inputOffset&lt;/code&gt; inclusive, and any input
                  bytes that may have been buffered during a previous &lt;code&gt;update&lt;/code&gt;
                  operation, are processed, with padding (if requested) being applied.
                  If an AEAD mode such as GCM/CCM is being used, the authentication
                  tag is appended in the case of encryption, or verified in the
                  case of decryption.
                  The result is stored in the &lt;code&gt;output&lt;/code&gt; buffer, starting at
                  &lt;code&gt;outputOffset&lt;/code&gt; inclusive.
                  &lt;p&gt;If the &lt;code&gt;output&lt;/code&gt; buffer is too small to hold the result,
                  a &lt;code&gt;ShortBufferException&lt;/code&gt; is thrown.
                  &lt;p&gt;Upon finishing, this method resets this cipher object to the state
                  it was in when previously initialized via a call to
                  &lt;code&gt;engineInit&lt;/code&gt;.
                  That is, the object is reset and available to encrypt or decrypt
                  (depending on the operation mode that was specified in the call to
                  &lt;code&gt;engineInit&lt;/code&gt;) more data.
                  &lt;p&gt;Note: if any exception is thrown, this cipher object may need to
                  be reset before it can be used again.                
                <param>
                    input the input buffer                    
                </param>
                <param>
                    inputOffset the offset in <code>input</code> where the input
                      starts                    
                </param>
                <param>
                    inputLen the input length                    
                </param>
                <param>
                    output the buffer for the result                    
                </param>
                <param>
                    outputOffset the offset in <code>output</code> where the result
                      is stored                    
                </param>
                <return>
                    the number of bytes stored in <code>output</code>                    
                </return>
                <exception>
                    IllegalBlockSizeException if this cipher is a block cipher,
                      no padding has been requested (only in encryption mode), and the total
                      input length of the data processed by this cipher is not a multiple of
                      block size; or if this encryption algorithm is unable to
                      process the input data provided.                    
                </exception>
                <exception>
                    ShortBufferException if the given output buffer is too small
                      to hold the result                    
                </exception>
                <exception>
                    BadPaddingException if this cipher is in decryption mode,
                      and (un)padding has been requested, but the decrypted data is not
                      bounded by the appropriate padding bytes                    
                </exception>
                <exception>
                    AEADBadTagException if this cipher is decrypting in an
                      AEAD mode (such as GCM/CCM), and the received authentication tag
                      does not match the calculated value                    
                </exception>
            </javadoc>
            <javadoc line="663">
                Encrypts or decrypts data in a single-part operation,
                  or finishes a multiple-part operation.
                  The data is encrypted or decrypted, depending on how this cipher was
                  initialized.
                  &lt;p&gt;All &lt;code&gt;input.remaining()&lt;/code&gt; bytes starting at
                  &lt;code&gt;input.position()&lt;/code&gt; are processed.
                  If an AEAD mode such as GCM/CCM is being used, the authentication
                  tag is appended in the case of encryption, or verified in the
                  case of decryption.
                  The result is stored in the output buffer.
                  Upon return, the input buffer&apos;s position will be equal
                  to its limit; its limit will not have changed. The output buffer&apos;s
                  position will have advanced by n, where n is the value returned
                  by this method; the output buffer&apos;s limit will not have changed.
                  &lt;p&gt;If &lt;code&gt;output.remaining()&lt;/code&gt; bytes are insufficient to
                  hold the result, a &lt;code&gt;ShortBufferException&lt;/code&gt; is thrown.
                  &lt;p&gt;Upon finishing, this method resets this cipher object to the state
                  it was in when previously initialized via a call to
                  &lt;code&gt;engineInit&lt;/code&gt;.
                  That is, the object is reset and available to encrypt or decrypt
                  (depending on the operation mode that was specified in the call to
                  &lt;code&gt;engineInit&lt;/code&gt;) more data.
                  &lt;p&gt;Note: if any exception is thrown, this cipher object may need to
                  be reset before it can be used again.
                  &lt;p&gt;Subclasses should consider overriding this method if they can
                  process ByteBuffers more efficiently than byte arrays.                
                <param>
                    input the input ByteBuffer                    
                </param>
                <param>
                    output the output ByteByffer                    
                </param>
                <return>
                    the number of bytes stored in <code>output</code>                    
                </return>
                <exception>
                    IllegalBlockSizeException if this cipher is a block cipher,
                      no padding has been requested (only in encryption mode), and the total
                      input length of the data processed by this cipher is not a multiple of
                      block size; or if this encryption algorithm is unable to
                      process the input data provided.                    
                </exception>
                <exception>
                    ShortBufferException if there is insufficient space in the
                      output buffer                    
                </exception>
                <exception>
                    BadPaddingException if this cipher is in decryption mode,
                      and (un)padding has been requested, but the decrypted data is not
                      bounded by the appropriate padding bytes                    
                </exception>
                <exception>
                    AEADBadTagException if this cipher is decrypting in an
                      AEAD mode (such as GCM/CCM), and the received authentication tag
                      does not match the calculated value                    
                </exception>
                <throws>
                    NullPointerException if either parameter is <CODE>null</CODE>                    
                </throws>
                <since>
                    1.5                    
                </since>
            </javadoc>
            <method name="engineDoFinal" type="int" line="720">
                <params>
                    <param name="input" type="ByteBuffer"/>
                    <param name="output" type="ByteBuffer"/>
                </params>
            </method>
            <method name="getTempArraySize" type="int" line="727">
                <params>
                    <param name="totalSize" type="int"/>
                </params>
            </method>
            <javadoc line="731">
                Implementation for encryption using ByteBuffers. Used for both
                  engineUpdate() and engineDoFinal().                
            </javadoc>
            <method name="bufferCrypt" type="int" line="737">
                <params>
                    <param name="input" type="ByteBuffer"/>
                    <param name="output" type="ByteBuffer"/>
                    <param name="isUpdate" type="boolean"/>
                </params>
                <comment line="794">
                    output is not backed by an accessible byte[]                    
                </comment>
                <comment line="828">
                    we just resized the output buffer, but it still
                     did not work. Bug in the provider, abort                    
                </comment>
                <comment line="833">
                    output buffer is too small, realloc and try again                    
                </comment>
                <scope line="738"/>
                <declaration name="inPos" type="int" line="742"/>
                <declaration name="inLimit" type="int" line="743"/>
                <declaration name="inLen" type="int" line="744"/>
                <scope line="745"/>
                <declaration name="outLenNeeded" type="int" line="748"/>
                <scope line="749"/>
                <declaration name="a1" type="boolean" line="754"/>
                <declaration name="a2" type="boolean" line="755"/>
                <scope line="757">
                    <declaration name="inArray" type="byte[]" line="758"/>
                    <declaration name="inOfs" type="int" line="759"/>
                    <declaration name="outArray" type="byte[]" line="760"/>
                    <declaration name="outPos" type="int" line="761"/>
                    <declaration name="outOfs" type="int" line="762"/>
                    <declaration name="n" type="int" line="763"/>
                    <scope line="764"/>
                    <scope line="766"/>
                </scope>
                <scope line="772">
                    <declaration name="outPos" type="int" line="773"/>
                    <declaration name="outArray" type="byte[]" line="774"/>
                    <declaration name="outOfs" type="int" line="775"/>
                    <declaration name="inArray" type="byte[]" line="776"/>
                    <declaration name="total" type="int" line="777"/>
                    <scope line="778">
                        <declaration name="chunk" type="int" line="779"/>
                        <declaration name="n" type="int" line="781"/>
                        <scope line="782"/>
                        <scope line="784"/>
                    </scope>
                </scope>
                <scope line="793">
                    <declaration name="inArray" type="byte[]" line="794"/>
                    <declaration name="inOfs" type="int" line="795"/>
                    <scope line="796"/>
                    <scope line="799"/>
                    <declaration name="outArray" type="byte[]" line="803"/>
                    <declaration name="outSize" type="int" line="804"/>
                    <declaration name="total" type="int" line="805"/>
                    <declaration name="resized" type="boolean" line="806"/>
                    <scope line="807">
                        <declaration name="chunk" type="int" line="808"/>
                        <scope line="809"/>
                        <scope line="813">
                            <declaration name="n" type="int" line="814"/>
                            <scope line="815"/>
                            <scope line="817"/>
                        </scope>
                        <scope line="825">
                            <scope line="826"/>
                            <declaration name="newOut" type="int" line="834"/>
                        </scope>
                    </scope>
                </scope>
            </method>
            <javadoc line="843">
                Wrap a key.
                  &lt;p&gt;This concrete method has been added to this previously-defined
                  abstract class. (For backwards compatibility, it cannot be abstract.)
                  It may be overridden by a provider to wrap a key.
                  Such an override is expected to throw an IllegalBlockSizeException or
                  InvalidKeyException (under the specified circumstances),
                  if the given key cannot be wrapped.
                  If this method is not overridden, it always throws an
                  UnsupportedOperationException.                
                <param>
                    key the key to be wrapped.                    
                </param>
                <return>
                    the wrapped key.                    
                </return>
                <exception>
                    IllegalBlockSizeException if this cipher is a block cipher,
                      no padding has been requested, and the length of the encoding of the
                      key to be wrapped is not a multiple of the block size.                    
                </exception>
                <exception>
                    InvalidKeyException if it is impossible or unsafe to
                      wrap the key with this cipher (e.g., a hardware protected key is
                      being passed to a software-only cipher).                    
                </exception>
            </javadoc>
            <method name="engineWrap" type="byte[]" line="869">
                <params>
                    <param name="key" type="Key"/>
                </params>
            </method>
            <javadoc line="873">
                Unwrap a previously wrapped key.
                  &lt;p&gt;This concrete method has been added to this previously-defined
                  abstract class. (For backwards compatibility, it cannot be abstract.)
                  It may be overridden by a provider to unwrap a previously wrapped key.
                  Such an override is expected to throw an InvalidKeyException if
                  the given wrapped key cannot be unwrapped.
                  If this method is not overridden, it always throws an
                  UnsupportedOperationException.                
                <param>
                    wrappedKey the key to be unwrapped.                    
                </param>
                <param>
                    wrappedKeyAlgorithm the algorithm associated with the wrapped
                      key.                    
                </param>
                <param>
                    wrappedKeyType the type of the wrapped key. This is one of
                      <code>SECRET_KEY</code>, <code>PRIVATE_KEY</code>, or
                      <code>PUBLIC_KEY</code>.                    
                </param>
                <return>
                    the unwrapped key.                    
                </return>
                <exception>
                    NoSuchAlgorithmException if no installed providers
                      can create keys of type <code>wrappedKeyType</code> for the
                      <code>wrappedKeyAlgorithm</code>.                    
                </exception>
                <exception>
                    InvalidKeyException if <code>wrappedKey</code> does not
                      represent a wrapped key of type <code>wrappedKeyType</code> for
                      the <code>wrappedKeyAlgorithm</code>.                    
                </exception>
            </javadoc>
            <method name="engineUnwrap" type="Key" line="907">
                <params>
                    <param name="wrappedKey" type="byte[]"/>
                    <param name="wrappedKeyAlgorithm" type="String"/>
                    <param name="wrappedKeyType" type="int"/>
                </params>
            </method>
            <javadoc line="911">
                Returns the key size of the given key object in bits.
                  &lt;p&gt;This concrete method has been added to this previously-defined
                  abstract class. It throws an &lt;code&gt;UnsupportedOperationException&lt;/code&gt;
                  if it is not overridden by the provider.                
                <param>
                    key the key object.                    
                </param>
                <return>
                    the key size of the given key object.                    
                </return>
                <exception>
                    InvalidKeyException if <code>key</code> is invalid.                    
                </exception>
            </javadoc>
            <method name="engineGetKeySize" type="int" line="925">
                <params>
                    <param name="key" type="Key"/>
                </params>
            </method>
            <javadoc line="929">
                Continues a multi-part update of the Additional Authentication
                  Data (AAD), using a subset of the provided buffer.
                  &lt;p&gt;
                  Calls to this method provide AAD to the cipher when operating in
                  modes such as AEAD (GCM/CCM).  If this cipher is operating in
                  either GCM or CCM mode, all AAD must be supplied before beginning
                  operations on the ciphertext (via the {@code update} and {@codedoFinal} methods).                
                <param>
                    src the buffer containing the AAD                    
                </param>
                <param>
                    offset the offset in {@code src} where the AAD input starts                    
                </param>
                <param>
                    len the number of AAD bytes                    
                </param>
                <throws>
                    IllegalStateException if this cipher is in a wrong state
                      (e.g., has not been initialized), does not accept AAD, or if
                      operating in either GCM or CCM mode and one of the {@code update}methods has already been called for the active
                      encryption/decryption operation                    
                </throws>
                <throws>
                    UnsupportedOperationException if this method
                      has not been overridden by an implementation                    
                </throws>
                <since>
                    1.7                    
                </since>
            </javadoc>
            <method name="engineUpdateAAD" type="void" line="953">
                <params>
                    <param name="src" type="byte[]"/>
                    <param name="offset" type="int"/>
                    <param name="len" type="int"/>
                </params>
            </method>
            <javadoc line="959">
                Continues a multi-part update of the Additional Authentication
                  Data (AAD).
                  &lt;p&gt;
                  Calls to this method provide AAD to the cipher when operating in
                  modes such as AEAD (GCM/CCM).  If this cipher is operating in
                  either GCM or CCM mode, all AAD must be supplied before beginning
                  operations on the ciphertext (via the {@code update} and {@codedoFinal} methods).
                  &lt;p&gt;
                  All {@code src.remaining()} bytes starting at{@code src.position()} are processed.
                  Upon return, the input buffer&apos;s position will be equal
                  to its limit; its limit will not have changed.                
                <param>
                    src the buffer containing the AAD                    
                </param>
                <throws>
                    IllegalStateException if this cipher is in a wrong state
                      (e.g., has not been initialized), does not accept AAD, or if
                      operating in either GCM or CCM mode and one of the {@code update}methods has already been called for the active
                      encryption/decryption operation                    
                </throws>
                <throws>
                    UnsupportedOperationException if this method
                      has not been overridden by an implementation                    
                </throws>
                <since>
                    1.7                    
                </since>
            </javadoc>
            <method name="engineUpdateAAD" type="void" line="986">
                <params>
                    <param name="src" type="ByteBuffer"/>
                </params>
            </method>
        </class>
    </source>