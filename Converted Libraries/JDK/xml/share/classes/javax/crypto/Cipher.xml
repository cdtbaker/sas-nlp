<?xml version="1.0" encoding="UTF-8"?>
    <source package="javax.crypto">
        <import package="java.util"/>
        <import package="java.util.regex"/>
        <import package="java.util.Locale.ENGLISH"/>
        <import package="java.security"/>
        <import package="java.security.Provider.Service"/>
        <import package="java.security.spec.AlgorithmParameterSpec"/>
        <import package="java.security.spec.InvalidParameterSpecException"/>
        <import package="java.security.cert.Certificate"/>
        <import package="java.security.cert.X509Certificate"/>
        <import package="javax.crypto.spec"/>
        <import package="java.nio.ByteBuffer"/>
        <import package="java.nio.ReadOnlyBufferException"/>
        <import package="sun.security.util.Debug"/>
        <import package="sun.security.jca"/>
        <import package="sun.security.jca.GetInstance.Instance"/>
        <class name="Cipher" line="49">
            <comment line="193">
                The provider                
            </comment>
            <comment line="196">
                The provider implementation (delegate)                
            </comment>
            <comment line="199">
                The transformation                
            </comment>
            <comment line="202">
                Crypto permission representing the maximum allowable cryptographic
                 strength that this Cipher object can be used for. (The cryptographic
                 strength is a function of the keysize and algorithm parameters encoded
                 in the crypto permission.)                
            </comment>
            <comment line="208">
                The exemption mechanism that needs to be enforced                
            </comment>
            <comment line="211">
                Flag which indicates whether or not this cipher has been initialized                
            </comment>
            <comment line="214">
                The operation mode - store the operation mode after the
                 cipher has been initialized.                
            </comment>
            <comment line="218">
                The OID for the KeyUsage extension in an X.509 v3 certificate                
            </comment>
            <comment line="221">
                next SPI  to try in provider selection
                 null once provider is selected                
            </comment>
            <comment line="225">
                next service to try in provider selection
                 null once provider is selected                
            </comment>
            <comment line="229">
                remaining services to try in provider selection
                 null once provider is selected                
            </comment>
            <comment line="233">
                list of transform Strings to lookup in the provider                
            </comment>
            <comment line="320">
                Provider attribute name for supported chaining mode                
            </comment>
            <comment line="322">
                Provider attribute name for supported padding names                
            </comment>
            <comment line="325">
                constants indicating whether the provider supports
                 a given mode or padding                
            </comment>
            <comment line="327">
                does not support                
            </comment>
            <comment line="328">
                unable to determine                
            </comment>
            <comment line="329">
                does support                
            </comment>
            <comment line="439">
                get the transform matching the specified service                
            </comment>
            <comment line="677">
                If the requested crypto service is export-controlled,
                 determine the maximum allowable keysize.                
            </comment>
            <comment line="693">
                max number of debug warnings to print from chooseFirstProvider()                
            </comment>
            <comment line="994">
                Crypto permission check code below                
            </comment>
            <comment line="1095">
                check if opmode is one of the defined constants
                 throw InvalidParameterExeption if not                
            </comment>
            <javadoc line="49">
                This class provides the functionality of a cryptographic cipher for
                  encryption and decryption. It forms the core of the Java Cryptographic
                  Extension (JCE) framework.
                  &lt;p&gt;In order to create a Cipher object, the application calls the
                  Cipher&apos;s &lt;code&gt;getInstance&lt;/code&gt; method, and passes the name of the
                  requested &lt;i&gt;transformation&lt;/i&gt; to it. Optionally, the name of a provider
                  may be specified.
                  &lt;p&gt;A &lt;i&gt;transformation&lt;/i&gt; is a string that describes the operation (or
                  set of operations) to be performed on the given input, to produce some
                  output. A transformation always includes the name of a cryptographic
                  algorithm (e.g., &lt;i&gt;DES&lt;/i&gt;), and may be followed by a feedback mode and
                  padding scheme.
                  &lt;p&gt; A transformation is of the form:&lt;p&gt;
                  &lt;ul&gt;
                  &lt;li&gt;&quot;&lt;i&gt;algorithm/mode/padding&lt;/i&gt;&quot; or
                  &lt;p&gt;
                  &lt;li&gt;&quot;&lt;i&gt;algorithm&lt;/i&gt;&quot;
                  &lt;/ul&gt;
                  &lt;P&gt; (in the latter case,
                  provider-specific default values for the mode and padding scheme are used).
                  For example, the following is a valid transformation:&lt;p&gt;
                  &lt;pre&gt;
                  Cipher c = Cipher.getInstance(&quot;&lt;i&gt;DES/CBC/PKCS5Padding&lt;/i&gt;&quot;);
                  &lt;/pre&gt;
                  Using modes such as &lt;code&gt;CFB&lt;/code&gt; and &lt;code&gt;OFB&lt;/code&gt;, block
                  ciphers can encrypt data in units smaller than the cipher&apos;s actual
                  block size.  When requesting such a mode, you may optionally specify
                  the number of bits to be processed at a time by appending this number
                  to the mode name as shown in the &quot;&lt;code&gt;DES/CFB8/NoPadding&lt;/code&gt;&quot; and
                  &quot;&lt;code&gt;DES/OFB32/PKCS5Padding&lt;/code&gt;&quot; transformations. If no such
                  number is specified, a provider-specific default is used. (For
                  example, the SunJCE provider uses a default of 64 bits for DES.)
                  Thus, block ciphers can be turned into byte-oriented stream ciphers by
                  using an 8 bit mode such as CFB8 or OFB8.
                  &lt;p&gt;
                  Modes such as Authenticated Encryption with Associated Data (AEAD)
                  provide authenticity assurances for both confidential data and
                  Additional Associated Data (AAD) that is not encrypted.  (Please see
                  &lt;a href=&quot;http://www.ietf.org/rfc/rfc5116.txt&quot;&gt; RFC 5116 &lt;/a&gt; for more
                  information on AEAD and AEAD algorithms such as GCM/CCM.) Both
                  confidential and AAD data can be used when calculating the
                  authentication tag (similar to a {@link Mac}).  This tag is appended
                  to the ciphertext during encryption, and is verified on decryption.
                  &lt;p&gt;
                  AEAD modes such as GCM/CCM perform all AAD authenticity calculations
                  before starting the ciphertext authenticity calculations.  To avoid
                  implementations having to internally buffer ciphertext, all AAD data
                  must be supplied to GCM/CCM implementations (via the {@codeupdateAAD} methods) &lt;b&gt;before&lt;/b&gt; the ciphertext is processed (via
                  the {@code update} and {@code doFinal} methods).
                  &lt;pre&gt;
                  GCMParameterSpec s = new GCMParameterSpec(...);
                  cipher.init(..., s);
                  // If the GCMParameterSpec is needed again
                  cipher.getParameters().getParameterSpec(GCMParameterSpec.class));
                  cipher.updateAAD(...);  // AAD
                  cipher.update(...);     // Multi-part update
                  cipher.doFinal(...);    // conclusion of operation
                  &lt;/pre&gt;
                  Every implementation of the Java platform is required to support
                  the following standard &lt;code&gt;Cipher&lt;/code&gt; transformations with the keysizes
                  in parentheses:
                  &lt;ul&gt;
                  &lt;li&gt;&lt;tt&gt;AES/CBC/NoPadding&lt;/tt&gt; (128)&lt;/li&gt;
                  &lt;li&gt;&lt;tt&gt;AES/CBC/PKCS5Padding&lt;/tt&gt; (128)&lt;/li&gt;
                  &lt;li&gt;&lt;tt&gt;AES/ECB/NoPadding&lt;/tt&gt; (128)&lt;/li&gt;
                  &lt;li&gt;&lt;tt&gt;AES/ECB/PKCS5Padding&lt;/tt&gt; (128)&lt;/li&gt;
                  &lt;li&gt;&lt;tt&gt;DES/CBC/NoPadding&lt;/tt&gt; (56)&lt;/li&gt;
                  &lt;li&gt;&lt;tt&gt;DES/CBC/PKCS5Padding&lt;/tt&gt; (56)&lt;/li&gt;
                  &lt;li&gt;&lt;tt&gt;DES/ECB/NoPadding&lt;/tt&gt; (56)&lt;/li&gt;
                  &lt;li&gt;&lt;tt&gt;DES/ECB/PKCS5Padding&lt;/tt&gt; (56)&lt;/li&gt;
                  &lt;li&gt;&lt;tt&gt;DESede/CBC/NoPadding&lt;/tt&gt; (168)&lt;/li&gt;
                  &lt;li&gt;&lt;tt&gt;DESede/CBC/PKCS5Padding&lt;/tt&gt; (168)&lt;/li&gt;
                  &lt;li&gt;&lt;tt&gt;DESede/ECB/NoPadding&lt;/tt&gt; (168)&lt;/li&gt;
                  &lt;li&gt;&lt;tt&gt;DESede/ECB/PKCS5Padding&lt;/tt&gt; (168)&lt;/li&gt;
                  &lt;li&gt;&lt;tt&gt;RSA/ECB/PKCS1Padding&lt;/tt&gt; (1024, 2048)&lt;/li&gt;
                  &lt;li&gt;&lt;tt&gt;RSA/ECB/OAEPWithSHA-1AndMGF1Padding&lt;/tt&gt; (1024, 2048)&lt;/li&gt;
                  &lt;li&gt;&lt;tt&gt;RSA/ECB/OAEPWithSHA-256AndMGF1Padding&lt;/tt&gt; (1024, 2048)&lt;/li&gt;
                  &lt;/ul&gt;
                  These transformations are described in the
                  &lt;a href=&quot;{@docRoot}/../technotes/guides/security/StandardNames.html#Cipher&quot;&gt;
                  Cipher section&lt;/a&gt; of the
                  Java Cryptography Architecture Standard Algorithm Name Documentation.
                  Consult the release documentation for your implementation to see if any
                  other transformations are supported.                
                <author>
                    Jan Luehe                    
                </author>
                <see>
                    KeyGenerator                    
                </see>
                <see>
                    SecretKey                    
                </see>
                <since>
                    1.4                    
                </since>
            </javadoc>
            <declaration name="debug" type="Debug" line="154"/>
            <declaration name="ENCRYPT_MODE" type="int" line="157"/>
            <javadoc line="157">
                Constant used to initialize cipher to encryption mode.                
            </javadoc>
            <declaration name="DECRYPT_MODE" type="int" line="162"/>
            <javadoc line="162">
                Constant used to initialize cipher to decryption mode.                
            </javadoc>
            <declaration name="WRAP_MODE" type="int" line="167"/>
            <javadoc line="167">
                Constant used to initialize cipher to key-wrapping mode.                
            </javadoc>
            <declaration name="UNWRAP_MODE" type="int" line="172"/>
            <javadoc line="172">
                Constant used to initialize cipher to key-unwrapping mode.                
            </javadoc>
            <declaration name="PUBLIC_KEY" type="int" line="177"/>
            <javadoc line="177">
                Constant used to indicate the to-be-unwrapped key is a &quot;public key&quot;.                
            </javadoc>
            <declaration name="PRIVATE_KEY" type="int" line="182"/>
            <javadoc line="182">
                Constant used to indicate the to-be-unwrapped key is a &quot;private key&quot;.                
            </javadoc>
            <declaration name="SECRET_KEY" type="int" line="187"/>
            <javadoc line="187">
                Constant used to indicate the to-be-unwrapped key is a &quot;secret key&quot;.                
            </javadoc>
            <declaration name="provider" type="Provider" line="193"/>
            <declaration name="spi" type="CipherSpi" line="196"/>
            <declaration name="transformation" type="String" line="199"/>
            <declaration name="cryptoPerm" type="CryptoPermission" line="205"/>
            <declaration name="exmech" type="ExemptionMechanism" line="208"/>
            <declaration name="initialized" type="boolean" line="211"/>
            <declaration name="opmode" type="int" line="215"/>
            <declaration name="KEY_USAGE_EXTENSION_OID" type="String" line="218"/>
            <declaration name="firstSpi" type="CipherSpi" line="222"/>
            <declaration name="firstService" type="Service" line="226"/>
            <declaration name="serviceIterator" type="Iterator" line="230"/>
            <declaration name="transforms" type="List" line="233"/>
            <declaration name="lock" type="Object" line="235"/>
            <javadoc line="237">
                Creates a Cipher object.                
                <param>
                    cipherSpi the delegate                    
                </param>
                <param>
                    provider the provider                    
                </param>
                <param>
                    transformation the transformation                    
                </param>
            </javadoc>
            <method name="Cipher" type="constructor" line="246">
                <params>
                    <param name="cipherSpi" type="CipherSpi"/>
                    <param name="provider" type="Provider"/>
                    <param name="transformation" type="String"/>
                </params>
                <comment line="248">
                    See bug 4341369 &amp; 4334690 for more info.
                     If the caller is trusted, then okey.
                     Otherwise throw a NullPointerException.                    
                </comment>
                <scope line="250"/>
            </method>
            <javadoc line="260">
                Creates a Cipher object. Called internally and by NullCipher.                
                <param>
                    cipherSpi the delegate                    
                </param>
                <param>
                    transformation the transformation                    
                </param>
            </javadoc>
            <method name="Cipher" type="constructor" line="266">
                <params>
                    <param name="cipherSpi" type="CipherSpi"/>
                    <param name="transformation" type="String"/>
                </params>
            </method>
            <method name="Cipher" type="constructor" line="274">
                <params>
                    <param name="firstSpi" type="CipherSpi"/>
                    <param name="firstService" type="Service"/>
                    <param name="serviceIterator" type="Iterator"/>
                    <param name="transformation" type="String"/>
                    <param name="transforms" type="List"/>
                </params>
            </method>
            <method name="tokenizeTransformation" type="String[]" line="284">
                <params>
                    <param name="transformation" type="String"/>
                </params>
                <comment line="289">
                    array containing the components of a Cipher transformation:
                    
                     index 0: algorithm component (e.g., DES)
                     index 1: feedback component (e.g., CFB)
                     index 2: padding component (e.g., PKCS5Padding)                    
                </comment>
                <scope line="285"/>
                <declaration name="parts" type="String[]" line="295"/>
                <declaration name="count" type="int" line="296"/>
                <declaration name="parser" type="StringTokenizer" line="297"/>
                <scope line="298">
                    <scope line="299"/>
                    <scope line="302"/>
                </scope>
                <scope line="307"/>
                <scope line="311"/>
            </method>
            <declaration name="ATTR_MODE" type="String" line="320"/>
            <declaration name="ATTR_PAD" type="String" line="322"/>
            <declaration name="S_NO" type="int" line="326"/>
            <declaration name="S_MAYBE" type="int" line="327"/>
            <declaration name="S_YES" type="int" line="328"/>
            <class name="Transform" line="330">
                <comment line="335">
                    transform string to lookup in the provider                    
                </comment>
                <comment line="337">
                    the mode/padding suffix in upper case. for example, if the algorithm
                     to lookup is &quot;DES/CBC/PKCS5Padding&quot; suffix is &quot;/CBC/PKCS5PADDING&quot;
                     if loopup is &quot;DES&quot;, suffix is the empty string
                     needed because aliases prevent straight transform.equals()                    
                </comment>
                <comment line="342">
                    value to pass to setMode() or null if no such call required                    
                </comment>
                <comment line="344">
                    value to pass to setPadding() or null if no such call required                    
                </comment>
                <comment line="352">
                    set mode and padding for the given SPI                    
                </comment>
                <comment line="362">
                    check whether the given services supports the mode and
                     padding described by this Transform                    
                </comment>
                <comment line="374">
                    separate methods for mode and padding
                     called directly by Cipher only to throw the correct exception                    
                </comment>
                <comment line="394">
                    Map&lt;String,Pattern&gt; for previously compiled patterns
                     XXX use ConcurrentHashMap once available                    
                </comment>
                <javadoc line="330">
                    Nested class to deal with modes and paddings.                    
                </javadoc>
                <declaration name="transform" type="String" line="335"/>
                <declaration name="suffix" type="String" line="340"/>
                <declaration name="mode" type="String" line="342"/>
                <declaration name="pad" type="String" line="344"/>
                <method name="Transform" type="constructor" line="345">
                    <params>
                        <param name="alg" type="String"/>
                        <param name="suffix" type="String"/>
                        <param name="mode" type="String"/>
                        <param name="pad" type="String"/>
                    </params>
                </method>
                <method name="setModePadding" type="void" line="353">
                    <params>
                        <param name="spi" type="CipherSpi"/>
                    </params>
                    <scope line="354"/>
                    <scope line="357"/>
                </method>
                <method name="supportsModePadding" type="int" line="363">
                    <params>
                        <param name="s" type="Service"/>
                    </params>
                    <comment line="370">
                        our constants are defined so that Math.min() is a tri-valued AND                        
                    </comment>
                    <declaration name="smode" type="int" line="364"/>
                    <scope line="365"/>
                    <declaration name="spad" type="int" line="368"/>
                </method>
                <method name="supportsMode" type="int" line="375">
                    <params>
                        <param name="s" type="Service"/>
                    </params>
                </method>
                <method name="supportsPadding" type="int" line="378">
                    <params>
                        <param name="s" type="Service"/>
                    </params>
                </method>
                <method name="supports" type="int" line="382">
                    <params>
                        <param name="s" type="Service"/>
                        <param name="attrName" type="String"/>
                        <param name="value" type="String"/>
                    </params>
                    <scope line="383"/>
                    <declaration name="regexp" type="String" line="386"/>
                    <scope line="387"/>
                </method>
                <declaration name="patternCache" type="Map" line="395"/>
                <method name="matches" type="boolean" line="398">
                    <params>
                        <param name="regexp" type="String"/>
                        <param name="str" type="String"/>
                    </params>
                    <declaration name="pattern" type="Pattern" line="399"/>
                    <scope line="400"/>
                </method>
            </class>
            <method name="getTransforms" type="List" line="410">
                <params>
                    <param name="transformation" type="String"/>
                </params>
                <comment line="425">
                    DES                    
                </comment>
                <comment line="428">
                    if ((mode != null) &amp;&amp; (pad != null)) {                    
                </comment>
                <comment line="429">
                    DES/CBC/PKCS5Padding                    
                </comment>
                <declaration name="parts" type="String[]" line="411"/>
                <declaration name="alg" type="String" line="413"/>
                <declaration name="mode" type="String" line="414"/>
                <declaration name="pad" type="String" line="415"/>
                <scope line="416"/>
                <scope line="419"/>
                <scope line="423">
                    <declaration name="tr" type="Transform" line="425"/>
                </scope>
                <scope line="427">
                    <declaration name="list" type="List" line="429"/>
                </scope>
            </method>
            <method name="getTransform" type="Transform" line="439">
                <params>
                    <param name="s" type="Service"/>
                    <param name="transforms" type="List"/>
                </params>
                <declaration name="alg" type="String" line="440"/>
                <scope line="441">
                    <declaration name="tr" type="Transform" line="442"/>
                    <scope line="443"/>
                </scope>
            </method>
            <javadoc line="450">
                Returns a &lt;code&gt;Cipher&lt;/code&gt; object that implements the specified
                  transformation.
                  &lt;p&gt; This method traverses the list of registered security Providers,
                  starting with the most preferred Provider.
                  A new Cipher object encapsulating the
                  CipherSpi implementation from the first
                  Provider that supports the specified algorithm is returned.
                  &lt;p&gt; Note that the list of registered providers may be retrieved via
                  the {@link Security#getProviders() Security.getProviders()} method.                
                <param>
                    transformation the name of the transformation, e.g.,
                      <i>DES/CBC/PKCS5Padding</i>.
                      See the Cipher section in the <a href=
                      "{@docRoot}/../technotes/guides/security/StandardNames.html#Cipher">
                      Java Cryptography Architecture Standard Algorithm Name Documentation</a>
                      for information about standard transformation names.                    
                </param>
                <return>
                    a cipher that implements the requested transformation.                    
                </return>
                <exception>
                    NoSuchAlgorithmException if <code>transformation</code>
                      is null, empty, in an invalid format,
                      or if no Provider supports a CipherSpi implementation for the
                      specified algorithm.                    
                </exception>
                <exception>
                    NoSuchPaddingException if <code>transformation</code>
                      contains a padding scheme that is not available.                    
                </exception>
                <see>
                    java.security.Provider                    
                </see>
            </javadoc>
            <method name="getInstance" type="Cipher" line="484">
                <params>
                    <param name="transformation" type="String"/>
                </params>
                <comment line="493">
                    make sure there is at least one service from a signed provider
                     and that it can use the specified mode and padding                    
                </comment>
                <comment line="504">
                    should never happen                    
                </comment>
                <comment line="509">
                    does not support mode or padding we need, ignore                    
                </comment>
                <comment line="514">
                    S_MAYBE, try out if it works                    
                </comment>
                <declaration name="transforms" type="List" line="485"/>
                <declaration name="cipherServices" type="List" line="486"/>
                <scope line="487">
                    <declaration name="transform" type="Transform" line="488"/>
                </scope>
                <declaration name="services" type="List" line="491"/>
                <declaration name="t" type="Iterator" line="494"/>
                <declaration name="failure" type="Exception" line="495"/>
                <scope line="496">
                    <declaration name="s" type="Service" line="497"/>
                    <scope line="498"/>
                    <declaration name="tr" type="Transform" line="501"/>
                    <scope line="502"/>
                    <declaration name="canuse" type="int" line="506"/>
                    <scope line="507"/>
                    <scope line="511"/>
                    <scope line="513">
                        <scope line="514">
                            <declaration name="spi" type="CipherSpi" line="515"/>
                        </scope>
                        <scope line="518"/>
                    </scope>
                </scope>
            </method>
            <javadoc line="527">
                Returns a &lt;code&gt;Cipher&lt;/code&gt; object that implements the specified
                  transformation.
                  &lt;p&gt; A new Cipher object encapsulating the
                  CipherSpi implementation from the specified provider
                  is returned.  The specified provider must be registered
                  in the security provider list.
                  &lt;p&gt; Note that the list of registered providers may be retrieved via
                  the {@link Security#getProviders() Security.getProviders()} method.                
                <param>
                    transformation the name of the transformation,
                      e.g., <i>DES/CBC/PKCS5Padding</i>.
                      See the Cipher section in the <a href=
                      "{@docRoot}/../technotes/guides/security/StandardNames.html#Cipher">
                      Java Cryptography Architecture Standard Algorithm Name Documentation</a>
                      for information about standard transformation names.                    
                </param>
                <param>
                    provider the name of the provider.                    
                </param>
                <return>
                    a cipher that implements the requested transformation.                    
                </return>
                <exception>
                    NoSuchAlgorithmException if <code>transformation</code>
                      is null, empty, in an invalid format,
                      or if a CipherSpi implementation for the specified algorithm
                      is not available from the specified provider.                    
                </exception>
                <exception>
                    NoSuchProviderException if the specified provider is not
                      registered in the security provider list.                    
                </exception>
                <exception>
                    NoSuchPaddingException if <code>transformation</code>
                      contains a padding scheme that is not available.                    
                </exception>
                <exception>
                    IllegalArgumentException if the <code>provider</code>
                      is null or empty.                    
                </exception>
                <see>
                    java.security.Provider                    
                </see>
            </javadoc>
            <method name="getInstance" type="Cipher" line="570">
                <params>
                    <param name="transformation" type="String"/>
                    <param name="provider" type="String"/>
                </params>
                <scope line="571"/>
                <declaration name="p" type="Provider" line="574"/>
                <scope line="575"/>
            </method>
            <javadoc line="582">
                Returns a &lt;code&gt;Cipher&lt;/code&gt; object that implements the specified
                  transformation.
                  &lt;p&gt; A new Cipher object encapsulating the
                  CipherSpi implementation from the specified Provider
                  object is returned.  Note that the specified Provider object
                  does not have to be registered in the provider list.                
                <param>
                    transformation the name of the transformation,
                      e.g., <i>DES/CBC/PKCS5Padding</i>.
                      See the Cipher section in the <a href=
                      "{@docRoot}/../technotes/guides/security/StandardNames.html#Cipher">
                      Java Cryptography Architecture Standard Algorithm Name Documentation</a>
                      for information about standard transformation names.                    
                </param>
                <param>
                    provider the provider.                    
                </param>
                <return>
                    a cipher that implements the requested transformation.                    
                </return>
                <exception>
                    NoSuchAlgorithmException if <code>transformation</code>
                      is null, empty, in an invalid format,
                      or if a CipherSpi implementation for the specified algorithm
                      is not available from the specified Provider object.                    
                </exception>
                <exception>
                    NoSuchPaddingException if <code>transformation</code>
                      contains a padding scheme that is not available.                    
                </exception>
                <exception>
                    IllegalArgumentException if the <code>provider</code>
                      is null.                    
                </exception>
                <see>
                    java.security.Provider                    
                </see>
            </javadoc>
            <method name="getInstance" type="Cipher" line="618">
                <params>
                    <param name="transformation" type="String"/>
                    <param name="provider" type="Provider"/>
                </params>
                <comment line="634">
                    for compatibility, first do the lookup and then verify
                     the provider. this makes the difference between a NSAE
                     and a SecurityException if the
                     provider does not support the algorithm.                    
                </comment>
                <comment line="665">
                    throw NoSuchPaddingException if the problem is with padding                    
                </comment>
                <scope line="619"/>
                <declaration name="failure" type="Exception" line="622"/>
                <declaration name="transforms" type="List" line="623"/>
                <declaration name="providerChecked" type="boolean" line="624"/>
                <declaration name="paddingError" type="String" line="625"/>
                <scope line="626">
                    <declaration name="tr" type="Transform" line="627"/>
                    <declaration name="s" type="Service" line="628"/>
                    <scope line="629"/>
                    <scope line="632">
                        <declaration name="ve" type="Exception" line="637"/>
                        <scope line="638">
                            <declaration name="msg" type="String" line="639"/>
                        </scope>
                    </scope>
                    <scope line="645"/>
                    <scope line="648"/>
                    <scope line="652">
                        <declaration name="spi" type="CipherSpi" line="653"/>
                        <declaration name="cipher" type="Cipher" line="655"/>
                    </scope>
                    <scope line="659"/>
                </scope>
                <scope line="665"/>
                <scope line="668"/>
            </method>
            <method name="initCryptoPermission" type="void" line="678">
                <comment line="686">
                    Instantiate the exemption mechanism (if required)                    
                </comment>
                <scope line="679"/>
                <declaration name="exmechName" type="String" line="686"/>
                <scope line="687"/>
            </method>
            <declaration name="warnCount" type="int" line="693"/>
            <javadoc line="695">
                Choose the Spi from the first provider available. Used if
                  delayed provider selection is not possible because init()
                  is not the first method called.                
            </javadoc>
            <method name="chooseFirstProvider" type="void" line="700">
                <comment line="739">
                    should never happen                    
                </comment>
                <comment line="757">
                    not needed any more                    
                </comment>
                <scope line="701"/>
                <scope line="704">
                    <scope line="705"/>
                    <scope line="708">
                        <declaration name="w" type="int" line="709"/>
                        <scope line="710">
                            <scope line="713"/>
                        </scope>
                    </scope>
                    <declaration name="lastException" type="Exception" line="720"/>
                    <scope line="721">
                        <declaration name="s" type="Service" line="722"/>
                        <declaration name="thisSpi" type="CipherSpi" line="723"/>
                        <scope line="724"/>
                        <scope line="729"/>
                        <scope line="733"/>
                        <declaration name="tr" type="Transform" line="736"/>
                        <scope line="737"/>
                        <scope line="741"/>
                        <scope line="744">
                            <scope line="745">
                                <declaration name="obj" type="Object" line="746"/>
                                <scope line="747"/>
                            </scope>
                        </scope>
                        <scope line="761"/>
                    </scope>
                    <declaration name="e" type="ProviderException" line="765"/>
                    <scope line="767"/>
                </scope>
            </method>
            <declaration name="I_KEY" type="int" line="774"/>
            <declaration name="I_PARAMSPEC" type="int" line="775"/>
            <declaration name="I_PARAMS" type="int" line="776"/>
            <declaration name="I_CERT" type="int" line="777"/>
            <method name="implInit" type="void" line="782">
                <params>
                    <param name="thisSpi" type="CipherSpi"/>
                    <param name="type" type="int"/>
                    <param name="opmode" type="int"/>
                    <param name="key" type="Key"/>
                    <param name="paramSpec" type="AlgorithmParameterSpec"/>
                    <param name="params" type="AlgorithmParameters"/>
                    <param name="random" type="SecureRandom"/>
                </params>
            </method>
            <method name="chooseProvider" type="void" line="808">
                <params>
                    <param name="initType" type="int"/>
                    <param name="opmode" type="int"/>
                    <param name="key" type="Key"/>
                    <param name="paramSpec" type="AlgorithmParameterSpec"/>
                    <param name="params" type="AlgorithmParameters"/>
                    <param name="random" type="SecureRandom"/>
                </params>
                <comment line="828">
                    if provider says it does not support this key, ignore it                    
                </comment>
                <comment line="837">
                    should never happen                    
                </comment>
                <comment line="858">
                    NoSuchAlgorithmException from newInstance()
                     InvalidKeyException from init()
                     RuntimeException (ProviderException) from init()
                     SecurityException from crypto permission check                    
                </comment>
                <comment line="867">
                    no working provider found, fail                    
                </comment>
                <scope line="809">
                    <scope line="810"/>
                    <declaration name="lastException" type="Exception" line="814"/>
                    <scope line="815">
                        <declaration name="s" type="Service" line="816"/>
                        <declaration name="thisSpi" type="CipherSpi" line="817"/>
                        <scope line="818"/>
                        <scope line="823"/>
                        <scope line="828"/>
                        <scope line="831"/>
                        <declaration name="tr" type="Transform" line="834"/>
                        <scope line="835"/>
                        <scope line="839"/>
                        <scope line="842">
                            <scope line="843"/>
                        </scope>
                        <scope line="856">
                            <scope line="861"/>
                        </scope>
                    </scope>
                    <scope line="867"/>
                    <scope line="870"/>
                    <scope line="873"/>
                    <declaration name="kName" type="String" line="876"/>
                </scope>
            </method>
            <javadoc line="883">
                Returns the provider of this &lt;code&gt;Cipher&lt;/code&gt; object.                
                <return>
                    the provider of this <code>Cipher</code> object                    
                </return>
            </javadoc>
            <method name="getProvider" type="Provider" line="888"/>
            <javadoc line="893">
                Returns the algorithm name of this &lt;code&gt;Cipher&lt;/code&gt; object.
                  &lt;p&gt;This is the same name that was specified in one of the
                  &lt;code&gt;getInstance&lt;/code&gt; calls that created this &lt;code&gt;Cipher&lt;/code&gt;
                  object..                
                <return>
                    the algorithm name of this <code>Cipher</code> object.                    
                </return>
            </javadoc>
            <method name="getAlgorithm" type="String" line="902"/>
            <javadoc line="906">
                Returns the block size (in bytes).                
                <return>
                    the block size (in bytes), or 0 if the underlying algorithm is
                      not a block cipher                    
                </return>
            </javadoc>
            <method name="getBlockSize" type="int" line="912"/>
            <javadoc line="917">
                Returns the length in bytes that an output buffer would need to be in
                  order to hold the result of the next &lt;code&gt;update&lt;/code&gt; or
                  &lt;code&gt;doFinal&lt;/code&gt; operation, given the input length
                  &lt;code&gt;inputLen&lt;/code&gt; (in bytes).
                  &lt;p&gt;This call takes into account any unprocessed (buffered) data from a
                  previous &lt;code&gt;update&lt;/code&gt; call, padding, and AEAD tagging.
                  &lt;p&gt;The actual output length of the next &lt;code&gt;update&lt;/code&gt; or
                  &lt;code&gt;doFinal&lt;/code&gt; call may be smaller than the length returned by
                  this method.                
                <param>
                    inputLen the input length (in bytes)                    
                </param>
                <return>
                    the required output buffer size (in bytes)                    
                </return>
                <exception>
                    IllegalStateException if this cipher is in a wrong state
                      (e.g., has not yet been initialized)                    
                </exception>
            </javadoc>
            <method name="getOutputSize" type="int" line="937">
                <params>
                    <param name="inputLen" type="int"/>
                </params>
                <scope line="939"/>
                <scope line="942"/>
            </method>
            <javadoc line="950">
                Returns the initialization vector (IV) in a new buffer.
                  &lt;p&gt;This is useful in the case where a random IV was created,
                  or in the context of password-based encryption or
                  decryption, where the IV is derived from a user-supplied password.                
                <return>
                    the initialization vector in a new buffer, or null if the
                      underlying algorithm does not use an IV, or if the IV has not yet
                      been set.                    
                </return>
            </javadoc>
            <method name="getIV" type="byte[]" line="961"/>
            <javadoc line="966">
                Returns the parameters used with this cipher.
                  &lt;p&gt;The returned parameters may be the same that were used to initialize
                  this cipher, or may contain a combination of default and random
                  parameter values used by the underlying cipher implementation if this
                  cipher requires algorithm parameters but was not initialized with any.                
                <return>
                    the parameters used with this cipher, or null if this cipher
                      does not use any parameters.                    
                </return>
            </javadoc>
            <method name="getParameters" type="AlgorithmParameters" line="977"/>
            <javadoc line="982">
                Returns the exemption mechanism object used with this cipher.                
                <return>
                    the exemption mechanism object used with this cipher, or
                      null if this cipher does not use any exemption mechanism.                    
                </return>
            </javadoc>
            <method name="getExemptionMechanism" type="ExemptionMechanism" line="988"/>
            <method name="checkCryptoPerm" type="void" line="997">
                <params>
                    <param name="checkSpi" type="CipherSpi"/>
                    <param name="key" type="Key"/>
                </params>
                <comment line="1002">
                    Check if key size and default parameters are within legal limits                    
                </comment>
                <scope line="998"/>
                <declaration name="params" type="AlgorithmParameterSpec" line="1002"/>
                <scope line="1003"/>
                <scope line="1005"/>
                <scope line="1009"/>
            </method>
            <method name="checkCryptoPerm" type="void" line="1017">
                <params>
                    <param name="checkSpi" type="CipherSpi"/>
                    <param name="key" type="Key"/>
                    <param name="params" type="AlgorithmParameterSpec"/>
                </params>
                <comment line="1022">
                    Determine keysize and check if it is within legal limits                    
                </comment>
                <scope line="1018"/>
                <scope line="1022"/>
                <scope line="1025"/>
            </method>
            <method name="checkCryptoPerm" type="void" line="1032">
                <params>
                    <param name="checkSpi" type="CipherSpi"/>
                    <param name="key" type="Key"/>
                    <param name="params" type="AlgorithmParameters"/>
                </params>
                <comment line="1037">
                    Convert the specified parameters into specs and then delegate.                    
                </comment>
                <scope line="1033"/>
                <declaration name="pSpec" type="AlgorithmParameterSpec" line="1037"/>
                <scope line="1038"/>
                <scope line="1040"/>
            </method>
            <method name="passCryptoPermCheck" type="boolean" line="1049">
                <params>
                    <param name="checkSpi" type="CipherSpi"/>
                    <param name="key" type="Key"/>
                    <param name="params" type="AlgorithmParameterSpec"/>
                </params>
                <comment line="1053">
                    Use the &quot;algorithm&quot; component of the cipher
                     transformation so that the perm check would
                     work when the key has the &quot;aliased&quot; algo.                    
                </comment>
                <declaration name="em" type="String" line="1050"/>
                <declaration name="keySize" type="int" line="1051"/>
                <declaration name="algComponent" type="String" line="1055"/>
                <declaration name="index" type="int" line="1056"/>
                <scope line="1057"/>
                <scope line="1059"/>
                <declaration name="checkPerm" type="CryptoPermission" line="1062"/>
                <scope line="1065">
                    <scope line="1066"/>
                </scope>
                <scope line="1073"/>
                <scope line="1076">
                    <scope line="1077">
                        <scope line="1078"/>
                    </scope>
                </scope>
                <scope line="1083">
                    <scope line="1084"/>
                </scope>
            </method>
            <method name="checkOpmode" type="void" line="1096">
                <params>
                    <param name="opmode" type="int"/>
                </params>
                <scope line="1097"/>
            </method>
            <javadoc line="1102">
                Initializes this cipher with a key.
                  &lt;p&gt;The cipher is initialized for one of the following four operations:
                  encryption, decryption, key wrapping or key unwrapping, depending
                  on the value of &lt;code&gt;opmode&lt;/code&gt;.
                  &lt;p&gt;If this cipher requires any algorithm parameters that cannot be
                  derived from the given &lt;code&gt;key&lt;/code&gt;, the underlying cipher
                  implementation is supposed to generate the required parameters itself
                  (using provider-specific default or random values) if it is being
                  initialized for encryption or key wrapping, and raise an
                  &lt;code&gt;InvalidKeyException&lt;/code&gt; if it is being
                  initialized for decryption or key unwrapping.
                  The generated parameters can be retrieved using{@link #getParameters() getParameters} or{@link #getIV() getIV} (if the parameter is an IV).
                  &lt;p&gt;If this cipher requires algorithm parameters that cannot be
                  derived from the input parameters, and there are no reasonable
                  provider-specific default values, initialization will
                  necessarily fail.
                  &lt;p&gt;If this cipher (including its underlying feedback or padding scheme)
                  requires any random bytes (e.g., for parameter generation), it will get
                  them using the {@link SecureRandom &lt;code&gt;SecureRandom&lt;/code&gt;}implementation of the highest-priority
                  installed provider as the source of randomness.
                  (If none of the installed providers supply an implementation of
                  SecureRandom, a system-provided source of randomness will be used.)
                  &lt;p&gt;Note that when a Cipher object is initialized, it loses all
                  previously-acquired state. In other words, initializing a Cipher is
                  equivalent to creating a new instance of that Cipher and initializing
                  it.                
                <param>
                    opmode the operation mode of this cipher (this is one of
                      the following:
                      <code>ENCRYPT_MODE</code>, <code>DECRYPT_MODE</code>,
                      <code>WRAP_MODE</code> or <code>UNWRAP_MODE</code>)                    
                </param>
                <param>
                    key the key                    
                </param>
                <exception>
                    InvalidKeyException if the given key is inappropriate for
                      initializing this cipher, or requires
                      algorithm parameters that cannot be
                      determined from the given key, or if the given key has a keysize that
                      exceeds the maximum allowable keysize (as determined from the
                      configured jurisdiction policy files).                    
                </exception>
            </javadoc>
            <method name="init" type="void" line="1151">
                <params>
                    <param name="opmode" type="int"/>
                    <param name="key" type="Key"/>
                </params>
            </method>
            <javadoc line="1155">
                Initializes this cipher with a key and a source of randomness.
                  &lt;p&gt;The cipher is initialized for one of the following four operations:
                  encryption, decryption, key wrapping or  key unwrapping, depending
                  on the value of &lt;code&gt;opmode&lt;/code&gt;.
                  &lt;p&gt;If this cipher requires any algorithm parameters that cannot be
                  derived from the given &lt;code&gt;key&lt;/code&gt;, the underlying cipher
                  implementation is supposed to generate the required parameters itself
                  (using provider-specific default or random values) if it is being
                  initialized for encryption or key wrapping, and raise an
                  &lt;code&gt;InvalidKeyException&lt;/code&gt; if it is being
                  initialized for decryption or key unwrapping.
                  The generated parameters can be retrieved using{@link #getParameters() getParameters} or{@link #getIV() getIV} (if the parameter is an IV).
                  &lt;p&gt;If this cipher requires algorithm parameters that cannot be
                  derived from the input parameters, and there are no reasonable
                  provider-specific default values, initialization will
                  necessarily fail.
                  &lt;p&gt;If this cipher (including its underlying feedback or padding scheme)
                  requires any random bytes (e.g., for parameter generation), it will get
                  them from &lt;code&gt;random&lt;/code&gt;.
                  &lt;p&gt;Note that when a Cipher object is initialized, it loses all
                  previously-acquired state. In other words, initializing a Cipher is
                  equivalent to creating a new instance of that Cipher and initializing
                  it.                
                <param>
                    opmode the operation mode of this cipher (this is one of the
                      following:
                      <code>ENCRYPT_MODE</code>, <code>DECRYPT_MODE</code>,
                      <code>WRAP_MODE</code> or <code>UNWRAP_MODE</code>)                    
                </param>
                <param>
                    key the encryption key                    
                </param>
                <param>
                    random the source of randomness                    
                </param>
                <exception>
                    InvalidKeyException if the given key is inappropriate for
                      initializing this cipher, or requires
                      algorithm parameters that cannot be
                      determined from the given key, or if the given key has a keysize that
                      exceeds the maximum allowable keysize (as determined from the
                      configured jurisdiction policy files).                    
                </exception>
            </javadoc>
            <method name="init" type="void" line="1203">
                <params>
                    <param name="opmode" type="int"/>
                    <param name="key" type="Key"/>
                    <param name="random" type="SecureRandom"/>
                </params>
                <comment line="1215">
                    should never occur                    
                </comment>
                <scope line="1207"/>
                <scope line="1210">
                    <scope line="1211"/>
                    <scope line="1213"/>
                </scope>
            </method>
            <javadoc line="1223">
                Initializes this cipher with a key and a set of algorithm
                  parameters.
                  &lt;p&gt;The cipher is initialized for one of the following four operations:
                  encryption, decryption, key wrapping or  key unwrapping, depending
                  on the value of &lt;code&gt;opmode&lt;/code&gt;.
                  &lt;p&gt;If this cipher requires any algorithm parameters and
                  &lt;code&gt;params&lt;/code&gt; is null, the underlying cipher implementation is
                  supposed to generate the required parameters itself (using
                  provider-specific default or random values) if it is being
                  initialized for encryption or key wrapping, and raise an
                  &lt;code&gt;InvalidAlgorithmParameterException&lt;/code&gt; if it is being
                  initialized for decryption or key unwrapping.
                  The generated parameters can be retrieved using{@link #getParameters() getParameters} or{@link #getIV() getIV} (if the parameter is an IV).
                  &lt;p&gt;If this cipher requires algorithm parameters that cannot be
                  derived from the input parameters, and there are no reasonable
                  provider-specific default values, initialization will
                  necessarily fail.
                  &lt;p&gt;If this cipher (including its underlying feedback or padding scheme)
                  requires any random bytes (e.g., for parameter generation), it will get
                  them using the {@link SecureRandom &lt;code&gt;SecureRandom&lt;/code&gt;}implementation of the highest-priority
                  installed provider as the source of randomness.
                  (If none of the installed providers supply an implementation of
                  SecureRandom, a system-provided source of randomness will be used.)
                  &lt;p&gt;Note that when a Cipher object is initialized, it loses all
                  previously-acquired state. In other words, initializing a Cipher is
                  equivalent to creating a new instance of that Cipher and initializing
                  it.                
                <param>
                    opmode the operation mode of this cipher (this is one of the
                      following:
                      <code>ENCRYPT_MODE</code>, <code>DECRYPT_MODE</code>,
                      <code>WRAP_MODE</code> or <code>UNWRAP_MODE</code>)                    
                </param>
                <param>
                    key the encryption key                    
                </param>
                <param>
                    params the algorithm parameters                    
                </param>
                <exception>
                    InvalidKeyException if the given key is inappropriate for
                      initializing this cipher, or its keysize exceeds the maximum allowable
                      keysize (as determined from the configured jurisdiction policy files).                    
                </exception>
                <exception>
                    InvalidAlgorithmParameterException if the given algorithm
                      parameters are inappropriate for this cipher,
                      or this cipher requires
                      algorithm parameters and <code>params</code> is null, or the given
                      algorithm parameters imply a cryptographic strength that would exceed
                      the legal limits (as determined from the configured jurisdiction
                      policy files).                    
                </exception>
            </javadoc>
            <method name="init" type="void" line="1280">
                <params>
                    <param name="opmode" type="int"/>
                    <param name="key" type="Key"/>
                    <param name="params" type="AlgorithmParameterSpec"/>
                </params>
            </method>
            <javadoc line="1284">
                Initializes this cipher with a key, a set of algorithm
                  parameters, and a source of randomness.
                  &lt;p&gt;The cipher is initialized for one of the following four operations:
                  encryption, decryption, key wrapping or  key unwrapping, depending
                  on the value of &lt;code&gt;opmode&lt;/code&gt;.
                  &lt;p&gt;If this cipher requires any algorithm parameters and
                  &lt;code&gt;params&lt;/code&gt; is null, the underlying cipher implementation is
                  supposed to generate the required parameters itself (using
                  provider-specific default or random values) if it is being
                  initialized for encryption or key wrapping, and raise an
                  &lt;code&gt;InvalidAlgorithmParameterException&lt;/code&gt; if it is being
                  initialized for decryption or key unwrapping.
                  The generated parameters can be retrieved using{@link #getParameters() getParameters} or{@link #getIV() getIV} (if the parameter is an IV).
                  &lt;p&gt;If this cipher requires algorithm parameters that cannot be
                  derived from the input parameters, and there are no reasonable
                  provider-specific default values, initialization will
                  necessarily fail.
                  &lt;p&gt;If this cipher (including its underlying feedback or padding scheme)
                  requires any random bytes (e.g., for parameter generation), it will get
                  them from &lt;code&gt;random&lt;/code&gt;.
                  &lt;p&gt;Note that when a Cipher object is initialized, it loses all
                  previously-acquired state. In other words, initializing a Cipher is
                  equivalent to creating a new instance of that Cipher and initializing
                  it.                
                <param>
                    opmode the operation mode of this cipher (this is one of the
                      following:
                      <code>ENCRYPT_MODE</code>, <code>DECRYPT_MODE</code>,
                      <code>WRAP_MODE</code> or <code>UNWRAP_MODE</code>)                    
                </param>
                <param>
                    key the encryption key                    
                </param>
                <param>
                    params the algorithm parameters                    
                </param>
                <param>
                    random the source of randomness                    
                </param>
                <exception>
                    InvalidKeyException if the given key is inappropriate for
                      initializing this cipher, or its keysize exceeds the maximum allowable
                      keysize (as determined from the configured jurisdiction policy files).                    
                </exception>
                <exception>
                    InvalidAlgorithmParameterException if the given algorithm
                      parameters are inappropriate for this cipher,
                      or this cipher requires
                      algorithm parameters and <code>params</code> is null, or the given
                      algorithm parameters imply a cryptographic strength that would exceed
                      the legal limits (as determined from the configured jurisdiction
                      policy files).                    
                </exception>
            </javadoc>
            <method name="init" type="void" line="1339">
                <params>
                    <param name="opmode" type="int"/>
                    <param name="key" type="Key"/>
                    <param name="params" type="AlgorithmParameterSpec"/>
                    <param name="random" type="SecureRandom"/>
                </params>
                <scope line="1343"/>
                <scope line="1346"/>
            </method>
            <javadoc line="1354">
                Initializes this cipher with a key and a set of algorithm
                  parameters.
                  &lt;p&gt;The cipher is initialized for one of the following four operations:
                  encryption, decryption, key wrapping or  key unwrapping, depending
                  on the value of &lt;code&gt;opmode&lt;/code&gt;.
                  &lt;p&gt;If this cipher requires any algorithm parameters and
                  &lt;code&gt;params&lt;/code&gt; is null, the underlying cipher implementation is
                  supposed to generate the required parameters itself (using
                  provider-specific default or random values) if it is being
                  initialized for encryption or key wrapping, and raise an
                  &lt;code&gt;InvalidAlgorithmParameterException&lt;/code&gt; if it is being
                  initialized for decryption or key unwrapping.
                  The generated parameters can be retrieved using{@link #getParameters() getParameters} or{@link #getIV() getIV} (if the parameter is an IV).
                  &lt;p&gt;If this cipher requires algorithm parameters that cannot be
                  derived from the input parameters, and there are no reasonable
                  provider-specific default values, initialization will
                  necessarily fail.
                  &lt;p&gt;If this cipher (including its underlying feedback or padding scheme)
                  requires any random bytes (e.g., for parameter generation), it will get
                  them using the {@link SecureRandom &lt;code&gt;SecureRandom&lt;/code&gt;}implementation of the highest-priority
                  installed provider as the source of randomness.
                  (If none of the installed providers supply an implementation of
                  SecureRandom, a system-provided source of randomness will be used.)
                  &lt;p&gt;Note that when a Cipher object is initialized, it loses all
                  previously-acquired state. In other words, initializing a Cipher is
                  equivalent to creating a new instance of that Cipher and initializing
                  it.                
                <param>
                    opmode the operation mode of this cipher (this is one of the
                      following: <code>ENCRYPT_MODE</code>,
                      <code>DECRYPT_MODE</code>, <code>WRAP_MODE</code>
                      or <code>UNWRAP_MODE</code>)                    
                </param>
                <param>
                    key the encryption key                    
                </param>
                <param>
                    params the algorithm parameters                    
                </param>
                <exception>
                    InvalidKeyException if the given key is inappropriate for
                      initializing this cipher, or its keysize exceeds the maximum allowable
                      keysize (as determined from the configured jurisdiction policy files).                    
                </exception>
                <exception>
                    InvalidAlgorithmParameterException if the given algorithm
                      parameters are inappropriate for this cipher,
                      or this cipher requires
                      algorithm parameters and <code>params</code> is null, or the given
                      algorithm parameters imply a cryptographic strength that would exceed
                      the legal limits (as determined from the configured jurisdiction
                      policy files).                    
                </exception>
            </javadoc>
            <method name="init" type="void" line="1411">
                <params>
                    <param name="opmode" type="int"/>
                    <param name="key" type="Key"/>
                    <param name="params" type="AlgorithmParameters"/>
                </params>
            </method>
            <javadoc line="1415">
                Initializes this cipher with a key, a set of algorithm
                  parameters, and a source of randomness.
                  &lt;p&gt;The cipher is initialized for one of the following four operations:
                  encryption, decryption, key wrapping or  key unwrapping, depending
                  on the value of &lt;code&gt;opmode&lt;/code&gt;.
                  &lt;p&gt;If this cipher requires any algorithm parameters and
                  &lt;code&gt;params&lt;/code&gt; is null, the underlying cipher implementation is
                  supposed to generate the required parameters itself (using
                  provider-specific default or random values) if it is being
                  initialized for encryption or key wrapping, and raise an
                  &lt;code&gt;InvalidAlgorithmParameterException&lt;/code&gt; if it is being
                  initialized for decryption or key unwrapping.
                  The generated parameters can be retrieved using{@link #getParameters() getParameters} or{@link #getIV() getIV} (if the parameter is an IV).
                  &lt;p&gt;If this cipher requires algorithm parameters that cannot be
                  derived from the input parameters, and there are no reasonable
                  provider-specific default values, initialization will
                  necessarily fail.
                  &lt;p&gt;If this cipher (including its underlying feedback or padding scheme)
                  requires any random bytes (e.g., for parameter generation), it will get
                  them from &lt;code&gt;random&lt;/code&gt;.
                  &lt;p&gt;Note that when a Cipher object is initialized, it loses all
                  previously-acquired state. In other words, initializing a Cipher is
                  equivalent to creating a new instance of that Cipher and initializing
                  it.                
                <param>
                    opmode the operation mode of this cipher (this is one of the
                      following: <code>ENCRYPT_MODE</code>,
                      <code>DECRYPT_MODE</code>, <code>WRAP_MODE</code>
                      or <code>UNWRAP_MODE</code>)                    
                </param>
                <param>
                    key the encryption key                    
                </param>
                <param>
                    params the algorithm parameters                    
                </param>
                <param>
                    random the source of randomness                    
                </param>
                <exception>
                    InvalidKeyException if the given key is inappropriate for
                      initializing this cipher, or its keysize exceeds the maximum allowable
                      keysize (as determined from the configured jurisdiction policy files).                    
                </exception>
                <exception>
                    InvalidAlgorithmParameterException if the given algorithm
                      parameters are inappropriate for this cipher,
                      or this cipher requires
                      algorithm parameters and <code>params</code> is null, or the given
                      algorithm parameters imply a cryptographic strength that would exceed
                      the legal limits (as determined from the configured jurisdiction
                      policy files).                    
                </exception>
            </javadoc>
            <method name="init" type="void" line="1470">
                <params>
                    <param name="opmode" type="int"/>
                    <param name="key" type="Key"/>
                    <param name="params" type="AlgorithmParameters"/>
                    <param name="random" type="SecureRandom"/>
                </params>
                <scope line="1474"/>
                <scope line="1477"/>
            </method>
            <javadoc line="1485">
                Initializes this cipher with the public key from the given certificate.
                  &lt;p&gt; The cipher is initialized for one of the following four operations:
                  encryption, decryption, key wrapping or  key unwrapping, depending
                  on the value of &lt;code&gt;opmode&lt;/code&gt;.
                  &lt;p&gt;If the certificate is of type X.509 and has a &lt;i&gt;key usage&lt;/i&gt;
                  extension field marked as critical, and the value of the &lt;i&gt;key usage&lt;/i&gt;
                  extension field implies that the public key in
                  the certificate and its corresponding private key are not
                  supposed to be used for the operation represented by the value
                  of &lt;code&gt;opmode&lt;/code&gt;,
                  an &lt;code&gt;InvalidKeyException&lt;/code&gt;
                  is thrown.
                  &lt;p&gt; If this cipher requires any algorithm parameters that cannot be
                  derived from the public key in the given certificate, the underlying
                  cipher
                  implementation is supposed to generate the required parameters itself
                  (using provider-specific default or random values) if it is being
                  initialized for encryption or key wrapping, and raise an &lt;code&gt;
                  InvalidKeyException&lt;/code&gt; if it is being initialized for decryption or
                  key unwrapping.
                  The generated parameters can be retrieved using{@link #getParameters() getParameters} or{@link #getIV() getIV} (if the parameter is an IV).
                  &lt;p&gt;If this cipher requires algorithm parameters that cannot be
                  derived from the input parameters, and there are no reasonable
                  provider-specific default values, initialization will
                  necessarily fail.
                  &lt;p&gt;If this cipher (including its underlying feedback or padding scheme)
                  requires any random bytes (e.g., for parameter generation), it will get
                  them using the
                  &lt;code&gt;SecureRandom&lt;/code&gt;
                  implementation of the highest-priority
                  installed provider as the source of randomness.
                  (If none of the installed providers supply an implementation of
                  SecureRandom, a system-provided source of randomness will be used.)
                  &lt;p&gt;Note that when a Cipher object is initialized, it loses all
                  previously-acquired state. In other words, initializing a Cipher is
                  equivalent to creating a new instance of that Cipher and initializing
                  it.                
                <param>
                    opmode the operation mode of this cipher (this is one of the
                      following:
                      <code>ENCRYPT_MODE</code>, <code>DECRYPT_MODE</code>,
                      <code>WRAP_MODE</code> or <code>UNWRAP_MODE</code>)                    
                </param>
                <param>
                    certificate the certificate                    
                </param>
                <exception>
                    InvalidKeyException if the public key in the given
                      certificate is inappropriate for initializing this cipher, or this
                      cipher requires algorithm parameters that cannot be determined from the
                      public key in the given certificate, or the keysize of the public key
                      in the given certificate has a keysize that exceeds the maximum
                      allowable keysize (as determined by the configured jurisdiction policy
                      files).                    
                </exception>
            </javadoc>
            <method name="init" type="void" line="1547">
                <params>
                    <param name="opmode" type="int"/>
                    <param name="certificate" type="Certificate"/>
                </params>
            </method>
            <javadoc line="1551">
                Initializes this cipher with the public key from the given certificate
                  and
                  a source of randomness.
                  &lt;p&gt;The cipher is initialized for one of the following four operations:
                  encryption, decryption, key wrapping
                  or key unwrapping, depending on
                  the value of &lt;code&gt;opmode&lt;/code&gt;.
                  &lt;p&gt;If the certificate is of type X.509 and has a &lt;i&gt;key usage&lt;/i&gt;
                  extension field marked as critical, and the value of the &lt;i&gt;key usage&lt;/i&gt;
                  extension field implies that the public key in
                  the certificate and its corresponding private key are not
                  supposed to be used for the operation represented by the value of
                  &lt;code&gt;opmode&lt;/code&gt;,
                  an &lt;code&gt;InvalidKeyException&lt;/code&gt;
                  is thrown.
                  &lt;p&gt;If this cipher requires any algorithm parameters that cannot be
                  derived from the public key in the given &lt;code&gt;certificate&lt;/code&gt;,
                  the underlying cipher
                  implementation is supposed to generate the required parameters itself
                  (using provider-specific default or random values) if it is being
                  initialized for encryption or key wrapping, and raise an
                  &lt;code&gt;InvalidKeyException&lt;/code&gt; if it is being
                  initialized for decryption or key unwrapping.
                  The generated parameters can be retrieved using{@link #getParameters() getParameters} or{@link #getIV() getIV} (if the parameter is an IV).
                  &lt;p&gt;If this cipher requires algorithm parameters that cannot be
                  derived from the input parameters, and there are no reasonable
                  provider-specific default values, initialization will
                  necessarily fail.
                  &lt;p&gt;If this cipher (including its underlying feedback or padding scheme)
                  requires any random bytes (e.g., for parameter generation), it will get
                  them from &lt;code&gt;random&lt;/code&gt;.
                  &lt;p&gt;Note that when a Cipher object is initialized, it loses all
                  previously-acquired state. In other words, initializing a Cipher is
                  equivalent to creating a new instance of that Cipher and initializing
                  it.                
                <param>
                    opmode the operation mode of this cipher (this is one of the
                      following:
                      <code>ENCRYPT_MODE</code>, <code>DECRYPT_MODE</code>,
                      <code>WRAP_MODE</code> or <code>UNWRAP_MODE</code>)                    
                </param>
                <param>
                    certificate the certificate                    
                </param>
                <param>
                    random the source of randomness                    
                </param>
                <exception>
                    InvalidKeyException if the public key in the given
                      certificate is inappropriate for initializing this cipher, or this
                      cipher
                      requires algorithm parameters that cannot be determined from the
                      public key in the given certificate, or the keysize of the public key
                      in the given certificate has a keysize that exceeds the maximum
                      allowable keysize (as determined by the configured jurisdiction policy
                      files).                    
                </exception>
            </javadoc>
            <method name="init" type="void" line="1615">
                <params>
                    <param name="opmode" type="int"/>
                    <param name="certificate" type="Certificate"/>
                    <param name="random" type="SecureRandom"/>
                </params>
                <comment line="1620">
                    Check key usage if the certificate is of
                     type X.509.                    
                </comment>
                <comment line="1623">
                    Check whether the cert has a key usage extension
                     marked as a critical extension.                    
                </comment>
                <comment line="1631">
                    keyUsageInfo[2] is for keyEncipherment;
                     keyUsageInfo[3] is for dataEncipherment.                    
                </comment>
                <comment line="1655">
                    should never occur                    
                </comment>
                <scope line="1621">
                    <declaration name="cert" type="X509Certificate" line="1624"/>
                    <declaration name="critSet" type="Set" line="1625"/>
                    <scope line="1628">
                        <declaration name="keyUsageInfo" type="boolean[]" line="1629"/>
                        <scope line="1638"/>
                    </scope>
                </scope>
                <declaration name="publicKey" type="PublicKey" line="1644"/>
                <scope line="1647"/>
                <scope line="1650">
                    <scope line="1651"/>
                    <scope line="1653"/>
                </scope>
            </method>
            <javadoc line="1663">
                Ensures that Cipher is in a valid state for update() and doFinal()
                  calls - should be initialized and in ENCRYPT_MODE or DECRYPT_MODE.                
                <throws>
                    IllegalStateException if Cipher object is not in valid state.                    
                </throws>
            </javadoc>
            <method name="checkCipherState" type="void" line="1668">
                <scope line="1669">
                    <scope line="1670"/>
                    <scope line="1674"/>
                </scope>
            </method>
            <javadoc line="1681">
                Continues a multiple-part encryption or decryption operation
                  (depending on how this cipher was initialized), processing another data
                  part.
                  &lt;p&gt;The bytes in the &lt;code&gt;input&lt;/code&gt; buffer are processed, and the
                  result is stored in a new buffer.
                  &lt;p&gt;If &lt;code&gt;input&lt;/code&gt; has a length of zero, this method returns
                  &lt;code&gt;null&lt;/code&gt;.                
                <param>
                    input the input buffer                    
                </param>
                <return>
                    the new buffer with the result, or null if the underlying
                      cipher is a block cipher and the input data is too short to result in a
                      new block.                    
                </return>
                <exception>
                    IllegalStateException if this cipher is in a wrong state
                      (e.g., has not been initialized)                    
                </exception>
            </javadoc>
            <method name="update" type="byte[]" line="1701">
                <params>
                    <param name="input" type="byte[]"/>
                </params>
                <comment line="1705">
                    Input sanity check                    
                </comment>
                <scope line="1705"/>
                <scope line="1710"/>
            </method>
            <javadoc line="1716">
                Continues a multiple-part encryption or decryption operation
                  (depending on how this cipher was initialized), processing another data
                  part.
                  &lt;p&gt;The first &lt;code&gt;inputLen&lt;/code&gt; bytes in the &lt;code&gt;input&lt;/code&gt;
                  buffer, starting at &lt;code&gt;inputOffset&lt;/code&gt; inclusive, are processed,
                  and the result is stored in a new buffer.
                  &lt;p&gt;If &lt;code&gt;inputLen&lt;/code&gt; is zero, this method returns
                  &lt;code&gt;null&lt;/code&gt;.                
                <param>
                    input the input buffer                    
                </param>
                <param>
                    inputOffset the offset in <code>input</code> where the input
                      starts                    
                </param>
                <param>
                    inputLen the input length                    
                </param>
                <return>
                    the new buffer with the result, or null if the underlying
                      cipher is a block cipher and the input data is too short to result in a
                      new block.                    
                </return>
                <exception>
                    IllegalStateException if this cipher is in a wrong state
                      (e.g., has not been initialized)                    
                </exception>
            </javadoc>
            <method name="update" type="byte[]" line="1740">
                <params>
                    <param name="input" type="byte[]"/>
                    <param name="inputOffset" type="int"/>
                    <param name="inputLen" type="int"/>
                </params>
                <comment line="1744">
                    Input sanity check                    
                </comment>
                <scope line="1745"/>
                <scope line="1750"/>
            </method>
            <javadoc line="1756">
                Continues a multiple-part encryption or decryption operation
                  (depending on how this cipher was initialized), processing another data
                  part.
                  &lt;p&gt;The first &lt;code&gt;inputLen&lt;/code&gt; bytes in the &lt;code&gt;input&lt;/code&gt;
                  buffer, starting at &lt;code&gt;inputOffset&lt;/code&gt; inclusive, are processed,
                  and the result is stored in the &lt;code&gt;output&lt;/code&gt; buffer.
                  &lt;p&gt;If the &lt;code&gt;output&lt;/code&gt; buffer is too small to hold the result,
                  a &lt;code&gt;ShortBufferException&lt;/code&gt; is thrown. In this case, repeat this
                  call with a larger output buffer. Use{@link #getOutputSize(int) getOutputSize} to determine how big
                  the output buffer should be.
                  &lt;p&gt;If &lt;code&gt;inputLen&lt;/code&gt; is zero, this method returns
                  a length of zero.
                  &lt;p&gt;Note: this method should be copy-safe, which means the
                  &lt;code&gt;input&lt;/code&gt; and &lt;code&gt;output&lt;/code&gt; buffers can reference
                  the same byte array and no unprocessed input data is overwritten
                  when the result is copied into the output buffer.                
                <param>
                    input the input buffer                    
                </param>
                <param>
                    inputOffset the offset in <code>input</code> where the input
                      starts                    
                </param>
                <param>
                    inputLen the input length                    
                </param>
                <param>
                    output the buffer for the result                    
                </param>
                <return>
                    the number of bytes stored in <code>output</code>                    
                </return>
                <exception>
                    IllegalStateException if this cipher is in a wrong state
                      (e.g., has not been initialized)                    
                </exception>
                <exception>
                    ShortBufferException if the given output buffer is too small
                      to hold the result                    
                </exception>
            </javadoc>
            <method name="update" type="int" line="1794">
                <params>
                    <param name="input" type="byte[]"/>
                    <param name="inputOffset" type="int"/>
                    <param name="inputLen" type="int"/>
                    <param name="output" type="byte[]"/>
                </params>
                <comment line="1798">
                    Input sanity check                    
                </comment>
                <scope line="1799"/>
                <scope line="1804"/>
            </method>
            <javadoc line="1811">
                Continues a multiple-part encryption or decryption operation
                  (depending on how this cipher was initialized), processing another data
                  part.
                  &lt;p&gt;The first &lt;code&gt;inputLen&lt;/code&gt; bytes in the &lt;code&gt;input&lt;/code&gt;
                  buffer, starting at &lt;code&gt;inputOffset&lt;/code&gt; inclusive, are processed,
                  and the result is stored in the &lt;code&gt;output&lt;/code&gt; buffer, starting at
                  &lt;code&gt;outputOffset&lt;/code&gt; inclusive.
                  &lt;p&gt;If the &lt;code&gt;output&lt;/code&gt; buffer is too small to hold the result,
                  a &lt;code&gt;ShortBufferException&lt;/code&gt; is thrown. In this case, repeat this
                  call with a larger output buffer. Use{@link #getOutputSize(int) getOutputSize} to determine how big
                  the output buffer should be.
                  &lt;p&gt;If &lt;code&gt;inputLen&lt;/code&gt; is zero, this method returns
                  a length of zero.
                  &lt;p&gt;Note: this method should be copy-safe, which means the
                  &lt;code&gt;input&lt;/code&gt; and &lt;code&gt;output&lt;/code&gt; buffers can reference
                  the same byte array and no unprocessed input data is overwritten
                  when the result is copied into the output buffer.                
                <param>
                    input the input buffer                    
                </param>
                <param>
                    inputOffset the offset in <code>input</code> where the input
                      starts                    
                </param>
                <param>
                    inputLen the input length                    
                </param>
                <param>
                    output the buffer for the result                    
                </param>
                <param>
                    outputOffset the offset in <code>output</code> where the result
                      is stored                    
                </param>
                <return>
                    the number of bytes stored in <code>output</code>                    
                </return>
                <exception>
                    IllegalStateException if this cipher is in a wrong state
                      (e.g., has not been initialized)                    
                </exception>
                <exception>
                    ShortBufferException if the given output buffer is too small
                      to hold the result                    
                </exception>
            </javadoc>
            <method name="update" type="int" line="1852">
                <params>
                    <param name="input" type="byte[]"/>
                    <param name="inputOffset" type="int"/>
                    <param name="inputLen" type="int"/>
                    <param name="output" type="byte[]"/>
                    <param name="outputOffset" type="int"/>
                </params>
                <comment line="1856">
                    Input sanity check                    
                </comment>
                <scope line="1858"/>
                <scope line="1863"/>
            </method>
            <javadoc line="1870">
                Continues a multiple-part encryption or decryption operation
                  (depending on how this cipher was initialized), processing another data
                  part.
                  &lt;p&gt;All &lt;code&gt;input.remaining()&lt;/code&gt; bytes starting at
                  &lt;code&gt;input.position()&lt;/code&gt; are processed. The result is stored
                  in the output buffer.
                  Upon return, the input buffer&apos;s position will be equal
                  to its limit; its limit will not have changed. The output buffer&apos;s
                  position will have advanced by n, where n is the value returned
                  by this method; the output buffer&apos;s limit will not have changed.
                  &lt;p&gt;If &lt;code&gt;output.remaining()&lt;/code&gt; bytes are insufficient to
                  hold the result, a &lt;code&gt;ShortBufferException&lt;/code&gt; is thrown.
                  In this case, repeat this call with a larger output buffer. Use{@link #getOutputSize(int) getOutputSize} to determine how big
                  the output buffer should be.
                  &lt;p&gt;Note: this method should be copy-safe, which means the
                  &lt;code&gt;input&lt;/code&gt; and &lt;code&gt;output&lt;/code&gt; buffers can reference
                  the same block of memory and no unprocessed input data is overwritten
                  when the result is copied into the output buffer.                
                <param>
                    input the input ByteBuffer                    
                </param>
                <param>
                    output the output ByteByffer                    
                </param>
                <return>
                    the number of bytes stored in <code>output</code>                    
                </return>
                <exception>
                    IllegalStateException if this cipher is in a wrong state
                      (e.g., has not been initialized)                    
                </exception>
                <exception>
                    IllegalArgumentException if input and output are the
                      same object                    
                </exception>
                <exception>
                    ReadOnlyBufferException if the output buffer is read-only                    
                </exception>
                <exception>
                    ShortBufferException if there is insufficient space in the
                      output buffer                    
                </exception>
                <since>
                    1.5                    
                </since>
            </javadoc>
            <method name="update" type="int" line="1909">
                <params>
                    <param name="input" type="ByteBuffer"/>
                    <param name="output" type="ByteBuffer"/>
                </params>
                <scope line="1912"/>
                <scope line="1915"/>
                <scope line="1919"/>
            </method>
            <javadoc line="1927">
                Finishes a multiple-part encryption or decryption operation, depending
                  on how this cipher was initialized.
                  &lt;p&gt;Input data that may have been buffered during a previous
                  &lt;code&gt;update&lt;/code&gt; operation is processed, with padding (if requested)
                  being applied.
                  If an AEAD mode such as GCM/CCM is being used, the authentication
                  tag is appended in the case of encryption, or verified in the
                  case of decryption.
                  The result is stored in a new buffer.
                  &lt;p&gt;Upon finishing, this method resets this cipher object to the state
                  it was in when previously initialized via a call to &lt;code&gt;init&lt;/code&gt;.
                  That is, the object is reset and available to encrypt or decrypt
                  (depending on the operation mode that was specified in the call to
                  &lt;code&gt;init&lt;/code&gt;) more data.
                  &lt;p&gt;Note: if any exception is thrown, this cipher object may need to
                  be reset before it can be used again.                
                <return>
                    the new buffer with the result                    
                </return>
                <exception>
                    IllegalStateException if this cipher is in a wrong state
                      (e.g., has not been initialized)                    
                </exception>
                <exception>
                    IllegalBlockSizeException if this cipher is a block cipher,
                      no padding has been requested (only in encryption mode), and the total
                      input length of the data processed by this cipher is not a multiple of
                      block size; or if this encryption algorithm is unable to
                      process the input data provided.                    
                </exception>
                <exception>
                    BadPaddingException if this cipher is in decryption mode,
                      and (un)padding has been requested, but the decrypted data is not
                      bounded by the appropriate padding bytes                    
                </exception>
                <exception>
                    AEADBadTagException if this cipher is decrypting in an
                      AEAD mode (such as GCM/CCM), and the received authentication tag
                      does not match the calculated value                    
                </exception>
            </javadoc>
            <method name="doFinal" type="byte[]" line="1965"/>
            <javadoc line="1972">
                Finishes a multiple-part encryption or decryption operation, depending
                  on how this cipher was initialized.
                  &lt;p&gt;Input data that may have been buffered during a previous
                  &lt;code&gt;update&lt;/code&gt; operation is processed, with padding (if requested)
                  being applied.
                  If an AEAD mode such as GCM/CCM is being used, the authentication
                  tag is appended in the case of encryption, or verified in the
                  case of decryption.
                  The result is stored in the &lt;code&gt;output&lt;/code&gt; buffer, starting at
                  &lt;code&gt;outputOffset&lt;/code&gt; inclusive.
                  &lt;p&gt;If the &lt;code&gt;output&lt;/code&gt; buffer is too small to hold the result,
                  a &lt;code&gt;ShortBufferException&lt;/code&gt; is thrown. In this case, repeat this
                  call with a larger output buffer. Use{@link #getOutputSize(int) getOutputSize} to determine how big
                  the output buffer should be.
                  &lt;p&gt;Upon finishing, this method resets this cipher object to the state
                  it was in when previously initialized via a call to &lt;code&gt;init&lt;/code&gt;.
                  That is, the object is reset and available to encrypt or decrypt
                  (depending on the operation mode that was specified in the call to
                  &lt;code&gt;init&lt;/code&gt;) more data.
                  &lt;p&gt;Note: if any exception is thrown, this cipher object may need to
                  be reset before it can be used again.                
                <param>
                    output the buffer for the result                    
                </param>
                <param>
                    outputOffset the offset in <code>output</code> where the result
                      is stored                    
                </param>
                <return>
                    the number of bytes stored in <code>output</code>                    
                </return>
                <exception>
                    IllegalStateException if this cipher is in a wrong state
                      (e.g., has not been initialized)                    
                </exception>
                <exception>
                    IllegalBlockSizeException if this cipher is a block cipher,
                      no padding has been requested (only in encryption mode), and the total
                      input length of the data processed by this cipher is not a multiple of
                      block size; or if this encryption algorithm is unable to
                      process the input data provided.                    
                </exception>
                <exception>
                    ShortBufferException if the given output buffer is too small
                      to hold the result                    
                </exception>
                <exception>
                    BadPaddingException if this cipher is in decryption mode,
                      and (un)padding has been requested, but the decrypted data is not
                      bounded by the appropriate padding bytes                    
                </exception>
                <exception>
                    AEADBadTagException if this cipher is decrypting in an
                      AEAD mode (such as GCM/CCM), and the received authentication tag
                      does not match the calculated value                    
                </exception>
            </javadoc>
            <method name="doFinal" type="int" line="2024">
                <params>
                    <param name="output" type="byte[]"/>
                    <param name="outputOffset" type="int"/>
                </params>
                <comment line="2028">
                    Input sanity check                    
                </comment>
                <scope line="2028"/>
            </method>
            <javadoc line="2036">
                Encrypts or decrypts data in a single-part operation, or finishes a
                  multiple-part operation. The data is encrypted or decrypted,
                  depending on how this cipher was initialized.
                  &lt;p&gt;The bytes in the &lt;code&gt;input&lt;/code&gt; buffer, and any input bytes that
                  may have been buffered during a previous &lt;code&gt;update&lt;/code&gt; operation,
                  are processed, with padding (if requested) being applied.
                  If an AEAD mode such as GCM/CCM is being used, the authentication
                  tag is appended in the case of encryption, or verified in the
                  case of decryption.
                  The result is stored in a new buffer.
                  &lt;p&gt;Upon finishing, this method resets this cipher object to the state
                  it was in when previously initialized via a call to &lt;code&gt;init&lt;/code&gt;.
                  That is, the object is reset and available to encrypt or decrypt
                  (depending on the operation mode that was specified in the call to
                  &lt;code&gt;init&lt;/code&gt;) more data.
                  &lt;p&gt;Note: if any exception is thrown, this cipher object may need to
                  be reset before it can be used again.                
                <param>
                    input the input buffer                    
                </param>
                <return>
                    the new buffer with the result                    
                </return>
                <exception>
                    IllegalStateException if this cipher is in a wrong state
                      (e.g., has not been initialized)                    
                </exception>
                <exception>
                    IllegalBlockSizeException if this cipher is a block cipher,
                      no padding has been requested (only in encryption mode), and the total
                      input length of the data processed by this cipher is not a multiple of
                      block size; or if this encryption algorithm is unable to
                      process the input data provided.                    
                </exception>
                <exception>
                    BadPaddingException if this cipher is in decryption mode,
                      and (un)padding has been requested, but the decrypted data is not
                      bounded by the appropriate padding bytes                    
                </exception>
                <exception>
                    AEADBadTagException if this cipher is decrypting in an
                      AEAD mode (such as GCM/CCM), and the received authentication tag
                      does not match the calculated value                    
                </exception>
            </javadoc>
            <method name="doFinal" type="byte[]" line="2077">
                <params>
                    <param name="input" type="byte[]"/>
                </params>
                <comment line="2081">
                    Input sanity check                    
                </comment>
                <scope line="2081"/>
            </method>
            <javadoc line="2089">
                Encrypts or decrypts data in a single-part operation, or finishes a
                  multiple-part operation. The data is encrypted or decrypted,
                  depending on how this cipher was initialized.
                  &lt;p&gt;The first &lt;code&gt;inputLen&lt;/code&gt; bytes in the &lt;code&gt;input&lt;/code&gt;
                  buffer, starting at &lt;code&gt;inputOffset&lt;/code&gt; inclusive, and any input
                  bytes that may have been buffered during a previous &lt;code&gt;update&lt;/code&gt;
                  operation, are processed, with padding (if requested) being applied.
                  If an AEAD mode such as GCM/CCM is being used, the authentication
                  tag is appended in the case of encryption, or verified in the
                  case of decryption.
                  The result is stored in a new buffer.
                  &lt;p&gt;Upon finishing, this method resets this cipher object to the state
                  it was in when previously initialized via a call to &lt;code&gt;init&lt;/code&gt;.
                  That is, the object is reset and available to encrypt or decrypt
                  (depending on the operation mode that was specified in the call to
                  &lt;code&gt;init&lt;/code&gt;) more data.
                  &lt;p&gt;Note: if any exception is thrown, this cipher object may need to
                  be reset before it can be used again.                
                <param>
                    input the input buffer                    
                </param>
                <param>
                    inputOffset the offset in <code>input</code> where the input
                      starts                    
                </param>
                <param>
                    inputLen the input length                    
                </param>
                <return>
                    the new buffer with the result                    
                </return>
                <exception>
                    IllegalStateException if this cipher is in a wrong state
                      (e.g., has not been initialized)                    
                </exception>
                <exception>
                    IllegalBlockSizeException if this cipher is a block cipher,
                      no padding has been requested (only in encryption mode), and the total
                      input length of the data processed by this cipher is not a multiple of
                      block size; or if this encryption algorithm is unable to
                      process the input data provided.                    
                </exception>
                <exception>
                    BadPaddingException if this cipher is in decryption mode,
                      and (un)padding has been requested, but the decrypted data is not
                      bounded by the appropriate padding bytes                    
                </exception>
                <exception>
                    AEADBadTagException if this cipher is decrypting in an
                      AEAD mode (such as GCM/CCM), and the received authentication tag
                      does not match the calculated value                    
                </exception>
            </javadoc>
            <method name="doFinal" type="byte[]" line="2134">
                <params>
                    <param name="input" type="byte[]"/>
                    <param name="inputOffset" type="int"/>
                    <param name="inputLen" type="int"/>
                </params>
                <comment line="2138">
                    Input sanity check                    
                </comment>
                <scope line="2139"/>
            </method>
            <javadoc line="2147">
                Encrypts or decrypts data in a single-part operation, or finishes a
                  multiple-part operation. The data is encrypted or decrypted,
                  depending on how this cipher was initialized.
                  &lt;p&gt;The first &lt;code&gt;inputLen&lt;/code&gt; bytes in the &lt;code&gt;input&lt;/code&gt;
                  buffer, starting at &lt;code&gt;inputOffset&lt;/code&gt; inclusive, and any input
                  bytes that may have been buffered during a previous &lt;code&gt;update&lt;/code&gt;
                  operation, are processed, with padding (if requested) being applied.
                  If an AEAD mode such as GCM/CCM is being used, the authentication
                  tag is appended in the case of encryption, or verified in the
                  case of decryption.
                  The result is stored in the &lt;code&gt;output&lt;/code&gt; buffer.
                  &lt;p&gt;If the &lt;code&gt;output&lt;/code&gt; buffer is too small to hold the result,
                  a &lt;code&gt;ShortBufferException&lt;/code&gt; is thrown. In this case, repeat this
                  call with a larger output buffer. Use{@link #getOutputSize(int) getOutputSize} to determine how big
                  the output buffer should be.
                  &lt;p&gt;Upon finishing, this method resets this cipher object to the state
                  it was in when previously initialized via a call to &lt;code&gt;init&lt;/code&gt;.
                  That is, the object is reset and available to encrypt or decrypt
                  (depending on the operation mode that was specified in the call to
                  &lt;code&gt;init&lt;/code&gt;) more data.
                  &lt;p&gt;Note: if any exception is thrown, this cipher object may need to
                  be reset before it can be used again.
                  &lt;p&gt;Note: this method should be copy-safe, which means the
                  &lt;code&gt;input&lt;/code&gt; and &lt;code&gt;output&lt;/code&gt; buffers can reference
                  the same byte array and no unprocessed input data is overwritten
                  when the result is copied into the output buffer.                
                <param>
                    input the input buffer                    
                </param>
                <param>
                    inputOffset the offset in <code>input</code> where the input
                      starts                    
                </param>
                <param>
                    inputLen the input length                    
                </param>
                <param>
                    output the buffer for the result                    
                </param>
                <return>
                    the number of bytes stored in <code>output</code>                    
                </return>
                <exception>
                    IllegalStateException if this cipher is in a wrong state
                      (e.g., has not been initialized)                    
                </exception>
                <exception>
                    IllegalBlockSizeException if this cipher is a block cipher,
                      no padding has been requested (only in encryption mode), and the total
                      input length of the data processed by this cipher is not a multiple of
                      block size; or if this encryption algorithm is unable to
                      process the input data provided.                    
                </exception>
                <exception>
                    ShortBufferException if the given output buffer is too small
                      to hold the result                    
                </exception>
                <exception>
                    BadPaddingException if this cipher is in decryption mode,
                      and (un)padding has been requested, but the decrypted data is not
                      bounded by the appropriate padding bytes                    
                </exception>
                <exception>
                    AEADBadTagException if this cipher is decrypting in an
                      AEAD mode (such as GCM/CCM), and the received authentication tag
                      does not match the calculated value                    
                </exception>
            </javadoc>
            <method name="doFinal" type="int" line="2208">
                <params>
                    <param name="input" type="byte[]"/>
                    <param name="inputOffset" type="int"/>
                    <param name="inputLen" type="int"/>
                    <param name="output" type="byte[]"/>
                </params>
                <comment line="2212">
                    Input sanity check                    
                </comment>
                <scope line="2213"/>
            </method>
            <javadoc line="2222">
                Encrypts or decrypts data in a single-part operation, or finishes a
                  multiple-part operation. The data is encrypted or decrypted,
                  depending on how this cipher was initialized.
                  &lt;p&gt;The first &lt;code&gt;inputLen&lt;/code&gt; bytes in the &lt;code&gt;input&lt;/code&gt;
                  buffer, starting at &lt;code&gt;inputOffset&lt;/code&gt; inclusive, and any input
                  bytes that may have been buffered during a previous
                  &lt;code&gt;update&lt;/code&gt; operation, are processed, with padding
                  (if requested) being applied.
                  If an AEAD mode such as GCM/CCM is being used, the authentication
                  tag is appended in the case of encryption, or verified in the
                  case of decryption.
                  The result is stored in the &lt;code&gt;output&lt;/code&gt; buffer, starting at
                  &lt;code&gt;outputOffset&lt;/code&gt; inclusive.
                  &lt;p&gt;If the &lt;code&gt;output&lt;/code&gt; buffer is too small to hold the result,
                  a &lt;code&gt;ShortBufferException&lt;/code&gt; is thrown. In this case, repeat this
                  call with a larger output buffer. Use{@link #getOutputSize(int) getOutputSize} to determine how big
                  the output buffer should be.
                  &lt;p&gt;Upon finishing, this method resets this cipher object to the state
                  it was in when previously initialized via a call to &lt;code&gt;init&lt;/code&gt;.
                  That is, the object is reset and available to encrypt or decrypt
                  (depending on the operation mode that was specified in the call to
                  &lt;code&gt;init&lt;/code&gt;) more data.
                  &lt;p&gt;Note: if any exception is thrown, this cipher object may need to
                  be reset before it can be used again.
                  &lt;p&gt;Note: this method should be copy-safe, which means the
                  &lt;code&gt;input&lt;/code&gt; and &lt;code&gt;output&lt;/code&gt; buffers can reference
                  the same byte array and no unprocessed input data is overwritten
                  when the result is copied into the output buffer.                
                <param>
                    input the input buffer                    
                </param>
                <param>
                    inputOffset the offset in <code>input</code> where the input
                      starts                    
                </param>
                <param>
                    inputLen the input length                    
                </param>
                <param>
                    output the buffer for the result                    
                </param>
                <param>
                    outputOffset the offset in <code>output</code> where the result
                      is stored                    
                </param>
                <return>
                    the number of bytes stored in <code>output</code>                    
                </return>
                <exception>
                    IllegalStateException if this cipher is in a wrong state
                      (e.g., has not been initialized)                    
                </exception>
                <exception>
                    IllegalBlockSizeException if this cipher is a block cipher,
                      no padding has been requested (only in encryption mode), and the total
                      input length of the data processed by this cipher is not a multiple of
                      block size; or if this encryption algorithm is unable to
                      process the input data provided.                    
                </exception>
                <exception>
                    ShortBufferException if the given output buffer is too small
                      to hold the result                    
                </exception>
                <exception>
                    BadPaddingException if this cipher is in decryption mode,
                      and (un)padding has been requested, but the decrypted data is not
                      bounded by the appropriate padding bytes                    
                </exception>
                <exception>
                    AEADBadTagException if this cipher is decrypting in an
                      AEAD mode (such as GCM/CCM), and the received authentication tag
                      does not match the calculated value                    
                </exception>
            </javadoc>
            <method name="doFinal" type="int" line="2287">
                <params>
                    <param name="input" type="byte[]"/>
                    <param name="inputOffset" type="int"/>
                    <param name="inputLen" type="int"/>
                    <param name="output" type="byte[]"/>
                    <param name="outputOffset" type="int"/>
                </params>
                <comment line="2291">
                    Input sanity check                    
                </comment>
                <scope line="2293"/>
            </method>
            <javadoc line="2302">
                Encrypts or decrypts data in a single-part operation, or finishes a
                  multiple-part operation. The data is encrypted or decrypted,
                  depending on how this cipher was initialized.
                  &lt;p&gt;All &lt;code&gt;input.remaining()&lt;/code&gt; bytes starting at
                  &lt;code&gt;input.position()&lt;/code&gt; are processed.
                  If an AEAD mode such as GCM/CCM is being used, the authentication
                  tag is appended in the case of encryption, or verified in the
                  case of decryption.
                  The result is stored in the output buffer.
                  Upon return, the input buffer&apos;s position will be equal
                  to its limit; its limit will not have changed. The output buffer&apos;s
                  position will have advanced by n, where n is the value returned
                  by this method; the output buffer&apos;s limit will not have changed.
                  &lt;p&gt;If &lt;code&gt;output.remaining()&lt;/code&gt; bytes are insufficient to
                  hold the result, a &lt;code&gt;ShortBufferException&lt;/code&gt; is thrown.
                  In this case, repeat this call with a larger output buffer. Use{@link #getOutputSize(int) getOutputSize} to determine how big
                  the output buffer should be.
                  &lt;p&gt;Upon finishing, this method resets this cipher object to the state
                  it was in when previously initialized via a call to &lt;code&gt;init&lt;/code&gt;.
                  That is, the object is reset and available to encrypt or decrypt
                  (depending on the operation mode that was specified in the call to
                  &lt;code&gt;init&lt;/code&gt;) more data.
                  &lt;p&gt;Note: if any exception is thrown, this cipher object may need to
                  be reset before it can be used again.
                  &lt;p&gt;Note: this method should be copy-safe, which means the
                  &lt;code&gt;input&lt;/code&gt; and &lt;code&gt;output&lt;/code&gt; buffers can reference
                  the same byte array and no unprocessed input data is overwritten
                  when the result is copied into the output buffer.                
                <param>
                    input the input ByteBuffer                    
                </param>
                <param>
                    output the output ByteBuffer                    
                </param>
                <return>
                    the number of bytes stored in <code>output</code>                    
                </return>
                <exception>
                    IllegalStateException if this cipher is in a wrong state
                      (e.g., has not been initialized)                    
                </exception>
                <exception>
                    IllegalArgumentException if input and output are the
                      same object                    
                </exception>
                <exception>
                    ReadOnlyBufferException if the output buffer is read-only                    
                </exception>
                <exception>
                    IllegalBlockSizeException if this cipher is a block cipher,
                      no padding has been requested (only in encryption mode), and the total
                      input length of the data processed by this cipher is not a multiple of
                      block size; or if this encryption algorithm is unable to
                      process the input data provided.                    
                </exception>
                <exception>
                    ShortBufferException if there is insufficient space in the
                      output buffer                    
                </exception>
                <exception>
                    BadPaddingException if this cipher is in decryption mode,
                      and (un)padding has been requested, but the decrypted data is not
                      bounded by the appropriate padding bytes                    
                </exception>
                <exception>
                    AEADBadTagException if this cipher is decrypting in an
                      AEAD mode (such as GCM/CCM), and the received authentication tag
                      does not match the calculated value                    
                </exception>
                <since>
                    1.5                    
                </since>
            </javadoc>
            <method name="doFinal" type="int" line="2366">
                <params>
                    <param name="input" type="ByteBuffer"/>
                    <param name="output" type="ByteBuffer"/>
                </params>
                <scope line="2369"/>
                <scope line="2372"/>
                <scope line="2376"/>
            </method>
            <javadoc line="2384">
                Wrap a key.                
                <param>
                    key the key to be wrapped.                    
                </param>
                <return>
                    the wrapped key.                    
                </return>
                <exception>
                    IllegalStateException if this cipher is in a wrong
                      state (e.g., has not been initialized).                    
                </exception>
                <exception>
                    IllegalBlockSizeException if this cipher is a block
                      cipher, no padding has been requested, and the length of the
                      encoding of the key to be wrapped is not a
                      multiple of the block size.                    
                </exception>
                <exception>
                    InvalidKeyException if it is impossible or unsafe to
                      wrap the key with this cipher (e.g., a hardware protected key is
                      being passed to a software-only cipher).                    
                </exception>
            </javadoc>
            <method name="wrap" type="byte[]" line="2404">
                <params>
                    <param name="key" type="Key"/>
                </params>
                <scope line="2405">
                    <scope line="2406"/>
                    <scope line="2409"/>
                </scope>
            </method>
            <javadoc line="2419">
                Unwrap a previously wrapped key.                
                <param>
                    wrappedKey the key to be unwrapped.                    
                </param>
                <param>
                    wrappedKeyAlgorithm the algorithm associated with the wrapped
                      key.                    
                </param>
                <param>
                    wrappedKeyType the type of the wrapped key. This must be one of
                      <code>SECRET_KEY</code>, <code>PRIVATE_KEY</code>, or
                      <code>PUBLIC_KEY</code>.                    
                </param>
                <return>
                    the unwrapped key.                    
                </return>
                <exception>
                    IllegalStateException if this cipher is in a wrong state
                      (e.g., has not been initialized).                    
                </exception>
                <exception>
                    NoSuchAlgorithmException if no installed providers
                      can create keys of type <code>wrappedKeyType</code> for the
                      <code>wrappedKeyAlgorithm</code>.                    
                </exception>
                <exception>
                    InvalidKeyException if <code>wrappedKey</code> does not
                      represent a wrapped key of type <code>wrappedKeyType</code> for
                      the <code>wrappedKeyAlgorithm</code>.                    
                </exception>
            </javadoc>
            <method name="unwrap" type="Key" line="2447">
                <params>
                    <param name="wrappedKey" type="byte[]"/>
                    <param name="wrappedKeyAlgorithm" type="String"/>
                    <param name="wrappedKeyType" type="int"/>
                </params>
                <scope line="2449">
                    <scope line="2450"/>
                    <scope line="2453"/>
                </scope>
                <scope line="2460"/>
            </method>
            <method name="getAlgorithmParameterSpec" type="AlgorithmParameterSpec" line="2472">
                <params>
                    <param name="params" type="AlgorithmParameters"/>
                </params>
                <scope line="2473"/>
                <declaration name="alg" type="String" line="2477"/>
                <scope line="2479"/>
                <scope line="2483"/>
                <scope line="2487"/>
                <scope line="2491"/>
            </method>
            <method name="getConfiguredPermission" type="CryptoPermission" line="2499">
                <params>
                    <param name="transformation" type="String"/>
                </params>
                <declaration name="parts" type="String[]" line="2501"/>
            </method>
            <javadoc line="2505">
                Returns the maximum key length for the specified transformation
                  according to the installed JCE jurisdiction policy files. If
                  JCE unlimited strength jurisdiction policy files are installed,
                  Integer.MAX_VALUE will be returned.
                  For more information on default key size in JCE jurisdiction
                  policy files, please see Appendix E in the
                  &lt;a href=
                  &quot;{@docRoot}/../technotes/guides/security/crypto/CryptoSpec.html#AppC&quot;&gt;
                  Java Cryptography Architecture Reference Guide&lt;/a&gt;.                
                <param>
                    transformation the cipher transformation.                    
                </param>
                <return>
                    the maximum key length in bits or Integer.MAX_VALUE.                    
                </return>
                <exception>
                    NullPointerException if <code>transformation</code> is null.                    
                </exception>
                <exception>
                    NoSuchAlgorithmException if <code>transformation</code>
                      is not a valid transformation, i.e. in the form of "algorithm" or
                      "algorithm/mode/padding".                    
                </exception>
                <since>
                    1.5                    
                </since>
            </javadoc>
            <method name="getMaxAllowedKeyLength" type="int" line="2525">
                <params>
                    <param name="transformation" type="String"/>
                </params>
                <declaration name="cp" type="CryptoPermission" line="2526"/>
            </method>
            <javadoc line="2530">
                Returns an AlgorithmParameterSpec object which contains
                  the maximum cipher parameter value according to the
                  jurisdiction policy file. If JCE unlimited strength jurisdiction
                  policy files are installed or there is no maximum limit on the
                  parameters for the specified transformation in the policy file,
                  null will be returned.                
                <param>
                    transformation the cipher transformation.                    
                </param>
                <return>
                    an AlgorithmParameterSpec which holds the maximum
                      value or null.                    
                </return>
                <exception>
                    NullPointerException if <code>transformation</code>
                      is null.                    
                </exception>
                <exception>
                    NoSuchAlgorithmException if <code>transformation</code>
                      is not a valid transformation, i.e. in the form of "algorithm" or
                      "algorithm/mode/padding".                    
                </exception>
                <since>
                    1.5                    
                </since>
            </javadoc>
            <method name="getMaxAllowedParameterSpec" type="AlgorithmParameterSpec" line="2549">
                <params>
                    <param name="transformation" type="String"/>
                </params>
                <declaration name="cp" type="CryptoPermission" line="2550"/>
            </method>
            <javadoc line="2554">
                Continues a multi-part update of the Additional Authentication
                  Data (AAD).
                  &lt;p&gt;
                  Calls to this method provide AAD to the cipher when operating in
                  modes such as AEAD (GCM/CCM).  If this cipher is operating in
                  either GCM or CCM mode, all AAD must be supplied before beginning
                  operations on the ciphertext (via the {@code update} and {@codedoFinal} methods).                
                <param>
                    src the buffer containing the Additional Authentication Data                    
                </param>
                <throws>
                    IllegalArgumentException if the {@code src}byte array is null                    
                </throws>
                <throws>
                    IllegalStateException if this cipher is in a wrong state
                      (e.g., has not been initialized), does not accept AAD, or if
                      operating in either GCM or CCM mode and one of the {@code update}methods has already been called for the active
                      encryption/decryption operation                    
                </throws>
                <throws>
                    UnsupportedOperationException if the corresponding method
                      in the {@code CipherSpi} has not been overridden by an
                      implementation                    
                </throws>
                <since>
                    1.7                    
                </since>
            </javadoc>
            <method name="updateAAD" type="void" line="2579">
                <params>
                    <param name="src" type="byte[]"/>
                </params>
                <scope line="2580"/>
            </method>
            <javadoc line="2587">
                Continues a multi-part update of the Additional Authentication
                  Data (AAD), using a subset of the provided buffer.
                  &lt;p&gt;
                  Calls to this method provide AAD to the cipher when operating in
                  modes such as AEAD (GCM/CCM).  If this cipher is operating in
                  either GCM or CCM mode, all AAD must be supplied before beginning
                  operations on the ciphertext (via the {@code update} and {@codedoFinal} methods).                
                <param>
                    src the buffer containing the AAD                    
                </param>
                <param>
                    offset the offset in {@code src} where the AAD input starts                    
                </param>
                <param>
                    len the number of AAD bytes                    
                </param>
                <throws>
                    IllegalArgumentException if the {@code src}byte array is null, or the {@code offset} or {@code length}is less than 0, or the sum of the {@code offset} and{@code len} is greater than the length of the{@code src} byte array                    
                </throws>
                <throws>
                    IllegalStateException if this cipher is in a wrong state
                      (e.g., has not been initialized), does not accept AAD, or if
                      operating in either GCM or CCM mode and one of the {@code update}methods has already been called for the active
                      encryption/decryption operation                    
                </throws>
                <throws>
                    UnsupportedOperationException if the corresponding method
                      in the {@code CipherSpi} has not been overridden by an
                      implementation                    
                </throws>
                <since>
                    1.7                    
                </since>
            </javadoc>
            <method name="updateAAD" type="void" line="2617">
                <params>
                    <param name="src" type="byte[]"/>
                    <param name="offset" type="int"/>
                    <param name="len" type="int"/>
                </params>
                <comment line="2621">
                    Input sanity check                    
                </comment>
                <scope line="2622"/>
                <scope line="2627"/>
            </method>
            <javadoc line="2633">
                Continues a multi-part update of the Additional Authentication
                  Data (AAD).
                  &lt;p&gt;
                  Calls to this method provide AAD to the cipher when operating in
                  modes such as AEAD (GCM/CCM).  If this cipher is operating in
                  either GCM or CCM mode, all AAD must be supplied before beginning
                  operations on the ciphertext (via the {@code update} and {@codedoFinal} methods).
                  &lt;p&gt;
                  All {@code src.remaining()} bytes starting at{@code src.position()} are processed.
                  Upon return, the input buffer&apos;s position will be equal
                  to its limit; its limit will not have changed.                
                <param>
                    src the buffer containing the AAD                    
                </param>
                <throws>
                    IllegalArgumentException if the {@code src ByteBuffer}is null                    
                </throws>
                <throws>
                    IllegalStateException if this cipher is in a wrong state
                      (e.g., has not been initialized), does not accept AAD, or if
                      operating in either GCM or CCM mode and one of the {@code update}methods has already been called for the active
                      encryption/decryption operation                    
                </throws>
                <throws>
                    UnsupportedOperationException if the corresponding method
                      in the {@code CipherSpi} has not been overridden by an
                      implementation                    
                </throws>
                <since>
                    1.7                    
                </since>
            </javadoc>
            <method name="updateAAD" type="void" line="2663">
                <params>
                    <param name="src" type="ByteBuffer"/>
                </params>
                <comment line="2667">
                    Input sanity check                    
                </comment>
                <scope line="2667"/>
                <scope line="2672"/>
            </method>
        </class>
    </source>