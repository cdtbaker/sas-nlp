<?xml version="1.0" encoding="UTF-8"?>
    <source package="javax.crypto">
        <import package="java.io"/>
        <import package="java.security.AlgorithmParameters"/>
        <import package="java.security.Key"/>
        <import package="java.security.InvalidKeyException"/>
        <import package="java.security.InvalidAlgorithmParameterException"/>
        <import package="java.security.NoSuchAlgorithmException"/>
        <import package="java.security.NoSuchProviderException"/>
        <class name="SealedObject" line="36">
            <implements interface="Serializable"/>
            <javadoc line="36">
                This class enables a programmer to create an object and protect its
                  confidentiality with a cryptographic algorithm.
                  &lt;p&gt; Given any Serializable object, one can create a SealedObject
                  that encapsulates the original object, in serialized
                  format (i.e., a &quot;deep copy&quot;), and seals (encrypts) its serialized contents,
                  using a cryptographic algorithm such as DES, to protect its
                  confidentiality.  The encrypted content can later be decrypted (with
                  the corresponding algorithm using the correct decryption key) and
                  de-serialized, yielding the original object.
                  &lt;p&gt; Note that the Cipher object must be fully initialized with the
                  correct algorithm, key, padding scheme, etc., before being applied
                  to a SealedObject.
                  &lt;p&gt; The original object that was sealed can be recovered in two different
                  ways: &lt;p&gt;
                  &lt;ul&gt;
                  &lt;li&gt;by using the {@link #getObject(javax.crypto.Cipher) getObject}method that takes a &lt;code&gt;Cipher&lt;/code&gt; object.
                  &lt;p&gt; This method requires a fully initialized &lt;code&gt;Cipher&lt;/code&gt; object,
                  initialized with the
                  exact same algorithm, key, padding scheme, etc., that were used to seal the
                  object.
                  &lt;p&gt; This approach has the advantage that the party who unseals the
                  sealed object does not require knowledge of the decryption key. For example,
                  after one party has initialized the cipher object with the required
                  decryption key, it could hand over the cipher object to
                  another party who then unseals the sealed object.
                  &lt;p&gt;
                  &lt;li&gt;by using one of the{@link #getObject(java.security.Key) getObject} methods
                  that take a &lt;code&gt;Key&lt;/code&gt; object.
                  &lt;p&gt; In this approach, the &lt;code&gt;getObject&lt;/code&gt; method creates a cipher
                  object for the appropriate decryption algorithm and initializes it with the
                  given decryption key and the algorithm parameters (if any) that were stored
                  in the sealed object.
                  &lt;p&gt; This approach has the advantage that the party who
                  unseals the object does not need to keep track of the parameters (e.g., an
                  IV) that were used to seal the object.
                  &lt;/ul&gt;                
                <author>
                    Li Gong                    
                </author>
                <author>
                    Jan Luehe                    
                </author>
                <see>
                    Cipher                    
                </see>
                <since>
                    1.4                    
                </since>
            </javadoc>
            <declaration name="serialVersionUID" type="long" line="96"/>
            <declaration name="encryptedContent" type="byte[]" line="98"/>
            <javadoc line="98">
                The serialized object contents in encrypted format.                
                <serial>
                                        
                </serial>
            </javadoc>
            <declaration name="sealAlg" type="String" line="105"/>
            <javadoc line="105">
                The algorithm that was used to seal this object.                
                <serial>
                                        
                </serial>
            </javadoc>
            <declaration name="paramsAlg" type="String" line="112"/>
            <javadoc line="112">
                The algorithm of the parameters used.                
                <serial>
                                        
                </serial>
            </javadoc>
            <declaration name="encodedParams" type="byte[]" line="119"/>
            <javadoc line="119">
                The cryptographic parameters used by the sealing Cipher,
                  encoded in the default format.
                  &lt;p&gt;
                  That is, &lt;code&gt;cipher.getParameters().getEncoded()&lt;/code&gt;.                
                <serial>
                                        
                </serial>
            </javadoc>
            <javadoc line="129">
                Constructs a SealedObject from any Serializable object.
                  &lt;p&gt;The given object is serialized, and its serialized contents are
                  encrypted using the given Cipher, which must be fully initialized.
                  &lt;p&gt;Any algorithm parameters that may be used in the encryption
                  operation are stored inside of the new &lt;code&gt;SealedObject&lt;/code&gt;.                
                <param>
                    object the object to be sealed; can be null.                    
                </param>
                <param>
                    c the cipher used to seal the object.                    
                </param>
                <exception>
                    NullPointerException if the given cipher is null.                    
                </exception>
                <exception>
                    IOException if an error occurs during serialization                    
                </exception>
                <exception>
                    IllegalBlockSizeException if the given cipher is a block
                      cipher, no padding has been requested, and the total input length
                      (i.e., the length of the serialized object contents) is not a multiple
                      of the cipher's block size                    
                </exception>
            </javadoc>
            <method name="SealedObject" type="constructor" line="150">
                <params>
                    <param name="object" type="Serializable"/>
                    <param name="c" type="Cipher"/>
                </params>
                <comment line="152">
                    Serialize the object                    
                </comment>
                <comment line="156">
                    creating a stream pipe-line, from a to b                    
                </comment>
                <comment line="161">
                    write and flush the object content to byte array                    
                </comment>
                <comment line="169">
                    Seal the object                    
                </comment>
                <comment line="176">
                    if sealing is encryption only
                     Should never happen??                    
                </comment>
                <comment line="180">
                    Save the parameters                    
                </comment>
                <comment line="186">
                    Save the encryption algorithm                    
                </comment>
                <declaration name="b" type="ByteArrayOutputStream" line="156"/>
                <declaration name="a" type="ObjectOutput" line="157"/>
                <declaration name="content" type="byte[]" line="158"/>
                <scope line="159"/>
                <scope line="164"/>
                <scope line="171"/>
                <scope line="174"/>
                <scope line="180"/>
            </method>
            <javadoc line="189">
                Constructs a SealedObject object from the passed-in SealedObject.                
                <param>
                    so a SealedObject object                    
                </param>
                <exception>
                    NullPointerException if the given sealed object is null.                    
                </exception>
            </javadoc>
            <method name="SealedObject" type="constructor" line="195">
                <params>
                    <param name="so" type="SealedObject"/>
                </params>
                <scope line="199"/>
                <scope line="201"/>
            </method>
            <javadoc line="206">
                Returns the algorithm that was used to seal this object.                
                <return>
                    the algorithm that was used to seal this object.                    
                </return>
            </javadoc>
            <method name="getAlgorithm" type="String" line="211"/>
            <javadoc line="215">
                Retrieves the original (encapsulated) object.
                  &lt;p&gt;This method creates a cipher for the algorithm that had been used in
                  the sealing operation.
                  If the default provider package provides an implementation of that
                  algorithm, an instance of Cipher containing that implementation is used.
                  If the algorithm is not available in the default package, other
                  packages are searched.
                  The Cipher object is initialized for decryption, using the given
                  &lt;code&gt;key&lt;/code&gt; and the parameters (if any) that had been used in the
                  sealing operation.
                  &lt;p&gt;The encapsulated object is unsealed and de-serialized, before it is
                  returned.                
                <param>
                    key the key used to unseal the object.                    
                </param>
                <return>
                    the original object.                    
                </return>
                <exception>
                    IOException if an error occurs during de-serialiazation.                    
                </exception>
                <exception>
                    ClassNotFoundException if an error occurs during
                      de-serialiazation.                    
                </exception>
                <exception>
                    NoSuchAlgorithmException if the algorithm to unseal the
                      object is not available.                    
                </exception>
                <exception>
                    InvalidKeyException if the given key cannot be used to unseal
                      the object (e.g., it has the wrong algorithm).                    
                </exception>
                <exception>
                    NullPointerException if <code>key</code> is null.                    
                </exception>
            </javadoc>
            <method name="getObject" type="Object" line="247">
                <params>
                    <param name="key" type="Key"/>
                </params>
                <comment line="256">
                    we&apos;ve already caught NoSuchProviderException&apos;s and converted
                     them into NoSuchAlgorithmException&apos;s with details about
                     the failing algorithm                    
                </comment>
                <scope line="248"/>
                <scope line="252"/>
                <scope line="254"/>
                <scope line="259"/>
                <scope line="261"/>
            </method>
            <javadoc line="266">
                Retrieves the original (encapsulated) object.
                  &lt;p&gt;The encapsulated object is unsealed (using the given Cipher,
                  assuming that the Cipher is already properly initialized) and
                  de-serialized, before it is returned.                
                <param>
                    c the cipher used to unseal the object                    
                </param>
                <return>
                    the original object.                    
                </return>
                <exception>
                    NullPointerException if the given cipher is null.                    
                </exception>
                <exception>
                    IOException if an error occurs during de-serialiazation                    
                </exception>
                <exception>
                    ClassNotFoundException if an error occurs during
                      de-serialiazation                    
                </exception>
                <exception>
                    IllegalBlockSizeException if the given cipher is a block
                      cipher, no padding has been requested, and the total input length is
                      not a multiple of the cipher's block size                    
                </exception>
                <exception>
                    BadPaddingException if the given cipher has been
                      initialized for decryption, and padding has been specified, but
                      the input data does not have proper expected padding bytes                    
                </exception>
            </javadoc>
            <method name="getObject" type="Object" line="291">
                <params>
                    <param name="c" type="Cipher"/>
                </params>
                <comment line="293">
                    Unseal the object                    
                </comment>
                <comment line="298">
                    De-serialize it                    
                </comment>
                <comment line="301">
                    creating a stream pipe-line, from b to a                    
                </comment>
                <declaration name="content" type="byte[]" line="295"/>
                <declaration name="b" type="ByteArrayInputStream" line="301"/>
                <declaration name="a" type="ObjectInput" line="302"/>
                <scope line="303">
                    <declaration name="obj" type="Object" line="304"/>
                </scope>
                <scope line="306"/>
            </method>
            <javadoc line="311">
                Retrieves the original (encapsulated) object.
                  &lt;p&gt;This method creates a cipher for the algorithm that had been used in
                  the sealing operation, using an implementation of that algorithm from
                  the given &lt;code&gt;provider&lt;/code&gt;.
                  The Cipher object is initialized for decryption, using the given
                  &lt;code&gt;key&lt;/code&gt; and the parameters (if any) that had been used in the
                  sealing operation.
                  &lt;p&gt;The encapsulated object is unsealed and de-serialized, before it is
                  returned.                
                <param>
                    key the key used to unseal the object.                    
                </param>
                <param>
                    provider the name of the provider of the algorithm to unseal
                      the object.                    
                </param>
                <return>
                    the original object.                    
                </return>
                <exception>
                    IllegalArgumentException if the given provider is null
                      or empty.                    
                </exception>
                <exception>
                    IOException if an error occurs during de-serialiazation.                    
                </exception>
                <exception>
                    ClassNotFoundException if an error occurs during
                      de-serialiazation.                    
                </exception>
                <exception>
                    NoSuchAlgorithmException if the algorithm to unseal the
                      object is not available.                    
                </exception>
                <exception>
                    NoSuchProviderException if the given provider is not
                      configured.                    
                </exception>
                <exception>
                    InvalidKeyException if the given key cannot be used to unseal
                      the object (e.g., it has the wrong algorithm).                    
                </exception>
                <exception>
                    NullPointerException if <code>key</code> is null.                    
                </exception>
            </javadoc>
            <method name="getObject" type="Object" line="346">
                <params>
                    <param name="key" type="Key"/>
                    <param name="provider" type="String"/>
                </params>
                <scope line="347"/>
                <scope line="350"/>
                <scope line="354"/>
                <scope line="356"/>
                <scope line="358"/>
            </method>
            <method name="unseal" type="Object" line="368">
                <params>
                    <param name="key" type="Key"/>
                    <param name="provider" type="String"/>
                </params>
                <comment line="370">
                    Create the parameter object.                    
                </comment>
                <comment line="393">
                    Create and initialize the cipher.                    
                </comment>
                <comment line="420">
                    this should never happen, because we use the exact same
                     parameters that were used in the sealing operation                    
                </comment>
                <comment line="425">
                    Unseal the object                    
                </comment>
                <comment line="430">
                    De-serialize it                    
                </comment>
                <comment line="433">
                    creating a stream pipe-line, from b to a                    
                </comment>
                <declaration name="params" type="AlgorithmParameters" line="372"/>
                <scope line="373">
                    <scope line="374"/>
                    <scope line="381">
                        <scope line="382"/>
                        <scope line="385"/>
                    </scope>
                </scope>
                <declaration name="c" type="Cipher" line="395"/>
                <scope line="396"/>
                <scope line="401"/>
                <scope line="405">
                    <scope line="406"/>
                    <scope line="408"/>
                </scope>
                <scope line="413"/>
                <scope line="418"/>
                <declaration name="content" type="byte[]" line="427"/>
                <declaration name="b" type="ByteArrayInputStream" line="433"/>
                <declaration name="a" type="ObjectInput" line="434"/>
                <scope line="435">
                    <declaration name="obj" type="Object" line="436"/>
                </scope>
                <scope line="438"/>
            </method>
            <javadoc line="443">
                Restores the state of the SealedObject from a stream.                
                <param>
                    s the object input stream.                    
                </param>
                <exception>
                    NullPointerException if s is null.                    
                </exception>
            </javadoc>
            <method name="readObject" type="void" line="450">
                <params>
                    <param name="s" type="java.io.ObjectInputStream"/>
                </params>
            </method>
        </class>
        <class name="extObjectInputStream" line="459">
            <extends class="ObjectInputStream"/>
            <declaration name="systemClassLoader" type="ClassLoader" line="461"/>
            <method name="extObjectInputStream" type="constructor" line="464">
                <params>
                    <param name="in" type="InputStream"/>
                </params>
            </method>
            <method name="resolveClass" type="Class" line="470">
                <params>
                    <param name="v" type="ObjectStreamClass"/>
                </params>
                <comment line="474">
                    Calling the super.resolveClass() first
                     will let us pick up bug fixes in the super
                     class (e.g., 4171142).                    
                </comment>
                <comment line="481">
                    This is a workaround for bug 4224921.                    
                </comment>
                <scope line="472"/>
                <scope line="479">
                    <declaration name="loader" type="ClassLoader" line="483"/>
                    <scope line="484">
                        <scope line="485"/>
                        <scope line="489"/>
                    </scope>
                </scope>
            </method>
        </class>
    </source>