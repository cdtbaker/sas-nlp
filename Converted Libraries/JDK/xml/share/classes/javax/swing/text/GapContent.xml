<?xml version="1.0" encoding="UTF-8"?>
    <source package="javax.swing.text">
        <import package="java.util.Vector"/>
        <import package="java.io.IOException"/>
        <import package="java.io.ObjectInputStream"/>
        <import package="java.io.Serializable"/>
        <import package="javax.swing.undo.AbstractUndoableEdit"/>
        <import package="javax.swing.undo.CannotRedoException"/>
        <import package="javax.swing.undo.CannotUndoException"/>
        <import package="javax.swing.undo.UndoableEdit"/>
        <import package="javax.swing.SwingUtilities"/>
        <import package="java.lang.ref.WeakReference"/>
        <import package="java.lang.ref.ReferenceQueue"/>
        <class name="GapContent" line="13">
            <extends class="GapVector"/>
            <implements interface="AbstractDocument.Content"/>
            <implements interface="Serializable"/>
            <javadoc line="13">
                An implementation of the AbstractDocument.Content interface
                  implemented using a gapped buffer similar to that used by emacs.
                  The underlying storage is a array of unicode characters with
                  a gap somewhere.  The gap is moved to the location of changes
                  to take advantage of common behavior where most changes are
                  in the same location.  Changes that occur at a gap boundary are
                  generally cheap and moving the gap is generally cheaper than
                  moving the array contents directly to accomodate the change.
                  &lt;p&gt;
                  The positions tracking change are also generally cheap to
                  maintain.  The Position implementations (marks) store the array
                  index and can easily calculate the sequential position from
                  the current gap location.  Changes only require update to the
                  the marks between the old and new gap boundaries when the gap
                  is moved, so generally updating the marks is pretty cheap.
                  The marks are stored sorted so they can be located quickly
                  with a binary search.  This increases the cost of adding a
                  mark, and decreases the cost of keeping the mark updated.                
                <author>
                    Timothy Prinzing                    
                </author>
            </javadoc>
            <javadoc line="35">
                Creates a new GapContent object.  Initial size defaults to 10.                
            </javadoc>
            <method name="GapContent" type="constructor" line="38"/>
            <javadoc line="41">
                Creates a new GapContent object, with the initial
                  size specified.  The initial size will not be allowed
                  to go below 2, to give room for the implied break and
                  the gap.                
                <param>
                    initialLength the initial size                    
                </param>
            </javadoc>
            <method name="GapContent" type="constructor" line="48">
                <params>
                    <param name="initialLength" type="int"/>
                </params>
                <declaration name="implied" type="char[]" line="50"/>
            </method>
            <javadoc line="57">
                Allocate an array to store items of the type
                  appropriate (which is determined by the subclass).                
            </javadoc>
            <method name="allocateArray" type="Object" line="61">
                <params>
                    <param name="len" type="int"/>
                </params>
            </method>
            <javadoc line="64">
                Get the length of the allocated array.                
            </javadoc>
            <method name="getArrayLength" type="int" line="67">
                <declaration name="carray" type="char[]" line="68"/>
            </method>
            <javadoc line="71">
                Returns the length of the content.                
                <return>
                    the length &gt;= 1                    
                </return>
                <see>
                    AbstractDocument.Content#length                    
                </see>
            </javadoc>
            <method name="length" type="int" line="76">
                <declaration name="len" type="int" line="77"/>
            </method>
            <javadoc line="80">
                Inserts a string into the content.                
                <param>
                    where the starting position &gt;= 0, &lt; length()                    
                </param>
                <param>
                    str the non-null string to insert                    
                </param>
                <return>
                    an UndoableEdit object for undoing                    
                </return>
                <exception>
                    BadLocationException if the specified position is invalid                    
                </exception>
                <see>
                    AbstractDocument.Content#insertString                    
                </see>
            </javadoc>
            <method name="insertString" type="UndoableEdit" line="88">
                <params>
                    <param name="where" type="int"/>
                    <param name="str" type="String"/>
                </params>
                <scope line="89"/>
                <declaration name="chars" type="char[]" line="92"/>
            </method>
            <javadoc line="96">
                Removes part of the content.                
                <param>
                    where the starting position &gt;= 0, where + nitems &lt; length()                    
                </param>
                <param>
                    nitems the number of characters to remove &gt;= 0                    
                </param>
                <return>
                    an UndoableEdit object for undoing                    
                </return>
                <exception>
                    BadLocationException if the specified position is invalid                    
                </exception>
                <see>
                    AbstractDocument.Content#remove                    
                </see>
            </javadoc>
            <method name="remove" type="UndoableEdit" line="104">
                <params>
                    <param name="where" type="int"/>
                    <param name="nitems" type="int"/>
                </params>
                <scope line="105"/>
                <declaration name="removedString" type="String" line="108"/>
                <declaration name="edit" type="UndoableEdit" line="109"/>
            </method>
            <javadoc line="113">
                Retrieves a portion of the content.                
                <param>
                    where the starting position &gt;= 0                    
                </param>
                <param>
                    len the length to retrieve &gt;= 0                    
                </param>
                <return>
                    a string representing the content                    
                </return>
                <exception>
                    BadLocationException if the specified position is invalid                    
                </exception>
                <see>
                    AbstractDocument.Content#getString                    
                </see>
            </javadoc>
            <method name="getString" type="String" line="121">
                <params>
                    <param name="where" type="int"/>
                    <param name="len" type="int"/>
                </params>
                <declaration name="s" type="Segment" line="122"/>
            </method>
            <javadoc line="126">
                Retrieves a portion of the content.  If the desired content spans
                  the gap, we copy the content.  If the desired content does not
                  span the gap, the actual store is returned to avoid the copy since
                  it is contiguous.                
                <param>
                    where the starting position &gt;= 0, where + len &lt;= length()                    
                </param>
                <param>
                    len the number of characters to retrieve &gt;= 0                    
                </param>
                <param>
                    chars the Segment object to return the characters in                    
                </param>
                <exception>
                    BadLocationException if the specified position is invalid                    
                </exception>
                <see>
                    AbstractDocument.Content#getChars                    
                </see>
            </javadoc>
            <method name="getChars" type="void" line="137">
                <params>
                    <param name="where" type="int"/>
                    <param name="len" type="int"/>
                    <param name="chars" type="Segment"/>
                </params>
                <declaration name="end" type="int" line="138"/>
                <scope line="139"/>
                <scope line="142"/>
                <declaration name="g0" type="int" line="145"/>
                <declaration name="g1" type="int" line="146"/>
                <declaration name="array" type="char[]" line="147"/>
                <scope line="148"/>
                <scope line="152"/>
                <scope line="156">
                    <declaration name="before" type="int" line="157"/>
                    <scope line="158"/>
                </scope>
            </method>
            <javadoc line="171">
                Creates a position within the content that will
                  track change as the content is mutated.                
                <param>
                    offset the offset to track &gt;= 0                    
                </param>
                <return>
                    the position                    
                </return>
                <exception>
                    BadLocationException if the specified position is invalid                    
                </exception>
            </javadoc>
            <method name="createPosition" type="Position" line="178">
                <params>
                    <param name="offset" type="int"/>
                </params>
                <scope line="179"/>
                <scope line="182"/>
                <declaration name="g0" type="int" line="185"/>
                <declaration name="g1" type="int" line="186"/>
                <declaration name="index" type="int" line="187"/>
                <declaration name="sortIndex" type="int" line="189"/>
                <declaration name="m" type="MarkData" line="190"/>
                <declaration name="position" type="StickyPosition" line="191"/>
                <scope line="192"/>
                <scope line="194"/>
            </method>
            <class name="MarkData" line="202">
                <extends class="WeakReference">
                    <type_params>
                        <type_param name="StickyPosition"/>
                    </type_params>
                </extends>
                <javadoc line="202">
                    Holds the data for a mark... separately from
                      the real mark so that the real mark (Position
                      that the caller of createPosition holds) can be
                      collected if there are no more references to
                      it.  The update table holds only a reference
                      to this data.                    
                </javadoc>
                <method name="MarkData" type="constructor" line="211">
                    <params>
                        <param name="index" type="int"/>
                    </params>
                </method>
                <method name="MarkData" type="constructor" line="215">
                    <params>
                        <param name="index" type="int"/>
                        <param name="position" type="StickyPosition"/>
                        <param name="queue" type="ReferenceQueue&lt;? super StickyPosition&gt;"/>
                    </params>
                </method>
                <javadoc line="219">
                    Fetch the location in the contiguous sequence
                      being modeled.  The index in the gap array
                      is held by the mark, so it is adjusted according
                      to it&apos;s relationship to the gap.                    
                </javadoc>
                <method name="getOffset" type="int" line="225">
                    <declaration name="g0" type="int" line="226"/>
                    <declaration name="g1" type="int" line="227"/>
                    <declaration name="offs" type="int" line="228"/>
                </method>
                <method name="getPosition" type="StickyPosition" line="231"/>
                <declaration name="index" type="int" line="234"/>
            </class>
            <class name="StickyPosition" line="236">
                <implements interface="Position"/>
                <method name="StickyPosition" type="constructor" line="237"/>
                <method name="setMark" type="void" line="239">
                    <params>
                        <param name="mark" type="MarkData"/>
                    </params>
                </method>
                <method name="getOffset" type="int" line="242"/>
                <method name="toString" type="String" line="245"/>
                <declaration name="mark" type="MarkData" line="248"/>
            </class>
            <declaration name="empty" type="char[]" line="250"/>
            <declaration name="marks" type="MarkVector" line="251"/>
            <declaration name="search" type="MarkData" line="252"/>
            <javadoc line="252">
                Record used for searching for the place to
                  start updating mark indexs when the gap
                  boundaries are moved.                
            </javadoc>
            <declaration name="unusedMarks" type="int" line="258"/>
            <javadoc line="258">
                The number of unused mark entries                
            </javadoc>
            <declaration name="queue" type="ReferenceQueue&amp;lt;StickyPosition&amp;gt;" line="262"/>
            <declaration name="GROWTH_SIZE" type="int" line="263"/>
            <javadoc line="264">
                Make the gap bigger, moving any necessary data and updating
                  the appropriate marks                
            </javadoc>
            <method name="shiftEnd" type="void" line="268">
                <params>
                    <param name="newSize" type="int"/>
                </params>
                <declaration name="oldGapEnd" type="int" line="269"/>
                <declaration name="dg" type="int" line="271"/>
                <declaration name="adjustIndex" type="int" line="272"/>
                <declaration name="n" type="int" line="273"/>
                <scope line="274">
                    <declaration name="mark" type="MarkData" line="275"/>
                </scope>
            </method>
            <javadoc line="279">
                Overridden to make growth policy less agressive for large
                  text amount.                
            </javadoc>
            <method name="getNewArraySize" type="int" line="283">
                <params>
                    <param name="reqSize" type="int"/>
                </params>
                <scope line="284"/>
                <scope line="287"/>
            </method>
            <javadoc line="291">
                Move the start of the gap to a new location,
                  without changing the size of the gap.  This
                  moves the data in the array and updates the
                  marks accordingly.                
            </javadoc>
            <method name="shiftGap" type="void" line="297">
                <params>
                    <param name="newGapStart" type="int"/>
                </params>
                <declaration name="oldGapStart" type="int" line="298"/>
                <declaration name="dg" type="int" line="299"/>
                <declaration name="oldGapEnd" type="int" line="300"/>
                <declaration name="newGapEnd" type="int" line="301"/>
                <declaration name="gapSize" type="int" line="302"/>
                <scope line="304">
                    <declaration name="adjustIndex" type="int" line="305"/>
                    <declaration name="n" type="int" line="306"/>
                    <scope line="307">
                        <declaration name="mark" type="MarkData" line="308"/>
                        <scope line="309"/>
                    </scope>
                </scope>
                <scope line="315">
                    <declaration name="adjustIndex" type="int" line="316"/>
                    <declaration name="n" type="int" line="317"/>
                    <scope line="318">
                        <declaration name="mark" type="MarkData" line="319"/>
                        <scope line="320"/>
                    </scope>
                </scope>
            </method>
            <javadoc line="328">
                Resets all the marks that have an offset of 0 to have an index of
                  zero as well.                
            </javadoc>
            <method name="resetMarksAtZero" type="void" line="332">
                <scope line="333">
                    <declaration name="g1" type="int" line="334"/>
                    <scope line="335">
                        <declaration name="mark" type="MarkData" line="336"/>
                        <scope line="337"/>
                        <scope line="340"/>
                    </scope>
                </scope>
            </method>
            <javadoc line="346">
                Adjust the gap end downward.  This doesn&apos;t move
                  any data, but it does update any marks affected
                  by the boundary change.  All marks from the old
                  gap start down to the new gap start are squeezed
                  to the end of the gap (their location has been
                  removed).                
            </javadoc>
            <method name="shiftGapStartDown" type="void" line="354">
                <params>
                    <param name="newGapStart" type="int"/>
                </params>
                <declaration name="adjustIndex" type="int" line="355"/>
                <declaration name="n" type="int" line="356"/>
                <declaration name="g0" type="int" line="357"/>
                <declaration name="g1" type="int" line="358"/>
                <scope line="359">
                    <declaration name="mark" type="MarkData" line="360"/>
                    <scope line="361"/>
                </scope>
            </method>
            <javadoc line="369">
                Adjust the gap end upward.  This doesn&apos;t move
                  any data, but it does update any marks affected
                  by the boundary change. All marks from the old
                  gap end up to the new gap end are squeezed
                  to the end of the gap (their location has been
                  removed).                
            </javadoc>
            <method name="shiftGapEndUp" type="void" line="377">
                <params>
                    <param name="newGapEnd" type="int"/>
                </params>
                <declaration name="adjustIndex" type="int" line="378"/>
                <declaration name="n" type="int" line="379"/>
                <scope line="380">
                    <declaration name="mark" type="MarkData" line="381"/>
                    <scope line="382"/>
                </scope>
            </method>
            <javadoc line="390">
                Compares two marks.                
                <param>
                    o1 the first object                    
                </param>
                <param>
                    o2 the second object                    
                </param>
                <return>
                    &lt; 0 if o1 &lt; o2, 0 if the same, &gt; 0 if o1 &gt; o2                    
                </return>
            </javadoc>
            <method name="compare" type="int" line="396">
                <params>
                    <param name="o1" type="MarkData"/>
                    <param name="o2" type="MarkData"/>
                </params>
                <scope line="397"/>
                <scope line="400"/>
                <scope line="403"/>
            </method>
            <javadoc line="407">
                Finds the index to start mark adjustments given
                  some search index.                
            </javadoc>
            <method name="findMarkAdjustIndex" type="int" line="411">
                <params>
                    <param name="searchIndex" type="int"/>
                </params>
                <declaration name="index" type="int" line="413"/>
                <scope line="414">
                    <declaration name="d" type="MarkData" line="415"/>
                    <scope line="416"/>
                </scope>
            </method>
            <javadoc line="423">
                Finds the index of where to insert a new mark.                
                <param>
                    o the mark to insert                    
                </param>
                <return>
                    the index                    
                </return>
            </javadoc>
            <method name="findSortIndex" type="int" line="428">
                <params>
                    <param name="o" type="MarkData"/>
                </params>
                <declaration name="lower" type="int" line="429"/>
                <declaration name="upper" type="int" line="430"/>
                <declaration name="mid" type="int" line="431"/>
                <scope line="432"/>
                <declaration name="cmp" type="int" line="435"/>
                <declaration name="last" type="MarkData" line="436"/>
                <scope line="439">
                    <declaration name="entry" type="MarkData" line="441"/>
                    <scope line="443"/>
                    <scope line="446"/>
                    <scope line="449"/>
                </scope>
            </method>
            <javadoc line="455">
                Remove all unused marks out of the sorted collection
                  of marks.                
            </javadoc>
            <method name="removeUnusedMarks" type="void" line="459">
                <declaration name="n" type="int" line="460"/>
                <declaration name="cleaned" type="MarkVector" line="461"/>
                <scope line="462">
                    <declaration name="mark" type="MarkData" line="463"/>
                    <scope line="464"/>
                </scope>
            </method>
            <class name="MarkVector" line="471">
                <extends class="GapVector"/>
                <method name="MarkVector" type="constructor" line="472"/>
                <method name="MarkVector" type="constructor" line="475">
                    <params>
                        <param name="size" type="int"/>
                    </params>
                </method>
                <javadoc line="478">
                    Allocate an array to store items of the type
                      appropriate (which is determined by the subclass).                    
                </javadoc>
                <method name="allocateArray" type="Object" line="482">
                    <params>
                        <param name="len" type="int"/>
                    </params>
                </method>
                <javadoc line="485">
                    Get the length of the allocated array                    
                </javadoc>
                <method name="getArrayLength" type="int" line="488">
                    <declaration name="marks" type="MarkData[]" line="489"/>
                </method>
                <javadoc line="492">
                    Returns the number of marks currently held                    
                </javadoc>
                <method name="size" type="int" line="495">
                    <declaration name="len" type="int" line="496"/>
                </method>
                <javadoc line="499">
                    Inserts a mark into the vector                    
                </javadoc>
                <method name="insertElementAt" type="void" line="502">
                    <params>
                        <param name="m" type="MarkData"/>
                        <param name="index" type="int"/>
                    </params>
                </method>
                <javadoc line="506">
                    Add a mark to the end                    
                </javadoc>
                <method name="addElement" type="void" line="509">
                    <params>
                        <param name="m" type="MarkData"/>
                    </params>
                </method>
                <javadoc line="512">
                    Fetches the mark at the given index                    
                </javadoc>
                <method name="elementAt" type="MarkData" line="515">
                    <params>
                        <param name="index" type="int"/>
                    </params>
                    <declaration name="g0" type="int" line="516"/>
                    <declaration name="g1" type="int" line="517"/>
                    <declaration name="array" type="MarkData[]" line="518"/>
                    <scope line="519"/>
                    <scope line="522"/>
                </method>
                <javadoc line="527">
                    Replaces the elements in the specified range with the passed
                      in objects. This will NOT adjust the gap. The passed in indices
                      do not account for the gap, they are the same as would be used
                      int &lt;code&gt;elementAt&lt;/code&gt;.                    
                </javadoc>
                <method name="replaceRange" type="void" line="533">
                    <params>
                        <param name="start" type="int"/>
                        <param name="end" type="int"/>
                        <param name="marks" type="Object[]"/>
                    </params>
                    <declaration name="g0" type="int" line="534"/>
                    <declaration name="g1" type="int" line="535"/>
                    <declaration name="index" type="int" line="536"/>
                    <declaration name="newIndex" type="int" line="537"/>
                    <declaration name="array" type="Object[]" line="538"/>
                    <scope line="539"/>
                    <scope line="543">
                        <scope line="545"/>
                    </scope>
                    <scope line="550">
                        <scope line="551"/>
                    </scope>
                    <scope line="555"/>
                </method>
                <declaration name="oneMark" type="MarkData[]" line="559"/>
            </class>
            <method name="readObject" type="void" line="561">
                <params>
                    <param name="s" type="ObjectInputStream"/>
                </params>
            </method>
            <javadoc line="567">
                Returns a Vector containing instances of UndoPosRef for the
                  Positions in the range
                  &lt;code&gt;offset&lt;/code&gt; to &lt;code&gt;offset&lt;/code&gt; + &lt;code&gt;length&lt;/code&gt;.
                  If &lt;code&gt;v&lt;/code&gt; is not null the matching Positions are placed in
                  there. The vector with the resulting Positions are returned.                
                <param>
                    v the Vector to use, with a new one created on null                    
                </param>
                <param>
                    offset the starting offset &gt;= 0                    
                </param>
                <param>
                    length the length &gt;= 0                    
                </param>
                <return>
                    the set of instances                    
                </return>
            </javadoc>
            <method name="getPositionsInRange" type="Vector" line="578">
                <params>
                    <param name="v" type="Vector"/>
                    <param name="offset" type="int"/>
                    <param name="length" type="int"/>
                </params>
                <declaration name="endOffset" type="int" line="579"/>
                <declaration name="startIndex" type="int" line="580"/>
                <declaration name="endIndex" type="int" line="581"/>
                <declaration name="g0" type="int" line="582"/>
                <declaration name="g1" type="int" line="583"/>
                <scope line="584">
                    <scope line="585"/>
                    <scope line="588"/>
                    <scope line="591"/>
                    <scope line="594"/>
                </scope>
                <scope line="598"/>
                <declaration name="placeIn" type="Vector" line="602"/>
                <scope line="603"/>
            </method>
            <javadoc line="608">
                Resets the location for all the UndoPosRef instances
                  in &lt;code&gt;positions&lt;/code&gt;.
                  &lt;p&gt;
                  This is meant for internal usage, and is generally not of interest
                  to subclasses.                
                <param>
                    positions the UndoPosRef instances to reset                    
                </param>
            </javadoc>
            <method name="updateUndoPositions" type="void" line="616">
                <params>
                    <param name="positions" type="Vector"/>
                    <param name="offset" type="int"/>
                    <param name="length" type="int"/>
                </params>
                <declaration name="endOffset" type="int" line="617"/>
                <declaration name="g1" type="int" line="618"/>
                <declaration name="startIndex" type="int" line="619"/>
                <declaration name="endIndex" type="int" line="620"/>
                <scope line="621"/>
                <scope line="624"/>
                <scope line="627">
                    <declaration name="ref" type="UndoPosRef" line="628"/>
                </scope>
                <scope line="631">
                    <declaration name="sorted" type="Object[]" line="632"/>
                    <declaration name="addIndex" type="int" line="633"/>
                    <declaration name="counter" type="int" line="634"/>
                    <scope line="635">
                        <scope line="636">
                            <declaration name="mark" type="MarkData" line="637"/>
                            <scope line="638"/>
                        </scope>
                        <scope line="642">
                            <declaration name="mark" type="MarkData" line="643"/>
                            <scope line="644"/>
                        </scope>
                    </scope>
                    <scope line="649">
                        <scope line="650">
                            <declaration name="mark" type="MarkData" line="651"/>
                            <scope line="652"/>
                        </scope>
                        <scope line="656">
                            <declaration name="mark" type="MarkData" line="657"/>
                            <scope line="658"/>
                        </scope>
                    </scope>
                </scope>
            </method>
            <class name="UndoPosRef" line="666">
                <javadoc line="666">
                    Used to hold a reference to a Mark that is being reset as the
                      result of removing from the content.                    
                </javadoc>
                <method name="UndoPosRef" type="constructor" line="671">
                    <params>
                        <param name="rec" type="MarkData"/>
                    </params>
                </method>
                <javadoc line="675">
                    Resets the location of the Position to the offset when the
                      receiver was instantiated.                    
                    <param>
                        endOffset end location of inserted string.                        
                    </param>
                    <param>
                        g1 resulting end of gap.                        
                    </param>
                </javadoc>
                <method name="resetLocation" type="void" line="681">
                    <params>
                        <param name="endOffset" type="int"/>
                        <param name="g1" type="int"/>
                    </params>
                    <scope line="682"/>
                    <scope line="685"/>
                </method>
                <declaration name="undoLocation" type="int" line="689"/>
                <javadoc line="689">
                    Previous Offset of rec.                    
                </javadoc>
                <declaration name="rec" type="MarkData" line="693"/>
                <javadoc line="693">
                    Mark to reset offset.                    
                </javadoc>
            </class>
            <class name="InsertUndo" line="698">
                <extends class="AbstractUndoableEdit"/>
                <javadoc line="698">
                    UnoableEdit created for inserts.                    
                </javadoc>
                <method name="InsertUndo" type="constructor" line="702">
                    <params>
                        <param name="offset" type="int"/>
                        <param name="length" type="int"/>
                    </params>
                </method>
                <method name="undo" type="void" line="707">
                    <scope line="709"/>
                    <scope line="714"/>
                </method>
                <method name="redo" type="void" line="718">
                    <scope line="720">
                        <scope line="723"/>
                    </scope>
                    <scope line="728"/>
                </method>
                <declaration name="offset" type="int" line="732"/>
                <javadoc line="732">
                    Where string was inserted.                    
                </javadoc>
                <declaration name="length" type="int" line="736"/>
                <javadoc line="736">
                    Length of string inserted.                    
                </javadoc>
                <declaration name="string" type="String" line="740"/>
                <javadoc line="740">
                    The string that was inserted. This will only be valid after an
                      undo.                    
                </javadoc>
                <declaration name="posRefs" type="Vector" line="745"/>
                <javadoc line="745">
                    An array of instances of UndoPosRef for the Positions in the
                      range that was removed, valid after undo.                    
                </javadoc>
            </class>
            <class name="RemoveUndo" line="751">
                <extends class="AbstractUndoableEdit"/>
                <javadoc line="751">
                    UndoableEdit created for removes.                    
                </javadoc>
                <method name="RemoveUndo" type="constructor" line="755">
                    <params>
                        <param name="offset" type="int"/>
                        <param name="string" type="String"/>
                    </params>
                </method>
                <method name="undo" type="void" line="762">
                    <scope line="764">
                        <scope line="766"/>
                    </scope>
                    <scope line="772"/>
                </method>
                <method name="redo" type="void" line="776">
                    <scope line="778"/>
                    <scope line="783"/>
                </method>
                <declaration name="offset" type="int" line="787"/>
                <javadoc line="787">
                    Where the string was removed from.                    
                </javadoc>
                <declaration name="length" type="int" line="791"/>
                <javadoc line="791">
                    Length of string removed.                    
                </javadoc>
                <declaration name="string" type="String" line="795"/>
                <javadoc line="795">
                    The string that was removed. This is valid when redo is valid.                    
                </javadoc>
                <declaration name="posRefs" type="Vector" line="799"/>
                <javadoc line="799">
                    An array of instances of UndoPosRef for the Positions in the
                      range that was removed, valid before undo.                    
                </javadoc>
            </class>
        </class>
    </source>