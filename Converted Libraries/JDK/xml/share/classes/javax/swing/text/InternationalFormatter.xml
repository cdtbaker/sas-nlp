<?xml version="1.0" encoding="UTF-8"?>
    <source package="javax.swing.text">
        <import package="java.awt.event.ActionEvent"/>
        <import package="java.io"/>
        <import package="java.text"/>
        <import package="java.text.AttributedCharacterIterator.Attribute"/>
        <import package="java.util"/>
        <import package="javax.swing"/>
        <class name="InternationalFormatter" line="34">
            <extends class="DefaultFormatter"/>
            <comment line="115">
                &lt;code&gt;InternationalFormatter&lt;code&gt;&apos;s behavior is dicatated by a
                 &lt;code&gt;AttributedCharacterIterator&lt;code&gt; that is obtained from
                 the &lt;code&gt;Format&lt;code&gt;. On every edit, assuming
                 allows invalid is false, the &lt;code&gt;Format&lt;code&gt; instance is invoked
                 with &lt;code&gt;formatToCharacterIterator&lt;code&gt;. A &lt;code&gt;BitSet&lt;code&gt; is
                 also kept upto date with the non-literal characters, that is
                 for every index in the &lt;code&gt;AttributedCharacterIterator&lt;code&gt; an
                 entry in the bit set is updated based on the return value from
                 &lt;code&gt;isLiteral(Map)&lt;code&gt;. &lt;code&gt;isLiteral(int)&lt;code&gt; then uses
                 this cached information.
                 &lt;p&gt;
                 If allowsInvalid is false, every edit results in resetting the complete
                 text of the JTextComponent.
                 &lt;p&gt;
                 InternationalFormatterFilter can also provide two actions suitable for
                 incrementing and decrementing. To enable this a subclass must
                 override &lt;code&gt;getSupportsIncrement&lt;code&gt; to return true, and
                 override &lt;code&gt;adjustValue&lt;code&gt; to handle the changing of the
                 value. If you want to support changing the value outside of
                 the valid FieldPositions, you will need to override
                 &lt;code&gt;canIncrement&lt;code&gt;.                
            </comment>
            <javadoc line="34">
                &lt;code&gt;InternationalFormatter&lt;/code&gt; extends &lt;code&gt;DefaultFormatter&lt;/code&gt;,
                  using an instance of &lt;code&gt;java.text.Format&lt;/code&gt; to handle the
                  conversion to a String, and the conversion from a String.
                  &lt;p&gt;
                  If &lt;code&gt;getAllowsInvalid()&lt;/code&gt; is false, this will ask the
                  &lt;code&gt;Format&lt;/code&gt; to format the current text on every edit.
                  &lt;p&gt;
                  You can specify a minimum and maximum value by way of the
                  &lt;code&gt;setMinimum&lt;/code&gt; and &lt;code&gt;setMaximum&lt;/code&gt; methods. In order
                  for this to work the values returned from &lt;code&gt;stringToValue&lt;/code&gt; must be
                  comparable to the min/max values by way of the &lt;code&gt;Comparable&lt;/code&gt;
                  interface.
                  &lt;p&gt;
                  Be careful how you configure the &lt;code&gt;Format&lt;/code&gt; and the
                  &lt;code&gt;InternationalFormatter&lt;/code&gt;, as it is possible to create a
                  situation where certain values can not be input. Consider the date
                  format &apos;M/d/yy&apos;, an &lt;code&gt;InternationalFormatter&lt;/code&gt; that is always
                  valid (&lt;code&gt;setAllowsInvalid(false)&lt;/code&gt;), is in overwrite mode
                  (&lt;code&gt;setOverwriteMode(true)&lt;/code&gt;) and the date 7/1/99. In this
                  case the user will not be able to enter a two digit month or day of
                  month. To avoid this, the format should be &apos;MM/dd/yy&apos;.
                  &lt;p&gt;
                  If &lt;code&gt;InternationalFormatter&lt;/code&gt; is configured to only allow valid
                  values (&lt;code&gt;setAllowsInvalid(false)&lt;/code&gt;), every valid edit will result
                  in the text of the &lt;code&gt;JFormattedTextField&lt;/code&gt; being completely reset
                  from the &lt;code&gt;Format&lt;/code&gt;.
                  The cursor position will also be adjusted as literal characters are
                  added/removed from the resulting String.
                  &lt;p&gt;
                  &lt;code&gt;InternationalFormatter&lt;/code&gt;&apos;s behavior of
                  &lt;code&gt;stringToValue&lt;/code&gt; is  slightly different than that of
                  &lt;code&gt;DefaultTextFormatter&lt;/code&gt;, it does the following:
                  &lt;ol&gt;
                  &lt;li&gt;&lt;code&gt;parseObject&lt;/code&gt; is invoked on the &lt;code&gt;Format&lt;/code&gt;
                  specified by &lt;code&gt;setFormat&lt;/code&gt;
                  &lt;li&gt;If a Class has been set for the values (&lt;code&gt;setValueClass&lt;/code&gt;),
                  supers implementation is invoked to convert the value returned
                  from &lt;code&gt;parseObject&lt;/code&gt; to the appropriate class.
                  &lt;li&gt;If a &lt;code&gt;ParseException&lt;/code&gt; has not been thrown, and the value
                  is outside the min/max a &lt;code&gt;ParseException&lt;/code&gt; is thrown.
                  &lt;li&gt;The value is returned.
                  &lt;/ol&gt;
                  &lt;code&gt;InternationalFormatter&lt;/code&gt; implements &lt;code&gt;stringToValue&lt;/code&gt;
                  in this manner so that you can specify an alternate Class than
                  &lt;code&gt;Format&lt;/code&gt; may return.
                  &lt;p&gt;
                  &lt;strong&gt;Warning:&lt;/strong&gt;
                  Serialized objects of this class will not be compatible with
                  future Swing releases. The current serialization support is
                  appropriate for short term storage or RMI between applications running
                  the same version of Swing.  As of 1.4, support for long term storage
                  of all JavaBeans&lt;sup&gt;&lt;font size=&quot;-2&quot;&gt;TM&lt;/font&gt;&lt;/sup&gt;
                  has been added to the &lt;code&gt;java.beans&lt;/code&gt; package.
                  Please see {@link java.beans.XMLEncoder}.                
                <see>
                    java.text.Format                    
                </see>
                <see>
                    java.lang.Comparable                    
                </see>
                <since>
                    1.4                    
                </since>
            </javadoc>
            <declaration name="EMPTY_FIELD_ARRAY" type="Format.Field[]" line="96"/>
            <javadoc line="96">
                Used by &lt;code&gt;getFields&lt;/code&gt;.                
            </javadoc>
            <declaration name="format" type="Format" line="101"/>
            <javadoc line="101">
                Object used to handle the conversion.                
            </javadoc>
            <declaration name="max" type="Comparable" line="105"/>
            <javadoc line="105">
                Can be used to impose a maximum value.                
            </javadoc>
            <declaration name="min" type="Comparable" line="109"/>
            <javadoc line="109">
                Can be used to impose a minimum value.                
            </javadoc>
            <declaration name="literalMask" type="BitSet" line="137"/>
            <javadoc line="137">
                A bit is set for every index identified in the
                  AttributedCharacterIterator that is not considered decoration.
                  This should only be used if validMask is true.                
            </javadoc>
            <declaration name="iterator" type="AttributedCharacterIterator" line="143"/>
            <javadoc line="143">
                Used to iterate over characters.                
            </javadoc>
            <declaration name="validMask" type="boolean" line="147"/>
            <javadoc line="147">
                True if the Format was able to convert the value to a String and
                  back.                
            </javadoc>
            <declaration name="string" type="String" line="152"/>
            <javadoc line="152">
                Current value being displayed.                
            </javadoc>
            <declaration name="ignoreDocumentMutate" type="boolean" line="156"/>
            <javadoc line="156">
                If true, DocumentFilter methods are unconditionally allowed,
                  and no checking is done on their values. This is used when
                  incrementing/decrementing via the actions.                
            </javadoc>
            <javadoc line="164">
                Creates an &lt;code&gt;InternationalFormatter&lt;/code&gt; with no
                  &lt;code&gt;Format&lt;/code&gt; specified.                
            </javadoc>
            <method name="InternationalFormatter" type="constructor" line="168"/>
            <javadoc line="172">
                Creates an &lt;code&gt;InternationalFormatter&lt;/code&gt; with the specified
                  &lt;code&gt;Format&lt;/code&gt; instance.                
                <param>
                    format Format instance used for converting from/to Strings                    
                </param>
            </javadoc>
            <method name="InternationalFormatter" type="constructor" line="178">
                <params>
                    <param name="format" type="Format"/>
                </params>
            </method>
            <javadoc line="183">
                Sets the format that dictates the legal values that can be edited
                  and displayed.                
                <param>
                    format <code>Format</code> instance used for converting
                      from/to Strings                    
                </param>
            </javadoc>
            <method name="setFormat" type="void" line="190">
                <params>
                    <param name="format" type="Format"/>
                </params>
            </method>
            <javadoc line="194">
                Returns the format that dictates the legal values that can be edited
                  and displayed.                
                <return>
                    Format instance used for converting from/to Strings                    
                </return>
            </javadoc>
            <method name="getFormat" type="Format" line="200"/>
            <javadoc line="204">
                Sets the minimum permissible value. If the &lt;code&gt;valueClass&lt;/code&gt; has
                  not been specified, and &lt;code&gt;minimum&lt;/code&gt; is non null, the
                  &lt;code&gt;valueClass&lt;/code&gt; will be set to that of the class of
                  &lt;code&gt;minimum&lt;/code&gt;.                
                <param>
                    minimum Minimum legal value that can be input                    
                </param>
                <see>
                    #setValueClass                    
                </see>
            </javadoc>
            <method name="setMinimum" type="void" line="213">
                <params>
                    <param name="minimum" type="Comparable"/>
                </params>
                <scope line="214"/>
            </method>
            <javadoc line="220">
                Returns the minimum permissible value.                
                <return>
                    Minimum legal value that can be input                    
                </return>
            </javadoc>
            <method name="getMinimum" type="Comparable" line="225"/>
            <javadoc line="229">
                Sets the maximum permissible value. If the &lt;code&gt;valueClass&lt;/code&gt; has
                  not been specified, and &lt;code&gt;max&lt;/code&gt; is non null, the
                  &lt;code&gt;valueClass&lt;/code&gt; will be set to that of the class of
                  &lt;code&gt;max&lt;/code&gt;.                
                <param>
                    max Maximum legal value that can be input                    
                </param>
                <see>
                    #setValueClass                    
                </see>
            </javadoc>
            <method name="setMaximum" type="void" line="238">
                <params>
                    <param name="max" type="Comparable"/>
                </params>
                <scope line="239"/>
            </method>
            <javadoc line="245">
                Returns the maximum permissible value.                
                <return>
                    Maximum legal value that can be input                    
                </return>
            </javadoc>
            <method name="getMaximum" type="Comparable" line="250"/>
            <javadoc line="254">
                Installs the &lt;code&gt;DefaultFormatter&lt;/code&gt; onto a particular
                  &lt;code&gt;JFormattedTextField&lt;/code&gt;.
                  This will invoke &lt;code&gt;valueToString&lt;/code&gt; to convert the
                  current value from the &lt;code&gt;JFormattedTextField&lt;/code&gt; to
                  a String. This will then install the &lt;code&gt;Action&lt;/code&gt;s from
                  &lt;code&gt;getActions&lt;/code&gt;, the &lt;code&gt;DocumentFilter&lt;/code&gt;
                  returned from &lt;code&gt;getDocumentFilter&lt;/code&gt; and the
                  &lt;code&gt;NavigationFilter&lt;/code&gt; returned from
                  &lt;code&gt;getNavigationFilter&lt;/code&gt; onto the
                  &lt;code&gt;JFormattedTextField&lt;/code&gt;.
                  &lt;p&gt;
                  Subclasses will typically only need to override this if they
                  wish to install additional listeners on the
                  &lt;code&gt;JFormattedTextField&lt;/code&gt;.
                  &lt;p&gt;
                  If there is a &lt;code&gt;ParseException&lt;/code&gt; in converting the
                  current value to a String, this will set the text to an empty
                  String, and mark the &lt;code&gt;JFormattedTextField&lt;/code&gt; as being
                  in an invalid state.
                  &lt;p&gt;
                  While this is a public method, this is typically only useful
                  for subclassers of &lt;code&gt;JFormattedTextField&lt;/code&gt;.
                  &lt;code&gt;JFormattedTextField&lt;/code&gt; will invoke this method at
                  the appropriate times when the value changes, or its internal
                  state changes.                
                <param>
                    ftf JFormattedTextField to format for, may be null indicating
                      uninstall from current JFormattedTextField.                    
                </param>
            </javadoc>
            <method name="install" type="void" line="284">
                <params>
                    <param name="ftf" type="JFormattedTextField"/>
                </params>
                <comment line="287">
                    invoked again as the mask should now be valid.                    
                </comment>
            </method>
            <javadoc line="291">
                Returns a String representation of the Object &lt;code&gt;value&lt;/code&gt;.
                  This invokes &lt;code&gt;format&lt;/code&gt; on the current &lt;code&gt;Format&lt;/code&gt;.                
                <throws>
                    ParseException if there is an error in the conversion                    
                </throws>
                <param>
                    value Value to convert                    
                </param>
                <return>
                    String representation of value                    
                </return>
            </javadoc>
            <method name="valueToString" type="String" line="299">
                <params>
                    <param name="value" type="Object"/>
                </params>
                <scope line="300"/>
                <declaration name="f" type="Format" line="303"/>
                <scope line="305"/>
            </method>
            <javadoc line="311">
                Returns the &lt;code&gt;Object&lt;/code&gt; representation of the
                  &lt;code&gt;String&lt;/code&gt; &lt;code&gt;text&lt;/code&gt;.                
                <param>
                    text <code>String</code> to convert                    
                </param>
                <return>
                    <code>Object</code> representation of text                    
                </return>
                <throws>
                    ParseException if there is an error in the conversion                    
                </throws>
            </javadoc>
            <method name="stringToValue" type="Object" line="319">
                <params>
                    <param name="text" type="String"/>
                </params>
                <comment line="322">
                    Convert to the value class if the Value returned from the                    
                </comment>
                <comment line="323">
                    Format does not match.                    
                </comment>
                <declaration name="value" type="Object" line="320"/>
                <scope line="325"/>
                <scope line="328">
                    <scope line="329"/>
                </scope>
                <scope line="332"/>
            </method>
            <javadoc line="339">
                Returns the &lt;code&gt;Format.Field&lt;/code&gt; constants associated with
                  the text at &lt;code&gt;offset&lt;/code&gt;. If &lt;code&gt;offset&lt;/code&gt; is not
                  a valid location into the current text, this will return an
                  empty array.                
                <param>
                    offset offset into text to be examined                    
                </param>
                <return>
                    Format.Field constants associated with the text at the
                      given position.                    
                </return>
            </javadoc>
            <method name="getFields" type="Format.Field[]" line="349">
                <params>
                    <param name="offset" type="int"/>
                </params>
                <comment line="351">
                    This will work if the currently edited value is valid.                    
                </comment>
                <scope line="350"/>
                <declaration name="attrs" type="Map&lt;Attribute,Object&gt;" line="355"/>
                <scope line="357">
                    <declaration name="al" type="ArrayList&lt;Attribute&gt;" line="358"/>
                </scope>
            </method>
            <javadoc line="366">
                Creates a copy of the DefaultFormatter.                
                <return>
                    copy of the DefaultFormatter                    
                </return>
            </javadoc>
            <method name="clone" type="Object" line="371">
                <declaration name="formatter" type="InternationalFormatter" line="372"/>
            </method>
            <javadoc line="382">
                If &lt;code&gt;getSupportsIncrement&lt;/code&gt; returns true, this returns
                  two Actions suitable for incrementing/decrementing the value.                
            </javadoc>
            <method name="getActions" type="Action[]" line="386">
                <scope line="387"/>
            </method>
            <javadoc line="394">
                Invokes &lt;code&gt;parseObject&lt;/code&gt; on &lt;code&gt;f&lt;/code&gt;, returning
                  its value.                
            </javadoc>
            <method name="stringToValue" type="Object" line="398">
                <params>
                    <param name="text" type="String"/>
                    <param name="f" type="Format"/>
                </params>
                <scope line="399"/>
            </method>
            <javadoc line="405">
                Returns true if &lt;code&gt;value&lt;/code&gt; is between the min/max.                
                <param>
                    wantsCCE If false, and a ClassCastException is thrown in
                      comparing the values, the exception is consumed and
                      false is returned.                    
                </param>
            </javadoc>
            <method name="isValidValue" type="boolean" line="412">
                <params>
                    <param name="value" type="Object"/>
                    <param name="wantsCCE" type="boolean"/>
                </params>
                <declaration name="min" type="Comparable" line="413"/>
                <scope line="415">
                    <scope line="416"/>
                </scope>
                <scope line="419">
                    <scope line="420"/>
                </scope>
                <declaration name="max" type="Comparable" line="426"/>
                <scope line="427">
                    <scope line="428"/>
                </scope>
                <scope line="431">
                    <scope line="432"/>
                </scope>
            </method>
            <javadoc line="440">
                Returns a Set of the attribute identifiers at &lt;code&gt;index&lt;/code&gt;.                
            </javadoc>
            <method name="getAttributes" type="Map<Attribute,Object>" line="443">
                <params>
                    <param name="index" type="int"/>
                </params>
                <scope line="444">
                    <declaration name="iterator" type="AttributedCharacterIterator" line="445"/>
                    <scope line="447"/>
                </scope>
            </method>
            <javadoc line="456">
                Returns the start of the first run that contains the attribute
                  &lt;code&gt;id&lt;/code&gt;. This will return &lt;code&gt;-1&lt;/code&gt; if the attribute
                  can not be found.                
            </javadoc>
            <method name="getAttributeStart" type="int" line="461">
                <params>
                    <param name="id" type="AttributedCharacterIterator.Attribute"/>
                </params>
                <scope line="462">
                    <declaration name="iterator" type="AttributedCharacterIterator" line="463"/>
                    <scope line="466">
                        <scope line="467"/>
                    </scope>
                </scope>
            </method>
            <javadoc line="476">
                Returns the &lt;code&gt;AttributedCharacterIterator&lt;/code&gt; used to
                  format the last value.                
            </javadoc>
            <method name="getIterator" type="AttributedCharacterIterator" line="480"/>
            <javadoc line="484">
                Updates the AttributedCharacterIterator and bitset, if necessary.                
            </javadoc>
            <method name="updateMaskIfNecessary" type="void" line="487">
                <scope line="488">
                    <scope line="489"/>
                    <scope line="492">
                        <declaration name="newString" type="String" line="493"/>
                        <scope line="495"/>
                    </scope>
                </scope>
            </method>
            <javadoc line="502">
                Updates the AttributedCharacterIterator by invoking
                  &lt;code&gt;formatToCharacterIterator&lt;/code&gt; on the &lt;code&gt;Format&lt;/code&gt;.
                  If this is successful,
                  &lt;code&gt;updateMask(AttributedCharacterIterator)&lt;/code&gt;
                  is then invoked to update the internal bitmask.                
            </javadoc>
            <method name="updateMask" type="void" line="509">
                <scope line="510">
                    <declaration name="doc" type="Document" line="511"/>
                    <scope line="514">
                        <scope line="515"/>
                        <scope line="517"/>
                        <scope line="520">
                            <scope line="521">
                                <declaration name="value" type="Object" line="522"/>
                                <declaration name="iterator" type="AttributedCharacterIterator" line="523"/>
                            </scope>
                            <scope line="528"/>
                            <scope line="529"/>
                            <scope line="530"/>
                        </scope>
                    </scope>
                </scope>
            </method>
            <javadoc line="536">
                Returns the number of literal characters before &lt;code&gt;index&lt;/code&gt;.                
            </javadoc>
            <method name="getLiteralCountTo" type="int" line="539">
                <params>
                    <param name="index" type="int"/>
                </params>
                <declaration name="lCount" type="int" line="540"/>
                <scope line="542">
                    <scope line="543"/>
                </scope>
            </method>
            <javadoc line="550">
                Returns true if the character at index is a literal, that is
                  not editable.                
            </javadoc>
            <method name="isLiteral" type="boolean" line="554">
                <params>
                    <param name="index" type="int"/>
                </params>
                <scope line="555"/>
            </method>
            <javadoc line="561">
                Returns the literal character at index.                
            </javadoc>
            <method name="getLiteral" type="char" line="564">
                <params>
                    <param name="index" type="int"/>
                </params>
                <scope line="565"/>
            </method>
            <javadoc line="571">
                Returns true if the character at offset is navigatable too. This
                  is implemented in terms of &lt;code&gt;isLiteral&lt;/code&gt;, subclasses
                  may wish to provide different behavior.                
            </javadoc>
            <method name="isNavigatable" type="boolean" line="576">
                <params>
                    <param name="offset" type="int"/>
                </params>
            </method>
            <javadoc line="580">
                Overriden to update the mask after invoking supers implementation.                
            </javadoc>
            <method name="updateValue" type="void" line="583">
                <params>
                    <param name="value" type="Object"/>
                </params>
            </method>
            <javadoc line="588">
                Overriden to unconditionally allow the replace if
                  ignoreDocumentMutate is true.                
            </javadoc>
            <method name="replace" type="void" line="594">
                <params>
                    <param name="fb" type="DocumentFilter.FilterBypass"/>
                    <param name="offset" type="int"/>
                    <param name="length" type="int"/>
                    <param name="text" type="String"/>
                    <param name="attrs" type="AttributeSet"/>
                </params>
                <scope line="595"/>
            </method>
            <javadoc line="602">
                Returns the index of the next non-literal character starting at
                  index. If index is not a literal, it will be returned.                
                <param>
                    direction Amount to increment looking for non-literal                    
                </param>
            </javadoc>
            <method name="getNextNonliteralIndex" type="int" line="608">
                <params>
                    <param name="index" type="int"/>
                    <param name="direction" type="int"/>
                </params>
                <declaration name="max" type="int" line="609"/>
                <scope line="611">
                    <scope line="612"/>
                    <scope line="615"/>
                </scope>
            </method>
            <javadoc line="622">
                Overriden in an attempt to honor the literals.
                  &lt;p&gt;If we do not allow invalid values and are in overwrite mode, this{@code rh.length} is corrected as to preserve trailing literals.
                  If not in overwrite mode, and there is text to insert it is
                  inserted at the next non literal index going forward.  If there
                  is only text to remove, it is removed from the next non literal
                  index going backward.                
            </javadoc>
            <method name="canReplace" type="boolean" line="631">
                <params>
                    <param name="rh" type="ReplaceHolder"/>
                </params>
                <comment line="638">
                    Backspace, adjust to actually delete next non-literal.                    
                </comment>
                <comment line="659">
                    insert (or insert and remove)                    
                </comment>
                <comment line="663">
                    remove only                    
                </comment>
                <scope line="632">
                    <declaration name="text" type="String" line="633"/>
                    <declaration name="tl" type="int" line="634"/>
                    <declaration name="c" type="JTextComponent" line="635"/>
                    <scope line="637"/>
                    <scope line="640">
                        <declaration name="pos" type="int" line="641"/>
                        <declaration name="textPos" type="int" line="642"/>
                        <declaration name="overflown" type="boolean" line="643"/>
                        <scope line="645">
                            <scope line="647"/>
                        </scope>
                        <scope line="654"/>
                    </scope>
                    <scope line="658"/>
                    <scope line="662"/>
                </scope>
                <scope line="670"/>
                <declaration name="can" type="boolean" line="675"/>
                <scope line="676"/>
            </method>
            <javadoc line="682">
                When in !allowsInvalid mode the text is reset on every edit, thus
                  supers implementation will position the cursor at the wrong position.
                  As such, this invokes supers implementation and then invokes
                  &lt;code&gt;repositionCursor&lt;/code&gt; to correctly reset the cursor.                
            </javadoc>
            <method name="replace" type="boolean" line="688">
                <params>
                    <param name="rh" type="ReplaceHolder"/>
                </params>
                <comment line="700">
                    remove                    
                </comment>
                <declaration name="start" type="int" line="689"/>
                <declaration name="direction" type="int" line="690"/>
                <declaration name="literalCount" type="int" line="691"/>
                <scope line="695"/>
                <scope line="698">
                    <scope line="699"/>
                    <scope line="703"/>
                </scope>
                <scope line="708">
                    <scope line="709">
                        <declaration name="end" type="int" line="710"/>
                    </scope>
                    <scope line="715">
                        <scope line="717"/>
                    </scope>
                </scope>
            </method>
            <javadoc line="727">
                Repositions the cursor. &lt;code&gt;startLiteralCount&lt;/code&gt; gives
                  the number of literals to the start of the deleted range, end
                  gives the ending location to adjust from, direction gives
                  the direction relative to &lt;code&gt;end&lt;/code&gt; to position the
                  cursor from.                
            </javadoc>
            <method name="repositionCursor" type="void" line="735">
                <params>
                    <param name="startLiteralCount" type="int"/>
                    <param name="end" type="int"/>
                    <param name="direction" type="int"/>
                </params>
                <comment line="746">
                                        
                </comment>
                <declaration name="endLiteralCount" type="int" line="736"/>
                <scope line="738">
                    <scope line="740">
                        <scope line="741"/>
                    </scope>
                </scope>
            </method>
            <javadoc line="749">
                Returns the character from the mask that has been buffered
                  at &lt;code&gt;index&lt;/code&gt;.                
            </javadoc>
            <method name="getBufferedChar" type="char" line="753">
                <params>
                    <param name="index" type="int"/>
                </params>
                <scope line="754">
                    <scope line="755"/>
                </scope>
            </method>
            <javadoc line="762">
                Returns true if the current mask is valid.                
            </javadoc>
            <method name="isValidMask" type="boolean" line="765"/>
            <javadoc line="769">
                Returns true if &lt;code&gt;attributes&lt;/code&gt; is null or empty.                
            </javadoc>
            <method name="isLiteral" type="boolean" line="772">
                <params>
                    <param name="attributes" type="Map"/>
                </params>
            </method>
            <javadoc line="776">
                Updates the interal bitset from &lt;code&gt;iterator&lt;/code&gt;. This will
                  set &lt;code&gt;validMask&lt;/code&gt; to true if &lt;code&gt;iterator&lt;/code&gt; is
                  non-null.                
            </javadoc>
            <method name="updateMask" type="void" line="781">
                <params>
                    <param name="iterator" type="AttributedCharacterIterator"/>
                </params>
                <comment line="786">
                    Update the literal mask                    
                </comment>
                <scope line="782">
                    <scope line="787"/>
                    <scope line="790">
                        <scope line="792"/>
                    </scope>
                    <scope line="798">
                        <declaration name="attributes" type="Map" line="799"/>
                        <declaration name="set" type="boolean" line="800"/>
                        <declaration name="start" type="int" line="801"/>
                        <declaration name="end" type="int" line="802"/>
                        <scope line="804">
                            <scope line="805"/>
                            <scope line="808"/>
                        </scope>
                    </scope>
                </scope>
            </method>
            <javadoc line="818">
                Returns true if &lt;code&gt;field&lt;/code&gt; is non-null.
                  Subclasses that wish to allow incrementing to happen outside of
                  the known fields will need to override this.                
            </javadoc>
            <method name="canIncrement" type="boolean" line="823">
                <params>
                    <param name="field" type="Object"/>
                    <param name="cursorPosition" type="int"/>
                </params>
            </method>
            <javadoc line="827">
                Selects the fields identified by &lt;code&gt;attributes&lt;/code&gt;.                
            </javadoc>
            <method name="selectField" type="void" line="830">
                <params>
                    <param name="f" type="Object"/>
                    <param name="count" type="int"/>
                </params>
                <declaration name="iterator" type="AttributedCharacterIterator" line="831"/>
                <scope line="834">
                    <declaration name="field" type="AttributedCharacterIterator.Attribute" line="835"/>
                    <scope line="839">
                        <scope line="842">
                            <declaration name="limit" type="int" line="843"/>
                            <scope line="845"/>
                        </scope>
                    </scope>
                </scope>
            </method>
            <javadoc line="857">
                Returns the field that will be adjusted by adjustValue.                
            </javadoc>
            <method name="getAdjustField" type="Object" line="860">
                <params>
                    <param name="start" type="int"/>
                    <param name="attributes" type="Map"/>
                </params>
            </method>
            <javadoc line="864">
                Returns the number of occurences of &lt;code&gt;f&lt;/code&gt; before
                  the location &lt;code&gt;start&lt;/code&gt; in the current
                  &lt;code&gt;AttributedCharacterIterator&lt;/code&gt;.                
            </javadoc>
            <method name="getFieldTypeCountTo" type="int" line="869">
                <params>
                    <param name="f" type="Object"/>
                    <param name="start" type="int"/>
                </params>
                <declaration name="iterator" type="AttributedCharacterIterator" line="870"/>
                <declaration name="count" type="int" line="871"/>
                <scope line="874">
                    <declaration name="field" type="AttributedCharacterIterator.Attribute" line="875"/>
                    <scope line="879">
                        <scope line="882"/>
                        <scope line="887"/>
                    </scope>
                </scope>
            </method>
            <javadoc line="895">
                Subclasses supporting incrementing must override this to handle
                  the actual incrementing. &lt;code&gt;value&lt;/code&gt; is the current value,
                  &lt;code&gt;attributes&lt;/code&gt; gives the field the cursor is in (may be
                  null depending upon &lt;code&gt;canIncrement&lt;/code&gt;) and
                  &lt;code&gt;direction&lt;/code&gt; is the amount to increment by.                
            </javadoc>
            <method name="adjustValue" type="Object" line="904">
                <params>
                    <param name="value" type="Object"/>
                    <param name="attributes" type="Map"/>
                    <param name="field" type="Object"/>
                    <param name="direction" type="int"/>
                </params>
            </method>
            <javadoc line="908">
                Returns false, indicating InternationalFormatter does not allow
                  incrementing of the value. Subclasses that wish to support
                  incrementing/decrementing the value should override this and
                  return true. Subclasses should also override
                  &lt;code&gt;adjustValue&lt;/code&gt;.                
            </javadoc>
            <method name="getSupportsIncrement" type="boolean" line="915"/>
            <javadoc line="919">
                Resets the value of the JFormattedTextField to be
                  &lt;code&gt;value&lt;/code&gt;.                
            </javadoc>
            <method name="resetValue" type="void" line="923">
                <params>
                    <param name="value" type="Object"/>
                </params>
                <declaration name="doc" type="Document" line="924"/>
                <declaration name="string" type="String" line="925"/>
                <scope line="927"/>
                <scope line="931"/>
            </method>
            <javadoc line="937">
                Subclassed to update the internal representation of the mask after
                  the default read operation has completed.                
            </javadoc>
            <method name="readObject" type="void" line="942">
                <params>
                    <param name="s" type="ObjectInputStream"/>
                </params>
            </method>
            <javadoc line="948">
                Overriden to return an instance of &lt;code&gt;ExtendedReplaceHolder&lt;/code&gt;.                
            </javadoc>
            <method name="getReplaceHolder" type="ReplaceHolder" line="953">
                <params>
                    <param name="fb" type="DocumentFilter.FilterBypass"/>
                    <param name="offset" type="int"/>
                    <param name="length" type="int"/>
                    <param name="text" type="String"/>
                    <param name="attrs" type="AttributeSet"/>
                </params>
                <scope line="954"/>
            </method>
            <class name="ExtendedReplaceHolder" line="961">
                <extends class="ReplaceHolder"/>
                <javadoc line="961">
                    As InternationalFormatter replaces the complete text on every edit,
                      ExtendedReplaceHolder keeps track of the offset and length passed
                      into canReplace.                    
                </javadoc>
                <declaration name="endOffset" type="int" line="967"/>
                <javadoc line="967">
                    Offset of the insert/remove. This may differ from offset in
                      that if !allowsInvalid the text is replaced on every edit.                    
                </javadoc>
                <declaration name="endTextLength" type="int" line="970"/>
                <javadoc line="970">
                    Length of the text. This may differ from text.length in
                      that if !allowsInvalid the text is replaced on every edit.                    
                </javadoc>
                <javadoc line="974">
                    Resets the region to delete to be the complete document and
                      the text from invoking valueToString on the current value.                    
                </javadoc>
                <method name="resetFromValue" type="void" line="978">
                    <params>
                        <param name="formatter" type="InternationalFormatter"/>
                    </params>
                    <comment line="979">
                        Need to reset the complete string as Format&apos;s result can                        
                    </comment>
                    <comment line="980">
                        be completely different.                        
                    </comment>
                    <comment line="985">
                        Should never happen, otherwise canReplace would have                        
                    </comment>
                    <comment line="986">
                        returned value.                        
                    </comment>
                    <scope line="982"/>
                    <scope line="984"/>
                </method>
            </class>
            <class name="IncrementAction" line="994">
                <extends class="AbstractAction"/>
                <javadoc line="994">
                    IncrementAction is used to increment the value by a certain amount.
                      It calls into &lt;code&gt;adjustValue&lt;/code&gt; to handle the actual
                      incrementing of the value.                    
                </javadoc>
                <declaration name="direction" type="int" line="1000"/>
                <method name="IncrementAction" type="constructor" line="1002">
                    <params>
                        <param name="name" type="String"/>
                        <param name="direction" type="int"/>
                    </params>
                </method>
                <method name="actionPerformed" type="void" line="1007">
                    <params>
                        <param name="ae" type="ActionEvent"/>
                    </params>
                    <comment line="1011">
                        This will work if the currently edited value is valid.                        
                    </comment>
                    <scope line="1009">
                        <scope line="1010"/>
                        <declaration name="validEdit" type="boolean" line="1015"/>
                        <scope line="1017">
                            <declaration name="start" type="int" line="1018"/>
                            <scope line="1020">
                                <declaration name="iterator" type="AttributedCharacterIterator" line="1021"/>
                                <declaration name="attributes" type="Map" line="1025"/>
                                <declaration name="field" type="Object" line="1026"/>
                                <scope line="1028">
                                    <scope line="1029">
                                        <declaration name="value" type="Object" line="1030"/>
                                        <declaration name="fieldTypeCount" type="int" line="1032"/>
                                        <scope line="1037">
                                            <scope line="1041"/>
                                        </scope>
                                    </scope>
                                    <scope line="1047"/>
                                    <scope line="1048"/>
                                </scope>
                            </scope>
                        </scope>
                        <scope line="1052"/>
                    </scope>
                </method>
            </class>
        </class>
    </source>