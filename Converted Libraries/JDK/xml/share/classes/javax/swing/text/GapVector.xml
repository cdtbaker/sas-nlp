<?xml version="1.0" encoding="UTF-8"?>
    <source package="javax.swing.text">
        <import package="java.util.Vector"/>
        <import package="java.io.Serializable"/>
        <import package="javax.swing.undo.UndoableEdit"/>
        <class name="GapVector" line="31">
            <comment line="100">
                ---- variables -----------------------------------                
            </comment>
            <comment line="118">
                --- gap management -------------------------------                
            </comment>
            <implements interface="Serializable"/>
            <javadoc line="31">
                An implementation of a gapped buffer similar to that used by
                  emacs.  The underlying storage is a java array of some type,
                  which is known only by the subclass of this class.  The array
                  has a gap somewhere.  The gap is moved to the location of changes
                  to take advantage of common behavior where most changes occur
                  in the same location.  Changes that occur at a gap boundary are
                  generally cheap and moving the gap is generally cheaper than
                  moving the array contents directly to accomodate the change.                
                <author>
                    Timothy Prinzing                    
                </author>
                <see>
                    GapContent                    
                </see>
            </javadoc>
            <javadoc line="47">
                Creates a new GapVector object.  Initial size defaults to 10.                
            </javadoc>
            <method name="GapVector" type="constructor" line="50"/>
            <javadoc line="54">
                Creates a new GapVector object, with the initial
                  size specified.                
                <param>
                    initialLength the initial size                    
                </param>
            </javadoc>
            <method name="GapVector" type="constructor" line="60">
                <params>
                    <param name="initialLength" type="int"/>
                </params>
            </method>
            <method name="allocateArray" type="Object" line="66"/>
            <javadoc line="66">
                Allocate an array to store items of the type
                  appropriate (which is determined by the subclass).                
            </javadoc>
            <method name="getArrayLength" type="int" line="72"/>
            <javadoc line="72">
                Get the length of the allocated array                
            </javadoc>
            <javadoc line="77">
                Access to the array.  The actual type
                  of the array is known only by the subclass.                
            </javadoc>
            <method name="getArray" type="Object" line="81"/>
            <javadoc line="85">
                Access to the start of the gap.                
            </javadoc>
            <method name="getGapStart" type="int" line="88"/>
            <javadoc line="92">
                Access to the end of the gap.                
            </javadoc>
            <method name="getGapEnd" type="int" line="95"/>
            <declaration name="array" type="Object" line="101"/>
            <javadoc line="101">
                The array of items.  The type is determined by the subclass.                
            </javadoc>
            <declaration name="g0" type="int" line="106"/>
            <javadoc line="106">
                start of gap in the array                
            </javadoc>
            <declaration name="g1" type="int" line="111"/>
            <javadoc line="111">
                end of gap in the array                
            </javadoc>
            <javadoc line="119">
                Replace the given logical position in the storage with
                  the given new items.  This will move the gap to the area
                  being changed if the gap is not currently located at the
                  change location.                
                <param>
                    position the location to make the replacement.  This
                      is not the location in the underlying storage array, but
                      the location in the contiguous space being modeled.                    
                </param>
                <param>
                    rmSize the number of items to remove                    
                </param>
                <param>
                    addItems the new items to place in storage.                    
                </param>
            </javadoc>
            <method name="replace" type="void" line="131">
                <params>
                    <param name="position" type="int"/>
                    <param name="rmSize" type="int"/>
                    <param name="addItems" type="Object"/>
                    <param name="addSize" type="int"/>
                </params>
                <comment line="138">
                                        
                </comment>
                <comment line="141">
                                        
                </comment>
                <declaration name="addOffset" type="int" line="132"/>
                <scope line="133"/>
                <scope line="136"/>
                <scope line="139">
                    <declaration name="endSize" type="int" line="141"/>
                    <declaration name="end" type="int" line="142"/>
                </scope>
            </method>
            <javadoc line="149">
                Delete nItems at position.  Squeezes any marks
                  within the deleted area to position.  This moves
                  the gap to the best place by minimizing it&apos;s
                  overall movement.  The gap must intersect the
                  target block.                
            </javadoc>
            <method name="close" type="void" line="156">
                <params>
                    <param name="position" type="int"/>
                    <param name="nItems" type="int"/>
                </params>
                <comment line="163">
                    Move gap to end of block.                    
                </comment>
                <comment line="167">
                    Adjust g0.                    
                </comment>
                <comment line="170">
                    Move gap to beginning of block.                    
                </comment>
                <comment line="174">
                    Adjust g1.                    
                </comment>
                <comment line="177">
                    The gap is properly inside the target block.
                     No data movement necessary, simply move both gap pointers.                    
                </comment>
                <declaration name="end" type="int" line="159"/>
                <declaration name="new_gs" type="int" line="160"/>
                <scope line="161">
                    <scope line="163"/>
                </scope>
                <scope line="168">
                    <scope line="170"/>
                </scope>
                <scope line="175"/>
            </method>
            <javadoc line="183">
                Make space for the given number of items at the given
                  location.                
                <return>
                    the location that the caller should fill in                    
                </return>
            </javadoc>
            <method name="open" type="int" line="189">
                <params>
                    <param name="position" type="int"/>
                    <param name="nItems" type="int"/>
                </params>
                <comment line="198">
                    Expand the array if the gap is too small.                    
                </comment>
                <comment line="201">
                    Pre-shift the gap, to reduce total movement.                    
                </comment>
                <declaration name="gapSize" type="int" line="190"/>
                <scope line="191"/>
                <scope line="199"/>
            </method>
            <javadoc line="209">
                resize the underlying storage array to the
                  given new size                
            </javadoc>
            <method name="resize" type="void" line="213">
                <params>
                    <param name="nsize" type="int"/>
                </params>
                <declaration name="narray" type="Object" line="214"/>
            </method>
            <javadoc line="219">
                Make the gap bigger, moving any necessary data and updating
                  the appropriate marks                
            </javadoc>
            <method name="shiftEnd" type="void" line="223">
                <params>
                    <param name="newSize" type="int"/>
                </params>
                <comment line="234">
                    Copy array items to new end of array.                    
                </comment>
                <declaration name="oldSize" type="int" line="224"/>
                <declaration name="oldGapEnd" type="int" line="225"/>
                <declaration name="upperSize" type="int" line="226"/>
                <declaration name="arrayLength" type="int" line="227"/>
                <declaration name="newGapEnd" type="int" line="228"/>
                <scope line="232"/>
            </method>
            <javadoc line="238">
                Calculates a new size of the storage array depending on required
                  capacity.                
                <param>
                    reqSize the size which is necessary for new content                    
                </param>
                <return>
                    the new size of the storage array                    
                </return>
            </javadoc>
            <method name="getNewArraySize" type="int" line="244">
                <params>
                    <param name="reqSize" type="int"/>
                </params>
            </method>
            <javadoc line="248">
                Move the start of the gap to a new location,
                  without changing the size of the gap.  This
                  moves the data in the array and updates the
                  marks accordingly.                
            </javadoc>
            <method name="shiftGap" type="void" line="254">
                <params>
                    <param name="newGapStart" type="int"/>
                </params>
                <comment line="268">
                    Move gap up, move data down.                    
                </comment>
                <comment line="271">
                    Move gap down, move data up.                    
                </comment>
                <scope line="255"/>
                <declaration name="oldGapStart" type="int" line="258"/>
                <declaration name="dg" type="int" line="259"/>
                <declaration name="oldGapEnd" type="int" line="260"/>
                <declaration name="newGapEnd" type="int" line="261"/>
                <declaration name="gapSize" type="int" line="262"/>
                <scope line="266"/>
                <scope line="269"/>
            </method>
            <javadoc line="275">
                Adjust the gap end downward.  This doesn&apos;t move
                  any data, but it does update any marks affected
                  by the boundary change.  All marks from the old
                  gap start down to the new gap start are squeezed
                  to the end of the gap (their location has been
                  removed).                
            </javadoc>
            <method name="shiftGapStartDown" type="void" line="283">
                <params>
                    <param name="newGapStart" type="int"/>
                </params>
            </method>
            <javadoc line="287">
                Adjust the gap end upward.  This doesn&apos;t move
                  any data, but it does update any marks affected
                  by the boundary change. All marks from the old
                  gap end up to the new gap end are squeezed
                  to the end of the gap (their location has been
                  removed).                
            </javadoc>
            <method name="shiftGapEndUp" type="void" line="295">
                <params>
                    <param name="newGapEnd" type="int"/>
                </params>
            </method>
        </class>
    </source>