<?xml version="1.0" encoding="UTF-8"?>
    <source package="javax.swing">
        <import package="java.util.EventListener"/>
        <import package="java.util.BitSet"/>
        <import package="java.io.Serializable"/>
        <import package="java.beans.Transient"/>
        <import package="javax.swing.event"/>
        <class name="DefaultListSelectionModel" line="36">
            <comment line="254">
                Updates first and last change indices                
            </comment>
            <comment line="260">
                Sets the state at this index and update all relevant state.                
            </comment>
            <comment line="273">
                Clears the state at this index and update all relevant state.                
            </comment>
            <comment line="552">
                private implementation allowing the selection interval                
            </comment>
            <comment line="553">
                to be removed without affecting the lead and anchor                
            </comment>
            <implements interface="ListSelectionModel"/>
            <implements interface="Cloneable"/>
            <implements interface="Serializable"/>
            <javadoc line="36">
                Default data model for list selections.
                  &lt;p&gt;
                  &lt;strong&gt;Warning:&lt;/strong&gt;
                  Serialized objects of this class will not be compatible with
                  future Swing releases. The current serialization support is
                  appropriate for short term storage or RMI between applications running
                  the same version of Swing.  As of 1.4, support for long term storage
                  of all JavaBeans&lt;sup&gt;&lt;font size=&quot;-2&quot;&gt;TM&lt;/font&gt;&lt;/sup&gt;
                  has been added to the &lt;code&gt;java.beans&lt;/code&gt; package.
                  Please see {@link java.beans.XMLEncoder}.                
                <author>
                    Philip Milne                    
                </author>
                <author>
                    Hans Muller                    
                </author>
                <see>
                    ListSelectionModel                    
                </see>
            </javadoc>
            <declaration name="MIN" type="int" line="55"/>
            <declaration name="MAX" type="int" line="56"/>
            <declaration name="selectionMode" type="int" line="57"/>
            <declaration name="minIndex" type="int" line="58"/>
            <declaration name="maxIndex" type="int" line="59"/>
            <declaration name="anchorIndex" type="int" line="60"/>
            <declaration name="leadIndex" type="int" line="61"/>
            <declaration name="firstAdjustedIndex" type="int" line="62"/>
            <declaration name="lastAdjustedIndex" type="int" line="63"/>
            <declaration name="isAdjusting" type="boolean" line="64"/>
            <declaration name="firstChangedIndex" type="int" line="66"/>
            <declaration name="lastChangedIndex" type="int" line="67"/>
            <declaration name="value" type="BitSet" line="69"/>
            <declaration name="listenerList" type="EventListenerList" line="70"/>
            <declaration name="leadAnchorNotificationEnabled" type="boolean" line="72"/>
            <javadoc line="74">
                {@inheritDoc}                
            </javadoc>
            <method name="getMinSelectionIndex" type="int" line="75"/>
            <javadoc line="77">
                {@inheritDoc}                
            </javadoc>
            <method name="getMaxSelectionIndex" type="int" line="78"/>
            <javadoc line="80">
                {@inheritDoc}                
            </javadoc>
            <method name="getValueIsAdjusting" type="boolean" line="81"/>
            <javadoc line="83">
                {@inheritDoc}                
            </javadoc>
            <method name="getSelectionMode" type="int" line="84"/>
            <javadoc line="86">
                {@inheritDoc}                
                <throws>
                    IllegalArgumentException {@inheritDoc}                    
                </throws>
            </javadoc>
            <method name="setSelectionMode" type="void" line="90">
                <params>
                    <param name="selectionMode" type="int"/>
                </params>
            </method>
            <javadoc line="102">
                {@inheritDoc}                
            </javadoc>
            <method name="isSelectedIndex" type="boolean" line="103">
                <params>
                    <param name="index" type="int"/>
                </params>
            </method>
            <javadoc line="107">
                {@inheritDoc}                
            </javadoc>
            <method name="isSelectionEmpty" type="boolean" line="108"/>
            <javadoc line="112">
                {@inheritDoc}                
            </javadoc>
            <method name="addListSelectionListener" type="void" line="113">
                <params>
                    <param name="l" type="ListSelectionListener"/>
                </params>
            </method>
            <javadoc line="117">
                {@inheritDoc}                
            </javadoc>
            <method name="removeListSelectionListener" type="void" line="118">
                <params>
                    <param name="l" type="ListSelectionListener"/>
                </params>
            </method>
            <javadoc line="122">
                Returns an array of all the list selection listeners
                  registered on this &lt;code&gt;DefaultListSelectionModel&lt;/code&gt;.                
                <return>
                    all of this model's <code>ListSelectionListener</code>s
                      or an empty
                      array if no list selection listeners are currently registered                    
                </return>
                <see>
                    #addListSelectionListener                    
                </see>
                <see>
                    #removeListSelectionListener                    
                </see>
                <since>
                    1.4                    
                </since>
            </javadoc>
            <method name="getListSelectionListeners" type="ListSelectionListener[]" line="135"/>
            <javadoc line="139">
                Notifies listeners that we have ended a series of adjustments.                
            </javadoc>
            <method name="fireValueChanged" type="void" line="142">
                <params>
                    <param name="isAdjusting" type="boolean"/>
                </params>
                <comment line="146">
                    Change the values before sending the event to the
                     listeners in case the event causes a listener to make
                     another change to the selection.                    
                </comment>
                <scope line="143"/>
                <declaration name="oldFirstChangedIndex" type="int" line="150"/>
                <declaration name="oldLastChangedIndex" type="int" line="151"/>
            </method>
            <javadoc line="158">
                Notifies &lt;code&gt;ListSelectionListeners&lt;/code&gt; that the value
                  of the selection, in the closed interval &lt;code&gt;firstIndex&lt;/code&gt;,
                  &lt;code&gt;lastIndex&lt;/code&gt;, has changed.                
            </javadoc>
            <method name="fireValueChanged" type="void" line="163">
                <params>
                    <param name="firstIndex" type="int"/>
                    <param name="lastIndex" type="int"/>
                </params>
            </method>
            <javadoc line="167">
                @param firstIndex the first index in the interval                
                <param>
                    lastIndex the last index in the interval                    
                </param>
                <param>
                    isAdjusting true if this is the final change in a series of
                      adjustments                    
                </param>
                <see>
                    EventListenerList                    
                </see>
            </javadoc>
            <method name="fireValueChanged" type="void" line="175">
                <params>
                    <param name="firstIndex" type="int"/>
                    <param name="lastIndex" type="int"/>
                    <param name="isAdjusting" type="boolean"/>
                </params>
                <declaration name="listeners" type="Object[]" line="176"/>
                <declaration name="e" type="ListSelectionEvent" line="177"/>
                <scope line="179">
                    <scope line="180">
                        <scope line="181"/>
                    </scope>
                </scope>
            </method>
            <method name="fireValueChanged" type="void" line="189">
                <comment line="193">
                    If getValueAdjusting() is true, (eg. during a drag opereration)
                     record the bounds of the changes so that, when the drag finishes (and
                     setValueAdjusting(false) is called) we can post a single event
                     with bounds covering all of these individual adjustments.                    
                </comment>
                <comment line="202">
                    Change the values before sending the event to the
                     listeners in case the event causes a listener to make
                     another change to the selection.                    
                </comment>
                <scope line="190"/>
                <scope line="198"/>
                <declaration name="oldFirstAdjustedIndex" type="int" line="206"/>
                <declaration name="oldLastAdjustedIndex" type="int" line="207"/>
            </method>
            <javadoc line="214">
                Returns an array of all the objects currently registered as
                  &lt;code&gt;&lt;em&gt;Foo&lt;/em&gt;Listener&lt;/code&gt;s
                  upon this model.
                  &lt;code&gt;&lt;em&gt;Foo&lt;/em&gt;Listener&lt;/code&gt;s
                  are registered using the &lt;code&gt;add&lt;em&gt;Foo&lt;/em&gt;Listener&lt;/code&gt; method.
                  &lt;p&gt;
                  You can specify the &lt;code&gt;listenerType&lt;/code&gt; argument
                  with a class literal, such as &lt;code&gt;&lt;em&gt;Foo&lt;/em&gt;Listener.class&lt;/code&gt;.
                  For example, you can query a &lt;code&gt;DefaultListSelectionModel&lt;/code&gt;
                  instance &lt;code&gt;m&lt;/code&gt;
                  for its list selection listeners
                  with the following code:
                  &lt;pre&gt;ListSelectionListener[] lsls = (ListSelectionListener[])(m.getListeners(ListSelectionListener.class));&lt;/pre&gt;
                  If no such listeners exist,
                  this method returns an empty array.                
                <param>
                    listenerType  the type of listeners requested;
                      this parameter should specify an interface
                      that descends from <code>java.util.EventListener</code>                    
                </param>
                <return>
                    an array of all objects registered as
                      <code><em>Foo</em>Listener</code>s
                      on this model,
                      or an empty array if no such
                      listeners have been added                    
                </return>
                <exception>
                    ClassCastException if <code>listenerType</code> doesn't
                      specify a class or interface that implements
                      <code>java.util.EventListener</code>                    
                </exception>
                <see>
                    #getListSelectionListeners                    
                </see>
                <since>
                    1.3                    
                </since>
            </javadoc>
            <method name="getListeners" type="T[]" line="249">
                <params>
                    <param name="listenerType" type="Class<T>"/>
                </params>
            </method>
            <method name="markAsDirty" type="void" line="254">
                <params>
                    <param name="r" type="int"/>
                </params>
            </method>
            <method name="set" type="void" line="260">
                <params>
                    <param name="r" type="int"/>
                </params>
                <comment line="267">
                    Update minimum and maximum indices                    
                </comment>
                <scope line="261"/>
            </method>
            <method name="clear" type="void" line="273">
                <params>
                    <param name="r" type="int"/>
                </params>
                <comment line="280">
                    Update minimum and maximum indices                    
                </comment>
                <comment line="281">
                    If (r &gt; minIndex) the minimum has not changed.
                    The case (r &lt; minIndex) is not possible because r&apos;th value was set.
                    We only need to check for the case when lowest entry has been cleared,
                    and in this case we need to search for the first value set above it.                    
                </comment>
                <comment line="294">
                    If (r &lt; maxIndex) the maximum has not changed.
                    The case (r &gt; maxIndex) is not possible because r&apos;th value was set.
                    We only need to check for the case when highest entry has been cleared,
                    and in this case we need to search for the first value set below it.                    
                </comment>
                <comment line="307">
                    Performance note: This method is called from inside a loop in
                    changeSelection() but we will only iterate in the loops
                    above on the basis of one iteration per deselected cell - in total.
                    Ie. the next time this method is called the work of the previous
                    deselection will not be repeated.
                    
                    We also don&apos;t need to worry about the case when the min and max
                    values are in their unassigned states. This cannot happen because
                    this method&apos;s initial check ensures that the selection was not empty
                    and therefore that the minIndex and maxIndex had &apos;real&apos; values.
                    
                    If we have cleared the whole selection, set the minIndex and maxIndex
                    to their cannonical values so that the next set command always works
                    just by using Math.min and Math.max.                    
                </comment>
                <scope line="274"/>
                <scope line="287">
                    <scope line="288">
                        <scope line="289"/>
                    </scope>
                </scope>
                <scope line="300">
                    <scope line="301">
                        <scope line="302"/>
                    </scope>
                </scope>
                <scope line="322"/>
            </method>
            <javadoc line="328">
                Sets the value of the leadAnchorNotificationEnabled flag.                
                <see>
                    #isLeadAnchorNotificationEnabled()                    
                </see>
            </javadoc>
            <method name="setLeadAnchorNotificationEnabled" type="void" line="332">
                <params>
                    <param name="flag" type="boolean"/>
                </params>
            </method>
            <javadoc line="336">
                Returns the value of the &lt;code&gt;leadAnchorNotificationEnabled&lt;/code&gt; flag.
                  When &lt;code&gt;leadAnchorNotificationEnabled&lt;/code&gt; is true the model
                  generates notification events with bounds that cover all the changes to
                  the selection plus the changes to the lead and anchor indices.
                  Setting the flag to false causes a narrowing of the event&apos;s bounds to
                  include only the elements that have been selected or deselected since
                  the last change. Either way, the model continues to maintain the lead
                  and anchor variables internally. The default is true.
                  &lt;p&gt;
                  Note: It is possible for the lead or anchor to be changed without a
                  change to the selection. Notification of these changes is often
                  important, such as when the new lead or anchor needs to be updated in
                  the view. Therefore, caution is urged when changing the default value.                
                <return>
                    the value of the <code>leadAnchorNotificationEnabled</code> flag                    
                </return>
                <see>
                    #setLeadAnchorNotificationEnabled(boolean)                    
                </see>
            </javadoc>
            <method name="isLeadAnchorNotificationEnabled" type="boolean" line="354"/>
            <method name="updateLeadAnchorIndices" type="void" line="358">
                <params>
                    <param name="anchorIndex" type="int"/>
                    <param name="leadIndex" type="int"/>
                </params>
                <comment line="361">
                    The unassigned state.                    
                </comment>
                <comment line="368">
                    The unassigned state.                    
                </comment>
                <scope line="359">
                    <scope line="360">
                        <scope line="361"/>
                    </scope>
                    <scope line="367">
                        <scope line="368"/>
                    </scope>
                </scope>
            </method>
            <method name="contains" type="boolean" line="378">
                <params>
                    <param name="a" type="int"/>
                    <param name="b" type="int"/>
                    <param name="i" type="int"/>
                </params>
            </method>
            <method name="changeSelection" type="void" line="383">
                <params>
                    <param name="clearMin" type="int"/>
                    <param name="clearMax" type="int"/>
                    <param name="setMin" type="int"/>
                    <param name="setMax" type="int"/>
                    <param name="clearFirst" type="boolean"/>
                </params>
                <scope line="384">
                    <declaration name="shouldClear" type="boolean" line="386"/>
                    <declaration name="shouldSet" type="boolean" line="387"/>
                    <scope line="389">
                        <scope line="390"/>
                        <scope line="393"/>
                    </scope>
                    <scope line="398"/>
                    <scope line="401"/>
                </scope>
            </method>
            <javadoc line="408">
                Change the selection with the effect of first clearing the values
                  in the inclusive range [clearMin, clearMax] then setting the values
                  in the inclusive range [setMin, setMax]. Do this in one pass so
                  that no values are cleared if they would later be set.                
            </javadoc>
            <method name="changeSelection" type="void" line="414">
                <params>
                    <param name="clearMin" type="int"/>
                    <param name="clearMax" type="int"/>
                    <param name="setMin" type="int"/>
                    <param name="setMax" type="int"/>
                </params>
            </method>
            <javadoc line="418">
                {@inheritDoc}                
            </javadoc>
            <method name="clearSelection" type="void" line="419"/>
            <javadoc line="423">
                Changes the selection to be between {@code index0} and {@code index1}inclusive. {@code index0} doesn&apos;t have to be less than or equal to{@code index1}.
                  &lt;p&gt;
                  In {@code SINGLE_SELECTION} selection mode, only the second index
                  is used.
                  &lt;p&gt;
                  If this represents a change to the current selection, then each{@code ListSelectionListener} is notified of the change.
                  &lt;p&gt;
                  If either index is {@code -1}, this method does nothing and returns
                  without exception. Otherwise, if either index is less than {@code -1},
                  an {@code IndexOutOfBoundsException} is thrown.                
                <param>
                    index0 one end of the interval.                    
                </param>
                <param>
                    index1 other end of the interval                    
                </param>
                <throws>
                    IndexOutOfBoundsException if either index is less than {@code -1}(and neither index is {@code -1})                    
                </throws>
                <see>
                    #addListSelectionListener                    
                </see>
            </javadoc>
            <method name="setSelectionInterval" type="void" line="444">
                <params>
                    <param name="index0" type="int"/>
                    <param name="index1" type="int"/>
                </params>
                <scope line="445"/>
                <scope line="449"/>
                <declaration name="clearMin" type="int" line="455"/>
                <declaration name="clearMax" type="int" line="456"/>
                <declaration name="setMin" type="int" line="457"/>
                <declaration name="setMax" type="int" line="458"/>
            </method>
            <javadoc line="462">
                Changes the selection to be the set union of the current selection
                  and the indices between {@code index0} and {@code index1} inclusive.
                  &lt;p&gt;
                  In {@code SINGLE_SELECTION} selection mode, this is equivalent
                  to calling {@code setSelectionInterval}, and only the second index
                  is used. In {@code SINGLE_INTERVAL_SELECTION} selection mode, this
                  method behaves like {@code setSelectionInterval}, unless the given
                  interval is immediately adjacent to or overlaps the existing selection,
                  and can therefore be used to grow it.
                  &lt;p&gt;
                  If this represents a change to the current selection, then each{@code ListSelectionListener} is notified of the change. Note that{@code index0} doesn&apos;t have to be less than or equal to {@code index1}.
                  &lt;p&gt;
                  If either index is {@code -1}, this method does nothing and returns
                  without exception. Otherwise, if either index is less than {@code -1},
                  an {@code IndexOutOfBoundsException} is thrown.                
                <param>
                    index0 one end of the interval.                    
                </param>
                <param>
                    index1 other end of the interval                    
                </param>
                <throws>
                    IndexOutOfBoundsException if either index is less than {@code -1}(and neither index is {@code -1})                    
                </throws>
                <see>
                    #addListSelectionListener                    
                </see>
                <see>
                    #setSelectionInterval                    
                </see>
            </javadoc>
            <method name="addSelectionInterval" type="void" line="489">
                <params>
                    <param name="index0" type="int"/>
                    <param name="index1" type="int"/>
                </params>
                <comment line="494">
                    If we only allow a single selection, channel through                    
                </comment>
                <comment line="495">
                    setSelectionInterval() to enforce the rule.                    
                </comment>
                <comment line="508">
                    If we only allow a single interval and this would result                    
                </comment>
                <comment line="509">
                    in multiple intervals, then set the selection to be just                    
                </comment>
                <comment line="510">
                    the new range.                    
                </comment>
                <scope line="490"/>
                <scope line="496"/>
                <declaration name="clearMin" type="int" line="503"/>
                <declaration name="clearMax" type="int" line="504"/>
                <declaration name="setMin" type="int" line="505"/>
                <declaration name="setMax" type="int" line="506"/>
                <scope line="512"/>
            </method>
            <javadoc line="522">
                Changes the selection to be the set difference of the current selection
                  and the indices between {@code index0} and {@code index1} inclusive.{@code index0} doesn&apos;t have to be less than or equal to {@code index1}.
                  &lt;p&gt;
                  In {@code SINGLE_INTERVAL_SELECTION} selection mode, if the removal
                  would produce two disjoint selections, the removal is extended through
                  the greater end of the selection. For example, if the selection is{@code 0-10} and you supply indices {@code 5,6} (in any order) the
                  resulting selection is {@code 0-4}.
                  &lt;p&gt;
                  If this represents a change to the current selection, then each{@code ListSelectionListener} is notified of the change.
                  &lt;p&gt;
                  If either index is {@code -1}, this method does nothing and returns
                  without exception. Otherwise, if either index is less than {@code -1},
                  an {@code IndexOutOfBoundsException} is thrown.                
                <param>
                    index0 one end of the interval                    
                </param>
                <param>
                    index1 other end of the interval                    
                </param>
                <throws>
                    IndexOutOfBoundsException if either index is less than {@code -1}(and neither index is {@code -1})                    
                </throws>
                <see>
                    #addListSelectionListener                    
                </see>
            </javadoc>
            <method name="removeSelectionInterval" type="void" line="547">
                <params>
                    <param name="index0" type="int"/>
                    <param name="index1" type="int"/>
                </params>
            </method>
            <method name="removeSelectionIntervalImpl" type="void" line="554">
                <params>
                    <param name="index0" type="int"/>
                    <param name="index1" type="int"/>
                    <param name="changeLeadAnchor" type="boolean"/>
                </params>
                <comment line="569">
                    If the removal would produce to two disjoint selections in a mode                    
                </comment>
                <comment line="570">
                    that only allows one, extend the removal to the end of the selection.                    
                </comment>
                <scope line="556"/>
                <scope line="560"/>
                <declaration name="clearMin" type="int" line="564"/>
                <declaration name="clearMax" type="int" line="565"/>
                <declaration name="setMin" type="int" line="566"/>
                <declaration name="setMax" type="int" line="567"/>
                <scope line="572"/>
            </method>
            <method name="setState" type="void" line="579">
                <params>
                    <param name="index" type="int"/>
                    <param name="state" type="boolean"/>
                </params>
                <scope line="580"/>
                <scope line="583"/>
            </method>
            <javadoc line="588">
                Insert length indices beginning before/after index. If the value
                  at index is itself selected and the selection mode is not
                  SINGLE_SELECTION, set all of the newly inserted items as selected.
                  Otherwise leave them unselected. This method is typically
                  called to sync the selection model with a corresponding change
                  in the data model.                
            </javadoc>
            <method name="insertIndexInterval" type="void" line="597">
                <params>
                    <param name="index" type="int"/>
                    <param name="length" type="int"/>
                    <param name="before" type="boolean"/>
                </params>
                <comment line="598">
                    The first new index will appear at insMinIndex and the last
                     one will appear at insMaxIndex                    
                </comment>
                <comment line="604">
                    Right shift the entire bitset by length, beginning with
                     index-1 if before is true, index+1 if it&apos;s false (i.e. with
                     insMinIndex).                    
                </comment>
                <comment line="612">
                    Initialize the newly inserted indices.                    
                </comment>
                <declaration name="insMinIndex" type="int" line="601"/>
                <declaration name="insMaxIndex" type="int" line="602"/>
                <scope line="608"/>
                <declaration name="setInsertedValues" type="boolean" line="614"/>
                <scope line="616"/>
                <declaration name="leadIndex" type="int" line="620"/>
                <scope line="621"/>
                <declaration name="anchorIndex" type="int" line="624"/>
                <scope line="625"/>
                <scope line="628"/>
            </method>
            <javadoc line="636">
                Remove the indices in the interval index0,index1 (inclusive) from
                  the selection model.  This is typically called to sync the selection
                  model width a corresponding change in the data model.  Note
                  that (as always) index0 need not be &lt;= index1.                
            </javadoc>
            <method name="removeIndexInterval" type="void" line="643">
                <params>
                    <param name="index0" type="int"/>
                    <param name="index1" type="int"/>
                </params>
                <comment line="648">
                    Shift the entire bitset to the left to close the index0, index1
                     gap.                    
                </comment>
                <comment line="657">
                    do nothing                    
                </comment>
                <comment line="666">
                    do nothing                    
                </comment>
                <declaration name="rmMinIndex" type="int" line="644"/>
                <declaration name="rmMaxIndex" type="int" line="645"/>
                <declaration name="gapLength" type="int" line="646"/>
                <scope line="651"/>
                <declaration name="leadIndex" type="int" line="655"/>
                <scope line="656"/>
                <scope line="658"/>
                <scope line="660"/>
                <declaration name="anchorIndex" type="int" line="664"/>
                <scope line="665"/>
                <scope line="667"/>
                <scope line="669"/>
                <scope line="673"/>
            </method>
            <javadoc line="681">
                {@inheritDoc}                
            </javadoc>
            <method name="setValueIsAdjusting" type="void" line="682">
                <params>
                    <param name="isAdjusting" type="boolean"/>
                </params>
                <scope line="683"/>
            </method>
            <javadoc line="690">
                Returns a string that displays and identifies this
                  object&apos;s properties.                
                <return>
                    a <code>String</code> representation of this object                    
                </return>
            </javadoc>
            <method name="toString" type="String" line="696">
                <declaration name="s" type="String" line="697"/>
            </method>
            <javadoc line="701">
                Returns a clone of this selection model with the same selection.
                  &lt;code&gt;listenerLists&lt;/code&gt; are not duplicated.                
                <exception>
                    CloneNotSupportedException if the selection model does not
                      both (a) implement the Cloneable interface and (b) define a
                      <code>clone</code> method.                    
                </exception>
            </javadoc>
            <method name="clone" type="Object" line="709">
                <declaration name="clone" type="DefaultListSelectionModel" line="710"/>
            </method>
            <javadoc line="716">
                {@inheritDoc}                
            </javadoc>
            <method name="getAnchorSelectionIndex" type="int" line="718"/>
            <javadoc line="722">
                {@inheritDoc}                
            </javadoc>
            <method name="getLeadSelectionIndex" type="int" line="724"/>
            <javadoc line="728">
                Set the anchor selection index, leaving all selection values unchanged.
                  If leadAnchorNotificationEnabled is true, send a notification covering
                  the old and new anchor cells.                
                <see>
                    #getAnchorSelectionIndex                    
                </see>
                <see>
                    #setLeadSelectionIndex                    
                </see>
            </javadoc>
            <method name="setAnchorSelectionIndex" type="void" line="736">
                <params>
                    <param name="anchorIndex" type="int"/>
                </params>
            </method>
            <javadoc line="741">
                Set the lead selection index, leaving all selection values unchanged.
                  If leadAnchorNotificationEnabled is true, send a notification covering
                  the old and new lead cells.                
                <param>
                    leadIndex the new lead selection index                    
                </param>
                <see>
                    #setAnchorSelectionIndex                    
                </see>
                <see>
                    #setLeadSelectionIndex                    
                </see>
                <see>
                    #getLeadSelectionIndex                    
                </see>
                <since>
                    1.5                    
                </since>
            </javadoc>
            <method name="moveLeadSelectionIndex" type="void" line="754">
                <params>
                    <param name="leadIndex" type="int"/>
                </params>
                <comment line="755">
                    disallow a -1 lead unless the anchor is already -1                    
                </comment>
                <comment line="761">
                    PENDING(shannonh) - The following check is nice, to be consistent with
                    setLeadSelectionIndex. However, it is not absolutely
                    necessary: One could work around it by setting the anchor
                    to something valid, modifying the lead, and then moving
                    the anchor back to -1. For this reason, there&apos;s no sense
                    in adding it at this time, as that would require
                    updating the spec and officially committing to it.
                    
                     otherwise, don&apos;t do anything if the anchor is -1
                    } else if (this.anchorIndex == -1) {
                    return;                    
                </comment>
                <scope line="756">
                    <scope line="757"/>
                </scope>
            </method>
            <javadoc line="780">
                Sets the lead selection index, ensuring that values between the
                  anchor and the new lead are either all selected or all deselected.
                  If the value at the anchor index is selected, first clear all the
                  values in the range [anchor, oldLeadIndex], then select all the values
                  values in the range [anchor, newLeadIndex], where oldLeadIndex is the old
                  leadIndex and newLeadIndex is the new one.
                  &lt;p&gt;
                  If the value at the anchor index is not selected, do the same thing in
                  reverse selecting values in the old range and deslecting values in the
                  new one.
                  &lt;p&gt;
                  Generate a single event for this change and notify all listeners.
                  For the purposes of generating minimal bounds in this event, do the
                  operation in a single pass; that way the first and last index inside the
                  ListSelectionEvent that is broadcast will refer to cells that actually
                  changed value because of this method. If, instead, this operation were
                  done in two steps the effect on the selection state would be the same
                  but two events would be generated and the bounds around the changed
                  values would be wider, including cells that had been first cleared only
                  to later be set.
                  &lt;p&gt;
                  This method can be used in the &lt;code&gt;mouseDragged&lt;/code&gt; method
                  of a UI class to extend a selection.                
                <see>
                    #getLeadSelectionIndex                    
                </see>
                <see>
                    #setAnchorSelectionIndex                    
                </see>
            </javadoc>
            <method name="setLeadSelectionIndex" type="void" line="808">
                <params>
                    <param name="leadIndex" type="int"/>
                </params>
                <comment line="811">
                    only allow a -1 lead if the anchor is already -1                    
                </comment>
                <comment line="819">
                    otherwise, don&apos;t do anything if the anchor is -1                    
                </comment>
                <declaration name="anchorIndex" type="int" line="809"/>
                <scope line="812">
                    <scope line="813"/>
                </scope>
                <scope line="820"/>
                <scope line="824"/>
                <declaration name="shouldSelect" type="boolean" line="828"/>
                <scope line="830"/>
                <declaration name="oldMin" type="int" line="835"/>
                <declaration name="oldMax" type="int" line="836"/>
                <declaration name="newMin" type="int" line="837"/>
                <declaration name="newMax" type="int" line="838"/>
                <scope line="842"/>
                <scope line="845"/>
            </method>
        </class>
    </source>