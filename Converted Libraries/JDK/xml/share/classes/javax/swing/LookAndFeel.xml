<?xml version="1.0" encoding="UTF-8"?>
    <source package="javax.swing">
        <import package="java.awt.Font"/>
        <import package="java.awt.event.InputEvent"/>
        <import package="java.awt.event.KeyEvent"/>
        <import package="java.awt.Color"/>
        <import package="java.awt.Component"/>
        <import package="java.awt.SystemColor"/>
        <import package="java.awt.Toolkit"/>
        <import package="sun.awt.SunToolkit"/>
        <import package="javax.swing.text"/>
        <import package="javax.swing.border"/>
        <import package="javax.swing.plaf"/>
        <import package="java.net.URL"/>
        <import package="sun.swing.SwingUtilities2"/>
        <import package="sun.swing.DefaultLayoutStyle"/>
        <import package="sun.swing.ImageIconUIResource"/>
        <import package="java.util.StringTokenizer"/>
        <class name="LookAndFeel" line="18">
            <javadoc line="18">
                {@code LookAndFeel}, as the name implies, encapsulates a look and
                  feel. Beyond installing a look and feel most developers never need to
                  interact directly with {@code LookAndFeel}. In general only developers
                  creating a custom look and feel need to concern themselves with this class.
                  &lt;p&gt;
                  Swing is built upon the foundation that each {@code JComponent}subclass has an implementation of a specific {@code ComponentUI}subclass. The {@code ComponentUI} is often referred to as &quot;the ui&quot;,
                  &quot;component ui&quot;, or &quot;look and feel delegate&quot;. The {@code ComponentUI}subclass is responsible for providing the look and feel specific
                  functionality of the component. For example, {@code JTree} requires
                  an implementation of the {@code ComponentUI} subclass {@codeTreeUI}. The implementation of the specific {@codeComponentUI} subclass is provided by the {@code LookAndFeel}. Each{@code JComponent} subclass identifies the {@code ComponentUI}subclass it requires by way of the {@code JComponent} method {@codegetUIClassID}.
                  &lt;p&gt;
                  Each {@code LookAndFeel} implementation must provide
                  an implementation of the appropriate {@code ComponentUI} subclass by
                  specifying a value for each of Swing&apos;s ui class ids in the {@codeUIDefaults} object returned from {@code getDefaults}. For example,{@code BasicLookAndFeel} uses {@code BasicTreeUI} as the concrete
                  implementation for {@code TreeUI}. This is accomplished by {@codeBasicLookAndFeel} providing the key-value pair {@code&quot;TreeUI&quot;-&quot;javax.swing.plaf.basic.BasicTreeUI&quot;}, in the{@code UIDefaults} returned from {@code getDefaults}. Refer to{@link UIDefaults#getUI(JComponent)} for defails on how the implementation
                  of the {@code ComponentUI} subclass is obtained.
                  &lt;p&gt;
                  When a {@code LookAndFeel} is installed the {@code UIManager} does
                  not check that an entry exists for all ui class ids. As such,
                  random exceptions will occur if the current look and feel has not
                  provided a value for a particular ui class id and an instance of
                  the {@code JComponent} subclass is created.
                  &lt;h2&gt;Recommendations for Look and Feels&lt;/h2&gt;
                  As noted in {@code UIManager} each {@code LookAndFeel} has the opportunity
                  to provide a set of defaults that are layered in with developer and
                  system defaults. Some of Swing&apos;s components require the look and feel
                  to provide a specific set of defaults. These are documented in the
                  classes that require the specific default.
                  &lt;h3&gt;&lt;a name=&quot;#defaultRecommendation&quot;&gt;ComponentUIs and defaults&lt;/a&gt;&lt;/h2&gt;
                  All {@code ComponentUIs} typically need to set various properties
                  on the {@code JComponent} the {@code ComponentUI} is providing the
                  look and feel for. This is typically done when the {@codeComponentUI} is installed on the {@code JComponent}. Setting a
                  property should only be done if the developer has not set the
                  property. For non-primitive values it is recommended that the{@code ComponentUI} only change the property on the {@codeJComponent} if the current value is {@code null} or implements{@code UIResource}. If the current value is {@code null} or
                  implements {@code UIResource} it indicates the property has not
                  been set by the developer, and the ui is free to change it.  For
                  example, {@code BasicButtonUI.installDefaults} only changes the
                  font on the {@code JButton} if the return value from 
                   is {@code null} or implements {@codeUIResource}. On the other hand if {@code button.getFont()} returned
                  a {@code non-null} value that did not implement {@code UIResource}then {@code BasicButtonUI.installDefaults} would not change the{@code JButton}&apos;s font.
                  &lt;p&gt;
                  For primitive values, such as {@code opaque}, the method {@codeinstallProperty} should be invoked.  {@code installProperty} only changes
                  the correspoding property if the value has not been changed by the
                  developer.
                  &lt;p&gt;{@code ComponentUI} implementations should use the various install methods
                  provided by this class as they handle the necessary checking and install
                  the property using the recommended guidelines.
                  &lt;p&gt;
                  &lt;h3&gt;&lt;a name=&quot;exceptions&quot;&gt;&lt;/a&gt;Exceptions&lt;/h3&gt;
                  All of the install methods provided by {@code LookAndFeel} need to
                  access the defaults if the value of the property being changed is{@code null} or a {@code UIResource}. For example, installing the
                  font does the following:
                  &lt;pre&gt;
                  JComponent c;
                  Font font = c.getFont();
                  if (font == null || (font instanceof UIResource)) {
                  c.setFont(UIManager.getFont(&quot;fontKey&quot;));
                  }
                  &lt;/pre&gt;
                  If the font is {@code null} or a {@code UIResource}, the
                  defaults table is queried with the key {@code fontKey}. All of{@code UIDefault&apos;s} get methods throw a {@codeNullPointerException} if passed in {@code null}. As such, unless
                  otherwise noted each of the various install methods of {@codeLookAndFeel} throw a {@code NullPointerException} if the current
                  value is {@code null} or a {@code UIResource} and the supplied
                  defaults key is {@code null}. In addition, unless otherwise specified
                  all of the {@code install} methods throw a {@code NullPointerException} if
                  a {@code null} component is passed in.                
                <author>
                    Tom Ball                    
                </author>
                <author>
                    Hans Muller                    
                </author>
            </javadoc>
            <javadoc line="87">
                Convenience method for setting a component&apos;s foreground
                  and background color properties with values from the
                  defaults.  The properties are only set if the current
                  value is either {@code null} or a {@code UIResource}.                
                <param>
                    c component to set the colors on                    
                </param>
                <param>
                    defaultBgName key for the background                    
                </param>
                <param>
                    defaultFgName key for the foreground                    
                </param>
                <see>
                    #installColorsAndFont                    
                </see>
                <see>
                    UIManager#getColor                    
                </see>
                <throws>
                    NullPointerException as described in
                      &lt;a href=&quot;#exceptions&quot;&gt;exceptions&lt;/a&gt;                    
                </throws>
            </javadoc>
            <method name="installColors" type="void" line="100">
                <params>
                    <param name="c" type="JComponent"/>
                    <param name="defaultBgName" type="String"/>
                    <param name="defaultFgName" type="String"/>
                </params>
                <declaration name="bg" type="Color" line="101"/>
                <scope line="102"/>
                <declaration name="fg" type="Color" line="105"/>
                <scope line="106"/>
            </method>
            <javadoc line="110">
                Convenience method for setting a component&apos;s foreground,
                  background and font properties with values from the
                  defaults.  The properties are only set if the current
                  value is either {@code null} or a {@code UIResource}.                
                <param>
                    c component set to the colors and font on                    
                </param>
                <param>
                    defaultBgName key for the background                    
                </param>
                <param>
                    defaultFgName key for the foreground                    
                </param>
                <param>
                    defaultFontName key for the font                    
                </param>
                <throws>
                    NullPointerException as described in
                      &lt;a href=&quot;#exceptions&quot;&gt;exceptions&lt;/a&gt;                    
                </throws>
                <see>
                    #installColors                    
                </see>
                <see>
                    UIManager#getColor                    
                </see>
                <see>
                    UIManager#getFont                    
                </see>
            </javadoc>
            <method name="installColorsAndFont" type="void" line="125">
                <params>
                    <param name="c" type="JComponent"/>
                    <param name="defaultBgName" type="String"/>
                    <param name="defaultFgName" type="String"/>
                    <param name="defaultFontName" type="String"/>
                </params>
                <declaration name="f" type="Font" line="126"/>
                <scope line="127"/>
            </method>
            <javadoc line="132">
                Convenience method for setting a component&apos;s border property with
                  a value from the defaults. The border is only set if the border is{@code null} or an instance of {@code UIResource}.                
                <param>
                    c component to set the border on                    
                </param>
                <param>
                    defaultBorderName key specifying the border                    
                </param>
                <throws>
                    NullPointerException as described in
                      &lt;a href=&quot;#exceptions&quot;&gt;exceptions&lt;/a&gt;                    
                </throws>
            </javadoc>
            <method name="installBorder" type="void" line="140">
                <params>
                    <param name="c" type="JComponent"/>
                    <param name="defaultBorderName" type="String"/>
                </params>
                <declaration name="b" type="Border" line="141"/>
                <scope line="142"/>
            </method>
            <javadoc line="146">
                Convenience method for uninstalling a border. If the border of
                  the component is a {@code UIResource}, it is set to {@codenull}.                
                <param>
                    c component to uninstall the border on                    
                </param>
                <throws>
                    NullPointerException if {@code c} is {@code null}                    
                </throws>
            </javadoc>
            <method name="uninstallBorder" type="void" line="152">
                <params>
                    <param name="c" type="JComponent"/>
                </params>
                <scope line="153"/>
            </method>
            <javadoc line="157">
                Convenience method for installing a property with the specified name
                  and value on a component if that property has not already been set
                  by the developer.  This method is intended to be used by
                  ui delegate instances that need to specify a default value for a
                  property of primitive type (boolean, int, ..), but do not wish
                  to override a value set by the client.  Since primitive property
                  values cannot be wrapped with the {@code UIResource} marker, this method
                  uses private state to determine whether the property has been set
                  by the client.                
                <throws>
                    IllegalArgumentException if the specified property is not
                      one which can be set using this method                    
                </throws>
                <throws>
                    ClassCastException if the property value has not been set
                      by the developer and the type does not match the property&apos;s type                    
                </throws>
                <throws>
                    NullPointerException if {@code c} is {@code null}, or the
                      named property has not been set by the developer and{@code propertyValue} is {@code null}                    
                </throws>
                <param>
                    c target component to set the property on                    
                </param>
                <param>
                    propertyName name of the property to set                    
                </param>
                <param>
                    propertyValue value of the property                    
                </param>
                <since>
                    1.5                    
                </since>
            </javadoc>
            <method name="installProperty" type="void" line="178">
                <params>
                    <param name="c" type="JComponent"/>
                    <param name="propertyName" type="String"/>
                    <param name="propertyValue" type="Object"/>
                </params>
                <scope line="179">
                    <scope line="180"/>
                </scope>
                <scope line="184"/>
            </method>
            <javadoc line="188">
                Convenience method for building an array of {@codeKeyBindings}. While this method is not deprecated, developers
                  should instead use {@code ActionMap} and {@code InputMap} for
                  supplying key bindings.
                  &lt;p&gt;
                  This method returns an array of {@code KeyBindings}, one for each
                  alternating {@code key-action} pair in {@code keyBindingList}.
                  A {@code key} can either be a {@code String} in the format
                  specified by the &lt;code&gt;KeyStroke.getKeyStroke&lt;/code&gt; method, or
                  a {@code KeyStroke}. The {@code action} part of the pair is a{@code String} that corresponds to the name of the {@codeAction}.
                  &lt;p&gt;
                  The following example illustrates creating a {@code KeyBinding} array
                  from six alternating {@code key-action} pairs:
                  &lt;pre&gt;
                  JTextComponent.KeyBinding[] multilineBindings = makeKeyBindings( new Object[] {
                  &quot;UP&quot;, DefaultEditorKit.upAction,
                  &quot;DOWN&quot;, DefaultEditorKit.downAction,
                  &quot;PAGE_UP&quot;, DefaultEditorKit.pageUpAction,
                  &quot;PAGE_DOWN&quot;, DefaultEditorKit.pageDownAction,
                  &quot;ENTER&quot;, DefaultEditorKit.insertBreakAction,
                  &quot;TAB&quot;, DefaultEditorKit.insertTabAction
                  });
                  &lt;/pre&gt;
                  If {@code keyBindingList&apos;s} length is odd, the last element is
                  ignored.
                  &lt;p&gt;
                  Supplying a {@code null} value for either the {@code key} or{@code action} part of the {@code key-action} pair results in
                  creating a {@code KeyBinding} with the corresponding value{@code null}. As other parts of Swing&apos;s expect {@code non-null} values
                  in a {@code KeyBinding}, you should avoid supplying {@code null} as
                  either the {@code key} or {@code action} part of the {@code key-action}pair.                
                <param>
                    keyBindingList an array of {@code key-action} pairs                    
                </param>
                <return>
                    an array of {@code KeyBindings}                    
                </return>
                <throws>
                    NullPointerException if {@code keyBindingList} is {@code null}                    
                </throws>
                <throws>
                    ClassCastException if the {@code key} part of the pair is
                      not a {@code KeyStroke} or {@code String}, or the{@code action} part of the pair is not a {@code String}                    
                </throws>
                <see>
                    ActionMap                    
                </see>
                <see>
                    InputMap                    
                </see>
                <see>
                    KeyStroke#getKeyStroke                    
                </see>
            </javadoc>
            <method name="makeKeyBindings" type="JTextComponent.KeyBinding[]" line="227">
                <params>
                    <param name="keyBindingList" type="Object[]"/>
                </params>
                <declaration name="rv" type="JTextComponent.KeyBinding[]" line="228"/>
                <scope line="229">
                    <declaration name="o" type="Object" line="230"/>
                    <declaration name="keystroke" type="KeyStroke" line="231"/>
                    <declaration name="action" type="String" line="232"/>
                </scope>
            </method>
            <javadoc line="237">
                Creates a {@code InputMapUIResource} from &lt;code&gt;keys&lt;/code&gt;. This is
                  a convenience method for creating a new {@code InputMapUIResource},
                  invoking {@code loadKeyBindings(map, keys)}, and returning the{@code InputMapUIResource}.                
                <param>
                    keys alternating pairs of {@code keystroke-action key}pairs as described in {@link #loadKeyBindings}                    
                </param>
                <return>
                    newly created and populated {@code InputMapUIResource}                    
                </return>
                <see>
                    #loadKeyBindings                    
                </see>
                <since>
                    1.3                    
                </since>
            </javadoc>
            <method name="makeInputMap" type="InputMap" line="246">
                <params>
                    <param name="keys" type="Object[]"/>
                </params>
                <declaration name="retMap" type="InputMap" line="247"/>
            </method>
            <javadoc line="251">
                Creates a {@code ComponentInputMapUIResource} from
                  &lt;code&gt;keys&lt;/code&gt;. This is a convenience method for creating a
                  new {@code ComponentInputMapUIResource}, invoking {@codeloadKeyBindings(map, keys)}, and} returning the {@codeComponentInputMapUIResource}.                
                <param>
                    c component to create the {@code ComponentInputMapUIResource}with                    
                </param>
                <param>
                    keys alternating pairs of {@code keystroke-action key}pairs as described in {@link #loadKeyBindings}                    
                </param>
                <return>
                    newly created and populated {@code InputMapUIResource}                    
                </return>
                <throws>
                    IllegalArgumentException if {@code c} is {@code null}                    
                </throws>
                <see>
                    #loadKeyBindings                    
                </see>
                <see>
                    ComponentInputMapUIResource                    
                </see>
                <since>
                    1.3                    
                </since>
            </javadoc>
            <method name="makeComponentInputMap" type="ComponentInputMap" line="263">
                <params>
                    <param name="c" type="JComponent"/>
                    <param name="keys" type="Object[]"/>
                </params>
                <declaration name="retMap" type="ComponentInputMap" line="264"/>
            </method>
            <javadoc line="268">
                Populates an {@code InputMap} with the specified bindings.
                  The bindings are supplied as a list of alternating{@code keystroke-action key} pairs. The {@code keystroke} is either
                  an instance of {@code KeyStroke}, or a {@code String}that identifies the {@code KeyStroke} for the binding. Refer
                  to {@code KeyStroke.getKeyStroke(String)} for the specific
                  format. The {@code action key} part of the pair is the key
                  registered in the {@code InputMap} for the {@code KeyStroke}.
                  &lt;p&gt;
                  The following illustrates loading an {@code InputMap} with two{@code key-action} pairs:
                  &lt;pre&gt;
                  LookAndFeel.loadKeyBindings(inputMap, new Object[] {
                  &quot;control X&quot;, &quot;cut&quot;,
                  &quot;control V&quot;, &quot;paste&quot;
                  });
                  &lt;/pre&gt;
                  &lt;p&gt;
                  Supplying a {@code null} list of bindings ({@code keys}) does not
                  change {@code retMap} in any way.
                  &lt;p&gt;
                  Specifying a {@code null} {@code action key} results in
                  removing the {@code keystroke&apos;s} entry from the {@code InputMap}.
                  A {@code null} {@code keystroke} is ignored.                
                <param>
                    retMap {@code InputMap} to add the {@code key-action}pairs to                    
                </param>
                <param>
                    keys bindings to add to {@code retMap}                    
                </param>
                <throws>
                    NullPointerException if {@code keys} is{@code non-null}, not empty, and {@code retMap} is{@code null}                    
                </throws>
                <see>
                    KeyStroke#getKeyStroke(String)                    
                </see>
                <see>
                    InputMap                    
                </see>
                <since>
                    1.3                    
                </since>
            </javadoc>
            <method name="loadKeyBindings" type="void" line="297">
                <params>
                    <param name="retMap" type="InputMap"/>
                    <param name="keys" type="Object[]"/>
                </params>
                <scope line="298">
                    <scope line="299">
                        <declaration name="keyStrokeO" type="Object" line="300"/>
                        <declaration name="ks" type="KeyStroke" line="301"/>
                    </scope>
                </scope>
            </method>
            <javadoc line="306">
                Creates and returns a {@code UIDefault.LazyValue} that loads an
                  image. The returned value is an implementation of {@codeUIDefaults.LazyValue}. When {@code createValue} is invoked on
                  the returned object, the image is loaded. If the image is {@codenon-null}, it is then wrapped in an {@code Icon} that implements {@codeUIResource}. The image is loaded using 
                  This method does not check the arguments in any way. It is
                  strongly recommended that {@code non-null} values are supplied else
                  exceptions may occur when {@code createValue} is invoked on the
                  returned object.                
                <param>
                    baseClass {@code Class} used to load the resource                    
                </param>
                <param>
                    gifFile path to the image to load                    
                </param>
                <return>
                    a {@code UIDefaults.LazyValue}; when resolved the{@code LazyValue} loads the specified image                    
                </return>
                <see>
                    UIDefaults.LazyValue                    
                </see>
                <see>
                    Icon                    
                </see>
                <see>
                    Class#getResourceAsStream(String)                    
                </see>
            </javadoc>
            <method name="makeIcon" type="Object" line="322">
                <params>
                    <param name="baseClass" type="Class&lt;?&gt;"/>
                    <param name="gifFile" type="String"/>
                </params>
            </method>
            <javadoc line="325">
                Returns the &lt;code&gt;LayoutStyle&lt;/code&gt; for this look
                  and feel.  This never returns {@code null}.
                  &lt;p&gt;
                  You generally don&apos;t use the &lt;code&gt;LayoutStyle&lt;/code&gt; from
                  the look and feel, instead use the &lt;code&gt;LayoutStyle&lt;/code&gt;
                  method &lt;code&gt;getInstance&lt;/code&gt;.                
                <see>
                    LayoutStyle#getInstance                    
                </see>
                <return>
                    the &lt;code&gt;LayoutStyle&lt;/code&gt; for this look and feel                    
                </return>
                <since>
                    1.6                    
                </since>
            </javadoc>
            <method name="getLayoutStyle" type="LayoutStyle" line="336"/>
            <javadoc line="339">
                Invoked when the user attempts an invalid operation,
                  such as pasting into an uneditable &lt;code&gt;JTextField&lt;/code&gt;
                  that has focus. The default implementation beeps. Subclasses
                  that wish different behavior should override this and provide
                  the additional feedback.                
                <param>
                    component the &lt;code&gt;Component&lt;/code&gt; the error occurred in,
                      may be &lt;code&gt;null&lt;/code&gt;
                      indicating the error condition is not directly
                      associated with a &lt;code&gt;Component&lt;/code&gt;                    
                </param>
                <since>
                    1.4                    
                </since>
            </javadoc>
            <method name="provideErrorFeedback" type="void" line="351">
                <params>
                    <param name="component" type="Component"/>
                </params>
                <declaration name="toolkit" type="Toolkit" line="352"/>
                <scope line="353"/>
                <scope line="356"/>
            </method>
            <javadoc line="361">
                Returns the value of the specified system desktop property by
                  invoking &lt;code&gt;Toolkit.getDefaultToolkit().getDesktopProperty()&lt;/code&gt;.
                  If the value of the specified property is {@code null},{@code fallbackValue} is returned.                
                <param>
                    systemPropertyName the name of the system desktop property being queried                    
                </param>
                <param>
                    fallbackValue the object to be returned as the value if the system value is null                    
                </param>
                <return>
                    the current value of the desktop property                    
                </return>
                <see>
                    java.awt.Toolkit#getDesktopProperty                    
                </see>
                <since>
                    1.4                    
                </since>
            </javadoc>
            <method name="getDesktopPropertyValue" type="Object" line="371">
                <params>
                    <param name="systemPropertyName" type="String"/>
                    <param name="fallbackValue" type="Object"/>
                </params>
                <declaration name="value" type="Object" line="372"/>
                <scope line="373"/>
                <scope line="376"/>
                <scope line="379"/>
            </method>
            <javadoc line="384">
                Returns an &lt;code&gt;Icon&lt;/code&gt; with a disabled appearance.
                  This method is used to generate a disabled &lt;code&gt;Icon&lt;/code&gt; when
                  one has not been specified.  For example, if you create a
                  &lt;code&gt;JButton&lt;/code&gt; and only specify an &lt;code&gt;Icon&lt;/code&gt; via
                  &lt;code&gt;setIcon&lt;/code&gt; this method will be called to generate the
                  disabled &lt;code&gt;Icon&lt;/code&gt;. If {@code null} is passed as
                  &lt;code&gt;icon&lt;/code&gt; this method returns {@code null}.
                  &lt;p&gt;
                  Some look and feels might not render the disabled {@code Icon}, in which
                  case they will ignore this.                
                <param>
                    component {@code JComponent} that will display the {@code Icon},
                      may be {@code null}                    
                </param>
                <param>
                    icon {@code Icon} to generate the disabled icon from                    
                </param>
                <return>
                    disabled {@code Icon}, or {@code null} if a suitable{@code Icon} can not be generated                    
                </return>
                <since>
                    1.5                    
                </since>
            </javadoc>
            <method name="getDisabledIcon" type="Icon" line="401">
                <params>
                    <param name="component" type="JComponent"/>
                    <param name="icon" type="Icon"/>
                </params>
                <scope line="402"/>
            </method>
            <javadoc line="407">
                Returns an &lt;code&gt;Icon&lt;/code&gt; for use by disabled
                  components that are also selected. This method is used to generate an
                  &lt;code&gt;Icon&lt;/code&gt; for components that are in both the disabled and
                  selected states but do not have a specific &lt;code&gt;Icon&lt;/code&gt; for this
                  state.  For example, if you create a &lt;code&gt;JButton&lt;/code&gt; and only
                  specify an &lt;code&gt;Icon&lt;/code&gt; via &lt;code&gt;setIcon&lt;/code&gt; this method
                  will be called to generate the disabled and selected
                  &lt;code&gt;Icon&lt;/code&gt;. If {@code null} is passed as &lt;code&gt;icon&lt;/code&gt; this
                  methods returns {@code null}.
                  &lt;p&gt;
                  Some look and feels might not render the disabled and selected{@code Icon}, in which case they will ignore this.                
                <param>
                    component {@code JComponent} that will display the {@code Icon},
                      may be {@code null}                    
                </param>
                <param>
                    icon {@code Icon} to generate disabled and selected icon from                    
                </param>
                <return>
                    disabled and selected icon, or {@code null} if a suitable{@code Icon} can not be generated.                    
                </return>
                <since>
                    1.5                    
                </since>
            </javadoc>
            <method name="getDisabledSelectedIcon" type="Icon" line="425">
                <params>
                    <param name="component" type="JComponent"/>
                    <param name="icon" type="Icon"/>
                </params>
            </method>
            <method name="getName" type="String" line="428"/>
            <javadoc line="428">
                Return a short string that identifies this look and feel, e.g.
                  &quot;CDE/Motif&quot;.  This string should be appropriate for a menu item.
                  Distinct look and feels should have different names, e.g.
                  a subclass of MotifLookAndFeel that changes the way a few components
                  are rendered should be called &quot;CDE/Motif My Way&quot;; something
                  that would be useful to a user trying to select a L&amp;F from a list
                  of names.                
                <return>
                    short identifier for the look and feel                    
                </return>
            </javadoc>
            <method name="getID" type="String" line="439"/>
            <javadoc line="439">
                Return a string that identifies this look and feel.  This string
                  will be used by applications/services that want to recognize
                  well known look and feel implementations.  Presently
                  the well known names are &quot;Motif&quot;, &quot;Windows&quot;, &quot;Mac&quot;, &quot;Metal&quot;.  Note
                  that a LookAndFeel derived from a well known superclass
                  that doesn&apos;t make any fundamental changes to the look or feel
                  shouldn&apos;t override this method.                
                <return>
                    identifier for the look and feel                    
                </return>
            </javadoc>
            <method name="getDescription" type="String" line="450"/>
            <javadoc line="450">
                Return a one line description of this look and feel implementation,
                  e.g. &quot;The CDE/Motif Look and Feel&quot;.   This string is intended for
                  the user, e.g. in the title of a window or in a ToolTip message.                
                <return>
                    short description for the look and feel                    
                </return>
            </javadoc>
            <javadoc line="457">
                Returns {@code true} if the &lt;code&gt;LookAndFeel&lt;/code&gt; returned
                  &lt;code&gt;RootPaneUI&lt;/code&gt; instances support providing {@code Window}decorations in a &lt;code&gt;JRootPane&lt;/code&gt;.
                  &lt;p&gt;
                  The default implementation returns {@code false}, subclasses that
                  support {@code Window} decorations should override this and return{@code true}.                
                <return>
                    {@code true} if the {@code RootPaneUI} instances created by
                      this look and feel support client side decorations                    
                </return>
                <see>
                    JDialog#setDefaultLookAndFeelDecorated                    
                </see>
                <see>
                    JFrame#setDefaultLookAndFeelDecorated                    
                </see>
                <see>
                    JRootPane#setWindowDecorationStyle                    
                </see>
                <since>
                    1.4                    
                </since>
            </javadoc>
            <method name="getSupportsWindowDecorations" type="boolean" line="470"/>
            <method name="isNativeLookAndFeel" type="boolean" line="473"/>
            <javadoc line="473">
                If the underlying platform has a &quot;native&quot; look and feel, and
                  this is an implementation of it, return {@code true}.  For
                  example, when the underlying platform is Solaris running CDE
                  a CDE/Motif look and feel implementation would return {@codetrue}.                
                <return>
                    {@code true} if this look and feel represents the underlying
                      platform look and feel                    
                </return>
            </javadoc>
            <method name="isSupportedLookAndFeel" type="boolean" line="482"/>
            <javadoc line="482">
                Return {@code true} if the underlying platform supports and or permits
                  this look and feel.  This method returns {@code false} if the look
                  and feel depends on special resources or legal agreements that
                  aren&apos;t defined for the current platform.                
                <return>
                    {@code true} if this is a supported look and feel                    
                </return>
                <see>
                    UIManager#setLookAndFeel                    
                </see>
            </javadoc>
            <javadoc line="491">
                Initializes the look and feel. While this method is public,
                  it should only be invoked by the {@code UIManager} when a
                  look and feel is installed as the current look and feel. This
                  method is invoked before the {@code UIManager} invokes{@code getDefaults}. This method is intended to perform any
                  initialization for the look and feel. Subclasses
                  should do any one-time setup they need here, rather than
                  in a static initializer, because look and feel class objects
                  may be loaded just to discover that {@code isSupportedLookAndFeel()}returns {@code false}.                
                <see>
                    #uninitialize                    
                </see>
                <see>
                    UIManager#setLookAndFeel                    
                </see>
            </javadoc>
            <method name="initialize" type="void" line="503"/>
            <javadoc line="505">
                Uninitializes the look and feel. While this method is public,
                  it should only be invoked by the {@code UIManager} when
                  the look and feel is uninstalled. For example,{@code UIManager.setLookAndFeel} invokes this when the look and
                  feel is changed.
                  &lt;p&gt;
                  Subclasses may choose to free up some resources here.                
                <see>
                    #initialize                    
                </see>
                <see>
                    UIManager#setLookAndFeel                    
                </see>
            </javadoc>
            <method name="uninitialize" type="void" line="515"/>
            <javadoc line="517">
                Returns the look and feel defaults. While this method is public,
                  it should only be invoked by the {@code UIManager} when the
                  look and feel is set as the current look and feel and after{@code initialize} has been invoked.                
                <return>
                    the look and feel defaults                    
                </return>
                <see>
                    #initialize                    
                </see>
                <see>
                    #uninitialize                    
                </see>
                <see>
                    UIManager#setLookAndFeel                    
                </see>
            </javadoc>
            <method name="getDefaults" type="UIDefaults" line="526"/>
            <javadoc line="529">
                Returns a string that displays and identifies this
                  object&apos;s properties.                
                <return>
                    a String representation of this object                    
                </return>
            </javadoc>
            <method name="toString" type="String" line="534"/>
        </class>
    </source>