<?xml version="1.0" encoding="UTF-8"?>
    <source package="javax.swing.plaf.nimbus">
        <import package="java.awt"/>
        <import package="java.awt.image"/>
        <import package="java.lang.reflect.Method"/>
        <import package="javax.swing"/>
        <import package="javax.swing.plaf.UIResource"/>
        <import package="javax.swing.Painter"/>
        <import package="java.awt.print.PrinterGraphics"/>
        <class name="AbstractRegionPainter" line="35">
            <comment line="58">
                Various metrics used for decoding xy values based on the canvas size
                and stretching insets.
                
                On each call to paint, we first ask the subclass for the PaintContext.
                From the context we get the canvas size and stretching insets, and whether
                the algorithm should be &quot;inverted&quot;, meaning the center section remains
                a fixed size and the other sections scale.
                
                We then use these values to compute a series of metrics (listed below)
                which are used to decode points in a specific axis (x or y).
                
                The leftWidth represents the distance from the left edge of the region
                to the first stretching inset, after accounting for any scaling factor
                (such as DPI scaling). The centerWidth is the distance between the leftWidth
                and the rightWidth. The rightWidth is the distance from the right edge,
                to the right inset (after scaling has been applied).
                
                The same logic goes for topHeight, centerHeight, and bottomHeight.
                
                The leftScale represents the proportion of the width taken by the left section.
                The same logic is applied to the other scales.
                
                The various widthsheights are used to decode control points. The
                various scales are used to decode bezier handles (or anchors).                
            </comment>
            <comment line="577">
                ---------------------- private methods                
            </comment>
            <comment line="579">
                initializes the class to prepare it for being able to decode points                
            </comment>
            <comment line="723">
                convenience method which creates a temporary graphics object by creating a
                clone of the passed in one, configuring it, drawing with it, disposing it.
                These steps have to be taken to ensure that any hints set on the graphics
                are removed subsequent to painting.                
            </comment>
            <implements interface="Painter">
                <type_params>
                    <type_param name="JComponent"/>
                </type_params>
            </implements>
            <javadoc line="35">
                Convenient base class for defining Painter instances for rendering a
                  region or component in Nimbus.                
                <author>
                    Jasper Potts                    
                </author>
                <author>
                    Richard Bair                    
                </author>
            </javadoc>
            <declaration name="ctx" type="PaintContext" line="43"/>
            <javadoc line="43">
                PaintContext, which holds a lot of the state needed for cache hinting and x/y value decoding
                  The data contained within the context is typically only computed once and reused over
                  multiple paint calls, whereas the other values (w, h, f, leftWidth, etc) are recomputed
                  for each call to paint.
                  This field is retrieved from subclasses on each paint operation. It is up
                  to the subclass to compute and cache the PaintContext over multiple calls.                
            </javadoc>
            <declaration name="f" type="float" line="53"/>
            <javadoc line="53">
                The scaling factor. Recomputed on each call to paint.                
            </javadoc>
            <declaration name="leftWidth" type="float" line="83"/>
            <javadoc line="83">
                The width of the left section. Recomputed on each call to paint.                
            </javadoc>
            <declaration name="topHeight" type="float" line="87"/>
            <javadoc line="87">
                The height of the top section. Recomputed on each call to paint.                
            </javadoc>
            <declaration name="centerWidth" type="float" line="91"/>
            <javadoc line="91">
                The width of the center section. Recomputed on each call to paint.                
            </javadoc>
            <declaration name="centerHeight" type="float" line="95"/>
            <javadoc line="95">
                The height of the center section. Recomputed on each call to paint.                
            </javadoc>
            <declaration name="rightWidth" type="float" line="99"/>
            <javadoc line="99">
                The width of the right section. Recomputed on each call to paint.                
            </javadoc>
            <declaration name="bottomHeight" type="float" line="103"/>
            <javadoc line="103">
                The height of the bottom section. Recomputed on each call to paint.                
            </javadoc>
            <declaration name="leftScale" type="float" line="107"/>
            <javadoc line="107">
                The scaling factor to use for the left section. Recomputed on each call to paint.                
            </javadoc>
            <declaration name="topScale" type="float" line="111"/>
            <javadoc line="111">
                The scaling factor to use for the top section. Recomputed on each call to paint.                
            </javadoc>
            <declaration name="centerHScale" type="float" line="115"/>
            <javadoc line="115">
                The scaling factor to use for the center section, in the horizontal
                  direction. Recomputed on each call to paint.                
            </javadoc>
            <declaration name="centerVScale" type="float" line="120"/>
            <javadoc line="120">
                The scaling factor to use for the center section, in the vertical
                  direction. Recomputed on each call to paint.                
            </javadoc>
            <declaration name="rightScale" type="float" line="125"/>
            <javadoc line="125">
                The scaling factor to use for the right section. Recomputed on each call to paint.                
            </javadoc>
            <declaration name="bottomScale" type="float" line="129"/>
            <javadoc line="129">
                The scaling factor to use for the bottom section. Recomputed on each call to paint.                
            </javadoc>
            <javadoc line="134">
                Create a new AbstractRegionPainter                
            </javadoc>
            <method name="AbstractRegionPainter" type="constructor" line="137"/>
            <javadoc line="139">
                @inheritDoc                
            </javadoc>
            <method name="paint" type="void" line="143">
                <params>
                    <param name="g" type="Graphics2D"/>
                    <param name="c" type="JComponent"/>
                    <param name="w" type="int"/>
                    <param name="h" type="int"/>
                </params>
                <comment line="145">
                    don&apos;t render if the width/height are too small                    
                </comment>
                <comment line="154">
                    no caching so paint directly                    
                </comment>
                <comment line="159">
                    9 Square caching                    
                </comment>
                <declaration name="extendedCacheKeys" type="Object[]" line="147"/>
                <declaration name="cacheMode" type="PaintContext.CacheMode" line="149"/>
                <scope line="152"/>
                <scope line="155"/>
                <scope line="157"/>
            </method>
            <javadoc line="163">
                Get any extra attributes which the painter implementation would like
                  to include in the image cache lookups. This is checked for every call
                  of the paint(g, c, w, h) method.                
                <param>
                    c The component on the current paint call                    
                </param>
                <return>
                    Array of extra objects to be included in the cache key                    
                </return>
            </javadoc>
            <method name="getExtendedCacheKeys" type="Object[]" line="171">
                <params>
                    <param name="c" type="JComponent"/>
                </params>
            </method>
            <method name="getPaintContext" type="PaintContext" line="175"/>
            <javadoc line="175">
                &lt;p&gt;Gets the PaintContext for this painting operation. This method is called on every
                  paint, and so should be fast and produce no garbage. The PaintContext contains
                  information such as cache hints. It also contains data necessary for decoding
                  points at runtime, such as the stretching insets, the canvas size at which the
                  encoded points were defined, and whether the stretching insets are inverted.&lt;/p&gt;
                  &lt;p&gt; This method allows for subclasses to package the painting of different states
                  with possibly different canvas sizes, etc, into one AbstractRegionPainter implementation.&lt;/p&gt;                
                <return>
                    a PaintContext associated with this paint operation.                    
                </return>
            </javadoc>
            <javadoc line="189">
                &lt;p&gt;Configures the given Graphics2D. Often, rendering hints or compositiing rules are
                  applied to a Graphics2D object prior to painting, which should affect all of the
                  subsequent painting operations. This method provides a convenient hook for configuring
                  the Graphics object prior to rendering, regardless of whether the render operation is
                  performed to an intermediate buffer or directly to the display.&lt;/p&gt;                
                <param>
                    g The Graphics2D object to configure. Will not be null.                    
                </param>
            </javadoc>
            <method name="configureGraphics" type="void" line="198">
                <params>
                    <param name="g" type="Graphics2D"/>
                </params>
            </method>
            <method name="doPaint" type="void" line="202"/>
            <javadoc line="202">
                Actually performs the painting operation. Subclasses must implement this method.
                  The graphics object passed may represent the actual surface being rendererd to,
                  or it may be an intermediate buffer. It has also been pre-translated. Simply render
                  the component as if it were located at 0, 0 and had a width of &lt;code&gt;width&lt;/code&gt;
                  and a height of &lt;code&gt;height&lt;/code&gt;. For performance reasons, you may want to read
                  the clip from the Graphics2D object and only render within that space.                
                <param>
                    g The Graphics2D surface to paint to                    
                </param>
                <param>
                    c The JComponent related to the drawing event. For example, if the
                      region being rendered is Button, then <code>c</code> will be a
                      JButton. If the region being drawn is ScrollBarSlider, then the
                      component will be JScrollBar. This value may be null.                    
                </param>
                <param>
                    width The width of the region to paint. Note that in the case of
                      painting the foreground, this value may differ from c.getWidth().                    
                </param>
                <param>
                    height The height of the region to paint. Note that in the case of
                      painting the foreground, this value may differ from c.getHeight().                    
                </param>
                <param>
                    extendedCacheKeys The result of the call to getExtendedCacheKeys()                    
                </param>
            </javadoc>
            <javadoc line="224">
                Decodes and returns a float value representing the actual pixel location for
                  the given encoded X value.                
                <param>
                    x an encoded x value (0...1, or 1...2, or 2...3)                    
                </param>
                <return>
                    the decoded x value                    
                </return>
                <throws>
                    IllegalArgumentExceptionif {@code x < 0} or {@code x > 3}                    
                </throws>
            </javadoc>
            <method name="decodeX" type="float" line="233">
                <params>
                    <param name="x" type="float"/>
                </params>
                <scope line="234"/>
                <scope line="236"/>
                <scope line="238"/>
                <scope line="240"/>
            </method>
            <javadoc line="245">
                Decodes and returns a float value representing the actual pixel location for
                  the given encoded y value.                
                <param>
                    y an encoded y value (0...1, or 1...2, or 2...3)                    
                </param>
                <return>
                    the decoded y value                    
                </return>
                <throws>
                    IllegalArgumentExceptionif {@code y < 0} or {@code y > 3}                    
                </throws>
            </javadoc>
            <method name="decodeY" type="float" line="254">
                <params>
                    <param name="y" type="float"/>
                </params>
                <scope line="255"/>
                <scope line="257"/>
                <scope line="259"/>
                <scope line="261"/>
            </method>
            <javadoc line="266">
                Decodes and returns a float value representing the actual pixel location for
                  the anchor point given the encoded X value of the control point, and the offset
                  distance to the anchor from that control point.                
                <param>
                    x an encoded x value of the bezier control point (0...1, or 1...2, or 2...3)                    
                </param>
                <param>
                    dx the offset distance to the anchor from the control point x                    
                </param>
                <return>
                    the decoded x location of the control point                    
                </return>
                <throws>
                    IllegalArgumentExceptionif {@code x < 0} or {@code x > 3}                    
                </throws>
            </javadoc>
            <method name="decodeAnchorX" type="float" line="277">
                <params>
                    <param name="x" type="float"/>
                    <param name="dx" type="float"/>
                </params>
                <scope line="278"/>
                <scope line="280"/>
                <scope line="282"/>
                <scope line="284"/>
            </method>
            <javadoc line="289">
                Decodes and returns a float value representing the actual pixel location for
                  the anchor point given the encoded Y value of the control point, and the offset
                  distance to the anchor from that control point.                
                <param>
                    y an encoded y value of the bezier control point (0...1, or 1...2, or 2...3)                    
                </param>
                <param>
                    dy the offset distance to the anchor from the control point y                    
                </param>
                <return>
                    the decoded y position of the control point                    
                </return>
                <throws>
                    IllegalArgumentExceptionif {@code y < 0} or {@code y > 3}                    
                </throws>
            </javadoc>
            <method name="decodeAnchorY" type="float" line="300">
                <params>
                    <param name="y" type="float"/>
                    <param name="dy" type="float"/>
                </params>
                <scope line="301"/>
                <scope line="303"/>
                <scope line="305"/>
                <scope line="307"/>
            </method>
            <javadoc line="312">
                Decodes and returns a color, which is derived from a base color in UI
                  defaults.                
                <param>
                    key     A key corrosponding to the value in the UI Defaults table
                      of UIManager where the base color is defined                    
                </param>
                <param>
                    hOffset The hue offset used for derivation.                    
                </param>
                <param>
                    sOffset The saturation offset used for derivation.                    
                </param>
                <param>
                    bOffset The brightness offset used for derivation.                    
                </param>
                <param>
                    aOffset The alpha offset used for derivation. Between 0...255                    
                </param>
                <return>
                    The derived color, whos color value will change if the parent
                      uiDefault color changes.                    
                </return>
            </javadoc>
            <method name="decodeColor" type="Color" line="326">
                <params>
                    <param name="key" type="String"/>
                    <param name="hOffset" type="float"/>
                    <param name="sOffset" type="float"/>
                    <param name="bOffset" type="float"/>
                    <param name="aOffset" type="int"/>
                </params>
                <comment line="332">
                    can not give a right answer as painter sould not be used outside
                     of nimbus laf but do the best we can                    
                </comment>
                <scope line="327">
                    <declaration name="laf" type="NimbusLookAndFeel" line="328"/>
                </scope>
                <scope line="330"/>
            </method>
            <javadoc line="337">
                Decodes and returns a color, which is derived from a offset between two
                  other colors.                
                <param>
                    color1   The first color                    
                </param>
                <param>
                    color2   The second color                    
                </param>
                <param>
                    midPoint The offset between color 1 and color 2, a value of 0.0 is
                      color 1 and 1.0 is color 2;                    
                </param>
                <return>
                    The derived color                    
                </return>
            </javadoc>
            <method name="decodeColor" type="Color" line="348">
                <params>
                    <param name="color1" type="Color"/>
                    <param name="color2" type="Color"/>
                    <param name="midPoint" type="float"/>
                </params>
            </method>
            <javadoc line="352">
                Given parameters for creating a LinearGradientPaint, this method will
                  create and return a linear gradient paint. One primary purpose for this
                  method is to avoid creating a LinearGradientPaint where the start and
                  end points are equal. In such a case, the end y point is slightly
                  increased to avoid the overlap.                
                <param>
                    x1                    
                </param>
                <param>
                    y1                    
                </param>
                <param>
                    x2                    
                </param>
                <param>
                    y2                    
                </param>
                <param>
                    midpoints                    
                </param>
                <param>
                    colors                    
                </param>
                <return>
                    a valid LinearGradientPaint. This method never returns null.                    
                </return>
                <throws>
                    NullPointerExceptionif {@code midpoints} array is null,
                      or {@code colors} array is null,                    
                </throws>
                <throws>
                    IllegalArgumentExceptionif start and end points are the same points,
                      or {@code midpoints.length != colors.length},
                      or {@code colors} is less than 2 in size,
                      or a {@code midpoints} value is less than 0.0 or greater than 1.0,
                      or the {@code midpoints} are not provided in strictly increasing order                    
                </throws>
            </javadoc>
            <method name="decodeGradient" type="LinearGradientPaint" line="376">
                <params>
                    <param name="x1" type="float"/>
                    <param name="y1" type="float"/>
                    <param name="x2" type="float"/>
                    <param name="y2" type="float"/>
                    <param name="midpoints" type="float[]"/>
                    <param name="colors" type="Color[]"/>
                </params>
                <scope line="377"/>
            </method>
            <javadoc line="383">
                Given parameters for creating a RadialGradientPaint, this method will
                  create and return a radial gradient paint. One primary purpose for this
                  method is to avoid creating a RadialGradientPaint where the radius
                  is non-positive. In such a case, the radius is just slightly
                  increased to avoid 0.                
                <param>
                    x                    
                </param>
                <param>
                    y                    
                </param>
                <param>
                    r                    
                </param>
                <param>
                    midpoints                    
                </param>
                <param>
                    colors                    
                </param>
                <return>
                    a valid RadialGradientPaint. This method never returns null.                    
                </return>
                <throws>
                    NullPointerExceptionif {@code midpoints} array is null,
                      or {@code colors} array is null                    
                </throws>
                <throws>
                    IllegalArgumentExceptionif {@code r} is non-positive,
                      or {@code midpoints.length != colors.length},
                      or {@code colors} is less than 2 in size,
                      or a {@code midpoints} value is less than 0.0 or greater than 1.0,
                      or the {@code midpoints} are not provided in strictly increasing order                    
                </throws>
            </javadoc>
            <method name="decodeRadialGradient" type="RadialGradientPaint" line="406">
                <params>
                    <param name="x" type="float"/>
                    <param name="y" type="float"/>
                    <param name="r" type="float"/>
                    <param name="midpoints" type="float[]"/>
                    <param name="colors" type="Color[]"/>
                </params>
                <scope line="407"/>
            </method>
            <javadoc line="413">
                Get a color property from the given JComponent. First checks for a
                  &lt;code&gt;getXXX()&lt;/code&gt; method and if that fails checks for a client
                  property with key &lt;code&gt;property&lt;/code&gt;. If that still fails to return
                  a Color then &lt;code&gt;defaultColor&lt;/code&gt; is returned.                
                <param>
                    c The component to get the color property from                    
                </param>
                <param>
                    property The name of a bean style property or client property                    
                </param>
                <param>
                    defaultColor The color to return if no color was obtained from
                      the component.                    
                </param>
                <return>
                    The color that was obtained from the component or defaultColor                    
                </return>
            </javadoc>
            <method name="getComponentColor" type="Color" line="429">
                <params>
                    <param name="c" type="JComponent"/>
                    <param name="property" type="String"/>
                    <param name="defaultColor" type="Color"/>
                    <param name="saturationOffset" type="float"/>
                    <param name="brightnessOffset" type="float"/>
                    <param name="alphaOffset" type="int"/>
                </params>
                <comment line="433">
                    handle some special cases for performance                    
                </comment>
                <comment line="452">
                    don&apos;t do anything, it just didn&apos;t work, that&apos;s all.
                    This could be a normal occurance if you use a property
                    name referring to a key in clientProperties instead of
                    a real property                    
                </comment>
                <comment line="465">
                    we return the defaultColor if the color found is null, or if
                     it is a UIResource. This is done because the color for the
                     ENABLED state is set on the component, but you don&apos;t want to use
                     that color for the over state. So we only respect the color
                     specified for the property if it was set by the user, as opposed
                     to set by us.                    
                </comment>
                <declaration name="color" type="Color" line="430"/>
                <scope line="431">
                    <scope line="433"/>
                    <scope line="435"/>
                    <scope line="437"/>
                    <scope line="439"/>
                    <scope line="441"/>
                    <scope line="443"/>
                    <scope line="445">
                        <declaration name="s" type="String" line="446"/>
                        <scope line="447">
                            <declaration name="method" type="Method" line="448"/>
                        </scope>
                        <scope line="450"/>
                        <scope line="456">
                            <declaration name="value" type="Object" line="457"/>
                            <scope line="458"/>
                        </scope>
                    </scope>
                </scope>
                <scope line="470"/>
                <scope line="472">
                    <declaration name="tmp" type="float[]" line="473"/>
                    <declaration name="alpha" type="int" line="476"/>
                </scope>
                <scope line="478"/>
            </method>
            <class name="PaintContext" line="483">
                <comment line="504">
                    insets.left                    
                </comment>
                <comment line="505">
                    canvasSize.width - insets.right                    
                </comment>
                <comment line="506">
                    insets.top                    
                </comment>
                <comment line="507">
                    canvasSize.height - insets.bottom;                    
                </comment>
                <comment line="508">
                    only used if inverted == true                    
                </comment>
                <comment line="509">
                    only used if inverted == true                    
                </comment>
                <comment line="510">
                    only used if inverted == true                    
                </comment>
                <comment line="511">
                    only used if inverted == true                    
                </comment>
                <javadoc line="483">
                    A class encapsulating state useful when painting. Generally, instances of this
                      class are created once, and reused for each paint request without modification.
                      This class contains values useful when hinting the cache engine, and when decoding
                      control points and bezier curve anchors.                    
                </javadoc>
                <declaration name="EMPTY_INSETS" type="Insets" line="494"/>
                <declaration name="stretchingInsets" type="Insets" line="496"/>
                <declaration name="canvasSize" type="Dimension" line="497"/>
                <declaration name="inverted" type="boolean" line="498"/>
                <declaration name="cacheMode" type="CacheMode" line="499"/>
                <declaration name="maxHorizontalScaleFactor" type="double" line="500"/>
                <declaration name="maxVerticalScaleFactor" type="double" line="501"/>
                <declaration name="a" type="float" line="503"/>
                <declaration name="b" type="float" line="504"/>
                <declaration name="c" type="float" line="505"/>
                <declaration name="d" type="float" line="506"/>
                <declaration name="aPercent" type="float" line="507"/>
                <declaration name="bPercent" type="float" line="508"/>
                <declaration name="cPercent" type="float" line="509"/>
                <declaration name="dPercent" type="float" line="510"/>
                <javadoc line="512">
                    Creates a new PaintContext which does not attempt to cache or scale any cached
                      images.                    
                    <param>
                        insets The stretching insets. May be null. If null, then assumed to be 0, 0, 0, 0.                        
                    </param>
                    <param>
                        canvasSize The size of the canvas used when encoding the various x/y values. May be null.
                          If null, then it is assumed that there are no encoded values, and any calls
                          to one of the "decode" methods will return the passed in value.                        
                    </param>
                    <param>
                        inverted Whether to "invert" the meaning of the 9-square grid and stretching insets                        
                    </param>
                </javadoc>
                <method name="PaintContext" type="constructor" line="522">
                    <params>
                        <param name="insets" type="Insets"/>
                        <param name="canvasSize" type="Dimension"/>
                        <param name="inverted" type="boolean"/>
                    </params>
                </method>
                <javadoc line="526">
                    Creates a new PaintContext.                    
                    <param>
                        insets The stretching insets. May be null. If null, then assumed to be 0, 0, 0, 0.                        
                    </param>
                    <param>
                        canvasSize The size of the canvas used when encoding the various x/y values. May be null.
                          If null, then it is assumed that there are no encoded values, and any calls
                          to one of the "decode" methods will return the passed in value.                        
                    </param>
                    <param>
                        inverted Whether to "invert" the meaning of the 9-square grid and stretching insets                        
                    </param>
                    <param>
                        cacheMode A hint as to which caching mode to use. If null, then set to no caching.                        
                    </param>
                    <param>
                        maxH The maximium scale in the horizontal direction to use before punting and redrawing from scratch.
                          For example, if maxH is 2, then we will attempt to scale any cached images up to 2x the canvas
                          width before redrawing from scratch. Reasonable maxH values may improve painting performance.
                          If set too high, then you may get poor looking graphics at higher zoom levels. Must be >= 1.                        
                    </param>
                    <param>
                        maxV The maximium scale in the vertical direction to use before punting and redrawing from scratch.
                          For example, if maxV is 2, then we will attempt to scale any cached images up to 2x the canvas
                          height before redrawing from scratch. Reasonable maxV values may improve painting performance.
                          If set too high, then you may get poor looking graphics at higher zoom levels. Must be >= 1.                        
                    </param>
                </javadoc>
                <method name="PaintContext" type="constructor" line="545">
                    <params>
                        <param name="insets" type="Insets"/>
                        <param name="canvasSize" type="Dimension"/>
                        <param name="inverted" type="boolean"/>
                        <param name="cacheMode" type="CacheMode"/>
                        <param name="maxH" type="double"/>
                        <param name="maxV" type="double"/>
                    </params>
                    <scope line="546"/>
                    <scope line="557">
                        <scope line="564">
                            <declaration name="available" type="float" line="565"/>
                        </scope>
                    </scope>
                </method>
            </class>
            <method name="prepare" type="void" line="579">
                <params>
                    <param name="w" type="float"/>
                    <param name="h" type="float"/>
                </params>
                <comment line="581">
                    if no PaintContext has been specified, reset the values and bail
                    also bail if the canvasSize was not set (since decoding will not work)                    
                </comment>
                <comment line="592">
                    calculate the scaling factor, and the sizes for the various 9-square sections                    
                </comment>
                <scope line="582"/>
                <declaration name="scale" type="Number" line="592"/>
                <scope line="595">
                    <declaration name="availableSpace" type="float" line="597"/>
                </scope>
                <scope line="604"/>
            </method>
            <method name="paintWith9SquareCaching" type="void" line="623">
                <params>
                    <param name="g" type="Graphics2D"/>
                    <param name="ctx" type="PaintContext"/>
                    <param name="c" type="JComponent"/>
                    <param name="w" type="int"/>
                    <param name="h" type="int"/>
                    <param name="extendedCacheKeys" type="Object[]"/>
                </params>
                <comment line="625">
                    check if we can scale to the requested size                    
                </comment>
                <comment line="630">
                    get image at canvas size                    
                </comment>
                <comment line="633">
                    calculate dst inserts
                     todo: destination inserts need to take into acount scale factor for high dpi. Note: You can use f for this, I think                    
                </comment>
                <comment line="643">
                    paint 9 square scaled                    
                </comment>
                <comment line="651">
                    render directly                    
                </comment>
                <comment line="655">
                    paint directly                    
                </comment>
                <declaration name="canvas" type="Dimension" line="625"/>
                <declaration name="insets" type="Insets" line="626"/>
                <scope line="628">
                    <declaration name="img" type="VolatileImage" line="630"/>
                    <scope line="631">
                        <declaration name="dstInsets" type="Insets" line="634"/>
                        <scope line="635">
                            <declaration name="leftRight" type="int" line="636"/>
                            <declaration name="topBottom" type="int" line="637"/>
                        </scope>
                        <scope line="639"/>
                        <declaration name="oldScaleingHints" type="Object" line="643"/>
                    </scope>
                    <scope line="649"/>
                </scope>
                <scope line="653"/>
            </method>
            <method name="paintWithFixedSizeCaching" type="void" line="660">
                <params>
                    <param name="g" type="Graphics2D"/>
                    <param name="c" type="JComponent"/>
                    <param name="w" type="int"/>
                    <param name="h" type="int"/>
                    <param name="extendedCacheKeys" type="Object[]"/>
                </params>
                <comment line="664">
                    render cached image                    
                </comment>
                <comment line="667">
                    render directly                    
                </comment>
                <declaration name="img" type="VolatileImage" line="661"/>
                <scope line="662"/>
                <scope line="665"/>
            </method>
            <javadoc line="671">
                Gets the rendered image for this painter at the requested size, either from cache or create a new one                
            </javadoc>
            <method name="getImage" type="VolatileImage" line="673">
                <params>
                    <param name="config" type="GraphicsConfiguration"/>
                    <param name="c" type="JComponent"/>
                    <param name="w" type="int"/>
                    <param name="h" type="int"/>
                    <param name="extendedCacheKeys" type="Object[]"/>
                </params>
                <comment line="676">
                    get the buffer for this component                    
                </comment>
                <comment line="679">
                    to avoid any potential, though unlikely, infinite loop                    
                </comment>
                <comment line="681">
                    validate the buffer so we can check for surface loss                    
                </comment>
                <comment line="687">
                    If the buffer status is incompatible or restored, then we need to re-render to the volatile image                    
                </comment>
                <comment line="689">
                    if the buffer is null (hasn&apos;t been created), or isn&apos;t the right size, or has lost its contents,
                    then recreate the buffer                    
                </comment>
                <comment line="693">
                    clear any resources related to the old back buffer                    
                </comment>
                <comment line="698">
                    recreate the buffer                    
                </comment>
                <comment line="701">
                    put in cache for future                    
                </comment>
                <comment line="704">
                    create the graphics context with which to paint to the buffer                    
                </comment>
                <comment line="706">
                    clear the background before configuring the graphics                    
                </comment>
                <comment line="711">
                    paint the painter into buffer                    
                </comment>
                <comment line="713">
                    close buffer graphics                    
                </comment>
                <comment line="717">
                    check if we failed                    
                </comment>
                <comment line="719">
                    return image                    
                </comment>
                <declaration name="imageCache" type="ImageCache" line="674"/>
                <declaration name="buffer" type="VolatileImage" line="676"/>
                <declaration name="renderCounter" type="int" line="678"/>
                <scope line="679">
                    <declaration name="bufferStatus" type="int" line="681"/>
                    <scope line="682"/>
                    <scope line="687">
                        <scope line="691">
                            <scope line="693"/>
                        </scope>
                        <declaration name="bg" type="Graphics2D" line="704"/>
                    </scope>
                </scope>
            </method>
            <method name="paint0" type="void" line="727">
                <params>
                    <param name="g" type="Graphics2D"/>
                    <param name="c" type="JComponent"/>
                    <param name="width" type="int"/>
                    <param name="height" type="int"/>
                    <param name="extendedCacheKeys" type="Object[]"/>
                </params>
            </method>
            <method name="clamp" type="float" line="735">
                <params>
                    <param name="value" type="float"/>
                </params>
                <scope line="736"/>
                <scope line="738"/>
            </method>
            <method name="clamp" type="int" line="744">
                <params>
                    <param name="value" type="int"/>
                </params>
                <scope line="745"/>
                <scope line="747"/>
            </method>
        </class>
    </source>