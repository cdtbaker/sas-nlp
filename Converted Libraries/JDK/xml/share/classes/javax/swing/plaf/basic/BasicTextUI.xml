<?xml version="1.0" encoding="UTF-8"?>
    <source package="javax.swing.plaf.basic">
        <import package="java.util"/>
        <import package="java.awt"/>
        <import package="java.awt.event"/>
        <import package="java.awt.datatransfer"/>
        <import package="java.awt.im.InputContext"/>
        <import package="java.beans"/>
        <import package="java.io"/>
        <import package="javax.swing"/>
        <import package="javax.swing.plaf"/>
        <import package="javax.swing.text"/>
        <import package="javax.swing.event"/>
        <import package="javax.swing.border.Border"/>
        <import package="javax.swing.plaf.UIResource"/>
        <import package="javax.swing.plaf.synth.SynthUI"/>
        <import package="sun.swing.DefaultLookup"/>
        <import package="sun.awt.AppContext"/>
        <import package="javax.swing.plaf.basic.DragRecognitionSupport.BeforeDrag"/>
        <class name="BasicTextUI" line="45">
            <extends class="TextUI"/>
            <comment line="753">
                --- ComponentUI methods --------------------------------------------                
            </comment>
            <comment line="984">
                ---- TextUI methods -------------------------------------------                
            </comment>
            <comment line="1253">
                --- ViewFactory methods ------------------------------                
            </comment>
            <comment line="1300">
                ----- member variables ---------------------------------------                
            </comment>
            <implements interface="ViewFactory"/>
            <javadoc line="45">
                &lt;p&gt;
                  Basis of a text components look-and-feel.  This provides the
                  basic editor view and controller services that may be useful
                  when creating a look-and-feel for an extension of
                  &lt;code&gt;JTextComponent&lt;/code&gt;.
                  &lt;p&gt;
                  Most state is held in the associated &lt;code&gt;JTextComponent&lt;/code&gt;
                  as bound properties, and the UI installs default values for the
                  various properties.  This default will install something for
                  all of the properties.  Typically, a LAF implementation will
                  do more however.  At a minimum, a LAF would generally install
                  key bindings.
                  &lt;p&gt;
                  This class also provides some concurrency support if the
                  &lt;code&gt;Document&lt;/code&gt; associated with the JTextComponent is a subclass of
                  &lt;code&gt;AbstractDocument&lt;/code&gt;.  Access to the View (or View hierarchy) is
                  serialized between any thread mutating the model and the Swing
                  event thread (which is expected to render, do model/view coordinate
                  translation, etc).  &lt;em&gt;Any access to the root view should first
                  acquire a read-lock on the AbstractDocument and release that lock
                  in a finally block.&lt;/em&gt;
                  &lt;p&gt;
                  An important method to define is the {@link #getPropertyPrefix} method
                  which is used as the basis of the keys used to fetch defaults
                  from the UIManager.  The string should reflect the type of
                  TextUI (eg. TextField, TextArea, etc) without the particular
                  LAF part of the name (eg Metal, Motif, etc).
                  &lt;p&gt;
                  To build a view of the model, one of the following strategies
                  can be employed.
                  &lt;ol&gt;
                  &lt;li&gt;
                  One strategy is to simply redefine the
                  ViewFactory interface in the UI.  By default, this UI itself acts
                  as the factory for View implementations.  This is useful
                  for simple factories.  To do this reimplement the{@link #create} method.
                  &lt;li&gt;
                  A common strategy for creating more complex types of documents
                  is to have the EditorKit implementation return a factory.  Since
                  the EditorKit ties all of the pieces necessary to maintain a type
                  of document, the factory is typically an important part of that
                  and should be produced by the EditorKit implementation.
                  &lt;/ol&gt;
                  &lt;p&gt;
                  &lt;strong&gt;Warning:&lt;/strong&gt;
                  Serialized objects of this class will not be compatible with
                  future Swing releases. The current serialization support is
                  appropriate for short term storage or RMI between applications running
                  the same version of Swing.  As of 1.4, support for long term storage
                  of all JavaBeans&lt;sup&gt;&lt;font size=&quot;-2&quot;&gt;TM&lt;/font&gt;&lt;/sup&gt;
                  has been added to the &lt;code&gt;java.beans&lt;/code&gt; package.
                  Please see {@link java.beans.XMLEncoder}.                
                <author>
                    Timothy Prinzing                    
                </author>
                <author>
                    Shannon Hickey (drag and drop)                    
                </author>
            </javadoc>
            <javadoc line="105">
                Creates a new UI.                
            </javadoc>
            <method name="BasicTextUI" type="constructor" line="108"/>
            <javadoc line="112">
                Creates the object to use for a caret.  By default an
                  instance of BasicCaret is created.  This method
                  can be redefined to provide something else that implements
                  the InputPosition interface or a subclass of JCaret.                
                <return>
                    the caret object                    
                </return>
            </javadoc>
            <method name="createCaret" type="Caret" line="120"/>
            <javadoc line="124">
                Creates the object to use for adding highlights.  By default
                  an instance of BasicHighlighter is created.  This method
                  can be redefined to provide something else that implements
                  the Highlighter interface or a subclass of DefaultHighlighter.                
                <return>
                    the highlighter                    
                </return>
            </javadoc>
            <method name="createHighlighter" type="Highlighter" line="132"/>
            <javadoc line="136">
                Fetches the name of the keymap that will be installed/used
                  by default for this UI. This is implemented to create a
                  name based upon the classname.  The name is the the name
                  of the class with the package prefix removed.                
                <return>
                    the name                    
                </return>
            </javadoc>
            <method name="getKeymapName" type="String" line="144">
                <declaration name="nm" type="String" line="145"/>
                <declaration name="index" type="int" line="146"/>
                <scope line="147"/>
            </method>
            <javadoc line="153">
                Creates the keymap to use for the text component, and installs
                  any necessary bindings into it.  By default, the keymap is
                  shared between all instances of this type of TextUI. The
                  keymap has the name defined by the getKeymapName method.  If the
                  keymap is not found, then DEFAULT_KEYMAP from JTextComponent is used.
                  &lt;p&gt;
                  The set of bindings used to create the keymap is fetched
                  from the UIManager using a key formed by combining the{@link #getPropertyPrefix} method
                  and the string &lt;code&gt;.keyBindings&lt;/code&gt;.  The type is expected
                  to be &lt;code&gt;JTextComponent.KeyBinding[]&lt;/code&gt;.                
                <return>
                    the keymap                    
                </return>
                <see>
                    #getKeymapName                    
                </see>
                <see>
                    javax.swing.text.JTextComponent                    
                </see>
            </javadoc>
            <method name="createKeymap" type="Keymap" line="170">
                <declaration name="nm" type="String" line="171"/>
                <declaration name="map" type="Keymap" line="172"/>
                <scope line="173">
                    <declaration name="parent" type="Keymap" line="174"/>
                    <declaration name="prefix" type="String" line="176"/>
                    <declaration name="o" type="Object" line="177"/>
                    <scope line="179">
                        <declaration name="bindings" type="JTextComponent.KeyBinding[]" line="180"/>
                    </scope>
                </scope>
            </method>
            <javadoc line="187">
                This method gets called when a bound property is changed
                  on the associated JTextComponent.  This is a hook
                  which UI implementations may change to reflect how the
                  UI displays bound properties of JTextComponent subclasses.
                  This is implemented to do nothing (i.e. the response to
                  properties in JTextComponent itself are handled prior
                  to calling this method).
                  This implementation updates the background of the text
                  component if the editable and/or enabled state changes.                
                <param>
                    evt the property change event                    
                </param>
            </javadoc>
            <method name="propertyChange" type="void" line="201">
                <params>
                    <param name="evt" type="PropertyChangeEvent"/>
                </params>
                <scope line="203"/>
            </method>
            <javadoc line="209">
                Updates the background of the text component based on whether the
                  text component is editable and/or enabled.                
                <param>
                    c the JTextComponent that needs its background color updated                    
                </param>
            </javadoc>
            <method name="updateBackground" type="void" line="215">
                <params>
                    <param name="c" type="JTextComponent"/>
                </params>
                <comment line="217">
                    This is a temporary workaround.
                     This code does not correctly deal with Synth (Synth doesn&apos;t use
                     properties like this), nor does it deal with the situation where
                     the developer grabs the color from a JLabel and sets it as
                     the background for a JTextArea in all look and feels. The problem
                     scenario results if the Color obtained for the Label and TextArea
                     is ==, which is the case for the windows look and feel.
                     Until an appropriate solution is found, the code is being
                     reverted to what it was before the original fix.                    
                </comment>
                <comment line="240">
                    In an ideal situation, the following check would not be necessary
                     and we would replace the color any time the previous color was a
                     UIResouce. However, it turns out that there is existing code that
                     uses the following inadvisable pattern to turn a text area into
                     what appears to be a multi-line label:
                    
                     JLabel label = new JLabel();
                     JTextArea area = new JTextArea();
                     area.setBackground(label.getBackground());
                     area.setEditable(false);
                    
                     JLabel&apos;s default background is a UIResource. As such, just
                     checking for UIResource would have us always changing the
                     background away from what the developer wanted.
                    
                     Therefore, for JTextAreaJEditorPane, we&apos;ll additionally check
                     that the color we&apos;re about to replace matches one that was
                     installed by us from the UIDefaults.                    
                </comment>
                <scope line="225"/>
                <declaration name="background" type="Color" line="228"/>
                <scope line="229">
                    <declaration name="prefix" type="String" line="230"/>
                    <declaration name="disabledBG" type="Color" line="232"/>
                    <declaration name="inactiveBG" type="Color" line="234"/>
                    <declaration name="bg" type="Color" line="236"/>
                    <scope line="261"/>
                    <declaration name="newColor" type="Color" line="266"/>
                    <scope line="267"/>
                    <scope line="270"/>
                    <scope line="273"/>
                    <scope line="276"/>
                </scope>
            </method>
            <method name="getPropertyPrefix" type="String" line="282"/>
            <javadoc line="282">
                Gets the name used as a key to look up properties through the
                  UIManager.  This is used as a prefix to all the standard
                  text properties.                
                <return>
                    the name                    
                </return>
            </javadoc>
            <javadoc line="291">
                Initializes component properties, such as font, foreground,
                  background, caret color, selection color, selected text color,
                  disabled text color, and border color.  The font, foreground, and
                  background properties are only set if their current value is either null
                  or a UIResource, other properties are set if the current
                  value is null.                
                <see>
                    #uninstallDefaults                    
                </see>
                <see>
                    #installUI                    
                </see>
            </javadoc>
            <method name="installDefaults" type="void" line="303">
                <declaration name="prefix" type="String" line="304"/>
                <declaration name="f" type="Font" line="305"/>
                <scope line="306"/>
                <declaration name="bg" type="Color" line="310"/>
                <scope line="311"/>
                <declaration name="fg" type="Color" line="315"/>
                <scope line="316"/>
                <declaration name="color" type="Color" line="320"/>
                <scope line="321"/>
                <declaration name="s" type="Color" line="325"/>
                <scope line="326"/>
                <declaration name="sfg" type="Color" line="330"/>
                <scope line="331"/>
                <declaration name="dfg" type="Color" line="335"/>
                <scope line="336"/>
                <declaration name="b" type="Border" line="340"/>
                <scope line="341"/>
                <declaration name="margin" type="Insets" line="345"/>
                <scope line="346"/>
            </method>
            <method name="installDefaults2" type="void" line="353">
                <declaration name="prefix" type="String" line="357"/>
                <declaration name="caret" type="Caret" line="359"/>
                <scope line="360">
                    <declaration name="rate" type="int" line="364"/>
                </scope>
                <declaration name="highlighter" type="Highlighter" line="368"/>
                <scope line="369"/>
                <declaration name="th" type="TransferHandler" line="373"/>
                <scope line="374"/>
            </method>
            <javadoc line="379">
                Sets the component properties that have not been explicitly overridden
                  to {@code null}.  A property is considered overridden if its current
                  value is not a {@code UIResource}.                
                <see>
                    #installDefaults                    
                </see>
                <see>
                    #uninstallUI                    
                </see>
            </javadoc>
            <method name="uninstallDefaults" type="void" line="388">
                <scope line="392"/>
                <scope line="396"/>
                <scope line="400"/>
                <scope line="404"/>
                <scope line="408"/>
                <scope line="412"/>
                <scope line="416"/>
                <scope line="420"/>
                <scope line="424"/>
                <scope line="428"/>
            </method>
            <javadoc line="433">
                Installs listeners for the UI.                
            </javadoc>
            <method name="installListeners" type="void" line="436"/>
            <javadoc line="439">
                Uninstalls listeners for the UI.                
            </javadoc>
            <method name="uninstallListeners" type="void" line="442"/>
            <method name="installKeyboardActions" type="void" line="445">
                <comment line="447">
                    backward compatibility support... keymaps for the UI
                     are now installed in the more friendly input map.                    
                </comment>
                <declaration name="km" type="InputMap" line="450"/>
                <scope line="451"/>
                <declaration name="map" type="ActionMap" line="456"/>
                <scope line="457"/>
            </method>
            <javadoc line="464">
                Get the InputMap to use for the UI.                
            </javadoc>
            <method name="getInputMap" type="InputMap" line="467">
                <declaration name="map" type="InputMap" line="468"/>
                <declaration name="shared" type="InputMap" line="470"/>
                <scope line="473"/>
            </method>
            <javadoc line="479">
                Invoked when the focus accelerator changes, this will update the
                  key bindings as necessary.                
            </javadoc>
            <method name="updateFocusAcceleratorBinding" type="void" line="483">
                <params>
                    <param name="changed" type="boolean"/>
                </params>
                <declaration name="accelerator" type="char" line="484"/>
                <scope line="486">
                    <declaration name="km" type="InputMap" line="487"/>
                    <scope line="490">
                        <declaration name="am" type="ActionMap" line="494"/>
                    </scope>
                    <scope line="497">
                        <scope line="499"/>
                    </scope>
                </scope>
            </method>
            <javadoc line="509">
                Invoked when editable property is changed.
                  removing &apos;TAB&apos; and &apos;SHIFT-TAB&apos; from traversalKeysSet in case
                  editor is editable
                  adding &apos;TAB&apos; and &apos;SHIFT-TAB&apos; to traversalKeysSet in case
                  editor is non editable                
            </javadoc>
            <method name="updateFocusTraversalKeys" type="void" line="518">
                <comment line="520">
                    Fix for 4514331 Non-editable JTextArea and similar
                     should allow Tab to keyboard - accessibility                    
                </comment>
                <declaration name="editorKit" type="EditorKit" line="523"/>
                <scope line="525">
                    <declaration name="storedForwardTraversalKeys" type="Set&lt;AWTKeyStroke&gt;" line="526"/>
                    <declaration name="storedBackwardTraversalKeys" type="Set&lt;AWTKeyStroke&gt;" line="529"/>
                    <declaration name="forwardTraversalKeys" type="Set&lt;AWTKeyStroke&gt;" line="532"/>
                    <declaration name="backwardTraversalKeys" type="Set&lt;AWTKeyStroke&gt;" line="534"/>
                    <scope line="536"/>
                    <scope line="542"/>
                </scope>
            </method>
            <javadoc line="559">
                As needed updates cursor for the target editor.                
            </javadoc>
            <method name="updateCursor" type="void" line="562">
                <scope line="564">
                    <declaration name="cursor" type="Cursor" line="565"/>
                </scope>
            </method>
            <javadoc line="570">
                Returns the &lt;code&gt;TransferHandler&lt;/code&gt; that will be installed if
                  their isn&apos;t one installed on the &lt;code&gt;JTextComponent&lt;/code&gt;.                
            </javadoc>
            <method name="getTransferHandler" type="TransferHandler" line="574"/>
            <javadoc line="578">
                Fetch an action map to use.                
            </javadoc>
            <method name="getActionMap" type="ActionMap" line="581">
                <comment line="594">
                    fix for bug 4515750
                     JTextField &amp; non-editable JTextArea bind return key - default btn not accessible
                    
                     Wrap the return action so that it is only enabled when the
                     component is editable. This allows the default button to be
                     processed when the text component has focus and isn&apos;t editable.                    
                </comment>
                <declaration name="mapName" type="String" line="582"/>
                <declaration name="map" type="ActionMap" line="583"/>
                <scope line="585">
                    <scope line="587"/>
                </scope>
                <declaration name="componentMap" type="ActionMap" line="591"/>
                <scope line="602">
                    <scope line="603">
                        <declaration name="obj" type="Object" line="604"/>
                        <scope line="606">
                            <declaration name="action" type="Action" line="607"/>
                        </scope>
                    </scope>
                </scope>
                <scope line="612"/>
            </method>
            <javadoc line="618">
                Create a default action map.  This is basically the
                  set of actions found exported by the component.                
            </javadoc>
            <method name="createActionMap" type="ActionMap" line="622">
                <comment line="626">
                    System.out.println(&quot;building map for UI: &quot; + getPropertyPrefix());                    
                </comment>
                <comment line="631">
                    System.out.println(&quot;  &quot; + a.getValue(Action.NAME));                    
                </comment>
                <declaration name="map" type="ActionMap" line="623"/>
                <declaration name="actions" type="Action[]" line="624"/>
                <declaration name="n" type="int" line="626"/>
                <scope line="627">
                    <declaration name="a" type="Action" line="628"/>
                </scope>
            </method>
            <method name="uninstallKeyboardActions" type="void" line="641"/>
            <javadoc line="648">
                Paints a background for the view.  This will only be
                  called if isOpaque() on the associated component is
                  true.  The default is to paint the background color
                  of the component.                
                <param>
                    g the graphics context                    
                </param>
            </javadoc>
            <method name="paintBackground" type="void" line="656">
                <params>
                    <param name="g" type="Graphics"/>
                </params>
            </method>
            <javadoc line="661">
                Fetches the text component associated with this
                  UI implementation.  This will be null until
                  the ui has been installed.                
                <return>
                    the editor component                    
                </return>
            </javadoc>
            <method name="getComponent" type="JTextComponent" line="668"/>
            <javadoc line="672">
                Flags model changes.
                  This is called whenever the model has changed.
                  It is implemented to rebuild the view hierarchy
                  to represent the default root element of the
                  associated model.                
            </javadoc>
            <method name="modelChanged" type="void" line="679">
                <comment line="681">
                    create a view hierarchy                    
                </comment>
                <declaration name="f" type="ViewFactory" line="681"/>
                <declaration name="doc" type="Document" line="682"/>
                <declaration name="elem" type="Element" line="683"/>
            </method>
            <javadoc line="687">
                Sets the current root of the view hierarchy and calls invalidate().
                  If there were any child components, they will be removed (i.e.
                  there are assumed to have come from components embedded in views).                
                <param>
                    v the root view                    
                </param>
            </javadoc>
            <method name="setView" type="void" line="694">
                <params>
                    <param name="v" type="View"/>
                </params>
            </method>
            <javadoc line="701">
                Paints the interface safely with a guarantee that
                  the model won&apos;t change from the view of this thread.
                  This does the following things, rendering from
                  back to front.
                  &lt;ol&gt;
                  &lt;li&gt;
                  If the component is marked as opaque, the background
                  is painted in the current background color of the
                  component.
                  &lt;li&gt;
                  The highlights (if any) are painted.
                  &lt;li&gt;
                  The view hierarchy is painted.
                  &lt;li&gt;
                  The caret is painted.
                  &lt;/ol&gt;                
                <param>
                    g the graphics context                    
                </param>
            </javadoc>
            <method name="paintSafely" type="void" line="721">
                <params>
                    <param name="g" type="Graphics"/>
                </params>
                <comment line="727">
                    paint the background                    
                </comment>
                <comment line="732">
                    paint the highlights                    
                </comment>
                <comment line="737">
                    paint the view hierarchy                    
                </comment>
                <comment line="743">
                    paint the caret                    
                </comment>
                <declaration name="highlighter" type="Highlighter" line="723"/>
                <declaration name="caret" type="Caret" line="724"/>
                <scope line="727"/>
                <scope line="732"/>
                <declaration name="alloc" type="Rectangle" line="737"/>
                <scope line="738"/>
                <scope line="743"/>
                <scope line="747"/>
            </method>
            <javadoc line="754">
                Installs the UI for a component.  This does the following
                  things.
                  &lt;ol&gt;
                  &lt;li&gt;
                  Sets the associated component to opaque if the opaque property
                  has not already been set by the client program. This will cause the
                  component&apos;s background color to be painted.
                  &lt;li&gt;
                  Installs the default caret and highlighter into the
                  associated component. These properties are only set if their
                  current value is either {@code null} or an instance of{@link UIResource}.
                  &lt;li&gt;
                  Attaches to the editor and model.  If there is no
                  model, a default one is created.
                  &lt;li&gt;
                  Creates the view factory and the view hierarchy used
                  to represent the model.
                  &lt;/ol&gt;                
                <param>
                    c the editor component                    
                </param>
                <see>
                    ComponentUI#installUI                    
                </see>
            </javadoc>
            <method name="installUI" type="void" line="778">
                <params>
                    <param name="c" type="JComponent"/>
                </params>
                <comment line="783">
                    common case is background painted... this can
                     easily be changed by subclasses or from outside
                     of the component.                    
                </comment>
                <comment line="789">
                    install defaults                    
                </comment>
                <comment line="793">
                    attach to the model and editor                    
                </comment>
                <comment line="797">
                    no model, create a default one.  This will
                     fire a notification to the updateHandler
                     which takes care of the rest.                    
                </comment>
                <comment line="806">
                    install keymap                    
                </comment>
                <comment line="812">
                    by default, use default LayoutManger implementation that
                     will position the components associated with a View object.                    
                </comment>
                <scope line="779">
                    <declaration name="doc" type="Document" line="794"/>
                    <scope line="795"/>
                    <scope line="800"/>
                    <declaration name="oldLayout" type="LayoutManager" line="809"/>
                    <scope line="810"/>
                </scope>
                <scope line="817"/>
            </method>
            <javadoc line="822">
                Deinstalls the UI for a component.  This removes the listeners,
                  uninstalls the highlighter, removes views, and nulls out the keymap.                
                <param>
                    c the editor component                    
                </param>
                <see>
                    ComponentUI#uninstallUI                    
                </see>
            </javadoc>
            <method name="uninstallUI" type="void" line="829">
                <params>
                    <param name="c" type="JComponent"/>
                </params>
                <comment line="831">
                    detach from the model                    
                </comment>
                <comment line="835">
                    view part                    
                </comment>
                <comment line="845">
                    controller part                    
                </comment>
                <declaration name="lm" type="LayoutManager" line="839"/>
                <scope line="840"/>
            </method>
            <javadoc line="851">
                Superclass paints background in an uncontrollable way
                  (i.e. one might want an image tiled into the background).
                  To prevent this from happening twice, this method is
                  reimplemented to simply paint.
                  &lt;p&gt;
                  &lt;em&gt;NOTE:&lt;/em&gt; NOTE: Superclass is also not thread-safe in its
                  rendering of the background, although that is not an issue with the
                  default rendering.                
            </javadoc>
            <method name="update" type="void" line="861">
                <params>
                    <param name="g" type="Graphics"/>
                    <param name="c" type="JComponent"/>
                </params>
            </method>
            <javadoc line="865">
                Paints the interface.  This is routed to the
                  paintSafely method under the guarantee that
                  the model won&apos;t change from the view of this thread
                  while it&apos;s rendering (if the associated model is
                  derived from AbstractDocument).  This enables the
                  model to potentially be updated asynchronously.                
                <param>
                    g the graphics context                    
                </param>
                <param>
                    c the editor component                    
                </param>
            </javadoc>
            <method name="paint" type="void" line="876">
                <params>
                    <param name="g" type="Graphics"/>
                    <param name="c" type="JComponent"/>
                </params>
                <scope line="877">
                    <declaration name="doc" type="Document" line="878"/>
                    <scope line="879"/>
                    <scope line="882"/>
                    <scope line="884">
                        <scope line="885"/>
                    </scope>
                </scope>
            </method>
            <javadoc line="892">
                Gets the preferred size for the editor component.  If the component
                  has been given a size prior to receiving this request, it will
                  set the size of the view hierarchy to reflect the size of the component
                  before requesting the preferred size of the view hierarchy.  This
                  allows formatted views to format to the current component size before
                  answering the request.  Other views don&apos;t care about currently formatted
                  size and give the same answer either way.                
                <param>
                    c the editor component                    
                </param>
                <return>
                    the size                    
                </return>
            </javadoc>
            <method name="getPreferredSize" type="Dimension" line="904">
                <params>
                    <param name="c" type="JComponent"/>
                </params>
                <comment line="918">
                    Probably haven&apos;t been layed out yet, force some sort of
                     initial sizing.                    
                </comment>
                <declaration name="doc" type="Document" line="905"/>
                <declaration name="i" type="Insets" line="906"/>
                <declaration name="d" type="Dimension" line="907"/>
                <scope line="909"/>
                <scope line="912">
                    <scope line="913"/>
                    <scope line="916"/>
                </scope>
                <scope line="925">
                    <scope line="926"/>
                </scope>
            </method>
            <javadoc line="933">
                Gets the minimum size for the editor component.                
                <param>
                    c the editor component                    
                </param>
                <return>
                    the size                    
                </return>
            </javadoc>
            <method name="getMinimumSize" type="Dimension" line="939">
                <params>
                    <param name="c" type="JComponent"/>
                </params>
                <declaration name="doc" type="Document" line="940"/>
                <declaration name="i" type="Insets" line="941"/>
                <declaration name="d" type="Dimension" line="942"/>
                <scope line="943"/>
                <scope line="946"/>
                <scope line="949">
                    <scope line="950"/>
                </scope>
            </method>
            <javadoc line="957">
                Gets the maximum size for the editor component.                
                <param>
                    c the editor component                    
                </param>
                <return>
                    the size                    
                </return>
            </javadoc>
            <method name="getMaximumSize" type="Dimension" line="963">
                <params>
                    <param name="c" type="JComponent"/>
                </params>
                <declaration name="doc" type="Document" line="964"/>
                <declaration name="i" type="Insets" line="965"/>
                <declaration name="d" type="Dimension" line="966"/>
                <scope line="967"/>
                <scope line="970"/>
                <scope line="975">
                    <scope line="976"/>
                </scope>
            </method>
            <javadoc line="986">
                Gets the allocation to give the root View.  Due
                  to an unfortunate set of historical events this
                  method is inappropriately named.  The Rectangle
                  returned has nothing to do with visibility.
                  The component must have a non-zero positive size for
                  this translation to be computed.                
                <return>
                    the bounding box for the root view                    
                </return>
            </javadoc>
            <method name="getVisibleEditorRect" type="Rectangle" line="996">
                <declaration name="alloc" type="Rectangle" line="997"/>
                <scope line="998">
                    <declaration name="insets" type="Insets" line="1000"/>
                </scope>
            </method>
            <javadoc line="1010">
                Converts the given location in the model to a place in
                  the view coordinate system.
                  The component must have a non-zero positive size for
                  this translation to be computed.                
                <param>
                    tc the text component for which this UI is installed                    
                </param>
                <param>
                    pos the local location in the model to translate >= 0                    
                </param>
                <return>
                    the coordinates as a rectangle, null if the model is not painted                    
                </return>
                <exception>
                    BadLocationException  if the given position does not
                      represent a valid location in the associated document                    
                </exception>
                <see>
                    TextUI#modelToView                    
                </see>
            </javadoc>
            <method name="modelToView" type="Rectangle" line="1023">
                <params>
                    <param name="tc" type="JTextComponent"/>
                    <param name="pos" type="int"/>
                </params>
            </method>
            <javadoc line="1027">
                Converts the given location in the model to a place in
                  the view coordinate system.
                  The component must have a non-zero positive size for
                  this translation to be computed.                
                <param>
                    tc the text component for which this UI is installed                    
                </param>
                <param>
                    pos the local location in the model to translate >= 0                    
                </param>
                <return>
                    the coordinates as a rectangle, null if the model is not painted                    
                </return>
                <exception>
                    BadLocationException  if the given position does not
                      represent a valid location in the associated document                    
                </exception>
                <see>
                    TextUI#modelToView                    
                </see>
            </javadoc>
            <method name="modelToView" type="Rectangle" line="1040">
                <params>
                    <param name="tc" type="JTextComponent"/>
                    <param name="pos" type="int"/>
                    <param name="bias" type="Position.Bias"/>
                </params>
                <declaration name="doc" type="Document" line="1041"/>
                <scope line="1042"/>
                <scope line="1045">
                    <declaration name="alloc" type="Rectangle" line="1046"/>
                    <scope line="1047">
                        <declaration name="s" type="Shape" line="1049"/>
                        <scope line="1050"/>
                    </scope>
                </scope>
                <scope line="1054">
                    <scope line="1055"/>
                </scope>
            </method>
            <javadoc line="1062">
                Converts the given place in the view coordinate system
                  to the nearest representative location in the model.
                  The component must have a non-zero positive size for
                  this translation to be computed.                
                <param>
                    tc the text component for which this UI is installed                    
                </param>
                <param>
                    pt the location in the view to translate.  This
                      should be in the same coordinate system as the mouse events.                    
                </param>
                <return>
                    the offset from the start of the document >= 0,
                      -1 if not painted                    
                </return>
                <see>
                    TextUI#viewToModel                    
                </see>
            </javadoc>
            <method name="viewToModel" type="int" line="1075">
                <params>
                    <param name="tc" type="JTextComponent"/>
                    <param name="pt" type="Point"/>
                </params>
            </method>
            <javadoc line="1079">
                Converts the given place in the view coordinate system
                  to the nearest representative location in the model.
                  The component must have a non-zero positive size for
                  this translation to be computed.                
                <param>
                    tc the text component for which this UI is installed                    
                </param>
                <param>
                    pt the location in the view to translate.  This
                      should be in the same coordinate system as the mouse events.                    
                </param>
                <return>
                    the offset from the start of the document >= 0,
                      -1 if the component doesn't yet have a positive size.                    
                </return>
                <see>
                    TextUI#viewToModel                    
                </see>
            </javadoc>
            <method name="viewToModel" type="int" line="1093">
                <params>
                    <param name="tc" type="JTextComponent"/>
                    <param name="pt" type="Point"/>
                    <param name="biasReturn" type="Position.Bias[]"/>
                </params>
                <declaration name="offs" type="int" line="1094"/>
                <declaration name="doc" type="Document" line="1095"/>
                <scope line="1096"/>
                <scope line="1099">
                    <declaration name="alloc" type="Rectangle" line="1100"/>
                    <scope line="1101"/>
                </scope>
                <scope line="1105">
                    <scope line="1106"/>
                </scope>
            </method>
            <javadoc line="1113">
                {@inheritDoc}                
            </javadoc>
            <method name="getNextVisualPositionFrom" type="int" line="1118">
                <params>
                    <param name="t" type="JTextComponent"/>
                    <param name="pos" type="int"/>
                    <param name="b" type="Position.Bias"/>
                    <param name="direction" type="int"/>
                    <param name="biasRet" type="Position.Bias[]"/>
                </params>
                <declaration name="doc" type="Document" line="1119"/>
                <scope line="1120"/>
                <scope line="1123">
                    <scope line="1124">
                        <declaration name="alloc" type="Rectangle" line="1125"/>
                        <scope line="1126"/>
                    </scope>
                </scope>
                <scope line="1132">
                    <scope line="1133"/>
                </scope>
            </method>
            <javadoc line="1140">
                Causes the portion of the view responsible for the
                  given part of the model to be repainted.  Does nothing if
                  the view is not currently painted.                
                <param>
                    tc the text component for which this UI is installed                    
                </param>
                <param>
                    p0 the beginning of the range >= 0                    
                </param>
                <param>
                    p1 the end of the range >= p0                    
                </param>
                <see>
                    TextUI#damageRange                    
                </see>
            </javadoc>
            <method name="damageRange" type="void" line="1150">
                <params>
                    <param name="tc" type="JTextComponent"/>
                    <param name="p0" type="int"/>
                    <param name="p1" type="int"/>
                </params>
            </method>
            <javadoc line="1154">
                Causes the portion of the view responsible for the
                  given part of the model to be repainted.                
                <param>
                    p0 the beginning of the range >= 0                    
                </param>
                <param>
                    p1 the end of the range >= p0                    
                </param>
            </javadoc>
            <method name="damageRange" type="void" line="1162">
                <params>
                    <param name="t" type="JTextComponent"/>
                    <param name="p0" type="int"/>
                    <param name="p1" type="int"/>
                    <param name="p0Bias" type="Position.Bias"/>
                    <param name="p1Bias" type="Position.Bias"/>
                </params>
                <scope line="1163">
                    <declaration name="alloc" type="Rectangle" line="1164"/>
                    <scope line="1165">
                        <declaration name="doc" type="Document" line="1166"/>
                        <scope line="1167"/>
                        <scope line="1170">
                            <declaration name="toDamage" type="Shape" line="1172"/>
                            <declaration name="rect" type="Rectangle" line="1174"/>
                        </scope>
                        <scope line="1177"/>
                        <scope line="1178">
                            <scope line="1179"/>
                        </scope>
                    </scope>
                </scope>
            </method>
            <javadoc line="1187">
                Fetches the EditorKit for the UI.                
                <param>
                    tc the text component for which this UI is installed                    
                </param>
                <return>
                    the editor capabilities                    
                </return>
                <see>
                    TextUI#getEditorKit                    
                </see>
            </javadoc>
            <method name="getEditorKit" type="EditorKit" line="1194">
                <params>
                    <param name="tc" type="JTextComponent"/>
                </params>
            </method>
            <javadoc line="1198">
                Fetches a View with the allocation of the associated
                  text component (i.e. the root of the hierarchy) that
                  can be traversed to determine how the model is being
                  represented spatially.
                  &lt;p&gt;
                  &lt;font color=red&gt;&lt;b&gt;NOTE:&lt;/b&gt;The View hierarchy can
                  be traversed from the root view, and other things
                  can be done as well.  Things done in this way cannot
                  be protected like simple method calls through the TextUI.
                  Therefore, proper operation in the presence of concurrency
                  must be arranged by any logic that calls this method!
                  &lt;/font&gt;                
                <param>
                    tc the text component for which this UI is installed                    
                </param>
                <return>
                    the view                    
                </return>
                <see>
                    TextUI#getRootView                    
                </see>
            </javadoc>
            <method name="getRootView" type="View" line="1216">
                <params>
                    <param name="tc" type="JTextComponent"/>
                </params>
            </method>
            <javadoc line="1221">
                Returns the string to be used as the tooltip at the passed in location.
                  This forwards the method onto the root View.                
                <see>
                    javax.swing.text.JTextComponent#getToolTipText                    
                </see>
                <see>
                    javax.swing.text.View#getToolTipText                    
                </see>
                <since>
                    1.4                    
                </since>
            </javadoc>
            <method name="getToolTipText" type="String" line="1229">
                <params>
                    <param name="t" type="JTextComponent"/>
                    <param name="pt" type="Point"/>
                </params>
                <scope line="1230"/>
                <declaration name="doc" type="Document" line="1233"/>
                <declaration name="tt" type="String" line="1234"/>
                <declaration name="alloc" type="Rectangle" line="1235"/>
                <scope line="1237">
                    <scope line="1238"/>
                    <scope line="1241"/>
                    <scope line="1243">
                        <scope line="1244"/>
                    </scope>
                </scope>
            </method>
            <javadoc line="1254">
                Creates a view for an element.
                  If a subclass wishes to directly implement the factory
                  producing the view(s), it should reimplement this
                  method.  By default it simply returns null indicating
                  it is unable to represent the element.                
                <param>
                    elem the element                    
                </param>
                <return>
                    the view                    
                </return>
            </javadoc>
            <method name="create" type="View" line="1264">
                <params>
                    <param name="elem" type="Element"/>
                </params>
            </method>
            <javadoc line="1268">
                Creates a view for an element.
                  If a subclass wishes to directly implement the factory
                  producing the view(s), it should reimplement this
                  method.  By default it simply returns null indicating
                  it is unable to represent the part of the element.                
                <param>
                    elem the element                    
                </param>
                <param>
                    p0 the starting offset >= 0                    
                </param>
                <param>
                    p1 the ending offset >= p0                    
                </param>
                <return>
                    the view                    
                </return>
            </javadoc>
            <method name="create" type="View" line="1280">
                <params>
                    <param name="elem" type="Element"/>
                    <param name="p0" type="int"/>
                    <param name="p1" type="int"/>
                </params>
            </method>
            <class name="BasicCaret" line="1284">
                <extends class="DefaultCaret"/>
                <comment line="1769">
                    --- PropertyChangeListener methods -----------------------                    
                </comment>
                <comment line="1837">
                    --- DocumentListener methods -----------------------                    
                </comment>
                <comment line="1897">
                    --- LayoutManager2 methods --------------------------------                    
                </comment>
                <comment line="2361">
                    --- TransferHandler methods ------------------------------------                    
                </comment>
                <implements interface="UIResource"/>
            </class>
            <class name="BasicHighlighter" line="1286">
                <extends class="DefaultHighlighter"/>
                <comment line="1769">
                    --- PropertyChangeListener methods -----------------------                    
                </comment>
                <comment line="1837">
                    --- DocumentListener methods -----------------------                    
                </comment>
                <comment line="1897">
                    --- LayoutManager2 methods --------------------------------                    
                </comment>
                <comment line="2361">
                    --- TransferHandler methods ------------------------------------                    
                </comment>
                <implements interface="UIResource"/>
            </class>
            <class name="BasicCursor" line="1288">
                <extends class="Cursor"/>
                <comment line="1769">
                    --- PropertyChangeListener methods -----------------------                    
                </comment>
                <comment line="1837">
                    --- DocumentListener methods -----------------------                    
                </comment>
                <comment line="1897">
                    --- LayoutManager2 methods --------------------------------                    
                </comment>
                <comment line="2361">
                    --- TransferHandler methods ------------------------------------                    
                </comment>
                <implements interface="UIResource"/>
                <method name="BasicCursor" type="constructor" line="1289">
                    <params>
                        <param name="type" type="int"/>
                    </params>
                </method>
                <method name="BasicCursor" type="constructor" line="1293">
                    <params>
                        <param name="name" type="String"/>
                    </params>
                </method>
            </class>
            <declaration name="textCursor" type="BasicCursor" line="1298"/>
            <declaration name="defaultKit" type="EditorKit" line="1301"/>
            <declaration name="editor" type="JTextComponent" line="1302"/>
            <declaration name="painted" type="boolean" line="1303"/>
            <declaration name="rootView" type="RootView" line="1304"/>
            <declaration name="updateHandler" type="UpdateHandler" line="1305"/>
            <declaration name="defaultTransferHandler" type="TransferHandler" line="1306"/>
            <declaration name="dragListener" type="DragListener" line="1307"/>
            <declaration name="discardBias" type="Position.Bias[]" line="1308"/>
            <declaration name="dropCaret" type="DefaultCaret" line="1309"/>
            <class name="RootView" line="1311">
                <extends class="View"/>
                <comment line="1769">
                    --- PropertyChangeListener methods -----------------------                    
                </comment>
                <comment line="1837">
                    --- DocumentListener methods -----------------------                    
                </comment>
                <comment line="1897">
                    --- LayoutManager2 methods --------------------------------                    
                </comment>
                <comment line="2361">
                    --- TransferHandler methods ------------------------------------                    
                </comment>
                <javadoc line="1311">
                    Root view that acts as a gateway between the component
                      and the View hierarchy.                    
                </javadoc>
                <method name="RootView" type="constructor" line="1317"/>
                <method name="setView" type="void" line="1321">
                    <params>
                        <param name="v" type="View"/>
                    </params>
                    <comment line="1326">
                        get rid of back reference so that the old
                         hierarchy can be garbage collected.                        
                    </comment>
                    <declaration name="oldView" type="View" line="1322"/>
                    <scope line="1324"/>
                    <scope line="1329"/>
                </method>
                <javadoc line="1335">
                    Fetches the attributes to use when rendering.  At the root
                      level there are no attributes.  If an attribute is resolved
                      up the view hierarchy this is the end of the line.                    
                </javadoc>
                <method name="getAttributes" type="AttributeSet" line="1340"/>
                <javadoc line="1344">
                    Determines the preferred span for this view along an axis.                    
                    <param>
                        axis may be either X_AXIS or Y_AXIS                        
                    </param>
                    <return>
                        the span the view would like to be rendered into.
                          Typically the view is told to render into the span
                          that is returned, although there is no guarantee.
                          The parent may choose to resize or break the view.                        
                    </return>
                </javadoc>
                <method name="getPreferredSpan" type="float" line="1353">
                    <params>
                        <param name="axis" type="int"/>
                    </params>
                    <scope line="1354"/>
                </method>
                <javadoc line="1360">
                    Determines the minimum span for this view along an axis.                    
                    <param>
                        axis may be either X_AXIS or Y_AXIS                        
                    </param>
                    <return>
                        the span the view would like to be rendered into.
                          Typically the view is told to render into the span
                          that is returned, although there is no guarantee.
                          The parent may choose to resize or break the view.                        
                    </return>
                </javadoc>
                <method name="getMinimumSpan" type="float" line="1369">
                    <params>
                        <param name="axis" type="int"/>
                    </params>
                    <scope line="1370"/>
                </method>
                <javadoc line="1376">
                    Determines the maximum span for this view along an axis.                    
                    <param>
                        axis may be either X_AXIS or Y_AXIS                        
                    </param>
                    <return>
                        the span the view would like to be rendered into.
                          Typically the view is told to render into the span
                          that is returned, although there is no guarantee.
                          The parent may choose to resize or break the view.                        
                    </return>
                </javadoc>
                <method name="getMaximumSpan" type="float" line="1385">
                    <params>
                        <param name="axis" type="int"/>
                    </params>
                </method>
                <javadoc line="1389">
                    Specifies that a preference has changed.
                      Child views can call this on the parent to indicate that
                      the preference has changed.  The root view routes this to
                      invalidate on the hosting component.
                      &lt;p&gt;
                      This can be called on a different thread from the
                      event dispatching thread and is basically unsafe to
                      propagate into the component.  To make this safe,
                      the operation is transferred over to the event dispatching
                      thread for completion.  It is a design goal that all view
                      methods be safe to call without concern for concurrency,
                      and this behavior helps make that true.                    
                    <param>
                        child the child view                        
                    </param>
                    <param>
                        width true if the width preference has changed                        
                    </param>
                    <param>
                        height true if the height preference has changed                        
                    </param>
                </javadoc>
                <method name="preferenceChanged" type="void" line="1407">
                    <params>
                        <param name="child" type="View"/>
                        <param name="width" type="boolean"/>
                        <param name="height" type="boolean"/>
                    </params>
                </method>
                <javadoc line="1411">
                    Determines the desired alignment for this view along an axis.                    
                    <param>
                        axis may be either X_AXIS or Y_AXIS                        
                    </param>
                    <return>
                        the desired alignment, where 0.0 indicates the origin
                          and 1.0 the full span away from the origin                        
                    </return>
                </javadoc>
                <method name="getAlignment" type="float" line="1418">
                    <params>
                        <param name="axis" type="int"/>
                    </params>
                    <scope line="1419"/>
                </method>
                <javadoc line="1425">
                    Renders the view.                    
                    <param>
                        g the graphics context                        
                    </param>
                    <param>
                        allocation the region to render into                        
                    </param>
                </javadoc>
                <method name="paint" type="void" line="1431">
                    <params>
                        <param name="g" type="Graphics"/>
                        <param name="allocation" type="Shape"/>
                    </params>
                    <scope line="1432">
                        <declaration name="alloc" type="Rectangle" line="1433"/>
                    </scope>
                </method>
                <javadoc line="1440">
                    Sets the view parent.                    
                    <param>
                        parent the parent view                        
                    </param>
                </javadoc>
                <method name="setParent" type="void" line="1445">
                    <params>
                        <param name="parent" type="View"/>
                    </params>
                </method>
                <javadoc line="1449">
                    Returns the number of views in this view.  Since
                      this view simply wraps the root of the view hierarchy
                      it has exactly one child.                    
                    <return>
                        the number of views                        
                    </return>
                    <see>
                        #getView                        
                    </see>
                </javadoc>
                <method name="getViewCount" type="int" line="1457"/>
                <javadoc line="1461">
                    Gets the n-th view in this container.                    
                    <param>
                        n the number of the view to get                        
                    </param>
                    <return>
                        the view                        
                    </return>
                </javadoc>
                <method name="getView" type="View" line="1467">
                    <params>
                        <param name="n" type="int"/>
                    </params>
                </method>
                <javadoc line="1471">
                    Returns the child view index representing the given position in
                      the model.  This is implemented to return the index of the only
                      child.                    
                    <param>
                        pos the position >= 0                        
                    </param>
                    <return>
                        index of the view representing the given position, or
                          -1 if no view represents that position                        
                    </return>
                    <since>
                        1.3                        
                    </since>
                </javadoc>
                <method name="getViewIndex" type="int" line="1481">
                    <params>
                        <param name="pos" type="int"/>
                        <param name="b" type="Position.Bias"/>
                    </params>
                </method>
                <javadoc line="1485">
                    Fetches the allocation for the given child view.
                      This enables finding out where various views
                      are located, without assuming the views store
                      their location.  This returns the given allocation
                      since this view simply acts as a gateway between
                      the view hierarchy and the associated component.                    
                    <param>
                        index the index of the child                        
                    </param>
                    <param>
                        a  the allocation to this view.                        
                    </param>
                    <return>
                        the allocation to the child                        
                    </return>
                </javadoc>
                <method name="getChildAllocation" type="Shape" line="1497">
                    <params>
                        <param name="index" type="int"/>
                        <param name="a" type="Shape"/>
                    </params>
                </method>
                <javadoc line="1501">
                    Provides a mapping from the document model coordinate space
                      to the coordinate space of the view mapped to it.                    
                    <param>
                        pos the position to convert                        
                    </param>
                    <param>
                        a the allocated region to render into                        
                    </param>
                    <return>
                        the bounding box of the given position                        
                    </return>
                </javadoc>
                <method name="modelToView" type="Shape" line="1509">
                    <params>
                        <param name="pos" type="int"/>
                        <param name="a" type="Shape"/>
                        <param name="b" type="Position.Bias"/>
                    </params>
                    <scope line="1510"/>
                </method>
                <javadoc line="1516">
                    Provides a mapping from the document model coordinate space
                      to the coordinate space of the view mapped to it.                    
                    <param>
                        p0 the position to convert >= 0                        
                    </param>
                    <param>
                        b0 the bias toward the previous character or the
                          next character represented by p0, in case the
                          position is a boundary of two views.                        
                    </param>
                    <param>
                        p1 the position to convert >= 0                        
                    </param>
                    <param>
                        b1 the bias toward the previous character or the
                          next character represented by p1, in case the
                          position is a boundary of two views.                        
                    </param>
                    <param>
                        a the allocated region to render into                        
                    </param>
                    <return>
                        the bounding box of the given position is returned                        
                    </return>
                    <exception>
                        BadLocationException  if the given position does
                          not represent a valid location in the associated document                        
                    </exception>
                    <exception>
                        IllegalArgumentException for an invalid bias argument                        
                    </exception>
                    <see>
                        View#viewToModel                        
                    </see>
                </javadoc>
                <method name="modelToView" type="Shape" line="1535">
                    <params>
                        <param name="p0" type="int"/>
                        <param name="b0" type="Position.Bias"/>
                        <param name="p1" type="int"/>
                        <param name="b1" type="Position.Bias"/>
                        <param name="a" type="Shape"/>
                    </params>
                    <scope line="1536"/>
                </method>
                <javadoc line="1542">
                    Provides a mapping from the view coordinate space to the logical
                      coordinate space of the model.                    
                    <param>
                        x x coordinate of the view location to convert                        
                    </param>
                    <param>
                        y y coordinate of the view location to convert                        
                    </param>
                    <param>
                        a the allocated region to render into                        
                    </param>
                    <return>
                        the location within the model that best represents the
                          given point in the view                        
                    </return>
                </javadoc>
                <method name="viewToModel" type="int" line="1552">
                    <params>
                        <param name="x" type="float"/>
                        <param name="y" type="float"/>
                        <param name="a" type="Shape"/>
                        <param name="bias" type="Position.Bias[]"/>
                    </params>
                    <scope line="1553">
                        <declaration name="retValue" type="int" line="1554"/>
                    </scope>
                </method>
                <javadoc line="1560">
                    Provides a way to determine the next visually represented model
                      location that one might place a caret.  Some views may not be visible,
                      they might not be in the same order found in the model, or they just
                      might not allow access to some of the locations in the model.                    
                    <param>
                        pos the position to convert >= 0                        
                    </param>
                    <param>
                        a the allocated region to render into                        
                    </param>
                    <param>
                        direction the direction from the current position that can
                          be thought of as the arrow keys typically found on a keyboard.
                          This may be SwingConstants.WEST, SwingConstants.EAST,
                          SwingConstants.NORTH, or SwingConstants.SOUTH.                        
                    </param>
                    <return>
                        the location within the model that best represents the next
                          location visual position.                        
                    </return>
                    <exception>
                        BadLocationException                        
                    </exception>
                    <exception>
                        IllegalArgumentException for an invalid direction                        
                    </exception>
                </javadoc>
                <method name="getNextVisualPositionFrom" type="int" line="1580">
                    <params>
                        <param name="pos" type="int"/>
                        <param name="b" type="Position.Bias"/>
                        <param name="a" type="Shape"/>
                        <param name="direction" type="int"/>
                        <param name="biasRet" type="Position.Bias[]"/>
                    </params>
                    <scope line="1581">
                        <declaration name="nextPos" type="int" line="1582"/>
                        <scope line="1584"/>
                        <scope line="1587"/>
                    </scope>
                </method>
                <javadoc line="1594">
                    Gives notification that something was inserted into the document
                      in a location that this view is responsible for.                    
                    <param>
                        e the change information from the associated document                        
                    </param>
                    <param>
                        a the current allocation of the view                        
                    </param>
                    <param>
                        f the factory to use to rebuild if the view has children                        
                    </param>
                </javadoc>
                <method name="insertUpdate" type="void" line="1602">
                    <params>
                        <param name="e" type="DocumentEvent"/>
                        <param name="a" type="Shape"/>
                        <param name="f" type="ViewFactory"/>
                    </params>
                    <scope line="1603"/>
                </method>
                <javadoc line="1608">
                    Gives notification that something was removed from the document
                      in a location that this view is responsible for.                    
                    <param>
                        e the change information from the associated document                        
                    </param>
                    <param>
                        a the current allocation of the view                        
                    </param>
                    <param>
                        f the factory to use to rebuild if the view has children                        
                    </param>
                </javadoc>
                <method name="removeUpdate" type="void" line="1616">
                    <params>
                        <param name="e" type="DocumentEvent"/>
                        <param name="a" type="Shape"/>
                        <param name="f" type="ViewFactory"/>
                    </params>
                    <scope line="1617"/>
                </method>
                <javadoc line="1622">
                    Gives notification from the document that attributes were changed
                      in a location that this view is responsible for.                    
                    <param>
                        e the change information from the associated document                        
                    </param>
                    <param>
                        a the current allocation of the view                        
                    </param>
                    <param>
                        f the factory to use to rebuild if the view has children                        
                    </param>
                </javadoc>
                <method name="changedUpdate" type="void" line="1630">
                    <params>
                        <param name="e" type="DocumentEvent"/>
                        <param name="a" type="Shape"/>
                        <param name="f" type="ViewFactory"/>
                    </params>
                    <scope line="1631"/>
                </method>
                <javadoc line="1636">
                    Returns the document model underlying the view.                    
                    <return>
                        the model                        
                    </return>
                </javadoc>
                <method name="getDocument" type="Document" line="1641"/>
                <javadoc line="1645">
                    Returns the starting offset into the model for this view.                    
                    <return>
                        the starting offset                        
                    </return>
                </javadoc>
                <method name="getStartOffset" type="int" line="1650">
                    <scope line="1651"/>
                </method>
                <javadoc line="1657">
                    Returns the ending offset into the model for this view.                    
                    <return>
                        the ending offset                        
                    </return>
                </javadoc>
                <method name="getEndOffset" type="int" line="1662">
                    <scope line="1663"/>
                </method>
                <javadoc line="1669">
                    Gets the element that this view is mapped to.                    
                    <return>
                        the view                        
                    </return>
                </javadoc>
                <method name="getElement" type="Element" line="1674">
                    <scope line="1675"/>
                </method>
                <javadoc line="1681">
                    Breaks this view on the given axis at the given length.                    
                    <param>
                        axis may be either X_AXIS or Y_AXIS                        
                    </param>
                    <param>
                        len specifies where a break is desired in the span                        
                    </param>
                    <param>
                        the current allocation of the view                        
                    </param>
                    <return>
                        the fragment of the view that represents the given span
                          if the view can be broken, otherwise null                        
                    </return>
                </javadoc>
                <method name="breakView" type="View" line="1690">
                    <params>
                        <param name="axis" type="int"/>
                        <param name="len" type="float"/>
                        <param name="a" type="Shape"/>
                    </params>
                </method>
                <javadoc line="1694">
                    Determines the resizability of the view along the
                      given axis.  A value of 0 or less is not resizable.                    
                    <param>
                        axis may be either X_AXIS or Y_AXIS                        
                    </param>
                    <return>
                        the weight                        
                    </return>
                </javadoc>
                <method name="getResizeWeight" type="int" line="1701">
                    <params>
                        <param name="axis" type="int"/>
                    </params>
                    <scope line="1702"/>
                </method>
                <javadoc line="1708">
                    Sets the view size.                    
                    <param>
                        width the width                        
                    </param>
                    <param>
                        height the height                        
                    </param>
                </javadoc>
                <method name="setSize" type="void" line="1714">
                    <params>
                        <param name="width" type="float"/>
                        <param name="height" type="float"/>
                    </params>
                    <scope line="1715"/>
                </method>
                <javadoc line="1720">
                    Fetches the container hosting the view.  This is useful for
                      things like scheduling a repaint, finding out the host
                      components font, etc.  The default implementation
                      of this is to forward the query to the parent view.                    
                    <return>
                        the container                        
                    </return>
                </javadoc>
                <method name="getContainer" type="Container" line="1728"/>
                <javadoc line="1732">
                    Fetches the factory to be used for building the
                      various view fragments that make up the view that
                      represents the model.  This is what determines
                      how the model will be represented.  This is implemented
                      to fetch the factory provided by the associated
                      EditorKit unless that is null, in which case this
                      simply returns the BasicTextUI itself which allows
                      subclasses to implement a simple factory directly without
                      creating extra objects.                    
                    <return>
                        the factory                        
                    </return>
                </javadoc>
                <method name="getViewFactory" type="ViewFactory" line="1745">
                    <declaration name="kit" type="EditorKit" line="1746"/>
                    <declaration name="f" type="ViewFactory" line="1747"/>
                    <scope line="1748"/>
                </method>
                <declaration name="view" type="View" line="1754"/>
            </class>
            <class name="UpdateHandler" line="1758">
                <comment line="1769">
                    --- PropertyChangeListener methods -----------------------                    
                </comment>
                <comment line="1837">
                    --- DocumentListener methods -----------------------                    
                </comment>
                <comment line="1897">
                    --- LayoutManager2 methods --------------------------------                    
                </comment>
                <comment line="2361">
                    --- TransferHandler methods ------------------------------------                    
                </comment>
                <implements interface="PropertyChangeListener"/>
                <implements interface="DocumentListener"/>
                <implements interface="LayoutManager2"/>
                <implements interface="UIResource"/>
                <javadoc line="1758">
                    Handles updates from various places.  If the model is changed,
                      this class unregisters as a listener to the old model and
                      registers with the new model.  If the document model changes,
                      the change is forwarded to the root view.  If the focus
                      accelerator changes, a new keystroke is registered to request
                      focus.                    
                </javadoc>
                <javadoc line="1770">
                    This method gets called when a bound property is changed.
                      We are looking for document changes on the editor.                    
                </javadoc>
                <method name="propertyChange" type="void" line="1774">
                    <params>
                        <param name="evt" type="PropertyChangeEvent"/>
                    </params>
                    <comment line="1798">
                        Changes in ComponentOrientation require the views to be
                         rebuilt.                        
                    </comment>
                    <declaration name="oldValue" type="Object" line="1775"/>
                    <declaration name="newValue" type="Object" line="1776"/>
                    <declaration name="propertyName" type="String" line="1777"/>
                    <scope line="1778">
                        <scope line="1779"/>
                        <scope line="1783">
                            <scope line="1785"/>
                        </scope>
                    </scope>
                    <scope line="1794"/>
                    <scope line="1796"/>
                    <scope line="1800"/>
                    <scope line="1802"/>
                    <scope line="1804"/>
                </method>
                <method name="dropIndexChanged" type="void" line="1811">
                    <scope line="1812"/>
                    <declaration name="dropLocation" type="JTextComponent.DropLocation" line="1816"/>
                    <scope line="1818">
                        <scope line="1819"/>
                    </scope>
                    <scope line="1824">
                        <scope line="1825"/>
                    </scope>
                </method>
                <javadoc line="1838">
                    The insert notification.  Gets sent to the root of the view structure
                      that represents the portion of the model being represented by the
                      editor.  The factory is added as an argument to the update so that
                      the views can update themselves in a dynamic (not hardcoded) way.                    
                    <param>
                        e  The change notification from the currently associated
                          document.                        
                    </param>
                    <see>
                        DocumentListener#insertUpdate                        
                    </see>
                </javadoc>
                <method name="insertUpdate" type="void" line="1848">
                    <params>
                        <param name="e" type="DocumentEvent"/>
                    </params>
                    <comment line="1855">
                        i18n flag changed, rebuild the view                        
                    </comment>
                    <comment line="1862">
                        normal insert update                        
                    </comment>
                    <declaration name="doc" type="Document" line="1849"/>
                    <declaration name="o" type="Object" line="1850"/>
                    <scope line="1851">
                        <declaration name="i18nFlag" type="Boolean" line="1852"/>
                        <scope line="1853"/>
                    </scope>
                    <declaration name="alloc" type="Rectangle" line="1862"/>
                </method>
                <javadoc line="1866">
                    The remove notification.  Gets sent to the root of the view structure
                      that represents the portion of the model being represented by the
                      editor.  The factory is added as an argument to the update so that
                      the views can update themselves in a dynamic (not hardcoded) way.                    
                    <param>
                        e  The change notification from the currently associated
                          document.                        
                    </param>
                    <see>
                        DocumentListener#removeUpdate                        
                    </see>
                </javadoc>
                <method name="removeUpdate" type="void" line="1876">
                    <params>
                        <param name="e" type="DocumentEvent"/>
                    </params>
                    <declaration name="alloc" type="Rectangle" line="1877"/>
                </method>
                <javadoc line="1881">
                    The change notification.  Gets sent to the root of the view structure
                      that represents the portion of the model being represented by the
                      editor.  The factory is added as an argument to the update so that
                      the views can update themselves in a dynamic (not hardcoded) way.                    
                    <param>
                        e  The change notification from the currently associated
                          document.                        
                    </param>
                    <see>
                        DocumentListener#changedUpdate(DocumentEvent)                        
                    </see>
                </javadoc>
                <method name="changedUpdate" type="void" line="1891">
                    <params>
                        <param name="e" type="DocumentEvent"/>
                    </params>
                    <declaration name="alloc" type="Rectangle" line="1892"/>
                </method>
                <javadoc line="1898">
                    Adds the specified component with the specified name to
                      the layout.                    
                    <param>
                        name the component name                        
                    </param>
                    <param>
                        comp the component to be added                        
                    </param>
                </javadoc>
                <method name="addLayoutComponent" type="void" line="1904">
                    <params>
                        <param name="name" type="String"/>
                        <param name="comp" type="Component"/>
                    </params>
                    <comment line="1906">
                        not supported                        
                    </comment>
                </method>
                <javadoc line="1908">
                    Removes the specified component from the layout.                    
                    <param>
                        comp the component to be removed                        
                    </param>
                </javadoc>
                <method name="removeLayoutComponent" type="void" line="1912">
                    <params>
                        <param name="comp" type="Component"/>
                    </params>
                    <comment line="1915">
                        remove the constraint record                        
                    </comment>
                    <scope line="1913"/>
                </method>
                <javadoc line="1919">
                    Calculates the preferred size dimensions for the specified
                      panel given the components in the specified parent container.                    
                    <param>
                        parent the component to be laid out                        
                    </param>
                    <see>
                        #minimumLayoutSize                        
                    </see>
                </javadoc>
                <method name="preferredLayoutSize" type="Dimension" line="1926">
                    <params>
                        <param name="parent" type="Container"/>
                    </params>
                    <comment line="1928">
                        should not be called (JComponent uses UI instead)                        
                    </comment>
                </method>
                <javadoc line="1931">
                    Calculates the minimum size dimensions for the specified
                      panel given the components in the specified parent container.                    
                    <param>
                        parent the component to be laid out                        
                    </param>
                    <see>
                        #preferredLayoutSize                        
                    </see>
                </javadoc>
                <method name="minimumLayoutSize" type="Dimension" line="1937">
                    <params>
                        <param name="parent" type="Container"/>
                    </params>
                    <comment line="1939">
                        should not be called (JComponent uses UI instead)                        
                    </comment>
                </method>
                <javadoc line="1942">
                    Lays out the container in the specified panel.  This is
                      implemented to position all components that were added
                      with a View object as a constraint.  The current allocation
                      of the associated View is used as the location of the
                      component.
                      &lt;p&gt;
                      A read-lock is acquired on the document to prevent the
                      view tree from being modified while the layout process
                      is active.                    
                    <param>
                        parent the component which needs to be laid out                        
                    </param>
                </javadoc>
                <method name="layoutContainer" type="void" line="1955">
                    <params>
                        <param name="parent" type="Container"/>
                    </params>
                    <scope line="1956">
                        <declaration name="alloc" type="Rectangle" line="1957"/>
                        <scope line="1958">
                            <declaration name="doc" type="Document" line="1959"/>
                            <scope line="1960"/>
                            <scope line="1963">
                                <declaration name="components" type="Enumeration&lt;Component&gt;" line="1965"/>
                                <scope line="1966">
                                    <declaration name="comp" type="Component" line="1967"/>
                                    <declaration name="v" type="View" line="1968"/>
                                    <declaration name="ca" type="Shape" line="1969"/>
                                    <scope line="1970">
                                        <declaration name="compAlloc" type="Rectangle" line="1971"/>
                                    </scope>
                                </scope>
                            </scope>
                            <scope line="1976">
                                <scope line="1977"/>
                            </scope>
                        </scope>
                    </scope>
                </method>
                <javadoc line="1985">
                    Find the Shape representing the given view.                    
                </javadoc>
                <method name="calculateViewPosition" type="Shape" line="1988">
                    <params>
                        <param name="alloc" type="Shape"/>
                        <param name="v" type="View"/>
                    </params>
                    <declaration name="pos" type="int" line="1989"/>
                    <declaration name="child" type="View" line="1990"/>
                    <scope line="1991">
                        <declaration name="index" type="int" line="1992"/>
                    </scope>
                </method>
                <javadoc line="1999">
                    Adds the specified component to the layout, using the specified
                      constraint object.  We only store those components that were added
                      with a constraint that is of type View.                    
                    <param>
                        comp the component to be added                        
                    </param>
                    <param>
                        constraint  where/how the component is added to the layout.                        
                    </param>
                </javadoc>
                <method name="addLayoutComponent" type="void" line="2007">
                    <params>
                        <param name="comp" type="Component"/>
                        <param name="constraint" type="Object"/>
                    </params>
                    <scope line="2008">
                        <scope line="2009"/>
                    </scope>
                </method>
                <javadoc line="2016">
                    Returns the maximum size of this component.                    
                    <see>
                        java.awt.Component#getMinimumSize()                        
                    </see>
                    <see>
                        java.awt.Component#getPreferredSize()                        
                    </see>
                    <see>
                        LayoutManager                        
                    </see>
                </javadoc>
                <method name="maximumLayoutSize" type="Dimension" line="2022">
                    <params>
                        <param name="target" type="Container"/>
                    </params>
                    <comment line="2024">
                        should not be called (JComponent uses UI instead)                        
                    </comment>
                </method>
                <javadoc line="2027">
                    Returns the alignment along the x axis.  This specifies how
                      the component would like to be aligned relative to other
                      components.  The value should be a number between 0 and 1
                      where 0 represents alignment along the origin, 1 is aligned
                      the furthest away from the origin, 0.5 is centered, etc.                    
                </javadoc>
                <method name="getLayoutAlignmentX" type="float" line="2034">
                    <params>
                        <param name="target" type="Container"/>
                    </params>
                </method>
                <javadoc line="2038">
                    Returns the alignment along the y axis.  This specifies how
                      the component would like to be aligned relative to other
                      components.  The value should be a number between 0 and 1
                      where 0 represents alignment along the origin, 1 is aligned
                      the furthest away from the origin, 0.5 is centered, etc.                    
                </javadoc>
                <method name="getLayoutAlignmentY" type="float" line="2045">
                    <params>
                        <param name="target" type="Container"/>
                    </params>
                </method>
                <javadoc line="2049">
                    Invalidates the layout, indicating that if the layout manager
                      has cached information it should be discarded.                    
                </javadoc>
                <method name="invalidateLayout" type="void" line="2053">
                    <params>
                        <param name="target" type="Container"/>
                    </params>
                </method>
                <declaration name="constraints" type="Hashtable&lt;Component,Object&gt;" line="2056"/>
                <javadoc line="2056">
                    The &quot;layout constraints&quot; for the LayoutManager2 implementation.
                      These are View objects for those components that are represented
                      by a View in the View tree.                    
                </javadoc>
                <declaration name="i18nView" type="boolean" line="2063"/>
            </class>
            <class name="TextActionWrapper" line="2066">
                <extends class="TextAction"/>
                <comment line="1769">
                    --- PropertyChangeListener methods -----------------------                    
                </comment>
                <comment line="1837">
                    --- DocumentListener methods -----------------------                    
                </comment>
                <comment line="1897">
                    --- LayoutManager2 methods --------------------------------                    
                </comment>
                <comment line="2361">
                    --- TransferHandler methods ------------------------------------                    
                </comment>
                <javadoc line="2066">
                    Wrapper for text actions to return isEnabled false in case editor is non editable                    
                </javadoc>
                <method name="TextActionWrapper" type="constructor" line="2070">
                    <params>
                        <param name="action" type="TextAction"/>
                    </params>
                </method>
                <javadoc line="2074">
                    The operation to perform when this action is triggered.                    
                    <param>
                        e the action event                        
                    </param>
                </javadoc>
                <method name="actionPerformed" type="void" line="2079">
                    <params>
                        <param name="e" type="ActionEvent"/>
                    </params>
                </method>
                <method name="isEnabled" type="boolean" line="2082"/>
                <declaration name="action" type="TextAction" line="2085"/>
            </class>
            <class name="FocusAction" line="2089">
                <extends class="AbstractAction"/>
                <comment line="1769">
                    --- PropertyChangeListener methods -----------------------                    
                </comment>
                <comment line="1837">
                    --- DocumentListener methods -----------------------                    
                </comment>
                <comment line="1897">
                    --- LayoutManager2 methods --------------------------------                    
                </comment>
                <comment line="2361">
                    --- TransferHandler methods ------------------------------------                    
                </comment>
                <javadoc line="2089">
                    Registered in the ActionMap.                    
                </javadoc>
                <method name="actionPerformed" type="void" line="2094">
                    <params>
                        <param name="e" type="ActionEvent"/>
                    </params>
                </method>
                <method name="isEnabled" type="boolean" line="2098"/>
            </class>
            <method name="getDragListener" type="DragListener" line="2103">
                <scope line="2104">
                    <declaration name="listener" type="DragListener" line="2105"/>
                    <scope line="2109"/>
                </scope>
            </method>
            <class name="DragListener" line="2118">
                <extends class="MouseInputAdapter"/>
                <comment line="1769">
                    --- PropertyChangeListener methods -----------------------                    
                </comment>
                <comment line="1837">
                    --- DocumentListener methods -----------------------                    
                </comment>
                <comment line="1897">
                    --- LayoutManager2 methods --------------------------------                    
                </comment>
                <comment line="2361">
                    --- TransferHandler methods ------------------------------------                    
                </comment>
                <implements interface="BeforeDrag"/>
                <javadoc line="2118">
                    Listens for mouse events for the purposes of detecting drag gestures.
                      BasicTextUI will maintain one of these per AppContext.                    
                </javadoc>
                <declaration name="dragStarted" type="boolean" line="2125"/>
                <method name="dragStarting" type="void" line="2127">
                    <params>
                        <param name="me" type="MouseEvent"/>
                    </params>
                </method>
                <method name="mousePressed" type="void" line="2131">
                    <params>
                        <param name="e" type="MouseEvent"/>
                    </params>
                    <declaration name="c" type="JTextComponent" line="2132"/>
                    <scope line="2133">
                        <scope line="2135"/>
                    </scope>
                </method>
                <method name="mouseReleased" type="void" line="2141">
                    <params>
                        <param name="e" type="MouseEvent"/>
                    </params>
                    <declaration name="c" type="JTextComponent" line="2142"/>
                    <scope line="2143">
                        <scope line="2144"/>
                    </scope>
                </method>
                <method name="mouseDragged" type="void" line="2152">
                    <params>
                        <param name="e" type="MouseEvent"/>
                    </params>
                    <declaration name="c" type="JTextComponent" line="2153"/>
                    <scope line="2154">
                        <scope line="2155"/>
                    </scope>
                </method>
                <javadoc line="2161">
                    Determines if the following are true:
                      &lt;ul&gt;
                      &lt;li&gt;the component is enabled
                      &lt;li&gt;the press event is located over a selection
                      &lt;/ul&gt;                    
                </javadoc>
                <method name="isDragPossible" type="boolean" line="2168">
                    <params>
                        <param name="e" type="MouseEvent"/>
                    </params>
                    <declaration name="c" type="JTextComponent" line="2169"/>
                    <scope line="2170">
                        <declaration name="caret" type="Caret" line="2171"/>
                        <declaration name="dot" type="int" line="2172"/>
                        <declaration name="mark" type="int" line="2173"/>
                        <scope line="2174">
                            <declaration name="p" type="Point" line="2175"/>
                            <declaration name="pos" type="int" line="2176"/>
                            <declaration name="p0" type="int" line="2178"/>
                            <declaration name="p1" type="int" line="2179"/>
                            <scope line="2180"/>
                        </scope>
                    </scope>
                </method>
            </class>
            <class name="TextTransferHandler" line="2189">
                <extends class="TransferHandler"/>
                <comment line="1769">
                    --- PropertyChangeListener methods -----------------------                    
                </comment>
                <comment line="1837">
                    --- DocumentListener methods -----------------------                    
                </comment>
                <comment line="1897">
                    --- LayoutManager2 methods --------------------------------                    
                </comment>
                <comment line="2361">
                    --- TransferHandler methods ------------------------------------                    
                </comment>
                <implements interface="UIResource"/>
                <declaration name="exportComp" type="JTextComponent" line="2191"/>
                <declaration name="shouldRemove" type="boolean" line="2192"/>
                <declaration name="p0" type="int" line="2193"/>
                <declaration name="p1" type="int" line="2194"/>
                <declaration name="modeBetween" type="boolean" line="2196"/>
                <javadoc line="2196">
                    Whether or not this is a drop using
                      &lt;code&gt;DropMode.INSERT&lt;/code&gt;.                    
                </javadoc>
                <declaration name="isDrop" type="boolean" line="2202"/>
                <javadoc line="2202">
                    Whether or not this is a drop.                    
                </javadoc>
                <declaration name="dropAction" type="int" line="2207"/>
                <javadoc line="2207">
                    The drop action.                    
                </javadoc>
                <declaration name="dropBias" type="Position.Bias" line="2212"/>
                <javadoc line="2212">
                    The drop bias.                    
                </javadoc>
                <javadoc line="2217">
                    Try to find a flavor that can be used to import a Transferable.
                      The set of usable flavors are tried in the following order:
                      &lt;ol&gt;
                      &lt;li&gt;First, an attempt is made to find a flavor matching the content type
                      of the EditorKit for the component.
                      &lt;li&gt;Second, an attempt to find a text/plain flavor is made.
                      &lt;li&gt;Third, an attempt to find a flavor representing a String reference
                      in the same VM is made.
                      &lt;li&gt;Lastly, DataFlavor.stringFlavor is searched for.
                      &lt;/ol&gt;                    
                </javadoc>
                <method name="getImportFlavor" type="DataFlavor" line="2229">
                    <params>
                        <param name="flavors" type="DataFlavor[]"/>
                        <param name="c" type="JTextComponent"/>
                    </params>
                    <declaration name="plainFlavor" type="DataFlavor" line="2230"/>
                    <declaration name="refFlavor" type="DataFlavor" line="2231"/>
                    <declaration name="stringFlavor" type="DataFlavor" line="2232"/>
                    <scope line="2234">
                        <scope line="2235">
                            <declaration name="mime" type="String" line="2236"/>
                            <scope line="2237"/>
                            <scope line="2239"/>
                            <scope line="2242"/>
                            <scope line="2244"/>
                        </scope>
                        <scope line="2248"/>
                        <scope line="2250"/>
                        <scope line="2252"/>
                    </scope>
                    <scope line="2259">
                        <declaration name="mime" type="String" line="2260"/>
                        <scope line="2261"/>
                        <scope line="2264"/>
                        <scope line="2266"/>
                    </scope>
                    <scope line="2270"/>
                    <scope line="2272"/>
                </method>
                <javadoc line="2278">
                    Import the given stream data into the text component.                    
                </javadoc>
                <method name="handleReaderImport" type="void" line="2282">
                    <params>
                        <param name="in" type="Reader"/>
                        <param name="c" type="JTextComponent"/>
                        <param name="useRead" type="boolean"/>
                    </params>
                    <comment line="2301">
                        Read in a block at a time, mapping \r\n to \n, as well as single
                         \r to \n.                        
                    </comment>
                    <comment line="2326">
                        else nothing to do, can skip \r, next write will
                         write \n                        
                    </comment>
                    <scope line="2283">
                        <declaration name="startPosition" type="int" line="2284"/>
                        <declaration name="endPosition" type="int" line="2285"/>
                        <declaration name="length" type="int" line="2286"/>
                        <declaration name="kit" type="EditorKit" line="2287"/>
                        <declaration name="doc" type="Document" line="2288"/>
                        <scope line="2289"/>
                    </scope>
                    <scope line="2293">
                        <declaration name="buff" type="char[]" line="2294"/>
                        <declaration name="nch" type="int" line="2295"/>
                        <declaration name="lastWasCR" type="boolean" line="2296"/>
                        <declaration name="last" type="int" line="2297"/>
                        <declaration name="sbuff" type="StringBuffer" line="2298"/>
                        <scope line="2302">
                            <scope line="2303"/>
                            <scope line="2307">
                                <scope line="2310">
                                    <scope line="2311"/>
                                    <scope line="2313"/>
                                </scope>
                                <scope line="2316"/>
                                <scope line="2321">
                                    <scope line="2322"/>
                                </scope>
                                <scope line="2332">
                                    <scope line="2333"/>
                                    <scope line="2335"/>
                                </scope>
                            </scope>
                            <scope line="2343">
                                <scope line="2344">
                                    <scope line="2345"/>
                                </scope>
                                <scope line="2348"/>
                            </scope>
                        </scope>
                        <scope line="2353"/>
                    </scope>
                </method>
                <javadoc line="2362">
                    This is the type of transfer actions supported by the source.  Some models are
                      not mutable, so a transfer operation of COPY only should
                      be advertised in that case.                    
                    <param>
                        c  The component holding the data to be transfered.  This
                          argument is provided to enable sharing of TransferHandlers by
                          multiple components.                        
                    </param>
                    <return>
                        This is implemented to return NONE if the component is a JPasswordField
                          since exporting data via user gestures is not allowed.  If the text component is
                          editable, COPY_OR_MOVE is returned, otherwise just COPY is allowed.                        
                    </return>
                </javadoc>
                <method name="getSourceActions" type="int" line="2374">
                    <params>
                        <param name="c" type="JComponent"/>
                    </params>
                    <scope line="2377"/>
                </method>
                <javadoc line="2384">
                    Create a Transferable to use as the source for a data transfer.                    
                    <param>
                        comp  The component holding the data to be transfered.  This
                          argument is provided to enable sharing of TransferHandlers by
                          multiple components.                        
                    </param>
                    <return>
                        The representation of the data to be transfered.                        
                    </return>
                </javadoc>
                <method name="createTransferable" type="Transferable" line="2393">
                    <params>
                        <param name="comp" type="JComponent"/>
                    </params>
                </method>
                <javadoc line="2401">
                    This method is called after data has been exported.  This method should remove
                      the data that was transfered if the action was MOVE.                    
                    <param>
                        source The component that was the source of the data.                        
                    </param>
                    <param>
                        data   The data that was transferred or possibly null
                          if the action is <code>NONE</code>.                        
                    </param>
                    <param>
                        action The actual action that was performed.                        
                    </param>
                </javadoc>
                <method name="exportDone" type="void" line="2410">
                    <params>
                        <param name="source" type="JComponent"/>
                        <param name="data" type="Transferable"/>
                        <param name="action" type="int"/>
                    </params>
                    <comment line="2412">
                        only remove the text if shouldRemove has not been set to
                         false by importData and only if the action is a move                        
                    </comment>
                    <scope line="2413">
                        <declaration name="t" type="TextTransferable" line="2414"/>
                    </scope>
                </method>
                <method name="importData" type="boolean" line="2421">
                    <params>
                        <param name="support" type="TransferSupport"/>
                    </params>
                    <scope line="2424"/>
                    <scope line="2433"/>
                    <scope line="2435"/>
                </method>
                <javadoc line="2443">
                    This method causes a transfer to a component from a clipboard or a
                      DND drop operation.  The Transferable represents the data to be
                      imported into the component.                    
                    <param>
                        comp  The component to receive the transfer.  This
                          argument is provided to enable sharing of TransferHandlers by
                          multiple components.                        
                    </param>
                    <param>
                        t     The data to import                        
                    </param>
                    <return>
                        true if the data was inserted into the component, false otherwise.                        
                    </return>
                </javadoc>
                <method name="importData" type="boolean" line="2454">
                    <params>
                        <param name="comp" type="JComponent"/>
                        <param name="t" type="Transferable"/>
                    </params>
                    <comment line="2461">
                        if we are importing to the same component that we exported from
                         then don&apos;t actually do anything if the drop location is inside
                         the drag location and set shouldRemove to false so that exportDone
                         knows not to remove any data                        
                    </comment>
                    <declaration name="c" type="JTextComponent" line="2455"/>
                    <declaration name="pos" type="int" line="2457"/>
                    <scope line="2464"/>
                    <declaration name="imported" type="boolean" line="2469"/>
                    <declaration name="importFlavor" type="DataFlavor" line="2470"/>
                    <scope line="2471">
                        <scope line="2472">
                            <declaration name="useRead" type="boolean" line="2473"/>
                            <scope line="2474">
                                <declaration name="ep" type="JEditorPane" line="2475"/>
                                <scope line="2477"/>
                            </scope>
                            <declaration name="ic" type="InputContext" line="2481"/>
                            <scope line="2482"/>
                            <declaration name="r" type="Reader" line="2485"/>
                            <scope line="2487">
                                <declaration name="caret" type="Caret" line="2488"/>
                                <scope line="2489"/>
                                <scope line="2491"/>
                            </scope>
                            <scope line="2498">
                                <declaration name="caret" type="Caret" line="2500"/>
                                <scope line="2501">
                                    <declaration name="newPos" type="int" line="2502"/>
                                    <declaration name="newBias" type="Position.Bias" line="2503"/>
                                </scope>
                                <scope line="2507"/>
                            </scope>
                        </scope>
                        <scope line="2513"/>
                        <scope line="2514"/>
                        <scope line="2515"/>
                    </scope>
                </method>
                <javadoc line="2521">
                    This method indicates if a component would accept an import of the given
                      set of data flavors prior to actually attempting to import it.                    
                    <param>
                        comp  The component to receive the transfer.  This
                          argument is provided to enable sharing of TransferHandlers by
                          multiple components.                        
                    </param>
                    <param>
                        flavors  The data formats available                        
                    </param>
                    <return>
                        true if the data can be inserted into the component, false otherwise.                        
                    </return>
                </javadoc>
                <method name="canImport" type="boolean" line="2531">
                    <params>
                        <param name="comp" type="JComponent"/>
                        <param name="flavors" type="DataFlavor[]"/>
                    </params>
                    <declaration name="c" type="JTextComponent" line="2532"/>
                    <scope line="2533"/>
                </method>
                <class name="TextTransferable" line="2539">
                    <extends class="BasicTransferable"/>
                    <comment line="2597">
                        ---- EditorKit other than plain or HTML text -----------------------                        
                    </comment>
                    <javadoc line="2539">
                        A possible implementation of the Transferable interface
                          for text components.  For a JEditorPane with a rich set
                          of EditorKit implementations, conversions could be made
                          giving a wider set of formats.  This is implemented to
                          offer up only the active content type and text/plain
                          (if that is not the active format) since that can be
                          extracted from other formats.                        
                    </javadoc>
                    <method name="TextTransferable" type="constructor" line="2550">
                        <params>
                            <param name="c" type="JTextComponent"/>
                            <param name="start" type="int"/>
                            <param name="end" type="int"/>
                        </params>
                        <declaration name="doc" type="Document" line="2555"/>
                        <scope line="2557">
                            <scope line="2563">
                                <declaration name="ep" type="JEditorPane" line="2564"/>
                                <scope line="2568"/>
                                <declaration name="sw" type="StringWriter" line="2572"/>
                                <scope line="2575"/>
                                <scope line="2577"/>
                            </scope>
                        </scope>
                        <scope line="2581"/>
                        <scope line="2582"/>
                    </method>
                    <method name="removeText" type="void" line="2586">
                        <scope line="2587">
                            <scope line="2588">
                                <declaration name="doc" type="Document" line="2589"/>
                            </scope>
                            <scope line="2591"/>
                        </scope>
                    </method>
                    <javadoc line="2598">
                        If the EditorKit is not for text/plain or text/html, that format
                          is supported through the &quot;richer flavors&quot; part of BasicTransferable.                        
                    </javadoc>
                    <method name="getRicherFlavors" type="DataFlavor[]" line="2602">
                        <comment line="2615">
                            fall through to unsupported (should not happen)                            
                        </comment>
                        <scope line="2603"/>
                        <scope line="2607">
                            <declaration name="flavors" type="DataFlavor[]" line="2608"/>
                        </scope>
                        <scope line="2613"/>
                    </method>
                    <javadoc line="2620">
                        The only richer format supported is the file list flavor                        
                    </javadoc>
                    <method name="getRicherData" type="Object" line="2623">
                        <params>
                            <param name="flavor" type="DataFlavor"/>
                        </params>
                        <scope line="2624"/>
                        <scope line="2628"/>
                        <scope line="2630"/>
                        <scope line="2632"/>
                    </method>
                    <declaration name="p0" type="Position" line="2638"/>
                    <declaration name="p1" type="Position" line="2639"/>
                    <declaration name="mimeType" type="String" line="2640"/>
                    <declaration name="richText" type="String" line="2641"/>
                    <declaration name="c" type="JTextComponent" line="2642"/>
                </class>
            </class>
        </class>
    </source>