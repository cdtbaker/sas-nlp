<?xml version="1.0" encoding="UTF-8"?>
    <source package="javax.swing.plaf.nimbus">
        <import package="javax.swing.Painter"/>
        <import package="javax.swing.JComponent"/>
        <import package="javax.swing.UIDefaults"/>
        <import package="javax.swing.UIManager"/>
        <import package="javax.swing.plaf.ColorUIResource"/>
        <import package="javax.swing.plaf.synth.ColorType"/>
        <import package="javax.swing.plaf.synth.SynthConstants"/>
        <import package="javax.swing.plaf.synth.SynthContext"/>
        <import package="javax.swing.plaf.synth.SynthPainter"/>
        <import package="javax.swing.plaf.synth.SynthStyle"/>
        <import package="java.awt.Color"/>
        <import package="java.awt.Font"/>
        <import package="java.awt.Insets"/>
        <import package="java.lang.ref.WeakReference"/>
        <import package="java.util.ArrayList"/>
        <import package="java.util.Collections"/>
        <import package="java.util.Comparator"/>
        <import package="java.util.HashMap"/>
        <import package="java.util.List"/>
        <import package="java.util.Map"/>
        <import package="java.util.TreeMap"/>
        <class name="NimbusStyle" line="23">
            <extends class="SynthStyle"/>
            <javadoc line="23">
                &lt;p&gt;A SynthStyle implementation used by Nimbus. Each Region that has been
                  registered with the NimbusLookAndFeel will have an associated NimbusStyle.
                  Third party components that are registered with the NimbusLookAndFeel will
                  therefore be handed a NimbusStyle from the look and feel from the
                  #getStyle(JComponent, Region) method.&lt;/p&gt;
                  &lt;p&gt;This class properly reads and retrieves values placed in the UIDefaults
                  according to the standard Nimbus naming conventions. It will create and
                  retrieve painters, fonts, colors, and other data stored there.&lt;/p&gt;
                  &lt;p&gt;NimbusStyle also supports the ability to override settings on a per
                  component basis. NimbusStyle checks the component&apos;s client property map for
                  &quot;Nimbus.Overrides&quot;. If the value associated with this key is an instance of
                  UIDefaults, then the values in that defaults table will override the standard
                  Nimbus defaults in UIManager, but for that component instance only.&lt;/p&gt;
                  &lt;p&gt;Optionally, you may specify the client property
                  &quot;Nimbus.Overrides.InheritDefaults&quot;. If true, this client property indicates
                  that the defaults located in UIManager should first be read, and then
                  replaced with defaults located in the component client properties. If false,
                  then only the defaults located in the component client property map will
                  be used. If not specified, it is assumed to be true.&lt;/p&gt;
                  &lt;p&gt;You must specify &quot;Nimbus.Overrides&quot; for &quot;Nimbus.Overrides.InheritDefaults&quot;
                  to have any effect. &quot;Nimbus.Overrides&quot; indicates whether there are any
                  overrides, while &quot;Nimbus.Overrides.InheritDefaults&quot; indicates whether those
                  overrides should first be initialized with the defaults from UIManager.&lt;/p&gt;
                  &lt;p&gt;The NimbusStyle is reloaded whenever a property change event is fired
                  for a component for &quot;Nimbus.Overrides&quot; or &quot;Nimbus.Overrides.InheritDefaults&quot;.
                  So for example, setting a new UIDefaults on a component would cause the
                  style to be reloaded.&lt;/p&gt;
                  &lt;p&gt;The values are only read out of UIManager once, and then cached. If
                  you need to read the values again (for example, if the UI is being reloaded),
                  then discard this NimbusStyle and read a new one from NimbusLookAndFeel
                  using NimbusLookAndFeel.getStyle.&lt;/p&gt;
                  &lt;p&gt;The primary API of interest in this class for 3rd party component authors
                  are the three methods which retrieve painters: #getBackgroundPainter,
                  #getForegroundPainter, and #getBorderPainter.&lt;/p&gt;
                  &lt;p&gt;NimbusStyle allows you to specify custom states, or modify the order of
                  states. Synth (and thus Nimbus) has the concept of a &quot;state&quot;. For example,
                  a JButton might be in the &quot;MOUSE_OVER&quot; state, or the &quot;ENABLED&quot; state, or the
                  &quot;DISABLED&quot; state. These are all &quot;standard&quot; states which are defined in synth,
                  and which apply to all synth Regions.&lt;/p&gt;
                  &lt;p&gt;Sometimes, however, you need to have a custom state. For example, you
                  want JButton to render differently if it&apos;s parent is a JToolbar. In Nimbus,
                  you specify these custom states by including a special key in UIDefaults.
                  The following UIDefaults entries define three states for this button:&lt;/p&gt;
                  &lt;pre&gt;&lt;code&gt;
                  JButton.States = Enabled, Disabled, Toolbar
                  JButton[Enabled].backgroundPainter = somePainter
                  JButton[Disabled].background = BLUE
                  JButton[Toolbar].backgroundPainter = someOtherPaint
                  &lt;/code&gt;&lt;/pre&gt;
                  &lt;p&gt;As you can see, the &lt;code&gt;JButton.States&lt;/code&gt; entry lists the states
                  that the JButton style will support. You then specify the settings for
                  each state. If you do not specify the &lt;code&gt;JButton.States&lt;/code&gt; entry,
                  then the standard Synth states will be assumed. If you specify the entry
                  but the list of states is empty or null, then the standard synth states
                  will be assumed.&lt;/p&gt;                
                <author>
                    Richard Bair                    
                </author>
                <author>
                    Jasper Potts                    
                </author>
            </javadoc>
            <declaration name="LARGE_KEY" type="String" line="83"/>
            <declaration name="SMALL_KEY" type="String" line="84"/>
            <declaration name="MINI_KEY" type="String" line="85"/>
            <declaration name="LARGE_SCALE" type="double" line="86"/>
            <declaration name="SMALL_SCALE" type="double" line="87"/>
            <declaration name="MINI_SCALE" type="double" line="88"/>
            <declaration name="NULL" type="Object" line="89"/>
            <javadoc line="89">
                Special constant used for performance reasons during the get() method.
                  If get() runs through all of the search locations and determines that
                  there is no value, then NULL will be placed into the values map. This way
                  on subsequent lookups it will simply extract NULL, see it, and return
                  null rather than continuing the lookup procedure.                
            </javadoc>
            <declaration name="DEFAULT_COLOR" type="Color" line="97"/>
            <javadoc line="97">
                &lt;p&gt;The Color to return from getColorForState if it would otherwise have
                  returned null.&lt;/p&gt;
                  &lt;p&gt;Returning null from getColorForState is a very bad thing, as it causes
                  the AWT peer for the component to install a SystemColor, which is not a
                  UIResource. As a result, if &lt;code&gt;null&lt;/code&gt; is returned from
                  getColorForState, then thereafter the color is not updated for other
                  states or on LAF changes or updates. This DEFAULT_COLOR is used to
                  ensure that a ColorUIResource is always returned from
                  getColorForState.&lt;/p&gt;                
            </javadoc>
            <declaration name="STATE_COMPARATOR" type="Comparator&amp;lt;RuntimeState&amp;gt;" line="109"/>
            <javadoc line="109">
                Simple Comparator for ordering the RuntimeStates according to their
                  rank.                
            </javadoc>
            <anonymous_class line="113">
                <method name="compare" type="int" line="114">
                    <params>
                        <param name="a" type="RuntimeState"/>
                        <param name="b" type="RuntimeState"/>
                    </params>
                </method>
            </anonymous_class>
            <declaration name="prefix" type="String" line="119"/>
            <javadoc line="119">
                The prefix for the component or region that this NimbusStyle
                  represents. This prefix is used to lookup state in the UIManager.
                  It should be something like Button or Slider.Thumb or &quot;MyButton&quot; or
                  ComboBox.&quot;ComboBox.arrowButton&quot; or &quot;MyComboBox&quot;.&quot;ComboBox.arrowButton&quot;                
            </javadoc>
            <declaration name="painter" type="SynthPainter" line="126"/>
            <javadoc line="126">
                The SynthPainter that will be returned from this NimbusStyle. The
                  SynthPainter returned will be a SynthPainterImpl, which will in turn
                  delegate back to this NimbusStyle for the proper Painter (not
                  SynthPainter) to use for painting the foreground, background, or border.                
            </javadoc>
            <declaration name="values" type="Values" line="133"/>
            <javadoc line="133">
                Data structure containing all of the defaults, insets, states, and other
                  values associated with this style. This instance refers to default
                  values, and are used when no overrides are discovered in the client
                  properties of a component. These values are lazily created on first
                  access.                
            </javadoc>
            <declaration name="tmpKey" type="CacheKey" line="141"/>
            <javadoc line="141">
                A temporary CacheKey used to perform lookups. This pattern avoids
                  creating useless garbage keys, or concatenating strings, etc.                
            </javadoc>
            <declaration name="component" type="WeakReference&amp;lt;JComponent&amp;gt;" line="146"/>
            <javadoc line="146">
                Some NimbusStyles are created for a specific component only. In Nimbus,
                  this happens whenever the component has as a client property a
                  UIDefaults which overrides (or supplements) those defaults found in
                  UIManager.                
            </javadoc>
            <javadoc line="153">
                Create a new NimbusStyle. Only the prefix must be supplied. At the
                  appropriate time, installDefaults will be called. At that point, all of
                  the state information will be pulled from UIManager and stored locally
                  within this style.                
                <param>
                    prefix Something like Button or Slider.Thumb or
                      org.jdesktop.swingx.JXStatusBar or ComboBox.&quot;ComboBox.arrowButton&quot;                    
                </param>
                <param>
                    c an optional reference to a component that this NimbusStyle
                      should be associated with. This is only used when the component
                      has Nimbus overrides registered in its client properties and
                      should be null otherwise.                    
                </param>
            </javadoc>
            <method name="NimbusStyle" type="constructor" line="165">
                <params>
                    <param name="prefix" type="String"/>
                    <param name="c" type="JComponent"/>
                </params>
                <scope line="166"/>
            </method>
            <javadoc line="172">
                @inheritDocOverridden to cause this style to populate itself with data from
                  UIDefaults, if necessary.                
            </javadoc>
            <method name="installDefaults" type="void" line="176">
                <params>
                    <param name="ctx" type="SynthContext"/>
                </params>
            </method>
            <javadoc line="180">
                Pulls data out of UIDefaults, if it has not done so already, and sets
                  up the internal state.                
            </javadoc>
            <method name="validate" type="void" line="184">
                <declaration name="defaults" type="Map&amp;lt;String,Object&amp;gt;" line="187"/>
                <scope line="188">
                    <declaration name="o" type="Object" line="189"/>
                    <scope line="190">
                        <declaration name="i" type="Object" line="191"/>
                        <declaration name="inherit" type="boolean" line="192"/>
                        <declaration name="d" type="UIDefaults" line="193"/>
                        <declaration name="map" type="TreeMap&amp;lt;String,Object&amp;gt;" line="194"/>
                        <scope line="195">
                            <scope line="196">
                                <declaration name="key" type="String" line="197"/>
                                <scope line="198"/>
                            </scope>
                        </scope>
                        <scope line="203"/>
                        <scope line="206"/>
                    </scope>
                </scope>
                <declaration name="states" type="List&amp;lt;State&amp;gt;" line="211"/>
                <declaration name="stateCodes" type="Map&amp;lt;String,Integer&amp;gt;" line="212"/>
                <declaration name="runtimeStates" type="List&amp;lt;RuntimeState&amp;gt;" line="213"/>
                <declaration name="statesString" type="String" line="214"/>
                <scope line="215">
                    <declaration name="s" type="String" line="216"/>
                    <scope line="217">
                        <scope line="219">
                            <declaration name="stateName" type="String" line="220"/>
                            <declaration name="customState" type="State" line="221"/>
                            <scope line="222"/>
                        </scope>
                        <scope line="226"/>
                    </scope>
                    <scope line="230"/>
                    <declaration name="code" type="int" line="233"/>
                    <scope line="234"/>
                </scope>
                <scope line="239"/>
                <scope line="255">
                    <declaration name="temp" type="String" line="256"/>
                    <declaration name="stateString" type="String" line="259"/>
                    <declaration name="property" type="String" line="260"/>
                    <declaration name="bracketIndex" type="int" line="261"/>
                    <scope line="262"/>
                    <scope line="265"/>
                    <scope line="269">
                        <scope line="270"/>
                        <scope line="273"/>
                        <scope line="275"/>
                    </scope>
                    <scope line="279">
                        <declaration name="skip" type="boolean" line="280"/>
                        <declaration name="componentState" type="int" line="281"/>
                        <declaration name="stateParts" type="String[]" line="282"/>
                        <scope line="283">
                            <scope line="284"/>
                            <scope line="287"/>
                        </scope>
                        <declaration name="rs" type="RuntimeState" line="293"/>
                        <scope line="294">
                            <scope line="295"/>
                        </scope>
                        <scope line="300"/>
                        <scope line="304"/>
                        <scope line="307"/>
                        <scope line="310"/>
                        <scope line="313"/>
                    </scope>
                </scope>
            </method>
            <method name="getPainter" type="Painter" line="321">
                <params>
                    <param name="defaults" type="Map&lt;String,Object&gt;"/>
                    <param name="key" type="String"/>
                </params>
                <declaration name="p" type="Object" line="322"/>
                <scope line="323"/>
            </method>
            <javadoc line="328">
                @inheritDocOverridden to cause this style to populate itself with data from
                  UIDefaults, if necessary.                
            </javadoc>
            <method name="getInsets" type="Insets" line="332">
                <params>
                    <param name="ctx" type="SynthContext"/>
                    <param name="in" type="Insets"/>
                </params>
                <scope line="333"/>
                <declaration name="v" type="Values" line="336"/>
                <scope line="337"/>
                <scope line="341">
                    <declaration name="scaleKey" type="String" line="346"/>
                    <scope line="347">
                        <scope line="348"/>
                        <scope line="354"/>
                        <scope line="360"/>
                    </scope>
                </scope>
            </method>
            <javadoc line="370">
                @inheritDoc&lt;p&gt;Overridden to cause this style to populate itself with data from
                  UIDefaults, if necessary.&lt;/p&gt;
                  &lt;p&gt;In addition, NimbusStyle handles ColorTypes slightly differently from
                  Synth.&lt;/p&gt;
                  &lt;ul&gt;
                  &lt;li&gt;ColorType.BACKGROUND will equate to the color stored in UIDefaults
                  named &quot;background&quot;.&lt;/li&gt;
                  &lt;li&gt;ColorType.TEXT_BACKGROUND will equate to the color stored in
                  UIDefaults named &quot;textBackground&quot;.&lt;/li&gt;
                  &lt;li&gt;ColorType.FOREGROUND will equate to the color stored in UIDefaults
                  named &quot;textForeground&quot;.&lt;/li&gt;
                  &lt;li&gt;ColorType.TEXT_FOREGROUND will equate to the color stored in
                  UIDefaults named &quot;textForeground&quot;.&lt;/li&gt;
                  &lt;/ul&gt;                
            </javadoc>
            <method name="getColorForState" type="Color" line="386">
                <params>
                    <param name="ctx" type="SynthContext"/>
                    <param name="type" type="ColorType"/>
                </params>
                <declaration name="key" type="String" line="387"/>
                <scope line="388"/>
                <scope line="391"/>
                <scope line="394"/>
                <scope line="397"/>
                <scope line="400"/>
                <scope line="403"/>
                <scope line="406"/>
                <declaration name="c" type="Color" line="409"/>
            </method>
            <javadoc line="413">
                @inheritDocOverridden to cause this style to populate itself with data from
                  UIDefaults, if necessary. If a value named &quot;font&quot; is not found in
                  UIDefaults, then the &quot;defaultFont&quot; font in UIDefaults will be returned
                  instead.                
            </javadoc>
            <method name="getFontForState" type="Font" line="419">
                <params>
                    <param name="ctx" type="SynthContext"/>
                </params>
                <declaration name="f" type="Font" line="420"/>
                <declaration name="scaleKey" type="String" line="422"/>
                <scope line="423">
                    <scope line="424"/>
                    <scope line="427"/>
                    <scope line="430"/>
                </scope>
            </method>
            <javadoc line="436">
                @inheritDocReturns the SynthPainter for this style, which ends up delegating to
                  the Painters installed in this style.                
            </javadoc>
            <method name="getPainter" type="SynthPainter" line="440">
                <params>
                    <param name="ctx" type="SynthContext"/>
                </params>
            </method>
            <javadoc line="443">
                @inheritDocOverridden to cause this style to populate itself with data from
                  UIDefaults, if necessary. If opacity is not specified in UI defaults,
                  then it defaults to being non-opaque.                
            </javadoc>
            <method name="isOpaque" type="boolean" line="448">
                <params>
                    <param name="ctx" type="SynthContext"/>
                </params>
                <scope line="449"/>
                <declaration name="opaque" type="Boolean" line="452"/>
            </method>
            <javadoc line="455">
                @inheritDoc&lt;p&gt;Overridden to cause this style to populate itself with data from
                  UIDefaults, if necessary.&lt;/p&gt;
                  &lt;p&gt;Properties in UIDefaults may be specified in a chained manner. For
                  example:
                  &lt;pre&gt;
                  background
                  Button.opacity
                  Button.Enabled.foreground
                  Button.Enabled+Selected.background
                  &lt;/pre&gt;&lt;/p&gt;
                  &lt;p&gt;In this example, suppose you were in the Enabled+Selected state and
                  searched for &quot;foreground&quot;. In this case, we first check for
                  Button.Enabled+Selected.foreground, but no such color exists. We then
                  fall back to the next valid state, in this case,
                  Button.Enabled.foreground, and have a match. So we return it.&lt;/p&gt;
                  &lt;p&gt;Again, if we were in the state Enabled and looked for &quot;background&quot;, we
                  wouldn&apos;t find it in Button.Enabled, or in Button, but would at the top
                  level in UIManager. So we return that value.&lt;/p&gt;
                  &lt;p&gt;One special note: the &quot;key&quot; passed to this method could be of the form
                  &quot;background&quot; or &quot;Button.background&quot; where &quot;Button&quot; equals the prefix
                  passed to the NimbusStyle constructor. In either case, it looks for
                  &quot;background&quot;.&lt;/p&gt;                
                <param>
                    ctx                    
                </param>
                <param>
                    key must not be null                    
                </param>
            </javadoc>
            <method name="get" type="Object" line="481">
                <params>
                    <param name="ctx" type="SynthContext"/>
                    <param name="key" type="Object"/>
                </params>
                <declaration name="v" type="Values" line="482"/>
                <declaration name="fullKey" type="String" line="483"/>
                <declaration name="partialKey" type="String" line="484"/>
                <declaration name="obj" type="Object" line="485"/>
                <declaration name="xstate" type="int" line="486"/>
                <declaration name="wasInCache" type="boolean" line="489"/>
                <scope line="490">
                    <declaration name="s" type="RuntimeState" line="491"/>
                    <declaration name="lastIndex" type="int[]" line="492"/>
                    <scope line="493"/>
                    <scope line="496"/>
                    <scope line="500"/>
                </scope>
            </method>
            <javadoc line="507">
                Gets the appropriate background Painter, if there is one, for the state
                  specified in the given SynthContext. This method does appropriate
                  fallback searching, as described in #get.                
                <param>
                    ctx The SynthContext. Must not be null.                    
                </param>
                <return>
                    The background painter associated for the given state, or null if
                      none could be found.                    
                </return>
            </javadoc>
            <method name="getBackgroundPainter" type="Painter" line="515">
                <params>
                    <param name="ctx" type="SynthContext"/>
                </params>
                <declaration name="v" type="Values" line="516"/>
                <declaration name="xstate" type="int" line="517"/>
                <declaration name="p" type="Painter" line="518"/>
                <declaration name="s" type="RuntimeState" line="522"/>
                <declaration name="lastIndex" type="int[]" line="523"/>
                <scope line="524">
                    <scope line="525"/>
                </scope>
                <scope line="531"/>
            </method>
            <javadoc line="536">
                Gets the appropriate foreground Painter, if there is one, for the state
                  specified in the given SynthContext. This method does appropriate
                  fallback searching, as described in #get.                
                <param>
                    ctx The SynthContext. Must not be null.                    
                </param>
                <return>
                    The foreground painter associated for the given state, or null if
                      none could be found.                    
                </return>
            </javadoc>
            <method name="getForegroundPainter" type="Painter" line="544">
                <params>
                    <param name="ctx" type="SynthContext"/>
                </params>
                <declaration name="v" type="Values" line="545"/>
                <declaration name="xstate" type="int" line="546"/>
                <declaration name="p" type="Painter" line="547"/>
                <declaration name="s" type="RuntimeState" line="551"/>
                <declaration name="lastIndex" type="int[]" line="552"/>
                <scope line="553">
                    <scope line="554"/>
                </scope>
                <scope line="560"/>
            </method>
            <javadoc line="565">
                Gets the appropriate border Painter, if there is one, for the state
                  specified in the given SynthContext. This method does appropriate
                  fallback searching, as described in #get.                
                <param>
                    ctx The SynthContext. Must not be null.                    
                </param>
                <return>
                    The border painter associated for the given state, or null if
                      none could be found.                    
                </return>
            </javadoc>
            <method name="getBorderPainter" type="Painter" line="573">
                <params>
                    <param name="ctx" type="SynthContext"/>
                </params>
                <declaration name="v" type="Values" line="574"/>
                <declaration name="xstate" type="int" line="575"/>
                <declaration name="p" type="Painter" line="576"/>
                <declaration name="s" type="RuntimeState" line="580"/>
                <declaration name="lastIndex" type="int[]" line="581"/>
                <scope line="582">
                    <scope line="583"/>
                </scope>
                <scope line="589"/>
            </method>
            <javadoc line="594">
                Utility method which returns the proper Values based on the given
                  SynthContext. Ensures that parsing of the values has occurred, or
                  reoccurs as necessary.                
                <param>
                    ctx The SynthContext                    
                </param>
                <return>
                    a non-null values reference                    
                </return>
            </javadoc>
            <method name="getValues" type="Values" line="601">
                <params>
                    <param name="ctx" type="SynthContext"/>
                </params>
            </method>
            <javadoc line="605">
                Simple utility method that searchs the given array of Strings for the
                  given string. This method is only called from getExtendedState if
                  the developer has specified a specific state for the component to be
                  in (ie, has &quot;wedged&quot; the component in that state) by specifying
                  they client property &quot;Nimbus.State&quot;.                
                <param>
                    names a non-null array of strings                    
                </param>
                <param>
                    name the name to look for in the array                    
                </param>
                <return>
                    true or false based on whether the given name is in the array                    
                </return>
            </javadoc>
            <method name="contains" type="boolean" line="615">
                <params>
                    <param name="names" type="String[]"/>
                    <param name="name" type="String"/>
                </params>
            </method>
            <javadoc line="624">
                &lt;p&gt;Gets the extended state for a given synth context. Nimbus supports the
                  ability to define custom states. The algorithm used for choosing what
                  style information to use for a given state requires a single integer
                  bit string where each bit in the integer represents a different state
                  that the component is in. This method uses the componentState as
                  reported in the SynthContext, in addition to custom states, to determine
                  what this extended state is.&lt;/p&gt;
                  &lt;p&gt;In addition, this method checks the component in the given context
                  for a client property called &quot;Nimbus.State&quot;. If one exists, then it will
                  decompose the String associated with that property to determine what
                  state to return. In this way, the developer can force a component to be
                  in a specific state, regardless of what the &quot;real&quot; state of the component
                  is.&lt;/p&gt;
                  &lt;p&gt;The string associated with &quot;Nimbus.State&quot; would be of the form:
                  &lt;pre&gt;Enabled+CustomState+MouseOver&lt;/pre&gt;&lt;/p&gt;                
                <param>
                    ctx                    
                </param>
                <param>
                    v                    
                </param>
                <return>
                                        
                </return>
            </javadoc>
            <method name="getExtendedState" type="int" line="644">
                <params>
                    <param name="ctx" type="SynthContext"/>
                    <param name="v" type="Values"/>
                </params>
                <declaration name="c" type="JComponent" line="645"/>
                <declaration name="xstate" type="int" line="646"/>
                <declaration name="mask" type="int" line="647"/>
                <declaration name="property" type="Object" line="648"/>
                <scope line="649">
                    <declaration name="stateNames" type="String" line="650"/>
                    <declaration name="states" type="String[]" line="651"/>
                    <scope line="652">
                        <scope line="653">
                            <declaration name="s" type="State.StandardState" line="654"/>
                        </scope>
                    </scope>
                    <scope line="658">
                        <scope line="659">
                            <scope line="660"/>
                        </scope>
                    </scope>
                </scope>
                <scope line="667">
                    <declaration name="state" type="int" line="669"/>
                    <scope line="670">
                        <scope line="671"/>
                    </scope>
                </scope>
            </method>
            <javadoc line="679">
                &lt;p&gt;Gets the RuntimeState that most closely matches the state in the given
                  context, but is less specific than the given &quot;lastState&quot;. Essentially,
                  this allows you to search for the next best state.&lt;/p&gt;
                  &lt;p&gt;For example, if you had the following three states:
                  &lt;pre&gt;
                  Enabled
                  Enabled+Pressed
                  Disabled
                  &lt;/pre&gt;
                  And you wanted to find the state that best represented
                  ENABLED+PRESSED+FOCUSED and &lt;code&gt;lastState&lt;/code&gt; was null (or an
                  empty array, or an array with a single int with index == -1), then
                  Enabled+Pressed would be returned. If you then call this method again but
                  pass the index of Enabled+Pressed as the &quot;lastState&quot;, then
                  Enabled would be returned. If you call this method a third time and pass
                  the index of Enabled in as the &lt;code&gt;lastState&lt;/code&gt;, then null would be
                  returned.&lt;/p&gt;
                  &lt;p&gt;The actual code path for determining the proper state is the same as
                  in Synth.&lt;/p&gt;                
                <param>
                    ctx                    
                </param>
                <param>
                    lastState a 1 element array, allowing me to do pass-by-reference.                    
                </param>
                <return>
                                        
                </return>
            </javadoc>
            <method name="getNextState" type="RuntimeState" line="703">
                <params>
                    <param name="states" type="RuntimeState[]"/>
                    <param name="lastState" type="int[]"/>
                    <param name="xstate" type="int"/>
                </params>
                <scope line="704">
                    <declaration name="bestCount" type="int" line="705"/>
                    <declaration name="bestIndex" type="int" line="706"/>
                    <declaration name="wildIndex" type="int" line="707"/>
                    <scope line="708">
                        <scope line="709">
                            <scope line="710"/>
                        </scope>
                    </scope>
                    <declaration name="lastStateIndex" type="int" line="718"/>
                    <scope line="719">
                        <declaration name="oState" type="int" line="720"/>
                        <scope line="721">
                            <scope line="722"/>
                        </scope>
                        <scope line="726">
                            <declaration name="bitCount" type="int" line="727"/>
                            <scope line="734"/>
                        </scope>
                    </scope>
                    <scope line="740"/>
                    <scope line="744"/>
                </scope>
            </method>
            <class name="RuntimeState" line="752">
                <implements interface="Cloneable"/>
                <javadoc line="752">
                    Contains values such as the UIDefaults and painters asssociated with
                      a state. Whereas &lt;code&gt;State&lt;/code&gt; represents a distinct state that a
                      component can be in (such as Enabled), this class represents the colors,
                      fonts, painters, etc associated with some state for this
                      style.                    
                </javadoc>
                <declaration name="state" type="int" line="760"/>
                <declaration name="backgroundPainter" type="Painter" line="761"/>
                <declaration name="foregroundPainter" type="Painter" line="762"/>
                <declaration name="borderPainter" type="Painter" line="763"/>
                <declaration name="stateName" type="String" line="764"/>
                <declaration name="defaults" type="UIDefaults" line="765"/>
                <method name="RuntimeState" type="constructor" line="766">
                    <params>
                        <param name="state" type="int"/>
                        <param name="stateName" type="String"/>
                    </params>
                </method>
                <method name="toString" type="String" line="770"/>
                <method name="clone" type="RuntimeState" line="773">
                    <declaration name="clone" type="RuntimeState" line="774"/>
                </method>
            </class>
            <class name="Values" line="782">
                <javadoc line="782">
                    Essentially a struct of data for a style. A default instance of this
                      class is used by NimbusStyle. Additional instances exist for each
                      component that has overrides.                    
                </javadoc>
                <declaration name="stateTypes" type="State[]" line="788"/>
                <javadoc line="788">
                    The list of State types. A State represents a type of state, such
                      as Enabled, Default, WindowFocused, etc. These can be custom states.                    
                </javadoc>
                <declaration name="states" type="RuntimeState[]" line="793"/>
                <javadoc line="793">
                    The list of actual runtime state representations. These can represent things such
                      as Enabled + Focused. Thus, they differ from States in that they contain
                      several states together, and have associated properties, data, etc.                    
                </javadoc>
                <declaration name="contentMargins" type="Insets" line="799"/>
                <javadoc line="799">
                    The content margins for this region.                    
                </javadoc>
                <declaration name="defaults" type="UIDefaults" line="803"/>
                <javadoc line="803">
                    Defaults on the region/component level.                    
                </javadoc>
                <declaration name="cache" type="Map&amp;lt;CacheKey,Object&amp;gt;" line="807"/>
                <javadoc line="807">
                    Simple cache. After a value has been looked up, it is stored
                      in this cache for later retrieval. The key is a concatenation of
                      the property being looked up, two dollar signs, and the extended
                      state. So for example:
                      foo.bar$$2353                    
                </javadoc>
            </class>
            <class name="CacheKey" line="816">
                <javadoc line="816">
                    This implementation presupposes that key is never null and that
                      the two keys being checked for equality are never null                    
                </javadoc>
                <declaration name="key" type="String" line="821"/>
                <declaration name="xstate" type="int" line="822"/>
                <method name="CacheKey" type="constructor" line="823">
                    <params>
                        <param name="key" type="Object"/>
                        <param name="xstate" type="int"/>
                    </params>
                </method>
                <method name="init" type="void" line="826">
                    <params>
                        <param name="key" type="Object"/>
                        <param name="xstate" type="int"/>
                    </params>
                </method>
                <method name="equals" type="boolean" line="830">
                    <params>
                        <param name="obj" type="Object"/>
                    </params>
                    <declaration name="other" type="CacheKey" line="831"/>
                </method>
                <method name="hashCode" type="int" line="837">
                    <declaration name="hash" type="int" line="838"/>
                </method>
            </class>
        </class>
    </source>