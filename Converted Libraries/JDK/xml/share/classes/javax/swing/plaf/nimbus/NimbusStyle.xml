<?xml version="1.0" encoding="UTF-8"?>
    <source package="javax.swing.plaf.nimbus">
        <import package="javax.swing.Painter"/>
        <import package="javax.swing.JComponent"/>
        <import package="javax.swing.UIDefaults"/>
        <import package="javax.swing.UIManager"/>
        <import package="javax.swing.plaf.ColorUIResource"/>
        <import package="javax.swing.plaf.synth.ColorType"/>
        <import package="javax.swing.plaf.synth.SynthConstants"/>
        <import package="javax.swing.plaf.synth.SynthContext"/>
        <import package="javax.swing.plaf.synth.SynthPainter"/>
        <import package="javax.swing.plaf.synth.SynthStyle"/>
        <import package="java.awt.Color"/>
        <import package="java.awt.Font"/>
        <import package="java.awt.Insets"/>
        <import package="java.lang.ref.WeakReference"/>
        <import package="java.util.ArrayList"/>
        <import package="java.util.Collections"/>
        <import package="java.util.Comparator"/>
        <import package="java.util.HashMap"/>
        <import package="java.util.List"/>
        <import package="java.util.Map"/>
        <import package="java.util.TreeMap"/>
        <class name="NimbusStyle" line="50">
            <extends class="SynthStyle"/>
            <comment line="123">
                                
            </comment>
            <javadoc line="50">
                &lt;p&gt;A SynthStyle implementation used by Nimbus. Each Region that has been
                  registered with the NimbusLookAndFeel will have an associated NimbusStyle.
                  Third party components that are registered with the NimbusLookAndFeel will
                  therefore be handed a NimbusStyle from the look and feel from the
                  #getStyle(JComponent, Region) method.&lt;/p&gt;
                  &lt;p&gt;This class properly reads and retrieves values placed in the UIDefaults
                  according to the standard Nimbus naming conventions. It will create and
                  retrieve painters, fonts, colors, and other data stored there.&lt;/p&gt;
                  &lt;p&gt;NimbusStyle also supports the ability to override settings on a per
                  component basis. NimbusStyle checks the component&apos;s client property map for
                  &quot;Nimbus.Overrides&quot;. If the value associated with this key is an instance of
                  UIDefaults, then the values in that defaults table will override the standard
                  Nimbus defaults in UIManager, but for that component instance only.&lt;/p&gt;
                  &lt;p&gt;Optionally, you may specify the client property
                  &quot;Nimbus.Overrides.InheritDefaults&quot;. If true, this client property indicates
                  that the defaults located in UIManager should first be read, and then
                  replaced with defaults located in the component client properties. If false,
                  then only the defaults located in the component client property map will
                  be used. If not specified, it is assumed to be true.&lt;/p&gt;
                  &lt;p&gt;You must specify &quot;Nimbus.Overrides&quot; for &quot;Nimbus.Overrides.InheritDefaults&quot;
                  to have any effect. &quot;Nimbus.Overrides&quot; indicates whether there are any
                  overrides, while &quot;Nimbus.Overrides.InheritDefaults&quot; indicates whether those
                  overrides should first be initialized with the defaults from UIManager.&lt;/p&gt;
                  &lt;p&gt;The NimbusStyle is reloaded whenever a property change event is fired
                  for a component for &quot;Nimbus.Overrides&quot; or &quot;Nimbus.Overrides.InheritDefaults&quot;.
                  So for example, setting a new UIDefaults on a component would cause the
                  style to be reloaded.&lt;/p&gt;
                  &lt;p&gt;The values are only read out of UIManager once, and then cached. If
                  you need to read the values again (for example, if the UI is being reloaded),
                  then discard this NimbusStyle and read a new one from NimbusLookAndFeel
                  using NimbusLookAndFeel.getStyle.&lt;/p&gt;
                  &lt;p&gt;The primary API of interest in this class for 3rd party component authors
                  are the three methods which retrieve painters: #getBackgroundPainter,
                  #getForegroundPainter, and #getBorderPainter.&lt;/p&gt;
                  &lt;p&gt;NimbusStyle allows you to specify custom states, or modify the order of
                  states. Synth (and thus Nimbus) has the concept of a &quot;state&quot;. For example,
                  a JButton might be in the &quot;MOUSE_OVER&quot; state, or the &quot;ENABLED&quot; state, or the
                  &quot;DISABLED&quot; state. These are all &quot;standard&quot; states which are defined in synth,
                  and which apply to all synth Regions.&lt;/p&gt;
                  &lt;p&gt;Sometimes, however, you need to have a custom state. For example, you
                  want JButton to render differently if it&apos;s parent is a JToolbar. In Nimbus,
                  you specify these custom states by including a special key in UIDefaults.
                  The following UIDefaults entries define three states for this button:&lt;/p&gt;
                  &lt;pre&gt;&lt;code&gt;
                  JButton.States = Enabled, Disabled, Toolbar
                  JButton[Enabled].backgroundPainter = somePainter
                  JButton[Disabled].background = BLUE
                  JButton[Toolbar].backgroundPainter = someOtherPaint
                  &lt;/code&gt;&lt;/pre&gt;
                  &lt;p&gt;As you can see, the &lt;code&gt;JButton.States&lt;/code&gt; entry lists the states
                  that the JButton style will support. You then specify the settings for
                  each state. If you do not specify the &lt;code&gt;JButton.States&lt;/code&gt; entry,
                  then the standard Synth states will be assumed. If you specify the entry
                  but the list of states is empty or null, then the standard synth states
                  will be assumed.&lt;/p&gt;                
                <author>
                    Richard Bair                    
                </author>
                <author>
                    Jasper Potts                    
                </author>
            </javadoc>
            <declaration name="LARGE_KEY" type="String" line="123"/>
            <declaration name="SMALL_KEY" type="String" line="124"/>
            <declaration name="MINI_KEY" type="String" line="125"/>
            <declaration name="LARGE_SCALE" type="double" line="126"/>
            <declaration name="SMALL_SCALE" type="double" line="127"/>
            <declaration name="MINI_SCALE" type="double" line="128"/>
            <declaration name="NULL" type="Object" line="130"/>
            <javadoc line="130">
                Special constant used for performance reasons during the get() method.
                  If get() runs through all of the search locations and determines that
                  there is no value, then NULL will be placed into the values map. This way
                  on subsequent lookups it will simply extract NULL, see it, and return
                  null rather than continuing the lookup procedure.                
            </javadoc>
            <declaration name="DEFAULT_COLOR" type="Color" line="138"/>
            <javadoc line="138">
                &lt;p&gt;The Color to return from getColorForState if it would otherwise have
                  returned null.&lt;/p&gt;
                  &lt;p&gt;Returning null from getColorForState is a very bad thing, as it causes
                  the AWT peer for the component to install a SystemColor, which is not a
                  UIResource. As a result, if &lt;code&gt;null&lt;/code&gt; is returned from
                  getColorForState, then thereafter the color is not updated for other
                  states or on LAF changes or updates. This DEFAULT_COLOR is used to
                  ensure that a ColorUIResource is always returned from
                  getColorForState.&lt;/p&gt;                
            </javadoc>
            <declaration name="STATE_COMPARATOR" type="Comparator&lt;RuntimeState&gt;" line="151"/>
            <javadoc line="151">
                Simple Comparator for ordering the RuntimeStates according to their
                  rank.                
            </javadoc>
            <anonymous_class line="156">
                <method name="compare" type="int" line="158">
                    <params>
                        <param name="a" type="RuntimeState"/>
                        <param name="b" type="RuntimeState"/>
                    </params>
                </method>
            </anonymous_class>
            <declaration name="prefix" type="String" line="162"/>
            <javadoc line="162">
                The prefix for the component or region that this NimbusStyle
                  represents. This prefix is used to lookup state in the UIManager.
                  It should be something like Button or Slider.Thumb or &quot;MyButton&quot; or
                  ComboBox.&quot;ComboBox.arrowButton&quot; or &quot;MyComboBox&quot;.&quot;ComboBox.arrowButton&quot;                
            </javadoc>
            <declaration name="painter" type="SynthPainter" line="169"/>
            <javadoc line="169">
                The SynthPainter that will be returned from this NimbusStyle. The
                  SynthPainter returned will be a SynthPainterImpl, which will in turn
                  delegate back to this NimbusStyle for the proper Painter (not
                  SynthPainter) to use for painting the foreground, background, or border.                
            </javadoc>
            <declaration name="values" type="Values" line="176"/>
            <javadoc line="176">
                Data structure containing all of the defaults, insets, states, and other
                  values associated with this style. This instance refers to default
                  values, and are used when no overrides are discovered in the client
                  properties of a component. These values are lazily created on first
                  access.                
            </javadoc>
            <declaration name="tmpKey" type="CacheKey" line="185"/>
            <javadoc line="185">
                A temporary CacheKey used to perform lookups. This pattern avoids
                  creating useless garbage keys, or concatenating strings, etc.                
            </javadoc>
            <declaration name="component" type="WeakReference&lt;JComponent&gt;" line="191"/>
            <javadoc line="191">
                Some NimbusStyles are created for a specific component only. In Nimbus,
                  this happens whenever the component has as a client property a
                  UIDefaults which overrides (or supplements) those defaults found in
                  UIManager.                
            </javadoc>
            <javadoc line="199">
                Create a new NimbusStyle. Only the prefix must be supplied. At the
                  appropriate time, installDefaults will be called. At that point, all of
                  the state information will be pulled from UIManager and stored locally
                  within this style.                
                <param>
                    prefix Something like Button or Slider.Thumb or
                      org.jdesktop.swingx.JXStatusBar or ComboBox."ComboBox.arrowButton"                    
                </param>
                <param>
                    c an optional reference to a component that this NimbusStyle
                      should be associated with. This is only used when the component
                      has Nimbus overrides registered in its client properties and
                      should be null otherwise.                    
                </param>
            </javadoc>
            <method name="NimbusStyle" type="constructor" line="212">
                <params>
                    <param name="prefix" type="String"/>
                    <param name="c" type="JComponent"/>
                </params>
                <scope line="213"/>
            </method>
            <javadoc line="220">
                @inheritDocOverridden to cause this style to populate itself with data from
                  UIDefaults, if necessary.                
            </javadoc>
            <method name="installDefaults" type="void" line="226">
                <params>
                    <param name="ctx" type="SynthContext"/>
                </params>
                <comment line="229">
                    delegate to the superclass to install defaults such as background,                    
                </comment>
                <comment line="230">
                    foreground, font, and opaque onto the swing component.                    
                </comment>
            </method>
            <javadoc line="234">
                Pulls data out of UIDefaults, if it has not done so already, and sets
                  up the internal state.                
            </javadoc>
            <method name="validate" type="void" line="238">
                <comment line="239">
                    a non-null values object is the flag we use to determine whether                    
                </comment>
                <comment line="240">
                    to reparse from UIManager.                    
                </comment>
                <comment line="243">
                    reconstruct this NimbusStyle based on the entries in the UIManager                    
                </comment>
                <comment line="244">
                    and possibly based on any overrides within the component&apos;s                    
                </comment>
                <comment line="245">
                    client properties (assuming such a component exists and contains                    
                </comment>
                <comment line="246">
                    any Nimbus.Overrides)                    
                </comment>
                <comment line="253">
                    inspect the client properties for the key &quot;Nimbus.Overrides&quot;. If the                    
                </comment>
                <comment line="254">
                    value is an instance of UIDefaults, then these defaults are used                    
                </comment>
                <comment line="255">
                    in place of, or in addition to, the defaults in UIManager.                    
                </comment>
                <comment line="257">
                    We know component.get() is non-null here, as if the component                    
                </comment>
                <comment line="258">
                    were GC&apos;ed, we wouldn&apos;t be processing its style.                    
                </comment>
                <comment line="282">
                    a list of the different types of states used by this style. This                    
                </comment>
                <comment line="283">
                    list may contain only &quot;standard&quot; states (those defined by Synth),                    
                </comment>
                <comment line="284">
                    or it may contain custom states, or it may contain only &quot;standard&quot;                    
                </comment>
                <comment line="285">
                    states but list them in a non-standard order.                    
                </comment>
                <comment line="287">
                    a map of state name to code                    
                </comment>
                <comment line="289">
                    This is a list of runtime &quot;state&quot; context objects. These contain                    
                </comment>
                <comment line="290">
                    the values associated with each state.                    
                </comment>
                <comment line="293">
                    determine whether there are any custom states, or custom state                    
                </comment>
                <comment line="294">
                    order. If so, then read all those custom states and define the                    
                </comment>
                <comment line="295">
                    &quot;values&quot; stateTypes to be a non-null array.                    
                </comment>
                <comment line="296">
                    Otherwise, let the &quot;values&quot; stateTypes be null to indicate that                    
                </comment>
                <comment line="297">
                    there are no custom states or custom state ordering                    
                </comment>
                <comment line="304">
                    this is a non-standard state name, so look for the                    
                </comment>
                <comment line="305">
                    custom state associated with it                    
                </comment>
                <comment line="316">
                    if there were any states defined, then set the stateTypes array                    
                </comment>
                <comment line="317">
                    to be non-null. Otherwise, leave it null (meaning, use the                    
                </comment>
                <comment line="318">
                    standard synth states).                    
                </comment>
                <comment line="323">
                    assign codes for each of the state types                    
                </comment>
                <comment line="330">
                    since there were no custom states defined, setup the list of                    
                </comment>
                <comment line="331">
                    standard synth states. Note that the &quot;v.stateTypes&quot; is not                    
                </comment>
                <comment line="332">
                    being set here, indicating that at runtime the state selection                    
                </comment>
                <comment line="333">
                    routines should use standard synth states instead of custom                    
                </comment>
                <comment line="334">
                    states. I do need to popuplate this temp list now though, so that                    
                </comment>
                <comment line="335">
                    the remainder of this method will function as expected.                    
                </comment>
                <comment line="344">
                    assign codes for the states                    
                </comment>
                <comment line="354">
                    Now iterate over all the keys in the defaults table                    
                </comment>
                <comment line="356">
                    The key is something like JButton.Enabled.backgroundPainter,                    
                </comment>
                <comment line="357">
                    or JButton.States, or JButton.background.                    
                </comment>
                <comment line="358">
                    Remove the &quot;JButton.&quot; portion of the key                    
                </comment>
                <comment line="360">
                    if there is a &quot; or : then we skip it because it is a subregion                    
                </comment>
                <comment line="361">
                    of some kind                    
                </comment>
                <comment line="363">
                    remove the separator                    
                </comment>
                <comment line="365">
                    At this point, temp may be any of the following:                    
                </comment>
                <comment line="366">
                    background                    
                </comment>
                <comment line="367">
                    [Enabled].background                    
                </comment>
                <comment line="368">
                    [Enabled+MouseOver].background                    
                </comment>
                <comment line="369">
                    property.foo                    
                </comment>
                <comment line="371">
                    parse out the states and the property                    
                </comment>
                <comment line="376">
                    there is not a state string, so property = temp                    
                </comment>
                <comment line="383">
                    now that I have the state (if any) and the property, get the                    
                </comment>
                <comment line="384">
                    value for this property and install it where it belongs                    
                </comment>
                <comment line="386">
                    there was no state, just a property. Check for the custom                    
                </comment>
                <comment line="387">
                    &quot;contentMargins&quot; property (which is handled specially by                    
                </comment>
                <comment line="388">
                    Synth/Nimbus). Also check for the property being &quot;States&quot;,                    
                </comment>
                <comment line="389">
                    in which case it is not a real property and should be ignored.                    
                </comment>
                <comment line="390">
                    otherwise, assume it is a property and install it on the                    
                </comment>
                <comment line="391">
                    values object                    
                </comment>
                <comment line="395">
                    ignore                    
                </comment>
                <comment line="400">
                    it is possible that the developer has a malformed UIDefaults                    
                </comment>
                <comment line="401">
                    entry, such that something was specified in the place of                    
                </comment>
                <comment line="402">
                    the State portion of the key but it wasn&apos;t a state. In this                    
                </comment>
                <comment line="403">
                    case, skip will be set to true                    
                </comment>
                <comment line="405">
                    this variable keeps track of the int value associated with                    
                </comment>
                <comment line="406">
                    the state. See SynthState for details.                    
                </comment>
                <comment line="408">
                    Multiple states may be specified in the string, such as                    
                </comment>
                <comment line="409">
                    Enabled+MouseOver                    
                </comment>
                <comment line="411">
                    For each state, we need to find the State object associated                    
                </comment>
                <comment line="412">
                    with it, or skip it if it cannot be found.                    
                </comment>
                <comment line="417">
                    Was not a state. Maybe it was a subregion or something                    
                </comment>
                <comment line="418">
                    skip it.                    
                </comment>
                <comment line="426">
                    find the RuntimeState for this State                    
                </comment>
                <comment line="435">
                    couldn&apos;t find the runtime state, so create a new one                    
                </comment>
                <comment line="441">
                    check for a couple special properties, such as for the                    
                </comment>
                <comment line="442">
                    painters. If these are found, then set the specially on                    
                </comment>
                <comment line="443">
                    the runtime state. Else, it is just a normal property,                    
                </comment>
                <comment line="444">
                    so put it in the UIDefaults associated with that runtime                    
                </comment>
                <comment line="445">
                    state                    
                </comment>
                <comment line="458">
                    now that I&apos;ve collected all the runtime states, I&apos;ll sort them based                    
                </comment>
                <comment line="459">
                    on their integer &quot;state&quot; (see SynthState for how this works).                    
                </comment>
                <comment line="462">
                    finally, set the array of runtime states on the values object                    
                </comment>
                <declaration name="defaults" type="Map&lt;String,Object&gt;" line="249"/>
                <scope line="256">
                    <declaration name="o" type="Object" line="259"/>
                    <scope line="260">
                        <declaration name="i" type="Object" line="261"/>
                        <declaration name="inherit" type="boolean" line="263"/>
                        <declaration name="d" type="UIDefaults" line="264"/>
                        <declaration name="map" type="TreeMap&lt;String,Object&gt;" line="265"/>
                        <scope line="266">
                            <scope line="267">
                                <declaration name="key" type="String" line="268"/>
                                <scope line="269"/>
                            </scope>
                        </scope>
                        <scope line="274"/>
                        <scope line="276"/>
                    </scope>
                </scope>
                <declaration name="states" type="List&lt;State&gt;" line="286"/>
                <declaration name="stateCodes" type="Map&lt;String,Integer&gt;" line="288"/>
                <declaration name="runtimeStates" type="List&lt;RuntimeState&gt;" line="291"/>
                <declaration name="statesString" type="String" line="298"/>
                <scope line="299">
                    <declaration name="s" type="String" line="300"/>
                    <scope line="301">
                        <scope line="303">
                            <declaration name="stateName" type="String" line="306"/>
                            <declaration name="customState" type="State" line="307"/>
                            <scope line="308"/>
                        </scope>
                        <scope line="311"/>
                    </scope>
                    <scope line="319"/>
                    <declaration name="code" type="int" line="324"/>
                    <scope line="325"/>
                </scope>
                <scope line="329"/>
                <scope line="355">
                    <declaration name="temp" type="String" line="359"/>
                    <declaration name="stateString" type="String" line="372"/>
                    <declaration name="property" type="String" line="373"/>
                    <declaration name="bracketIndex" type="int" line="374"/>
                    <scope line="375"/>
                    <scope line="378"/>
                    <scope line="385">
                        <scope line="392"/>
                        <scope line="394"/>
                        <scope line="396"/>
                    </scope>
                    <scope line="399">
                        <declaration name="skip" type="boolean" line="404"/>
                        <declaration name="componentState" type="int" line="407"/>
                        <declaration name="stateParts" type="String[]" line="410"/>
                        <scope line="413">
                            <scope line="414"/>
                            <scope line="416"/>
                        </scope>
                        <declaration name="rs" type="RuntimeState" line="427"/>
                        <scope line="428">
                            <scope line="429"/>
                        </scope>
                        <scope line="436"/>
                        <scope line="446"/>
                        <scope line="448"/>
                        <scope line="450"/>
                        <scope line="452"/>
                    </scope>
                </scope>
            </method>
            <method name="getPainter" type="Painter" line="466">
                <params>
                    <param name="defaults" type="Map<String,Object>"/>
                    <param name="key" type="String"/>
                </params>
                <declaration name="p" type="Object" line="467"/>
                <scope line="468"/>
            </method>
            <javadoc line="474">
                @inheritDocOverridden to cause this style to populate itself with data from
                  UIDefaults, if necessary.                
            </javadoc>
            <method name="getInsets" type="Insets" line="480">
                <params>
                    <param name="ctx" type="SynthContext"/>
                    <param name="in" type="Insets"/>
                </params>
                <comment line="495">
                    Account for scale                    
                </comment>
                <comment line="496">
                    The key &quot;JComponent.sizeVariant&quot; is used to match Apple&apos;s LAF                    
                </comment>
                <scope line="481"/>
                <declaration name="v" type="Values" line="485"/>
                <scope line="487"/>
                <scope line="490">
                    <declaration name="scaleKey" type="String" line="497"/>
                    <scope line="499">
                        <scope line="500"/>
                        <scope line="505"/>
                        <scope line="510"/>
                    </scope>
                </scope>
            </method>
            <javadoc line="521">
                @inheritDoc&lt;p&gt;Overridden to cause this style to populate itself with data from
                  UIDefaults, if necessary.&lt;/p&gt;
                  &lt;p&gt;In addition, NimbusStyle handles ColorTypes slightly differently from
                  Synth.&lt;/p&gt;
                  &lt;ul&gt;
                  &lt;li&gt;ColorType.BACKGROUND will equate to the color stored in UIDefaults
                  named &quot;background&quot;.&lt;/li&gt;
                  &lt;li&gt;ColorType.TEXT_BACKGROUND will equate to the color stored in
                  UIDefaults named &quot;textBackground&quot;.&lt;/li&gt;
                  &lt;li&gt;ColorType.FOREGROUND will equate to the color stored in UIDefaults
                  named &quot;textForeground&quot;.&lt;/li&gt;
                  &lt;li&gt;ColorType.TEXT_FOREGROUND will equate to the color stored in
                  UIDefaults named &quot;textForeground&quot;.&lt;/li&gt;
                  &lt;/ul&gt;                
            </javadoc>
            <method name="getColorForState" type="Color" line="540">
                <params>
                    <param name="ctx" type="SynthContext"/>
                    <param name="type" type="ColorType"/>
                </params>
                <comment line="545">
                    map FOREGROUND as TEXT_FOREGROUND                    
                </comment>
                <comment line="559">
                    if all else fails, return a default color (which is a ColorUIResource)                    
                </comment>
                <declaration name="key" type="String" line="541"/>
                <scope line="542"/>
                <scope line="544"/>
                <scope line="547"/>
                <scope line="549"/>
                <scope line="551"/>
                <scope line="553"/>
                <scope line="555"/>
                <declaration name="c" type="Color" line="558"/>
            </method>
            <javadoc line="564">
                @inheritDocOverridden to cause this style to populate itself with data from
                  UIDefaults, if necessary. If a value named &quot;font&quot; is not found in
                  UIDefaults, then the &quot;defaultFont&quot; font in UIDefaults will be returned
                  instead.                
            </javadoc>
            <method name="getFontForState" type="Font" line="572">
                <params>
                    <param name="ctx" type="SynthContext"/>
                </params>
                <comment line="576">
                    Account for scale                    
                </comment>
                <comment line="577">
                    The key &quot;JComponent.sizeVariant&quot; is used to match Apple&apos;s LAF                    
                </comment>
                <declaration name="f" type="Font" line="573"/>
                <declaration name="scaleKey" type="String" line="578"/>
                <scope line="580">
                    <scope line="581"/>
                    <scope line="583"/>
                    <scope line="585"/>
                </scope>
            </method>
            <javadoc line="592">
                @inheritDocReturns the SynthPainter for this style, which ends up delegating to
                  the Painters installed in this style.                
            </javadoc>
            <method name="getPainter" type="SynthPainter" line="598">
                <params>
                    <param name="ctx" type="SynthContext"/>
                </params>
            </method>
            <javadoc line="602">
                @inheritDocOverridden to cause this style to populate itself with data from
                  UIDefaults, if necessary. If opacity is not specified in UI defaults,
                  then it defaults to being non-opaque.                
            </javadoc>
            <method name="isOpaque" type="boolean" line="609">
                <params>
                    <param name="ctx" type="SynthContext"/>
                </params>
                <comment line="610">
                    Force Table CellRenderers to be opaque                    
                </comment>
                <scope line="611"/>
                <declaration name="opaque" type="Boolean" line="614"/>
            </method>
            <javadoc line="618">
                @inheritDoc&lt;p&gt;Overridden to cause this style to populate itself with data from
                  UIDefaults, if necessary.&lt;/p&gt;
                  &lt;p&gt;Properties in UIDefaults may be specified in a chained manner. For
                  example:
                  &lt;pre&gt;
                  background
                  Button.opacity
                  Button.Enabled.foreground
                  Button.Enabled+Selected.background
                  &lt;/pre&gt;&lt;/p&gt;
                  &lt;p&gt;In this example, suppose you were in the Enabled+Selected state and
                  searched for &quot;foreground&quot;. In this case, we first check for
                  Button.Enabled+Selected.foreground, but no such color exists. We then
                  fall back to the next valid state, in this case,
                  Button.Enabled.foreground, and have a match. So we return it.&lt;/p&gt;
                  &lt;p&gt;Again, if we were in the state Enabled and looked for &quot;background&quot;, we
                  wouldn&apos;t find it in Button.Enabled, or in Button, but would at the top
                  level in UIManager. So we return that value.&lt;/p&gt;
                  &lt;p&gt;One special note: the &quot;key&quot; passed to this method could be of the form
                  &quot;background&quot; or &quot;Button.background&quot; where &quot;Button&quot; equals the prefix
                  passed to the NimbusStyle constructor. In either case, it looks for
                  &quot;background&quot;.&lt;/p&gt;                
                <param>
                    ctx                    
                </param>
                <param>
                    key must not be null                    
                </param>
            </javadoc>
            <method name="get" type="Object" line="651">
                <params>
                    <param name="ctx" type="SynthContext"/>
                    <param name="key" type="Object"/>
                </params>
                <comment line="654">
                    strip off the prefix, if there is one.                    
                </comment>
                <comment line="661">
                    check the cache                    
                </comment>
                <comment line="666">
                    Search exact matching states and then lesser matching states                    
                </comment>
                <comment line="673">
                    Search Region Defaults                    
                </comment>
                <comment line="677">
                    return found object                    
                </comment>
                <comment line="678">
                    Search UIManager Defaults                    
                </comment>
                <comment line="680">
                    Search Synth Defaults for InputMaps                    
                </comment>
                <comment line="684">
                    if all we got was a null, store this fact for later use                    
                </comment>
                <comment line="688">
                    return found object                    
                </comment>
                <declaration name="v" type="Values" line="652"/>
                <declaration name="fullKey" type="String" line="655"/>
                <declaration name="partialKey" type="String" line="656"/>
                <declaration name="obj" type="Object" line="658"/>
                <declaration name="xstate" type="int" line="659"/>
                <declaration name="wasInCache" type="boolean" line="664"/>
                <scope line="665">
                    <declaration name="s" type="RuntimeState" line="667"/>
                    <declaration name="lastIndex" type="int[]" line="668"/>
                    <scope line="670"/>
                    <scope line="674"/>
                    <scope line="681"/>
                </scope>
            </method>
            <javadoc line="692">
                Gets the appropriate background Painter, if there is one, for the state
                  specified in the given SynthContext. This method does appropriate
                  fallback searching, as described in #get.                
                <param>
                    ctx The SynthContext. Must not be null.                    
                </param>
                <return>
                    The background painter associated for the given state, or null if
                      none could be found.                    
                </return>
            </javadoc>
            <method name="getBackgroundPainter" type="Painter" line="701">
                <params>
                    <param name="ctx" type="SynthContext"/>
                </params>
                <comment line="706">
                    check the cache                    
                </comment>
                <comment line="711">
                    not in cache, so lookup and store in cache                    
                </comment>
                <declaration name="v" type="Values" line="702"/>
                <declaration name="xstate" type="int" line="703"/>
                <declaration name="p" type="Painter" line="704"/>
                <declaration name="s" type="RuntimeState" line="712"/>
                <declaration name="lastIndex" type="int[]" line="713"/>
                <scope line="714">
                    <scope line="715"/>
                </scope>
                <scope line="721"/>
            </method>
            <javadoc line="727">
                Gets the appropriate foreground Painter, if there is one, for the state
                  specified in the given SynthContext. This method does appropriate
                  fallback searching, as described in #get.                
                <param>
                    ctx The SynthContext. Must not be null.                    
                </param>
                <return>
                    The foreground painter associated for the given state, or null if
                      none could be found.                    
                </return>
            </javadoc>
            <method name="getForegroundPainter" type="Painter" line="736">
                <params>
                    <param name="ctx" type="SynthContext"/>
                </params>
                <comment line="741">
                    check the cache                    
                </comment>
                <comment line="746">
                    not in cache, so lookup and store in cache                    
                </comment>
                <declaration name="v" type="Values" line="737"/>
                <declaration name="xstate" type="int" line="738"/>
                <declaration name="p" type="Painter" line="739"/>
                <declaration name="s" type="RuntimeState" line="747"/>
                <declaration name="lastIndex" type="int[]" line="748"/>
                <scope line="749">
                    <scope line="750"/>
                </scope>
                <scope line="756"/>
            </method>
            <javadoc line="762">
                Gets the appropriate border Painter, if there is one, for the state
                  specified in the given SynthContext. This method does appropriate
                  fallback searching, as described in #get.                
                <param>
                    ctx The SynthContext. Must not be null.                    
                </param>
                <return>
                    The border painter associated for the given state, or null if
                      none could be found.                    
                </return>
            </javadoc>
            <method name="getBorderPainter" type="Painter" line="771">
                <params>
                    <param name="ctx" type="SynthContext"/>
                </params>
                <comment line="776">
                    check the cache                    
                </comment>
                <comment line="781">
                    not in cache, so lookup and store in cache                    
                </comment>
                <declaration name="v" type="Values" line="772"/>
                <declaration name="xstate" type="int" line="773"/>
                <declaration name="p" type="Painter" line="774"/>
                <declaration name="s" type="RuntimeState" line="782"/>
                <declaration name="lastIndex" type="int[]" line="783"/>
                <scope line="784">
                    <scope line="785"/>
                </scope>
                <scope line="791"/>
            </method>
            <javadoc line="797">
                Utility method which returns the proper Values based on the given
                  SynthContext. Ensures that parsing of the values has occurred, or
                  reoccurs as necessary.                
                <param>
                    ctx The SynthContext                    
                </param>
                <return>
                    a non-null values reference                    
                </return>
            </javadoc>
            <method name="getValues" type="Values" line="805">
                <params>
                    <param name="ctx" type="SynthContext"/>
                </params>
            </method>
            <javadoc line="810">
                Simple utility method that searchs the given array of Strings for the
                  given string. This method is only called from getExtendedState if
                  the developer has specified a specific state for the component to be
                  in (ie, has &quot;wedged&quot; the component in that state) by specifying
                  they client property &quot;Nimbus.State&quot;.                
                <param>
                    names a non-null array of strings                    
                </param>
                <param>
                    name the name to look for in the array                    
                </param>
                <return>
                    true or false based on whether the given name is in the array                    
                </return>
            </javadoc>
            <method name="contains" type="boolean" line="821">
                <params>
                    <param name="names" type="String[]"/>
                    <param name="name" type="String"/>
                </params>
                <scope line="823">
                    <scope line="824"/>
                </scope>
            </method>
            <javadoc line="831">
                &lt;p&gt;Gets the extended state for a given synth context. Nimbus supports the
                  ability to define custom states. The algorithm used for choosing what
                  style information to use for a given state requires a single integer
                  bit string where each bit in the integer represents a different state
                  that the component is in. This method uses the componentState as
                  reported in the SynthContext, in addition to custom states, to determine
                  what this extended state is.&lt;/p&gt;
                  &lt;p&gt;In addition, this method checks the component in the given context
                  for a client property called &quot;Nimbus.State&quot;. If one exists, then it will
                  decompose the String associated with that property to determine what
                  state to return. In this way, the developer can force a component to be
                  in a specific state, regardless of what the &quot;real&quot; state of the component
                  is.&lt;/p&gt;
                  &lt;p&gt;The string associated with &quot;Nimbus.State&quot; would be of the form:
                  &lt;pre&gt;Enabled+CustomState+MouseOver&lt;/pre&gt;&lt;/p&gt;                
                <param>
                    ctx                    
                </param>
                <param>
                    v                    
                </param>
                <return>
                                        
                </return>
            </javadoc>
            <method name="getExtendedState" type="int" line="854">
                <params>
                    <param name="ctx" type="SynthContext"/>
                    <param name="v" type="Values"/>
                </params>
                <comment line="858">
                    check for the Nimbus.State client property                    
                </comment>
                <comment line="859">
                    Performance NOTE: getClientProperty ends up inside a synchronized                    
                </comment>
                <comment line="860">
                    block, so there is some potential for performance issues here, however                    
                </comment>
                <comment line="861">
                    I&apos;m not certain that there is one on a modern VM.                    
                </comment>
                <comment line="867">
                    standard states only                    
                </comment>
                <comment line="873">
                    custom states                    
                </comment>
                <comment line="882">
                    if there are no custom states defined, then simply return the                    
                </comment>
                <comment line="883">
                    state that Synth reported                    
                </comment>
                <comment line="886">
                    there are custom states on this values, so I&apos;ll have to iterate                    
                </comment>
                <comment line="887">
                    over them all and return a custom extended state                    
                </comment>
                <declaration name="c" type="JComponent" line="855"/>
                <declaration name="xstate" type="int" line="856"/>
                <declaration name="mask" type="int" line="857"/>
                <declaration name="property" type="Object" line="862"/>
                <scope line="863">
                    <declaration name="stateNames" type="String" line="864"/>
                    <declaration name="states" type="String[]" line="865"/>
                    <scope line="866">
                        <scope line="868">
                            <declaration name="s" type="State.StandardState" line="869"/>
                        </scope>
                    </scope>
                    <scope line="872">
                        <scope line="874">
                            <scope line="875"/>
                        </scope>
                    </scope>
                </scope>
                <scope line="881">
                    <declaration name="state" type="int" line="888"/>
                    <scope line="889">
                        <scope line="890"/>
                    </scope>
                </scope>
            </method>
            <javadoc line="899">
                &lt;p&gt;Gets the RuntimeState that most closely matches the state in the given
                  context, but is less specific than the given &quot;lastState&quot;. Essentially,
                  this allows you to search for the next best state.&lt;/p&gt;
                  &lt;p&gt;For example, if you had the following three states:
                  &lt;pre&gt;
                  Enabled
                  Enabled+Pressed
                  Disabled
                  &lt;/pre&gt;
                  And you wanted to find the state that best represented
                  ENABLED+PRESSED+FOCUSED and &lt;code&gt;lastState&lt;/code&gt; was null (or an
                  empty array, or an array with a single int with index == -1), then
                  Enabled+Pressed would be returned. If you then call this method again but
                  pass the index of Enabled+Pressed as the &quot;lastState&quot;, then
                  Enabled would be returned. If you call this method a third time and pass
                  the index of Enabled in as the &lt;code&gt;lastState&lt;/code&gt;, then null would be
                  returned.&lt;/p&gt;
                  &lt;p&gt;The actual code path for determining the proper state is the same as
                  in Synth.&lt;/p&gt;                
                <param>
                    ctx                    
                </param>
                <param>
                    lastState a 1 element array, allowing me to do pass-by-reference.                    
                </param>
                <return>
                                        
                </return>
            </javadoc>
            <method name="getNextState" type="RuntimeState" line="928">
                <params>
                    <param name="states" type="RuntimeState[]"/>
                    <param name="lastState" type="int[]"/>
                    <param name="xstate" type="int"/>
                </params>
                <comment line="929">
                    Use the StateInfo with the most bits that matches that of state.                    
                </comment>
                <comment line="930">
                    If there are none, then fallback to                    
                </comment>
                <comment line="931">
                    the StateInfo with a state of 0, indicating it&apos;ll match anything.                    
                </comment>
                <comment line="933">
                    Consider if we have 3 StateInfos a, b and c with states:                    
                </comment>
                <comment line="934">
                    SELECTED, SELECTED | ENABLED, 0                    
                </comment>
                <comment line="935">
                                        
                </comment>
                <comment line="936">
                    Input                          Return Value                    
                </comment>
                <comment line="937">
                    -----                          ------------                    
                </comment>
                <comment line="938">
                    SELECTED                       a                    
                </comment>
                <comment line="939">
                    SELECTED | ENABLED             b                    
                </comment>
                <comment line="940">
                    MOUSE_OVER                     c                    
                </comment>
                <comment line="941">
                    SELECTED | ENABLED | FOCUSED   b                    
                </comment>
                <comment line="942">
                    ENABLED                        c                    
                </comment>
                <comment line="949">
                    if xstate is 0, then search for the runtime state with component                    
                </comment>
                <comment line="950">
                    state of 0. That is, find the exact match and return it.                    
                </comment>
                <comment line="958">
                    an exact match couldn&apos;t be found, so there was no match.                    
                </comment>
                <comment line="963">
                    xstate is some value != 0                    
                </comment>
                <comment line="965">
                    determine from which index to start looking. If lastState[0] is -1                    
                </comment>
                <comment line="966">
                    then we know to start from the end of the state array. Otherwise,                    
                </comment>
                <comment line="967">
                    we start at the lastIndex - 1.                    
                </comment>
                <comment line="979">
                    This is key, we need to make sure all bits of the                    
                </comment>
                <comment line="980">
                    StateInfo match, otherwise a StateInfo with                    
                </comment>
                <comment line="981">
                    SELECTED | ENABLED would match ENABLED, which we                    
                </comment>
                <comment line="982">
                    don&apos;t want.                    
                </comment>
                <comment line="984">
                    This comes from BigInteger.bitCnt                    
                </comment>
                <scope line="944">
                    <declaration name="bestCount" type="int" line="945"/>
                    <declaration name="bestIndex" type="int" line="946"/>
                    <declaration name="wildIndex" type="int" line="947"/>
                    <scope line="951">
                        <scope line="952">
                            <scope line="953"/>
                        </scope>
                    </scope>
                    <declaration name="lastStateIndex" type="int" line="968"/>
                    <scope line="971">
                        <declaration name="oState" type="int" line="972"/>
                        <scope line="974">
                            <scope line="975"/>
                        </scope>
                        <scope line="978">
                            <declaration name="bitCount" type="int" line="985"/>
                            <scope line="993"/>
                        </scope>
                    </scope>
                    <scope line="999"/>
                    <scope line="1003"/>
                </scope>
            </method>
            <class name="RuntimeState" line="1012">
                <implements interface="Cloneable"/>
                <javadoc line="1012">
                    Contains values such as the UIDefaults and painters asssociated with
                      a state. Whereas &lt;code&gt;State&lt;/code&gt; represents a distinct state that a
                      component can be in (such as Enabled), this class represents the colors,
                      fonts, painters, etc associated with some state for this
                      style.                    
                </javadoc>
                <declaration name="state" type="int" line="1020"/>
                <declaration name="backgroundPainter" type="Painter" line="1021"/>
                <declaration name="foregroundPainter" type="Painter" line="1022"/>
                <declaration name="borderPainter" type="Painter" line="1023"/>
                <declaration name="stateName" type="String" line="1024"/>
                <declaration name="defaults" type="UIDefaults" line="1025"/>
                <method name="RuntimeState" type="constructor" line="1027">
                    <params>
                        <param name="state" type="int"/>
                        <param name="stateName" type="String"/>
                    </params>
                </method>
                <method name="toString" type="String" line="1033"/>
                <method name="clone" type="RuntimeState" line="1038">
                    <declaration name="clone" type="RuntimeState" line="1039"/>
                </method>
            </class>
            <class name="Values" line="1048">
                <javadoc line="1048">
                    Essentially a struct of data for a style. A default instance of this
                      class is used by NimbusStyle. Additional instances exist for each
                      component that has overrides.                    
                </javadoc>
                <declaration name="stateTypes" type="State[]" line="1054"/>
                <javadoc line="1054">
                    The list of State types. A State represents a type of state, such
                      as Enabled, Default, WindowFocused, etc. These can be custom states.                    
                </javadoc>
                <declaration name="states" type="RuntimeState[]" line="1059"/>
                <javadoc line="1059">
                    The list of actual runtime state representations. These can represent things such
                      as Enabled + Focused. Thus, they differ from States in that they contain
                      several states together, and have associated properties, data, etc.                    
                </javadoc>
                <declaration name="contentMargins" type="Insets" line="1065"/>
                <javadoc line="1065">
                    The content margins for this region.                    
                </javadoc>
                <declaration name="defaults" type="UIDefaults" line="1069"/>
                <javadoc line="1069">
                    Defaults on the region/component level.                    
                </javadoc>
                <declaration name="cache" type="Map&lt;CacheKey,Object&gt;" line="1073"/>
                <javadoc line="1073">
                    Simple cache. After a value has been looked up, it is stored
                      in this cache for later retrieval. The key is a concatenation of
                      the property being looked up, two dollar signs, and the extended
                      state. So for example:
                      foo.bar$$2353                    
                </javadoc>
            </class>
            <class name="CacheKey" line="1084">
                <javadoc line="1084">
                    This implementation presupposes that key is never null and that
                      the two keys being checked for equality are never null                    
                </javadoc>
                <declaration name="key" type="String" line="1089"/>
                <declaration name="xstate" type="int" line="1090"/>
                <method name="CacheKey" type="constructor" line="1092">
                    <params>
                        <param name="key" type="Object"/>
                        <param name="xstate" type="int"/>
                    </params>
                </method>
                <method name="init" type="void" line="1096">
                    <params>
                        <param name="key" type="Object"/>
                        <param name="xstate" type="int"/>
                    </params>
                </method>
                <method name="equals" type="boolean" line="1102">
                    <params>
                        <param name="obj" type="Object"/>
                    </params>
                    <declaration name="other" type="CacheKey" line="1103"/>
                </method>
                <method name="hashCode" type="int" line="1111">
                    <declaration name="hash" type="int" line="1112"/>
                </method>
            </class>
        </class>
    </source>