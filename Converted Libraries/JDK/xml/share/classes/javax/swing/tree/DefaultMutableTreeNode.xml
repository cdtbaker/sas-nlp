<?xml version="1.0" encoding="UTF-8"?>
    <source package="javax.swing.tree">
        <import package="java.io"/>
        <import package="java.util"/>
        <class name="DefaultMutableTreeNode" line="33">
            <comment line="150">
                Primitives                
            </comment>
            <comment line="350">
                Derived methods                
            </comment>
            <comment line="415">
                Tree Queries                
            </comment>
            <comment line="841">
                Child Queries                
            </comment>
            <comment line="963">
                Sibling Queries                
            </comment>
            <comment line="1072">
                Leaf Queries                
            </comment>
            <comment line="1229">
                Overrides                
            </comment>
            <comment line="1273">
                Serialization support.                
            </comment>
            <comment line="1329">
                End of class PreorderEnumeration                
            </comment>
            <comment line="1365">
                End of class PostorderEnumeration                
            </comment>
            <comment line="1453">
                End of class BreadthFirstEnumeration                
            </comment>
            <comment line="1497">
                End of class PathBetweenNodesEnumeration                
            </comment>
            <implements interface="Cloneable"/>
            <implements interface="MutableTreeNode"/>
            <implements interface="Serializable"/>
            <javadoc line="33">
                A &lt;code&gt;DefaultMutableTreeNode&lt;/code&gt; is a general-purpose node in a tree data
                  structure.
                  For examples of using default mutable tree nodes, see
                  &lt;a
                  href=&quot;http://java.sun.com/docs/books/tutorial/uiswing/components/tree.html&quot;&gt;How to Use Trees&lt;/a&gt;
                  in &lt;em&gt;The Java Tutorial.&lt;/em&gt;
                  &lt;p&gt;
                  A tree node may have at most one parent and 0 or more children.
                  &lt;code&gt;DefaultMutableTreeNode&lt;/code&gt; provides operations for examining and modifying a
                  node&apos;s parent and children and also operations for examining the tree that
                  the node is a part of.  A node&apos;s tree is the set of all nodes that can be
                  reached by starting at the node and following all the possible links to
                  parents and children.  A node with no parent is the root of its tree; a
                  node with no children is a leaf.  A tree may consist of many subtrees,
                  each node acting as the root for its own subtree.
                  &lt;p&gt;
                  This class provides enumerations for efficiently traversing a tree or
                  subtree in various orders or for following the path between two nodes.
                  A &lt;code&gt;DefaultMutableTreeNode&lt;/code&gt; may also hold a reference to a user object, the
                  use of which is left to the user.  Asking a &lt;code&gt;DefaultMutableTreeNode&lt;/code&gt; for its
                  string representation with &lt;code&gt;toString()&lt;/code&gt; returns the string
                  representation of its user object.
                  &lt;p&gt;
                  &lt;b&gt;This is not a thread safe class.&lt;/b&gt;If you intend to use
                  a DefaultMutableTreeNode (or a tree of TreeNodes) in more than one thread, you
                  need to do your own synchronizing. A good convention to adopt is
                  synchronizing on the root node of a tree.
                  &lt;p&gt;
                  While DefaultMutableTreeNode implements the MutableTreeNode interface and
                  will allow you to add in any implementation of MutableTreeNode not all
                  of the methods in DefaultMutableTreeNode will be applicable to all
                  MutableTreeNodes implementations. Especially with some of the enumerations
                  that are provided, using some of these methods assumes the
                  DefaultMutableTreeNode contains only DefaultMutableNode instances. All
                  of the TreeNode/MutableTreeNode methods will behave as defined no
                  matter what implementations are added.
                  &lt;p&gt;
                  &lt;strong&gt;Warning:&lt;/strong&gt;
                  Serialized objects of this class will not be compatible with
                  future Swing releases. The current serialization support is
                  appropriate for short term storage or RMI between applications running
                  the same version of Swing.  As of 1.4, support for long term storage
                  of all JavaBeans&lt;sup&gt;&lt;font size=&quot;-2&quot;&gt;TM&lt;/font&gt;&lt;/sup&gt;
                  has been added to the &lt;code&gt;java.beans&lt;/code&gt; package.
                  Please see {@link java.beans.XMLEncoder}.                
                <see>
                    MutableTreeNode                    
                </see>
                <author>
                    Rob Davis                    
                </author>
            </javadoc>
            <declaration name="serialVersionUID" type="long" line="90"/>
            <declaration name="EMPTY_ENUMERATION" type="Enumeration&lt;TreeNode&gt;" line="92"/>
            <javadoc line="92">
                An enumeration that is always empty. This is used when an enumeration
                  of a leaf node&apos;s children is requested.                
            </javadoc>
            <declaration name="parent" type="MutableTreeNode" line="99"/>
            <javadoc line="99">
                this node&apos;s parent, or null if this node has no parent                
            </javadoc>
            <declaration name="children" type="Vector" line="102"/>
            <javadoc line="102">
                array of children, may be null if this node has no children                
            </javadoc>
            <declaration name="userObject" type="Object" line="105"/>
            <javadoc line="105">
                optional user object                
            </javadoc>
            <declaration name="allowsChildren" type="boolean" line="108"/>
            <javadoc line="108">
                true if the node is able to have children                
            </javadoc>
            <javadoc line="112">
                Creates a tree node that has no parent and no children, but which
                  allows children.                
            </javadoc>
            <method name="DefaultMutableTreeNode" type="constructor" line="116"/>
            <javadoc line="120">
                Creates a tree node with no parent, no children, but which allows
                  children, and initializes it with the specified user object.                
                <param>
                    userObject an Object provided by the user that constitutes
                      the node&apos;s data                    
                </param>
            </javadoc>
            <method name="DefaultMutableTreeNode" type="constructor" line="127">
                <params>
                    <param name="userObject" type="Object"/>
                </params>
            </method>
            <javadoc line="131">
                Creates a tree node with no parent, no children, initialized with
                  the specified user object, and that allows children only if
                  specified.                
                <param>
                    userObject an Object provided by the user that constitutes
                      the node&apos;s data                    
                </param>
                <param>
                    allowsChildren if true, the node is allowed to have child
                      nodes -- otherwise, it is always a leaf node                    
                </param>
            </javadoc>
            <method name="DefaultMutableTreeNode" type="constructor" line="141">
                <params>
                    <param name="userObject" type="Object"/>
                    <param name="allowsChildren" type="boolean"/>
                </params>
            </method>
            <javadoc line="153">
                Removes &lt;code&gt;newChild&lt;/code&gt; from its present parent (if it has a
                  parent), sets the child&apos;s parent to this node, and then adds the child
                  to this node&apos;s child array at index &lt;code&gt;childIndex&lt;/code&gt;.
                  &lt;code&gt;newChild&lt;/code&gt; must not be null and must not be an ancestor of
                  this node.                
                <param>
                    newChild        the MutableTreeNode to insert under this node                    
                </param>
                <param>
                    childIndex      the index in this node&apos;s child array
                      where this node is to be inserted                    
                </param>
                <exception>
                    ArrayIndexOutOfBoundsException  if
                      &lt;code&gt;childIndex&lt;/code&gt; is out of bounds                    
                </exception>
                <exception>
                    IllegalArgumentException        if
                      &lt;code&gt;newChild&lt;/code&gt; is null or is an
                      ancestor of this node                    
                </exception>
                <exception>
                    IllegalStateException   if this node does not allow
                      children                    
                </exception>
                <see>
                    #isNodeDescendant                    
                </see>
            </javadoc>
            <method name="insert" type="void" line="172">
                <params>
                    <param name="newChild" type="MutableTreeNode"/>
                    <param name="childIndex" type="int"/>
                </params>
                <scope line="173"/>
                <scope line="175"/>
                <scope line="177"/>
                <declaration name="oldParent" type="MutableTreeNode" line="181"/>
                <scope line="183"/>
                <scope line="187"/>
            </method>
            <javadoc line="193">
                Removes the child at the specified index from this node&apos;s children
                  and sets that node&apos;s parent to null. The child node to remove
                  must be a &lt;code&gt;MutableTreeNode&lt;/code&gt;.                
                <param>
                    childIndex      the index in this node&apos;s child array
                      of the child to remove                    
                </param>
                <exception>
                    ArrayIndexOutOfBoundsException  if
                      &lt;code&gt;childIndex&lt;/code&gt; is out of bounds                    
                </exception>
            </javadoc>
            <method name="remove" type="void" line="203">
                <params>
                    <param name="childIndex" type="int"/>
                </params>
                <declaration name="child" type="MutableTreeNode" line="204"/>
            </method>
            <javadoc line="209">
                Sets this node&apos;s parent to &lt;code&gt;newParent&lt;/code&gt; but does not
                  change the parent&apos;s child array.  This method is called from
                  &lt;code&gt;insert()&lt;/code&gt; and &lt;code&gt;remove()&lt;/code&gt; to
                  reassign a child&apos;s parent, it should not be messaged from anywhere
                  else.                
                <param>
                    newParent       this node&apos;s new parent                    
                </param>
            </javadoc>
            <method name="setParent" type="void" line="218">
                <params>
                    <param name="newParent" type="MutableTreeNode"/>
                </params>
            </method>
            <javadoc line="222">
                Returns this node&apos;s parent or null if this node has no parent.                
                <return>
                    this node&apos;s parent TreeNode, or null if this node has no parent                    
                </return>
            </javadoc>
            <method name="getParent" type="TreeNode" line="227"/>
            <javadoc line="231">
                Returns the child at the specified index in this node&apos;s child array.                
                <param>
                    index   an index into this node&apos;s child array                    
                </param>
                <exception>
                    ArrayIndexOutOfBoundsException  if &lt;code&gt;index&lt;/code&gt;
                      is out of bounds                    
                </exception>
                <return>
                    the TreeNode in this node&apos;s child array at  the specified index                    
                </return>
            </javadoc>
            <method name="getChildAt" type="TreeNode" line="239">
                <params>
                    <param name="index" type="int"/>
                </params>
                <scope line="240"/>
            </method>
            <javadoc line="246">
                Returns the number of children of this node.                
                <return>
                    an int giving the number of children of this node                    
                </return>
            </javadoc>
            <method name="getChildCount" type="int" line="251">
                <scope line="252"/>
                <scope line="254"/>
            </method>
            <javadoc line="259">
                Returns the index of the specified child in this node&apos;s child array.
                  If the specified node is not a child of this node, returns
                  &lt;code&gt;-1&lt;/code&gt;.  This method performs a linear search and is O(n)
                  where n is the number of children.                
                <param>
                    aChild  the TreeNode to search for among this node&apos;s children                    
                </param>
                <exception>
                    IllegalArgumentException        if &lt;code&gt;aChild&lt;/code&gt;
                      is null                    
                </exception>
                <return>
                    an int giving the index of the node in this node&apos;s child
                      array, or &lt;code&gt;-1&lt;/code&gt; if the specified node is a not
                      a child of this node                    
                </return>
            </javadoc>
            <method name="getIndex" type="int" line="272">
                <params>
                    <param name="aChild" type="TreeNode"/>
                </params>
                <comment line="281">
                    linear search                    
                </comment>
                <scope line="273"/>
                <scope line="277"/>
            </method>
            <javadoc line="283">
                Creates and returns a forward-order enumeration of this node&apos;s
                  children.  Modifying this node&apos;s child array invalidates any child
                  enumerations created before the modification.                
                <return>
                    an Enumeration of this node&apos;s children                    
                </return>
            </javadoc>
            <method name="children" type="Enumeration" line="290">
                <scope line="291"/>
                <scope line="293"/>
            </method>
            <javadoc line="298">
                Determines whether or not this node is allowed to have children.
                  If &lt;code&gt;allows&lt;/code&gt; is false, all of this node&apos;s children are
                  removed.
                  &lt;p&gt;
                  Note: By default, a node allows children.                
                <param>
                    allows  true if this node is allowed to have children                    
                </param>
            </javadoc>
            <method name="setAllowsChildren" type="void" line="307">
                <params>
                    <param name="allows" type="boolean"/>
                </params>
                <scope line="308">
                    <scope line="310"/>
                </scope>
            </method>
            <javadoc line="316">
                Returns true if this node is allowed to have children.                
                <return>
                    true if this node allows children, else false                    
                </return>
            </javadoc>
            <method name="getAllowsChildren" type="boolean" line="321"/>
            <javadoc line="325">
                Sets the user object for this node to &lt;code&gt;userObject&lt;/code&gt;.                
                <param>
                    userObject      the Object that constitutes this node&apos;s
                      user-specified data                    
                </param>
                <see>
                    #getUserObject                    
                </see>
                <see>
                    #toString                    
                </see>
            </javadoc>
            <method name="setUserObject" type="void" line="333">
                <params>
                    <param name="userObject" type="Object"/>
                </params>
            </method>
            <javadoc line="337">
                Returns this node&apos;s user object.                
                <return>
                    the Object stored at this node by the user                    
                </return>
                <see>
                    #setUserObject                    
                </see>
                <see>
                    #toString                    
                </see>
            </javadoc>
            <method name="getUserObject" type="Object" line="344"/>
            <javadoc line="353">
                Removes the subtree rooted at this node from the tree, giving this
                  node a null parent.  Does nothing if this node is the root of its
                  tree.                
            </javadoc>
            <method name="removeFromParent" type="void" line="358">
                <declaration name="parent" type="MutableTreeNode" line="359"/>
                <scope line="360"/>
            </method>
            <javadoc line="365">
                Removes &lt;code&gt;aChild&lt;/code&gt; from this node&apos;s child array, giving it a
                  null parent.                
                <param>
                    aChild  a child of this node to remove                    
                </param>
                <exception>
                    IllegalArgumentException        if &lt;code&gt;aChild&lt;/code&gt;
                      is null or is not a child of this node                    
                </exception>
            </javadoc>
            <method name="remove" type="void" line="373">
                <params>
                    <param name="aChild" type="MutableTreeNode"/>
                </params>
                <comment line="382">
                    linear search                    
                </comment>
                <scope line="374"/>
                <scope line="378"/>
            </method>
            <javadoc line="384">
                Removes all of this node&apos;s children, setting their parents to null.
                  If this node has no children, this method does nothing.                
            </javadoc>
            <method name="removeAllChildren" type="void" line="388">
                <scope line="389"/>
            </method>
            <javadoc line="394">
                Removes &lt;code&gt;newChild&lt;/code&gt; from its parent and makes it a child of
                  this node by adding it to the end of this node&apos;s child array.                
                <see>
                    #insert                    
                </see>
                <param>
                    newChild        node to add as a child of this node                    
                </param>
                <exception>
                    IllegalArgumentException    if &lt;code&gt;newChild&lt;/code&gt;
                      is null                    
                </exception>
                <exception>
                    IllegalStateException   if this node does not allow
                      children                    
                </exception>
            </javadoc>
            <method name="add" type="void" line="405">
                <params>
                    <param name="newChild" type="MutableTreeNode"/>
                </params>
            </method>
            <javadoc line="418">
                Returns true if &lt;code&gt;anotherNode&lt;/code&gt; is an ancestor of this node
                  -- if it is this node, this node&apos;s parent, or an ancestor of this
                  node&apos;s parent.  (Note that a node is considered an ancestor of itself.)
                  If &lt;code&gt;anotherNode&lt;/code&gt; is null, this method returns false.  This
                  operation is at worst O(h) where h is the distance from the root to
                  this node.                
                <see>
                    #isNodeDescendant                    
                </see>
                <see>
                    #getSharedAncestor                    
                </see>
                <param>
                    anotherNode     node to test as an ancestor of this node                    
                </param>
                <return>
                    true if this node is a descendant of &lt;code&gt;anotherNode&lt;/code&gt;                    
                </return>
            </javadoc>
            <method name="isNodeAncestor" type="boolean" line="431">
                <params>
                    <param name="anotherNode" type="TreeNode"/>
                </params>
                <scope line="432"/>
                <declaration name="ancestor" type="TreeNode" line="436"/>
                <scope line="438">
                    <scope line="439"/>
                </scope>
            </method>
            <javadoc line="447">
                Returns true if &lt;code&gt;anotherNode&lt;/code&gt; is a descendant of this node
                  -- if it is this node, one of this node&apos;s children, or a descendant of
                  one of this node&apos;s children.  Note that a node is considered a
                  descendant of itself.  If &lt;code&gt;anotherNode&lt;/code&gt; is null, returns
                  false.  This operation is at worst O(h) where h is the distance from the
                  root to &lt;code&gt;anotherNode&lt;/code&gt;.                
                <see>
                    #isNodeAncestor                    
                </see>
                <see>
                    #getSharedAncestor                    
                </see>
                <param>
                    anotherNode     node to test as descendant of this node                    
                </param>
                <return>
                    true if this node is an ancestor of &lt;code&gt;anotherNode&lt;/code&gt;                    
                </return>
            </javadoc>
            <method name="isNodeDescendant" type="boolean" line="460">
                <params>
                    <param name="anotherNode" type="DefaultMutableTreeNode"/>
                </params>
            </method>
            <javadoc line="467">
                Returns the nearest common ancestor to this node and &lt;code&gt;aNode&lt;/code&gt;.
                  Returns null, if no such ancestor exists -- if this node and
                  &lt;code&gt;aNode&lt;/code&gt; are in different trees or if &lt;code&gt;aNode&lt;/code&gt; is
                  null.  A node is considered an ancestor of itself.                
                <see>
                    #isNodeAncestor                    
                </see>
                <see>
                    #isNodeDescendant                    
                </see>
                <param>
                    aNode   node to find common ancestor with                    
                </param>
                <return>
                    nearest ancestor common to this node and &lt;code&gt;aNode&lt;/code&gt;,
                      or null if none                    
                </return>
            </javadoc>
            <method name="getSharedAncestor" type="TreeNode" line="479">
                <params>
                    <param name="aNode" type="DefaultMutableTreeNode"/>
                </params>
                <comment line="503">
                    Go up the tree until the nodes are at the same level                    
                </comment>
                <comment line="509">
                    Move up the tree until we find a common ancestor.  Since we know
                     that both nodes are at the same level, we won&apos;t cross paths
                     unknowingly (if there is a common ancestor, both nodes hit it in
                     the same iteration).                    
                </comment>
                <comment line="520">
                    only need to check one -- they&apos;re at the                    
                </comment>
                <comment line="521">
                    same level so if one is null, the other is                    
                </comment>
                <scope line="480"/>
                <scope line="482"/>
                <declaration name="level1" type="int" line="486"/>
                <declaration name="node1" type="TreeNode" line="487"/>
                <scope line="492"/>
                <scope line="496"/>
                <scope line="503"/>
                <scope line="513">
                    <scope line="514"/>
                </scope>
                <scope line="522"/>
            </method>
            <javadoc line="530">
                Returns true if and only if &lt;code&gt;aNode&lt;/code&gt; is in the same tree
                  as this node.  Returns false if &lt;code&gt;aNode&lt;/code&gt; is null.                
                <see>
                    #getSharedAncestor                    
                </see>
                <see>
                    #getRoot                    
                </see>
                <return>
                    true if &lt;code&gt;aNode&lt;/code&gt; is in the same tree as this node;
                      false if &lt;code&gt;aNode&lt;/code&gt; is null                    
                </return>
            </javadoc>
            <method name="isNodeRelated" type="boolean" line="539">
                <params>
                    <param name="aNode" type="DefaultMutableTreeNode"/>
                </params>
            </method>
            <javadoc line="544">
                Returns the depth of the tree rooted at this node -- the longest
                  distance from this node to a leaf.  If this node has no children,
                  returns 0.  This operation is much more expensive than
                  &lt;code&gt;getLevel()&lt;/code&gt; because it must effectively traverse the entire
                  tree rooted at this node.                
                <see>
                    #getLevel                    
                </see>
                <return>
                    the depth of the tree whose root is this node                    
                </return>
            </javadoc>
            <method name="getDepth" type="int" line="554">
                <declaration name="last" type="Object" line="555"/>
                <declaration name="enum_" type="Enumeration" line="556"/>
                <scope line="558"/>
                <scope line="562"/>
            </method>
            <javadoc line="571">
                Returns the number of levels above this node -- the distance from
                  the root to this node.  If this node is the root, returns 0.                
                <see>
                    #getDepth                    
                </see>
                <return>
                    the number of levels above this node                    
                </return>
            </javadoc>
            <method name="getLevel" type="int" line="578">
                <declaration name="ancestor" type="TreeNode" line="579"/>
                <declaration name="levels" type="int" line="580"/>
                <scope line="583"/>
            </method>
            <javadoc line="591">
                Returns the path from the root, to get to this node.  The last
                  element in the path is this node.                
                <return>
                    an array of TreeNode objects giving the path, where the
                      first element in the path is the root and the last
                      element is this node.                    
                </return>
            </javadoc>
            <method name="getPath" type="TreeNode[]" line="599"/>
            <javadoc line="603">
                Builds the parents of node up to and including the root node,
                  where the original node is the last element in the returned array.
                  The length of the returned array gives the node&apos;s depth in the
                  tree.                
                <param>
                    aNode  the TreeNode to get the path for                    
                </param>
                <param>
                    depth  an int giving the number of steps already taken towards
                      the root (on recursive calls), used to size the returned array                    
                </param>
                <return>
                    an array of TreeNodes giving the path from the root to the
                      specified node                    
                </return>
            </javadoc>
            <method name="getPathToRoot" type="TreeNode[]" line="615">
                <params>
                    <param name="aNode" type="TreeNode"/>
                    <param name="depth" type="int"/>
                </params>
                <comment line="619">
                    Check for null, in case someone passed in a null node, or                    
                </comment>
                <declaration name="retNodes" type="TreeNode[]" line="616"/>
                <scope line="620"/>
                <scope line="626"/>
            </method>
            <javadoc line="634">
                Returns the user object path, from the root, to get to this node.
                  If some of the TreeNodes in the path have null user objects, the
                  returned path will contain nulls.                
            </javadoc>
            <method name="getUserObjectPath" type="Object[]" line="639">
                <declaration name="realPath" type="TreeNode[]" line="640"/>
                <declaration name="retPath" type="Object[]" line="641"/>
            </method>
            <javadoc line="649">
                Returns the root of the tree that contains this node.  The root is
                  the ancestor with a null parent.                
                <see>
                    #isNodeAncestor                    
                </see>
                <return>
                    the root of the tree that contains this node                    
                </return>
            </javadoc>
            <method name="getRoot" type="TreeNode" line="656">
                <declaration name="ancestor" type="TreeNode" line="657"/>
                <declaration name="previous" type="TreeNode" line="658"/>
                <scope line="660"/>
            </method>
            <javadoc line="669">
                Returns true if this node is the root of the tree.  The root is
                  the only node in the tree with a null parent; every tree has exactly
                  one root.                
                <return>
                    true if this node is the root of its tree                    
                </return>
            </javadoc>
            <method name="isRoot" type="boolean" line="676"/>
            <javadoc line="681">
                Returns the node that follows this node in a preorder traversal of this
                  node&apos;s tree.  Returns null if this node is the last node of the
                  traversal.  This is an inefficient way to traverse the entire tree; use
                  an enumeration, instead.                
                <see>
                    #preorderEnumeration                    
                </see>
                <return>
                    the node that follows this node in a preorder traversal, or
                      null if this node is last                    
                </return>
            </javadoc>
            <method name="getNextNode" type="DefaultMutableTreeNode" line="691">
                <comment line="694">
                    No children, so look for nextSibling                    
                </comment>
                <scope line="692">
                    <declaration name="nextSibling" type="DefaultMutableTreeNode" line="694"/>
                    <scope line="696">
                        <declaration name="aNode" type="DefaultMutableTreeNode" line="697"/>
                        <scope line="699">
                            <scope line="700"/>
                            <scope line="705"/>
                        </scope>
                    </scope>
                    <scope line="711"/>
                </scope>
                <scope line="714"/>
            </method>
            <javadoc line="720">
                Returns the node that precedes this node in a preorder traversal of
                  this node&apos;s tree.  Returns &lt;code&gt;null&lt;/code&gt; if this node is the
                  first node of the traversal -- the root of the tree.
                  This is an inefficient way to
                  traverse the entire tree; use an enumeration, instead.                
                <see>
                    #preorderEnumeration                    
                </see>
                <return>
                    the node that precedes this node in a preorder traversal, or
                      null if this node is the first                    
                </return>
            </javadoc>
            <method name="getPreviousNode" type="DefaultMutableTreeNode" line="731">
                <declaration name="previousSibling" type="DefaultMutableTreeNode" line="732"/>
                <declaration name="myParent" type="DefaultMutableTreeNode" line="733"/>
                <scope line="735"/>
                <scope line="741"/>
                <scope line="746"/>
            </method>
            <javadoc line="751">
                Creates and returns an enumeration that traverses the subtree rooted at
                  this node in preorder.  The first node returned by the enumeration&apos;s
                  &lt;code&gt;nextElement()&lt;/code&gt; method is this node.&lt;P&gt;
                  Modifying the tree by inserting, removing, or moving a node invalidates
                  any enumerations created before the modification.                
                <see>
                    #postorderEnumeration                    
                </see>
                <return>
                    an enumeration for traversing the tree in preorder                    
                </return>
            </javadoc>
            <method name="preorderEnumeration" type="Enumeration" line="762"/>
            <javadoc line="766">
                Creates and returns an enumeration that traverses the subtree rooted at
                  this node in postorder.  The first node returned by the enumeration&apos;s
                  &lt;code&gt;nextElement()&lt;/code&gt; method is the leftmost leaf.  This is the
                  same as a depth-first traversal.&lt;P&gt;
                  Modifying the tree by inserting, removing, or moving a node invalidates
                  any enumerations created before the modification.                
                <see>
                    #depthFirstEnumeration                    
                </see>
                <see>
                    #preorderEnumeration                    
                </see>
                <return>
                    an enumeration for traversing the tree in postorder                    
                </return>
            </javadoc>
            <method name="postorderEnumeration" type="Enumeration" line="779"/>
            <javadoc line="783">
                Creates and returns an enumeration that traverses the subtree rooted at
                  this node in breadth-first order.  The first node returned by the
                  enumeration&apos;s &lt;code&gt;nextElement()&lt;/code&gt; method is this node.&lt;P&gt;
                  Modifying the tree by inserting, removing, or moving a node invalidates
                  any enumerations created before the modification.                
                <see>
                    #depthFirstEnumeration                    
                </see>
                <return>
                    an enumeration for traversing the tree in breadth-first order                    
                </return>
            </javadoc>
            <method name="breadthFirstEnumeration" type="Enumeration" line="794"/>
            <javadoc line="798">
                Creates and returns an enumeration that traverses the subtree rooted at
                  this node in depth-first order.  The first node returned by the
                  enumeration&apos;s &lt;code&gt;nextElement()&lt;/code&gt; method is the leftmost leaf.
                  This is the same as a postorder traversal.&lt;P&gt;
                  Modifying the tree by inserting, removing, or moving a node invalidates
                  any enumerations created before the modification.                
                <see>
                    #breadthFirstEnumeration                    
                </see>
                <see>
                    #postorderEnumeration                    
                </see>
                <return>
                    an enumeration for traversing the tree in depth-first order                    
                </return>
            </javadoc>
            <method name="depthFirstEnumeration" type="Enumeration" line="811"/>
            <javadoc line="815">
                Creates and returns an enumeration that follows the path from
                  &lt;code&gt;ancestor&lt;/code&gt; to this node.  The enumeration&apos;s
                  &lt;code&gt;nextElement()&lt;/code&gt; method first returns &lt;code&gt;ancestor&lt;/code&gt;,
                  then the child of &lt;code&gt;ancestor&lt;/code&gt; that is an ancestor of this
                  node, and so on, and finally returns this node.  Creation of the
                  enumeration is O(m) where m is the number of nodes between this node
                  and &lt;code&gt;ancestor&lt;/code&gt;, inclusive.  Each &lt;code&gt;nextElement()&lt;/code&gt;
                  message is O(1).&lt;P&gt;
                  Modifying the tree by inserting, removing, or moving a node invalidates
                  any enumerations created before the modification.                
                <see>
                    #isNodeAncestor                    
                </see>
                <see>
                    #isNodeDescendant                    
                </see>
                <exception>
                    IllegalArgumentException if &lt;code&gt;ancestor&lt;/code&gt; is
                      not an ancestor of this node                    
                </exception>
                <return>
                    an enumeration for following the path from an ancestor of
                      this node to this one                    
                </return>
            </javadoc>
            <method name="pathFromAncestorEnumeration" type="Enumeration" line="835">
                <params>
                    <param name="ancestor" type="TreeNode"/>
                </params>
            </method>
            <javadoc line="844">
                Returns true if &lt;code&gt;aNode&lt;/code&gt; is a child of this node.  If
                  &lt;code&gt;aNode&lt;/code&gt; is null, this method returns false.                
                <return>
                    true if &lt;code&gt;aNode&lt;/code&gt; is a child of this node; false if
                      &lt;code&gt;aNode&lt;/code&gt; is null                    
                </return>
            </javadoc>
            <method name="isNodeChild" type="boolean" line="851">
                <params>
                    <param name="aNode" type="TreeNode"/>
                </params>
                <declaration name="retval" type="boolean" line="852"/>
                <scope line="854"/>
                <scope line="856">
                    <scope line="857"/>
                    <scope line="859"/>
                </scope>
            </method>
            <javadoc line="868">
                Returns this node&apos;s first child.  If this node has no children,
                  throws NoSuchElementException.                
                <return>
                    the first child of this node                    
                </return>
                <exception>
                    NoSuchElementException  if this node has no children                    
                </exception>
            </javadoc>
            <method name="getFirstChild" type="TreeNode" line="875">
                <scope line="876"/>
            </method>
            <javadoc line="883">
                Returns this node&apos;s last child.  If this node has no children,
                  throws NoSuchElementException.                
                <return>
                    the last child of this node                    
                </return>
                <exception>
                    NoSuchElementException  if this node has no children                    
                </exception>
            </javadoc>
            <method name="getLastChild" type="TreeNode" line="890">
                <scope line="891"/>
            </method>
            <javadoc line="898">
                Returns the child in this node&apos;s child array that immediately
                  follows &lt;code&gt;aChild&lt;/code&gt;, which must be a child of this node.  If
                  &lt;code&gt;aChild&lt;/code&gt; is the last child, returns null.  This method
                  performs a linear search of this node&apos;s children for
                  &lt;code&gt;aChild&lt;/code&gt; and is O(n) where n is the number of children; to
                  traverse the entire array of children, use an enumeration instead.                
                <see>
                    #children                    
                </see>
                <exception>
                    IllegalArgumentException if &lt;code&gt;aChild&lt;/code&gt; is
                      null or is not a child of this node                    
                </exception>
                <return>
                    the child of this node that immediately follows
                      &lt;code&gt;aChild&lt;/code&gt;                    
                </return>
            </javadoc>
            <method name="getChildAfter" type="TreeNode" line="912">
                <params>
                    <param name="aChild" type="TreeNode"/>
                </params>
                <comment line="918">
                    linear search                    
                </comment>
                <scope line="913"/>
                <declaration name="index" type="int" line="917"/>
                <scope line="919"/>
                <scope line="923"/>
                <scope line="925"/>
            </method>
            <javadoc line="931">
                Returns the child in this node&apos;s child array that immediately
                  precedes &lt;code&gt;aChild&lt;/code&gt;, which must be a child of this node.  If
                  &lt;code&gt;aChild&lt;/code&gt; is the first child, returns null.  This method
                  performs a linear search of this node&apos;s children for &lt;code&gt;aChild&lt;/code&gt;
                  and is O(n) where n is the number of children.                
                <exception>
                    IllegalArgumentException if &lt;code&gt;aChild&lt;/code&gt; is null
                      or is not a child of this node                    
                </exception>
                <return>
                    the child of this node that immediately precedes
                      &lt;code&gt;aChild&lt;/code&gt;                    
                </return>
            </javadoc>
            <method name="getChildBefore" type="TreeNode" line="943">
                <params>
                    <param name="aChild" type="TreeNode"/>
                </params>
                <comment line="949">
                    linear search                    
                </comment>
                <scope line="944"/>
                <declaration name="index" type="int" line="948"/>
                <scope line="950"/>
                <scope line="954"/>
                <scope line="956"/>
            </method>
            <javadoc line="967">
                Returns true if &lt;code&gt;anotherNode&lt;/code&gt; is a sibling of (has the
                  same parent as) this node.  A node is its own sibling.  If
                  &lt;code&gt;anotherNode&lt;/code&gt; is null, returns false.                
                <param>
                    anotherNode     node to test as sibling of this node                    
                </param>
                <return>
                    true if &lt;code&gt;anotherNode&lt;/code&gt; is a sibling of this node                    
                </return>
            </javadoc>
            <method name="isNodeSibling" type="boolean" line="975">
                <params>
                    <param name="anotherNode" type="TreeNode"/>
                </params>
                <declaration name="retval" type="boolean" line="976"/>
                <scope line="978"/>
                <scope line="980"/>
                <scope line="982">
                    <declaration name="myParent" type="TreeNode" line="983"/>
                    <scope line="987"/>
                </scope>
            </method>
            <javadoc line="996">
                Returns the number of siblings of this node.  A node is its own sibling
                  (if it has no parent or no siblings, this method returns
                  &lt;code&gt;1&lt;/code&gt;).                
                <return>
                    the number of siblings of this node                    
                </return>
            </javadoc>
            <method name="getSiblingCount" type="int" line="1003">
                <declaration name="myParent" type="TreeNode" line="1004"/>
                <scope line="1006"/>
                <scope line="1008"/>
            </method>
            <javadoc line="1014">
                Returns the next sibling of this node in the parent&apos;s children array.
                  Returns null if this node has no parent or is the parent&apos;s last child.
                  This method performs a linear search that is O(n) where n is the number
                  of children; to traverse the entire array, use the parent&apos;s child
                  enumeration instead.                
                <see>
                    #children                    
                </see>
                <return>
                    the sibling of this node that immediately follows this node                    
                </return>
            </javadoc>
            <method name="getNextSibling" type="DefaultMutableTreeNode" line="1024">
                <comment line="1033">
                    linear search                    
                </comment>
                <declaration name="retval" type="DefaultMutableTreeNode" line="1025"/>
                <declaration name="myParent" type="DefaultMutableTreeNode" line="1027"/>
                <scope line="1029"/>
                <scope line="1031"/>
                <scope line="1035"/>
            </method>
            <javadoc line="1043">
                Returns the previous sibling of this node in the parent&apos;s children
                  array.  Returns null if this node has no parent or is the parent&apos;s
                  first child.  This method performs a linear search that is O(n) where n
                  is the number of children.                
                <return>
                    the sibling of this node that immediately precedes this node                    
                </return>
            </javadoc>
            <method name="getPreviousSibling" type="DefaultMutableTreeNode" line="1051">
                <comment line="1060">
                    linear search                    
                </comment>
                <declaration name="retval" type="DefaultMutableTreeNode" line="1052"/>
                <declaration name="myParent" type="DefaultMutableTreeNode" line="1054"/>
                <scope line="1056"/>
                <scope line="1058"/>
                <scope line="1062"/>
            </method>
            <javadoc line="1075">
                Returns true if this node has no children.  To distinguish between
                  nodes that have no children and nodes that &lt;i&gt;cannot&lt;/i&gt; have
                  children (e.g. to distinguish files from empty directories), use this
                  method in conjunction with &lt;code&gt;getAllowsChildren&lt;/code&gt;                
                <see>
                    #getAllowsChildren                    
                </see>
                <return>
                    true if this node has no children                    
                </return>
            </javadoc>
            <method name="isLeaf" type="boolean" line="1084"/>
            <javadoc line="1089">
                Finds and returns the first leaf that is a descendant of this node --
                  either this node or its first child&apos;s first leaf.
                  Returns this node if it is a leaf.                
                <see>
                    #isLeaf                    
                </see>
                <see>
                    #isNodeDescendant                    
                </see>
                <return>
                    the first leaf in the subtree rooted at this node                    
                </return>
            </javadoc>
            <method name="getFirstLeaf" type="DefaultMutableTreeNode" line="1098">
                <declaration name="node" type="DefaultMutableTreeNode" line="1099"/>
                <scope line="1101"/>
            </method>
            <javadoc line="1109">
                Finds and returns the last leaf that is a descendant of this node --
                  either this node or its last child&apos;s last leaf.
                  Returns this node if it is a leaf.                
                <see>
                    #isLeaf                    
                </see>
                <see>
                    #isNodeDescendant                    
                </see>
                <return>
                    the last leaf in the subtree rooted at this node                    
                </return>
            </javadoc>
            <method name="getLastLeaf" type="DefaultMutableTreeNode" line="1118">
                <declaration name="node" type="DefaultMutableTreeNode" line="1119"/>
                <scope line="1121"/>
            </method>
            <javadoc line="1129">
                Returns the leaf after this node or null if this node is the
                  last leaf in the tree.
                  &lt;p&gt;
                  In this implementation of the &lt;code&gt;MutableNode&lt;/code&gt; interface,
                  this operation is very inefficient. In order to determine the
                  next node, this method first performs a linear search in the
                  parent&apos;s child-list in order to find the current node.
                  &lt;p&gt;
                  That implementation makes the operation suitable for short
                  traversals from a known position. But to traverse all of the
                  leaves in the tree, you should use &lt;code&gt;depthFirstEnumeration&lt;/code&gt;
                  to enumerate the nodes in the tree and use &lt;code&gt;isLeaf&lt;/code&gt;
                  on each node to determine which are leaves.                
                <see>
                    #depthFirstEnumeration                    
                </see>
                <see>
                    #isLeaf                    
                </see>
                <return>
                    returns the next leaf past this node                    
                </return>
            </javadoc>
            <method name="getNextLeaf" type="DefaultMutableTreeNode" line="1148">
                <comment line="1156">
                    linear search                    
                </comment>
                <comment line="1161">
                    tail recursion                    
                </comment>
                <declaration name="nextSibling" type="DefaultMutableTreeNode" line="1149"/>
                <declaration name="myParent" type="DefaultMutableTreeNode" line="1150"/>
            </method>
            <javadoc line="1164">
                Returns the leaf before this node or null if this node is the
                  first leaf in the tree.
                  &lt;p&gt;
                  In this implementation of the &lt;code&gt;MutableNode&lt;/code&gt; interface,
                  this operation is very inefficient. In order to determine the
                  previous node, this method first performs a linear search in the
                  parent&apos;s child-list in order to find the current node.
                  &lt;p&gt;
                  That implementation makes the operation suitable for short
                  traversals from a known position. But to traverse all of the
                  leaves in the tree, you should use &lt;code&gt;depthFirstEnumeration&lt;/code&gt;
                  to enumerate the nodes in the tree and use &lt;code&gt;isLeaf&lt;/code&gt;
                  on each node to determine which are leaves.                
                <see>
                    #depthFirstEnumeration                    
                </see>
                <see>
                    #isLeaf                    
                </see>
                <return>
                    returns the leaf before this node                    
                </return>
            </javadoc>
            <method name="getPreviousLeaf" type="DefaultMutableTreeNode" line="1183">
                <comment line="1191">
                    linear search                    
                </comment>
                <comment line="1196">
                    tail recursion                    
                </comment>
                <declaration name="previousSibling" type="DefaultMutableTreeNode" line="1184"/>
                <declaration name="myParent" type="DefaultMutableTreeNode" line="1185"/>
            </method>
            <javadoc line="1199">
                Returns the total number of leaves that are descendants of this node.
                  If this node is a leaf, returns &lt;code&gt;1&lt;/code&gt;.  This method is O(n)
                  where n is the number of descendants of this node.                
                <see>
                    #isNodeAncestor                    
                </see>
                <return>
                    the number of leaves beneath this node                    
                </return>
            </javadoc>
            <method name="getLeafCount" type="int" line="1207">
                <comment line="1212">
                    order matters not                    
                </comment>
                <declaration name="count" type="int" line="1208"/>
                <declaration name="node" type="TreeNode" line="1210"/>
                <declaration name="enum_" type="Enumeration" line="1211"/>
                <scope line="1213">
                    <scope line="1215"/>
                </scope>
                <scope line="1220"/>
            </method>
            <javadoc line="1232">
                Returns the result of sending &lt;code&gt;toString()&lt;/code&gt; to this node&apos;s
                  user object, or the empty string if the node has no user object.                
                <see>
                    #getUserObject                    
                </see>
            </javadoc>
            <method name="toString" type="String" line="1238">
                <scope line="1239"/>
                <scope line="1241"/>
            </method>
            <javadoc line="1246">
                Overridden to make clone public.  Returns a shallow copy of this node;
                  the new node has no parent or children and has a reference to the same
                  user object, if any.                
                <return>
                    a copy of this node                    
                </return>
            </javadoc>
            <method name="clone" type="Object" line="1253">
                <comment line="1260">
                    shallow copy -- the new node has no parent or children                    
                </comment>
                <comment line="1265">
                    Won&apos;t happen because we implement Cloneable                    
                </comment>
                <declaration name="newNode" type="DefaultMutableTreeNode" line="1254"/>
                <scope line="1256"/>
                <scope line="1263"/>
            </method>
            <method name="writeObject" type="void" line="1273">
                <params>
                    <param name="s" type="ObjectOutputStream"/>
                </params>
                <comment line="1278">
                    Save the userObject, if its Serializable.                    
                </comment>
                <declaration name="tValues" type="Object[]" line="1274"/>
                <scope line="1278"/>
            </method>
            <method name="readObject" type="void" line="1289">
                <params>
                    <param name="s" type="ObjectInputStream"/>
                </params>
                <declaration name="tValues" type="Object[]" line="1290"/>
            </method>
            <class name="PreorderEnumeration" line="1300">
                <comment line="1400">
                    A simple queue with a linked list data structure.                    
                </comment>
                <comment line="1451">
                    End of class Queue                    
                </comment>
                <implements interface="Enumeration">
                    <type_params>
                        <type_param name="TreeNode"/>
                    </type_params>
                </implements>
                <declaration name="stack" type="Stack&lt;Enumeration&gt;" line="1301"/>
                <method name="PreorderEnumeration" type="constructor" line="1303">
                    <params>
                        <param name="rootNode" type="TreeNode"/>
                    </params>
                    <comment line="1307">
                        PENDING: don&apos;t really need a vector                        
                    </comment>
                    <declaration name="v" type="Vector&lt;TreeNode&gt;" line="1305"/>
                </method>
                <method name="hasMoreElements" type="boolean" line="1310"/>
                <method name="nextElement" type="TreeNode" line="1314">
                    <declaration name="enumer" type="Enumeration" line="1315"/>
                    <declaration name="node" type="TreeNode" line="1316"/>
                    <declaration name="children" type="Enumeration" line="1317"/>
                    <scope line="1319"/>
                    <scope line="1322"/>
                </method>
            </class>
            <class name="PostorderEnumeration" line="1332">
                <comment line="1400">
                    A simple queue with a linked list data structure.                    
                </comment>
                <comment line="1451">
                    End of class Queue                    
                </comment>
                <implements interface="Enumeration">
                    <type_params>
                        <type_param name="TreeNode"/>
                    </type_params>
                </implements>
                <declaration name="root" type="TreeNode" line="1333"/>
                <declaration name="children" type="Enumeration&lt;TreeNode&gt;" line="1334"/>
                <declaration name="subtree" type="Enumeration&lt;TreeNode&gt;" line="1335"/>
                <method name="PostorderEnumeration" type="constructor" line="1337">
                    <params>
                        <param name="rootNode" type="TreeNode"/>
                    </params>
                </method>
                <method name="hasMoreElements" type="boolean" line="1344"/>
                <method name="nextElement" type="TreeNode" line="1348">
                    <declaration name="retval" type="TreeNode" line="1349"/>
                    <scope line="1351"/>
                    <scope line="1353"/>
                    <scope line="1356"/>
                </method>
            </class>
            <class name="BreadthFirstEnumeration" line="1368">
                <comment line="1400">
                    A simple queue with a linked list data structure.                    
                </comment>
                <comment line="1451">
                    End of class Queue                    
                </comment>
                <implements interface="Enumeration">
                    <type_params>
                        <type_param name="TreeNode"/>
                    </type_params>
                </implements>
                <declaration name="queue" type="Queue" line="1369"/>
                <method name="BreadthFirstEnumeration" type="constructor" line="1371">
                    <params>
                        <param name="rootNode" type="TreeNode"/>
                    </params>
                    <comment line="1375">
                        PENDING: don&apos;t really need a vector                        
                    </comment>
                    <declaration name="v" type="Vector&lt;TreeNode&gt;" line="1373"/>
                </method>
                <method name="hasMoreElements" type="boolean" line="1379"/>
                <method name="nextElement" type="TreeNode" line="1384">
                    <declaration name="enumer" type="Enumeration" line="1385"/>
                    <declaration name="node" type="TreeNode" line="1386"/>
                    <declaration name="children" type="Enumeration" line="1387"/>
                    <scope line="1389"/>
                    <scope line="1392"/>
                </method>
                <class name="Queue" line="1400">
                    <comment line="1402">
                        null if empty                        
                    </comment>
                    <declaration name="head" type="QNode" line="1401"/>
                    <declaration name="tail" type="QNode" line="1402"/>
                    <class name="QNode" line="1404">
                        <comment line="1407">
                            null if end                            
                        </comment>
                        <declaration name="object" type="Object" line="1405"/>
                        <declaration name="next" type="QNode" line="1406"/>
                        <method name="QNode" type="constructor" line="1407">
                            <params>
                                <param name="object" type="Object"/>
                                <param name="next" type="QNode"/>
                            </params>
                        </method>
                    </class>
                    <method name="enqueue" type="void" line="1413">
                        <params>
                            <param name="anObject" type="Object"/>
                        </params>
                        <scope line="1414"/>
                        <scope line="1416"/>
                    </method>
                    <method name="dequeue" type="Object" line="1422">
                        <scope line="1423"/>
                        <declaration name="retval" type="Object" line="1427"/>
                        <declaration name="oldHead" type="QNode" line="1428"/>
                        <scope line="1430"/>
                        <scope line="1432"/>
                    </method>
                    <method name="firstObject" type="Object" line="1438">
                        <scope line="1439"/>
                    </method>
                    <method name="isEmpty" type="boolean" line="1446"/>
                </class>
            </class>
            <class name="PathBetweenNodesEnumeration" line="1456">
                <comment line="1400">
                    A simple queue with a linked list data structure.                    
                </comment>
                <comment line="1451">
                    End of class Queue                    
                </comment>
                <implements interface="Enumeration">
                    <type_params>
                        <type_param name="TreeNode"/>
                    </type_params>
                </implements>
                <declaration name="stack" type="Stack&lt;TreeNode&gt;" line="1457"/>
                <method name="PathBetweenNodesEnumeration" type="constructor" line="1461">
                    <params>
                        <param name="ancestor" type="TreeNode"/>
                        <param name="descendant" type="TreeNode"/>
                    </params>
                    <scope line="1464"/>
                    <declaration name="current" type="TreeNode" line="1468"/>
                    <scope line="1474">
                        <scope line="1476"/>
                    </scope>
                </method>
                <method name="hasMoreElements" type="boolean" line="1484"/>
                <method name="nextElement" type="TreeNode" line="1488">
                    <scope line="1489"/>
                    <scope line="1491"/>
                </method>
            </class>
        </class>
    </source>