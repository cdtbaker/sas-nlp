<?xml version="1.0" encoding="UTF-8"?>
    <source package="javax.swing">
        <import package="java.awt"/>
        <import package="java.awt.event"/>
        <import package="java.awt.peer.ComponentPeer"/>
        <import package="java.awt.peer.ContainerPeer"/>
        <import package="java.awt.image.VolatileImage"/>
        <import package="java.security.AccessController"/>
        <import package="java.util"/>
        <import package="java.applet"/>
        <import package="sun.awt.AWTAccessor"/>
        <import package="sun.awt.AppContext"/>
        <import package="sun.awt.DisplayChangedListener"/>
        <import package="sun.awt.SunToolkit"/>
        <import package="sun.java2d.SunGraphicsEnvironment"/>
        <import package="sun.security.action.GetPropertyAction"/>
        <import package="com.sun.java.swing.SwingUtilities3"/>
        <class name="RepaintManager" line="17">
            <javadoc line="17">
                This class manages repaint requests, allowing the number
                  of repaints to be minimized, for example by collapsing multiple
                  requests into a single repaint for members of a component tree.
                  &lt;p&gt;
                  As of 1.6 &lt;code&gt;RepaintManager&lt;/code&gt; handles repaint requests
                  for Swing&apos;s top level components (&lt;code&gt;JApplet&lt;/code&gt;,
                  &lt;code&gt;JWindow&lt;/code&gt;, &lt;code&gt;JFrame&lt;/code&gt; and &lt;code&gt;JDialog&lt;/code&gt;).
                  Any calls to &lt;code&gt;repaint&lt;/code&gt; on one of these will call into the
                  appropriate &lt;code&gt;addDirtyRegion&lt;/code&gt; method.                
                <author>
                    Arnaud Weber                    
                </author>
            </javadoc>
            <declaration name="HANDLE_TOP_LEVEL_PAINT" type="boolean" line="30"/>
            <javadoc line="30">
                Whether or not the RepaintManager should handle paint requests
                  for top levels.                
            </javadoc>
            <declaration name="BUFFER_STRATEGY_NOT_SPECIFIED" type="short" line="35"/>
            <declaration name="BUFFER_STRATEGY_SPECIFIED_ON" type="short" line="36"/>
            <declaration name="BUFFER_STRATEGY_SPECIFIED_OFF" type="short" line="37"/>
            <declaration name="BUFFER_STRATEGY_TYPE" type="short" line="38"/>
            <declaration name="volatileMap" type="Map&amp;lt;GraphicsConfiguration,VolatileImage&amp;gt;" line="39"/>
            <javadoc line="39">
                Maps from GraphicsConfiguration to VolatileImage.                
            </javadoc>
            <declaration name="hwDirtyComponents" type="Map&amp;lt;Container,Rectangle&amp;gt;" line="43"/>
            <declaration name="dirtyComponents" type="Map&amp;lt;Component,Rectangle&amp;gt;" line="44"/>
            <declaration name="tmpDirtyComponents" type="Map&amp;lt;Component,Rectangle&amp;gt;" line="45"/>
            <declaration name="invalidComponents" type="java.util.List&amp;lt;Component&amp;gt;" line="46"/>
            <declaration name="runnableList" type="java.util.List&amp;lt;Runnable&amp;gt;" line="47"/>
            <declaration name="doubleBufferingEnabled" type="boolean" line="48"/>
            <declaration name="doubleBufferMaxSize" type="Dimension" line="49"/>
            <declaration name="standardDoubleBuffer" type="DoubleBufferInfo" line="50"/>
            <declaration name="paintManager" type="PaintManager" line="51"/>
            <javadoc line="51">
                Object responsible for hanlding core paint functionality.                
            </javadoc>
            <declaration name="repaintManagerKey" type="Object" line="55"/>
            <declaration name="volatileImageBufferEnabled" type="boolean" line="56"/>
            <declaration name="nativeDoubleBuffering" type="boolean" line="57"/>
            <javadoc line="57">
                Value of the system property awt.nativeDoubleBuffering.                
            </javadoc>
            <declaration name="VOLATILE_LOOP_MAX" type="int" line="61"/>
            <declaration name="paintDepth" type="int" line="62"/>
            <javadoc line="62">
                Number of &lt;code&gt;beginPaint&lt;/code&gt; that have been invoked.                
            </javadoc>
            <declaration name="bufferStrategyType" type="short" line="66"/>
            <javadoc line="66">
                Type of buffer strategy to use.  Will be one of the BUFFER_STRATEGY_
                  constants.                
            </javadoc>
            <declaration name="painting" type="boolean" line="71"/>
            <javadoc line="71">
                True if we&apos;re in the process of painting the dirty regions.  This is
                  set to true in &lt;code&gt;paintDirtyRegions&lt;/code&gt;.                
            </javadoc>
            <declaration name="repaintRoot" type="JComponent" line="76"/>
            <javadoc line="76">
                If the PaintManager calls into repaintRoot during painting this field
                  will be set to the root.                
            </javadoc>
            <declaration name="paintThread" type="Thread" line="81"/>
            <javadoc line="81">
                The Thread that has initiated painting.  If null it
                  indicates painting is not currently in progress.                
            </javadoc>
            <declaration name="processingRunnable" type="ProcessingRunnable" line="86"/>
            <javadoc line="86">
                Runnable used to process all repaint/revalidate requests.                
            </javadoc>
            <scope line="90">
                <declaration name="headless" type="boolean" line="92"/>
                <scope line="93"/>
                <declaration name="bs" type="String" line="97"/>
                <scope line="98"/>
                <scope line="101"/>
                <scope line="104"/>
                <scope line="107"/>
                <declaration name="ge" type="GraphicsEnvironment" line="111"/>
                <scope line="112"/>
            </scope>
            <javadoc line="116">
                Return the RepaintManager for the calling thread given a Component.                
                <param>
                    c a Component -- unused in the default implementation, but could
                      be used by an overridden version to return a different RepaintManager
                      depending on the Component                    
                </param>
                <return>
                    the RepaintManager object                    
                </return>
            </javadoc>
            <method name="currentManager" type="RepaintManager" line="123">
                <params>
                    <param name="c" type="Component"/>
                </params>
            </method>
            <javadoc line="126">
                Returns the RepaintManager for the specified AppContext.  If
                  a RepaintManager has not been created for the specified
                  AppContext this will return null.                
            </javadoc>
            <method name="currentManager" type="RepaintManager" line="131">
                <params>
                    <param name="appContext" type="AppContext"/>
                </params>
                <declaration name="rm" type="RepaintManager" line="132"/>
                <scope line="133"/>
            </method>
            <javadoc line="139">
                Return the RepaintManager for the calling thread given a JComponent.
                  &lt;p&gt;
                  Note: This method exists for backward binary compatibility with earlier
                  versions of the Swing library. It simply returns the result returned by{@link #currentManager(Component)}.                
                <param>
                    c a JComponent -- unused                    
                </param>
                <return>
                    the RepaintManager object                    
                </return>
            </javadoc>
            <method name="currentManager" type="RepaintManager" line="147">
                <params>
                    <param name="c" type="JComponent"/>
                </params>
            </method>
            <javadoc line="150">
                Set the RepaintManager that should be used for the calling
                  thread. &lt;b&gt;aRepaintManager&lt;/b&gt; will become the current RepaintManager
                  for the calling thread&apos;s thread group.                
                <param>
                    aRepaintManager  the RepaintManager object to use                    
                </param>
            </javadoc>
            <method name="setCurrentManager" type="void" line="156">
                <params>
                    <param name="aRepaintManager" type="RepaintManager"/>
                </params>
                <scope line="157"/>
                <scope line="160"/>
            </method>
            <javadoc line="164">
                Create a new RepaintManager instance. You rarely call this constructor.
                  directly. To get the default RepaintManager, use
                  RepaintManager.currentManager(JComponent) (normally &quot;this&quot;).                
            </javadoc>
            <method name="RepaintManager" type="constructor" line="169"/>
            <method name="RepaintManager" type="constructor" line="172">
                <params>
                    <param name="bufferStrategyType" type="short"/>
                </params>
                <scope line="174"/>
            </method>
            <method name="displayChanged" type="void" line="182"/>
            <javadoc line="185">
                Mark the component as in need of layout and queue a runnable
                  for the event dispatching thread that will validate the components
                  first isValidateRoot() ancestor.                
                <see>
                    JComponent#isValidateRoot                    
                </see>
                <see>
                    #removeInvalidComponent                    
                </see>
            </javadoc>
            <method name="addInvalidComponent" type="void" line="192">
                <params>
                    <param name="invalidComponent" type="JComponent"/>
                </params>
                <declaration name="delegate" type="RepaintManager" line="193"/>
                <scope line="194"/>
                <declaration name="validateRoot" type="Component" line="198"/>
                <scope line="199"/>
                <scope line="202"/>
                <scope line="205">
                    <declaration name="n" type="int" line="206"/>
                    <scope line="207">
                        <scope line="208"/>
                    </scope>
                </scope>
            </method>
            <javadoc line="216">
                Remove a component from the list of invalid components.                
                <see>
                    #addInvalidComponent                    
                </see>
            </javadoc>
            <method name="removeInvalidComponent" type="void" line="220">
                <params>
                    <param name="component" type="JComponent"/>
                </params>
                <declaration name="delegate" type="RepaintManager" line="221"/>
                <scope line="222"/>
                <scope line="226">
                    <declaration name="index" type="int" line="227"/>
                    <scope line="228"/>
                </scope>
            </method>
            <javadoc line="233">
                Add a component in the list of components that should be refreshed.
                  If &lt;i&gt;c&lt;/i&gt; already has a dirty region, the rectangle &lt;i&gt;(x,y,w,h)&lt;/i&gt;
                  will be unioned with the region that should be redrawn.                
                <see>
                    JComponent#repaint                    
                </see>
            </javadoc>
            <method name="addDirtyRegion0" type="void" line="239">
                <params>
                    <param name="c" type="Container"/>
                    <param name="x" type="int"/>
                    <param name="y" type="int"/>
                    <param name="w" type="int"/>
                    <param name="h" type="int"/>
                </params>
                <scope line="240"/>
                <scope line="243"/>
                <scope line="246"/>
                <declaration name="root" type="Component" line="249"/>
                <scope line="250">
                    <scope line="251"/>
                    <scope line="254">
                        <scope line="255"/>
                    </scope>
                </scope>
                <scope line="263">
                    <scope line="264"/>
                </scope>
            </method>
            <javadoc line="271">
                Add a component in the list of components that should be refreshed.
                  If &lt;i&gt;c&lt;/i&gt; already has a dirty region, the rectangle &lt;i&gt;(x,y,w,h)&lt;/i&gt;
                  will be unioned with the region that should be redrawn.                
                <param>
                    c Component to repaint, null results in nothing happening.                    
                </param>
                <param>
                    x X coordinate of the region to repaint                    
                </param>
                <param>
                    y Y coordinate of the region to repaint                    
                </param>
                <param>
                    w Width of the region to repaint                    
                </param>
                <param>
                    h Height of the region to repaint                    
                </param>
                <see>
                    JComponent#repaint                    
                </see>
            </javadoc>
            <method name="addDirtyRegion" type="void" line="282">
                <params>
                    <param name="c" type="JComponent"/>
                    <param name="x" type="int"/>
                    <param name="y" type="int"/>
                    <param name="w" type="int"/>
                    <param name="h" type="int"/>
                </params>
                <declaration name="delegate" type="RepaintManager" line="283"/>
                <scope line="284"/>
            </method>
            <javadoc line="290">
                Adds &lt;code&gt;window&lt;/code&gt; to the list of &lt;code&gt;Component&lt;/code&gt;s that
                  need to be repainted.                
                <param>
                    window Window to repaint, null results in nothing happening.                    
                </param>
                <param>
                    x X coordinate of the region to repaint                    
                </param>
                <param>
                    y Y coordinate of the region to repaint                    
                </param>
                <param>
                    w Width of the region to repaint                    
                </param>
                <param>
                    h Height of the region to repaint                    
                </param>
                <see>
                    JFrame#repaint                    
                </see>
                <see>
                    JWindow#repaint                    
                </see>
                <see>
                    JDialog#repaint                    
                </see>
                <since>
                    1.6                    
                </since>
            </javadoc>
            <method name="addDirtyRegion" type="void" line="303">
                <params>
                    <param name="window" type="Window"/>
                    <param name="x" type="int"/>
                    <param name="y" type="int"/>
                    <param name="w" type="int"/>
                    <param name="h" type="int"/>
                </params>
            </method>
            <javadoc line="306">
                Adds &lt;code&gt;applet&lt;/code&gt; to the list of &lt;code&gt;Component&lt;/code&gt;s that
                  need to be repainted.                
                <param>
                    applet Applet to repaint, null results in nothing happening.                    
                </param>
                <param>
                    x X coordinate of the region to repaint                    
                </param>
                <param>
                    y Y coordinate of the region to repaint                    
                </param>
                <param>
                    w Width of the region to repaint                    
                </param>
                <param>
                    h Height of the region to repaint                    
                </param>
                <see>
                    JApplet#repaint                    
                </see>
                <since>
                    1.6                    
                </since>
            </javadoc>
            <method name="addDirtyRegion" type="void" line="317">
                <params>
                    <param name="applet" type="Applet"/>
                    <param name="x" type="int"/>
                    <param name="y" type="int"/>
                    <param name="w" type="int"/>
                    <param name="h" type="int"/>
                </params>
            </method>
            <method name="scheduleHeavyWeightPaints" type="void" line="320">
                <declaration name="hws" type="Map&amp;lt;Container,Rectangle&amp;gt;" line="321"/>
                <scope line="322">
                    <scope line="323"/>
                </scope>
                <scope line="329">
                    <declaration name="dirty" type="Rectangle" line="330"/>
                    <scope line="331"/>
                    <scope line="334"/>
                    <scope line="337"/>
                </scope>
            </method>
            <method name="nativeAddDirtyRegion" type="void" line="342">
                <params>
                    <param name="appContext" type="AppContext"/>
                    <param name="c" type="Container"/>
                    <param name="x" type="int"/>
                    <param name="y" type="int"/>
                    <param name="w" type="int"/>
                    <param name="h" type="int"/>
                </params>
                <scope line="343">
                    <scope line="344">
                        <declaration name="dirty" type="Rectangle" line="345"/>
                        <scope line="346"/>
                        <scope line="349"/>
                    </scope>
                </scope>
            </method>
            <method name="nativeQueueSurfaceDataRunnable" type="void" line="356">
                <params>
                    <param name="appContext" type="AppContext"/>
                    <param name="c" type="Component"/>
                    <param name="r" type="Runnable"/>
                </params>
                <scope line="357">
                    <scope line="358"/>
                </scope>
            </method>
            <javadoc line="365">
                Extends the dirty region for the specified component to include
                  the new region.                
                <return>
                    false if &lt;code&gt;c&lt;/code&gt; is not yet marked dirty.                    
                </return>
            </javadoc>
            <method name="extendDirtyRegion" type="boolean" line="370">
                <params>
                    <param name="c" type="Component"/>
                    <param name="x" type="int"/>
                    <param name="y" type="int"/>
                    <param name="w" type="int"/>
                    <param name="h" type="int"/>
                </params>
                <declaration name="r" type="Rectangle" line="371"/>
                <scope line="372"/>
            </method>
            <javadoc line="378">
                Return the current dirty region for a component.
                  Return an empty rectangle if the component is not
                  dirty.                
            </javadoc>
            <method name="getDirtyRegion" type="Rectangle" line="383">
                <params>
                    <param name="aComponent" type="JComponent"/>
                </params>
                <declaration name="delegate" type="RepaintManager" line="384"/>
                <scope line="385"/>
                <declaration name="r" type="Rectangle" line="388"/>
                <scope line="389"/>
            </method>
            <javadoc line="395">
                Mark a component completely dirty. &lt;b&gt;aComponent&lt;/b&gt; will be
                  completely painted during the next paintDirtyRegions() call.                
            </javadoc>
            <method name="markCompletelyDirty" type="void" line="399">
                <params>
                    <param name="aComponent" type="JComponent"/>
                </params>
                <declaration name="delegate" type="RepaintManager" line="400"/>
                <scope line="401"/>
            </method>
            <javadoc line="407">
                Mark a component completely clean. &lt;b&gt;aComponent&lt;/b&gt; will not
                  get painted during the next paintDirtyRegions() call.                
            </javadoc>
            <method name="markCompletelyClean" type="void" line="411">
                <params>
                    <param name="aComponent" type="JComponent"/>
                </params>
                <declaration name="delegate" type="RepaintManager" line="412"/>
                <scope line="413"/>
                <scope line="417"/>
            </method>
            <javadoc line="421">
                Convenience method that returns true if &lt;b&gt;aComponent&lt;/b&gt; will be completely
                  painted during the next paintDirtyRegions(). If computing dirty regions is
                  expensive for your component, use this method and avoid computing dirty region
                  if it return true.                
            </javadoc>
            <method name="isCompletelyDirty" type="boolean" line="427">
                <params>
                    <param name="aComponent" type="JComponent"/>
                </params>
                <declaration name="delegate" type="RepaintManager" line="428"/>
                <scope line="429"/>
                <declaration name="r" type="Rectangle" line="432"/>
            </method>
            <javadoc line="437">
                Validate all of the components that have been marked invalid.                
                <see>
                    #addInvalidComponent                    
                </see>
            </javadoc>
            <method name="validateInvalidComponents" type="void" line="441">
                <declaration name="ic" type="java.util.List&amp;lt;Component&amp;gt;" line="442"/>
                <scope line="443">
                    <scope line="444"/>
                </scope>
                <declaration name="n" type="int" line="450"/>
                <scope line="451"/>
            </method>
            <javadoc line="455">
                This is invoked to process paint requests.  It&apos;s needed
                  for backward compatability in so far as RepaintManager would previously
                  not see paint requests for top levels, so, we have to make sure
                  a subclass correctly paints any dirty top levels.                
            </javadoc>
            <method name="prePaintDirtyRegions" type="void" line="461">
                <declaration name="dirtyComponents" type="Map&amp;lt;Component,Rectangle&amp;gt;" line="462"/>
                <declaration name="runnableList" type="java.util.List&amp;lt;Runnable&amp;gt;" line="463"/>
                <scope line="464"/>
                <scope line="469">
                    <scope line="470"/>
                </scope>
                <scope line="475"/>
            </method>
            <method name="updateWindows" type="void" line="479">
                <params>
                    <param name="dirtyComponents" type="Map&lt;Component,Rectangle&gt;"/>
                </params>
                <declaration name="toolkit" type="Toolkit" line="480"/>
                <scope line="481"/>
                <declaration name="windows" type="Set&amp;lt;Window&amp;gt;" line="484"/>
                <declaration name="dirtyComps" type="Set&amp;lt;Component&amp;gt;" line="485"/>
                <scope line="486">
                    <declaration name="dirty" type="Component" line="487"/>
                    <declaration name="window" type="Window" line="488"/>
                    <scope line="489"/>
                </scope>
                <scope line="493"/>
            </method>
            <method name="isPainting" type="boolean" line="497"/>
            <javadoc line="500">
                Paint all of the components that have been marked dirty.                
                <see>
                    #addDirtyRegion                    
                </see>
            </javadoc>
            <method name="paintDirtyRegions" type="void" line="504">
                <scope line="505">
                    <declaration name="tmp" type="Map&amp;lt;Component,Rectangle&amp;gt;" line="506"/>
                </scope>
            </method>
            <method name="paintDirtyRegions" type="void" line="513">
                <params>
                    <param name="tmpDirtyComponents" type="Map&lt;Component,Rectangle&gt;"/>
                </params>
                <declaration name="i" type="int" line="514"/>
                <declaration name="roots" type="java.util.List&amp;lt;Component&amp;gt;" line="515"/>
                <declaration name="dirtyComponent" type="Component" line="516"/>
                <scope line="518"/>
                <declaration name="rect" type="Rectangle" line="521"/>
                <declaration name="localBoundsX" type="int" line="522"/>
                <declaration name="localBoundsY" type="int" line="523"/>
                <declaration name="localBoundsH" type="int" line="524"/>
                <declaration name="localBoundsW" type="int" line="525"/>
                <declaration name="keys" type="Enumeration" line="526"/>
                <scope line="528"/>
                <scope line="533">
                    <scope line="534">
                        <scope line="540"/>
                        <scope line="543">
                            <declaration name="g" type="Graphics" line="544"/>
                            <scope line="545">
                                <scope line="547"/>
                                <scope line="550"/>
                            </scope>
                        </scope>
                        <scope line="555"/>
                    </scope>
                </scope>
                <scope line="565"/>
            </method>
            <javadoc line="571">
                Removes any components from roots that are children of
                  root.                
            </javadoc>
            <method name="adjustRoots" type="void" line="575">
                <params>
                    <param name="root" type="JComponent"/>
                    <param name="roots" type="java.util.List&lt;Component&gt;"/>
                    <param name="index" type="int"/>
                </params>
                <scope line="576">
                    <declaration name="c" type="Component" line="577"/>
                    <scope line="578">
                        <scope line="579"/>
                    </scope>
                    <scope line="584"/>
                </scope>
            </method>
            <declaration name="tmp" type="Rectangle" line="589"/>
            <method name="collectDirtyComponents" type="void" line="590">
                <params>
                    <param name="dirtyComponents" type="Map&lt;Component,Rectangle&gt;"/>
                    <param name="dirtyComponent" type="Component"/>
                    <param name="roots" type="java.util.List&lt;Component&gt;"/>
                </params>
                <declaration name="dx" type="int" line="591"/>
                <declaration name="component" type="Component" line="592"/>
                <declaration name="cBounds" type="Rectangle" line="593"/>
                <declaration name="x" type="int" line="595"/>
                <declaration name="y" type="int" line="596"/>
                <declaration name="w" type="int" line="597"/>
                <declaration name="h" type="int" line="598"/>
                <scope line="603"/>
                <scope line="606">
                    <scope line="619"/>
                    <scope line="622"/>
                </scope>
                <scope line="628">
                    <declaration name="r" type="Rectangle" line="629"/>
                </scope>
            </method>
            <javadoc line="636">
                Returns a string that displays and identifies this
                  object&apos;s properties.                
                <return>
                    a String representation of this object                    
                </return>
            </javadoc>
            <method name="toString" type="String" line="641">
                <declaration name="sb" type="StringBuffer" line="642"/>
            </method>
            <javadoc line="646">
                Return the offscreen buffer that should be used as a double buffer with
                  the component &lt;code&gt;c&lt;/code&gt;.
                  By default there is a double buffer per RepaintManager.
                  The buffer might be smaller than &lt;code&gt;(proposedWidth,proposedHeight)&lt;/code&gt;
                  This happens when the maximum double buffer size as been set for the receiving
                  repaint manager.                
            </javadoc>
            <method name="getOffscreenBuffer" type="Image" line="654">
                <params>
                    <param name="c" type="Component"/>
                    <param name="proposedWidth" type="int"/>
                    <param name="proposedHeight" type="int"/>
                </params>
                <declaration name="delegate" type="RepaintManager" line="655"/>
                <scope line="656"/>
            </method>
            <javadoc line="661">
                Return a volatile offscreen buffer that should be used as a
                  double buffer with the specified component &lt;code&gt;c&lt;/code&gt;.
                  The image returned will be an instance of VolatileImage, or null
                  if a VolatileImage object could not be instantiated.
                  This buffer might be smaller than &lt;code&gt;(proposedWidth,proposedHeight)&lt;/code&gt;.
                  This happens when the maximum double buffer size has been set for this
                  repaint manager.                
                <see>
                    java.awt.image.VolatileImage                    
                </see>
                <since>
                    1.4                    
                </since>
            </javadoc>
            <method name="getVolatileOffscreenBuffer" type="Image" line="672">
                <params>
                    <param name="c" type="Component"/>
                    <param name="proposedWidth" type="int"/>
                    <param name="proposedHeight" type="int"/>
                </params>
                <declaration name="delegate" type="RepaintManager" line="673"/>
                <scope line="674"/>
                <declaration name="w" type="Window" line="677"/>
                <scope line="678">
                    <declaration name="tk" type="Toolkit" line="679"/>
                    <scope line="680"/>
                </scope>
                <declaration name="config" type="GraphicsConfiguration" line="684"/>
                <scope line="685"/>
                <declaration name="maxSize" type="Dimension" line="688"/>
                <declaration name="width" type="int" line="689"/>
                <declaration name="height" type="int" line="690"/>
                <declaration name="image" type="VolatileImage" line="691"/>
                <scope line="692">
                    <scope line="693"/>
                </scope>
            </method>
            <method name="_getOffscreenBuffer" type="Image" line="701">
                <params>
                    <param name="c" type="Component"/>
                    <param name="proposedWidth" type="int"/>
                    <param name="proposedHeight" type="int"/>
                </params>
                <declaration name="maxSize" type="Dimension" line="702"/>
                <declaration name="doubleBuffer" type="DoubleBufferInfo" line="703"/>
                <declaration name="width" type="int" line="704"/>
                <declaration name="w" type="Window" line="705"/>
                <scope line="706">
                    <declaration name="tk" type="Toolkit" line="707"/>
                    <scope line="708"/>
                </scope>
                <scope line="712"/>
                <scope line="718">
                    <scope line="720"/>
                </scope>
                <declaration name="result" type="Image" line="727"/>
                <scope line="728">
                    <scope line="731"/>
                </scope>
            </method>
            <javadoc line="738">
                Set the maximum double buffer size.                
            </javadoc>
            <method name="setDoubleBufferMaximumSize" type="void" line="741">
                <params>
                    <param name="d" type="Dimension"/>
                </params>
                <scope line="743"/>
                <scope line="746"/>
            </method>
            <method name="clearImages" type="void" line="750"/>
            <method name="clearImages" type="void" line="753">
                <params>
                    <param name="width" type="int"/>
                    <param name="height" type="int"/>
                </params>
                <scope line="754">
                    <scope line="755"/>
                </scope>
                <declaration name="gcs" type="Iterator" line="760"/>
                <scope line="761">
                    <declaration name="gc" type="GraphicsConfiguration" line="762"/>
                    <declaration name="image" type="VolatileImage" line="763"/>
                    <scope line="764"/>
                </scope>
            </method>
            <javadoc line="770">
                Returns the maximum double buffer size.                
                <return>
                    a Dimension object representing the maximum size                    
                </return>
            </javadoc>
            <method name="getDoubleBufferMaximumSize" type="Dimension" line="774">
                <scope line="775">
                    <scope line="776">
                        <declaration name="virtualBounds" type="Rectangle" line="777"/>
                        <declaration name="ge" type="GraphicsEnvironment" line="778"/>
                        <scope line="779">
                            <declaration name="gc" type="GraphicsConfiguration" line="780"/>
                        </scope>
                    </scope>
                    <scope line="785"/>
                </scope>
            </method>
            <javadoc line="791">
                Enables or disables double buffering in this RepaintManager.
                  CAUTION: The default value for this property is set for optimal
                  paint performance on the given platform and it is not recommended
                  that programs modify this property directly.                
                <param>
                    aFlag  true to activate double buffering                    
                </param>
                <see>
                    #isDoubleBufferingEnabled                    
                </see>
            </javadoc>
            <method name="setDoubleBufferingEnabled" type="void" line="799">
                <params>
                    <param name="aFlag" type="boolean"/>
                </params>
                <declaration name="paintManager" type="PaintManager" line="801"/>
                <scope line="802"/>
            </method>
            <javadoc line="806">
                Returns true if this RepaintManager is double buffered.
                  The default value for this property may vary from platform
                  to platform.  On platforms where native double buffering
                  is supported in the AWT, the default value will be &lt;code&gt;false&lt;/code&gt;
                  to avoid unnecessary buffering in Swing.
                  On platforms where native double buffering is not supported,
                  the default value will be &lt;code&gt;true&lt;/code&gt;.                
                <return>
                    true if this object is double buffered                    
                </return>
            </javadoc>
            <method name="isDoubleBufferingEnabled" type="boolean" line="816"/>
            <javadoc line="819">
                This resets the double buffer. Actually, it marks the double buffer
                  as invalid, the double buffer will then be recreated on the next
                  invocation of getOffscreenBuffer.                
            </javadoc>
            <method name="resetDoubleBuffer" type="void" line="824">
                <scope line="825"/>
            </method>
            <javadoc line="829">
                This resets the volatile double buffer.                
            </javadoc>
            <method name="resetVolatileDoubleBuffer" type="void" line="832">
                <params>
                    <param name="gc" type="GraphicsConfiguration"/>
                </params>
                <declaration name="image" type="Image" line="833"/>
                <scope line="834"/>
            </method>
            <javadoc line="838">
                Returns true if we should use the &lt;code&gt;Image&lt;/code&gt; returned
                  from &lt;code&gt;getVolatileOffscreenBuffer&lt;/code&gt; to do double buffering.                
            </javadoc>
            <method name="useVolatileDoubleBuffer" type="boolean" line="842"/>
            <javadoc line="845">
                Returns true if the current thread is the thread painting.  This
                  will return false if no threads are painting.                
            </javadoc>
            <method name="isPaintingThread" type="boolean" line="849"/>
            <javadoc line="852">
                Paints a region of a component                
                <param>
                    paintingComponent Component to paint                    
                </param>
                <param>
                    bufferComponent Component to obtain buffer for                    
                </param>
                <param>
                    g Graphics to paint to                    
                </param>
                <param>
                    x X-coordinate                    
                </param>
                <param>
                    y Y-coordinate                    
                </param>
                <param>
                    w Width                    
                </param>
                <param>
                    h Height                    
                </param>
            </javadoc>
            <method name="paint" type="void" line="862">
                <params>
                    <param name="paintingComponent" type="JComponent"/>
                    <param name="bufferComponent" type="JComponent"/>
                    <param name="g" type="Graphics"/>
                    <param name="x" type="int"/>
                    <param name="y" type="int"/>
                    <param name="w" type="int"/>
                    <param name="h" type="int"/>
                </params>
                <declaration name="paintManager" type="PaintManager" line="863"/>
                <scope line="864">
                    <scope line="865"/>
                </scope>
                <scope line="870"/>
            </method>
            <javadoc line="875">
                Does a copy area on the specified region.                
                <param>
                    clip Whether or not the copyArea needs to be clipped to the
                      Component&apos;s bounds.                    
                </param>
            </javadoc>
            <method name="copyArea" type="void" line="880">
                <params>
                    <param name="c" type="JComponent"/>
                    <param name="g" type="Graphics"/>
                    <param name="x" type="int"/>
                    <param name="y" type="int"/>
                    <param name="w" type="int"/>
                    <param name="h" type="int"/>
                    <param name="deltaX" type="int"/>
                    <param name="deltaY" type="int"/>
                    <param name="clip" type="boolean"/>
                </params>
            </method>
            <javadoc line="883">
                Invoked prior to any paint/copyArea method calls.  This will
                  be followed by an invocation of &lt;code&gt;endPaint&lt;/code&gt;.
                  &lt;b&gt;WARNING&lt;/b&gt;: Callers of this method need to wrap the call
                  in a &lt;code&gt;try/finally&lt;/code&gt;, otherwise if an exception is thrown
                  during the course of painting the RepaintManager may
                  be left in a state in which the screen is not updated, eg:
                  &lt;pre&gt;
                  repaintManager.beginPaint();
                  try {
                  repaintManager.paint(...);
                  } finally {
                  repaintManager.endPaint();
                  }
                  &lt;/pre&gt;                
            </javadoc>
            <method name="beginPaint" type="void" line="899">
                <declaration name="multiThreadedPaint" type="boolean" line="900"/>
                <declaration name="paintDepth" type="int" line="901"/>
                <declaration name="currentThread" type="Thread" line="902"/>
                <scope line="903">
                    <scope line="905"/>
                    <scope line="909"/>
                </scope>
                <scope line="913"/>
            </method>
            <javadoc line="917">
                Invoked after &lt;code&gt;beginPaint&lt;/code&gt; has been invoked.                
            </javadoc>
            <method name="endPaint" type="void" line="920">
                <scope line="921">
                    <declaration name="paintManager" type="PaintManager" line="922"/>
                    <scope line="923">
                        <scope line="924"/>
                    </scope>
                    <scope line="928">
                        <scope line="930"/>
                    </scope>
                </scope>
            </method>
            <javadoc line="936">
                If possible this will show a previously rendered portion of
                  a Component.  If successful, this will return true, otherwise false.
                  &lt;p&gt;
                  WARNING: This method is invoked from the native toolkit thread, be
                  very careful as to what methods this invokes!                
            </javadoc>
            <method name="show" type="boolean" line="943">
                <params>
                    <param name="c" type="Container"/>
                    <param name="x" type="int"/>
                    <param name="y" type="int"/>
                    <param name="w" type="int"/>
                    <param name="h" type="int"/>
                </params>
            </method>
            <javadoc line="946">
                Invoked when the doubleBuffered or useTrueDoubleBuffering
                  properties of a JRootPane change.  This may come in on any thread.                
            </javadoc>
            <method name="doubleBufferingChanged" type="void" line="950">
                <params>
                    <param name="rootPane" type="JRootPane"/>
                </params>
            </method>
            <javadoc line="953">
                Sets the &lt;code&gt;PaintManager&lt;/code&gt; that is used to handle all
                  double buffered painting.                
                <param>
                    paintManager The PaintManager to use.  Passing in null indicates
                      the fallback PaintManager should be used.                    
                </param>
            </javadoc>
            <method name="setPaintManager" type="void" line="959">
                <params>
                    <param name="paintManager" type="PaintManager"/>
                </params>
                <scope line="960"/>
                <declaration name="oldPaintManager" type="PaintManager" line="963"/>
                <scope line="964"/>
                <scope line="969"/>
            </method>
            <method name="getPaintManager" type="PaintManager" line="973">
                <scope line="974">
                    <declaration name="paintManager" type="PaintManager" line="975"/>
                    <scope line="976">
                        <declaration name="tk" type="Toolkit" line="979"/>
                        <scope line="980">
                            <declaration name="stk" type="SunToolkit" line="981"/>
                            <scope line="982"/>
                        </scope>
                    </scope>
                </scope>
            </method>
            <method name="scheduleProcessingRunnable" type="void" line="998"/>
            <method name="scheduleProcessingRunnable" type="void" line="1001">
                <params>
                    <param name="context" type="AppContext"/>
                </params>
                <scope line="1002">
                    <declaration name="tk" type="Toolkit" line="1003"/>
                    <scope line="1004"/>
                    <scope line="1007"/>
                </scope>
            </method>
            <class name="PaintManager" line="1012">
                <javadoc line="1012">
                    PaintManager is used to handle all double buffered painting for
                      Swing.  Subclasses should call back into the JComponent method
                      &lt;code&gt;paintToOffscreen&lt;/code&gt; to handle the actual painting.                    
                </javadoc>
                <declaration name="repaintManager" type="RepaintManager" line="1018"/>
                <javadoc line="1018">
                    RepaintManager the PaintManager has been installed on.                    
                </javadoc>
                <declaration name="isRepaintingRoot" type="boolean" line="1022"/>
                <javadoc line="1023">
                    Paints a region of a component                    
                    <param>
                        paintingComponent Component to paint                        
                    </param>
                    <param>
                        bufferComponent Component to obtain buffer for                        
                    </param>
                    <param>
                        g Graphics to paint to                        
                    </param>
                    <param>
                        x X-coordinate                        
                    </param>
                    <param>
                        y Y-coordinate                        
                    </param>
                    <param>
                        w Width                        
                    </param>
                    <param>
                        h Height                        
                    </param>
                    <return>
                        true if painting was successful.                        
                    </return>
                </javadoc>
                <method name="paint" type="boolean" line="1034">
                    <params>
                        <param name="paintingComponent" type="JComponent"/>
                        <param name="bufferComponent" type="JComponent"/>
                        <param name="g" type="Graphics"/>
                        <param name="x" type="int"/>
                        <param name="y" type="int"/>
                        <param name="w" type="int"/>
                        <param name="h" type="int"/>
                    </params>
                    <declaration name="paintCompleted" type="boolean" line="1035"/>
                    <declaration name="offscreen" type="Image" line="1036"/>
                    <scope line="1037">
                        <declaration name="vImage" type="VolatileImage" line="1038"/>
                        <declaration name="gc" type="GraphicsConfiguration" line="1039"/>
                        <scope line="1040">
                            <scope line="1041"/>
                        </scope>
                    </scope>
                    <scope line="1050"/>
                </method>
                <javadoc line="1056">
                    Does a copy area on the specified region.                    
                </javadoc>
                <method name="copyArea" type="void" line="1059">
                    <params>
                        <param name="c" type="JComponent"/>
                        <param name="g" type="Graphics"/>
                        <param name="x" type="int"/>
                        <param name="y" type="int"/>
                        <param name="w" type="int"/>
                        <param name="h" type="int"/>
                        <param name="deltaX" type="int"/>
                        <param name="deltaY" type="int"/>
                        <param name="clip" type="boolean"/>
                    </params>
                </method>
                <javadoc line="1062">
                    Invoked prior to any calls to paint or copyArea.                    
                </javadoc>
                <method name="beginPaint" type="void" line="1065"/>
                <javadoc line="1067">
                    Invoked to indicate painting has been completed.                    
                </javadoc>
                <method name="endPaint" type="void" line="1070"/>
                <javadoc line="1072">
                    Shows a region of a previously rendered component.  This
                      will return true if successful, false otherwise.  The default
                      implementation returns false.                    
                </javadoc>
                <method name="show" type="boolean" line="1077">
                    <params>
                        <param name="c" type="Container"/>
                        <param name="x" type="int"/>
                        <param name="y" type="int"/>
                        <param name="w" type="int"/>
                        <param name="h" type="int"/>
                    </params>
                </method>
                <javadoc line="1080">
                    Invoked when the doubleBuffered or useTrueDoubleBuffering
                      properties of a JRootPane change.  This may come in on any thread.                    
                </javadoc>
                <method name="doubleBufferingChanged" type="void" line="1084">
                    <params>
                        <param name="rootPane" type="JRootPane"/>
                    </params>
                </method>
                <javadoc line="1086">
                    Paints a portion of a component to an offscreen buffer.                    
                </javadoc>
                <method name="paintDoubleBuffered" type="void" line="1089">
                    <params>
                        <param name="c" type="JComponent"/>
                        <param name="image" type="Image"/>
                        <param name="g" type="Graphics"/>
                        <param name="clipX" type="int"/>
                        <param name="clipY" type="int"/>
                        <param name="clipW" type="int"/>
                        <param name="clipH" type="int"/>
                    </params>
                    <declaration name="osg" type="Graphics" line="1090"/>
                    <declaration name="bw" type="int" line="1091"/>
                    <declaration name="bh" type="int" line="1092"/>
                    <declaration name="x" type="int" line="1093"/>
                    <scope line="1094">
                        <scope line="1095">
                            <scope line="1096"/>
                        </scope>
                    </scope>
                    <scope line="1106"/>
                </method>
                <javadoc line="1110">
                    If &lt;code&gt;image&lt;/code&gt; is non-null with a positive size it
                      is returned, otherwise null is returned.                    
                </javadoc>
                <method name="getValidImage" type="Image" line="1114">
                    <params>
                        <param name="image" type="Image"/>
                    </params>
                    <scope line="1115"/>
                </method>
                <javadoc line="1120">
                    Schedules a repaint for the specified component.  This differs
                      from &lt;code&gt;root.repaint&lt;/code&gt; in that if the RepaintManager is
                      currently processing paint requests it&apos;ll process this request
                      with the current set of requests.                    
                </javadoc>
                <method name="repaintRoot" type="void" line="1126">
                    <params>
                        <param name="root" type="JComponent"/>
                    </params>
                    <scope line="1128"/>
                    <scope line="1131"/>
                </method>
                <javadoc line="1135">
                    Returns true if the component being painted is the root component
                      that was previously passed to &lt;code&gt;repaintRoot&lt;/code&gt;.                    
                </javadoc>
                <method name="isRepaintingRoot" type="boolean" line="1139"/>
                <javadoc line="1142">
                    Cleans up any state.  After invoked the PaintManager will no
                      longer be used anymore.                    
                </javadoc>
                <method name="dispose" type="void" line="1146"/>
            </class>
            <class name="DoubleBufferInfo" line="1149">
                <declaration name="image" type="Image" line="1150"/>
                <declaration name="size" type="Dimension" line="1151"/>
                <declaration name="needsReset" type="boolean" line="1152"/>
            </class>
            <class name="DisplayChangedHandler" line="1154">
                <implements interface="DisplayChangedListener"/>
                <javadoc line="1154">
                    Listener installed to detect display changes. When display changes,
                      schedules a callback to notify all RepaintManagers of the display
                      changes. Only one DisplayChangedHandler is ever installed. The
                      singleton instance will schedule notification for all AppContexts.                    
                </javadoc>
                <method name="displayChanged" type="void" line="1161"/>
                <method name="paletteChanged" type="void" line="1164"/>
                <method name="scheduleDisplayChanges" type="void" line="1166">
                    <scope line="1167">
                        <declaration name="context" type="AppContext" line="1168"/>
                        <scope line="1169">
                            <scope line="1170">
                                <declaration name="eventQueue" type="EventQueue" line="1171"/>
                                <scope line="1172"/>
                            </scope>
                        </scope>
                    </scope>
                </method>
            </class>
            <class name="DisplayChangedRunnable" line="1180">
                <implements interface="Runnable"/>
                <method name="run" type="void" line="1181"/>
            </class>
            <class name="ProcessingRunnable" line="1185">
                <implements interface="Runnable"/>
                <javadoc line="1185">
                    Runnable used to process all repaint/revalidate requests.                    
                </javadoc>
                <declaration name="pending" type="boolean" line="1189"/>
                <javadoc line="1190">
                    Marks this processing runnable as pending. If this was not
                      already marked as pending, true is returned.                    
                </javadoc>
                <method name="markPending" type="boolean" line="1194">
                    <scope line="1195"/>
                </method>
                <method name="run" type="void" line="1201">
                    <scope line="1202"/>
                </method>
            </class>
            <method name="getDelegate" type="RepaintManager" line="1210">
                <params>
                    <param name="c" type="Component"/>
                </params>
                <declaration name="delegate" type="RepaintManager" line="1211"/>
                <scope line="1212"/>
            </method>
        </class>
    </source>