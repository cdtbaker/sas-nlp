<?xml version="1.0" encoding="UTF-8"?>
    <source package="javax.swing">
        <import package="java.awt"/>
        <import package="java.awt.event"/>
        <import package="java.awt.peer.ComponentPeer"/>
        <import package="java.awt.peer.ContainerPeer"/>
        <import package="java.awt.image.VolatileImage"/>
        <import package="java.security.AccessController"/>
        <import package="java.util"/>
        <import package="java.applet"/>
        <import package="sun.awt.AWTAccessor"/>
        <import package="sun.awt.AppContext"/>
        <import package="sun.awt.DisplayChangedListener"/>
        <import package="sun.awt.SunToolkit"/>
        <import package="sun.java2d.SunGraphicsEnvironment"/>
        <import package="sun.security.action.GetPropertyAction"/>
        <import package="com.sun.java.swing.SwingUtilities3"/>
        <class name="RepaintManager" line="46">
            <comment line="80">
                                
            </comment>
            <comment line="81">
                As of 1.6 Swing handles scheduling of paint events from native code.                
            </comment>
            <comment line="82">
                That is, SwingPaintEventDispatcher is invoked on the toolkit thread,                
            </comment>
            <comment line="83">
                which in turn invokes nativeAddDirtyRegion.  Because this is invoked                
            </comment>
            <comment line="84">
                from the native thread we can not invoke any public methods and so                
            </comment>
            <comment line="85">
                we introduce these added maps.  So, any time nativeAddDirtyRegion is                
            </comment>
            <comment line="86">
                invoked the region is added to hwDirtyComponents and a work request                
            </comment>
            <comment line="87">
                is scheduled.  When the work request is processed all entries in                
            </comment>
            <comment line="88">
                this map are pushed to the real map (dirtyComponents) and then                
            </comment>
            <comment line="89">
                painted with the rest of the components.                
            </comment>
            <comment line="90">
                                
            </comment>
            <comment line="97">
                List of Runnables that need to be processed before painting from AWT.                
            </comment>
            <comment line="104">
                Support for both the standard and volatile offscreen buffers exists to                
            </comment>
            <comment line="105">
                provide backwards compatibility for the [rare] programs which may be                
            </comment>
            <comment line="106">
                calling getOffScreenBuffer() and not expecting to get a VolatileImage.                
            </comment>
            <comment line="107">
                Swing internally is migrating to use *only* the volatile image buffer.                
            </comment>
            <comment line="109">
                Support for standard offscreen buffer                
            </comment>
            <comment line="110">
                                
            </comment>
            <comment line="120">
                Whether or not a VolatileImage should be used for double-buffered painting                
            </comment>
            <comment line="127">
                The maximum number of times Swing will attempt to use the VolatileImage                
            </comment>
            <comment line="128">
                buffer during a paint operation.                
            </comment>
            <comment line="142">
                                
            </comment>
            <comment line="143">
                BufferStrategyPaintManager has the unique characteristic that it                
            </comment>
            <comment line="144">
                must deal with the buffer being lost while painting to it.  For                
            </comment>
            <comment line="145">
                example, if we paint a component and show it and the buffer has                
            </comment>
            <comment line="146">
                become lost we must repaint the whole window.  To deal with that                
            </comment>
            <comment line="147">
                the PaintManager calls into repaintRoot, and if we&apos;re still in                
            </comment>
            <comment line="148">
                the process of painting the repaintRoot field is set to the JRootPane                
            </comment>
            <comment line="149">
                and after the current JComponent.paintImmediately call finishes                
            </comment>
            <comment line="150">
                paintImmediately will be invoked on the repaintRoot.  In this                
            </comment>
            <comment line="151">
                way we don&apos;t try to show garbage to the screen.                
            </comment>
            <comment line="152">
                                
            </comment>
            <comment line="515">
                                
            </comment>
            <comment line="516">
                This is called from the toolkit thread when a native expose is                
            </comment>
            <comment line="517">
                received.                
            </comment>
            <comment line="518">
                                
            </comment>
            <comment line="536">
                                
            </comment>
            <comment line="537">
                This is called from the toolkit thread when awt needs to run a                
            </comment>
            <comment line="538">
                Runnable before we paint.                
            </comment>
            <comment line="539">
                                
            </comment>
            <comment line="1175">
                                
            </comment>
            <comment line="1176">
                Paint methods.  You very, VERY rarely need to invoke these.                
            </comment>
            <comment line="1177">
                They are invoked directly from JComponent&apos;s painting code and                
            </comment>
            <comment line="1178">
                when painting happens outside the normal flow: DefaultDesktopManager                
            </comment>
            <comment line="1179">
                and JViewport.  If you end up needing these methods in other places be                
            </comment>
            <comment line="1180">
                careful that you don&apos;t get stuck in a paint loop.                
            </comment>
            <comment line="1181">
                                
            </comment>
            <javadoc line="46">
                This class manages repaint requests, allowing the number
                  of repaints to be minimized, for example by collapsing multiple
                  requests into a single repaint for members of a component tree.
                  &lt;p&gt;
                  As of 1.6 &lt;code&gt;RepaintManager&lt;/code&gt; handles repaint requests
                  for Swing&apos;s top level components (&lt;code&gt;JApplet&lt;/code&gt;,
                  &lt;code&gt;JWindow&lt;/code&gt;, &lt;code&gt;JFrame&lt;/code&gt; and &lt;code&gt;JDialog&lt;/code&gt;).
                  Any calls to &lt;code&gt;repaint&lt;/code&gt; on one of these will call into the
                  appropriate &lt;code&gt;addDirtyRegion&lt;/code&gt; method.                
                <author>
                    Arnaud Weber                    
                </author>
            </javadoc>
            <declaration name="HANDLE_TOP_LEVEL_PAINT" type="boolean" line="61"/>
            <javadoc line="61">
                Whether or not the RepaintManager should handle paint requests
                  for top levels.                
            </javadoc>
            <declaration name="BUFFER_STRATEGY_NOT_SPECIFIED" type="short" line="67"/>
            <declaration name="BUFFER_STRATEGY_SPECIFIED_ON" type="short" line="68"/>
            <declaration name="BUFFER_STRATEGY_SPECIFIED_OFF" type="short" line="69"/>
            <declaration name="BUFFER_STRATEGY_TYPE" type="short" line="71"/>
            <declaration name="volatileMap" type="Map&lt;GraphicsConfiguration,VolatileImage&gt;" line="73"/>
            <javadoc line="73">
                Maps from GraphicsConfiguration to VolatileImage.                
            </javadoc>
            <declaration name="hwDirtyComponents" type="Map&lt;Container,Rectangle&gt;" line="90"/>
            <declaration name="dirtyComponents" type="Map&lt;Component,Rectangle&gt;" line="92"/>
            <declaration name="tmpDirtyComponents" type="Map&lt;Component,Rectangle&gt;" line="93"/>
            <declaration name="invalidComponents" type="java.util.List&lt;Component&gt;" line="94"/>
            <declaration name="runnableList" type="java.util.List&lt;Runnable&gt;" line="97"/>
            <declaration name="doubleBufferingEnabled" type="boolean" line="99"/>
            <declaration name="doubleBufferMaxSize" type="Dimension" line="101"/>
            <declaration name="standardDoubleBuffer" type="DoubleBufferInfo" line="110"/>
            <declaration name="paintManager" type="PaintManager" line="112"/>
            <javadoc line="112">
                Object responsible for hanlding core paint functionality.                
            </javadoc>
            <declaration name="repaintManagerKey" type="Object" line="117"/>
            <declaration name="volatileImageBufferEnabled" type="boolean" line="120"/>
            <declaration name="nativeDoubleBuffering" type="boolean" line="121"/>
            <javadoc line="121">
                Value of the system property awt.nativeDoubleBuffering.                
            </javadoc>
            <declaration name="VOLATILE_LOOP_MAX" type="int" line="128"/>
            <declaration name="paintDepth" type="int" line="130"/>
            <javadoc line="130">
                Number of &lt;code&gt;beginPaint&lt;/code&gt; that have been invoked.                
            </javadoc>
            <declaration name="bufferStrategyType" type="short" line="135"/>
            <javadoc line="135">
                Type of buffer strategy to use.  Will be one of the BUFFER_STRATEGY_
                  constants.                
            </javadoc>
            <declaration name="painting" type="boolean" line="152"/>
            <javadoc line="152">
                True if we&apos;re in the process of painting the dirty regions.  This is
                  set to true in &lt;code&gt;paintDirtyRegions&lt;/code&gt;.                
            </javadoc>
            <declaration name="repaintRoot" type="JComponent" line="157"/>
            <javadoc line="157">
                If the PaintManager calls into repaintRoot during painting this field
                  will be set to the root.                
            </javadoc>
            <declaration name="paintThread" type="Thread" line="163"/>
            <javadoc line="163">
                The Thread that has initiated painting.  If null it
                  indicates painting is not currently in progress.                
            </javadoc>
            <declaration name="processingRunnable" type="ProcessingRunnable" line="169"/>
            <javadoc line="169">
                Runnable used to process all repaint/revalidate requests.                
            </javadoc>
            <scope line="175">
                <declaration name="headless" type="boolean" line="179"/>
                <scope line="180"/>
                <declaration name="bs" type="String" line="185"/>
                <scope line="187"/>
                <scope line="190"/>
                <scope line="193"/>
                <scope line="196"/>
                <declaration name="ge" type="GraphicsEnvironment" line="201"/>
                <scope line="203"/>
            </scope>
            <javadoc line="209">
                Return the RepaintManager for the calling thread given a Component.                
                <param>
                    c a Component -- unused in the default implementation, but could
                      be used by an overridden version to return a different RepaintManager
                      depending on the Component                    
                </param>
                <return>
                    the RepaintManager object                    
                </return>
            </javadoc>
            <method name="currentManager" type="RepaintManager" line="217">
                <params>
                    <param name="c" type="Component"/>
                </params>
                <comment line="218">
                    Note: DisplayChangedRunnable passes in null as the component, so if                    
                </comment>
                <comment line="219">
                    component is ever used to determine the current                    
                </comment>
                <comment line="220">
                    RepaintManager, DisplayChangedRunnable will need to be modified                    
                </comment>
                <comment line="221">
                    accordingly.                    
                </comment>
            </method>
            <javadoc line="225">
                Returns the RepaintManager for the specified AppContext.  If
                  a RepaintManager has not been created for the specified
                  AppContext this will return null.                
            </javadoc>
            <method name="currentManager" type="RepaintManager" line="230">
                <params>
                    <param name="appContext" type="AppContext"/>
                </params>
                <declaration name="rm" type="RepaintManager" line="231"/>
                <scope line="232"/>
            </method>
            <javadoc line="239">
                Return the RepaintManager for the calling thread given a JComponent.
                  &lt;p&gt;
                  Note: This method exists for backward binary compatibility with earlier
                  versions of the Swing library. It simply returns the result returned by{@link #currentManager(Component)}.                
                <param>
                    c a JComponent -- unused                    
                </param>
                <return>
                    the RepaintManager object                    
                </return>
            </javadoc>
            <method name="currentManager" type="RepaintManager" line="249">
                <params>
                    <param name="c" type="JComponent"/>
                </params>
            </method>
            <javadoc line="254">
                Set the RepaintManager that should be used for the calling
                  thread. &lt;b&gt;aRepaintManager&lt;/b&gt; will become the current RepaintManager
                  for the calling thread&apos;s thread group.                
                <param>
                    aRepaintManager  the RepaintManager object to use                    
                </param>
            </javadoc>
            <method name="setCurrentManager" type="void" line="260">
                <params>
                    <param name="aRepaintManager" type="RepaintManager"/>
                </params>
                <scope line="261"/>
                <scope line="263"/>
            </method>
            <javadoc line="268">
                Create a new RepaintManager instance. You rarely call this constructor.
                  directly. To get the default RepaintManager, use
                  RepaintManager.currentManager(JComponent) (normally &quot;this&quot;).                
            </javadoc>
            <method name="RepaintManager" type="constructor" line="273">
                <comment line="274">
                    Because we can&apos;t know what a subclass is doing with the                    
                </comment>
                <comment line="275">
                    volatile image we immediately punt in subclasses.  If this                    
                </comment>
                <comment line="276">
                    poses a problem we&apos;ll need a more sophisticated detection algorithm,                    
                </comment>
                <comment line="277">
                    or API.                    
                </comment>
            </method>
            <method name="RepaintManager" type="constructor" line="281">
                <params>
                    <param name="bufferStrategyType" type="short"/>
                </params>
                <comment line="282">
                    If native doublebuffering is being used, do NOT use                    
                </comment>
                <comment line="283">
                    Swing doublebuffering.                    
                </comment>
                <scope line="285"/>
            </method>
            <method name="displayChanged" type="void" line="294"/>
            <javadoc line="298">
                Mark the component as in need of layout and queue a runnable
                  for the event dispatching thread that will validate the components
                  first isValidateRoot() ancestor.                
                <see>
                    JComponent#isValidateRoot                    
                </see>
                <see>
                    #removeInvalidComponent                    
                </see>
            </javadoc>
            <method name="addInvalidComponent" type="void" line="307">
                <params>
                    <param name="invalidComponent" type="JComponent"/>
                </params>
                <comment line="320">
                    Lazily create the invalidateComponents vector and add the
                     validateRoot if it&apos;s not there already.  If this validateRoot
                     is already in the vector, we&apos;re done.                    
                </comment>
                <comment line="337">
                    Queue a Runnable to invoke paintDirtyRegions and                    
                </comment>
                <comment line="338">
                    validateInvalidComponents.                    
                </comment>
                <declaration name="delegate" type="RepaintManager" line="308"/>
                <scope line="309"/>
                <declaration name="validateRoot" type="Component" line="313"/>
                <scope line="316"/>
                <scope line="324"/>
                <scope line="327">
                    <declaration name="n" type="int" line="328"/>
                    <scope line="329">
                        <scope line="330"/>
                    </scope>
                </scope>
            </method>
            <javadoc line="343">
                Remove a component from the list of invalid components.                
                <see>
                    #addInvalidComponent                    
                </see>
            </javadoc>
            <method name="removeInvalidComponent" type="void" line="348">
                <params>
                    <param name="component" type="JComponent"/>
                </params>
                <declaration name="delegate" type="RepaintManager" line="349"/>
                <scope line="350"/>
                <scope line="354">
                    <declaration name="index" type="int" line="355"/>
                    <scope line="356"/>
                </scope>
            </method>
            <javadoc line="363">
                Add a component in the list of components that should be refreshed.
                  If &lt;i&gt;c&lt;/i&gt; already has a dirty region, the rectangle &lt;i&gt;(x,y,w,h)&lt;/i&gt;
                  will be unioned with the region that should be redrawn.                
                <see>
                    JComponent#repaint                    
                </see>
            </javadoc>
            <method name="addDirtyRegion0" type="void" line="370">
                <params>
                    <param name="c" type="Container"/>
                    <param name="x" type="int"/>
                    <param name="y" type="int"/>
                    <param name="w" type="int"/>
                    <param name="h" type="int"/>
                </params>
                <comment line="371">
                    Special cases we don&apos;t have to bother with.                    
                </comment>
                <comment line="382">
                    Component was already marked as dirty, region has been                    
                </comment>
                <comment line="383">
                    extended, no need to continue.                    
                </comment>
                <comment line="387">
                    Make sure that c and all it ancestors (up to an Applet or
                     Window) are visible.  This loop has the same effect as
                     checking c.isShowing() (and note that it&apos;s still possible
                     that c is completely obscured by an opaque ancestor in
                     the specified rectangle).                    
                </comment>
                <comment line="395">
                    Note: We can&apos;t synchronize around this, Frame.getExtendedState                    
                </comment>
                <comment line="396">
                    is synchronized so that if we were to synchronize around this                    
                </comment>
                <comment line="397">
                    it could lead to the possibility of getting locks out                    
                </comment>
                <comment line="398">
                    of order and deadlocking.                    
                </comment>
                <comment line="404">
                    Iconified frames are still visible!                    
                </comment>
                <comment line="419">
                    In between last check and this check another thread                    
                </comment>
                <comment line="420">
                    queued up runnable, can bail here.                    
                </comment>
                <comment line="426">
                    Queue a Runnable to invoke paintDirtyRegions and                    
                </comment>
                <comment line="427">
                    validateInvalidComponents.                    
                </comment>
                <scope line="373"/>
                <scope line="377"/>
                <scope line="381"/>
                <declaration name="root" type="Component" line="393"/>
                <scope line="399">
                    <scope line="400"/>
                    <scope line="403">
                        <scope line="407"/>
                    </scope>
                </scope>
                <scope line="417">
                    <scope line="418"/>
                </scope>
            </method>
            <javadoc line="431">
                Add a component in the list of components that should be refreshed.
                  If &lt;i&gt;c&lt;/i&gt; already has a dirty region, the rectangle &lt;i&gt;(x,y,w,h)&lt;/i&gt;
                  will be unioned with the region that should be redrawn.                
                <param>
                    c Component to repaint, null results in nothing happening.                    
                </param>
                <param>
                    x X coordinate of the region to repaint                    
                </param>
                <param>
                    y Y coordinate of the region to repaint                    
                </param>
                <param>
                    w Width of the region to repaint                    
                </param>
                <param>
                    h Height of the region to repaint                    
                </param>
                <see>
                    JComponent#repaint                    
                </see>
            </javadoc>
            <method name="addDirtyRegion" type="void" line="444">
                <params>
                    <param name="c" type="JComponent"/>
                    <param name="x" type="int"/>
                    <param name="y" type="int"/>
                    <param name="w" type="int"/>
                    <param name="h" type="int"/>
                </params>
                <declaration name="delegate" type="RepaintManager" line="445"/>
                <scope line="446"/>
            </method>
            <javadoc line="453">
                Adds &lt;code&gt;window&lt;/code&gt; to the list of &lt;code&gt;Component&lt;/code&gt;s that
                  need to be repainted.                
                <param>
                    window Window to repaint, null results in nothing happening.                    
                </param>
                <param>
                    x X coordinate of the region to repaint                    
                </param>
                <param>
                    y Y coordinate of the region to repaint                    
                </param>
                <param>
                    w Width of the region to repaint                    
                </param>
                <param>
                    h Height of the region to repaint                    
                </param>
                <see>
                    JFrame#repaint                    
                </see>
                <see>
                    JWindow#repaint                    
                </see>
                <see>
                    JDialog#repaint                    
                </see>
                <since>
                    1.6                    
                </since>
            </javadoc>
            <method name="addDirtyRegion" type="void" line="467">
                <params>
                    <param name="window" type="Window"/>
                    <param name="x" type="int"/>
                    <param name="y" type="int"/>
                    <param name="w" type="int"/>
                    <param name="h" type="int"/>
                </params>
            </method>
            <javadoc line="471">
                Adds &lt;code&gt;applet&lt;/code&gt; to the list of &lt;code&gt;Component&lt;/code&gt;s that
                  need to be repainted.                
                <param>
                    applet Applet to repaint, null results in nothing happening.                    
                </param>
                <param>
                    x X coordinate of the region to repaint                    
                </param>
                <param>
                    y Y coordinate of the region to repaint                    
                </param>
                <param>
                    w Width of the region to repaint                    
                </param>
                <param>
                    h Height of the region to repaint                    
                </param>
                <see>
                    JApplet#repaint                    
                </see>
                <since>
                    1.6                    
                </since>
            </javadoc>
            <method name="addDirtyRegion" type="void" line="483">
                <params>
                    <param name="applet" type="Applet"/>
                    <param name="x" type="int"/>
                    <param name="y" type="int"/>
                    <param name="w" type="int"/>
                    <param name="h" type="int"/>
                </params>
            </method>
            <method name="scheduleHeavyWeightPaints" type="void" line="487">
                <comment line="507">
                    SwingHeavyWeight                    
                </comment>
                <declaration name="hws" type="Map&lt;Container,Rectangle&gt;" line="488"/>
                <scope line="490">
                    <scope line="491"/>
                </scope>
                <scope line="497">
                    <declaration name="dirty" type="Rectangle" line="498"/>
                    <scope line="499"/>
                    <scope line="503"/>
                    <scope line="507"/>
                </scope>
            </method>
            <method name="nativeAddDirtyRegion" type="void" line="519">
                <params>
                    <param name="appContext" type="AppContext"/>
                    <param name="c" type="Container"/>
                    <param name="x" type="int"/>
                    <param name="y" type="int"/>
                    <param name="w" type="int"/>
                    <param name="h" type="int"/>
                </params>
                <scope line="520">
                    <scope line="521">
                        <declaration name="dirty" type="Rectangle" line="522"/>
                        <scope line="523"/>
                        <scope line="526"/>
                    </scope>
                </scope>
            </method>
            <method name="nativeQueueSurfaceDataRunnable" type="void" line="540">
                <params>
                    <param name="appContext" type="AppContext"/>
                    <param name="c" type="Component"/>
                    <param name="r" type="Runnable"/>
                </params>
                <scope line="541">
                    <scope line="542"/>
                </scope>
            </method>
            <javadoc line="550">
                Extends the dirty region for the specified component to include
                  the new region.                
                <return>
                    false if <code>c</code> is not yet marked dirty.                    
                </return>
            </javadoc>
            <method name="extendDirtyRegion" type="boolean" line="557">
                <params>
                    <param name="c" type="Component"/>
                    <param name="x" type="int"/>
                    <param name="y" type="int"/>
                    <param name="w" type="int"/>
                    <param name="h" type="int"/>
                </params>
                <comment line="560">
                    A non-null r implies c is already marked as dirty,                    
                </comment>
                <comment line="561">
                    and that the parent is valid. Therefore we can                    
                </comment>
                <comment line="562">
                    just union the rect and bail.                    
                </comment>
                <declaration name="r" type="Rectangle" line="558"/>
                <scope line="559"/>
            </method>
            <javadoc line="569">
                Return the current dirty region for a component.
                  Return an empty rectangle if the component is not
                  dirty.                
            </javadoc>
            <method name="getDirtyRegion" type="Rectangle" line="573">
                <params>
                    <param name="aComponent" type="JComponent"/>
                </params>
                <declaration name="delegate" type="RepaintManager" line="574"/>
                <scope line="575"/>
                <declaration name="r" type="Rectangle" line="578"/>
                <scope line="579"/>
            </method>
            <javadoc line="588">
                Mark a component completely dirty. &lt;b&gt;aComponent&lt;/b&gt; will be
                  completely painted during the next paintDirtyRegions() call.                
            </javadoc>
            <method name="markCompletelyDirty" type="void" line="592">
                <params>
                    <param name="aComponent" type="JComponent"/>
                </params>
                <declaration name="delegate" type="RepaintManager" line="593"/>
                <scope line="594"/>
            </method>
            <javadoc line="601">
                Mark a component completely clean. &lt;b&gt;aComponent&lt;/b&gt; will not
                  get painted during the next paintDirtyRegions() call.                
            </javadoc>
            <method name="markCompletelyClean" type="void" line="605">
                <params>
                    <param name="aComponent" type="JComponent"/>
                </params>
                <declaration name="delegate" type="RepaintManager" line="606"/>
                <scope line="607"/>
                <scope line="611"/>
            </method>
            <javadoc line="616">
                Convenience method that returns true if &lt;b&gt;aComponent&lt;/b&gt; will be completely
                  painted during the next paintDirtyRegions(). If computing dirty regions is
                  expensive for your component, use this method and avoid computing dirty region
                  if it return true.                
            </javadoc>
            <method name="isCompletelyDirty" type="boolean" line="622">
                <params>
                    <param name="aComponent" type="JComponent"/>
                </params>
                <declaration name="delegate" type="RepaintManager" line="623"/>
                <scope line="624"/>
                <declaration name="r" type="Rectangle" line="627"/>
            </method>
            <javadoc line="638">
                Validate all of the components that have been marked invalid.                
                <see>
                    #addInvalidComponent                    
                </see>
            </javadoc>
            <method name="validateInvalidComponents" type="void" line="642">
                <declaration name="ic" type="java.util.List&lt;Component&gt;" line="643"/>
                <scope line="644">
                    <scope line="645"/>
                </scope>
                <declaration name="n" type="int" line="651"/>
                <scope line="652"/>
            </method>
            <javadoc line="658">
                This is invoked to process paint requests.  It&apos;s needed
                  for backward compatability in so far as RepaintManager would previously
                  not see paint requests for top levels, so, we have to make sure
                  a subclass correctly paints any dirty top levels.                
            </javadoc>
            <method name="prePaintDirtyRegions" type="void" line="664">
                <comment line="679">
                    This&apos;ll only happen if a subclass isn&apos;t correctly dealing                    
                </comment>
                <comment line="680">
                    with toplevels.                    
                </comment>
                <declaration name="dirtyComponents" type="Map&lt;Component,Rectangle&gt;" line="665"/>
                <declaration name="runnableList" type="java.util.List&lt;Runnable&gt;" line="666"/>
                <scope line="667"/>
                <scope line="672">
                    <scope line="673"/>
                </scope>
                <scope line="678"/>
            </method>
            <method name="updateWindows" type="void" line="685">
                <params>
                    <param name="dirtyComponents" type="Map<Component,Rectangle>"/>
                </params>
                <declaration name="toolkit" type="Toolkit" line="686"/>
                <scope line="689"/>
                <declaration name="windows" type="Set&lt;Window&gt;" line="693"/>
                <declaration name="dirtyComps" type="Set&lt;Component&gt;" line="694"/>
                <scope line="695">
                    <declaration name="dirty" type="Component" line="696"/>
                    <declaration name="window" type="Window" line="697"/>
                    <scope line="702"/>
                </scope>
                <scope line="707"/>
            </method>
            <method name="isPainting" type="boolean" line="712"/>
            <javadoc line="716">
                Paint all of the components that have been marked dirty.                
                <see>
                    #addDirtyRegion                    
                </see>
            </javadoc>
            <method name="paintDirtyRegions" type="void" line="721">
                <comment line="722">
                    swap for thread safety                    
                </comment>
                <scope line="722">
                    <declaration name="tmp" type="Map&lt;Component,Rectangle&gt;" line="723"/>
                </scope>
            </method>
            <method name="paintDirtyRegions" type="void" line="732">
                <params>
                    <param name="tmpDirtyComponents" type="Map<Component,Rectangle>"/>
                </params>
                <comment line="776">
                    If the Graphics goes away, it means someone disposed of                    
                </comment>
                <comment line="777">
                    the window, don&apos;t do anything.                    
                </comment>
                <comment line="787">
                    If the repaintRoot has been set, service it now and                    
                </comment>
                <comment line="788">
                    remove any components that are children of repaintRoot.                    
                </comment>
                <comment line="796">
                    Only service repaintRoot once.                    
                </comment>
                <declaration name="i" type="int" line="733"/>
                <declaration name="roots" type="java.util.List&lt;Component&gt;" line="734"/>
                <declaration name="dirtyComponent" type="Component" line="735"/>
                <scope line="738"/>
                <declaration name="rect" type="Rectangle" line="742"/>
                <declaration name="localBoundsX" type="int" line="743"/>
                <declaration name="localBoundsY" type="int" line="744"/>
                <declaration name="localBoundsH" type="int" line="745"/>
                <declaration name="localBoundsW" type="int" line="746"/>
                <declaration name="keys" type="Enumeration" line="747"/>
                <scope line="751"/>
                <scope line="757">
                    <scope line="758">
                        <scope line="769"/>
                        <scope line="773">
                            <declaration name="g" type="Graphics" line="774"/>
                            <scope line="778">
                                <scope line="780"/>
                                <scope line="782"/>
                            </scope>
                        </scope>
                        <scope line="789"/>
                    </scope>
                </scope>
                <scope line="800"/>
            </method>
            <javadoc line="810">
                Removes any components from roots that are children of
                  root.                
            </javadoc>
            <method name="adjustRoots" type="void" line="815">
                <params>
                    <param name="root" type="JComponent"/>
                    <param name="roots" type="java.util.List<Component>"/>
                    <param name="index" type="int"/>
                </params>
                <scope line="816">
                    <declaration name="c" type="Component" line="817"/>
                    <scope line="818">
                        <scope line="819"/>
                    </scope>
                    <scope line="824"/>
                </scope>
            </method>
            <declaration name="tmp" type="Rectangle" line="830"/>
            <method name="collectDirtyComponents" type="void" line="834">
                <params>
                    <param name="dirtyComponents" type="Map<Component,Rectangle>"/>
                    <param name="dirtyComponent" type="Component"/>
                    <param name="roots" type="java.util.List<Component>"/>
                </params>
                <comment line="839">
                    Find the highest parent which is dirty.  When we get out of this                    
                </comment>
                <comment line="840">
                    rootDx and rootDy will contain the translation from the                    
                </comment>
                <comment line="841">
                    rootDirtyComponent&apos;s coordinate system to the coordinates of the                    
                </comment>
                <comment line="842">
                    original dirty component.  The tmp Rect is also used to compute the                    
                </comment>
                <comment line="843">
                    visible portion of the dirtyRect.                    
                </comment>
                <comment line="856">
                    System.out.println(&quot;Collect dirty component for bound &quot; + tmp +                    
                </comment>
                <comment line="857">
                    &quot;component bounds is &quot; + cBounds);;                    
                </comment>
                <comment line="861">
                    System.out.println(&quot;Empty 1&quot;);                    
                </comment>
                <comment line="886">
                    System.out.println(&quot;Empty 2&quot;);                    
                </comment>
                <comment line="905">
                    If we haven&apos;t seen this root before, then we need to add it to the                    
                </comment>
                <comment line="906">
                    list of root dirty Views.                    
                </comment>
                <declaration name="dx" type="int" line="835"/>
                <declaration name="component" type="Component" line="836"/>
                <declaration name="cBounds" type="Rectangle" line="837"/>
                <declaration name="x" type="int" line="847"/>
                <declaration name="y" type="int" line="848"/>
                <declaration name="w" type="int" line="849"/>
                <declaration name="h" type="int" line="850"/>
                <scope line="860"/>
                <scope line="865">
                    <scope line="885"/>
                    <scope line="890"/>
                </scope>
                <scope line="897">
                    <declaration name="r" type="Rectangle" line="898"/>
                </scope>
            </method>
            <javadoc line="913">
                Returns a string that displays and identifies this
                  object&apos;s properties.                
                <return>
                    a String representation of this object                    
                </return>
            </javadoc>
            <method name="toString" type="String" line="919">
                <declaration name="sb" type="StringBuffer" line="920"/>
            </method>
            <javadoc line="927">
                Return the offscreen buffer that should be used as a double buffer with
                  the component &lt;code&gt;c&lt;/code&gt;.
                  By default there is a double buffer per RepaintManager.
                  The buffer might be smaller than &lt;code&gt;(proposedWidth,proposedHeight)&lt;/code&gt;
                  This happens when the maximum double buffer size as been set for the receiving
                  repaint manager.                
            </javadoc>
            <method name="getOffscreenBuffer" type="Image" line="935">
                <params>
                    <param name="c" type="Component"/>
                    <param name="proposedWidth" type="int"/>
                    <param name="proposedHeight" type="int"/>
                </params>
                <declaration name="delegate" type="RepaintManager" line="936"/>
                <scope line="937"/>
            </method>
            <javadoc line="943">
                Return a volatile offscreen buffer that should be used as a
                  double buffer with the specified component &lt;code&gt;c&lt;/code&gt;.
                  The image returned will be an instance of VolatileImage, or null
                  if a VolatileImage object could not be instantiated.
                  This buffer might be smaller than &lt;code&gt;(proposedWidth,proposedHeight)&lt;/code&gt;.
                  This happens when the maximum double buffer size has been set for this
                  repaint manager.                
                <see>
                    java.awt.image.VolatileImage                    
                </see>
                <since>
                    1.4                    
                </since>
            </javadoc>
            <method name="getVolatileOffscreenBuffer" type="Image" line="956">
                <params>
                    <param name="c" type="Component"/>
                    <param name="proposedWidth" type="int"/>
                    <param name="proposedHeight" type="int"/>
                </params>
                <comment line="963">
                    If the window is non-opaque, it&apos;s double-buffered at peer&apos;s level                    
                </comment>
                <declaration name="delegate" type="RepaintManager" line="957"/>
                <scope line="958"/>
                <declaration name="w" type="Window" line="964"/>
                <scope line="965">
                    <declaration name="tk" type="Toolkit" line="966"/>
                    <scope line="967"/>
                </scope>
                <declaration name="config" type="GraphicsConfiguration" line="972"/>
                <scope line="973"/>
                <declaration name="maxSize" type="Dimension" line="977"/>
                <declaration name="width" type="int" line="978"/>
                <declaration name="height" type="int" line="980"/>
                <declaration name="image" type="VolatileImage" line="982"/>
                <scope line="984">
                    <scope line="985"/>
                </scope>
            </method>
            <method name="_getOffscreenBuffer" type="Image" line="994">
                <params>
                    <param name="c" type="Component"/>
                    <param name="proposedWidth" type="int"/>
                    <param name="proposedHeight" type="int"/>
                </params>
                <comment line="999">
                    If the window is non-opaque, it&apos;s double-buffered at peer&apos;s level                    
                </comment>
                <comment line="1039">
                    JComponent will inform us when it is no longer valid                    
                </comment>
                <comment line="1040">
                    (via removeNotify) we have no such hook to other components,                    
                </comment>
                <comment line="1041">
                    therefore we don&apos;t keep a ref to the Component                    
                </comment>
                <comment line="1042">
                    (indirectly through the Image) by stashing the image.                    
                </comment>
                <declaration name="maxSize" type="Dimension" line="995"/>
                <declaration name="doubleBuffer" type="DoubleBufferInfo" line="996"/>
                <declaration name="width" type="int" line="997"/>
                <declaration name="w" type="Window" line="1000"/>
                <scope line="1001">
                    <declaration name="tk" type="Toolkit" line="1002"/>
                    <scope line="1003"/>
                </scope>
                <scope line="1008"/>
                <scope line="1020">
                    <scope line="1022"/>
                </scope>
                <declaration name="result" type="Image" line="1030"/>
                <scope line="1032">
                    <scope line="1035"/>
                </scope>
            </method>
            <javadoc line="1048">
                Set the maximum double buffer size.                
            </javadoc>
            <method name="setDoubleBufferMaximumSize" type="void" line="1049">
                <params>
                    <param name="d" type="Dimension"/>
                </params>
                <scope line="1051"/>
                <scope line="1053"/>
            </method>
            <method name="clearImages" type="void" line="1058"/>
            <method name="clearImages" type="void" line="1062">
                <params>
                    <param name="width" type="int"/>
                    <param name="height" type="int"/>
                </params>
                <comment line="1070">
                    Clear out the VolatileImages                    
                </comment>
                <scope line="1063">
                    <scope line="1065"/>
                </scope>
                <declaration name="gcs" type="Iterator" line="1071"/>
                <scope line="1072">
                    <declaration name="gc" type="GraphicsConfiguration" line="1073"/>
                    <declaration name="image" type="VolatileImage" line="1074"/>
                    <scope line="1075"/>
                </scope>
            </method>
            <javadoc line="1082">
                Returns the maximum double buffer size.                
                <return>
                    a Dimension object representing the maximum size                    
                </return>
            </javadoc>
            <method name="getDoubleBufferMaximumSize" type="Dimension" line="1087">
                <scope line="1088">
                    <scope line="1089">
                        <declaration name="virtualBounds" type="Rectangle" line="1090"/>
                        <declaration name="ge" type="GraphicsEnvironment" line="1091"/>
                        <scope line="1093">
                            <declaration name="gc" type="GraphicsConfiguration" line="1094"/>
                        </scope>
                    </scope>
                    <scope line="1099"/>
                </scope>
            </method>
            <javadoc line="1106">
                Enables or disables double buffering in this RepaintManager.
                  CAUTION: The default value for this property is set for optimal
                  paint performance on the given platform and it is not recommended
                  that programs modify this property directly.                
                <param>
                    aFlag  true to activate double buffering                    
                </param>
                <see>
                    #isDoubleBufferingEnabled                    
                </see>
            </javadoc>
            <method name="setDoubleBufferingEnabled" type="void" line="1115">
                <params>
                    <param name="aFlag" type="boolean"/>
                </params>
                <declaration name="paintManager" type="PaintManager" line="1117"/>
                <scope line="1118"/>
            </method>
            <javadoc line="1123">
                Returns true if this RepaintManager is double buffered.
                  The default value for this property may vary from platform
                  to platform.  On platforms where native double buffering
                  is supported in the AWT, the default value will be &lt;code&gt;false&lt;/code&gt;
                  to avoid unnecessary buffering in Swing.
                  On platforms where native double buffering is not supported,
                  the default value will be &lt;code&gt;true&lt;/code&gt;.                
                <return>
                    true if this object is double buffered                    
                </return>
            </javadoc>
            <method name="isDoubleBufferingEnabled" type="boolean" line="1134"/>
            <javadoc line="1138">
                This resets the double buffer. Actually, it marks the double buffer
                  as invalid, the double buffer will then be recreated on the next
                  invocation of getOffscreenBuffer.                
            </javadoc>
            <method name="resetDoubleBuffer" type="void" line="1143">
                <scope line="1144"/>
            </method>
            <javadoc line="1149">
                This resets the volatile double buffer.                
            </javadoc>
            <method name="resetVolatileDoubleBuffer" type="void" line="1152">
                <params>
                    <param name="gc" type="GraphicsConfiguration"/>
                </params>
                <declaration name="image" type="Image" line="1153"/>
                <scope line="1154"/>
            </method>
            <javadoc line="1159">
                Returns true if we should use the &lt;code&gt;Image&lt;/code&gt; returned
                  from &lt;code&gt;getVolatileOffscreenBuffer&lt;/code&gt; to do double buffering.                
            </javadoc>
            <method name="useVolatileDoubleBuffer" type="boolean" line="1163"/>
            <javadoc line="1167">
                Returns true if the current thread is the thread painting.  This
                  will return false if no threads are painting.                
            </javadoc>
            <method name="isPaintingThread" type="boolean" line="1171"/>
            <javadoc line="1182">
                Paints a region of a component                
                <param>
                    paintingComponent Component to paint                    
                </param>
                <param>
                    bufferComponent Component to obtain buffer for                    
                </param>
                <param>
                    g Graphics to paint to                    
                </param>
                <param>
                    x X-coordinate                    
                </param>
                <param>
                    y Y-coordinate                    
                </param>
                <param>
                    w Width                    
                </param>
                <param>
                    h Height                    
                </param>
            </javadoc>
            <method name="paint" type="void" line="1195">
                <params>
                    <param name="paintingComponent" type="JComponent"/>
                    <param name="bufferComponent" type="JComponent"/>
                    <param name="g" type="Graphics"/>
                    <param name="x" type="int"/>
                    <param name="y" type="int"/>
                    <param name="w" type="int"/>
                    <param name="h" type="int"/>
                </params>
                <comment line="1198">
                    We&apos;re painting to two threads at once.  PaintManager deals                    
                </comment>
                <comment line="1199">
                    with this a bit better than BufferStrategyPaintManager, use                    
                </comment>
                <comment line="1200">
                    it to avoid possible exceptions/corruption.                    
                </comment>
                <declaration name="paintManager" type="PaintManager" line="1196"/>
                <scope line="1197">
                    <scope line="1201"/>
                </scope>
                <scope line="1207"/>
            </method>
            <javadoc line="1213">
                Does a copy area on the specified region.                
                <param>
                    clip Whether or not the copyArea needs to be clipped to the
                      Component's bounds.                    
                </param>
            </javadoc>
            <method name="copyArea" type="void" line="1220">
                <params>
                    <param name="c" type="JComponent"/>
                    <param name="g" type="Graphics"/>
                    <param name="x" type="int"/>
                    <param name="y" type="int"/>
                    <param name="w" type="int"/>
                    <param name="h" type="int"/>
                    <param name="deltaX" type="int"/>
                    <param name="deltaY" type="int"/>
                    <param name="clip" type="boolean"/>
                </params>
            </method>
            <javadoc line="1224">
                Invoked prior to any paint/copyArea method calls.  This will
                  be followed by an invocation of &lt;code&gt;endPaint&lt;/code&gt;.
                  &lt;b&gt;WARNING&lt;/b&gt;: Callers of this method need to wrap the call
                  in a &lt;code&gt;try/finally&lt;/code&gt;, otherwise if an exception is thrown
                  during the course of painting the RepaintManager may
                  be left in a state in which the screen is not updated, eg:
                  &lt;pre&gt;
                  repaintManager.beginPaint();
                  try {
                  repaintManager.paint(...);
                  } finally {
                  repaintManager.endPaint();
                  }
                  &lt;/pre&gt;                
            </javadoc>
            <method name="beginPaint" type="void" line="1240">
                <declaration name="multiThreadedPaint" type="boolean" line="1241"/>
                <declaration name="paintDepth" type="int" line="1242"/>
                <declaration name="currentThread" type="Thread" line="1243"/>
                <scope line="1244">
                    <scope line="1246"/>
                    <scope line="1249"/>
                </scope>
                <scope line="1253"/>
            </method>
            <javadoc line="1258">
                Invoked after &lt;code&gt;beginPaint&lt;/code&gt; has been invoked.                
            </javadoc>
            <method name="endPaint" type="void" line="1261">
                <scope line="1262">
                    <declaration name="paintManager" type="PaintManager" line="1263"/>
                    <scope line="1264">
                        <scope line="1265"/>
                    </scope>
                    <scope line="1269">
                        <scope line="1271"/>
                    </scope>
                </scope>
            </method>
            <javadoc line="1278">
                If possible this will show a previously rendered portion of
                  a Component.  If successful, this will return true, otherwise false.
                  &lt;p&gt;
                  WARNING: This method is invoked from the native toolkit thread, be
                  very careful as to what methods this invokes!                
            </javadoc>
            <method name="show" type="boolean" line="1285">
                <params>
                    <param name="c" type="Container"/>
                    <param name="x" type="int"/>
                    <param name="y" type="int"/>
                    <param name="w" type="int"/>
                    <param name="h" type="int"/>
                </params>
            </method>
            <javadoc line="1289">
                Invoked when the doubleBuffered or useTrueDoubleBuffering
                  properties of a JRootPane change.  This may come in on any thread.                
            </javadoc>
            <method name="doubleBufferingChanged" type="void" line="1293">
                <params>
                    <param name="rootPane" type="JRootPane"/>
                </params>
            </method>
            <javadoc line="1297">
                Sets the &lt;code&gt;PaintManager&lt;/code&gt; that is used to handle all
                  double buffered painting.                
                <param>
                    paintManager The PaintManager to use.  Passing in null indicates
                      the fallback PaintManager should be used.                    
                </param>
            </javadoc>
            <method name="setPaintManager" type="void" line="1304">
                <params>
                    <param name="paintManager" type="PaintManager"/>
                </params>
                <scope line="1305"/>
                <declaration name="oldPaintManager" type="PaintManager" line="1308"/>
                <scope line="1309"/>
                <scope line="1314"/>
            </method>
            <method name="getPaintManager" type="PaintManager" line="1319">
                <comment line="1340">
                    null case handled in setPaintManager                    
                </comment>
                <scope line="1320">
                    <declaration name="paintManager" type="PaintManager" line="1321"/>
                    <scope line="1322">
                        <declaration name="tk" type="Toolkit" line="1325"/>
                        <scope line="1326">
                            <declaration name="stk" type="SunToolkit" line="1327"/>
                            <scope line="1328"/>
                        </scope>
                    </scope>
                </scope>
            </method>
            <method name="scheduleProcessingRunnable" type="void" line="1346"/>
            <method name="scheduleProcessingRunnable" type="void" line="1350">
                <params>
                    <param name="context" type="AppContext"/>
                </params>
                <scope line="1351">
                    <declaration name="tk" type="Toolkit" line="1352"/>
                    <scope line="1353"/>
                    <scope line="1357"/>
                </scope>
            </method>
            <class name="PaintManager" line="1366">
                <comment line="1593">
                    If true, we&apos;re wainting on the EventQueue.                    
                </comment>
                <javadoc line="1366">
                    PaintManager is used to handle all double buffered painting for
                      Swing.  Subclasses should call back into the JComponent method
                      &lt;code&gt;paintToOffscreen&lt;/code&gt; to handle the actual painting.                    
                </javadoc>
                <declaration name="repaintManager" type="RepaintManager" line="1372"/>
                <javadoc line="1372">
                    RepaintManager the PaintManager has been installed on.                    
                </javadoc>
                <declaration name="isRepaintingRoot" type="boolean" line="1376"/>
                <javadoc line="1378">
                    Paints a region of a component                    
                    <param>
                        paintingComponent Component to paint                        
                    </param>
                    <param>
                        bufferComponent Component to obtain buffer for                        
                    </param>
                    <param>
                        g Graphics to paint to                        
                    </param>
                    <param>
                        x X-coordinate                        
                    </param>
                    <param>
                        y Y-coordinate                        
                    </param>
                    <param>
                        w Width                        
                    </param>
                    <param>
                        h Height                        
                    </param>
                    <return>
                        true if painting was successful.                        
                    </return>
                </javadoc>
                <method name="paint" type="boolean" line="1392">
                    <params>
                        <param name="paintingComponent" type="JComponent"/>
                        <param name="bufferComponent" type="JComponent"/>
                        <param name="g" type="Graphics"/>
                        <param name="x" type="int"/>
                        <param name="y" type="int"/>
                        <param name="w" type="int"/>
                        <param name="h" type="int"/>
                    </params>
                    <comment line="1393">
                        First attempt to use VolatileImage buffer for performance.                        
                    </comment>
                    <comment line="1394">
                        If this fails (which should rarely occur), fallback to a                        
                    </comment>
                    <comment line="1395">
                        standard Image buffer.                        
                    </comment>
                    <comment line="1418">
                        VolatileImage painting loop failed, fallback to regular                        
                    </comment>
                    <comment line="1419">
                        offscreen buffer                        
                    </comment>
                    <declaration name="paintCompleted" type="boolean" line="1396"/>
                    <declaration name="offscreen" type="Image" line="1397"/>
                    <scope line="1400">
                        <declaration name="vImage" type="VolatileImage" line="1401"/>
                        <declaration name="gc" type="GraphicsConfiguration" line="1402"/>
                        <scope line="1405">
                            <scope line="1407"/>
                        </scope>
                    </scope>
                    <scope line="1422"/>
                </method>
                <javadoc line="1430">
                    Does a copy area on the specified region.                    
                </javadoc>
                <method name="copyArea" type="void" line="1434">
                    <params>
                        <param name="c" type="JComponent"/>
                        <param name="g" type="Graphics"/>
                        <param name="x" type="int"/>
                        <param name="y" type="int"/>
                        <param name="w" type="int"/>
                        <param name="h" type="int"/>
                        <param name="deltaX" type="int"/>
                        <param name="deltaY" type="int"/>
                        <param name="clip" type="boolean"/>
                    </params>
                </method>
                <javadoc line="1438">
                    Invoked prior to any calls to paint or copyArea.                    
                </javadoc>
                <method name="beginPaint" type="void" line="1441"/>
                <javadoc line="1444">
                    Invoked to indicate painting has been completed.                    
                </javadoc>
                <method name="endPaint" type="void" line="1447"/>
                <javadoc line="1450">
                    Shows a region of a previously rendered component.  This
                      will return true if successful, false otherwise.  The default
                      implementation returns false.                    
                </javadoc>
                <method name="show" type="boolean" line="1455">
                    <params>
                        <param name="c" type="Container"/>
                        <param name="x" type="int"/>
                        <param name="y" type="int"/>
                        <param name="w" type="int"/>
                        <param name="h" type="int"/>
                    </params>
                </method>
                <javadoc line="1459">
                    Invoked when the doubleBuffered or useTrueDoubleBuffering
                      properties of a JRootPane change.  This may come in on any thread.                    
                </javadoc>
                <method name="doubleBufferingChanged" type="void" line="1463">
                    <params>
                        <param name="rootPane" type="JRootPane"/>
                    </params>
                </method>
                <javadoc line="1466">
                    Paints a portion of a component to an offscreen buffer.                    
                </javadoc>
                <method name="paintDoubleBuffered" type="void" line="1471">
                    <params>
                        <param name="c" type="JComponent"/>
                        <param name="image" type="Image"/>
                        <param name="g" type="Graphics"/>
                        <param name="clipX" type="int"/>
                        <param name="clipY" type="int"/>
                        <param name="clipW" type="int"/>
                        <param name="clipH" type="int"/>
                    </params>
                    <declaration name="osg" type="Graphics" line="1472"/>
                    <declaration name="bw" type="int" line="1473"/>
                    <declaration name="bh" type="int" line="1474"/>
                    <declaration name="x" type="int" line="1475"/>
                    <scope line="1477">
                        <scope line="1478">
                            <scope line="1479"/>
                        </scope>
                    </scope>
                    <scope line="1488"/>
                </method>
                <javadoc line="1493">
                    If &lt;code&gt;image&lt;/code&gt; is non-null with a positive size it
                      is returned, otherwise null is returned.                    
                </javadoc>
                <method name="getValidImage" type="Image" line="1497">
                    <params>
                        <param name="image" type="Image"/>
                    </params>
                    <scope line="1499"/>
                </method>
                <javadoc line="1505">
                    Schedules a repaint for the specified component.  This differs
                      from &lt;code&gt;root.repaint&lt;/code&gt; in that if the RepaintManager is
                      currently processing paint requests it&apos;ll process this request
                      with the current set of requests.                    
                </javadoc>
                <method name="repaintRoot" type="void" line="1511">
                    <params>
                        <param name="root" type="JComponent"/>
                    </params>
                    <scope line="1513"/>
                    <scope line="1516"/>
                </method>
                <javadoc line="1521">
                    Returns true if the component being painted is the root component
                      that was previously passed to &lt;code&gt;repaintRoot&lt;/code&gt;.                    
                </javadoc>
                <method name="isRepaintingRoot" type="boolean" line="1525"/>
                <javadoc line="1529">
                    Cleans up any state.  After invoked the PaintManager will no
                      longer be used anymore.                    
                </javadoc>
                <method name="dispose" type="void" line="1533"/>
            </class>
            <class name="DoubleBufferInfo" line="1538">
                <comment line="1593">
                    If true, we&apos;re wainting on the EventQueue.                    
                </comment>
                <declaration name="image" type="Image" line="1539"/>
                <declaration name="size" type="Dimension" line="1540"/>
                <declaration name="needsReset" type="boolean" line="1541"/>
            </class>
            <class name="DisplayChangedHandler" line="1545">
                <comment line="1593">
                    If true, we&apos;re wainting on the EventQueue.                    
                </comment>
                <implements interface="DisplayChangedListener"/>
                <javadoc line="1545">
                    Listener installed to detect display changes. When display changes,
                      schedules a callback to notify all RepaintManagers of the display
                      changes. Only one DisplayChangedHandler is ever installed. The
                      singleton instance will schedule notification for all AppContexts.                    
                </javadoc>
                <method name="displayChanged" type="void" line="1553"/>
                <method name="paletteChanged" type="void" line="1557"/>
                <method name="scheduleDisplayChanges" type="void" line="1560">
                    <comment line="1561">
                        To avoid threading problems, we notify each RepaintManager                        
                    </comment>
                    <comment line="1562">
                        on the thread it was created on.                        
                    </comment>
                    <scope line="1563">
                        <declaration name="context" type="AppContext" line="1564"/>
                        <scope line="1565">
                            <scope line="1566">
                                <declaration name="eventQueue" type="EventQueue" line="1567"/>
                                <scope line="1569"/>
                            </scope>
                        </scope>
                    </scope>
                </method>
            </class>
            <class name="DisplayChangedRunnable" line="1581">
                <comment line="1593">
                    If true, we&apos;re wainting on the EventQueue.                    
                </comment>
                <implements interface="Runnable"/>
                <method name="run" type="void" line="1582"/>
            </class>
            <class name="ProcessingRunnable" line="1588">
                <comment line="1593">
                    If true, we&apos;re wainting on the EventQueue.                    
                </comment>
                <implements interface="Runnable"/>
                <javadoc line="1588">
                    Runnable used to process all repaint/revalidate requests.                    
                </javadoc>
                <declaration name="pending" type="boolean" line="1593"/>
                <javadoc line="1595">
                    Marks this processing runnable as pending. If this was not
                      already marked as pending, true is returned.                    
                </javadoc>
                <method name="markPending" type="boolean" line="1599">
                    <scope line="1600"/>
                </method>
                <method name="run" type="void" line="1607">
                    <comment line="1611">
                        First pass, flush any heavy paint events into real paint                        
                    </comment>
                    <comment line="1612">
                        events.  If there are pending heavy weight requests this will                        
                    </comment>
                    <comment line="1613">
                        result in q&apos;ing this request up one more time.  As                        
                    </comment>
                    <comment line="1614">
                        long as no other requests come in between now and the time                        
                    </comment>
                    <comment line="1615">
                        the second one is processed nothing will happen.  This is not                        
                    </comment>
                    <comment line="1616">
                        ideal, but the logic needed to suppress the second request is                        
                    </comment>
                    <comment line="1617">
                        more headache than it&apos;s worth.                        
                    </comment>
                    <comment line="1619">
                        Do the actual validation and painting.                        
                    </comment>
                    <scope line="1608"/>
                </method>
            </class>
            <method name="getDelegate" type="RepaintManager" line="1624">
                <params>
                    <param name="c" type="Component"/>
                </params>
                <declaration name="delegate" type="RepaintManager" line="1625"/>
                <scope line="1626"/>
            </method>
        </class>
    </source>