<?xml version="1.0" encoding="UTF-8"?>
    <source package="javax.swing">
        <import package="sun.swing.SwingUtilities2"/>
        <import package="sun.swing.UIAction"/>
        <import package="java.applet"/>
        <import package="java.awt"/>
        <import package="java.awt.event"/>
        <import package="java.awt.dnd.DropTarget"/>
        <import package="java.util.Vector"/>
        <import package="java.util.Hashtable"/>
        <import package="java.lang.reflect"/>
        <import package="javax.accessibility"/>
        <import package="javax.swing.event.MenuDragMouseEvent"/>
        <import package="javax.swing.plaf.UIResource"/>
        <import package="javax.swing.text.View"/>
        <import package="java.security.AccessController"/>
        <import package="sun.security.action.GetPropertyAction"/>
        <import package="sun.awt.AppContext"/>
        <class name="SwingUtilities" line="50">
            <comment line="58">
                These states are system-wide, rather than AppContext wide.                
            </comment>
            <comment line="1196">
                Ensures that cell renderer &lt;code&gt;c&lt;code&gt; has a
                 &lt;code&gt;ComponentShell&lt;code&gt; parent and that
                 the shell&apos;s parent is p.                
            </comment>
            <comment line="1364">
                --- Accessibility Support ---                
            </comment>
            <comment line="1753">
                Don&apos;t use String, as it&apos;s not guaranteed to be unique in a Hashtable.                
            </comment>
            <comment line="1851">
                Don&apos;t make these AppContext accessors public or protected --
                 since AppContext is in sun.awt in 1.2, we shouldn&apos;t expose it
                 even indirectly with a public API.                
            </comment>
            <comment line="1855">
                REMIND(aim): phase out use of 4 methods below since they
                 are just private covers for AWT methods (?)                
            </comment>
            <comment line="1877">
                Convenience function for determining ComponentOrientation.  Helps us
                 avoid having Munge directives throughout the code.                
            </comment>
            <implements interface="SwingConstants"/>
            <javadoc line="50">
                A collection of utility methods for Swing.                
                <author>
                    unknown                    
                </author>
            </javadoc>
            <declaration name="canAccessEventQueue" type="boolean" line="58"/>
            <declaration name="eventQueueTested" type="boolean" line="59"/>
            <declaration name="suppressDropSupport" type="boolean" line="61"/>
            <javadoc line="61">
                Indicates if we should change the drop target when a{@code TransferHandler} is set.                
            </javadoc>
            <declaration name="checkedSuppressDropSupport" type="boolean" line="67"/>
            <javadoc line="67">
                Indiciates if we&apos;ve checked the system property for suppressing
                  drop support.                
            </javadoc>
            <javadoc line="74">
                Returns true if &lt;code&gt;setTransferHandler&lt;/code&gt; should change the
                  &lt;code&gt;DropTarget&lt;/code&gt;.                
            </javadoc>
            <method name="getSuppressDropTarget" type="boolean" line="78">
                <scope line="79"/>
            </method>
            <javadoc line="88">
                Installs a {@code DropTarget} on the component as necessary for a{@code TransferHandler} change.                
            </javadoc>
            <method name="installSwingDropTargetAsNecessary" type="void" line="93">
                <params>
                    <param name="c" type="Component"/>
                    <param name="t" type="TransferHandler"/>
                </params>
                <scope line="95">
                    <declaration name="dropHandler" type="DropTarget" line="96"/>
                    <scope line="97">
                        <scope line="98"/>
                        <scope line="100"/>
                    </scope>
                </scope>
            </method>
            <javadoc line="107">
                Return true if &lt;code&gt;a&lt;/code&gt; contains &lt;code&gt;b&lt;/code&gt;                
            </javadoc>
            <method name="isRectangleContainingRectangle" type="boolean" line="110">
                <params>
                    <param name="a" type="Rectangle"/>
                    <param name="b" type="Rectangle"/>
                </params>
            </method>
            <javadoc line="115">
                Return the rectangle (0,0,bounds.width,bounds.height) for the component &lt;code&gt;aComponent&lt;/code&gt;                
            </javadoc>
            <method name="getLocalBounds" type="Rectangle" line="118">
                <params>
                    <param name="aComponent" type="Component"/>
                </params>
                <declaration name="b" type="Rectangle" line="119"/>
            </method>
            <javadoc line="125">
                Returns the first &lt;code&gt;Window &lt;/code&gt; ancestor of &lt;code&gt;c&lt;/code&gt;, or{@code null} if &lt;code&gt;c&lt;/code&gt; is not contained inside a &lt;code&gt;Window&lt;/code&gt;.                
                <param>
                    c &lt;code&gt;Component&lt;/code&gt; to get &lt;code&gt;Window&lt;/code&gt; ancestor
                      of.                    
                </param>
                <return>
                    the first &lt;code&gt;Window &lt;/code&gt; ancestor of &lt;code&gt;c&lt;/code&gt;, or{@code null} if &lt;code&gt;c&lt;/code&gt; is not contained inside a
                      &lt;code&gt;Window&lt;/code&gt;.                    
                </return>
                <since>
                    1.3                    
                </since>
            </javadoc>
            <method name="getWindowAncestor" type="Window" line="136">
                <params>
                    <param name="c" type="Component"/>
                </params>
                <scope line="137">
                    <scope line="138"/>
                </scope>
            </method>
            <javadoc line="145">
                Converts the location &lt;code&gt;x&lt;/code&gt; &lt;code&gt;y&lt;/code&gt; to the
                  parents coordinate system, returning the location.                
            </javadoc>
            <method name="convertScreenLocationToParent" type="Point" line="149">
                <params>
                    <param name="parent" type="Container"/>
                    <param name="x" type="int"/>
                    <param name="y" type="int"/>
                </params>
                <scope line="150">
                    <scope line="151">
                        <declaration name="point" type="Point" line="152"/>
                    </scope>
                </scope>
            </method>
            <javadoc line="161">
                Convert a &lt;code&gt;aPoint&lt;/code&gt; in &lt;code&gt;source&lt;/code&gt; coordinate system to
                  &lt;code&gt;destination&lt;/code&gt; coordinate system.
                  If &lt;code&gt;source&lt;/code&gt; is {@code null}, &lt;code&gt;aPoint&lt;/code&gt; is assumed to be in &lt;code&gt;destination&lt;/code&gt;&apos;s
                  root component coordinate system.
                  If &lt;code&gt;destination&lt;/code&gt; is {@code null}, &lt;code&gt;aPoint&lt;/code&gt; will be converted to &lt;code&gt;source&lt;/code&gt;&apos;s
                  root component coordinate system.
                  If both &lt;code&gt;source&lt;/code&gt; and &lt;code&gt;destination&lt;/code&gt; are {@code null}, return &lt;code&gt;aPoint&lt;/code&gt;
                  without any conversion.                
            </javadoc>
            <method name="convertPoint" type="Point" line="171">
                <params>
                    <param name="source" type="Component"/>
                    <param name="aPoint" type="Point"/>
                    <param name="destination" type="Component"/>
                </params>
                <declaration name="p" type="Point" line="172"/>
                <scope line="176"/>
                <scope line="183"/>
            </method>
            <javadoc line="192">
                Convert the point &lt;code&gt;(x,y)&lt;/code&gt; in &lt;code&gt;source&lt;/code&gt; coordinate system to
                  &lt;code&gt;destination&lt;/code&gt; coordinate system.
                  If &lt;code&gt;source&lt;/code&gt; is {@code null}, &lt;code&gt;(x,y)&lt;/code&gt; is assumed to be in &lt;code&gt;destination&lt;/code&gt;&apos;s
                  root component coordinate system.
                  If &lt;code&gt;destination&lt;/code&gt; is {@code null}, &lt;code&gt;(x,y)&lt;/code&gt; will be converted to &lt;code&gt;source&lt;/code&gt;&apos;s
                  root component coordinate system.
                  If both &lt;code&gt;source&lt;/code&gt; and &lt;code&gt;destination&lt;/code&gt; are {@code null}, return &lt;code&gt;(x,y)&lt;/code&gt;
                  without any conversion.                
            </javadoc>
            <method name="convertPoint" type="Point" line="202">
                <params>
                    <param name="source" type="Component"/>
                    <param name="x" type="int"/>
                    <param name="y" type="int"/>
                    <param name="destination" type="Component"/>
                </params>
                <declaration name="point" type="Point" line="203"/>
            </method>
            <javadoc line="207">
                Convert the rectangle &lt;code&gt;aRectangle&lt;/code&gt; in &lt;code&gt;source&lt;/code&gt; coordinate system to
                  &lt;code&gt;destination&lt;/code&gt; coordinate system.
                  If &lt;code&gt;source&lt;/code&gt; is {@code null}, &lt;code&gt;aRectangle&lt;/code&gt; is assumed to be in &lt;code&gt;destination&lt;/code&gt;&apos;s
                  root component coordinate system.
                  If &lt;code&gt;destination&lt;/code&gt; is {@code null}, &lt;code&gt;aRectangle&lt;/code&gt; will be converted to &lt;code&gt;source&lt;/code&gt;&apos;s
                  root component coordinate system.
                  If both &lt;code&gt;source&lt;/code&gt; and &lt;code&gt;destination&lt;/code&gt; are {@code null}, return &lt;code&gt;aRectangle&lt;/code&gt;
                  without any conversion.                
            </javadoc>
            <method name="convertRectangle" type="Rectangle" line="217">
                <params>
                    <param name="source" type="Component"/>
                    <param name="aRectangle" type="Rectangle"/>
                    <param name="destination" type="Component"/>
                </params>
                <declaration name="point" type="Point" line="218"/>
            </method>
            <javadoc line="223">
                Convenience method for searching above &lt;code&gt;comp&lt;/code&gt; in the
                  component hierarchy and returns the first object of class &lt;code&gt;c&lt;/code&gt; it
                  finds. Can return {@code null}, if a class &lt;code&gt;c&lt;/code&gt; cannot be found.                
            </javadoc>
            <method name="getAncestorOfClass" type="Container" line="229">
                <params>
                    <param name="c" type="Class<?>"/>
                    <param name="comp" type="Component"/>
                </params>
                <declaration name="parent" type="Container" line="233"/>
            </method>
            <javadoc line="239">
                Convenience method for searching above &lt;code&gt;comp&lt;/code&gt; in the
                  component hierarchy and returns the first object of &lt;code&gt;name&lt;/code&gt; it
                  finds. Can return {@code null}, if &lt;code&gt;name&lt;/code&gt; cannot be found.                
            </javadoc>
            <method name="getAncestorNamed" type="Container" line="244">
                <params>
                    <param name="name" type="String"/>
                    <param name="comp" type="Component"/>
                </params>
                <declaration name="parent" type="Container" line="248"/>
            </method>
            <javadoc line="254">
                Returns the deepest visible descendent Component of &lt;code&gt;parent&lt;/code&gt;
                  that contains the location &lt;code&gt;x&lt;/code&gt;, &lt;code&gt;y&lt;/code&gt;.
                  If &lt;code&gt;parent&lt;/code&gt; does not contain the specified location,
                  then &lt;code&gt;null&lt;/code&gt; is returned.  If &lt;code&gt;parent&lt;/code&gt; is not a
                  container, or none of &lt;code&gt;parent&lt;/code&gt;&apos;s visible descendents
                  contain the specified location, &lt;code&gt;parent&lt;/code&gt; is returned.                
                <param>
                    parent the root component to begin the search                    
                </param>
                <param>
                    x the x target location                    
                </param>
                <param>
                    y the y target location                    
                </param>
            </javadoc>
            <method name="getDeepestComponentAt" type="Component" line="266">
                <params>
                    <param name="parent" type="Component"/>
                    <param name="x" type="int"/>
                    <param name="y" type="int"/>
                </params>
                <scope line="267"/>
                <scope line="270">
                    <declaration name="components" type="Component" line="271"/>
                    <scope line="272">
                        <scope line="273">
                            <declaration name="loc" type="Point" line="274"/>
                            <scope line="275"/>
                            <scope line="277"/>
                            <scope line="280"/>
                        </scope>
                    </scope>
                </scope>
            </method>
            <javadoc line="290">
                Returns a MouseEvent similar to &lt;code&gt;sourceEvent&lt;/code&gt; except that its x
                  and y members have been converted to &lt;code&gt;destination&lt;/code&gt;&apos;s coordinate
                  system.  If &lt;code&gt;source&lt;/code&gt; is {@code null}, &lt;code&gt;sourceEvent&lt;/code&gt; x and y members
                  are assumed to be into &lt;code&gt;destination&lt;/code&gt;&apos;s root component coordinate system.
                  If &lt;code&gt;destination&lt;/code&gt; is &lt;code&gt;null&lt;/code&gt;, the
                  returned MouseEvent will be in &lt;code&gt;source&lt;/code&gt;&apos;s coordinate system.
                  &lt;code&gt;sourceEvent&lt;/code&gt; will not be changed. A new event is returned.
                  the &lt;code&gt;source&lt;/code&gt; field of the returned event will be set
                  to &lt;code&gt;destination&lt;/code&gt; if destination is non-{@code null}use the translateMouseEvent() method to translate a mouse event from
                  one component to another without changing the source.                
            </javadoc>
            <method name="convertMouseEvent" type="MouseEvent" line="305">
                <params>
                    <param name="source" type="Component"/>
                    <param name="sourceEvent" type="MouseEvent"/>
                    <param name="destination" type="Component"/>
                </params>
                <declaration name="p" type="Point" line="306"/>
                <declaration name="newSource" type="Component" line="309"/>
                <declaration name="newEvent" type="MouseEvent" line="316"/>
                <scope line="317">
                    <declaration name="sourceWheelEvent" type="MouseWheelEvent" line="318"/>
                </scope>
                <scope line="332">
                    <declaration name="sourceMenuDragEvent" type="MenuDragMouseEvent" line="333"/>
                </scope>
                <scope line="346"/>
            </method>
            <javadoc line="362">
                Convert a point from a component&apos;s coordinate system to
                  screen coordinates.                
                <param>
                    p  a Point object (converted to the new coordinate system)                    
                </param>
                <param>
                    c  a Component object                    
                </param>
            </javadoc>
            <method name="convertPointToScreen" type="void" line="369">
                <params>
                    <param name="p" type="Point"/>
                    <param name="c" type="Component"/>
                </params>
                <declaration name="b" type="Rectangle" line="370"/>
                <declaration name="x" type="int" line="371"/>
                <scope line="373">
                    <scope line="374"/>
                    <scope line="378">
                        <scope line="379">
                            <declaration name="pp" type="Point" line="380"/>
                        </scope>
                        <scope line="383"/>
                    </scope>
                    <scope line="387"/>
                </scope>
            </method>
            <javadoc line="401">
                Convert a point from a screen coordinates to a component&apos;s
                  coordinate system                
                <param>
                    p  a Point object (converted to the new coordinate system)                    
                </param>
                <param>
                    c  a Component object                    
                </param>
            </javadoc>
            <method name="convertPointFromScreen" type="void" line="408">
                <params>
                    <param name="p" type="Point"/>
                    <param name="c" type="Component"/>
                </params>
                <declaration name="b" type="Rectangle" line="409"/>
                <declaration name="x" type="int" line="410"/>
                <scope line="412">
                    <scope line="413"/>
                    <scope line="417">
                        <scope line="418">
                            <declaration name="pp" type="Point" line="419"/>
                        </scope>
                        <scope line="422"/>
                    </scope>
                    <scope line="426"/>
                </scope>
            </method>
            <javadoc line="440">
                Returns the first &lt;code&gt;Window &lt;/code&gt; ancestor of &lt;code&gt;c&lt;/code&gt;, or{@code null} if &lt;code&gt;c&lt;/code&gt; is not contained inside a &lt;code&gt;Window&lt;/code&gt;.
                  &lt;p&gt;
                  Note: This method provides the same functionality as
                  &lt;code&gt;getWindowAncestor&lt;/code&gt;.                
                <param>
                    c &lt;code&gt;Component&lt;/code&gt; to get &lt;code&gt;Window&lt;/code&gt; ancestor
                      of.                    
                </param>
                <return>
                    the first &lt;code&gt;Window &lt;/code&gt; ancestor of &lt;code&gt;c&lt;/code&gt;, or{@code null} if &lt;code&gt;c&lt;/code&gt; is not contained inside a
                      &lt;code&gt;Window&lt;/code&gt;.                    
                </return>
            </javadoc>
            <method name="windowForComponent" type="Window" line="453">
                <params>
                    <param name="c" type="Component"/>
                </params>
            </method>
            <javadoc line="457">
                Return &lt;code&gt;true&lt;/code&gt; if a component &lt;code&gt;a&lt;/code&gt; descends from a component &lt;code&gt;b&lt;/code&gt;                
            </javadoc>
            <method name="isDescendingFrom" type="boolean" line="460">
                <params>
                    <param name="a" type="Component"/>
                    <param name="b" type="Component"/>
                </params>
            </method>
            <javadoc line="470">
                Convenience to calculate the intersection of two rectangles
                  without allocating a new rectangle.
                  If the two rectangles don&apos;t intersect,
                  then the returned rectangle begins at (0,0)
                  and has zero width and height.                
                <param>
                    x       the X coordinate of the first rectangle&apos;s top-left point                    
                </param>
                <param>
                    y       the Y coordinate of the first rectangle&apos;s top-left point                    
                </param>
                <param>
                    width   the width of the first rectangle                    
                </param>
                <param>
                    height  the height of the first rectangle                    
                </param>
                <param>
                    dest    the second rectangle                    
                </param>
                <return>
                    &lt;code&gt;dest&lt;/code&gt;, modified to specify the intersection                    
                </return>
            </javadoc>
            <method name="computeIntersection" type="Rectangle" line="485">
                <params>
                    <param name="x" type="int"/>
                    <param name="y" type="int"/>
                    <param name="width" type="int"/>
                    <param name="height" type="int"/>
                    <param name="dest" type="Rectangle"/>
                </params>
                <comment line="497">
                    If rectangles don&apos;t intersect, return zero&apos;d intersection.                    
                </comment>
                <declaration name="x1" type="int" line="486"/>
                <declaration name="x2" type="int" line="487"/>
                <declaration name="y1" type="int" line="488"/>
                <declaration name="y2" type="int" line="489"/>
                <scope line="497"/>
            </method>
            <javadoc line="504">
                Convenience method that calculates the union of two rectangles
                  without allocating a new rectangle.                
                <param>
                    x the x-coordinate of the first rectangle                    
                </param>
                <param>
                    y the y-coordinate of the first rectangle                    
                </param>
                <param>
                    width the width of the first rectangle                    
                </param>
                <param>
                    height the height of the first rectangle                    
                </param>
                <param>
                    dest  the coordinates of the second rectangle; the union
                      of the two rectangles is returned in this rectangle                    
                </param>
                <return>
                    the &lt;code&gt;dest&lt;/code&gt; &lt;code&gt;Rectangle&lt;/code&gt;                    
                </return>
            </javadoc>
            <method name="computeUnion" type="Rectangle" line="516">
                <params>
                    <param name="x" type="int"/>
                    <param name="y" type="int"/>
                    <param name="width" type="int"/>
                    <param name="height" type="int"/>
                    <param name="dest" type="Rectangle"/>
                </params>
                <declaration name="x1" type="int" line="517"/>
                <declaration name="x2" type="int" line="518"/>
                <declaration name="y1" type="int" line="519"/>
                <declaration name="y2" type="int" line="520"/>
            </method>
            <javadoc line="529">
                Convenience returning an array of rect representing the regions within
                  &lt;code&gt;rectA&lt;/code&gt; that do not overlap with &lt;code&gt;rectB&lt;/code&gt;. If the
                  two Rects do not overlap, returns an empty array                
            </javadoc>
            <method name="computeDifference" type="Rectangle[]" line="534">
                <params>
                    <param name="rectA" type="Rectangle"/>
                    <param name="rectB" type="Rectangle"/>
                </params>
                <comment line="545">
                                        
                </comment>
                <comment line="573">
                                        
                </comment>
                <scope line="535"/>
                <declaration name="t" type="Rectangle" line="539"/>
                <declaration name="a" type="Rectangle" line="540"/>
                <declaration name="result" type="Rectangle" line="541"/>
                <declaration name="rectCount" type="int" line="542"/>
                <scope line="545">
                    <scope line="547"/>
                    <scope line="553"/>
                    <scope line="560"/>
                    <scope line="567"/>
                </scope>
                <scope line="571">
                    <scope line="573">
                        <scope line="574">
                            <scope line="578"/>
                        </scope>
                        <scope line="582">
                            <scope line="585"/>
                        </scope>
                        <scope line="589">
                            <scope line="593"/>
                            <scope line="600"/>
                        </scope>
                    </scope>
                    <scope line="605">
                        <scope line="606">
                            <scope line="608"/>
                        </scope>
                        <scope line="612">
                            <scope line="614"/>
                            <scope line="621"/>
                        </scope>
                    </scope>
                    <scope line="626">
                        <scope line="627">
                            <scope line="629"/>
                            <scope line="636"/>
                        </scope>
                        <scope line="640">
                            <scope line="642"/>
                            <scope line="650"/>
                            <scope line="657"/>
                        </scope>
                    </scope>
                    <scope line="662">
                        <scope line="663">
                            <scope line="665"/>
                        </scope>
                        <scope line="669">
                            <scope line="672"/>
                            <scope line="679"/>
                        </scope>
                        <scope line="683">
                            <scope line="685"/>
                            <scope line="692"/>
                        </scope>
                        <scope line="696">
                            <scope line="698"/>
                            <scope line="705"/>
                            <scope line="712"/>
                        </scope>
                    </scope>
                    <scope line="717">
                        <scope line="718">
                            <scope line="720"/>
                            <scope line="726"/>
                        </scope>
                        <scope line="730">
                            <scope line="732"/>
                            <scope line="740"/>
                            <scope line="747"/>
                        </scope>
                        <scope line="751">
                            <scope line="753"/>
                            <scope line="760"/>
                            <scope line="767"/>
                        </scope>
                    </scope>
                </scope>
            </method>
            <javadoc line="788">
                Returns true if the mouse event specifies the left mouse button.                
                <param>
                    anEvent  a MouseEvent object                    
                </param>
                <return>
                    true if the left mouse button was active                    
                </return>
            </javadoc>
            <method name="isLeftMouseButton" type="boolean" line="794">
                <params>
                    <param name="anEvent" type="MouseEvent"/>
                </params>
            </method>
            <javadoc line="798">
                Returns true if the mouse event specifies the middle mouse button.                
                <param>
                    anEvent  a MouseEvent object                    
                </param>
                <return>
                    true if the middle mouse button was active                    
                </return>
            </javadoc>
            <method name="isMiddleMouseButton" type="boolean" line="804">
                <params>
                    <param name="anEvent" type="MouseEvent"/>
                </params>
            </method>
            <javadoc line="808">
                Returns true if the mouse event specifies the right mouse button.                
                <param>
                    anEvent  a MouseEvent object                    
                </param>
                <return>
                    true if the right mouse button was active                    
                </return>
            </javadoc>
            <method name="isRightMouseButton" type="boolean" line="814">
                <params>
                    <param name="anEvent" type="MouseEvent"/>
                </params>
            </method>
            <javadoc line="818">
                Compute the width of the string using a font with the specified
                  &quot;metrics&quot; (sizes).                
                <param>
                    fm   a FontMetrics object to compute with                    
                </param>
                <param>
                    str  the String to compute                    
                </param>
                <return>
                    an int containing the string width                    
                </return>
            </javadoc>
            <method name="computeStringWidth" type="int" line="826">
                <params>
                    <param name="fm" type="FontMetrics"/>
                    <param name="str" type="String"/>
                </params>
                <comment line="828">
                    You can&apos;t assume that a string&apos;s width is the sum of its
                     characters&apos; widths in Java2D -- it may be smaller due to
                     kerning, etc.                    
                </comment>
            </method>
            <javadoc line="833">
                Compute and return the location of the icons origin, the
                  location of origin of the text baseline, and a possibly clipped
                  version of the compound labels string.  Locations are computed
                  relative to the viewR rectangle.
                  The JComponents orientation (LEADING/TRAILING) will also be taken
                  into account and translated into LEFT/RIGHT values accordingly.                
            </javadoc>
            <method name="layoutCompoundLabel" type="String" line="853">
                <params>
                    <param name="c" type="JComponent"/>
                    <param name="fm" type="FontMetrics"/>
                    <param name="text" type="String"/>
                    <param name="icon" type="Icon"/>
                    <param name="verticalAlignment" type="int"/>
                    <param name="horizontalAlignment" type="int"/>
                    <param name="verticalTextPosition" type="int"/>
                    <param name="horizontalTextPosition" type="int"/>
                    <param name="viewR" type="Rectangle"/>
                    <param name="iconR" type="Rectangle"/>
                    <param name="textR" type="Rectangle"/>
                    <param name="textIconGap" type="int"/>
                </params>
                <comment line="865">
                    Translate LEADING/TRAILING values in horizontalAlignment
                     to LEFT/RIGHT values depending on the components orientation                    
                </comment>
                <comment line="876">
                    Translate LEADING/TRAILING values in horizontalTextPosition
                     to LEFT/RIGHT values depending on the components orientation                    
                </comment>
                <declaration name="orientationIsLeftToRight" type="boolean" line="854"/>
                <declaration name="hAlign" type="int" line="855"/>
                <declaration name="hTextPos" type="int" line="856"/>
                <scope line="858">
                    <scope line="859"/>
                </scope>
            </method>
            <javadoc line="900">
                Compute and return the location of the icons origin, the
                  location of origin of the text baseline, and a possibly clipped
                  version of the compound labels string.  Locations are computed
                  relative to the viewR rectangle.
                  This layoutCompoundLabel() does not know how to handle LEADING/TRAILING
                  values in horizontalTextPosition (they will default to RIGHT) and in
                  horizontalAlignment (they will default to CENTER).
                  Use the other version of layoutCompoundLabel() instead.                
            </javadoc>
            <method name="layoutCompoundLabel" type="String" line="922">
                <params>
                    <param name="fm" type="FontMetrics"/>
                    <param name="text" type="String"/>
                    <param name="icon" type="Icon"/>
                    <param name="verticalAlignment" type="int"/>
                    <param name="horizontalAlignment" type="int"/>
                    <param name="verticalTextPosition" type="int"/>
                    <param name="horizontalTextPosition" type="int"/>
                    <param name="viewR" type="Rectangle"/>
                    <param name="iconR" type="Rectangle"/>
                    <param name="textR" type="Rectangle"/>
                    <param name="textIconGap" type="int"/>
                </params>
            </method>
            <javadoc line="931">
                Compute and return the location of the icons origin, the
                  location of origin of the text baseline, and a possibly clipped
                  version of the compound labels string.  Locations are computed
                  relative to the viewR rectangle.
                  This layoutCompoundLabel() does not know how to handle LEADING/TRAILING
                  values in horizontalTextPosition (they will default to RIGHT) and in
                  horizontalAlignment (they will default to CENTER).
                  Use the other version of layoutCompoundLabel() instead.                
            </javadoc>
            <method name="layoutCompoundLabelImpl" type="String" line="954">
                <params>
                    <param name="c" type="JComponent"/>
                    <param name="fm" type="FontMetrics"/>
                    <param name="text" type="String"/>
                    <param name="icon" type="Icon"/>
                    <param name="verticalAlignment" type="int"/>
                    <param name="horizontalAlignment" type="int"/>
                    <param name="verticalTextPosition" type="int"/>
                    <param name="horizontalTextPosition" type="int"/>
                    <param name="viewR" type="Rectangle"/>
                    <param name="iconR" type="Rectangle"/>
                    <param name="textR" type="Rectangle"/>
                    <param name="textIconGap" type="int"/>
                </params>
                <comment line="956">
                    Initialize the icon bounds rectangle iconR.                    
                </comment>
                <comment line="967">
                    Initialize the text bounds rectangle textR.  If a null
                     or and empty String was specified we substitute &quot;&quot; here
                     and use 0,0,0,0 for textR.                    
                </comment>
                <comment line="975">
                    Unless both text and icon are non-null, we effectively ignore
                     the value of textIconGap.                    
                </comment>
                <comment line="1005">
                    If lsb is negative, add it to the width and later
                     adjust the x location. This gives more space than is
                     actually needed.
                     This is done like this for two reasons:
                     1. If we set the width to the actual bounds all
                        callers would have to account for negative lsb
                        (pref size calculations ONLY look at width of
                        textR)
                     2. You can do a drawString at the returned location
                        and the text won&apos;t be clipped.                    
                </comment>
                <comment line="1027">
                    Compute textR.x,y given the verticalTextPosition and
                     horizontalTextPosition properties                    
                </comment>
                <comment line="1042">
                    (verticalTextPosition == BOTTOM)                    
                </comment>
                <comment line="1057">
                    (horizontalTextPosition == RIGHT)                    
                </comment>
                <comment line="1061">
                    WARNING: DefaultTreeCellEditor uses a shortened version of
                     this algorithm to position it&apos;s Icon. If you change how this
                     is calculated, be sure and update DefaultTreeCellEditor too.                    
                </comment>
                <comment line="1065">
                    labelR is the rectangle that contains iconR and textR.
                     Move it to its proper position given the labelAlignment
                     properties.
                    
                     To avoid actually allocating a Rectangle, Rectangle.union
                     has been inlined below.                    
                </comment>
                <comment line="1087">
                    (verticalAlignment == BOTTOM)                    
                </comment>
                <comment line="1097">
                    (horizontalAlignment == CENTER)                    
                </comment>
                <comment line="1102">
                    Translate textR and glypyR by dx,dy.                    
                </comment>
                <comment line="1112">
                    lsb is negative. Shift the x location so that the text is
                     visually drawn at the right location.                    
                </comment>
                <scope line="958"/>
                <scope line="962"/>
                <declaration name="textIsEmpty" type="boolean" line="971"/>
                <declaration name="lsb" type="int" line="972"/>
                <declaration name="rsb" type="int" line="973"/>
                <declaration name="gap" type="int" line="977"/>
                <declaration name="v" type="View" line="979"/>
                <scope line="980"/>
                <scope line="985">
                    <declaration name="availTextWidth" type="int" line="986"/>
                    <scope line="989"/>
                    <scope line="992"/>
                    <scope line="996"/>
                    <scope line="1000">
                        <scope line="1003"/>
                        <scope line="1016"/>
                    </scope>
                </scope>
                <scope line="1030">
                    <scope line="1031"/>
                    <scope line="1034"/>
                </scope>
                <scope line="1038"/>
                <scope line="1041">
                    <scope line="1042"/>
                    <scope line="1045"/>
                </scope>
                <scope line="1050"/>
                <scope line="1053"/>
                <scope line="1056"/>
                <declaration name="labelR_x" type="int" line="1071"/>
                <declaration name="labelR_width" type="int" line="1072"/>
                <declaration name="labelR_y" type="int" line="1074"/>
                <declaration name="labelR_height" type="int" line="1075"/>
                <declaration name="dx" type="int" line="1078"/>
                <scope line="1080"/>
                <scope line="1083"/>
                <scope line="1086"/>
                <scope line="1090"/>
                <scope line="1093"/>
                <scope line="1096"/>
                <scope line="1110"/>
                <scope line="1117"/>
            </method>
            <javadoc line="1125">
                Paints a component to the specified &lt;code&gt;Graphics&lt;/code&gt;.
                  This method is primarily useful to render
                  &lt;code&gt;Component&lt;/code&gt;s that don&apos;t exist as part of the visible
                  containment hierarchy, but are used for rendering.  For
                  example, if you are doing your own rendering and want to render
                  some text (or even HTML), you could make use of
                  &lt;code&gt;JLabel&lt;/code&gt;&apos;s text rendering support and have it paint
                  directly by way of this method, without adding the label to the
                  visible containment hierarchy.
                  &lt;p&gt;
                  This method makes use of &lt;code&gt;CellRendererPane&lt;/code&gt; to handle
                  the actual painting, and is only recommended if you use one
                  component for rendering.  If you make use of multiple components
                  to handle the rendering, as &lt;code&gt;JTable&lt;/code&gt; does, use
                  &lt;code&gt;CellRendererPane&lt;/code&gt; directly.  Otherwise, as described
                  below, you could end up with a &lt;code&gt;CellRendererPane&lt;/code&gt;
                  per &lt;code&gt;Component&lt;/code&gt;.
                  &lt;p&gt;
                  If &lt;code&gt;c&lt;/code&gt;&apos;s parent is not a &lt;code&gt;CellRendererPane&lt;/code&gt;,
                  a new &lt;code&gt;CellRendererPane&lt;/code&gt; is created, &lt;code&gt;c&lt;/code&gt; is
                  added to it, and the &lt;code&gt;CellRendererPane&lt;/code&gt; is added to
                  &lt;code&gt;p&lt;/code&gt;.  If &lt;code&gt;c&lt;/code&gt;&apos;s parent is a
                  &lt;code&gt;CellRendererPane&lt;/code&gt; and the &lt;code&gt;CellRendererPane&lt;/code&gt;s
                  parent is not &lt;code&gt;p&lt;/code&gt;, it is added to &lt;code&gt;p&lt;/code&gt;.
                  &lt;p&gt;
                  The component should either descend from &lt;code&gt;JComponent&lt;/code&gt;
                  or be another kind of lightweight component.
                  A lightweight component is one whose &quot;lightweight&quot; property
                  (returned by the &lt;code&gt;Component&lt;/code&gt;
                  &lt;code&gt;isLightweight&lt;/code&gt; method)
                  is true. If the Component is not lightweight, bad things map happen:
                  crashes, exceptions, painting problems...                
                <param>
                    g  the &lt;code&gt;Graphics&lt;/code&gt; object to draw on                    
                </param>
                <param>
                    c  the &lt;code&gt;Component&lt;/code&gt; to draw                    
                </param>
                <param>
                    p  the intermediate &lt;code&gt;Container&lt;/code&gt;                    
                </param>
                <param>
                    x  an int specifying the left side of the area draw in, in pixels,
                      measured from the left edge of the graphics context                    
                </param>
                <param>
                    y  an int specifying the top of the area to draw in, in pixels
                      measured down from the top edge of the graphics context                    
                </param>
                <param>
                    w  an int specifying the width of the area draw in, in pixels                    
                </param>
                <param>
                    h  an int specifying the height of the area draw in, in pixels                    
                </param>
                <see>
                    CellRendererPane                    
                </see>
                <see>
                    java.awt.Component#isLightweight                    
                </see>
            </javadoc>
            <method name="paintComponent" type="void" line="1172">
                <params>
                    <param name="g" type="Graphics"/>
                    <param name="c" type="Component"/>
                    <param name="p" type="Container"/>
                    <param name="x" type="int"/>
                    <param name="y" type="int"/>
                    <param name="w" type="int"/>
                    <param name="h" type="int"/>
                </params>
            </method>
            <javadoc line="1176">
                Paints a component to the specified &lt;code&gt;Graphics&lt;/code&gt;.  This
                  is a cover method for{@link #paintComponent(Graphics,Component,Container,int,int,int,int)}.
                  Refer to it for more information.                
                <param>
                    g  the &lt;code&gt;Graphics&lt;/code&gt; object to draw on                    
                </param>
                <param>
                    c  the &lt;code&gt;Component&lt;/code&gt; to draw                    
                </param>
                <param>
                    p  the intermediate &lt;code&gt;Container&lt;/code&gt;                    
                </param>
                <param>
                    r  the &lt;code&gt;Rectangle&lt;/code&gt; to draw in                    
                </param>
                <see>
                    #paintComponent(Graphics,Component,Container,int,int,int,int)                    
                </see>
                <see>
                    CellRendererPane                    
                </see>
            </javadoc>
            <method name="paintComponent" type="void" line="1190">
                <params>
                    <param name="g" type="Graphics"/>
                    <param name="c" type="Component"/>
                    <param name="p" type="Container"/>
                    <param name="r" type="Rectangle"/>
                </params>
            </method>
            <method name="getCellRendererPane" type="CellRendererPane" line="1200">
                <params>
                    <param name="c" type="Component"/>
                    <param name="p" type="Container"/>
                </params>
                <declaration name="shell" type="Container" line="1201"/>
                <scope line="1202">
                    <scope line="1203"/>
                </scope>
                <scope line="1206"/>
            </method>
            <javadoc line="1214">
                A simple minded look and feel change: ask each node in the tree
                  to &lt;code&gt;updateUI()&lt;/code&gt; -- that is, to initialize its UI property
                  with the current look and feel.                
            </javadoc>
            <method name="updateComponentTreeUI" type="void" line="1219">
                <params>
                    <param name="c" type="Component"/>
                </params>
            </method>
            <method name="updateComponentTreeUI0" type="void" line="1226">
                <params>
                    <param name="c" type="Component"/>
                </params>
                <scope line="1227">
                    <declaration name="jc" type="JComponent" line="1228"/>
                    <declaration name="jpm" type="JPopupMenu" line="1230"/>
                    <scope line="1231"/>
                </scope>
                <declaration name="children" type="Component[]" line="1235"/>
                <scope line="1236"/>
                <scope line="1239"/>
                <scope line="1242">
                    <scope line="1243"/>
                </scope>
            </method>
            <javadoc line="1250">
                Causes &lt;i&gt;doRun.run()&lt;/i&gt; to be executed asynchronously on the
                  AWT event dispatching thread.  This will happen after all
                  pending AWT events have been processed.  This method should
                  be used when an application thread needs to update the GUI.
                  In the following example the &lt;code&gt;invokeLater&lt;/code&gt; call queues
                  the &lt;code&gt;Runnable&lt;/code&gt; object &lt;code&gt;doHelloWorld&lt;/code&gt;
                  on the event dispatching thread and
                  then prints a message.
                  &lt;pre&gt;
                  Runnable doHelloWorld = new Runnable() {
                  public void run() {
                  System.out.println(&quot;Hello World on &quot; + Thread.currentThread());
                  }
                  };
                  SwingUtilities.invokeLater(doHelloWorld);
                  System.out.println(&quot;This might well be displayed before the other message.&quot;);
                  &lt;/pre&gt;
                  If invokeLater is called from the event dispatching thread --
                  for example, from a JButton&apos;s ActionListener -- the &lt;i&gt;doRun.run()&lt;/i&gt; will
                  still be deferred until all pending events have been processed.
                  Note that if the &lt;i&gt;doRun.run()&lt;/i&gt; throws an uncaught exception
                  the event dispatching thread will unwind (not the current thread).
                  &lt;p&gt;
                  Additional documentation and examples for this method can be
                  found in
                  &lt;A HREF=&quot;http://java.sun.com/docs/books/tutorial/uiswing/misc/threads.html&quot;&gt;How to Use Threads&lt;/a&gt;,
                  in &lt;em&gt;The Java Tutorial&lt;/em&gt;.
                  &lt;p&gt;
                  As of 1.3 this method is just a cover for &lt;code&gt;java.awt.EventQueue.invokeLater()&lt;/code&gt;.
                  &lt;p&gt;
                  Unlike the rest of Swing, this method can be invoked from any thread.                
                <see>
                    #invokeAndWait                    
                </see>
            </javadoc>
            <method name="invokeLater" type="void" line="1286">
                <params>
                    <param name="doRun" type="Runnable"/>
                </params>
            </method>
            <javadoc line="1291">
                Causes &lt;code&gt;doRun.run()&lt;/code&gt; to be executed synchronously on the
                  AWT event dispatching thread.  This call blocks until
                  all pending AWT events have been processed and (then)
                  &lt;code&gt;doRun.run()&lt;/code&gt; returns. This method should
                  be used when an application thread needs to update the GUI.
                  It shouldn&apos;t be called from the event dispatching thread.
                  Here&apos;s an example that creates a new application thread
                  that uses &lt;code&gt;invokeAndWait&lt;/code&gt; to print a string from the event
                  dispatching thread and then, when that&apos;s finished, print
                  a string from the application thread.
                  &lt;pre&gt;
                  final Runnable doHelloWorld = new Runnable() {
                  public void run() {
                  System.out.println(&quot;Hello World on &quot; + Thread.currentThread());
                  }
                  };
                  Thread appThread = new Thread() {
                  public void run() {
                  try {
                  SwingUtilities.invokeAndWait(doHelloWorld);
                  }
                  catch (Exception e) {
                  e.printStackTrace();
                  }
                  System.out.println(&quot;Finished on &quot; + Thread.currentThread());
                  }
                  };
                  appThread.start();
                  &lt;/pre&gt;
                  Note that if the &lt;code&gt;Runnable.run&lt;/code&gt; method throws an
                  uncaught exception
                  (on the event dispatching thread) it&apos;s caught and rethrown, as
                  an &lt;code&gt;InvocationTargetException&lt;/code&gt;, on the caller&apos;s thread.
                  &lt;p&gt;
                  Additional documentation and examples for this method can be
                  found in
                  &lt;A HREF=&quot;http://java.sun.com/docs/books/tutorial/uiswing/misc/threads.html&quot;&gt;How to Use Threads&lt;/a&gt;,
                  in &lt;em&gt;The Java Tutorial&lt;/em&gt;.
                  &lt;p&gt;
                  As of 1.3 this method is just a cover for
                  &lt;code&gt;java.awt.EventQueue.invokeAndWait()&lt;/code&gt;.                
                <exception>
                    InterruptedException if we&apos;re interrupted while waiting for
                      the event dispatching thread to finish excecuting
                      &lt;code&gt;doRun.run()&lt;/code&gt;                    
                </exception>
                <exception>
                    InvocationTargetException  if an exception is thrown
                      while running &lt;code&gt;doRun&lt;/code&gt;                    
                </exception>
                <see>
                    #invokeLater                    
                </see>
            </javadoc>
            <method name="invokeAndWait" type="void" line="1345">
                <params>
                    <param name="doRun" type="Runnable"/>
                </params>
            </method>
            <javadoc line="1349">
                Returns true if the current thread is an AWT event dispatching thread.
                  &lt;p&gt;
                  As of 1.3 this method is just a cover for
                  &lt;code&gt;java.awt.EventQueue.isDispatchThread()&lt;/code&gt;.                
                <return>
                    true if the current thread is an AWT event dispatching thread                    
                </return>
            </javadoc>
            <method name="isEventDispatchThread" type="boolean" line="1358"/>
            <javadoc line="1368">
                Get the index of this object in its accessible parent.&lt;p&gt;
                  Note: as of the Java 2 platform v1.3, it is recommended that developers call
                  Component.AccessibleAWTComponent.getAccessibleIndexInParent() instead
                  of using this method.                
                <return>
                    -1 of this object does not have an accessible parent.
                      Otherwise, the index of the child in its accessible parent.                    
                </return>
            </javadoc>
            <method name="getAccessibleIndexInParent" type="int" line="1378">
                <params>
                    <param name="c" type="Component"/>
                </params>
            </method>
            <javadoc line="1382">
                Returns the &lt;code&gt;Accessible&lt;/code&gt; child contained at the
                  local coordinate &lt;code&gt;Point&lt;/code&gt;, if one exists.
                  Otherwise returns &lt;code&gt;null&lt;/code&gt;.                
                <return>
                    the &lt;code&gt;Accessible&lt;/code&gt; at the specified location,
                      if it exists; otherwise &lt;code&gt;null&lt;/code&gt;                    
                </return>
            </javadoc>
            <method name="getAccessibleAt" type="Accessible" line="1390">
                <params>
                    <param name="c" type="Component"/>
                    <param name="p" type="Point"/>
                </params>
                <scope line="1391"/>
                <scope line="1393">
                    <declaration name="a" type="Accessible" line="1394"/>
                    <scope line="1395">
                        <declaration name="ac" type="AccessibleContext" line="1396"/>
                        <scope line="1397">
                            <declaration name="acmp" type="AccessibleComponent" line="1398"/>
                            <declaration name="location" type="Point" line="1399"/>
                            <declaration name="nchildren" type="int" line="1400"/>
                            <scope line="1401">
                                <scope line="1403">
                                    <scope line="1405">
                                        <scope line="1407">
                                            <declaration name="np" type="Point" line="1409"/>
                                            <scope line="1411"/>
                                        </scope>
                                    </scope>
                                </scope>
                            </scope>
                        </scope>
                    </scope>
                </scope>
            </method>
            <javadoc line="1425">
                Get the state of this object. &lt;p&gt;
                  Note: as of the Java 2 platform v1.3, it is recommended that developers call
                  Component.AccessibleAWTComponent.getAccessibleIndexInParent() instead
                  of using this method.                
                <return>
                    an instance of AccessibleStateSet containing the current state
                      set of the object                    
                </return>
                <see>
                    AccessibleState                    
                </see>
            </javadoc>
            <method name="getAccessibleStateSet" type="AccessibleStateSet" line="1436">
                <params>
                    <param name="c" type="Component"/>
                </params>
            </method>
            <javadoc line="1440">
                Returns the number of accessible children in the object.  If all
                  of the children of this object implement Accessible, than this
                  method should return the number of children of this object. &lt;p&gt;
                  Note: as of the Java 2 platform v1.3, it is recommended that developers call
                  Component.AccessibleAWTComponent.getAccessibleIndexInParent() instead
                  of using this method.                
                <return>
                    the number of accessible children in the object.                    
                </return>
            </javadoc>
            <method name="getAccessibleChildrenCount" type="int" line="1451">
                <params>
                    <param name="c" type="Component"/>
                </params>
            </method>
            <javadoc line="1455">
                Return the nth Accessible child of the object. &lt;p&gt;
                  Note: as of the Java 2 platform v1.3, it is recommended that developers call
                  Component.AccessibleAWTComponent.getAccessibleIndexInParent() instead
                  of using this method.                
                <param>
                    i zero-based index of child                    
                </param>
                <return>
                    the nth Accessible child of the object                    
                </return>
            </javadoc>
            <method name="getAccessibleChild" type="Accessible" line="1465">
                <params>
                    <param name="c" type="Component"/>
                    <param name="i" type="int"/>
                </params>
            </method>
            <javadoc line="1469">
                Return the child &lt;code&gt;Component&lt;/code&gt; of the specified
                  &lt;code&gt;Component&lt;/code&gt; that is the focus owner, if any.                
                <param>
                    c the root of the &lt;code&gt;Component&lt;/code&gt; hierarchy to
                      search for the focus owner                    
                </param>
                <return>
                    the focus owner, or &lt;code&gt;null&lt;/code&gt; if there is no focus
                      owner, or if the focus owner is not &lt;code&gt;comp&lt;/code&gt;, or a
                      descendant of &lt;code&gt;comp&lt;/code&gt;                    
                </return>
                <see>
                    java.awt.KeyboardFocusManager#getFocusOwner                    
                </see>
                <deprecated>
                    As of 1.4, replaced by
                      &lt;code&gt;KeyboardFocusManager.getFocusOwner()&lt;/code&gt;.                    
                </deprecated>
            </javadoc>
            <method name="findFocusOwner" type="Component" line="1484">
                <params>
                    <param name="c" type="Component"/>
                </params>
                <comment line="1489">
                    verify focusOwner is a descendant of c                    
                </comment>
                <declaration name="focusOwner" type="Component" line="1485"/>
                <scope line="1491">
                    <scope line="1492"/>
                </scope>
            </method>
            <javadoc line="1500">
                If c is a JRootPane descendant return its JRootPane ancestor.
                  If c is a RootPaneContainer then return its JRootPane.                
                <return>
                    the JRootPane for Component c or {@code null}.                    
                </return>
            </javadoc>
            <method name="getRootPane" type="JRootPane" line="1505">
                <params>
                    <param name="c" type="Component"/>
                </params>
                <scope line="1506"/>
                <scope line="1509">
                    <scope line="1510"/>
                </scope>
            </method>
            <javadoc line="1518">
                Returns the root component for the current component tree.                
                <return>
                    the first ancestor of c that&apos;s a Window or the last Applet ancestor                    
                </return>
            </javadoc>
            <method name="getRoot" type="Component" line="1522">
                <params>
                    <param name="c" type="Component"/>
                </params>
                <declaration name="applet" type="Component" line="1523"/>
                <scope line="1524">
                    <scope line="1525"/>
                    <scope line="1528"/>
                </scope>
            </method>
            <method name="getPaintingOrigin" type="JComponent" line="1535">
                <params>
                    <param name="c" type="JComponent"/>
                </params>
                <declaration name="p" type="Container" line="1536"/>
                <scope line="1537">
                    <declaration name="jp" type="JComponent" line="1538"/>
                    <scope line="1539"/>
                </scope>
            </method>
            <javadoc line="1546">
                Process the key bindings for the &lt;code&gt;Component&lt;/code&gt; associated with
                  &lt;code&gt;event&lt;/code&gt;. This method is only useful if
                  &lt;code&gt;event.getComponent()&lt;/code&gt; does not descend from
                  &lt;code&gt;JComponent&lt;/code&gt;, or your are not invoking
                  &lt;code&gt;super.processKeyEvent&lt;/code&gt; from within your
                  &lt;code&gt;JComponent&lt;/code&gt; subclass. &lt;code&gt;JComponent&lt;/code&gt;
                  automatically processes bindings from within its
                  &lt;code&gt;processKeyEvent&lt;/code&gt; method, hence you rarely need
                  to directly invoke this method.                
                <param>
                    event KeyEvent used to identify which bindings to process, as
                      well as which Component has focus.                    
                </param>
                <return>
                    true if a binding has found and processed                    
                </return>
                <since>
                    1.4                    
                </since>
            </javadoc>
            <method name="processKeyBindings" type="boolean" line="1562">
                <params>
                    <param name="event" type="KeyEvent"/>
                </params>
                <comment line="1575">
                    Find the first JComponent in the ancestor hierarchy, and
                     invoke processKeyBindings on it                    
                </comment>
                <comment line="1584">
                    No JComponents, if Window or Applet parent, process
                     WHEN_IN_FOCUSED_WINDOW bindings.                    
                </comment>
                <scope line="1563">
                    <scope line="1564"/>
                    <declaration name="component" type="Component" line="1568"/>
                    <declaration name="pressed" type="boolean" line="1569"/>
                    <scope line="1571"/>
                    <scope line="1576">
                        <scope line="1577"/>
                        <scope line="1582"/>
                    </scope>
                </scope>
            </method>
            <javadoc line="1594">
                Returns true if the &lt;code&gt;e&lt;/code&gt; is a valid KeyEvent to use in
                  processing the key bindings associated with JComponents.                
            </javadoc>
            <method name="isValidKeyEventForKeyBindings" type="boolean" line="1598">
                <params>
                    <param name="e" type="KeyEvent"/>
                </params>
            </method>
            <javadoc line="1602">
                Invokes &lt;code&gt;actionPerformed&lt;/code&gt; on &lt;code&gt;action&lt;/code&gt; if
                  &lt;code&gt;action&lt;/code&gt; is enabled (and non-{@code null}). The command for the
                  ActionEvent is determined by:
                  &lt;ol&gt;
                  &lt;li&gt;If the action was registered via
                  &lt;code&gt;registerKeyboardAction&lt;/code&gt;, then the command string
                  passed in ({@code null} will be used if {@code null} was passed in).
                  &lt;li&gt;Action value with name Action.ACTION_COMMAND_KEY, unless {@code null}.
                  &lt;li&gt;String value of the KeyEvent, unless &lt;code&gt;getKeyChar&lt;/code&gt;
                  returns KeyEvent.CHAR_UNDEFINED..
                  &lt;/ol&gt;
                  This will return true if &lt;code&gt;action&lt;/code&gt; is non-{@code null} and
                  actionPerformed is invoked on it.                
                <since>
                    1.3                    
                </since>
            </javadoc>
            <method name="notifyAction" type="boolean" line="1621">
                <params>
                    <param name="action" type="Action"/>
                    <param name="ks" type="KeyStroke"/>
                    <param name="event" type="KeyEvent"/>
                    <param name="sender" type="Object"/>
                    <param name="modifiers" type="int"/>
                </params>
                <comment line="1637">
                    Get the command object.                    
                </comment>
                <comment line="1640">
                    ActionStandin is used for historical reasons to support
                     registerKeyboardAction with a null value.                    
                </comment>
                <comment line="1648">
                    Convert it to a string.                    
                </comment>
                <comment line="1658">
                    Do null for undefined chars, or if registerKeyboardAction
                     was called with a null.                    
                </comment>
                <scope line="1622"/>
                <scope line="1625">
                    <scope line="1626"/>
                </scope>
                <scope line="1630"/>
                <declaration name="commandO" type="Object" line="1633"/>
                <declaration name="stayNull" type="boolean" line="1634"/>
                <scope line="1638"/>
                <scope line="1643"/>
                <declaration name="command" type="String" line="1648"/>
                <scope line="1650"/>
                <scope line="1653"/>
                <scope line="1656"/>
            </method>
            <javadoc line="1668">
                Convenience method to change the UI InputMap for &lt;code&gt;component&lt;/code&gt;
                  to &lt;code&gt;uiInputMap&lt;/code&gt;. If &lt;code&gt;uiInputMap&lt;/code&gt; is {@code null},
                  this removes any previously installed UI InputMap.                
                <since>
                    1.3                    
                </since>
            </javadoc>
            <method name="replaceUIInputMap" type="void" line="1676">
                <params>
                    <param name="component" type="JComponent"/>
                    <param name="type" type="int"/>
                    <param name="uiInputMap" type="InputMap"/>
                </params>
                <declaration name="map" type="InputMap" line="1677"/>
                <scope line="1679">
                    <declaration name="parent" type="InputMap" line="1680"/>
                    <scope line="1681"/>
                </scope>
            </method>
            <javadoc line="1690">
                Convenience method to change the UI ActionMap for &lt;code&gt;component&lt;/code&gt;
                  to &lt;code&gt;uiActionMap&lt;/code&gt;. If &lt;code&gt;uiActionMap&lt;/code&gt; is {@code null},
                  this removes any previously installed UI ActionMap.                
                <since>
                    1.3                    
                </since>
            </javadoc>
            <method name="replaceUIActionMap" type="void" line="1698">
                <params>
                    <param name="component" type="JComponent"/>
                    <param name="uiActionMap" type="ActionMap"/>
                </params>
                <declaration name="map" type="ActionMap" line="1699"/>
                <scope line="1701">
                    <declaration name="parent" type="ActionMap" line="1702"/>
                    <scope line="1703"/>
                </scope>
            </method>
            <javadoc line="1712">
                Returns the InputMap provided by the UI for condition
                  &lt;code&gt;condition&lt;/code&gt; in component &lt;code&gt;component&lt;/code&gt;.
                  &lt;p&gt;This will return {@code null} if the UI has not installed a InputMap
                  of the specified type.                
                <since>
                    1.3                    
                </since>
            </javadoc>
            <method name="getUIInputMap" type="InputMap" line="1720">
                <params>
                    <param name="component" type="JComponent"/>
                    <param name="condition" type="int"/>
                </params>
                <declaration name="map" type="InputMap" line="1721"/>
                <scope line="1722">
                    <declaration name="parent" type="InputMap" line="1723"/>
                    <scope line="1724"/>
                </scope>
            </method>
            <javadoc line="1732">
                Returns the ActionMap provided by the UI
                  in component &lt;code&gt;component&lt;/code&gt;.
                  &lt;p&gt;This will return {@code null} if the UI has not installed an ActionMap.                
                <since>
                    1.3                    
                </since>
            </javadoc>
            <method name="getUIActionMap" type="ActionMap" line="1739">
                <params>
                    <param name="component" type="JComponent"/>
                </params>
                <declaration name="map" type="ActionMap" line="1740"/>
                <scope line="1741">
                    <declaration name="parent" type="ActionMap" line="1742"/>
                    <scope line="1743"/>
                </scope>
            </method>
            <declaration name="sharedOwnerFrameKey" type="Object" line="1753"/>
            <class name="SharedOwnerFrame" line="1756">
                <extends class="Frame"/>
                <implements interface="WindowListener"/>
                <method name="addNotify" type="void" line="1757"/>
                <javadoc line="1762">
                    Install window listeners on owned windows to watch for displayability changes                    
                </javadoc>
                <method name="installListeners" type="void" line="1765">
                    <declaration name="windows" type="Window[]" line="1766"/>
                    <scope line="1767">
                        <scope line="1768"/>
                    </scope>
                </method>
                <javadoc line="1775">
                    Watches for displayability changes and disposes shared instance if there are no
                      displayable children left.                    
                </javadoc>
                <method name="windowClosed" type="void" line="1779">
                    <params>
                        <param name="e" type="WindowEvent"/>
                    </params>
                    <scope line="1780">
                        <declaration name="windows" type="Window[]" line="1781"/>
                        <scope line="1782">
                            <scope line="1783">
                                <scope line="1784"/>
                            </scope>
                        </scope>
                    </scope>
                </method>
                <method name="windowOpened" type="void" line="1793">
                    <params>
                        <param name="e" type="WindowEvent"/>
                    </params>
                </method>
                <method name="windowClosing" type="void" line="1795">
                    <params>
                        <param name="e" type="WindowEvent"/>
                    </params>
                </method>
                <method name="windowIconified" type="void" line="1797">
                    <params>
                        <param name="e" type="WindowEvent"/>
                    </params>
                </method>
                <method name="windowDeiconified" type="void" line="1799">
                    <params>
                        <param name="e" type="WindowEvent"/>
                    </params>
                </method>
                <method name="windowActivated" type="void" line="1801">
                    <params>
                        <param name="e" type="WindowEvent"/>
                    </params>
                </method>
                <method name="windowDeactivated" type="void" line="1803">
                    <params>
                        <param name="e" type="WindowEvent"/>
                    </params>
                </method>
                <method name="show" type="void" line="1806">
                    <comment line="1808">
                        This frame can never be shown                        
                    </comment>
                </method>
                <method name="dispose" type="void" line="1809">
                    <comment line="1815">
                        untrusted code not allowed to dispose                        
                    </comment>
                    <scope line="1810"/>
                    <scope line="1813"/>
                </method>
            </class>
            <javadoc line="1819">
                Returns a toolkit-private, shared, invisible Frame
                  to be the owner for JDialogs and JWindows created with{@code null} owners.                
                <exception>
                    HeadlessException if GraphicsEnvironment.isHeadless()
                      returns true.                    
                </exception>
                <see>
                    java.awt.GraphicsEnvironment#isHeadless                    
                </see>
            </javadoc>
            <method name="getSharedOwnerFrame" type="Frame" line="1827">
                <declaration name="sharedOwnerFrame" type="Frame" line="1828"/>
                <scope line="1830"/>
            </method>
            <javadoc line="1838">
                Returns a SharedOwnerFrame&apos;s shutdown listener to dispose the SharedOwnerFrame
                  if it has no more displayable children.                
                <exception>
                    HeadlessException if GraphicsEnvironment.isHeadless()
                      returns true.                    
                </exception>
                <see>
                    java.awt.GraphicsEnvironment#isHeadless                    
                </see>
            </javadoc>
            <method name="getSharedOwnerFrameShutdownListener" type="WindowListener" line="1845">
                <declaration name="sharedOwnerFrame" type="Frame" line="1846"/>
            </method>
            <method name="appContextGet" type="Object" line="1857">
                <params>
                    <param name="key" type="Object"/>
                </params>
            </method>
            <method name="appContextPut" type="void" line="1861">
                <params>
                    <param name="key" type="Object"/>
                    <param name="value" type="Object"/>
                </params>
            </method>
            <method name="appContextRemove" type="void" line="1865">
                <params>
                    <param name="key" type="Object"/>
                </params>
            </method>
            <method name="loadSystemClass" type="Class<?>" line="1870">
                <params>
                    <param name="className" type="String"/>
                </params>
            </method>
            <method name="isLeftToRight" type="boolean" line="1880">
                <params>
                    <param name="c" type="Component"/>
                </params>
            </method>
            <method name="SwingUtilities" type="constructor" line="1883"/>
            <javadoc line="1887">
                Returns true if the Icon &lt;code&gt;icon&lt;/code&gt; is an instance of
                  ImageIcon, and the image it contains is the same as &lt;code&gt;image&lt;/code&gt;.                
            </javadoc>
            <method name="doesIconReferenceImage" type="boolean" line="1891">
                <params>
                    <param name="icon" type="Icon"/>
                    <param name="image" type="Image"/>
                </params>
                <declaration name="iconImage" type="Image" line="1892"/>
            </method>
            <javadoc line="1897">
                Returns index of the first occurrence of &lt;code&gt;mnemonic&lt;/code&gt;
                  within string &lt;code&gt;text&lt;/code&gt;. Matching algorithm is not
                  case-sensitive.                
                <param>
                    text The text to search through, may be {@code null}                    
                </param>
                <param>
                    mnemonic The mnemonic to find the character for.                    
                </param>
                <return>
                    index into the string if exists, otherwise -1                    
                </return>
            </javadoc>
            <method name="findDisplayedMnemonicIndex" type="int" line="1906">
                <params>
                    <param name="text" type="String"/>
                    <param name="mnemonic" type="int"/>
                </params>
                <scope line="1907"/>
                <declaration name="uc" type="char" line="1911"/>
                <declaration name="lc" type="char" line="1912"/>
                <declaration name="uci" type="int" line="1914"/>
                <declaration name="lci" type="int" line="1915"/>
                <scope line="1917"/>
                <scope line="1919"/>
                <scope line="1921"/>
            </method>
            <javadoc line="1926">
                Stores the position and size of
                  the inner painting area of the specified component
                  in &lt;code&gt;r&lt;/code&gt; and returns &lt;code&gt;r&lt;/code&gt;.
                  The position and size specify the bounds of the component,
                  adjusted so as not to include the border area (the insets).
                  This method is useful for classes
                  that implement painting code.                
                <param>
                    c  the JComponent in question; if {@code null}, this method returns {@code null}                    
                </param>
                <param>
                    r  the Rectangle instance to be modified;
                      may be {@code null}                    
                </param>
                <return>
                    {@code null} if the Component is {@code null};
                      otherwise, returns the passed-in rectangle (if non-{@code null})
                      or a new rectangle specifying position and size information                    
                </return>
                <since>
                    1.4                    
                </since>
            </javadoc>
            <method name="calculateInnerArea" type="Rectangle" line="1944">
                <params>
                    <param name="c" type="JComponent"/>
                    <param name="r" type="Rectangle"/>
                </params>
                <scope line="1945"/>
                <declaration name="rect" type="Rectangle" line="1948"/>
                <declaration name="insets" type="Insets" line="1949"/>
                <scope line="1951"/>
            </method>
            <method name="updateRendererOrEditorUI" type="void" line="1963">
                <params>
                    <param name="rendererOrEditor" type="Object"/>
                </params>
                <scope line="1964"/>
                <declaration name="component" type="Component" line="1968"/>
                <scope line="1970"/>
                <scope line="1973"/>
                <scope line="1977"/>
            </method>
            <javadoc line="1982">
                Returns the first ancestor of the {@code component}which is not an instance of {@link JLayer}.                
                <param>
                    component {@code Component} to get
                      the first ancestor of, which is not a {@link JLayer} instance.                    
                </param>
                <return>
                    the first ancestor of the {@code component}which is not an instance of {@link JLayer}.
                      If such an ancestor can not be found, {@code null} is returned.                    
                </return>
                <throws>
                    NullPointerException if {@code component} is {@code null}                    
                </throws>
                <see>
                    JLayer                    
                </see>
                <since>
                    1.7                    
                </since>
            </javadoc>
            <method name="getUnwrappedParent" type="Container" line="1998">
                <params>
                    <param name="component" type="Component"/>
                </params>
                <declaration name="parent" type="Container" line="1999"/>
                <scope line="2000"/>
            </method>
            <javadoc line="2006">
                Returns the first {@code JViewport}&apos;s descendant
                  which is not an instance of {@code JLayer}.
                  If such a descendant can not be found, {@code null} is returned.
                  If the {@code viewport}&apos;s view component is not a {@code JLayer},
                  this method is equivalent to {@link JViewport#getView()}otherwise {@link JLayer#getView()} will be recursively
                  called on all descending {@code JLayer}s.                
                <param>
                    viewport {@code JViewport} to get the first descendant of,
                      which in not a {@code JLayer} instance.                    
                </param>
                <return>
                    the first {@code JViewport}&apos;s descendant
                      which is not an instance of {@code JLayer}.
                      If such a descendant can not be found, {@code null} is returned.                    
                </return>
                <throws>
                    NullPointerException if {@code viewport} is {@code null}                    
                </throws>
                <see>
                    JViewport#getView()                    
                </see>
                <see>
                    JLayer                    
                </see>
                <since>
                    1.7                    
                </since>
            </javadoc>
            <method name="getUnwrappedView" type="Component" line="2029">
                <params>
                    <param name="viewport" type="JViewport"/>
                </params>
                <declaration name="view" type="Component" line="2030"/>
                <scope line="2031"/>
            </method>
            <javadoc line="2037">
                Retrieves the validate root of a given container.
                  If the container is contained within a {@code CellRendererPane}, this
                  method returns {@code null} due to the synthetic nature of the {@codeCellRendererPane}.
                  &lt;p&gt;
                  The component hierarchy must be displayable up to the toplevel component
                  (either a {@code Frame} or an {@code Applet} object.) Otherwise this
                  method returns {@code null}.
                  &lt;p&gt;
                  If the {@code visibleOnly} argument is {@code true}, the found validate
                  root and all its parents up to the toplevel component must also be
                  visible. Otherwise this method returns {@code null}.                
                <return>
                    the validate root of the given container or null                    
                </return>
                <see>
                    java.awt.Component#isDisplayable()                    
                </see>
                <see>
                    java.awt.Component#isVisible()                    
                </see>
                <since>
                    1.7                    
                </since>
            </javadoc>
            <method name="getValidateRoot" type="Container" line="2057">
                <params>
                    <param name="c" type="Container"/>
                    <param name="visibleOnly" type="boolean"/>
                </params>
                <declaration name="root" type="Container" line="2058"/>
                <scope line="2061">
                    <scope line="2062"/>
                    <scope line="2065"/>
                </scope>
                <scope line="2071"/>
                <scope line="2075">
                    <scope line="2076"/>
                    <scope line="2079"/>
                </scope>
            </method>
        </class>
    </source>