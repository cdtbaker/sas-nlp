<?xml version="1.0" encoding="UTF-8"?>
    <source package="javax.swing">
        <import package="java.awt"/>
        <import package="java.awt.event"/>
        <import package="java.awt.image.VolatileImage"/>
        <import package="java.awt.peer.ComponentPeer"/>
        <import package="java.applet.Applet"/>
        <import package="java.beans.Transient"/>
        <import package="javax.swing.plaf.ViewportUI"/>
        <import package="javax.swing.event"/>
        <import package="javax.swing.border"/>
        <import package="javax.accessibility"/>
        <import package="java.io.Serializable"/>
        <class name="JViewport" line="44">
            <extends class="JComponent"/>
            <comment line="163">
                Listener that is notified each time the view changes size.                
            </comment>
            <comment line="168">
                Only one &lt;code&gt;ChangeEvent&lt;code&gt; is needed per
                 &lt;code&gt;JViewport&lt;code&gt; instance since the
                 event&apos;s only (read-only) state is the source property.  The source
                 of events generated here is always &quot;this&quot;.                
            </comment>
            <comment line="213">
                Window blitting:
                
                 As mentioned in the javadoc when using windowBlit a paint event
                 will be generated by the system if copyArea copies a non-visible
                 portion of the view (in other words, it copies garbage). We are
                 not guaranteed to receive the paint event before other mouse events,
                 so we can not be sure we haven&apos;t already copied garbage a bunch of
                 times to different parts of the view. For that reason when a blit
                 happens and the Component is obscured (the check for obscurity
                 is not supported on all platforms and is checked via ComponentPeer
                 methods) the ivar repaintAll is set to true. When paint is received
                 if repaintAll is true (we previously did a blit) it is set to
                 false, and if the clip region is smaller than the viewport
                 waitingForRepaint is set to true and a timer is started. When
                 the timer fires if waitingForRepaint is true, repaint is invoked.
                 In the mean time, if the view is asked to scroll and waitingForRepaint
                 is true, a blit will not happen, instead the non-backing store case
                 of scrolling will happen, which will reset waitingForRepaint.
                 waitingForRepaint is set to false in paint when the clip rect is
                 bigger (or equal) to the size of the viewport.
                 A Timer is used instead of just a repaint as it appeared to offer
                 better performance.                
            </comment>
            <comment line="491">
                Used by the scrollRectToVisible method to determine the
                  proper direction and amount to move by. The integer variables are named
                  width, but this method is applicable to height also. The code assumes that
                  parentWidthchildWidth are positive and childAt can be negative.                
            </comment>
            <comment line="1410">
                Following is used when doBlit is true.                
            </comment>
            <comment line="1560">
                NOTE: the code below uses paintForceDoubleBuffered for historical
                 reasons.  If we&apos;re going to allow a blit we&apos;ve already accounted for
                 everything that paintImmediately and _paintImmediately does, for that
                 reason we call into paintForceDoubleBuffered to diregard whether or
                 not setDoubleBuffered(true) was invoked on the view.                
            </comment>
            <comment line="1704">
                ///////////////
                 Accessibility support                
            </comment>
            <comment line="1748">
                inner class AccessibleJViewport                
            </comment>
            <implements interface="Accessible"/>
            <javadoc line="44">
                The &quot;viewport&quot; or &quot;porthole&quot; through which you see the underlying
                  information. When you scroll, what moves is the viewport. It is like
                  peering through a camera&apos;s viewfinder. Moving the viewfinder upwards
                  brings new things into view at the top of the picture and loses
                  things that were at the bottom.
                  &lt;p&gt;
                  By default, &lt;code&gt;JViewport&lt;/code&gt; is opaque. To change this, use the
                  &lt;code&gt;setOpaque&lt;/code&gt; method.
                  &lt;p&gt;
                  &lt;b&gt;NOTE:&lt;/b&gt;We have implemented a faster scrolling algorithm that
                  does not require a buffer to draw in. The algorithm works as follows:
                  &lt;ol&gt;&lt;li&gt;The view and parent view and checked to see if they are
                  &lt;code&gt;JComponents&lt;/code&gt;,
                  if they aren&apos;t, stop and repaint the whole viewport.
                  &lt;li&gt;If the viewport is obscured by an ancestor, stop and repaint the whole
                  viewport.
                  &lt;li&gt;Compute the region that will become visible, if it is as big as
                  the viewport, stop and repaint the whole view region.
                  &lt;li&gt;Obtain the ancestor &lt;code&gt;Window&lt;/code&gt;&apos;s graphics and
                  do a &lt;code&gt;copyArea&lt;/code&gt; on the scrolled region.
                  &lt;li&gt;Message the view to repaint the newly visible region.
                  &lt;li&gt;The next time paint is invoked on the viewport, if the clip region
                  is smaller than the viewport size a timer is kicked off to repaint the
                  whole region.
                  &lt;/ol&gt;
                  In general this approach is much faster. Compared to the backing store
                  approach this avoids the overhead of maintaining an offscreen buffer and
                  having to do two &lt;code&gt;copyArea&lt;/code&gt;s.
                  Compared to the non backing store case this
                  approach will greatly reduce the painted region.
                  &lt;p&gt;
                  This approach can cause slower times than the backing store approach
                  when the viewport is obscured by another window, or partially offscreen.
                  When another window
                  obscures the viewport the copyArea will copy garbage and a
                  paint event will be generated by the system to inform us we need to
                  paint the newly exposed region. The only way to handle this is to
                  repaint the whole viewport, which can cause slower performance than the
                  backing store case. In most applications very rarely will the user be
                  scrolling while the viewport is obscured by another window or offscreen,
                  so this optimization is usually worth the performance hit when obscured.
                  &lt;p&gt;
                  &lt;strong&gt;Warning:&lt;/strong&gt; Swing is not thread safe. For more
                  information see &lt;a
                  href=&quot;package-summary.html#threading&quot;&gt;Swing&apos;s Threading
                  Policy&lt;/a&gt;.
                  &lt;p&gt;
                  &lt;strong&gt;Warning:&lt;/strong&gt;
                  Serialized objects of this class will not be compatible with
                  future Swing releases. The current serialization support is
                  appropriate for short term storage or RMI between applications running
                  the same version of Swing.  As of 1.4, support for long term storage
                  of all JavaBeans&lt;sup&gt;&lt;font size=&quot;-2&quot;&gt;TM&lt;/font&gt;&lt;/sup&gt;
                  has been added to the &lt;code&gt;java.beans&lt;/code&gt; package.
                  Please see {@link java.beans.XMLEncoder}.                
                <author>
                    Hans Muller                    
                </author>
                <author>
                    Philip Milne                    
                </author>
                <see>
                    JScrollPane                    
                </see>
            </javadoc>
            <declaration name="uiClassID" type="String" line="107"/>
            <javadoc line="107">
                @see #getUIClassID                
                <see>
                    #readObject                    
                </see>
            </javadoc>
            <declaration name="EnableWindowBlit" type="Object" line="113"/>
            <javadoc line="113">
                Property used to indicate window blitting should not be done.                
            </javadoc>
            <declaration name="isViewSizeSet" type="boolean" line="117"/>
            <javadoc line="117">
                True when the viewport dimensions have been determined.
                  The default is false.                
            </javadoc>
            <declaration name="lastPaintPosition" type="Point" line="123"/>
            <javadoc line="123">
                The last &lt;code&gt;viewPosition&lt;/code&gt; that we&apos;ve painted, so we know how
                  much of the backing store image is valid.                
            </javadoc>
            <declaration name="backingStore" type="boolean" line="129"/>
            <javadoc line="129">
                True when this viewport is maintaining an offscreen image of its
                  contents, so that some scrolling can take place using fast &quot;bit-blit&quot;
                  operations instead of by accessing the view object to construct the
                  display.  The default is &lt;code&gt;false&lt;/code&gt;.                
                <deprecated>
                    As of Java 2 platform v1.3                    
                </deprecated>
                <see>
                    #setScrollMode                    
                </see>
            </javadoc>
            <declaration name="backingStoreImage" type="Image" line="141"/>
            <javadoc line="141">
                The view image used for a backing store.                
            </javadoc>
            <declaration name="scrollUnderway" type="boolean" line="144"/>
            <javadoc line="144">
                The &lt;code&gt;scrollUnderway&lt;/code&gt; flag is used for components like
                  &lt;code&gt;JList&lt;/code&gt;.  When the downarrow key is pressed on a
                  &lt;code&gt;JList&lt;/code&gt; and the selected
                  cell is the last in the list, the &lt;code&gt;scrollpane&lt;/code&gt; autoscrolls.
                  Here, the old selected cell needs repainting and so we need
                  a flag to make the viewport do the optimized painting
                  only when there is an explicit call to
                  &lt;code&gt;setViewPosition(Point)&lt;/code&gt;.
                  When &lt;code&gt;setBounds&lt;/code&gt; is called through other routes,
                  the flag is off and the view repaints normally.  Another approach
                  would be to remove this from the &lt;code&gt;JViewport&lt;/code&gt;
                  class and have the &lt;code&gt;JList&lt;/code&gt; manage this case by using
                  &lt;code&gt;setBackingStoreEnabled&lt;/code&gt;.  The default is
                  &lt;code&gt;false&lt;/code&gt;.                
            </javadoc>
            <declaration name="viewListener" type="ComponentListener" line="165"/>
            <declaration name="changeEvent" type="ChangeEvent" line="172"/>
            <declaration name="BLIT_SCROLL_MODE" type="int" line="174"/>
            <javadoc line="174">
                Use &lt;code&gt;graphics.copyArea&lt;/code&gt; to implement scrolling.
                  This is the fastest for most applications.                
                <see>
                    #setScrollMode                    
                </see>
                <since>
                    1.3                    
                </since>
            </javadoc>
            <declaration name="BACKINGSTORE_SCROLL_MODE" type="int" line="183"/>
            <javadoc line="183">
                Draws viewport contents into an offscreen image.
                  This was previously the default mode for &lt;code&gt;JTable&lt;/code&gt;.
                  This mode may offer advantages over &quot;blit mode&quot;
                  in some cases, but it requires a large chunk of extra RAM.                
                <see>
                    #setScrollMode                    
                </see>
                <since>
                    1.3                    
                </since>
            </javadoc>
            <declaration name="SIMPLE_SCROLL_MODE" type="int" line="194"/>
            <javadoc line="194">
                This mode uses the very simple method of redrawing the entire
                  contents of the scrollpane each time it is scrolled.
                  This was the default behavior in Swing 1.0 and Swing 1.1.
                  Either of the other two options will provide better performance
                  in most cases.                
                <see>
                    #setScrollMode                    
                </see>
                <since>
                    1.3                    
                </since>
            </javadoc>
            <declaration name="scrollMode" type="int" line="206"/>
            <javadoc line="206">
                @see #setScrollMode                
                <since>
                    1.3                    
                </since>
            </javadoc>
            <declaration name="repaintAll" type="boolean" line="237"/>
            <javadoc line="237">
                This is set to true in &lt;code&gt;setViewPosition&lt;/code&gt;
                  if doing a window blit and the viewport is obscured.                
            </javadoc>
            <declaration name="waitingForRepaint" type="boolean" line="243"/>
            <javadoc line="243">
                This is set to true in paint, if &lt;code&gt;repaintAll&lt;/code&gt;
                  is true and the clip rectangle does not match the bounds.
                  If true, and scrolling happens the
                  repaint manager is not cleared which then allows for the repaint
                  previously invoked to succeed.                
            </javadoc>
            <declaration name="repaintTimer" type="Timer" line="252"/>
            <javadoc line="252">
                Instead of directly invoking repaint, a &lt;code&gt;Timer&lt;/code&gt;
                  is started and when it fires, repaint is invoked.                
            </javadoc>
            <declaration name="inBlitPaint" type="boolean" line="258"/>
            <javadoc line="258">
                Set to true in paintView when paint is invoked.                
            </javadoc>
            <declaration name="hasHadValidView" type="boolean" line="263"/>
            <javadoc line="263">
                Whether or not a valid view has been installed.                
            </javadoc>
            <javadoc line="268">
                Creates a &lt;code&gt;JViewport&lt;/code&gt;.                
            </javadoc>
            <method name="JViewport" type="constructor" line="269"/>
            <javadoc line="279">
                Returns the L&amp;F object that renders this component.                
                <return>
                    a &lt;code&gt;ViewportUI&lt;/code&gt; object                    
                </return>
                <since>
                    1.3                    
                </since>
            </javadoc>
            <method name="getUI" type="ViewportUI" line="285"/>
            <javadoc line="290">
                Sets the L&amp;F object that renders this component.                
                <param>
                    ui  the &lt;code&gt;ViewportUI&lt;/code&gt; L&amp;F object                    
                </param>
                <see>
                    UIDefaults#getUI                    
                </see>
                <beaninfo>
                    bound: true
                      hidden: true
                      attribute: visualUpdate true
                      description: The UI object that implements the Component&apos;s LookAndFeel.                    
                </beaninfo>
                <since>
                    1.3                    
                </since>
            </javadoc>
            <method name="setUI" type="void" line="302">
                <params>
                    <param name="ui" type="ViewportUI"/>
                </params>
            </method>
            <javadoc line="307">
                Resets the UI property to a value from the current look and feel.                
                <see>
                    JComponent#updateUI                    
                </see>
            </javadoc>
            <method name="updateUI" type="void" line="312"/>
            <javadoc line="317">
                Returns a string that specifies the name of the L&amp;F class
                  that renders this component.                
                <return>
                    the string &quot;ViewportUI&quot;                    
                </return>
                <see>
                    JComponent#getUIClassID                    
                </see>
                <see>
                    UIDefaults#getUI                    
                </see>
            </javadoc>
            <method name="getUIClassID" type="String" line="326"/>
            <javadoc line="331">
                Sets the &lt;code&gt;JViewport&lt;/code&gt;&apos;s one lightweight child,
                  which can be &lt;code&gt;null&lt;/code&gt;.
                  (Since there is only one child which occupies the entire viewport,
                  the &lt;code&gt;constraints&lt;/code&gt; and &lt;code&gt;index&lt;/code&gt;
                  arguments are ignored.)                
                <param>
                    child       the lightweight &lt;code&gt;child&lt;/code&gt; of the viewport                    
                </param>
                <param>
                    constraints the &lt;code&gt;constraints&lt;/code&gt; to be respected                    
                </param>
                <param>
                    index       the index                    
                </param>
                <see>
                    #setView                    
                </see>
            </javadoc>
            <method name="addImpl" type="void" line="343">
                <params>
                    <param name="child" type="Component"/>
                    <param name="constraints" type="Object"/>
                    <param name="index" type="int"/>
                </params>
            </method>
            <javadoc line="348">
                Removes the &lt;code&gt;Viewport&lt;/code&gt;s one lightweight child.                
                <see>
                    #setView                    
                </see>
            </javadoc>
            <method name="remove" type="void" line="353">
                <params>
                    <param name="child" type="Component"/>
                </params>
            </method>
            <javadoc line="359">
                Scrolls the view so that &lt;code&gt;Rectangle&lt;/code&gt;
                  within the view becomes visible.
                  &lt;p&gt;
                  This attempts to validate the view before scrolling if the
                  view is currently not valid - &lt;code&gt;isValid&lt;/code&gt; returns false.
                  To avoid excessive validation when the containment hierarchy is
                  being created this will not validate if one of the ancestors does not
                  have a peer, or there is no validate root ancestor, or one of the
                  ancestors is not a &lt;code&gt;Window&lt;/code&gt; or &lt;code&gt;Applet&lt;/code&gt;.
                  &lt;p&gt;
                  Note that this method will not scroll outside of the
                  valid viewport; for example, if &lt;code&gt;contentRect&lt;/code&gt; is larger
                  than the viewport, scrolling will be confined to the viewport&apos;s
                  bounds.                
                <param>
                    contentRect the &lt;code&gt;Rectangle&lt;/code&gt; to display                    
                </param>
                <see>
                    JComponent#isValidateRoot                    
                </see>
                <see>
                    java.awt.Component#isValid                    
                </see>
                <see>
                    java.awt.Component#getPeer                    
                </see>
            </javadoc>
            <method name="scrollRectToVisible" type="void" line="380">
                <params>
                    <param name="contentRect" type="Rectangle"/>
                </params>
                <comment line="388">
                    If the view is not valid, validate. scrollRectToVisible
                     may fail if the view is not valid first, contentRect
                     could be bigger than invalid size.                    
                </comment>
                <comment line="407">
                    Only constrain the location if the view is valid. If the
                     the view isn&apos;t valid, it typically indicates the view
                     isn&apos;t visible yet and most likely has a bogus size as will
                     we, and therefore we shouldn&apos;t constrain the scrolling                    
                </comment>
                <comment line="435">
                    NOTE: How JViewport currently works with the
                     backing store is not foolproof. The sequence of
                     events when setViewPosition
                     (scrollRectToVisible) is called is to reset the
                     views bounds, which causes a repaint on the
                     visible region and sets an ivar indicating
                     scrolling (scrollUnderway). When
                     JViewport.paint is invoked if scrollUnderway is
                     true, the backing store is blitted.  This fails
                     if between the time setViewPosition is invoked
                     and paint is received another repaint is queued
                     indicating part of the view is invalid. There
                     is no way for JViewport to notice another
                     repaint has occured and it ends up blitting
                     what is now a dirty region and the repaint is
                     never delivered.
                     It just so happens JTable encounters this
                     behavior by way of scrollRectToVisible, for
                     this reason scrollUnderway is set to false
                     here, which effectively disables the backing
                     store.                    
                </comment>
                <declaration name="view" type="Component" line="381"/>
                <scope line="383"/>
                <scope line="385">
                    <scope line="386"/>
                    <declaration name="dx" type="int" line="392"/>
                    <scope line="397">
                        <declaration name="viewPosition" type="Point" line="398"/>
                        <declaration name="viewSize" type="Dimension" line="399"/>
                        <declaration name="startX" type="int" line="400"/>
                        <declaration name="startY" type="int" line="401"/>
                        <declaration name="extent" type="Dimension" line="402"/>
                        <scope line="410">
                            <scope line="411">
                                <scope line="412"/>
                                <scope line="414"/>
                            </scope>
                            <scope line="417">
                                <scope line="418"/>
                                <scope line="420"/>
                            </scope>
                            <scope line="424"/>
                            <scope line="428"/>
                        </scope>
                        <scope line="432"/>
                    </scope>
                </scope>
            </method>
            <javadoc line="461">
                Ascends the &lt;code&gt;Viewport&lt;/code&gt;&apos;s parents stopping when
                  a component is found that returns
                  &lt;code&gt;true&lt;/code&gt; to &lt;code&gt;isValidateRoot&lt;/code&gt;.
                  If all the &lt;code&gt;Component&lt;/code&gt;&apos;s  parents are visible,
                  &lt;code&gt;validate&lt;/code&gt; will then be invoked on it. The
                  &lt;code&gt;RepaintManager&lt;/code&gt; is then invoked with
                  &lt;code&gt;removeInvalidComponent&lt;/code&gt;. This
                  is the synchronous version of a &lt;code&gt;revalidate&lt;/code&gt;.                
            </javadoc>
            <method name="validateView" type="void" line="471">
                <comment line="479">
                    Validate the root.                    
                </comment>
                <comment line="482">
                    And let the RepaintManager it does not have to validate from
                     validateRoot anymore.                    
                </comment>
                <declaration name="validateRoot" type="Component" line="472"/>
                <scope line="474"/>
                <declaration name="rm" type="RepaintManager" line="483"/>
                <scope line="485"/>
            </method>
            <method name="positionAdjustment" type="int" line="495">
                <params>
                    <param name="parentWidth" type="int"/>
                    <param name="childWidth" type="int"/>
                    <param name="childAt" type="int"/>
                </params>
                <comment line="498">
                    +-----+
                       | --- |     No Change
                       +-----+                    
                </comment>
                <comment line="505">
                    +-----+
                      ---------   No Change
                       +-----+                    
                </comment>
                <comment line="512">
                    +-----+          +-----+
                       |   ----    -&gt;   | ----|
                       +-----+          +-----+                    
                </comment>
                <comment line="519">
                    +-----+             +-----+
                       |  --------  -&gt;     |--------
                       +-----+             +-----+                    
                </comment>
                <comment line="526">
                    +-----+          +-----+
                     ----    |     -&gt;   |---- |
                       +-----+          +-----+                    
                </comment>
                <comment line="533">
                    +-----+             +-----+
                    -------- |      -&gt;   --------|
                       +-----+             +-----+                    
                </comment>
                <scope line="500"/>
                <scope line="507"/>
                <scope line="514"/>
                <scope line="521"/>
                <scope line="528"/>
                <scope line="535"/>
            </method>
            <javadoc line="543">
                The viewport &quot;scrolls&quot; its child (called the &quot;view&quot;) by the
                  normal parent/child clipping (typically the view is moved in
                  the opposite direction of the scroll).  A non-&lt;code&gt;null&lt;/code&gt; border,
                  or non-zero insets, isn&apos;t supported, to prevent the geometry
                  of this component from becoming complex enough to inhibit
                  subclassing.  To create a &lt;code&gt;JViewport&lt;/code&gt; with a border,
                  add it to a &lt;code&gt;JPanel&lt;/code&gt; that has a border.
                  &lt;p&gt;Note:  If &lt;code&gt;border&lt;/code&gt; is non-&lt;code&gt;null&lt;/code&gt;, this
                  method will throw an exception as borders are not supported on
                  a &lt;code&gt;JViewPort&lt;/code&gt;.                
                <param>
                    border the &lt;code&gt;Border&lt;/code&gt; to set                    
                </param>
                <exception>
                    IllegalArgumentException this method is not implemented                    
                </exception>
            </javadoc>
            <method name="setBorder" type="void" line="558">
                <params>
                    <param name="border" type="Border"/>
                </params>
                <scope line="559"/>
            </method>
            <javadoc line="565">
                Returns the insets (border) dimensions as (0,0,0,0), since borders
                  are not supported on a &lt;code&gt;JViewport&lt;/code&gt;.                
                <return>
                    a &lt;code&gt;Rectange&lt;/code&gt; of zero dimension and zero origin                    
                </return>
                <see>
                    #setBorder                    
                </see>
            </javadoc>
            <method name="getInsets" type="Insets" line="572"/>
            <javadoc line="576">
                Returns an &lt;code&gt;Insets&lt;/code&gt; object containing this
                  &lt;code&gt;JViewport&lt;/code&gt;s inset values.  The passed-in
                  &lt;code&gt;Insets&lt;/code&gt; object will be reinitialized, and
                  all existing values within this object are overwritten.                
                <param>
                    insets the &lt;code&gt;Insets&lt;/code&gt; object which can be reused                    
                </param>
                <return>
                    this viewports inset values                    
                </return>
                <see>
                    #getInsets                    
                </see>
                <beaninfo>
                    expert: true                    
                </beaninfo>
            </javadoc>
            <method name="getInsets" type="Insets" line="588">
                <params>
                    <param name="insets" type="Insets"/>
                </params>
            </method>
            <method name="getBackingStoreGraphics" type="Graphics" line="594">
                <params>
                    <param name="g" type="Graphics"/>
                </params>
                <declaration name="bsg" type="Graphics" line="595"/>
            </method>
            <method name="paintViaBackingStore" type="void" line="603">
                <params>
                    <param name="g" type="Graphics"/>
                </params>
                <declaration name="bsg" type="Graphics" line="604"/>
                <scope line="605"/>
                <scope line="608"/>
            </method>
            <method name="paintViaBackingStore" type="void" line="613">
                <params>
                    <param name="g" type="Graphics"/>
                    <param name="oClip" type="Rectangle"/>
                </params>
                <declaration name="bsg" type="Graphics" line="614"/>
                <scope line="615"/>
                <scope line="619"/>
            </method>
            <javadoc line="624">
                The &lt;code&gt;JViewport&lt;/code&gt; overrides the default implementation of
                  this method (in &lt;code&gt;JComponent&lt;/code&gt;) to return false.
                  This ensures
                  that the drawing machinery will call the &lt;code&gt;Viewport&lt;/code&gt;&apos;s
                  &lt;code&gt;paint&lt;/code&gt;
                  implementation rather than messaging the &lt;code&gt;JViewport&lt;/code&gt;&apos;s
                  children directly.                
                <return>
                    false                    
                </return>
            </javadoc>
            <method name="isOptimizedDrawingEnabled" type="boolean" line="635"/>
            <javadoc line="639">
                Returns true if scroll mode is a {@code BACKINGSTORE_SCROLL_MODE} to cause
                  painting to originate from {@code JViewport}, or one of its
                  ancestors. Otherwise returns {@code false}.                
                <return>
                    true if if scroll mode is a {@code BACKINGSTORE_SCROLL_MODE}.                    
                </return>
                <see>
                    JComponent#isPaintingOrigin()                    
                </see>
            </javadoc>
            <method name="isPaintingOrigin" type="boolean" line="647"/>
            <javadoc line="652">
                Only used by the paint method below.                
            </javadoc>
            <method name="getViewLocation" type="Point" line="655">
                <declaration name="view" type="Component" line="656"/>
                <scope line="657"/>
                <scope line="660"/>
            </method>
            <javadoc line="665">
                Depending on whether the &lt;code&gt;backingStore&lt;/code&gt; is enabled,
                  either paint the image through the backing store or paint
                  just the recently exposed part, using the backing store
                  to &quot;blit&quot; the remainder.
                  &lt;blockquote&gt;
                  The term &quot;blit&quot; is the pronounced version of the PDP-10
                  BLT (BLock Transfer) instruction, which copied a block of
                  bits. (In case you were curious.)
                  &lt;/blockquote&gt;                
                <param>
                    g the &lt;code&gt;Graphics&lt;/code&gt; context within which to paint                    
                </param>
            </javadoc>
            <method name="paint" type="void" line="679">
                <params>
                    <param name="g" type="Graphics"/>
                </params>
                <comment line="689">
                    We invoked paint as part of copyArea cleanup, let it through.                    
                </comment>
                <comment line="705">
                    We really don&apos;t need to paint, a future repaint will
                     take care of it, but if we don&apos;t we get an ugly flicker.                    
                </comment>
                <comment line="716">
                    Need a complete repaint before resetting waitingForRepaint                    
                </comment>
                <comment line="731">
                    If the view is smaller than the viewport and we are not opaque
                     (that is, we won&apos;t paint our background), we should set the
                     clip. Otherwise, as the bounds of the view vary, we will
                     blit garbage into the exposed areas.                    
                </comment>
                <comment line="741">
                    Backing store is enabled but this is the first call to paint.
                     Create the backing store, paint it and then copy to g.
                     The backing store image will be created with the size of
                     the viewport. We must make sure the clip region is the
                     same size, otherwise when scrolling the backing image
                     the region outside of the clipped region will not be painted,
                     and result in empty areas.                    
                </comment>
                <comment line="766">
                    No scrolling happened: repaint required area via backing store.                    
                </comment>
                <comment line="769">
                    The image was scrolled. Manipulate the backing store and flush it to g.                    
                </comment>
                <comment line="780">
                    The image was either moved diagonally or
                     moved by more than the image size: paint normally.                    
                </comment>
                <comment line="787">
                    Move the relevant part of the backing store.                    
                </comment>
                <comment line="789">
                    We don&apos;t want to inherit the clip region when copying
                     bits, if it is inherited it will result in not moving
                     all of the image resulting in garbage appearing on
                     the screen.                    
                </comment>
                <comment line="799">
                    Paint the rest of the view; the part that has just been exposed.                    
                </comment>
                <comment line="804">
                    Copy whole of the backing store to g.                    
                </comment>
                <declaration name="width" type="int" line="680"/>
                <declaration name="height" type="int" line="681"/>
                <scope line="683"/>
                <scope line="687"/>
                <scope line="693">
                    <declaration name="clipB" type="Rectangle" line="695"/>
                    <scope line="697">
                        <scope line="699"/>
                    </scope>
                    <scope line="707">
                        <scope line="708"/>
                    </scope>
                </scope>
                <scope line="714">
                    <declaration name="clipB" type="Rectangle" line="716"/>
                    <scope line="718"/>
                </scope>
                <scope line="724"/>
                <declaration name="viewBounds" type="Rectangle" line="734"/>
                <scope line="735"/>
                <scope line="739">
                    <declaration name="clip" type="Rectangle" line="748"/>
                    <scope line="749">
                        <scope line="750"/>
                        <scope line="754"/>
                    </scope>
                    <scope line="759"/>
                </scope>
                <scope line="763">
                    <scope line="764"/>
                    <scope line="767">
                        <declaration name="blitFrom" type="Point" line="769"/>
                        <declaration name="blitTo" type="Point" line="770"/>
                        <declaration name="blitSize" type="Dimension" line="771"/>
                        <declaration name="blitPaint" type="Rectangle" line="772"/>
                        <declaration name="newLocation" type="Point" line="774"/>
                        <declaration name="dx" type="int" line="775"/>
                        <declaration name="dy" type="int" line="776"/>
                        <declaration name="canBlit" type="boolean" line="777"/>
                        <scope line="778"/>
                        <scope line="782">
                            <declaration name="bdx" type="int" line="783"/>
                            <declaration name="bdy" type="int" line="784"/>
                            <declaration name="clip" type="Rectangle" line="787"/>
                            <declaration name="bsg" type="Graphics" line="793"/>
                            <scope line="794">
                                <declaration name="r" type="Rectangle" line="799"/>
                            </scope>
                            <scope line="805"/>
                        </scope>
                    </scope>
                </scope>
            </method>
            <javadoc line="816">
                Sets the bounds of this viewport.  If the viewport&apos;s width
                  or height has changed, fire a &lt;code&gt;StateChanged&lt;/code&gt; event.                
                <param>
                    x left edge of the origin                    
                </param>
                <param>
                    y top edge of the origin                    
                </param>
                <param>
                    w width in pixels                    
                </param>
                <param>
                    h height in pixels                    
                </param>
                <see>
                    JComponent#reshape(int,int,int,int)                    
                </see>
            </javadoc>
            <method name="reshape" type="void" line="827">
                <params>
                    <param name="x" type="int"/>
                    <param name="y" type="int"/>
                    <param name="w" type="int"/>
                    <param name="h" type="int"/>
                </params>
                <declaration name="sizeChanged" type="boolean" line="828"/>
                <scope line="829"/>
                <scope line="833"/>
            </method>
            <javadoc line="839">
                Used to control the method of scrolling the viewport contents.
                  You may want to change this mode to get maximum performance for your
                  use case.                
                <param>
                    mode one of the following values:
                      &lt;ul&gt;
                      &lt;li&gt; JViewport.BLIT_SCROLL_MODE
                      &lt;li&gt; JViewport.BACKINGSTORE_SCROLL_MODE
                      &lt;li&gt; JViewport.SIMPLE_SCROLL_MODE
                      &lt;/ul&gt;                    
                </param>
                <see>
                    #BLIT_SCROLL_MODE                    
                </see>
                <see>
                    #BACKINGSTORE_SCROLL_MODE                    
                </see>
                <see>
                    #SIMPLE_SCROLL_MODE                    
                </see>
                <beaninfo>
                    bound: false
                      description: Method of moving contents for incremental scrolls.
                      enum: BLIT_SCROLL_MODE JViewport.BLIT_SCROLL_MODE
                      BACKINGSTORE_SCROLL_MODE JViewport.BACKINGSTORE_SCROLL_MODE
                      SIMPLE_SCROLL_MODE JViewport.SIMPLE_SCROLL_MODE                    
                </beaninfo>
                <since>
                    1.3                    
                </since>
            </javadoc>
            <method name="setScrollMode" type="void" line="864">
                <params>
                    <param name="mode" type="int"/>
                </params>
            </method>
            <javadoc line="869">
                Returns the current scrolling mode.                
                <return>
                    the &lt;code&gt;scrollMode&lt;/code&gt; property                    
                </return>
                <see>
                    #setScrollMode                    
                </see>
                <since>
                    1.3                    
                </since>
            </javadoc>
            <method name="getScrollMode" type="int" line="876"/>
            <javadoc line="880">
                Returns &lt;code&gt;true&lt;/code&gt; if this viewport is maintaining
                  an offscreen image of its contents.                
                <return>
                    &lt;code&gt;true&lt;/code&gt; if &lt;code&gt;scrollMode&lt;/code&gt; is
                      &lt;code&gt;BACKINGSTORE_SCROLL_MODE&lt;/code&gt;                    
                </return>
                <deprecated>
                    As of Java 2 platform v1.3, replaced by
                      &lt;code&gt;getScrollMode()&lt;/code&gt;.                    
                </deprecated>
            </javadoc>
            <method name="isBackingStoreEnabled" type="boolean" line="891"/>
            <javadoc line="896">
                If true if this viewport will maintain an offscreen
                  image of its contents.  The image is used to reduce the cost
                  of small one dimensional changes to the &lt;code&gt;viewPosition&lt;/code&gt;.
                  Rather than repainting the entire viewport we use
                  &lt;code&gt;Graphics.copyArea&lt;/code&gt; to effect some of the scroll.                
                <param>
                    enabled if true, maintain an offscreen backing store                    
                </param>
                <deprecated>
                    As of Java 2 platform v1.3, replaced by
                      &lt;code&gt;setScrollMode()&lt;/code&gt;.                    
                </deprecated>
            </javadoc>
            <method name="setBackingStoreEnabled" type="void" line="909">
                <params>
                    <param name="enabled" type="boolean"/>
                </params>
                <scope line="910"/>
                <scope line="912"/>
            </method>
            <method name="isBlitting" type="boolean" line="917">
                <declaration name="view" type="Component" line="918"/>
            </method>
            <javadoc line="924">
                Returns the &lt;code&gt;JViewport&lt;/code&gt;&apos;s one child or &lt;code&gt;null&lt;/code&gt;.                
                <return>
                    the viewports child, or &lt;code&gt;null&lt;/code&gt; if none exists                    
                </return>
                <see>
                    #setView                    
                </see>
            </javadoc>
            <method name="getView" type="Component" line="931"/>
            <javadoc line="935">
                Sets the &lt;code&gt;JViewport&lt;/code&gt;&apos;s one lightweight child
                  (&lt;code&gt;view&lt;/code&gt;), which can be &lt;code&gt;null&lt;/code&gt;.                
                <param>
                    view the viewport&apos;s new lightweight child                    
                </param>
                <see>
                    #getView                    
                </see>
            </javadoc>
            <method name="setView" type="void" line="943">
                <params>
                    <param name="view" type="Component"/>
                </params>
                <comment line="946">
                    Remove the viewport&apos;s existing children, if any.
                     Note that removeAll() isn&apos;t used here because it
                     doesn&apos;t call remove() (which JViewport overrides).                    
                </comment>
                <comment line="964">
                    Only fire a change if a view has been installed.                    
                </comment>
                <declaration name="n" type="int" line="949"/>
                <scope line="950"/>
                <scope line="956"/>
                <scope line="962"/>
                <scope line="966"/>
            </method>
            <javadoc line="975">
                If the view&apos;s size hasn&apos;t been explicitly set, return the
                  preferred size, otherwise return the view&apos;s current size.
                  If there is no view, return 0,0.                
                <return>
                    a &lt;code&gt;Dimension&lt;/code&gt; object specifying the size of the view                    
                </return>
            </javadoc>
            <method name="getViewSize" type="Dimension" line="982">
                <declaration name="view" type="Component" line="983"/>
                <scope line="985"/>
                <scope line="988"/>
                <scope line="991"/>
            </method>
            <javadoc line="997">
                Sets the size of the view.  A state changed event will be fired.                
                <param>
                    newSize a &lt;code&gt;Dimension&lt;/code&gt; object specifying the new
                      size of the view                    
                </param>
            </javadoc>
            <method name="setViewSize" type="void" line="1003">
                <params>
                    <param name="newSize" type="Dimension"/>
                </params>
                <comment line="1009">
                    scrollUnderway will be true if this is invoked as the
                     result of a validate and setViewPosition was previously
                     invoked.                    
                </comment>
                <declaration name="view" type="Component" line="1004"/>
                <scope line="1005">
                    <declaration name="oldSize" type="Dimension" line="1006"/>
                    <scope line="1007"/>
                </scope>
            </method>
            <javadoc line="1019">
                Returns the view coordinates that appear in the upper left
                  hand corner of the viewport, or 0,0 if there&apos;s no view.                
                <return>
                    a &lt;code&gt;Point&lt;/code&gt; object giving the upper left coordinates                    
                </return>
            </javadoc>
            <method name="getViewPosition" type="Point" line="1025">
                <declaration name="view" type="Component" line="1026"/>
                <scope line="1027">
                    <declaration name="p" type="Point" line="1028"/>
                </scope>
                <scope line="1033"/>
            </method>
            <javadoc line="1039">
                Sets the view coordinates that appear in the upper left
                  hand corner of the viewport, does nothing if there&apos;s no view.                
                <param>
                    p  a &lt;code&gt;Point&lt;/code&gt; object giving the upper left coordinates                    
                </param>
            </javadoc>
            <method name="setViewPosition" type="void" line="1046">
                <params>
                    <param name="p" type="Point"/>
                </params>
                <comment line="1055">
                    Collect the old x,y values for the views location
                     and do the song and dance to avoid allocating
                     a Rectangle object if we don&apos;t have to.                    
                </comment>
                <comment line="1070">
                    The view scrolls in the opposite direction to mouse
                     movement.                    
                </comment>
                <comment line="1079">
                    The cast to JComponent will work, if view is not
                     a JComponent, isBlitting will return false.                    
                </comment>
                <comment line="1091">
                    Repaint the complete component if the blit succeeded
                     and needsRepaintAfterBlit returns true.                    
                </comment>
                <comment line="1104">
                    The visible region is dirty, no point in doing copyArea                    
                </comment>
                <comment line="1111">
                    This calls setBounds(), and then repaint().                    
                </comment>
                <comment line="1115">
                    we must validate the hierarchy to not break the hw/lw mixing                    
                </comment>
                <declaration name="view" type="Component" line="1047"/>
                <scope line="1048"/>
                <declaration name="oldX" type="int" line="1052"/>
                <scope line="1058">
                    <declaration name="c" type="JComponent" line="1059"/>
                </scope>
                <scope line="1063">
                    <declaration name="r" type="Rectangle" line="1064"/>
                </scope>
                <declaration name="newX" type="int" line="1072"/>
                <declaration name="newY" type="int" line="1073"/>
                <scope line="1075">
                    <scope line="1076">
                        <declaration name="rm" type="RepaintManager" line="1077"/>
                        <declaration name="jview" type="JComponent" line="1080"/>
                        <declaration name="dirty" type="Rectangle" line="1081"/>
                        <scope line="1082">
                            <scope line="1084">
                                <declaration name="g" type="Graphics" line="1085"/>
                            </scope>
                            <scope line="1098"/>
                        </scope>
                        <scope line="1102"/>
                    </scope>
                    <scope line="1108"/>
                </scope>
            </method>
            <javadoc line="1121">
                Returns a rectangle whose origin is &lt;code&gt;getViewPosition&lt;/code&gt;
                  and size is &lt;code&gt;getExtentSize&lt;/code&gt;.
                  This is the visible part of the view, in view coordinates.                
                <return>
                    a &lt;code&gt;Rectangle&lt;/code&gt; giving the visible part of
                      the view using view coordinates.                    
                </return>
            </javadoc>
            <method name="getViewRect" type="Rectangle" line="1129"/>
            <javadoc line="1134">
                Computes the parameters for a blit where the backing store image
                  currently contains &lt;code&gt;oldLoc&lt;/code&gt; in the upper left hand corner
                  and we&apos;re scrolling to &lt;code&gt;newLoc&lt;/code&gt;.
                  The parameters are modified
                  to return the values required for the blit.                
                <param>
                    dx  the horizontal delta                    
                </param>
                <param>
                    dy  the vertical delta                    
                </param>
                <param>
                    blitFrom the &lt;code&gt;Point&lt;/code&gt; we&apos;re blitting from                    
                </param>
                <param>
                    blitTo the &lt;code&gt;Point&lt;/code&gt; we&apos;re blitting to                    
                </param>
                <param>
                    blitSize the &lt;code&gt;Dimension&lt;/code&gt; of the area to blit                    
                </param>
                <param>
                    blitPaint the area to blit                    
                </param>
                <return>
                    true if the parameters are modified and we&apos;re ready to blit;
                      false otherwise                    
                </return>
            </javadoc>
            <method name="computeBlit" type="boolean" line="1157">
                <params>
                    <param name="dx" type="int"/>
                    <param name="dy" type="int"/>
                    <param name="blitFrom" type="Point"/>
                    <param name="blitTo" type="Point"/>
                    <param name="blitSize" type="Dimension"/>
                    <param name="blitPaint" type="Rectangle"/>
                </params>
                <declaration name="dxAbs" type="int" line="1158"/>
                <declaration name="dyAbs" type="int" line="1159"/>
                <declaration name="extentSize" type="Dimension" line="1160"/>
                <scope line="1162">
                    <scope line="1163"/>
                    <scope line="1168"/>
                </scope>
                <scope line="1185">
                    <scope line="1186"/>
                    <scope line="1191"/>
                </scope>
                <scope line="1208"/>
            </method>
            <javadoc line="1214">
                Returns the size of the visible part of the view in view coordinates.                
                <return>
                    a &lt;code&gt;Dimension&lt;/code&gt; object giving the size of the view                    
                </return>
            </javadoc>
            <method name="getExtentSize" type="Dimension" line="1220"/>
            <javadoc line="1225">
                Converts a size in pixel coordinates to view coordinates.
                  Subclasses of viewport that support &quot;logical coordinates&quot;
                  will override this method.                
                <param>
                    size  a &lt;code&gt;Dimension&lt;/code&gt; object using pixel coordinates                    
                </param>
                <return>
                    a &lt;code&gt;Dimension&lt;/code&gt; object converted to view coordinates                    
                </return>
            </javadoc>
            <method name="toViewCoordinates" type="Dimension" line="1233">
                <params>
                    <param name="size" type="Dimension"/>
                </params>
            </method>
            <javadoc line="1237">
                Converts a point in pixel coordinates to view coordinates.
                  Subclasses of viewport that support &quot;logical coordinates&quot;
                  will override this method.                
                <param>
                    p  a &lt;code&gt;Point&lt;/code&gt; object using pixel coordinates                    
                </param>
                <return>
                    a &lt;code&gt;Point&lt;/code&gt; object converted to view coordinates                    
                </return>
            </javadoc>
            <method name="toViewCoordinates" type="Point" line="1245">
                <params>
                    <param name="p" type="Point"/>
                </params>
            </method>
            <javadoc line="1250">
                Sets the size of the visible part of the view using view coordinates.                
                <param>
                    newExtent  a &lt;code&gt;Dimension&lt;/code&gt; object specifying
                      the size of the view                    
                </param>
            </javadoc>
            <method name="setExtentSize" type="void" line="1256">
                <params>
                    <param name="newExtent" type="Dimension"/>
                </params>
                <declaration name="oldExtent" type="Dimension" line="1257"/>
                <scope line="1258"/>
            </method>
            <class name="ViewListener" line="1264">
                <extends class="ComponentAdapter"/>
                <implements interface="Serializable"/>
                <javadoc line="1264">
                    A listener for the view.
                      &lt;p&gt;
                      &lt;strong&gt;Warning:&lt;/strong&gt;
                      Serialized objects of this class will not be compatible with
                      future Swing releases. The current serialization support is
                      appropriate for short term storage or RMI between applications running
                      the same version of Swing.  As of 1.4, support for long term storage
                      of all JavaBeans&lt;sup&gt;&lt;font size=&quot;-2&quot;&gt;TM&lt;/font&gt;&lt;/sup&gt;
                      has been added to the &lt;code&gt;java.beans&lt;/code&gt; package.
                      Please see {@link java.beans.XMLEncoder}.                    
                </javadoc>
                <method name="componentResized" type="void" line="1278">
                    <params>
                        <param name="e" type="ComponentEvent"/>
                    </params>
                </method>
            </class>
            <javadoc line="1284">
                Creates a listener for the view.                
                <return>
                    a &lt;code&gt;ViewListener&lt;/code&gt;                    
                </return>
            </javadoc>
            <method name="createViewListener" type="ViewListener" line="1288"/>
            <javadoc line="1293">
                Subclassers can override this to install a different
                  layout manager (or &lt;code&gt;null&lt;/code&gt;) in the constructor.  Returns
                  the &lt;code&gt;LayoutManager&lt;/code&gt; to install on the &lt;code&gt;JViewport&lt;/code&gt;.                
                <return>
                    a &lt;code&gt;LayoutManager&lt;/code&gt;                    
                </return>
            </javadoc>
            <method name="createLayoutManager" type="LayoutManager" line="1300"/>
            <javadoc line="1305">
                Adds a &lt;code&gt;ChangeListener&lt;/code&gt; to the list that is
                  notified each time the view&apos;s
                  size, position, or the viewport&apos;s extent size has changed.                
                <param>
                    l the &lt;code&gt;ChangeListener&lt;/code&gt; to add                    
                </param>
                <see>
                    #removeChangeListener                    
                </see>
                <see>
                    #setViewPosition                    
                </see>
                <see>
                    #setViewSize                    
                </see>
                <see>
                    #setExtentSize                    
                </see>
            </javadoc>
            <method name="addChangeListener" type="void" line="1316">
                <params>
                    <param name="l" type="ChangeListener"/>
                </params>
            </method>
            <javadoc line="1320">
                Removes a &lt;code&gt;ChangeListener&lt;/code&gt; from the list that&apos;s notified each
                  time the views size, position, or the viewports extent size
                  has changed.                
                <param>
                    l the &lt;code&gt;ChangeListener&lt;/code&gt; to remove                    
                </param>
                <see>
                    #addChangeListener                    
                </see>
            </javadoc>
            <method name="removeChangeListener" type="void" line="1328">
                <params>
                    <param name="l" type="ChangeListener"/>
                </params>
            </method>
            <javadoc line="1332">
                Returns an array of all the &lt;code&gt;ChangeListener&lt;/code&gt;s added
                  to this JViewport with addChangeListener().                
                <return>
                    all of the &lt;code&gt;ChangeListener&lt;/code&gt;s added or an empty
                      array if no listeners have been added                    
                </return>
                <since>
                    1.4                    
                </since>
            </javadoc>
            <method name="getChangeListeners" type="ChangeListener[]" line="1340"/>
            <javadoc line="1344">
                Notifies all &lt;code&gt;ChangeListeners&lt;/code&gt; when the views
                  size, position, or the viewports extent size has changed.                
                <see>
                    #addChangeListener                    
                </see>
                <see>
                    #removeChangeListener                    
                </see>
                <see>
                    EventListenerList                    
                </see>
            </javadoc>
            <method name="fireStateChanged" type="void" line="1353">
                <declaration name="listeners" type="Object[]" line="1354"/>
                <scope line="1355">
                    <scope line="1356">
                        <scope line="1357"/>
                    </scope>
                </scope>
            </method>
            <javadoc line="1365">
                Always repaint in the parents coordinate system to make sure
                  only one paint is performed by the &lt;code&gt;RepaintManager&lt;/code&gt;.                
                <param>
                    tm   maximum time in milliseconds before update                    
                </param>
                <param>
                    x    the &lt;code&gt;x&lt;/code&gt; coordinate (pixels over from left)                    
                </param>
                <param>
                    y    the &lt;code&gt;y&lt;/code&gt; coordinate (pixels down from top)                    
                </param>
                <param>
                    w    the width                    
                </param>
                <param>
                    h   the height                    
                </param>
                <see>
                    java.awt.Component#update(java.awt.Graphics)                    
                </see>
            </javadoc>
            <method name="repaint" type="void" line="1376">
                <params>
                    <param name="tm" type="long"/>
                    <param name="x" type="int"/>
                    <param name="y" type="int"/>
                    <param name="w" type="int"/>
                    <param name="h" type="int"/>
                </params>
                <declaration name="parent" type="Container" line="1377"/>
            </method>
            <javadoc line="1385">
                Returns a string representation of this &lt;code&gt;JViewport&lt;/code&gt;.
                  This method
                  is intended to be used only for debugging purposes, and the
                  content and format of the returned string may vary between
                  implementations. The returned string may be empty but may not
                  be &lt;code&gt;null&lt;/code&gt;.                
                <return>
                    a string representation of this &lt;code&gt;JViewport&lt;/code&gt;                    
                </return>
            </javadoc>
            <method name="paramString" type="String" line="1395">
                <declaration name="isViewSizeSetString" type="String" line="1396"/>
                <declaration name="lastPaintPositionString" type="String" line="1398"/>
                <declaration name="scrollUnderwayString" type="String" line="1400"/>
            </method>
            <javadoc line="1413">
                Notifies listeners of a property change. This is subclassed to update
                  the &lt;code&gt;windowBlit&lt;/code&gt; property.
                  (The &lt;code&gt;putClientProperty&lt;/code&gt; property is final).                
                <param>
                    propertyName a string containing the property name                    
                </param>
                <param>
                    oldValue the old value of the property                    
                </param>
                <param>
                    newValue  the new value of the property                    
                </param>
            </javadoc>
            <method name="firePropertyChange" type="void" line="1423">
                <params>
                    <param name="propertyName" type="String"/>
                    <param name="oldValue" type="Object"/>
                    <param name="newValue" type="Object"/>
                </params>
                <scope line="1425">
                    <scope line="1426"/>
                    <scope line="1428"/>
                </scope>
            </method>
            <javadoc line="1434">
                Returns true if the component needs to be completely repainted after
                  a blit and a paint is received.                
            </javadoc>
            <method name="needsRepaintAfterBlit" type="boolean" line="1438">
                <comment line="1440">
                    Find the first heavy weight ancestor. isObscured and
                     canDetermineObscurity are only appropriate for heavy weights.                    
                </comment>
                <comment line="1453">
                    The peer says we aren&apos;t obscured, therefore we can assume
                     that we won&apos;t later be messaged to paint a portion that
                     we tried to blit that wasn&apos;t valid.
                     It is certainly possible that when we blited we were
                     obscured, and by the time this is invoked we aren&apos;t, but the
                     chances of that happening are pretty slim.                    
                </comment>
                <declaration name="heavyParent" type="Component" line="1441"/>
                <scope line="1443"/>
                <scope line="1447">
                    <declaration name="peer" type="ComponentPeer" line="1448"/>
                    <scope line="1451"/>
                </scope>
            </method>
            <method name="createRepaintTimer" type="Timer" line="1464">
                <comment line="1468">
                    waitingForRepaint will be false if a paint came down
                     with the complete clip rect, in which case we don&apos;t
                     have to cause a repaint.                    
                </comment>
                <anonymous_class line="1465">
                    <method name="actionPerformed" type="void" line="1466">
                        <params>
                            <param name="ae" type="ActionEvent"/>
                        </params>
                        <comment line="1468">
                            waitingForRepaint will be false if a paint came down
                             with the complete clip rect, in which case we don&apos;t
                             have to cause a repaint.                            
                        </comment>
                        <scope line="1470"/>
                    </method>
                </anonymous_class>
                <declaration name="timer" type="Timer" line="1465"/>
            </method>
            <javadoc line="1479">
                If the repaint manager has a dirty region for the view, the view is
                  asked to paint.                
                <param>
                    g  the &lt;code&gt;Graphics&lt;/code&gt; context within which to paint                    
                </param>
            </javadoc>
            <method name="flushViewDirtyRegion" type="void" line="1485">
                <params>
                    <param name="g" type="Graphics"/>
                    <param name="dirty" type="Rectangle"/>
                </params>
                <comment line="1493">
                    Only happens in 1.2                    
                </comment>
                <comment line="1498">
                    Only paint the dirty region if it is visible.                    
                </comment>
                <declaration name="view" type="JComponent" line="1486"/>
                <scope line="1487">
                    <declaration name="clip" type="Rectangle" line="1490"/>
                    <scope line="1491"/>
                    <scope line="1498"/>
                </scope>
            </method>
            <javadoc line="1504">
                Used when blitting.                
                <param>
                    g  the &lt;code&gt;Graphics&lt;/code&gt; context within which to paint                    
                </param>
                <return>
                    true if blitting succeeded; otherwise false                    
                </return>
            </javadoc>
            <method name="windowBlitPaint" type="boolean" line="1510">
                <params>
                    <param name="g" type="Graphics"/>
                </params>
                <comment line="1528">
                    The image was scrolled. Manipulate the backing store and flush
                     it to g.                    
                </comment>
                <comment line="1544">
                    Prepare the rest of the view; the part that has just been
                     exposed.                    
                </comment>
                <declaration name="width" type="int" line="1511"/>
                <declaration name="height" type="int" line="1512"/>
                <scope line="1514"/>
                <declaration name="retValue" type="boolean" line="1518"/>
                <declaration name="rm" type="RepaintManager" line="1519"/>
                <declaration name="view" type="JComponent" line="1520"/>
                <scope line="1523"/>
                <scope line="1526">
                    <declaration name="blitFrom" type="Point" line="1529"/>
                    <declaration name="blitTo" type="Point" line="1530"/>
                    <declaration name="blitSize" type="Dimension" line="1531"/>
                    <declaration name="blitPaint" type="Rectangle" line="1532"/>
                    <declaration name="newLocation" type="Point" line="1534"/>
                    <declaration name="dx" type="int" line="1535"/>
                    <declaration name="dy" type="int" line="1536"/>
                    <declaration name="canBlit" type="boolean" line="1537"/>
                    <scope line="1539"/>
                    <scope line="1542">
                        <declaration name="r" type="Rectangle" line="1545"/>
                    </scope>
                </scope>
            </method>
            <method name="blitDoubleBuffered" type="void" line="1570">
                <params>
                    <param name="view" type="JComponent"/>
                    <param name="g" type="Graphics"/>
                    <param name="clipX" type="int"/>
                    <param name="clipY" type="int"/>
                    <param name="clipW" type="int"/>
                    <param name="clipH" type="int"/>
                    <param name="blitFromX" type="int"/>
                    <param name="blitFromY" type="int"/>
                    <param name="blitToX" type="int"/>
                    <param name="blitToY" type="int"/>
                    <param name="blitW" type="int"/>
                    <param name="blitH" type="int"/>
                </params>
                <comment line="1572">
                    NOTE:
                       blitFrom/blitTo are in JViewport coordinates system
                         not the views coordinate space.
                       clip* are in the views coordinate space.                    
                </comment>
                <comment line="1580">
                    Shift the scrolled region                    
                </comment>
                <comment line="1584">
                    Paint the newly exposed region.                    
                </comment>
                <declaration name="rm" type="RepaintManager" line="1575"/>
                <declaration name="bdx" type="int" line="1576"/>
                <declaration name="bdy" type="int" line="1577"/>
                <declaration name="x" type="int" line="1584"/>
                <declaration name="y" type="int" line="1585"/>
            </method>
            <javadoc line="1592">
                Called to paint the view, usually when &lt;code&gt;blitPaint&lt;/code&gt;
                  can not blit.                
                <param>
                    g the &lt;code&gt;Graphics&lt;/code&gt; context within which to paint                    
                </param>
            </javadoc>
            <method name="paintView" type="void" line="1598">
                <params>
                    <param name="g" type="Graphics"/>
                </params>
                <comment line="1604">
                    Graphics is relative to JViewport, need to map to view&apos;s
                     coordinates space.                    
                </comment>
                <comment line="1615">
                    To avoid any problems that may result from the viewport being
                     bigger than the view we start painting from the viewport.                    
                </comment>
                <declaration name="clip" type="Rectangle" line="1599"/>
                <declaration name="view" type="JComponent" line="1600"/>
                <scope line="1602">
                    <declaration name="x" type="int" line="1605"/>
                    <declaration name="y" type="int" line="1606"/>
                </scope>
                <scope line="1613">
                    <scope line="1616"/>
                    <scope line="1619"/>
                </scope>
            </method>
            <javadoc line="1625">
                Returns true if the viewport is not obscured by one of its ancestors,
                  or its ancestors children and if the viewport is showing. Blitting
                  when the view isn&apos;t showing will work,
                  or rather &lt;code&gt;copyArea&lt;/code&gt; will work,
                  but will not produce the expected behavior.                
            </javadoc>
            <method name="canUseWindowBlitter" type="boolean" line="1632">
                <comment line="1639">
                    We&apos;re in the process of painting, don&apos;t blit. If we were
                     to blit we would draw on top of what we&apos;re already drawing,
                     so bail.                    
                </comment>
                <comment line="1650">
                    Part of the scrollpane needs to be repainted too, don&apos;t blit.                    
                </comment>
                <comment line="1697">
                    No Window parent.                    
                </comment>
                <scope line="1634"/>
                <scope line="1637"/>
                <declaration name="dirtyRegion" type="Rectangle" line="1644"/>
                <scope line="1648"/>
                <declaration name="clip" type="Rectangle" line="1653"/>
                <declaration name="oldClip" type="Rectangle" line="1654"/>
                <declaration name="tmp2" type="Rectangle" line="1655"/>
                <declaration name="parent" type="Container" line="1656"/>
                <declaration name="lastParent" type="Component" line="1657"/>
                <declaration name="x" type="int" line="1658"/>
                <scope line="1660">
                    <scope line="1672">
                        <declaration name="comps" type="Component" line="1673"/>
                        <declaration name="index" type="int" line="1674"/>
                        <scope line="1676">
                            <scope line="1677"/>
                        </scope>
                        <scope line="1683"/>
                    </scope>
                </scope>
                <scope line="1695"/>
            </method>
            <javadoc line="1707">
                Gets the AccessibleContext associated with this JViewport.
                  For viewports, the AccessibleContext takes the form of an
                  AccessibleJViewport.
                  A new AccessibleJViewport instance is created if necessary.                
                <return>
                    an AccessibleJViewport that serves as the
                      AccessibleContext of this JViewport                    
                </return>
            </javadoc>
            <method name="getAccessibleContext" type="AccessibleContext" line="1716">
                <scope line="1717"/>
            </method>
            <class name="AccessibleJViewport" line="1723">
                <extends class="AccessibleJComponent"/>
                <javadoc line="1723">
                    This class implements accessibility support for the
                      &lt;code&gt;JViewport&lt;/code&gt; class.  It provides an implementation of the
                      Java Accessibility API appropriate to viewport user-interface elements.
                      &lt;p&gt;
                      &lt;strong&gt;Warning:&lt;/strong&gt;
                      Serialized objects of this class will not be compatible with
                      future Swing releases. The current serialization support is
                      appropriate for short term storage or RMI between applications running
                      the same version of Swing.  As of 1.4, support for long term storage
                      of all JavaBeans&lt;sup&gt;&lt;font size=&quot;-2&quot;&gt;TM&lt;/font&gt;&lt;/sup&gt;
                      has been added to the &lt;code&gt;java.beans&lt;/code&gt; package.
                      Please see {@link java.beans.XMLEncoder}.                    
                </javadoc>
                <javadoc line="1738">
                    Get the role of this object.                    
                    <return>
                        an instance of AccessibleRole describing the role of
                          the object                        
                    </return>
                </javadoc>
                <method name="getAccessibleRole" type="AccessibleRole" line="1744"/>
            </class>
        </class>
    </source>