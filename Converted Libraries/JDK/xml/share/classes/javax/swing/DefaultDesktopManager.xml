<?xml version="1.0" encoding="UTF-8"?>
    <source package="javax.swing">
        <import package="com.sun.awt.AWTUtilities"/>
        <import package="sun.awt.AWTAccessor"/>
        <import package="sun.awt.SunToolkit"/>
        <import package="java.awt"/>
        <import package="java.beans.PropertyVetoException"/>
        <class name="DefaultDesktopManager" line="36">
            <comment line="283">
                implements javax.swing.DesktopManager                
            </comment>
            <comment line="292">
                implements javax.swing.DesktopManager                
            </comment>
            <comment line="390">
                implements javax.swing.DesktopManager                
            </comment>
            <comment line="406">
                implements javax.swing.DesktopManager                
            </comment>
            <comment line="448">
                implements javax.swing.DesktopManager                
            </comment>
            <comment line="636">
                =========== stuff for faster frame dragging ===================                
            </comment>
            <implements interface="DesktopManager"/>
            <implements interface="java.io.Serializable"/>
            <javadoc line="36">
                This is an implementation of the &lt;code&gt;DesktopManager&lt;/code&gt;.
                  It currently implements the basic behaviors for managing
                  &lt;code&gt;JInternalFrame&lt;/code&gt;s in an arbitrary parent.
                  &lt;code&gt;JInternalFrame&lt;/code&gt;s that are not children of a
                  &lt;code&gt;JDesktop&lt;/code&gt; will use this component
                  to handle their desktop-like actions.
                  &lt;p&gt;This class provides a policy for the various JInternalFrame methods,
                  it is not meant to be called directly rather the various JInternalFrame
                  methods will call into the DesktopManager.&lt;/p&gt;                
                <see>
                    JDesktopPane                    
                </see>
                <see>
                    JInternalFrame                    
                </see>
                <author>
                    David Kloba                    
                </author>
                <author>
                    Steve Wilson                    
                </author>
            </javadoc>
            <declaration name="HAS_BEEN_ICONIFIED_PROPERTY" type="String" line="51"/>
            <declaration name="DEFAULT_DRAG_MODE" type="int" line="53"/>
            <declaration name="OUTLINE_DRAG_MODE" type="int" line="54"/>
            <declaration name="FASTER_DRAG_MODE" type="int" line="55"/>
            <declaration name="dragMode" type="int" line="57"/>
            <declaration name="currentBounds" type="Rectangle" line="59"/>
            <declaration name="desktopGraphics" type="Graphics" line="60"/>
            <declaration name="desktopBounds" type="Rectangle" line="61"/>
            <declaration name="floatingItems" type="Rectangle[]" line="62"/>
            <declaration name="didDrag" type="boolean" line="64"/>
            <javadoc line="64">
                Set to true when the user actually drags a frame vs clicks on it
                  to start the drag operation.  This is only used when dragging with
                  FASTER_DRAG_MODE.                
            </javadoc>
            <javadoc line="71">
                Normally this method will not be called. If it is, it
                  try to determine the appropriate parent from the desktopIcon of the frame.
                  Will remove the desktopIcon from its parent if it successfully adds the frame.                
            </javadoc>
            <method name="openFrame" type="void" line="75">
                <params>
                    <param name="f" type="JInternalFrame"/>
                </params>
                <scope line="76"/>
            </method>
            <javadoc line="82">
                Removes the frame, and, if necessary, the
                  &lt;code&gt;desktopIcon&lt;/code&gt;, from its parent.                
                <param>
                    f the <code>JInternalFrame</code> to be removed                    
                </param>
            </javadoc>
            <method name="closeFrame" type="void" line="87">
                <params>
                    <param name="f" type="JInternalFrame"/>
                </params>
                <comment line="101">
                    Removes the focus.                    
                </comment>
                <comment line="113">
                    It was selected and was the last component on the desktop.                    
                </comment>
                <declaration name="d" type="JDesktopPane" line="88"/>
                <scope line="89"/>
                <declaration name="findNext" type="boolean" line="92"/>
                <declaration name="c" type="Container" line="93"/>
                <declaration name="nextFrame" type="JInternalFrame" line="94"/>
                <scope line="95">
                    <scope line="97"/>
                    <scope line="97"/>
                </scope>
                <scope line="99"/>
                <scope line="108">
                    <scope line="109"/>
                    <scope line="110"/>
                </scope>
                <scope line="111"/>
            </method>
            <javadoc line="117">
                Resizes the frame to fill its parents bounds.                
                <param>
                    f the frame to be resized                    
                </param>
            </javadoc>
            <method name="maximizeFrame" type="void" line="121">
                <params>
                    <param name="f" type="JInternalFrame"/>
                </params>
                <comment line="125">
                    In turn calls deiconifyFrame in the desktop manager.
                     That method will handle the maximization of the frame.                    
                </comment>
                <comment line="137">
                    Set the maximized frame as selected.                    
                </comment>
                <scope line="122">
                    <scope line="123"/>
                    <scope line="127"/>
                </scope>
                <scope line="129">
                    <declaration name="desktopBounds" type="Rectangle" line="131"/>
                </scope>
                <scope line="137"/>
                <scope line="139"/>
            </method>
            <javadoc line="143">
                Restores the frame back to its size and position prior
                  to a &lt;code&gt;maximizeFrame&lt;/code&gt; call.                
                <param>
                    f the <code>JInternalFrame</code> to be restored                    
                </param>
            </javadoc>
            <method name="minimizeFrame" type="void" line="148">
                <params>
                    <param name="f" type="JInternalFrame"/>
                </params>
                <comment line="150">
                    If the frame was an icon restore it back to an icon.                    
                </comment>
                <scope line="150"/>
                <scope line="155">
                    <declaration name="r" type="Rectangle" line="156"/>
                    <scope line="158"/>
                    <scope line="158"/>
                </scope>
            </method>
            <javadoc line="163">
                Removes the frame from its parent and adds its
                  &lt;code&gt;desktopIcon&lt;/code&gt; to the parent.                
                <param>
                    f the <code>JInternalFrame</code> to be iconified                    
                </param>
            </javadoc>
            <method name="iconifyFrame" type="void" line="168">
                <params>
                    <param name="f" type="JInternalFrame"/>
                </params>
                <comment line="178">
                    we must validate the hierarchy to not break the hw/lw mixing                    
                </comment>
                <comment line="193">
                    If we are maximized we already have the normal bounds recorded
                     don&apos;t try to re-record them, otherwise we incorrectly set the
                     normal bounds to maximized state.                    
                </comment>
                <comment line="206">
                    The icon is the last frame.                    
                </comment>
                <declaration name="desktopIcon" type="JInternalFrame.JDesktopIcon" line="169"/>
                <declaration name="c" type="Container" line="170"/>
                <declaration name="d" type="JDesktopPane" line="171"/>
                <declaration name="findNext" type="boolean" line="172"/>
                <scope line="174">
                    <declaration name="r" type="Rectangle" line="175"/>
                </scope>
                <scope line="182"/>
                <scope line="186">
                    <declaration name="lp" type="JLayeredPane" line="187"/>
                    <declaration name="layer" type="int" line="188"/>
                </scope>
                <scope line="195"/>
                <scope line="203">
                    <scope line="204"/>
                </scope>
            </method>
            <javadoc line="211">
                Removes the desktopIcon from its parent and adds its frame
                  to the parent.                
                <param>
                    f the <code>JInternalFrame</code> to be de-iconified                    
                </param>
            </javadoc>
            <method name="deiconifyFrame" type="void" line="216">
                <params>
                    <param name="f" type="JInternalFrame"/>
                </params>
                <comment line="223">
                    If the frame is to be restored to a maximized state make
                     sure it still fills the whole desktop.                    
                </comment>
                <declaration name="desktopIcon" type="JInternalFrame.JDesktopIcon" line="217"/>
                <declaration name="c" type="Container" line="218"/>
                <declaration name="d" type="JDesktopPane" line="219"/>
                <scope line="220">
                    <scope line="224">
                        <declaration name="desktopBounds" type="Rectangle" line="225"/>
                        <scope line="227"/>
                    </scope>
                    <scope line="233"/>
                    <scope line="237">
                        <scope line="238"/>
                        <scope line="240"/>
                    </scope>
                </scope>
            </method>
            <javadoc line="246">
                This will activate &lt;b&gt;f&lt;/b&gt; moving it to the front. It will
                  set the current active frame&apos;s (if any)
                  &lt;code&gt;IS_SELECTED_PROPERTY&lt;/code&gt; to &lt;code&gt;false&lt;/code&gt;.
                  There can be only one active frame across all Layers.                
                <param>
                    f the <code>JInternalFrame</code> to be activated                    
                </param>
            </javadoc>
            <method name="activateFrame" type="void" line="252">
                <params>
                    <param name="f" type="JInternalFrame"/>
                </params>
                <comment line="259">
                    fix for bug: 4162443                    
                </comment>
                <comment line="261">
                    If the frame is not in parent, its icon maybe, check it                    
                </comment>
                <comment line="266">
                    we only need to keep track of the currentActive InternalFrame, if any                    
                </comment>
                <comment line="270">
                    if not the same frame as the current active
                     we deactivate the current                    
                </comment>
                <declaration name="p" type="Container" line="253"/>
                <declaration name="c" type="Component[]" line="254"/>
                <declaration name="d" type="JDesktopPane" line="255"/>
                <declaration name="currentlyActiveFrame" type="JInternalFrame" line="256"/>
                <scope line="259"/>
                <scope line="266">
                    <scope line="267"/>
                </scope>
                <scope line="268">
                    <scope line="271">
                        <scope line="272"/>
                        <scope line="275"/>
                    </scope>
                    <scope line="277"/>
                </scope>
            </method>
            <method name="deactivateFrame" type="void" line="283">
                <params>
                    <param name="f" type="JInternalFrame"/>
                </params>
                <declaration name="d" type="JDesktopPane" line="284"/>
                <declaration name="currentlyActiveFrame" type="JInternalFrame" line="285"/>
            </method>
            <method name="beginDraggingFrame" type="void" line="292">
                <params>
                    <param name="f" type="JComponent"/>
                </params>
                <scope line="295">
                    <declaration name="desktop" type="Component" line="296"/>
                    <scope line="299"/>
                    <scope line="302"/>
                </scope>
            </method>
            <method name="setupDragMode" type="void" line="313">
                <params>
                    <param name="f" type="JComponent"/>
                </params>
                <declaration name="p" type="JDesktopPane" line="314"/>
                <declaration name="parent" type="Container" line="315"/>
                <scope line="317">
                    <declaration name="mode" type="String" line="318"/>
                    <declaration name="window" type="Window" line="319"/>
                    <scope line="320"/>
                    <scope line="322"/>
                    <scope line="327"/>
                    <scope line="329">
                        <scope line="330"/>
                        <scope line="334"/>
                        <scope line="336"/>
                    </scope>
                </scope>
            </method>
            <declaration name="currentLoc" type="Point" line="343"/>
            <javadoc line="345">
                Moves the visible location of the frame being dragged
                  to the location specified.  The means by which this occurs can vary depending
                  on the dragging algorithm being used.  The actual logical location of the frame
                  might not change until &lt;code&gt;endDraggingFrame&lt;/code&gt; is called.                
            </javadoc>
            <method name="dragFrame" type="void" line="351">
                <params>
                    <param name="f" type="JComponent"/>
                    <param name="newX" type="int"/>
                    <param name="newY" type="int"/>
                </params>
                <comment line="365">
                    Work around for 6635462: XOR mode may cause a SurfaceLost on first use.
                     Swing doesn&apos;t expect that its XOR drawRect did
                     not complete, so believes that on re-entering at
                     the next update location, that there is an XOR rect
                     to draw out at &quot;currentLoc&quot;. But in fact
                     its now got a new clean surface without that rect,
                     so drawing it &quot;out&quot; in fact draws it on, leaving garbage.
                     So only updateset currentLoc if the draw completed.                    
                </comment>
                <scope line="353">
                    <declaration name="desktopPane" type="JDesktopPane" line="354"/>
                    <scope line="355">
                        <declaration name="g" type="Graphics" line="356"/>
                        <scope line="359"/>
                        <declaration name="sData" type="sun.java2d.SurfaceData" line="373"/>
                        <scope line="376"/>
                    </scope>
                </scope>
                <scope line="382"/>
                <scope line="384"/>
            </method>
            <method name="endDraggingFrame" type="void" line="390">
                <params>
                    <param name="f" type="JComponent"/>
                </params>
                <scope line="391"/>
                <scope line="394">
                    <scope line="396"/>
                </scope>
            </method>
            <method name="beginResizingFrame" type="void" line="406">
                <params>
                    <param name="f" type="JComponent"/>
                    <param name="direction" type="int"/>
                </params>
            </method>
            <javadoc line="410">
                Calls &lt;code&gt;setBoundsForFrame&lt;/code&gt; with the new values.                
                <param>
                    f the component to be resized                    
                </param>
                <param>
                    newX the new x-coordinate                    
                </param>
                <param>
                    newY the new y-coordinate                    
                </param>
                <param>
                    newWidth the new width                    
                </param>
                <param>
                    newHeight the new height                    
                </param>
            </javadoc>
            <method name="resizeFrame" type="void" line="418">
                <params>
                    <param name="f" type="JComponent"/>
                    <param name="newX" type="int"/>
                    <param name="newY" type="int"/>
                    <param name="newWidth" type="int"/>
                    <param name="newHeight" type="int"/>
                </params>
                <comment line="434">
                    Work around for 6635462, see comment in dragFrame()                    
                </comment>
                <scope line="420"/>
                <scope line="422">
                    <declaration name="desktopPane" type="JDesktopPane" line="423"/>
                    <scope line="424">
                        <declaration name="g" type="Graphics" line="425"/>
                        <scope line="428"/>
                        <declaration name="sData" type="sun.java2d.SurfaceData" line="434"/>
                        <scope line="436"/>
                    </scope>
                </scope>
            </method>
            <method name="endResizingFrame" type="void" line="448">
                <params>
                    <param name="f" type="JComponent"/>
                </params>
                <scope line="449"/>
            </method>
            <javadoc line="456">
                This moves the &lt;code&gt;JComponent&lt;/code&gt; and repaints the damaged areas.                
            </javadoc>
            <method name="setBoundsForFrame" type="void" line="457">
                <params>
                    <param name="f" type="JComponent"/>
                    <param name="newX" type="int"/>
                    <param name="newY" type="int"/>
                    <param name="newWidth" type="int"/>
                    <param name="newHeight" type="int"/>
                </params>
                <comment line="460">
                    we must validate the hierarchy to not break the hw/lw mixing                    
                </comment>
            </method>
            <javadoc line="463">
                Convenience method to remove the desktopIcon of &lt;b&gt;f&lt;/b&gt; is necessary.                
            </javadoc>
            <method name="removeIconFor" type="void" line="464">
                <params>
                    <param name="f" type="JInternalFrame"/>
                </params>
                <declaration name="di" type="JInternalFrame.JDesktopIcon" line="465"/>
                <declaration name="c" type="Container" line="466"/>
                <scope line="467"/>
            </method>
            <javadoc line="473">
                The iconifyFrame() code calls this to determine the proper bounds
                  for the desktopIcon.                
            </javadoc>
            <method name="getBoundsForIconOf" type="Rectangle" line="477">
                <params>
                    <param name="f" type="JInternalFrame"/>
                </params>
                <comment line="479">
                    Get the icon for this internal frame and its preferred size                    
                </comment>
                <comment line="485">
                    Get the parent bounds and child components.                    
                </comment>
                <comment line="495">
                                        
                </comment>
                <comment line="503">
                    Iterate through valid default icon locations and return the
                     first one that does not intersect any other icons.                    
                </comment>
                <comment line="526">
                    Get the icon for this component                    
                </comment>
                <comment line="536">
                    found a child that&apos;s neither an internal frame nor
                    an icon. I don&apos;t believe this should happen, but at
                    present it does and causes a null pointer exception.
                    Even when that gets fixed, this code protects against                    
                </comment>
                <comment line="543">
                    If this icon intersects the current location, get next location.                    
                </comment>
                <comment line="556">
                    didn&apos;t find any useful children above. This probably shouldn&apos;t
                    happen, but this check protects against an npe if it ever does                    
                </comment>
                <declaration name="icon" type="JInternalFrame.JDesktopIcon" line="482"/>
                <declaration name="prefSize" type="Dimension" line="483"/>
                <declaration name="c" type="Container" line="488"/>
                <scope line="489"/>
                <scope line="493"/>
                <declaration name="parentBounds" type="Rectangle" line="498"/>
                <declaration name="components" type="Component[]" line="499"/>
                <declaration name="availableRectangle" type="Rectangle" line="507"/>
                <declaration name="currentIcon" type="JInternalFrame.JDesktopIcon" line="508"/>
                <declaration name="x" type="int" line="510"/>
                <declaration name="y" type="int" line="511"/>
                <declaration name="w" type="int" line="512"/>
                <declaration name="h" type="int" line="513"/>
                <declaration name="found" type="boolean" line="515"/>
                <scope line="517">
                    <scope line="523">
                        <scope line="529"/>
                        <scope line="532"/>
                        <scope line="546">
                            <scope line="547"/>
                        </scope>
                    </scope>
                    <scope line="562"/>
                </scope>
            </method>
            <javadoc line="571">
                Stores the bounds of the component just before a maximize call.                
                <param>
                    f the component about to be resized                    
                </param>
                <param>
                    r the normal bounds to be saved away                    
                </param>
            </javadoc>
            <method name="setPreviousBounds" type="void" line="576">
                <params>
                    <param name="f" type="JInternalFrame"/>
                    <param name="r" type="Rectangle"/>
                </params>
            </method>
            <javadoc line="580">
                Gets the normal bounds of the component prior to the component
                  being maximized.                
                <param>
                    f the <code>JInternalFrame</code> of interest                    
                </param>
                <return>
                    the normal bounds of the component                    
                </return>
            </javadoc>
            <method name="getPreviousBounds" type="Rectangle" line="586">
                <params>
                    <param name="f" type="JInternalFrame"/>
                </params>
            </method>
            <javadoc line="590">
                Sets that the component has been iconized and the bounds of the
                  &lt;code&gt;desktopIcon&lt;/code&gt; are valid.                
            </javadoc>
            <method name="setWasIcon" type="void" line="594">
                <params>
                    <param name="f" type="JInternalFrame"/>
                    <param name="value" type="Boolean"/>
                </params>
                <scope line="595"/>
            </method>
            <javadoc line="600">
                Returns &lt;code&gt;true&lt;/code&gt; if the component has been iconized
                  and the bounds of the &lt;code&gt;desktopIcon&lt;/code&gt; are valid,
                  otherwise returns &lt;code&gt;false&lt;/code&gt;.                
                <param>
                    f the <code>JInternalFrame</code> of interest                    
                </param>
                <return>
                    <code>true</code> if the component has been iconized;
                      otherwise returns <code>false</code>                    
                </return>
            </javadoc>
            <method name="wasIcon" type="boolean" line="609">
                <params>
                    <param name="f" type="JInternalFrame"/>
                </params>
            </method>
            <method name="getDesktopPane" type="JDesktopPane" line="614">
                <params>
                    <param name="frame" type="JComponent"/>
                </params>
                <comment line="619">
                    Find the JDesktopPane                    
                </comment>
                <declaration name="pane" type="JDesktopPane" line="615"/>
                <declaration name="c" type="Component" line="616"/>
                <scope line="619">
                    <scope line="620"/>
                    <scope line="623"/>
                    <scope line="626"/>
                </scope>
            </method>
            <method name="dragFrameFaster" type="void" line="637">
                <params>
                    <param name="f" type="JComponent"/>
                    <param name="newX" type="int"/>
                    <param name="newY" type="int"/>
                </params>
                <comment line="645">
                    move the frame                    
                </comment>
                <comment line="650">
                    Only initiate cleanup if we have actually done a drag.                    
                </comment>
                <comment line="655">
                    We reset the danger field as until now we haven&apos;t actually
                     moved the internal frame so we don&apos;t need to initiate repaint.                    
                </comment>
                <comment line="682">
                    since we couldn&apos;t blit we just redraw as fast as possible
                     the isDragging mucking is to avoid activating emergency
                     cleanup                    
                </comment>
                <comment line="690">
                    fake out the repaint manager.  We&apos;ll take care of everything                    
                </comment>
                <comment line="695">
                    compute the minimal newly exposed area
                     if the rects intersect then we use computeDifference.  Otherwise
                     we&apos;ll repaint the entire previous bounds                    
                </comment>
                <comment line="707">
                    Fix the damage                    
                </comment>
                <comment line="712">
                    new areas of blit were exposed                    
                </comment>
                <comment line="730">
                    update window if it&apos;s non-opaque                    
                </comment>
                <declaration name="previousBounds" type="Rectangle" line="639"/>
                <scope line="648"/>
                <scope line="652"/>
                <declaration name="floaterCollision" type="boolean" line="659"/>
                <declaration name="parent" type="JComponent" line="661"/>
                <declaration name="visBounds" type="Rectangle" line="662"/>
                <declaration name="currentManager" type="RepaintManager" line="664"/>
                <scope line="667">
                    <scope line="668"/>
                    <scope line="680"/>
                    <declaration name="dirtyRects" type="Rectangle[]" line="697"/>
                    <scope line="698"/>
                    <scope line="701"/>
                    <scope line="707"/>
                    <scope line="712">
                        <scope line="715"/>
                    </scope>
                </scope>
                <scope line="725"/>
                <declaration name="topLevel" type="Window" line="730"/>
                <declaration name="tk" type="Toolkit" line="731"/>
                <scope line="735"/>
            </method>
            <method name="isFloaterCollision" type="boolean" line="740">
                <params>
                    <param name="moveFrom" type="Rectangle"/>
                    <param name="moveTo" type="Rectangle"/>
                </params>
                <comment line="743">
                    System.out.println(&quot;no floaters&quot;);                    
                </comment>
                <scope line="741"/>
                <scope line="746">
                    <declaration name="intersectsFrom" type="boolean" line="747"/>
                    <scope line="748"/>
                    <declaration name="intersectsTo" type="boolean" line="751"/>
                    <scope line="752"/>
                </scope>
            </method>
            <method name="findFloatingItems" type="Rectangle[]" line="760">
                <params>
                    <param name="f" type="JComponent"/>
                </params>
                <comment line="770">
                    System.out.println(i);                    
                </comment>
                <declaration name="desktop" type="Container" line="761"/>
                <declaration name="children" type="Component[]" line="762"/>
                <declaration name="i" type="int" line="763"/>
                <scope line="764">
                    <scope line="765"/>
                </scope>
                <declaration name="floaters" type="Rectangle[]" line="770"/>
                <scope line="771"/>
            </method>
            <javadoc line="778">
                This method is here to clean up problems associated
                  with a race condition which can occur when the full contents
                  of a copyArea&apos;s source argument is not available onscreen.
                  This uses brute force to clean up in case of possible damage                
            </javadoc>
            <method name="emergencyCleanup" type="void" line="784">
                <params>
                    <param name="f" type="JComponent"/>
                </params>
                <comment line="797">
                    finalFrame.repaint();                    
                </comment>
                <comment line="799">
                    System.out.println(&quot;repair complete&quot;);                    
                </comment>
                <scope line="786">
                    <anonymous_class line="788">
                        <method name="run" type="void" line="789">
                            <comment line="797">
                                finalFrame.repaint();                                
                            </comment>
                            <comment line="799">
                                System.out.println(&quot;repair complete&quot;);                                
                            </comment>
                        </method>
                    </anonymous_class>
                </scope>
            </method>
        </class>
    </source>