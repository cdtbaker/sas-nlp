<?xml version="1.0" encoding="UTF-8"?>
    <source package="javax.swing">
        <import package="java.util.HashSet"/>
        <import package="java.util.Hashtable"/>
        <import package="java.util.Dictionary"/>
        <import package="java.util.Enumeration"/>
        <import package="java.util.Locale"/>
        <import package="java.util.Vector"/>
        <import package="java.util.EventListener"/>
        <import package="java.util.Set"/>
        <import package="java.util.Map"/>
        <import package="java.util.HashMap"/>
        <import package="java.awt"/>
        <import package="java.awt.event"/>
        <import package="java.awt.image.VolatileImage"/>
        <import package="java.awt.Graphics2D"/>
        <import package="java.awt.peer.LightweightPeer"/>
        <import package="java.awt.dnd.DropTarget"/>
        <import package="java.awt.font.FontRenderContext"/>
        <import package="java.beans.PropertyChangeListener"/>
        <import package="java.beans.VetoableChangeListener"/>
        <import package="java.beans.VetoableChangeSupport"/>
        <import package="java.beans.Transient"/>
        <import package="java.applet.Applet"/>
        <import package="java.io.Serializable"/>
        <import package="java.io.ObjectOutputStream"/>
        <import package="java.io.ObjectInputStream"/>
        <import package="java.io.IOException"/>
        <import package="java.io.ObjectInputValidation"/>
        <import package="java.io.InvalidObjectException"/>
        <import package="javax.swing.border"/>
        <import package="javax.swing.event"/>
        <import package="javax.swing.plaf"/>
        <import package="javax.swing.ClientPropertyKey"/>
        <import package="javax.accessibility"/>
        <import package="sun.swing.SwingUtilities2"/>
        <import package="sun.swing.UIClientPropertyKey"/>
        <class name="JComponent" line="69">
            <extends class="Container"/>
            <comment line="211">
                Following are the possible return values from getObscuredState.                
            </comment>
            <comment line="231">
                The following fields support set methods for the corresponding
                 java.awt.Component properties.                
            </comment>
            <comment line="239">
                Backing store for JComponent properties and listeners                
            </comment>
            <comment line="257">
                                
            </comment>
            <comment line="336">
                bit 10 is free                
            </comment>
            <comment line="1081">
                paint forcing use of the double buffer.  This is used for historical
                 reasons: JViewport, when scrolling, previously directly invoked paint
                 while turning off double buffering at the RepaintManager level, this
                 codes simulates that.                
            </comment>
            <comment line="3344">
                Inner classes can&apos;t get at this method from a super class                
            </comment>
            <comment line="3441">
                This class is used by the KeyboardState class to provide a single
                 instance that can be stored in the AppContext.                
            </comment>
            <comment line="3609">
                --- Accessibility Support ---                
            </comment>
            <comment line="3997">
                inner class AccessibleJComponent                
            </comment>
            <comment line="4097">
                Invoked from putClientProperty.  This is provided for subclasses
                 in Swing.                
            </comment>
            <comment line="4104">
                Sets the property with the specified name to the specified value if
                 the property has not already been set by the client program.
                 This method is used primarily to set UI defaults for properties
                 with primitive types, where the values cannot be marked with
                 UIResource.
                 @see LookAndFeel#installProperty
                 @param propertyName String containing the name of the property
                 @param value Object containing the property value                
            </comment>
            <comment line="4181">
                --- Transitional java.awt.Component Support ---
                 The methods and fields in this section will migrate to
                 java.awt.Component in the next JDK release.                
            </comment>
            <comment line="4514">
                XXX This method is implemented as a workaround to a JLS issue with ambiguous
                 methods. This should be removed once 4758654 is resolved.                
            </comment>
            <comment line="5313">
                These functions must be static so that they can be called from
                 subclasses inside the package, but whose inheritance hierarhcy includes
                 classes outside of the package below JComponent (e.g., JTextArea).                
            </comment>
            <comment line="5324">
                                
            </comment>
            <comment line="5360">
                                
            </comment>
            <implements interface="Serializable"/>
            <implements interface="TransferHandler.HasGetTransferHandler"/>
            <javadoc line="69">
                The base class for all Swing components except top-level containers.
                  To use a component that inherits from &lt;code&gt;JComponent&lt;/code&gt;,
                  you must place the component in a containment hierarchy
                  whose root is a top-level Swing container.
                  Top-level Swing containers --
                  such as &lt;code&gt;JFrame&lt;/code&gt;, &lt;code&gt;JDialog&lt;/code&gt;,
                  and &lt;code&gt;JApplet&lt;/code&gt; --
                  are specialized components
                  that provide a place for other Swing components to paint themselves.
                  For an explanation of containment hierarchies, see
                  &lt;a
                  href=&quot;http://java.sun.com/docs/books/tutorial/uiswing/overview/hierarchy.html&quot;&gt;Swing Components and the Containment Hierarchy&lt;/a&gt;,
                  a section in &lt;em&gt;The Java Tutorial&lt;/em&gt;.
                  &lt;p&gt;
                  The &lt;code&gt;JComponent&lt;/code&gt; class provides:
                  &lt;ul&gt;
                  &lt;li&gt;The base class for both standard and custom components
                  that use the Swing architecture.
                  &lt;li&gt;A &quot;pluggable look and feel&quot; (L&amp;F) that can be specified by the
                  programmer or (optionally) selected by the user at runtime.
                  The look and feel for each component is provided by a
                  &lt;em&gt;UI delegate&lt;/em&gt; -- an object that descends from{@link javax.swing.plaf.ComponentUI}.
                  See &lt;a
                  href=&quot;http://java.sun.com/docs/books/tutorial/uiswing/misc/plaf.html&quot;&gt;How
                  to Set the Look and Feel&lt;/a&gt;
                  in &lt;em&gt;The Java Tutorial&lt;/em&gt;
                  for more information.
                  &lt;li&gt;Comprehensive keystroke handling.
                  See the document &lt;a
                  href=&quot;http://java.sun.com/products/jfc/tsc/special_report/kestrel/keybindings.html&quot;&gt;Keyboard
                  Bindings in Swing&lt;/a&gt;,
                  an article in &lt;em&gt;The Swing Connection&lt;/em&gt;,
                  for more information.
                  &lt;li&gt;Support for tool tips --
                  short descriptions that pop up when the cursor lingers
                  over a component.
                  See &lt;a
                  href=&quot;http://java.sun.com/docs/books/tutorial/uiswing/components/tooltip.html&quot;&gt;How
                  to Use Tool Tips&lt;/a&gt;
                  in &lt;em&gt;The Java Tutorial&lt;/em&gt;
                  for more information.
                  &lt;li&gt;Support for accessibility.
                  &lt;code&gt;JComponent&lt;/code&gt; contains all of the methods in the
                  &lt;code&gt;Accessible&lt;/code&gt; interface,
                  but it doesn&apos;t actually implement the interface.  That is the
                  responsibility of the individual classes
                  that extend &lt;code&gt;JComponent&lt;/code&gt;.
                  &lt;li&gt;Support for component-specific properties.
                  With the {@link #putClientProperty}and {@link #getClientProperty} methods,
                  you can associate name-object pairs
                  with any object that descends from &lt;code&gt;JComponent&lt;/code&gt;.
                  &lt;li&gt;An infrastructure for painting
                  that includes double buffering and support for borders.
                  For more information see &lt;a
                  href=&quot;http://java.sun.com/docs/books/tutorial/uiswing/overview/draw.html&quot;&gt;Painting&lt;/a&gt; and
                  &lt;a href=&quot;http://java.sun.com/docs/books/tutorial/uiswing/misc/border.html&quot;&gt;How
                  to Use Borders&lt;/a&gt;,
                  both of which are sections in &lt;em&gt;The Java Tutorial&lt;/em&gt;.
                  &lt;/ul&gt;
                  For more information on these subjects, see the
                  &lt;a href=&quot;package-summary.html#package_description&quot;&gt;Swing package description&lt;/a&gt;
                  and &lt;em&gt;The Java Tutorial&lt;/em&gt; section
                  &lt;a href=&quot;http://java.sun.com/docs/books/tutorial/uiswing/components/jcomponent.html&quot;&gt;The JComponent Class&lt;/a&gt;.
                  &lt;p&gt;
                  &lt;code&gt;JComponent&lt;/code&gt; and its subclasses document default values
                  for certain properties.  For example, &lt;code&gt;JTable&lt;/code&gt; documents the
                  default row height as 16.  Each &lt;code&gt;JComponent&lt;/code&gt; subclass
                  that has a &lt;code&gt;ComponentUI&lt;/code&gt; will create the
                  &lt;code&gt;ComponentUI&lt;/code&gt; as part of its constructor.  In order
                  to provide a particular look and feel each
                  &lt;code&gt;ComponentUI&lt;/code&gt; may set properties back on the
                  &lt;code&gt;JComponent&lt;/code&gt; that created it.  For example, a custom
                  look and feel may require &lt;code&gt;JTable&lt;/code&gt;s to have a row
                  height of 24. The documented defaults are the value of a property
                  BEFORE the &lt;code&gt;ComponentUI&lt;/code&gt; has been installed.  If you
                  need a specific value for a particular property you should
                  explicitly set it.
                  &lt;p&gt;
                  In release 1.4, the focus subsystem was rearchitected.
                  For more information, see
                  &lt;a href=&quot;http://java.sun.com/docs/books/tutorial/uiswing/misc/focus.html&quot;&gt;
                  How to Use the Focus Subsystem&lt;/a&gt;,
                  a section in &lt;em&gt;The Java Tutorial&lt;/em&gt;.
                  &lt;p&gt;
                  &lt;strong&gt;Warning:&lt;/strong&gt; Swing is not thread safe. For more
                  information see &lt;a
                  href=&quot;package-summary.html#threading&quot;&gt;Swing&apos;s Threading
                  Policy&lt;/a&gt;.
                  &lt;p&gt;
                  &lt;strong&gt;Warning:&lt;/strong&gt;
                  Serialized objects of this class will not be compatible with
                  future Swing releases. The current serialization support is
                  appropriate for short term storage or RMI between applications running
                  the same version of Swing.  As of 1.4, support for long term storage
                  of all JavaBeans&lt;sup&gt;&lt;font size=&quot;-2&quot;&gt;TM&lt;/font&gt;&lt;/sup&gt;
                  has been added to the &lt;code&gt;java.beans&lt;/code&gt; package.
                  Please see {@link java.beans.XMLEncoder}.                
                <see>
                    KeyStroke                    
                </see>
                <see>
                    Action                    
                </see>
                <see>
                    #setBorder                    
                </see>
                <see>
                    #registerKeyboardAction                    
                </see>
                <see>
                    JOptionPane                    
                </see>
                <see>
                    #setDebugGraphicsOptions                    
                </see>
                <see>
                    #setToolTipText                    
                </see>
                <see>
                    #setAutoscrolls                    
                </see>
                <author>
                    Hans Muller                    
                </author>
                <author>
                    Arnaud Weber                    
                </author>
            </javadoc>
            <declaration name="uiClassID" type="String" line="186"/>
            <javadoc line="186">
                @see #getUIClassID                
                <see>
                    #writeObject                    
                </see>
            </javadoc>
            <declaration name="readObjectCallbacks" type="Hashtable&lt;ObjectInputStream,ReadObjectCallback&gt;" line="192"/>
            <javadoc line="192">
                @see #readObject                
            </javadoc>
            <declaration name="managingFocusForwardTraversalKeys" type="Set&lt;KeyStroke&gt;" line="198"/>
            <javadoc line="198">
                Keys to use for forward focus traversal when the JComponent is
                  managing focus.                
            </javadoc>
            <declaration name="managingFocusBackwardTraversalKeys" type="Set&lt;KeyStroke&gt;" line="204"/>
            <javadoc line="204">
                Keys to use for backward focus traversal when the JComponent is
                  managing focus.                
            </javadoc>
            <declaration name="NOT_OBSCURED" type="int" line="211"/>
            <declaration name="PARTIALLY_OBSCURED" type="int" line="212"/>
            <declaration name="COMPLETELY_OBSCURED" type="int" line="213"/>
            <declaration name="DEBUG_GRAPHICS_LOADED" type="boolean" line="215"/>
            <javadoc line="215">
                Set to true when DebugGraphics has been loaded.                
            </javadoc>
            <declaration name="INPUT_VERIFIER_SOURCE_KEY" type="Object" line="220"/>
            <javadoc line="220">
                Key used to look up a value from the AppContext to determine the
                  JComponent the InputVerifier is running for. That is, if
                  AppContext.get(INPUT_VERIFIER_SOURCE_KEY) returns non-null, it
                  indicates the EDT is calling into the InputVerifier from the
                  returned component.                
            </javadoc>
            <declaration name="isAlignmentXSet" type="boolean" line="233"/>
            <declaration name="alignmentX" type="float" line="234"/>
            <declaration name="isAlignmentYSet" type="boolean" line="235"/>
            <declaration name="alignmentY" type="float" line="236"/>
            <declaration name="ui" type="ComponentUI" line="242"/>
            <javadoc line="242">
                The look and feel delegate for this component.                
            </javadoc>
            <declaration name="listenerList" type="EventListenerList" line="244"/>
            <javadoc line="244">
                A list of event listeners for this component.                
            </javadoc>
            <declaration name="clientProperties" type="ArrayTable" line="247"/>
            <declaration name="vetoableChangeSupport" type="VetoableChangeSupport" line="248"/>
            <declaration name="autoscrolls" type="boolean" line="249"/>
            <javadoc line="249">
                Whether or not autoscroll has been enabled.                
            </javadoc>
            <declaration name="border" type="Border" line="253"/>
            <declaration name="flags" type="int" line="254"/>
            <declaration name="inputVerifier" type="InputVerifier" line="257"/>
            <declaration name="verifyInputWhenFocusTarget" type="boolean" line="259"/>
            <declaration name="paintingChild" type="Component" line="261"/>
            <javadoc line="261">
                Set in &lt;code&gt;_paintImmediately&lt;/code&gt;.
                  Will indicate the child that initiated the painting operation.
                  If &lt;code&gt;paintingChild&lt;/code&gt; is opaque, no need to paint
                  any child components after &lt;code&gt;paintingChild&lt;/code&gt;.
                  Test used in &lt;code&gt;paintChildren&lt;/code&gt;.                
            </javadoc>
            <declaration name="WHEN_FOCUSED" type="int" line="270"/>
            <javadoc line="270">
                Constant used for &lt;code&gt;registerKeyboardAction&lt;/code&gt; that
                  means that the command should be invoked when
                  the component has the focus.                
            </javadoc>
            <declaration name="WHEN_ANCESTOR_OF_FOCUSED_COMPONENT" type="int" line="277"/>
            <javadoc line="277">
                Constant used for &lt;code&gt;registerKeyboardAction&lt;/code&gt; that
                  means that the command should be invoked when the receiving
                  component is an ancestor of the focused component or is
                  itself the focused component.                
            </javadoc>
            <declaration name="WHEN_IN_FOCUSED_WINDOW" type="int" line="285"/>
            <javadoc line="285">
                Constant used for &lt;code&gt;registerKeyboardAction&lt;/code&gt; that
                  means that the command should be invoked when
                  the receiving component is in the window that has the focus
                  or is itself the focused component.                
            </javadoc>
            <declaration name="UNDEFINED_CONDITION" type="int" line="293"/>
            <javadoc line="293">
                Constant used by some of the APIs to mean that no condition is defined.                
            </javadoc>
            <declaration name="KEYBOARD_BINDINGS_KEY" type="String" line="298"/>
            <javadoc line="298">
                The key used by &lt;code&gt;JComponent&lt;/code&gt; to access keyboard bindings.                
            </javadoc>
            <declaration name="WHEN_IN_FOCUSED_WINDOW_BINDINGS" type="String" line="303"/>
            <javadoc line="303">
                An array of &lt;code&gt;KeyStroke&lt;/code&gt;s used for
                  &lt;code&gt;WHEN_IN_FOCUSED_WINDOW&lt;/code&gt; are stashed
                  in the client properties under this string.                
            </javadoc>
            <declaration name="TOOL_TIP_TEXT_KEY" type="String" line="310"/>
            <javadoc line="310">
                The comment to display when the cursor is over the component,
                  also known as a &quot;value tip&quot;, &quot;flyover help&quot;, or &quot;flyover label&quot;.                
            </javadoc>
            <declaration name="NEXT_FOCUS" type="String" line="316"/>
            <declaration name="popupMenu" type="JPopupMenu" line="318"/>
            <javadoc line="318">
                &lt;code&gt;JPopupMenu&lt;/code&gt; assigned to this component
                  and all of its childrens                
            </javadoc>
            <declaration name="IS_DOUBLE_BUFFERED" type="int" line="324"/>
            <javadoc line="324">
                Private flags                
            </javadoc>
            <declaration name="ANCESTOR_USING_BUFFER" type="int" line="326"/>
            <declaration name="IS_PAINTING_TILE" type="int" line="327"/>
            <declaration name="IS_OPAQUE" type="int" line="328"/>
            <declaration name="KEY_EVENTS_ENABLED" type="int" line="329"/>
            <declaration name="FOCUS_INPUTMAP_CREATED" type="int" line="330"/>
            <declaration name="ANCESTOR_INPUTMAP_CREATED" type="int" line="331"/>
            <declaration name="WIF_INPUTMAP_CREATED" type="int" line="332"/>
            <declaration name="ACTIONMAP_CREATED" type="int" line="333"/>
            <declaration name="CREATED_DOUBLE_BUFFER" type="int" line="334"/>
            <declaration name="IS_PRINTING" type="int" line="336"/>
            <declaration name="IS_PRINTING_ALL" type="int" line="337"/>
            <declaration name="IS_REPAINTING" type="int" line="338"/>
            <declaration name="WRITE_OBJ_COUNTER_FIRST" type="int" line="339"/>
            <javadoc line="339">
                Bits 14-21 are used to handle nested writeObject calls.                
            </javadoc>
            <declaration name="RESERVED_1" type="int" line="341"/>
            <declaration name="RESERVED_2" type="int" line="342"/>
            <declaration name="RESERVED_3" type="int" line="343"/>
            <declaration name="RESERVED_4" type="int" line="344"/>
            <declaration name="RESERVED_5" type="int" line="345"/>
            <declaration name="RESERVED_6" type="int" line="346"/>
            <declaration name="WRITE_OBJ_COUNTER_LAST" type="int" line="347"/>
            <declaration name="REQUEST_FOCUS_DISABLED" type="int" line="349"/>
            <declaration name="INHERITS_POPUP_MENU" type="int" line="350"/>
            <declaration name="OPAQUE_SET" type="int" line="351"/>
            <declaration name="AUTOSCROLLS_SET" type="int" line="352"/>
            <declaration name="FOCUS_TRAVERSAL_KEYS_FORWARD_SET" type="int" line="353"/>
            <declaration name="FOCUS_TRAVERSAL_KEYS_BACKWARD_SET" type="int" line="354"/>
            <declaration name="REVALIDATE_RUNNABLE_SCHEDULED" type="int" line="355"/>
            <declaration name="tempRectangles" type="java.util.List&lt;Rectangle&gt;" line="357"/>
            <javadoc line="357">
                Temporary rectangles.                
            </javadoc>
            <declaration name="focusInputMap" type="InputMap" line="362"/>
            <javadoc line="362">
                Used for &lt;code&gt;WHEN_FOCUSED&lt;/code&gt; bindings.                
            </javadoc>
            <declaration name="ancestorInputMap" type="InputMap" line="364"/>
            <javadoc line="364">
                Used for &lt;code&gt;WHEN_ANCESTOR_OF_FOCUSED_COMPONENT&lt;/code&gt; bindings.                
            </javadoc>
            <declaration name="windowInputMap" type="ComponentInputMap" line="366"/>
            <javadoc line="366">
                Used for &lt;code&gt;WHEN_IN_FOCUSED_KEY&lt;/code&gt; bindings.                
            </javadoc>
            <declaration name="actionMap" type="ActionMap" line="369"/>
            <javadoc line="369">
                ActionMap.                
            </javadoc>
            <declaration name="defaultLocale" type="String" line="372"/>
            <javadoc line="372">
                Key used to store the default locale in an AppContext                
            </javadoc>
            <declaration name="componentObtainingGraphicsFrom" type="Component" line="375"/>
            <declaration name="componentObtainingGraphicsFromLock" type="Object" line="376"/>
            <declaration name="aaTextInfo" type="Object" line="379"/>
            <javadoc line="379">
                AA text hints.                
            </javadoc>
            <method name="safelyGetGraphics" type="Graphics" line="384">
                <params>
                    <param name="c" type="Component"/>
                </params>
            </method>
            <method name="safelyGetGraphics" type="Graphics" line="388">
                <params>
                    <param name="c" type="Component"/>
                    <param name="root" type="Component"/>
                </params>
                <scope line="389">
                    <declaration name="g" type="Graphics" line="391"/>
                </scope>
            </method>
            <method name="getGraphicsInvoked" type="void" line="397">
                <params>
                    <param name="root" type="Component"/>
                </params>
                <scope line="398">
                    <declaration name="rootPane" type="JRootPane" line="399"/>
                    <scope line="400"/>
                </scope>
            </method>
            <javadoc line="407">
                Returns true if {@code c} is the component the graphics is being
                  requested of. This is intended for use when getGraphics is invoked.                
            </javadoc>
            <method name="isComponentObtainingGraphicsFrom" type="boolean" line="411">
                <params>
                    <param name="c" type="Component"/>
                </params>
                <scope line="412"/>
            </method>
            <javadoc line="417">
                Returns the Set of &lt;code&gt;KeyStroke&lt;/code&gt;s to use if the component
                  is managing focus for forward focus traversal.                
            </javadoc>
            <method name="getManagingFocusForwardTraversalKeys" type="Set<KeyStroke>" line="421">
                <scope line="422">
                    <scope line="423"/>
                </scope>
            </method>
            <javadoc line="433">
                Returns the Set of &lt;code&gt;KeyStroke&lt;/code&gt;s to use if the component
                  is managing focus for backward focus traversal.                
            </javadoc>
            <method name="getManagingFocusBackwardTraversalKeys" type="Set<KeyStroke>" line="437">
                <scope line="438">
                    <scope line="439"/>
                </scope>
            </method>
            <method name="fetchRectangle" type="Rectangle" line="450">
                <scope line="451">
                    <declaration name="rect" type="Rectangle" line="452"/>
                    <declaration name="size" type="int" line="453"/>
                    <scope line="454"/>
                    <scope line="457"/>
                </scope>
            </method>
            <method name="recycleRectangle" type="void" line="464">
                <params>
                    <param name="rect" type="Rectangle"/>
                </params>
                <scope line="465"/>
            </method>
            <javadoc line="470">
                Sets whether or not &lt;code&gt;getComponentPopupMenu&lt;/code&gt; should delegate
                  to the parent if this component does not have a &lt;code&gt;JPopupMenu&lt;/code&gt;
                  assigned to it.
                  &lt;p&gt;
                  The default value for this is false, but some &lt;code&gt;JComponent&lt;/code&gt;
                  subclasses that are implemented as a number of &lt;code&gt;JComponent&lt;/code&gt;s
                  may set this to true.
                  &lt;p&gt;
                  This is a bound property.                
                <param>
                    value whether or not the JPopupMenu is inherited                    
                </param>
                <see>
                    #setComponentPopupMenu                    
                </see>
                <beaninfo>
                    bound: true
                      description: Whether or not the JPopupMenu is inherited                    
                </beaninfo>
                <since>
                    1.5                    
                </since>
            </javadoc>
            <method name="setInheritsPopupMenu" type="void" line="488">
                <params>
                    <param name="value" type="boolean"/>
                </params>
                <declaration name="oldValue" type="boolean" line="489"/>
            </method>
            <javadoc line="494">
                Returns true if the JPopupMenu should be inherited from the parent.                
                <see>
                    #setComponentPopupMenu                    
                </see>
                <since>
                    1.5                    
                </since>
            </javadoc>
            <method name="getInheritsPopupMenu" type="boolean" line="500"/>
            <javadoc line="504">
                Sets the &lt;code&gt;JPopupMenu&lt;/code&gt; for this &lt;code&gt;JComponent&lt;/code&gt;.
                  The UI is responsible for registering bindings and adding the necessary
                  listeners such that the &lt;code&gt;JPopupMenu&lt;/code&gt; will be shown at
                  the appropriate time. When the &lt;code&gt;JPopupMenu&lt;/code&gt; is shown
                  depends upon the look and feel: some may show it on a mouse event,
                  some may enable a key binding.
                  &lt;p&gt;
                  If &lt;code&gt;popup&lt;/code&gt; is null, and &lt;code&gt;getInheritsPopupMenu&lt;/code&gt;
                  returns true, then &lt;code&gt;getComponentPopupMenu&lt;/code&gt; will be delegated
                  to the parent. This provides for a way to make all child components
                  inherit the popupmenu of the parent.
                  &lt;p&gt;
                  This is a bound property.                
                <param>
                    popup - the popup that will be assigned to this component
                      may be null                    
                </param>
                <see>
                    #getComponentPopupMenu                    
                </see>
                <beaninfo>
                    bound: true
                      preferred: true
                      description: Popup to show                    
                </beaninfo>
                <since>
                    1.5                    
                </since>
            </javadoc>
            <method name="setComponentPopupMenu" type="void" line="528">
                <params>
                    <param name="popup" type="JPopupMenu"/>
                </params>
                <scope line="529"/>
                <declaration name="oldPopup" type="JPopupMenu" line="532"/>
            </method>
            <javadoc line="537">
                Returns &lt;code&gt;JPopupMenu&lt;/code&gt; that assigned for this component.
                  If this component does not have a &lt;code&gt;JPopupMenu&lt;/code&gt; assigned
                  to it and &lt;code&gt;getInheritsPopupMenu&lt;/code&gt; is true, this
                  will return &lt;code&gt;getParent().getComponentPopupMenu()&lt;/code&gt; (assuming
                  the parent is valid.)                
                <return>
                    <code>JPopupMenu</code> assigned for this component
                      or <code>null</code> if no popup assigned                    
                </return>
                <see>
                    #setComponentPopupMenu                    
                </see>
                <since>
                    1.5                    
                </since>
            </javadoc>
            <method name="getComponentPopupMenu" type="JPopupMenu" line="549">
                <comment line="557">
                    Search parents for its popup                    
                </comment>
                <comment line="565">
                    Reached toplevel, break and return null                    
                </comment>
                <scope line="551"/>
                <scope line="555">
                    <declaration name="parent" type="Container" line="557"/>
                    <scope line="558">
                        <scope line="559"/>
                        <scope line="563"/>
                    </scope>
                </scope>
            </method>
            <javadoc line="575">
                Default &lt;code&gt;JComponent&lt;/code&gt; constructor.  This constructor does
                  very little initialization beyond calling the &lt;code&gt;Container&lt;/code&gt;
                  constructor.  For example, the initial layout manager is
                  &lt;code&gt;null&lt;/code&gt;. It does, however, set the component&apos;s locale
                  property to the value returned by
                  &lt;code&gt;JComponent.getDefaultLocale&lt;/code&gt;.                
                <see>
                    #getDefaultLocale                    
                </see>
            </javadoc>
            <method name="JComponent" type="constructor" line="585">
                <comment line="588">
                    We enable key events on all JComponents so that accessibility
                     bindings will work everywhere. This is a partial fix to BugID
                     4282211.                    
                </comment>
                <scope line="591"/>
            </method>
            <javadoc line="604">
                Resets the UI property to a value from the current look and feel.
                  &lt;code&gt;JComponent&lt;/code&gt; subclasses must override this method
                  like this:
                  &lt;pre&gt;
                  public void updateUI() {
                  setUI((SliderUI)UIManager.getUI(this);
                  }
                  &lt;/pre&gt;                
                <see>
                    #setUI                    
                </see>
                <see>
                    UIManager#getLookAndFeel                    
                </see>
                <see>
                    UIManager#getUI                    
                </see>
            </javadoc>
            <method name="updateUI" type="void" line="618"/>
            <javadoc line="621">
                Sets the look and feel delegate for this component.
                  &lt;code&gt;JComponent&lt;/code&gt; subclasses generally override this method
                  to narrow the argument type. For example, in &lt;code&gt;JSlider&lt;/code&gt;:
                  &lt;pre&gt;
                  public void setUI(SliderUI newUI) {
                  super.setUI(newUI);
                  }
                  &lt;/pre&gt;
                  &lt;p&gt;
                  Additionally &lt;code&gt;JComponent&lt;/code&gt; subclasses must provide a
                  &lt;code&gt;getUI&lt;/code&gt; method that returns the correct type.  For example:
                  &lt;pre&gt;
                  public SliderUI getUI() {
                  return (SliderUI)ui;
                  }
                  &lt;/pre&gt;                
                <param>
                    newUI the new UI delegate                    
                </param>
                <see>
                    #updateUI                    
                </see>
                <see>
                    UIManager#getLookAndFeel                    
                </see>
                <see>
                    UIManager#getUI                    
                </see>
                <beaninfo>
                    bound: true
                      hidden: true
                      attribute: visualUpdate true
                      description: The component's look and feel delegate.                    
                </beaninfo>
            </javadoc>
            <method name="setUI" type="void" line="649">
                <params>
                    <param name="newUI" type="ComponentUI"/>
                </params>
                <comment line="651">
                    We do not check that the UI instance is different
                     before allowing the switch in order to enable the
                     same UI instance with different default settings
                     to be installed.                    
                </comment>
                <comment line="659">
                    aaText shouldn&apos;t persist between look and feels, reset it.                    
                </comment>
                <declaration name="oldUI" type="ComponentUI" line="661"/>
                <scope line="663"/>
            </method>
            <javadoc line="672">
                Uninstalls the UI, if any, and any client properties designated
                  as being specific to the installed UI - instances of{@code UIClientPropertyKey}.                
            </javadoc>
            <method name="uninstallUIAndProperties" type="void" line="677">
                <comment line="681">
                    clean UIClientPropertyKeys from client properties                    
                </comment>
                <scope line="678">
                    <scope line="681">
                        <scope line="682">
                            <declaration name="clientPropertyKeys" type="Object[]" line="683"/>
                            <scope line="685">
                                <scope line="686">
                                    <scope line="687"/>
                                </scope>
                            </scope>
                        </scope>
                    </scope>
                </scope>
            </method>
            <javadoc line="697">
                Returns the &lt;code&gt;UIDefaults&lt;/code&gt; key used to
                  look up the name of the &lt;code&gt;swing.plaf.ComponentUI&lt;/code&gt;
                  class that defines the look and feel
                  for this component.  Most applications will never need to
                  call this method.  Subclasses of &lt;code&gt;JComponent&lt;/code&gt; that support
                  pluggable look and feel should override this method to
                  return a &lt;code&gt;UIDefaults&lt;/code&gt; key that maps to the
                  &lt;code&gt;ComponentUI&lt;/code&gt; subclass that defines their look and feel.                
                <return>
                    the <code>UIDefaults</code> key for a
                      <code>ComponentUI</code> subclass                    
                </return>
                <see>
                    UIDefaults#getUI                    
                </see>
                <beaninfo>
                    expert: true
                      description: UIClassID                    
                </beaninfo>
            </javadoc>
            <method name="getUIClassID" type="String" line="714"/>
            <javadoc line="719">
                Returns the graphics object used to paint this component.
                  If &lt;code&gt;DebugGraphics&lt;/code&gt; is turned on we create a new
                  &lt;code&gt;DebugGraphics&lt;/code&gt; object if necessary.
                  Otherwise we just configure the
                  specified graphics object&apos;s foreground and font.                
                <param>
                    g the original <code>Graphics</code> object                    
                </param>
                <return>
                    a <code>Graphics</code> object configured for this component                    
                </return>
            </javadoc>
            <method name="getComponentGraphics" type="Graphics" line="729">
                <params>
                    <param name="g" type="Graphics"/>
                </params>
                <declaration name="componentGraphics" type="Graphics" line="730"/>
                <scope line="731">
                    <scope line="734"/>
                </scope>
            </method>
            <javadoc line="745">
                Calls the UI delegate&apos;s paint method, if the UI delegate
                  is non-&lt;code&gt;null&lt;/code&gt;.  We pass the delegate a copy of the
                  &lt;code&gt;Graphics&lt;/code&gt; object to protect the rest of the
                  paint code from irrevocable changes
                  (for example, &lt;code&gt;Graphics.translate&lt;/code&gt;).
                  &lt;p&gt;
                  If you override this in a subclass you should not make permanent
                  changes to the passed in &lt;code&gt;Graphics&lt;/code&gt;. For example, you
                  should not alter the clip &lt;code&gt;Rectangle&lt;/code&gt; or modify the
                  transform. If you need to do these operations you may find it
                  easier to create a new &lt;code&gt;Graphics&lt;/code&gt; from the passed in
                  &lt;code&gt;Graphics&lt;/code&gt; and manipulate it. Further, if you do not
                  invoker super&apos;s implementation you must honor the opaque property,
                  that is
                  if this component is opaque, you must completely fill in the background
                  in a non-opaque color. If you do not honor the opaque property you
                  will likely see visual artifacts.
                  &lt;p&gt;
                  The passed in &lt;code&gt;Graphics&lt;/code&gt; object might
                  have a transform other than the identify transform
                  installed on it.  In this case, you might get
                  unexpected results if you cumulatively apply
                  another transform.                
                <param>
                    g the <code>Graphics</code> object to protect                    
                </param>
                <see>
                    #paint                    
                </see>
                <see>
                    ComponentUI                    
                </see>
            </javadoc>
            <method name="paintComponent" type="void" line="774">
                <params>
                    <param name="g" type="Graphics"/>
                </params>
                <scope line="775">
                    <declaration name="scratchGraphics" type="Graphics" line="776"/>
                    <scope line="777"/>
                    <scope line="780"/>
                </scope>
            </method>
            <javadoc line="786">
                Paints this component&apos;s children.
                  If &lt;code&gt;shouldUseBuffer&lt;/code&gt; is true,
                  no component ancestor has a buffer and
                  the component children can use a buffer if they have one.
                  Otherwise, one ancestor has a buffer currently in use and children
                  should not use a buffer to paint.                
                <param>
                    g  the <code>Graphics</code> context in which to paint                    
                </param>
                <see>
                    #paint                    
                </see>
                <see>
                    java.awt.Container#paint                    
                </see>
            </javadoc>
            <method name="paintChildren" type="void" line="797">
                <params>
                    <param name="g" type="Graphics"/>
                </params>
                <comment line="806">
                    If we are only to paint to a specific child, determine
                     its index.                    
                </comment>
                <comment line="839">
                    Enable painting of heavyweights in non-opaque windows.
                     See 6884960                    
                </comment>
                <comment line="899">
                    The component is either lightweight, or
                     heavyweight in a non-opaque window                    
                </comment>
                <declaration name="sg" type="Graphics" line="798"/>
                <scope line="800">
                    <declaration name="i" type="int" line="801"/>
                    <scope line="802"/>
                    <scope line="809">
                        <scope line="810">
                            <scope line="811"/>
                        </scope>
                    </scope>
                    <declaration name="tmpRect" type="Rectangle" line="816"/>
                    <declaration name="checkSiblings" type="boolean" line="817"/>
                    <declaration name="clipBounds" type="Rectangle" line="819"/>
                    <scope line="820">
                        <scope line="822"/>
                    </scope>
                    <declaration name="printing" type="boolean" line="827"/>
                    <declaration name="window" type="Window" line="828"/>
                    <declaration name="isWindowOpaque" type="boolean" line="829"/>
                    <scope line="830">
                        <declaration name="comp" type="Component" line="831"/>
                        <scope line="832"/>
                        <declaration name="isJComponent" type="boolean" line="836"/>
                        <scope line="842">
                            <declaration name="cr" type="Rectangle" line="843"/>
                            <declaration name="hitClip" type="boolean" line="847"/>
                            <scope line="850">
                                <scope line="851">
                                    <declaration name="x" type="int" line="852"/>
                                    <declaration name="y" type="int" line="853"/>
                                    <declaration name="width" type="int" line="854"/>
                                    <declaration name="height" type="int" line="855"/>
                                    <scope line="861"/>
                                </scope>
                                <declaration name="cg" type="Graphics" line="869"/>
                                <declaration name="shouldSetFlagBack" type="boolean" line="873"/>
                                <scope line="874">
                                    <scope line="875">
                                        <scope line="876"/>
                                        <scope line="881"/>
                                        <scope line="886"/>
                                        <scope line="889">
                                            <scope line="890"/>
                                            <scope line="893"/>
                                        </scope>
                                    </scope>
                                    <scope line="897">
                                        <scope line="900"/>
                                        <scope line="903">
                                            <scope line="904"/>
                                            <scope line="907"/>
                                        </scope>
                                    </scope>
                                </scope>
                                <scope line="912">
                                    <scope line="914"/>
                                </scope>
                            </scope>
                        </scope>
                    </scope>
                </scope>
            </method>
            <javadoc line="929">
                Paints the component&apos;s border.
                  &lt;p&gt;
                  If you override this in a subclass you should not make permanent
                  changes to the passed in &lt;code&gt;Graphics&lt;/code&gt;. For example, you
                  should not alter the clip &lt;code&gt;Rectangle&lt;/code&gt; or modify the
                  transform. If you need to do these operations you may find it
                  easier to create a new &lt;code&gt;Graphics&lt;/code&gt; from the passed in
                  &lt;code&gt;Graphics&lt;/code&gt; and manipulate it.                
                <param>
                    g  the <code>Graphics</code> context in which to paint                    
                </param>
                <see>
                    #paint                    
                </see>
                <see>
                    #setBorder                    
                </see>
            </javadoc>
            <method name="paintBorder" type="void" line="944">
                <params>
                    <param name="g" type="Graphics"/>
                </params>
                <declaration name="border" type="Border" line="945"/>
                <scope line="946"/>
            </method>
            <javadoc line="952">
                Calls &lt;code&gt;paint&lt;/code&gt;.  Doesn&apos;t clear the background but see
                  &lt;code&gt;ComponentUI.update&lt;/code&gt;, which is called by
                  &lt;code&gt;paintComponent&lt;/code&gt;.                
                <param>
                    g the <code>Graphics</code> context in which to paint                    
                </param>
                <see>
                    #paint                    
                </see>
                <see>
                    #paintComponent                    
                </see>
                <see>
                    javax.swing.plaf.ComponentUI                    
                </see>
            </javadoc>
            <method name="update" type="void" line="962">
                <params>
                    <param name="g" type="Graphics"/>
                </params>
            </method>
            <javadoc line="967">
                Invoked by Swing to draw components.
                  Applications should not invoke &lt;code&gt;paint&lt;/code&gt; directly,
                  but should instead use the &lt;code&gt;repaint&lt;/code&gt; method to
                  schedule the component for redrawing.
                  &lt;p&gt;
                  This method actually delegates the work of painting to three
                  protected methods: &lt;code&gt;paintComponent&lt;/code&gt;,
                  &lt;code&gt;paintBorder&lt;/code&gt;,
                  and &lt;code&gt;paintChildren&lt;/code&gt;.  They&apos;re called in the order
                  listed to ensure that children appear on top of component itself.
                  Generally speaking, the component and its children should not
                  paint in the insets area allocated to the border. Subclasses can
                  just override this method, as always.  A subclass that just
                  wants to specialize the UI (look and feel) delegate&apos;s
                  &lt;code&gt;paint&lt;/code&gt; method should just override
                  &lt;code&gt;paintComponent&lt;/code&gt;.                
                <param>
                    g  the <code>Graphics</code> context in which to paint                    
                </param>
                <see>
                    #paintComponent                    
                </see>
                <see>
                    #paintBorder                    
                </see>
                <see>
                    #paintChildren                    
                </see>
                <see>
                    #getComponentGraphics                    
                </see>
                <see>
                    #repaint                    
                </see>
            </javadoc>
            <method name="paint" type="void" line="992">
                <params>
                    <param name="g" type="Graphics"/>
                </params>
                <comment line="1048">
                    Will ocassionaly happen in 1.2, especially when printing.                    
                </comment>
                <declaration name="shouldClearPaintFlags" type="boolean" line="993"/>
                <scope line="995"/>
                <declaration name="componentGraphics" type="Graphics" line="999"/>
                <declaration name="co" type="Graphics" line="1000"/>
                <scope line="1001">
                    <declaration name="repaintManager" type="RepaintManager" line="1002"/>
                    <declaration name="clipRect" type="Rectangle" line="1003"/>
                    <declaration name="clipX" type="int" line="1004"/>
                    <declaration name="clipY" type="int" line="1005"/>
                    <declaration name="clipW" type="int" line="1006"/>
                    <declaration name="clipH" type="int" line="1007"/>
                    <scope line="1008"/>
                    <scope line="1013"/>
                    <scope line="1020"/>
                    <scope line="1023"/>
                    <scope line="1027"/>
                    <declaration name="bw" type="int" line="1032"/>
                    <declaration name="printing" type="boolean" line="1033"/>
                    <scope line="1037">
                        <scope line="1039"/>
                        <scope line="1042"/>
                    </scope>
                    <scope line="1046">
                        <scope line="1048"/>
                        <scope line="1052">
                            <scope line="1053"/>
                            <scope line="1057"/>
                        </scope>
                        <scope line="1062"/>
                        <scope line="1065"/>
                    </scope>
                </scope>
                <scope line="1069">
                    <scope line="1071"/>
                </scope>
            </method>
            <method name="paintForceDoubleBuffered" type="void" line="1084">
                <params>
                    <param name="g" type="Graphics"/>
                </params>
                <declaration name="rm" type="RepaintManager" line="1085"/>
                <declaration name="clip" type="Rectangle" line="1086"/>
                <scope line="1089"/>
                <scope line="1091"/>
            </method>
            <javadoc line="1097">
                Returns true if this component, or any of its ancestors, are in
                  the processing of painting.                
            </javadoc>
            <method name="isPainting" type="boolean" line="1101">
                <declaration name="component" type="Container" line="1102"/>
                <scope line="1103">
                    <scope line="1105"/>
                </scope>
            </method>
            <method name="adjustPaintFlags" type="void" line="1113">
                <declaration name="jparent" type="JComponent" line="1114"/>
                <declaration name="parent" type="Container" line="1115"/>
                <scope line="1117">
                    <scope line="1118"/>
                </scope>
            </method>
            <javadoc line="1133">
                Invoke this method to print the component. This method invokes
                  &lt;code&gt;print&lt;/code&gt; on the component.                
                <param>
                    g the <code>Graphics</code> context in which to paint                    
                </param>
                <see>
                    #print                    
                </see>
                <see>
                    #printComponent                    
                </see>
                <see>
                    #printBorder                    
                </see>
                <see>
                    #printChildren                    
                </see>
            </javadoc>
            <method name="printAll" type="void" line="1143">
                <params>
                    <param name="g" type="Graphics"/>
                </params>
                <scope line="1145"/>
                <scope line="1148"/>
            </method>
            <javadoc line="1153">
                Invoke this method to print the component to the specified
                  &lt;code&gt;Graphics&lt;/code&gt;. This method will result in invocations
                  of &lt;code&gt;printComponent&lt;/code&gt;, &lt;code&gt;printBorder&lt;/code&gt; and
                  &lt;code&gt;printChildren&lt;/code&gt;. It is recommended that you override
                  one of the previously mentioned methods rather than this one if
                  your intention is to customize the way printing looks. However,
                  it can be useful to override this method should you want to prepare
                  state before invoking the superclass behavior. As an example,
                  if you wanted to change the component&apos;s background color before
                  printing, you could do the following:
                  &lt;pre&gt;
                  public void print(Graphics g) {
                  Color orig = getBackground();
                  setBackground(Color.WHITE);
                  // wrap in try/finally so that we always restore the state
                  try {
                  super.print(g);
                  } finally {
                  setBackground(orig);
                  }
                  }
                  &lt;/pre&gt;
                  &lt;p&gt;
                  Alternatively, or for components that delegate painting to other objects,
                  you can query during painting whether or not the component is in the
                  midst of a print operation. The &lt;code&gt;isPaintingForPrint&lt;/code&gt; method provides
                  this ability and its return value will be changed by this method: to
                  &lt;code&gt;true&lt;/code&gt; immediately before rendering and to &lt;code&gt;false&lt;/code&gt;
                  immediately after. With each change a property change event is fired on
                  this component with the name &lt;code&gt;&quot;paintingForPrint&quot;&lt;/code&gt;.
                  &lt;p&gt;
                  This method sets the component&apos;s state such that the double buffer
                  will not be used: painting will be done directly on the passed in
                  &lt;code&gt;Graphics&lt;/code&gt;.                
                <param>
                    g the <code>Graphics</code> context in which to paint                    
                </param>
                <see>
                    #printComponent                    
                </see>
                <see>
                    #printBorder                    
                </see>
                <see>
                    #printChildren                    
                </see>
                <see>
                    #isPaintingForPrint                    
                </see>
            </javadoc>
            <method name="print" type="void" line="1196">
                <params>
                    <param name="g" type="Graphics"/>
                </params>
                <scope line="1199"/>
                <scope line="1202"/>
            </method>
            <javadoc line="1208">
                This is invoked during a printing operation. This is implemented to
                  invoke &lt;code&gt;paintComponent&lt;/code&gt; on the component. Override this
                  if you wish to add special painting behavior when printing.                
                <param>
                    g the <code>Graphics</code> context in which to paint                    
                </param>
                <see>
                    #print                    
                </see>
                <since>
                    1.3                    
                </since>
            </javadoc>
            <method name="printComponent" type="void" line="1217">
                <params>
                    <param name="g" type="Graphics"/>
                </params>
            </method>
            <javadoc line="1221">
                Prints this component&apos;s children. This is implemented to invoke
                  &lt;code&gt;paintChildren&lt;/code&gt; on the component. Override this if you
                  wish to print the children differently than painting.                
                <param>
                    g the <code>Graphics</code> context in which to paint                    
                </param>
                <see>
                    #print                    
                </see>
                <since>
                    1.3                    
                </since>
            </javadoc>
            <method name="printChildren" type="void" line="1230">
                <params>
                    <param name="g" type="Graphics"/>
                </params>
            </method>
            <javadoc line="1234">
                Prints the component&apos;s border. This is implemented to invoke
                  &lt;code&gt;paintBorder&lt;/code&gt; on the component. Override this if you
                  wish to print the border differently that it is painted.                
                <param>
                    g the <code>Graphics</code> context in which to paint                    
                </param>
                <see>
                    #print                    
                </see>
                <since>
                    1.3                    
                </since>
            </javadoc>
            <method name="printBorder" type="void" line="1243">
                <params>
                    <param name="g" type="Graphics"/>
                </params>
            </method>
            <javadoc line="1247">
                Returns true if the component is currently painting a tile.
                  If this method returns true, paint will be called again for another
                  tile. This method returns false if you are not painting a tile or
                  if the last tile is painted.
                  Use this method to keep some state you might need between tiles.                
                <return>
                    true if the component is currently painting a tile,
                      false otherwise                    
                </return>
            </javadoc>
            <method name="isPaintingTile" type="boolean" line="1257"/>
            <javadoc line="1261">
                Returns &lt;code&gt;true&lt;/code&gt; if the current painting operation on this
                  component is part of a &lt;code&gt;print&lt;/code&gt; operation. This method is
                  useful when you want to customize what you print versus what you show
                  on the screen.
                  &lt;p&gt;
                  You can detect changes in the value of this property by listening for
                  property change events on this component with name
                  &lt;code&gt;&quot;paintingForPrint&quot;&lt;/code&gt;.
                  &lt;p&gt;
                  Note: This method provides complimentary functionality to that provided
                  by other high level Swing printing APIs. However, it deals strictly with
                  painting and should not be confused as providing information on higher
                  level print processes. For example, a {@link javax.swing.JTable#print()}operation doesn&apos;t necessarily result in a continuous rendering of the
                  full component, and the return value of this method can change multiple
                  times during that operation. It is even possible for the component to be
                  painted to the screen while the printing process is ongoing. In such a
                  case, the return value of this method is &lt;code&gt;true&lt;/code&gt; when, and only
                  when, the table is being painted as part of the printing process.                
                <return>
                    true if the current painting operation on this component
                      is part of a print operation                    
                </return>
                <see>
                    #print                    
                </see>
                <since>
                    1.6                    
                </since>
            </javadoc>
            <method name="isPaintingForPrint" type="boolean" line="1287"/>
            <javadoc line="1291">
                In release 1.4, the focus subsystem was rearchitected.
                  For more information, see
                  &lt;a href=&quot;http://java.sun.com/docs/books/tutorial/uiswing/misc/focus.html&quot;&gt;
                  How to Use the Focus Subsystem&lt;/a&gt;,
                  a section in &lt;em&gt;The Java Tutorial&lt;/em&gt;.
                  &lt;p&gt;
                  Changes this &lt;code&gt;JComponent&lt;/code&gt;&apos;s focus traversal keys to
                  CTRL+TAB and CTRL+SHIFT+TAB. Also prevents
                  &lt;code&gt;SortingFocusTraversalPolicy&lt;/code&gt; from considering descendants
                  of this JComponent when computing a focus traversal cycle.                
                <see>
                    java.awt.Component#setFocusTraversalKeys                    
                </see>
                <see>
                    SortingFocusTraversalPolicy                    
                </see>
                <deprecated>
                    As of 1.4, replaced by
                      <code>Component.setFocusTraversalKeys(int, Set)</code> and
                      <code>Container.setFocusCycleRoot(boolean)</code>.                    
                </deprecated>
            </javadoc>
            <method name="isManagingFocus" type="boolean" line="1310"/>
            <method name="registerNextFocusableComponent" type="void" line="1314"/>
            <method name="registerNextFocusableComponent" type="void" line="1319">
                <params>
                    <param name="nextFocusableComponent" type="Component"/>
                </params>
                <scope line="1320"/>
                <declaration name="nearestRoot" type="Container" line="1324"/>
                <declaration name="policy" type="FocusTraversalPolicy" line="1326"/>
                <scope line="1327"/>
            </method>
            <method name="deregisterNextFocusableComponent" type="void" line="1335">
                <declaration name="nextFocusableComponent" type="Component" line="1336"/>
                <scope line="1337"/>
                <declaration name="nearestRoot" type="Container" line="1341"/>
                <scope line="1343"/>
                <declaration name="policy" type="FocusTraversalPolicy" line="1346"/>
                <scope line="1347"/>
            </method>
            <javadoc line="1353">
                In release 1.4, the focus subsystem was rearchitected.
                  For more information, see
                  &lt;a href=&quot;http://java.sun.com/docs/books/tutorial/uiswing/misc/focus.html&quot;&gt;
                  How to Use the Focus Subsystem&lt;/a&gt;,
                  a section in &lt;em&gt;The Java Tutorial&lt;/em&gt;.
                  &lt;p&gt;
                  Overrides the default &lt;code&gt;FocusTraversalPolicy&lt;/code&gt; for this
                  &lt;code&gt;JComponent&lt;/code&gt;&apos;s focus traversal cycle by unconditionally
                  setting the specified &lt;code&gt;Component&lt;/code&gt; as the next
                  &lt;code&gt;Component&lt;/code&gt; in the cycle, and this &lt;code&gt;JComponent&lt;/code&gt;
                  as the specified &lt;code&gt;Component&lt;/code&gt;&apos;s previous
                  &lt;code&gt;Component&lt;/code&gt; in the cycle.                
                <param>
                    aComponent the <code>Component</code> that should follow this
                      <code>JComponent</code> in the focus traversal cycle                    
                </param>
                <see>
                    #getNextFocusableComponent                    
                </see>
                <see>
                    java.awt.FocusTraversalPolicy                    
                </see>
                <deprecated>
                    As of 1.4, replaced by <code>FocusTraversalPolicy</code>                    
                </deprecated>
            </javadoc>
            <method name="setNextFocusableComponent" type="void" line="1375">
                <params>
                    <param name="aComponent" type="Component"/>
                </params>
                <declaration name="displayable" type="boolean" line="1376"/>
                <scope line="1377"/>
                <scope line="1381"/>
            </method>
            <javadoc line="1386">
                In release 1.4, the focus subsystem was rearchitected.
                  For more information, see
                  &lt;a href=&quot;http://java.sun.com/docs/books/tutorial/uiswing/misc/focus.html&quot;&gt;
                  How to Use the Focus Subsystem&lt;/a&gt;,
                  a section in &lt;em&gt;The Java Tutorial&lt;/em&gt;.
                  &lt;p&gt;
                  Returns the &lt;code&gt;Component&lt;/code&gt; set by a prior call to
                  &lt;code&gt;setNextFocusableComponent(Component)&lt;/code&gt; on this
                  &lt;code&gt;JComponent&lt;/code&gt;.                
                <return>
                    the <code>Component</code> that will follow this
                      <code>JComponent</code> in the focus traversal cycle, or
                      <code>null</code> if none has been explicitly specified                    
                </return>
                <see>
                    #setNextFocusableComponent                    
                </see>
                <deprecated>
                    As of 1.4, replaced by <code>FocusTraversalPolicy</code>.                    
                </deprecated>
            </javadoc>
            <method name="getNextFocusableComponent" type="Component" line="1405"/>
            <javadoc line="1409">
                Provides a hint as to whether or not this &lt;code&gt;JComponent&lt;/code&gt;
                  should get focus. This is only a hint, and it is up to consumers that
                  are requesting focus to honor this property. This is typically honored
                  for mouse operations, but not keyboard operations. For example, look
                  and feels could verify this property is true before requesting focus
                  during a mouse operation. This would often times be used if you did
                  not want a mouse press on a &lt;code&gt;JComponent&lt;/code&gt; to steal focus,
                  but did want the &lt;code&gt;JComponent&lt;/code&gt; to be traversable via the
                  keyboard. If you do not want this &lt;code&gt;JComponent&lt;/code&gt; focusable at
                  all, use the &lt;code&gt;setFocusable&lt;/code&gt; method instead.
                  &lt;p&gt;
                  Please see
                  &lt;a href=&quot;http://java.sun.com/docs/books/tutorial/uiswing/misc/focus.html&quot;&gt;
                  How to Use the Focus Subsystem&lt;/a&gt;,
                  a section in &lt;em&gt;The Java Tutorial&lt;/em&gt;,
                  for more information.                
                <param>
                    requestFocusEnabled indicates whether you want this
                      <code>JComponent</code> to be focusable or not                    
                </param>
                <see>
                    <a href="../../java/awt/doc-files/FocusSpec.html">Focus Specification</a>                    
                </see>
                <see>
                    java.awt.Component#setFocusable                    
                </see>
            </javadoc>
            <method name="setRequestFocusEnabled" type="void" line="1432">
                <params>
                    <param name="requestFocusEnabled" type="boolean"/>
                </params>
            </method>
            <javadoc line="1436">
                Returns &lt;code&gt;true&lt;/code&gt; if this &lt;code&gt;JComponent&lt;/code&gt; should
                  get focus; otherwise returns &lt;code&gt;false&lt;/code&gt;.
                  &lt;p&gt;
                  Please see
                  &lt;a href=&quot;http://java.sun.com/docs/books/tutorial/uiswing/misc/focus.html&quot;&gt;
                  How to Use the Focus Subsystem&lt;/a&gt;,
                  a section in &lt;em&gt;The Java Tutorial&lt;/em&gt;,
                  for more information.                
                <return>
                    <code>true</code> if this component should get focus,
                      otherwise returns <code>false</code>                    
                </return>
                <see>
                    #setRequestFocusEnabled                    
                </see>
                <see>
                    <a href="../../java/awt/doc-files/FocusSpec.html">Focus
                               Specification</a>                    
                </see>
                <see>
                    java.awt.Component#isFocusable                    
                </see>
            </javadoc>
            <method name="isRequestFocusEnabled" type="boolean" line="1453"/>
            <javadoc line="1457">
                Requests that this &lt;code&gt;Component&lt;/code&gt; gets the input focus.
                  Refer to {@link java.awt.Component#requestFocus()Component.requestFocus()} for a complete description of
                  this method.
                  &lt;p&gt;
                  Note that the use of this method is discouraged because
                  its behavior is platform dependent. Instead we recommend the
                  use of {@link #requestFocusInWindow() requestFocusInWindow()}.
                  If you would like more information on focus, see
                  &lt;a href=&quot;http://java.sun.com/docs/books/tutorial/uiswing/misc/focus.html&quot;&gt;
                  How to Use the Focus Subsystem&lt;/a&gt;,
                  a section in &lt;em&gt;The Java Tutorial&lt;/em&gt;.                
                <see>
                    java.awt.Component#requestFocusInWindow()                    
                </see>
                <see>
                    java.awt.Component#requestFocusInWindow(boolean)                    
                </see>
                <since>
                    1.4                    
                </since>
            </javadoc>
            <method name="requestFocus" type="void" line="1475"/>
            <javadoc line="1479">
                Requests that this &lt;code&gt;Component&lt;/code&gt; gets the input focus.
                  Refer to {@link java.awt.Component#requestFocus(boolean)Component.requestFocus(boolean)} for a complete description of
                  this method.
                  &lt;p&gt;
                  Note that the use of this method is discouraged because
                  its behavior is platform dependent. Instead we recommend the
                  use of {@link #requestFocusInWindow(boolean)requestFocusInWindow(boolean)}.
                  If you would like more information on focus, see
                  &lt;a href=&quot;http://java.sun.com/docs/books/tutorial/uiswing/misc/focus.html&quot;&gt;
                  How to Use the Focus Subsystem&lt;/a&gt;,
                  a section in &lt;em&gt;The Java Tutorial&lt;/em&gt;.                
                <param>
                    temporary boolean indicating if the focus change is temporary                    
                </param>
                <return>
                    <code>false</code> if the focus change request is guaranteed to
                      fail; <code>true</code> if it is likely to succeed                    
                </return>
                <see>
                    java.awt.Component#requestFocusInWindow()                    
                </see>
                <see>
                    java.awt.Component#requestFocusInWindow(boolean)                    
                </see>
                <since>
                    1.4                    
                </since>
            </javadoc>
            <method name="requestFocus" type="boolean" line="1501">
                <params>
                    <param name="temporary" type="boolean"/>
                </params>
            </method>
            <javadoc line="1505">
                Requests that this &lt;code&gt;Component&lt;/code&gt; gets the input focus.
                  Refer to {@link java.awt.Component#requestFocusInWindow()Component.requestFocusInWindow()} for a complete description of
                  this method.
                  &lt;p&gt;
                  If you would like more information on focus, see
                  &lt;a href=&quot;http://java.sun.com/docs/books/tutorial/uiswing/misc/focus.html&quot;&gt;
                  How to Use the Focus Subsystem&lt;/a&gt;,
                  a section in &lt;em&gt;The Java Tutorial&lt;/em&gt;.                
                <return>
                    <code>false</code> if the focus change request is guaranteed to
                      fail; <code>true</code> if it is likely to succeed                    
                </return>
                <see>
                    java.awt.Component#requestFocusInWindow()                    
                </see>
                <see>
                    java.awt.Component#requestFocusInWindow(boolean)                    
                </see>
                <since>
                    1.4                    
                </since>
            </javadoc>
            <method name="requestFocusInWindow" type="boolean" line="1522"/>
            <javadoc line="1526">
                Requests that this &lt;code&gt;Component&lt;/code&gt; gets the input focus.
                  Refer to {@link java.awt.Component#requestFocusInWindow(boolean)Component.requestFocusInWindow(boolean)} for a complete description of
                  this method.
                  &lt;p&gt;
                  If you would like more information on focus, see
                  &lt;a href=&quot;http://java.sun.com/docs/books/tutorial/uiswing/misc/focus.html&quot;&gt;
                  How to Use the Focus Subsystem&lt;/a&gt;,
                  a section in &lt;em&gt;The Java Tutorial&lt;/em&gt;.                
                <param>
                    temporary boolean indicating if the focus change is temporary                    
                </param>
                <return>
                    <code>false</code> if the focus change request is guaranteed to
                      fail; <code>true</code> if it is likely to succeed                    
                </return>
                <see>
                    java.awt.Component#requestFocusInWindow()                    
                </see>
                <see>
                    java.awt.Component#requestFocusInWindow(boolean)                    
                </see>
                <since>
                    1.4                    
                </since>
            </javadoc>
            <method name="requestFocusInWindow" type="boolean" line="1544">
                <params>
                    <param name="temporary" type="boolean"/>
                </params>
            </method>
            <javadoc line="1548">
                Requests that this Component get the input focus, and that this
                  Component&apos;s top-level ancestor become the focused Window. This component
                  must be displayable, visible, and focusable for the request to be
                  granted.
                  &lt;p&gt;
                  This method is intended for use by focus implementations. Client code
                  should not use this method; instead, it should use
                  &lt;code&gt;requestFocusInWindow()&lt;/code&gt;.                
                <see>
                    #requestFocusInWindow()                    
                </see>
            </javadoc>
            <method name="grabFocus" type="void" line="1560"/>
            <javadoc line="1564">
                Sets the value to indicate whether input verifier for the
                  current focus owner will be called before this component requests
                  focus. The default is true. Set to false on components such as a
                  Cancel button or a scrollbar, which should activate even if the
                  input in the current focus owner is not &quot;passed&quot; by the input
                  verifier for that component.                
                <param>
                    verifyInputWhenFocusTarget value for the
                      <code>verifyInputWhenFocusTarget</code> property                    
                </param>
                <see>
                    InputVerifier                    
                </see>
                <see>
                    #setInputVerifier                    
                </see>
                <see>
                    #getInputVerifier                    
                </see>
                <see>
                    #getVerifyInputWhenFocusTarget                    
                </see>
                <since>
                    1.3                    
                </since>
                <beaninfo>
                    bound: true
                      description: Whether the Component verifies input before accepting
                      focus.                    
                </beaninfo>
            </javadoc>
            <method name="setVerifyInputWhenFocusTarget" type="void" line="1586">
                <params>
                    <param name="verifyInputWhenFocusTarget" type="boolean"/>
                </params>
                <declaration name="oldVerifyInputWhenFocusTarget" type="boolean" line="1587"/>
            </method>
            <javadoc line="1595">
                Returns the value that indicates whether the input verifier for the
                  current focus owner will be called before this component requests
                  focus.                
                <return>
                    value of the <code>verifyInputWhenFocusTarget</code> property                    
                </return>
                <see>
                    InputVerifier                    
                </see>
                <see>
                    #setInputVerifier                    
                </see>
                <see>
                    #getInputVerifier                    
                </see>
                <see>
                    #setVerifyInputWhenFocusTarget                    
                </see>
                <since>
                    1.3                    
                </since>
            </javadoc>
            <method name="getVerifyInputWhenFocusTarget" type="boolean" line="1609"/>
            <javadoc line="1614">
                Gets the &lt;code&gt;FontMetrics&lt;/code&gt; for the specified &lt;code&gt;Font&lt;/code&gt;.                
                <param>
                    font the font for which font metrics is to be
                      obtained                    
                </param>
                <return>
                    the font metrics for <code>font</code>                    
                </return>
                <throws>
                    NullPointerException if <code>font</code> is null                    
                </throws>
                <since>
                    1.5                    
                </since>
            </javadoc>
            <method name="getFontMetrics" type="FontMetrics" line="1623">
                <params>
                    <param name="font" type="Font"/>
                </params>
            </method>
            <javadoc line="1628">
                Sets the preferred size of this component.
                  If &lt;code&gt;preferredSize&lt;/code&gt; is &lt;code&gt;null&lt;/code&gt;, the UI will
                  be asked for the preferred size.                
                <beaninfo>
                    preferred: true
                      bound: true
                      description: The preferred size of the component.                    
                </beaninfo>
            </javadoc>
            <method name="setPreferredSize" type="void" line="1637">
                <params>
                    <param name="preferredSize" type="Dimension"/>
                </params>
            </method>
            <javadoc line="1642">
                If the &lt;code&gt;preferredSize&lt;/code&gt; has been set to a
                  non-&lt;code&gt;null&lt;/code&gt; value just returns it.
                  If the UI delegate&apos;s &lt;code&gt;getPreferredSize&lt;/code&gt;
                  method returns a non &lt;code&gt;null&lt;/code&gt; value then return that;
                  otherwise defer to the component&apos;s layout manager.                
                <return>
                    the value of the <code>preferredSize</code> property                    
                </return>
                <see>
                    #setPreferredSize                    
                </see>
                <see>
                    ComponentUI                    
                </see>
            </javadoc>
            <method name="getPreferredSize" type="Dimension" line="1654">
                <scope line="1655"/>
                <declaration name="size" type="Dimension" line="1658"/>
                <scope line="1659"/>
            </method>
            <javadoc line="1666">
                Sets the maximum size of this component to a constant
                  value.  Subsequent calls to &lt;code&gt;getMaximumSize&lt;/code&gt; will always
                  return this value; the component&apos;s UI will not be asked
                  to compute it.  Setting the maximum size to &lt;code&gt;null&lt;/code&gt;
                  restores the default behavior.                
                <param>
                    maximumSize a <code>Dimension</code> containing the
                      desired maximum allowable size                    
                </param>
                <see>
                    #getMaximumSize                    
                </see>
                <beaninfo>
                    bound: true
                      description: The maximum size of the component.                    
                </beaninfo>
            </javadoc>
            <method name="setMaximumSize" type="void" line="1680">
                <params>
                    <param name="maximumSize" type="Dimension"/>
                </params>
            </method>
            <javadoc line="1685">
                If the maximum size has been set to a non-&lt;code&gt;null&lt;/code&gt; value
                  just returns it.  If the UI delegate&apos;s &lt;code&gt;getMaximumSize&lt;/code&gt;
                  method returns a non-&lt;code&gt;null&lt;/code&gt; value then return that;
                  otherwise defer to the component&apos;s layout manager.                
                <return>
                    the value of the <code>maximumSize</code> property                    
                </return>
                <see>
                    #setMaximumSize                    
                </see>
                <see>
                    ComponentUI                    
                </see>
            </javadoc>
            <method name="getMaximumSize" type="Dimension" line="1696">
                <scope line="1697"/>
                <declaration name="size" type="Dimension" line="1700"/>
                <scope line="1701"/>
            </method>
            <javadoc line="1708">
                Sets the minimum size of this component to a constant
                  value.  Subsequent calls to &lt;code&gt;getMinimumSize&lt;/code&gt; will always
                  return this value; the component&apos;s UI will not be asked
                  to compute it.  Setting the minimum size to &lt;code&gt;null&lt;/code&gt;
                  restores the default behavior.                
                <param>
                    minimumSize the new minimum size of this component                    
                </param>
                <see>
                    #getMinimumSize                    
                </see>
                <beaninfo>
                    bound: true
                      description: The minimum size of the component.                    
                </beaninfo>
            </javadoc>
            <method name="setMinimumSize" type="void" line="1721">
                <params>
                    <param name="minimumSize" type="Dimension"/>
                </params>
            </method>
            <javadoc line="1725">
                If the minimum size has been set to a non-&lt;code&gt;null&lt;/code&gt; value
                  just returns it.  If the UI delegate&apos;s &lt;code&gt;getMinimumSize&lt;/code&gt;
                  method returns a non-&lt;code&gt;null&lt;/code&gt; value then return that; otherwise
                  defer to the component&apos;s layout manager.                
                <return>
                    the value of the <code>minimumSize</code> property                    
                </return>
                <see>
                    #setMinimumSize                    
                </see>
                <see>
                    ComponentUI                    
                </see>
            </javadoc>
            <method name="getMinimumSize" type="Dimension" line="1736">
                <scope line="1737"/>
                <declaration name="size" type="Dimension" line="1740"/>
                <scope line="1741"/>
            </method>
            <javadoc line="1747">
                Gives the UI delegate an opportunity to define the precise
                  shape of this component for the sake of mouse processing.                
                <return>
                    true if this component logically contains x,y                    
                </return>
                <see>
                    java.awt.Component#contains(int,int)                    
                </see>
                <see>
                    ComponentUI                    
                </see>
            </javadoc>
            <method name="contains" type="boolean" line="1755">
                <params>
                    <param name="x" type="int"/>
                    <param name="y" type="int"/>
                </params>
            </method>
            <javadoc line="1759">
                Sets the border of this component.  The &lt;code&gt;Border&lt;/code&gt; object is
                  responsible for defining the insets for the component
                  (overriding any insets set directly on the component) and
                  for optionally rendering any border decorations within the
                  bounds of those insets.  Borders should be used (rather
                  than insets) for creating both decorative and non-decorative
                  (such as margins and padding) regions for a swing component.
                  Compound borders can be used to nest multiple borders within a
                  single component.
                  &lt;p&gt;
                  Although technically you can set the border on any object
                  that inherits from &lt;code&gt;JComponent&lt;/code&gt;, the look and
                  feel implementation of many standard Swing components
                  doesn&apos;t work well with user-set borders.  In general,
                  when you want to set a border on a standard Swing
                  component other than &lt;code&gt;JPanel&lt;/code&gt; or &lt;code&gt;JLabel&lt;/code&gt;,
                  we recommend that you put the component in a &lt;code&gt;JPanel&lt;/code&gt;
                  and set the border on the &lt;code&gt;JPanel&lt;/code&gt;.
                  &lt;p&gt;
                  This is a bound property.                
                <param>
                    border the border to be rendered for this component                    
                </param>
                <see>
                    Border                    
                </see>
                <see>
                    CompoundBorder                    
                </see>
                <beaninfo>
                    bound: true
                      preferred: true
                      attribute: visualUpdate true
                      description: The component's border.                    
                </beaninfo>
            </javadoc>
            <method name="setBorder" type="void" line="1790">
                <params>
                    <param name="border" type="Border"/>
                </params>
                <declaration name="oldBorder" type="Border" line="1791"/>
                <scope line="1795">
                    <scope line="1797"/>
                </scope>
            </method>
            <javadoc line="1804">
                Returns the border of this component or &lt;code&gt;null&lt;/code&gt; if no
                  border is currently set.                
                <return>
                    the border object for this component                    
                </return>
                <see>
                    #setBorder                    
                </see>
            </javadoc>
            <method name="getBorder" type="Border" line="1811"/>
            <javadoc line="1815">
                If a border has been set on this component, returns the
                  border&apos;s insets; otherwise calls &lt;code&gt;super.getInsets&lt;/code&gt;.                
                <return>
                    the value of the insets property                    
                </return>
                <see>
                    #setBorder                    
                </see>
            </javadoc>
            <method name="getInsets" type="Insets" line="1822">
                <scope line="1823"/>
            </method>
            <javadoc line="1829">
                Returns an &lt;code&gt;Insets&lt;/code&gt; object containing this component&apos;s inset
                  values.  The passed-in &lt;code&gt;Insets&lt;/code&gt; object will be reused
                  if possible.
                  Calling methods cannot assume that the same object will be returned,
                  however.  All existing values within this object are overwritten.
                  If &lt;code&gt;insets&lt;/code&gt; is null, this will allocate a new one.                
                <param>
                    insets the <code>Insets</code> object, which can be reused                    
                </param>
                <return>
                    the <code>Insets</code> object                    
                </return>
                <see>
                    #getInsets                    
                </see>
                <beaninfo>
                    expert: true                    
                </beaninfo>
            </javadoc>
            <method name="getInsets" type="Insets" line="1843">
                <params>
                    <param name="insets" type="Insets"/>
                </params>
                <comment line="1852">
                    Can&apos;t reuse border insets because the Border interface
                     can&apos;t be enhanced.                    
                </comment>
                <comment line="1857">
                    super.getInsets() always returns an Insets object with
                     all of its value zeroed.  No need for a new object here.                    
                </comment>
                <scope line="1844"/>
                <scope line="1847">
                    <scope line="1848"/>
                    <scope line="1850"/>
                </scope>
                <scope line="1855"/>
            </method>
            <javadoc line="1863">
                Overrides &lt;code&gt;Container.getAlignmentY&lt;/code&gt; to return
                  the horizontal alignment.                
                <return>
                    the value of the <code>alignmentY</code> property                    
                </return>
                <see>
                    #setAlignmentY                    
                </see>
                <see>
                    java.awt.Component#getAlignmentY                    
                </see>
            </javadoc>
            <method name="getAlignmentY" type="float" line="1871">
                <scope line="1872"/>
            </method>
            <javadoc line="1878">
                Sets the the horizontal alignment.                
                <param>
                    alignmentY  the new horizontal alignment                    
                </param>
                <see>
                    #getAlignmentY                    
                </see>
                <beaninfo>
                    description: The preferred vertical alignment of the component.                    
                </beaninfo>
            </javadoc>
            <method name="setAlignmentY" type="void" line="1886">
                <params>
                    <param name="alignmentY" type="float"/>
                </params>
            </method>
            <javadoc line="1892">
                Overrides &lt;code&gt;Container.getAlignmentX&lt;/code&gt; to return
                  the vertical alignment.                
                <return>
                    the value of the <code>alignmentX</code> property                    
                </return>
                <see>
                    #setAlignmentX                    
                </see>
                <see>
                    java.awt.Component#getAlignmentX                    
                </see>
            </javadoc>
            <method name="getAlignmentX" type="float" line="1900">
                <scope line="1901"/>
            </method>
            <javadoc line="1907">
                Sets the the vertical alignment.                
                <param>
                    alignmentX  the new vertical alignment                    
                </param>
                <see>
                    #getAlignmentX                    
                </see>
                <beaninfo>
                    description: The preferred horizontal alignment of the component.                    
                </beaninfo>
            </javadoc>
            <method name="setAlignmentX" type="void" line="1915">
                <params>
                    <param name="alignmentX" type="float"/>
                </params>
            </method>
            <javadoc line="1920">
                Sets the input verifier for this component.                
                <param>
                    inputVerifier the new input verifier                    
                </param>
                <since>
                    1.3                    
                </since>
                <see>
                    InputVerifier                    
                </see>
                <beaninfo>
                    bound: true
                      description: The component's input verifier.                    
                </beaninfo>
            </javadoc>
            <method name="setInputVerifier" type="void" line="1930">
                <params>
                    <param name="inputVerifier" type="InputVerifier"/>
                </params>
                <declaration name="oldInputVerifier" type="InputVerifier" line="1931"/>
            </method>
            <javadoc line="1937">
                Returns the input verifier for this component.                
                <return>
                    the <code>inputVerifier</code> property                    
                </return>
                <since>
                    1.3                    
                </since>
                <see>
                    InputVerifier                    
                </see>
            </javadoc>
            <method name="getInputVerifier" type="InputVerifier" line="1944"/>
            <javadoc line="1948">
                Returns this component&apos;s graphics context, which lets you draw
                  on a component. Use this method to get a &lt;code&gt;Graphics&lt;/code&gt; object and
                  then invoke operations on that object to draw on the component.                
                <return>
                    this components graphics context                    
                </return>
            </javadoc>
            <method name="getGraphics" type="Graphics" line="1954">
                <scope line="1955">
                    <declaration name="graphics" type="DebugGraphics" line="1956"/>
                </scope>
            </method>
            <javadoc line="1964">
                Enables or disables diagnostic information about every graphics
                  operation performed within the component or one of its children.                
                <param>
                    debugOptions  determines how the component should display
                      the information;  one of the following options:
                      <ul>
                      <li>DebugGraphics.LOG_OPTION - causes a text message to be printed.
                      <li>DebugGraphics.FLASH_OPTION - causes the drawing to flash several
                      times.
                      <li>DebugGraphics.BUFFERED_OPTION - creates an
                      <code>ExternalWindow</code> that displays the operations
                      performed on the View's offscreen buffer.
                      <li>DebugGraphics.NONE_OPTION disables debugging.
                      <li>A value of 0 causes no changes to the debugging options.
                      </ul>
                      <code>debugOptions</code> is bitwise OR'd into the current value                    
                </param>
                <beaninfo>
                    preferred: true
                      enum: NONE_OPTION DebugGraphics.NONE_OPTION
                      LOG_OPTION DebugGraphics.LOG_OPTION
                      FLASH_OPTION DebugGraphics.FLASH_OPTION
                      BUFFERED_OPTION DebugGraphics.BUFFERED_OPTION
                      description: Diagnostic options for graphics operations.                    
                </beaninfo>
            </javadoc>
            <method name="setDebugGraphicsOptions" type="void" line="1989">
                <params>
                    <param name="debugOptions" type="int"/>
                </params>
            </method>
            <javadoc line="1993">
                Returns the state of graphics debugging.                
                <return>
                    a bitwise OR'd flag of zero or more of the following options:
                      <ul>
                      <li>DebugGraphics.LOG_OPTION - causes a text message to be printed.
                      <li>DebugGraphics.FLASH_OPTION - causes the drawing to flash several
                      times.
                      <li>DebugGraphics.BUFFERED_OPTION - creates an
                      <code>ExternalWindow</code> that displays the operations
                      performed on the View's offscreen buffer.
                      <li>DebugGraphics.NONE_OPTION disables debugging.
                      <li>A value of 0 causes no changes to the debugging options.
                      </ul>                    
                </return>
                <see>
                    #setDebugGraphicsOptions                    
                </see>
            </javadoc>
            <method name="getDebugGraphicsOptions" type="int" line="2008"/>
            <javadoc line="2013">
                Returns true if debug information is enabled for this
                  &lt;code&gt;JComponent&lt;/code&gt; or one of its parents.                
            </javadoc>
            <method name="shouldDebugGraphics" type="int" line="2017"/>
            <javadoc line="2021">
                This method is now obsolete, please use a combination of
                  &lt;code&gt;getActionMap()&lt;/code&gt; and &lt;code&gt;getInputMap()&lt;/code&gt; for
                  similiar behavior. For example, to bind the &lt;code&gt;KeyStroke&lt;/code&gt;
                  &lt;code&gt;aKeyStroke&lt;/code&gt; to the &lt;code&gt;Action&lt;/code&gt; &lt;code&gt;anAction&lt;/code&gt;
                  now use:
                  &lt;pre&gt;
                  component.getInputMap().put(aKeyStroke, aCommand);
                  component.getActionMap().put(aCommmand, anAction);
                  &lt;/pre&gt;
                  The above assumes you want the binding to be applicable for
                  &lt;code&gt;WHEN_FOCUSED&lt;/code&gt;. To register bindings for other focus
                  states use the &lt;code&gt;getInputMap&lt;/code&gt; method that takes an integer.
                  &lt;p&gt;
                  Register a new keyboard action.
                  &lt;code&gt;anAction&lt;/code&gt; will be invoked if a key event matching
                  &lt;code&gt;aKeyStroke&lt;/code&gt; occurs and &lt;code&gt;aCondition&lt;/code&gt; is verified.
                  The &lt;code&gt;KeyStroke&lt;/code&gt; object defines a
                  particular combination of a keyboard key and one or more modifiers
                  (alt, shift, ctrl, meta).
                  &lt;p&gt;
                  The &lt;code&gt;aCommand&lt;/code&gt; will be set in the delivered event if
                  specified.
                  &lt;p&gt;
                  The &lt;code&gt;aCondition&lt;/code&gt; can be one of:
                  &lt;blockquote&gt;
                  &lt;DL&gt;
                  &lt;DT&gt;WHEN_FOCUSED
                  &lt;DD&gt;The action will be invoked only when the keystroke occurs
                  while the component has the focus.
                  &lt;DT&gt;WHEN_IN_FOCUSED_WINDOW
                  &lt;DD&gt;The action will be invoked when the keystroke occurs while
                  the component has the focus or if the component is in the
                  window that has the focus. Note that the component need not
                  be an immediate descendent of the window -- it can be
                  anywhere in the window&apos;s containment hierarchy. In other
                  words, whenever &lt;em&gt;any&lt;/em&gt; component in the window has the focus,
                  the action registered with this component is invoked.
                  &lt;DT&gt;WHEN_ANCESTOR_OF_FOCUSED_COMPONENT
                  &lt;DD&gt;The action will be invoked when the keystroke occurs while the
                  component has the focus or if the component is an ancestor of
                  the component that has the focus.
                  &lt;/DL&gt;
                  &lt;/blockquote&gt;
                  &lt;p&gt;
                  The combination of keystrokes and conditions lets you define high
                  level (semantic) action events for a specified keystroke+modifier
                  combination (using the KeyStroke class) and direct to a parent or
                  child of a component that has the focus, or to the component itself.
                  In other words, in any hierarchical structure of components, an
                  arbitrary key-combination can be immediately directed to the
                  appropriate component in the hierarchy, and cause a specific method
                  to be invoked (usually by way of adapter objects).
                  &lt;p&gt;
                  If an action has already been registered for the receiving
                  container, with the same charCode and the same modifiers,
                  &lt;code&gt;anAction&lt;/code&gt; will replace the action.                
                <param>
                    anAction  the <code>Action</code> to be registered                    
                </param>
                <param>
                    aCommand  the command to be set in the delivered event                    
                </param>
                <param>
                    aKeyStroke the <code>KeyStroke</code> to bind to the action                    
                </param>
                <param>
                    aCondition the condition that needs to be met, see above                    
                </param>
                <see>
                    KeyStroke                    
                </see>
            </javadoc>
            <method name="registerKeyboardAction" type="void" line="2085">
                <params>
                    <param name="anAction" type="ActionListener"/>
                    <param name="aCommand" type="String"/>
                    <param name="aKeyStroke" type="KeyStroke"/>
                    <param name="aCondition" type="int"/>
                </params>
                <declaration name="inputMap" type="InputMap" line="2087"/>
                <scope line="2089">
                    <declaration name="actionMap" type="ActionMap" line="2090"/>
                    <declaration name="action" type="ActionStandin" line="2091"/>
                    <scope line="2093"/>
                </scope>
            </method>
            <javadoc line="2099">
                Registers any bound &lt;code&gt;WHEN_IN_FOCUSED_WINDOW&lt;/code&gt; actions with
                  the &lt;code&gt;KeyboardManager&lt;/code&gt;. If &lt;code&gt;onlyIfNew&lt;/code&gt;
                  is true only actions that haven&apos;t been registered are pushed
                  to the &lt;code&gt;KeyboardManager&lt;/code&gt;;
                  otherwise all actions are pushed to the &lt;code&gt;KeyboardManager&lt;/code&gt;.                
                <param>
                    onlyIfNew  if true, only actions that haven't been registered
                      are pushed to the <code>KeyboardManager</code>                    
                </param>
            </javadoc>
            <method name="registerWithKeyboardManager" type="void" line="2109">
                <params>
                    <param name="onlyIfNew" type="boolean"/>
                </params>
                <comment line="2117">
                    Push any new KeyStrokes to the KeyboardManager.                    
                </comment>
                <comment line="2135">
                    Remove any old ones.                    
                </comment>
                <comment line="2145">
                    Updated the registered Hashtable.                    
                </comment>
                <declaration name="inputMap" type="InputMap" line="2110"/>
                <declaration name="strokes" type="KeyStroke[]" line="2111"/>
                <declaration name="registered" type="Hashtable&lt;KeyStroke,KeyStroke&gt;" line="2112"/>
                <scope line="2115">
                    <scope line="2118">
                        <scope line="2120">
                            <scope line="2122"/>
                            <scope line="2125"/>
                        </scope>
                    </scope>
                </scope>
                <scope line="2131"/>
                <scope line="2135">
                    <declaration name="keys" type="Enumeration&lt;KeyStroke&gt;" line="2136"/>
                    <scope line="2138">
                        <declaration name="ks" type="KeyStroke" line="2139"/>
                    </scope>
                </scope>
                <scope line="2145">
                    <scope line="2146"/>
                    <scope line="2150"/>
                </scope>
                <scope line="2154"/>
            </method>
            <javadoc line="2159">
                Unregisters all the previously registered
                  &lt;code&gt;WHEN_IN_FOCUSED_WINDOW&lt;/code&gt; &lt;code&gt;KeyStroke&lt;/code&gt; bindings.                
            </javadoc>
            <method name="unregisterWithKeyboardManager" type="void" line="2163">
                <declaration name="registered" type="Hashtable" line="2164"/>
                <scope line="2167">
                    <declaration name="keys" type="Enumeration" line="2168"/>
                    <scope line="2170">
                        <declaration name="ks" type="KeyStroke" line="2171"/>
                    </scope>
                </scope>
            </method>
            <javadoc line="2178">
                Invoked from &lt;code&gt;ComponentInputMap&lt;/code&gt; when its bindings change.
                  If &lt;code&gt;inputMap&lt;/code&gt; is the current &lt;code&gt;windowInputMap&lt;/code&gt;
                  (or a parent of the window &lt;code&gt;InputMap&lt;/code&gt;)
                  the &lt;code&gt;KeyboardManager&lt;/code&gt; is notified of the new bindings.                
                <param>
                    inputMap the map containing the new bindings                    
                </param>
            </javadoc>
            <method name="componentInputMapChanged" type="void" line="2186">
                <params>
                    <param name="inputMap" type="ComponentInputMap"/>
                </params>
                <declaration name="km" type="InputMap" line="2187"/>
                <scope line="2189"/>
                <scope line="2192"/>
            </method>
            <method name="registerWithKeyboardManager" type="void" line="2197">
                <params>
                    <param name="aKeyStroke" type="KeyStroke"/>
                </params>
            </method>
            <method name="unregisterWithKeyboardManager" type="void" line="2201">
                <params>
                    <param name="aKeyStroke" type="KeyStroke"/>
                </params>
            </method>
            <javadoc line="2206">
                This method is now obsolete, please use a combination of
                  &lt;code&gt;getActionMap()&lt;/code&gt; and &lt;code&gt;getInputMap()&lt;/code&gt; for
                  similiar behavior.                
            </javadoc>
            <method name="registerKeyboardAction" type="void" line="2211">
                <params>
                    <param name="anAction" type="ActionListener"/>
                    <param name="aKeyStroke" type="KeyStroke"/>
                    <param name="aCondition" type="int"/>
                </params>
            </method>
            <javadoc line="2215">
                This method is now obsolete. To unregister an existing binding
                  you can either remove the binding from the
                  &lt;code&gt;ActionMap/InputMap&lt;/code&gt;, or place a dummy binding the
                  &lt;code&gt;InputMap&lt;/code&gt;. Removing the binding from the
                  &lt;code&gt;InputMap&lt;/code&gt; allows bindings in parent &lt;code&gt;InputMap&lt;/code&gt;s
                  to be active, whereas putting a dummy binding in the
                  &lt;code&gt;InputMap&lt;/code&gt; effectively disables
                  the binding from ever happening.
                  &lt;p&gt;
                  Unregisters a keyboard action.
                  This will remove the binding from the &lt;code&gt;ActionMap&lt;/code&gt;
                  (if it exists) as well as the &lt;code&gt;InputMap&lt;/code&gt;s.                
            </javadoc>
            <method name="unregisterKeyboardAction" type="void" line="2229">
                <params>
                    <param name="aKeyStroke" type="KeyStroke"/>
                </params>
                <declaration name="am" type="ActionMap" line="2230"/>
                <scope line="2231">
                    <declaration name="km" type="InputMap" line="2232"/>
                    <scope line="2233">
                        <declaration name="actionID" type="Object" line="2234"/>
                        <scope line="2236"/>
                    </scope>
                </scope>
            </method>
            <javadoc line="2244">
                Returns the &lt;code&gt;KeyStrokes&lt;/code&gt; that will initiate
                  registered actions.                
                <return>
                    an array of <code>KeyStroke</code> objects                    
                </return>
                <see>
                    #registerKeyboardAction                    
                </see>
            </javadoc>
            <method name="getRegisteredKeyStrokes" type="KeyStroke[]" line="2251">
                <declaration name="counts" type="int[]" line="2252"/>
                <declaration name="strokes" type="KeyStroke[][]" line="2253"/>
                <scope line="2255">
                    <declaration name="km" type="InputMap" line="2256"/>
                </scope>
                <declaration name="retValue" type="KeyStroke[]" line="2261"/>
                <scope line="2263">
                    <scope line="2264"/>
                </scope>
            </method>
            <javadoc line="2273">
                Returns the condition that determines whether a registered action
                  occurs in response to the specified keystroke.
                  &lt;p&gt;
                  For Java 2 platform v1.3, a &lt;code&gt;KeyStroke&lt;/code&gt; can be associated
                  with more than one condition.
                  For example, &apos;a&apos; could be bound for the two
                  conditions &lt;code&gt;WHEN_FOCUSED&lt;/code&gt; and
                  &lt;code&gt;WHEN_IN_FOCUSED_WINDOW&lt;/code&gt; condition.                
                <return>
                    the action-keystroke condition                    
                </return>
            </javadoc>
            <method name="getConditionForKeyStroke" type="int" line="2285">
                <params>
                    <param name="aKeyStroke" type="KeyStroke"/>
                </params>
                <scope line="2286">
                    <declaration name="inputMap" type="InputMap" line="2287"/>
                    <scope line="2288"/>
                </scope>
            </method>
            <javadoc line="2295">
                Returns the object that will perform the action registered for a
                  given keystroke.                
                <return>
                    the <code>ActionListener</code>
                      object invoked when the keystroke occurs                    
                </return>
            </javadoc>
            <method name="getActionForKeyStroke" type="ActionListener" line="2302">
                <params>
                    <param name="aKeyStroke" type="KeyStroke"/>
                </params>
                <declaration name="am" type="ActionMap" line="2303"/>
                <scope line="2305"/>
                <scope line="2308">
                    <declaration name="inputMap" type="InputMap" line="2309"/>
                    <scope line="2310">
                        <declaration name="actionBinding" type="Object" line="2311"/>
                        <scope line="2313">
                            <declaration name="action" type="Action" line="2314"/>
                            <scope line="2315"/>
                        </scope>
                    </scope>
                </scope>
            </method>
            <javadoc line="2325">
                Unregisters all the bindings in the first tier &lt;code&gt;InputMaps&lt;/code&gt;
                  and &lt;code&gt;ActionMap&lt;/code&gt;. This has the effect of removing any
                  local bindings, and allowing the bindings defined in parent
                  &lt;code&gt;InputMap/ActionMaps&lt;/code&gt;
                  (the UI is usually defined in the second tier) to persist.                
            </javadoc>
            <method name="resetKeyboardActions" type="void" line="2332">
                <comment line="2334">
                    Keys                    
                </comment>
                <comment line="2343">
                    Actions                    
                </comment>
                <scope line="2334">
                    <declaration name="inputMap" type="InputMap" line="2335"/>
                    <scope line="2337"/>
                </scope>
                <declaration name="am" type="ActionMap" line="2343"/>
                <scope line="2345"/>
            </method>
            <javadoc line="2350">
                Sets the &lt;code&gt;InputMap&lt;/code&gt; to use under the condition
                  &lt;code&gt;condition&lt;/code&gt; to
                  &lt;code&gt;map&lt;/code&gt;. A &lt;code&gt;null&lt;/code&gt; value implies you
                  do not want any bindings to be used, even from the UI. This will
                  not reinstall the UI &lt;code&gt;InputMap&lt;/code&gt; (if there was one).
                  &lt;code&gt;condition&lt;/code&gt; has one of the following values:
                  &lt;ul&gt;
                  &lt;li&gt;&lt;code&gt;WHEN_IN_FOCUSED_WINDOW&lt;/code&gt;
                  &lt;li&gt;&lt;code&gt;WHEN_FOCUSED&lt;/code&gt;
                  &lt;li&gt;&lt;code&gt;WHEN_ANCESTOR_OF_FOCUSED_COMPONENT&lt;/code&gt;
                  &lt;/ul&gt;
                  If &lt;code&gt;condition&lt;/code&gt; is &lt;code&gt;WHEN_IN_FOCUSED_WINDOW&lt;/code&gt;
                  and &lt;code&gt;map&lt;/code&gt; is not a &lt;code&gt;ComponentInputMap&lt;/code&gt;, an
                  &lt;code&gt;IllegalArgumentException&lt;/code&gt; will be thrown.
                  Similarly, if &lt;code&gt;condition&lt;/code&gt; is not one of the values
                  listed, an &lt;code&gt;IllegalArgumentException&lt;/code&gt; will be thrown.                
                <param>
                    condition one of the values listed above                    
                </param>
                <param>
                    map  the <code>InputMap</code> to use for the given condition                    
                </param>
                <exception>
                    IllegalArgumentException if <code>condition</code> is
                      <code>WHEN_IN_FOCUSED_WINDOW</code> and <code>map</code>
                      is not an instance of <code>ComponentInputMap</code>; or
                      if <code>condition</code> is not one of the legal values
                      specified above                    
                </exception>
                <since>
                    1.3                    
                </since>
            </javadoc>
            <method name="setInputMap" type="void" line="2377">
                <params>
                    <param name="condition" type="int"/>
                    <param name="map" type="InputMap"/>
                </params>
                <scope line="2380"/>
            </method>
            <javadoc line="2400">
                Returns the &lt;code&gt;InputMap&lt;/code&gt; that is used during
                  &lt;code&gt;condition&lt;/code&gt;.                
                <param>
                    condition one of WHEN_IN_FOCUSED_WINDOW, WHEN_FOCUSED,
                      WHEN_ANCESTOR_OF_FOCUSED_COMPONENT                    
                </param>
                <return>
                    the <code>InputMap</code> for the specified
                      <code>condition</code>                    
                </return>
                <since>
                    1.3                    
                </since>
            </javadoc>
            <method name="getInputMap" type="InputMap" line="2410">
                <params>
                    <param name="condition" type="int"/>
                </params>
            </method>
            <javadoc line="2414">
                Returns the &lt;code&gt;InputMap&lt;/code&gt; that is used when the
                  component has focus.
                  This is convenience method for &lt;code&gt;getInputMap(WHEN_FOCUSED)&lt;/code&gt;.                
                <return>
                    the <code>InputMap</code> used when the component has focus                    
                </return>
                <since>
                    1.3                    
                </since>
            </javadoc>
            <method name="getInputMap" type="InputMap" line="2422"/>
            <javadoc line="2426">
                Sets the &lt;code&gt;ActionMap&lt;/code&gt; to &lt;code&gt;am&lt;/code&gt;. This does not set
                  the parent of the &lt;code&gt;am&lt;/code&gt; to be the &lt;code&gt;ActionMap&lt;/code&gt;
                  from the UI (if there was one), it is up to the caller to have done this.                
                <param>
                    am  the new <code>ActionMap</code>                    
                </param>
                <since>
                    1.3                    
                </since>
            </javadoc>
            <method name="setActionMap" type="void" line="2434">
                <params>
                    <param name="am" type="ActionMap"/>
                </params>
            </method>
            <javadoc line="2439">
                Returns the &lt;code&gt;ActionMap&lt;/code&gt; used to determine what
                  &lt;code&gt;Action&lt;/code&gt; to fire for particular &lt;code&gt;KeyStroke&lt;/code&gt;
                  binding. The returned &lt;code&gt;ActionMap&lt;/code&gt;, unless otherwise
                  set, will have the &lt;code&gt;ActionMap&lt;/code&gt; from the UI set as the parent.                
                <return>
                    the <code>ActionMap</code> containing the key/action bindings                    
                </return>
                <since>
                    1.3                    
                </since>
            </javadoc>
            <method name="getActionMap" type="ActionMap" line="2448"/>
            <javadoc line="2452">
                Returns the &lt;code&gt;InputMap&lt;/code&gt; to use for condition
                  &lt;code&gt;condition&lt;/code&gt;.  If the &lt;code&gt;InputMap&lt;/code&gt; hasn&apos;t
                  been created, and &lt;code&gt;create&lt;/code&gt; is
                  true, it will be created.                
                <param>
                    condition one of the following values:
                      <ul>
                      <li>JComponent.FOCUS_INPUTMAP_CREATED
                      <li>JComponent.WHEN_ANCESTOR_OF_FOCUSED_COMPONENT
                      <li>JComponent.WHEN_IN_FOCUSED_WINDOW
                      </ul>                    
                </param>
                <param>
                    create if true, create the <code>InputMap</code> if it
                      is not already created                    
                </param>
                <return>
                    the <code>InputMap</code> for the given <code>condition</code>;
                      if <code>create</code> is false and the <code>InputMap</code>
                      hasn't been created, returns <code>null</code>                    
                </return>
                <exception>
                    IllegalArgumentException if <code>condition</code>
                      is not one of the legal values listed above                    
                </exception>
            </javadoc>
            <method name="getInputMap" type="InputMap" line="2472">
                <params>
                    <param name="condition" type="int"/>
                    <param name="create" type="boolean"/>
                </params>
                <comment line="2479">
                    Hasn&apos;t been created yet.                    
                </comment>
                <comment line="2490">
                    Hasn&apos;t been created yet.                    
                </comment>
                <comment line="2501">
                    Hasn&apos;t been created yet.                    
                </comment>
                <scope line="2475"/>
                <scope line="2479">
                    <declaration name="km" type="InputMap" line="2480"/>
                </scope>
                <scope line="2486"/>
                <scope line="2490">
                    <declaration name="km" type="InputMap" line="2491"/>
                </scope>
                <scope line="2497"/>
                <scope line="2501">
                    <declaration name="km" type="ComponentInputMap" line="2502"/>
                </scope>
            </method>
            <javadoc line="2513">
                Finds and returns the appropriate &lt;code&gt;ActionMap&lt;/code&gt;.                
                <param>
                    create if true, create the <code>ActionMap</code> if it
                      is not already created                    
                </param>
                <return>
                    the <code>ActionMap</code> for this component; if the
                      <code>create</code> flag is false and there is no
                      current <code>ActionMap</code>, returns <code>null</code>                    
                </return>
            </javadoc>
            <method name="getActionMap" type="ActionMap" line="2522">
                <params>
                    <param name="create" type="boolean"/>
                </params>
                <comment line="2527">
                    Hasn&apos;t been created.                    
                </comment>
                <scope line="2523"/>
                <scope line="2527">
                    <declaration name="am" type="ActionMap" line="2528"/>
                </scope>
            </method>
            <javadoc line="2535">
                Returns the baseline.  The baseline is measured from the top of
                  the component.  This method is primarily meant for
                  &lt;code&gt;LayoutManager&lt;/code&gt;s to align components along their
                  baseline.  A return value less than 0 indicates this component
                  does not have a reasonable baseline and that
                  &lt;code&gt;LayoutManager&lt;/code&gt;s should not align this component on
                  its baseline.
                  &lt;p&gt;
                  This method calls into the &lt;code&gt;ComponentUI&lt;/code&gt; method of the
                  same name.  If this component does not have a &lt;code&gt;ComponentUI&lt;/code&gt;
                  -1 will be returned.  If a value &amp;gt;= 0 is
                  returned, then the component has a valid baseline for any
                  size &amp;gt;= the minimum size and &lt;code&gt;getBaselineResizeBehavior&lt;/code&gt;
                  can be used to determine how the baseline changes with size.                
                <throws>
                    IllegalArgumentException {@inheritDoc}                    
                </throws>
                <see>
                    #getBaselineResizeBehavior                    
                </see>
                <see>
                    java.awt.FontMetrics                    
                </see>
                <since>
                    1.6                    
                </since>
            </javadoc>
            <method name="getBaseline" type="int" line="2556">
                <params>
                    <param name="width" type="int"/>
                    <param name="height" type="int"/>
                </params>
                <comment line="2558">
                    check size.                    
                </comment>
                <scope line="2559"/>
            </method>
            <javadoc line="2565">
                Returns an enum indicating how the baseline of the component
                  changes as the size changes.  This method is primarily meant for
                  layout managers and GUI builders.
                  &lt;p&gt;
                  This method calls into the &lt;code&gt;ComponentUI&lt;/code&gt; method of
                  the same name.  If this component does not have a
                  &lt;code&gt;ComponentUI&lt;/code&gt;
                  &lt;code&gt;BaselineResizeBehavior.OTHER&lt;/code&gt; will be
                  returned.  Subclasses should
                  never return &lt;code&gt;null&lt;/code&gt;; if the baseline can not be
                  calculated return &lt;code&gt;BaselineResizeBehavior.OTHER&lt;/code&gt;.  Callers
                  should first ask for the baseline using
                  &lt;code&gt;getBaseline&lt;/code&gt; and if a value &amp;gt;= 0 is returned use
                  this method.  It is acceptable for this method to return a
                  value other than &lt;code&gt;BaselineResizeBehavior.OTHER&lt;/code&gt; even if
                  &lt;code&gt;getBaseline&lt;/code&gt; returns a value less than 0.                
                <see>
                    #getBaseline(int,int)                    
                </see>
                <since>
                    1.6                    
                </since>
            </javadoc>
            <method name="getBaselineResizeBehavior" type="BaselineResizeBehavior" line="2586">
                <scope line="2587"/>
            </method>
            <javadoc line="2593">
                In release 1.4, the focus subsystem was rearchitected.
                  For more information, see
                  &lt;a href=&quot;http://java.sun.com/docs/books/tutorial/uiswing/misc/focus.html&quot;&gt;
                  How to Use the Focus Subsystem&lt;/a&gt;,
                  a section in &lt;em&gt;The Java Tutorial&lt;/em&gt;.
                  &lt;p&gt;
                  Requests focus on this &lt;code&gt;JComponent&lt;/code&gt;&apos;s
                  &lt;code&gt;FocusTraversalPolicy&lt;/code&gt;&apos;s default &lt;code&gt;Component&lt;/code&gt;.
                  If this &lt;code&gt;JComponent&lt;/code&gt; is a focus cycle root, then its
                  &lt;code&gt;FocusTraversalPolicy&lt;/code&gt; is used. Otherwise, the
                  &lt;code&gt;FocusTraversalPolicy&lt;/code&gt; of this &lt;code&gt;JComponent&lt;/code&gt;&apos;s
                  focus-cycle-root ancestor is used.                
                <see>
                    java.awt.FocusTraversalPolicy#getDefaultComponent                    
                </see>
                <deprecated>
                    As of 1.4, replaced by
                      <code>FocusTraversalPolicy.getDefaultComponent(Container).requestFocus()</code>                    
                </deprecated>
            </javadoc>
            <method name="requestDefaultFocus" type="boolean" line="2612">
                <declaration name="nearestRoot" type="Container" line="2613"/>
                <scope line="2615"/>
                <declaration name="comp" type="Component" line="2618"/>
                <scope line="2620"/>
                <scope line="2623"/>
            </method>
            <javadoc line="2628">
                Makes the component visible or invisible.
                  Overrides &lt;code&gt;Component.setVisible&lt;/code&gt;.                
                <param>
                    aFlag  true to make the component visible; false to
                      make it invisible                    
                </param>
                <beaninfo>
                    attribute: visualUpdate true                    
                </beaninfo>
            </javadoc>
            <method name="setVisible" type="void" line="2638">
                <params>
                    <param name="aFlag" type="boolean"/>
                </params>
                <comment line="2647">
                    Some (all should) LayoutManagers do not consider components
                     that are not visible. As such we need to revalidate when the
                     visible bit changes.                    
                </comment>
                <scope line="2639">
                    <declaration name="parent" type="Container" line="2641"/>
                    <scope line="2642">
                        <declaration name="r" type="Rectangle" line="2643"/>
                    </scope>
                </scope>
            </method>
            <javadoc line="2653">
                Sets whether or not this component is enabled.
                  A component that is enabled may respond to user input,
                  while a component that is not enabled cannot respond to
                  user input.  Some components may alter their visual
                  representation when they are disabled in order to
                  provide feedback to the user that they cannot take input.
                  &lt;p&gt;Note: Disabling a component does not disable its children.
                  &lt;p&gt;Note: Disabling a lightweight component does not prevent it from
                  receiving MouseEvents.                
                <param>
                    enabled true if this component should be enabled, false otherwise                    
                </param>
                <see>
                    java.awt.Component#isEnabled                    
                </see>
                <see>
                    java.awt.Component#isLightweight                    
                </see>
                <beaninfo>
                    preferred: true
                      bound: true
                      attribute: visualUpdate true
                      description: The enabled state of the component.                    
                </beaninfo>
            </javadoc>
            <method name="setEnabled" type="void" line="2675">
                <params>
                    <param name="enabled" type="boolean"/>
                </params>
                <declaration name="oldEnabled" type="boolean" line="2676"/>
                <scope line="2679"/>
            </method>
            <javadoc line="2684">
                Sets the foreground color of this component.  It is up to the
                  look and feel to honor this property, some may choose to ignore
                  it.                
                <param>
                    fg  the desired foreground <code>Color</code>                    
                </param>
                <see>
                    java.awt.Component#getForeground                    
                </see>
                <beaninfo>
                    preferred: true
                      bound: true
                      attribute: visualUpdate true
                      description: The foreground color of the component.                    
                </beaninfo>
            </javadoc>
            <method name="setForeground" type="void" line="2698">
                <params>
                    <param name="fg" type="Color"/>
                </params>
                <comment line="2703">
                    foreground already bound in AWT1.2                    
                </comment>
                <declaration name="oldFg" type="Color" line="2699"/>
                <scope line="2701"/>
            </method>
            <javadoc line="2707">
                Sets the background color of this component.  The background
                  color is used only if the component is opaque, and only
                  by subclasses of &lt;code&gt;JComponent&lt;/code&gt; or
                  &lt;code&gt;ComponentUI&lt;/code&gt; implementations.  Direct subclasses of
                  &lt;code&gt;JComponent&lt;/code&gt; must override
                  &lt;code&gt;paintComponent&lt;/code&gt; to honor this property.
                  &lt;p&gt;
                  It is up to the look and feel to honor this property, some may
                  choose to ignore it.                
                <param>
                    bg the desired background <code>Color</code>                    
                </param>
                <see>
                    java.awt.Component#getBackground                    
                </see>
                <see>
                    #setOpaque                    
                </see>
                <beaninfo>
                    preferred: true
                      bound: true
                      attribute: visualUpdate true
                      description: The background color of the component.                    
                </beaninfo>
            </javadoc>
            <method name="setBackground" type="void" line="2728">
                <params>
                    <param name="bg" type="Color"/>
                </params>
                <comment line="2733">
                    background already bound in AWT1.2                    
                </comment>
                <declaration name="oldBg" type="Color" line="2729"/>
                <scope line="2731"/>
            </method>
            <javadoc line="2737">
                Sets the font for this component.                
                <param>
                    font the desired <code>Font</code> for this component                    
                </param>
                <see>
                    java.awt.Component#getFont                    
                </see>
                <beaninfo>
                    preferred: true
                      bound: true
                      attribute: visualUpdate true
                      description: The font for the component.                    
                </beaninfo>
            </javadoc>
            <method name="setFont" type="void" line="2749">
                <params>
                    <param name="font" type="Font"/>
                </params>
                <comment line="2753">
                    font already bound in AWT1.2                    
                </comment>
                <declaration name="oldFont" type="Font" line="2750"/>
                <scope line="2753"/>
            </method>
            <javadoc line="2759">
                Returns the default locale used to initialize each JComponent&apos;s
                  locale property upon creation.
                  The default locale has &quot;AppContext&quot; scope so that applets (and
                  potentially multiple lightweight applications running in a single VM)
                  can have their own setting. An applet can safely alter its default
                  locale because it will have no affect on other applets (or the browser).                
                <return>
                    the default <code>Locale</code>.                    
                </return>
                <see>
                    #setDefaultLocale                    
                </see>
                <see>
                    java.awt.Component#getLocale                    
                </see>
                <see>
                    #setLocale                    
                </see>
                <since>
                    1.4                    
                </since>
            </javadoc>
            <method name="getDefaultLocale" type="Locale" line="2774">
                <comment line="2778">
                    REMIND(bcb) choosing the default value is more complicated
                    than this.                    
                </comment>
                <declaration name="l" type="Locale" line="2775"/>
                <scope line="2776"/>
            </method>
            <javadoc line="2786">
                Sets the default locale used to initialize each JComponent&apos;s locale
                  property upon creation.  The initial value is the VM&apos;s default locale.
                  The default locale has &quot;AppContext&quot; scope so that applets (and
                  potentially multiple lightweight applications running in a single VM)
                  can have their own setting. An applet can safely alter its default
                  locale because it will have no affect on other applets (or the browser).                
                <param>
                    l the desired default <code>Locale</code> for new components.                    
                </param>
                <see>
                    #getDefaultLocale                    
                </see>
                <see>
                    java.awt.Component#getLocale                    
                </see>
                <see>
                    #setLocale                    
                </see>
                <since>
                    1.4                    
                </since>
            </javadoc>
            <method name="setDefaultLocale" type="void" line="2801">
                <params>
                    <param name="l" type="Locale"/>
                </params>
            </method>
            <javadoc line="2806">
                Processes any key events that the component itself
                  recognizes.  This is called after the focus
                  manager and any interested listeners have been
                  given a chance to steal away the event.  This
                  method is called only if the event has not
                  yet been consumed.  This method is called prior
                  to the keyboard UI logic.
                  &lt;p&gt;
                  This method is implemented to do nothing.  Subclasses would
                  normally override this method if they process some
                  key events themselves.  If the event is processed,
                  it should be consumed.                
            </javadoc>
            <method name="processComponentKeyEvent" type="void" line="2820">
                <params>
                    <param name="e" type="KeyEvent"/>
                </params>
            </method>
            <javadoc line="2823">
                Overrides &lt;code&gt;processKeyEvent&lt;/code&gt; to process events.                
            </javadoc>
            <method name="processKeyEvent" type="void" line="2824">
                <params>
                    <param name="e" type="KeyEvent"/>
                </params>
                <comment line="2829">
                    This gives the key event listeners a crack at the event                    
                </comment>
                <comment line="2832">
                    give the component itself a crack at the event                    
                </comment>
                <declaration name="result" type="boolean" line="2825"/>
                <declaration name="shouldProcessKey" type="boolean" line="2826"/>
                <scope line="2832"/>
                <scope line="2838"/>
                <scope line="2843"/>
            </method>
            <javadoc line="2848">
                Invoked to process the key bindings for &lt;code&gt;ks&lt;/code&gt; as the result
                  of the &lt;code&gt;KeyEvent&lt;/code&gt; &lt;code&gt;e&lt;/code&gt;. This obtains
                  the appropriate &lt;code&gt;InputMap&lt;/code&gt;,
                  gets the binding, gets the action from the &lt;code&gt;ActionMap&lt;/code&gt;,
                  and then (if the action is found and the component
                  is enabled) invokes &lt;code&gt;notifyAction&lt;/code&gt; to notify the action.                
                <param>
                    ks  the <code>KeyStroke</code> queried                    
                </param>
                <param>
                    e the <code>KeyEvent</code>                    
                </param>
                <param>
                    condition one of the following values:
                      <ul>
                      <li>JComponent.WHEN_FOCUSED
                      <li>JComponent.WHEN_ANCESTOR_OF_FOCUSED_COMPONENT
                      <li>JComponent.WHEN_IN_FOCUSED_WINDOW
                      </ul>                    
                </param>
                <param>
                    pressed true if the key is pressed                    
                </param>
                <return>
                    true if there was a binding to an action, and the action
                      was enabled                    
                </return>
                <since>
                    1.3                    
                </since>
            </javadoc>
            <method name="processKeyBinding" type="boolean" line="2871">
                <params>
                    <param name="ks" type="KeyStroke"/>
                    <param name="e" type="KeyEvent"/>
                    <param name="condition" type="int"/>
                    <param name="pressed" type="boolean"/>
                </params>
                <declaration name="map" type="InputMap" line="2872"/>
                <declaration name="am" type="ActionMap" line="2873"/>
                <scope line="2875">
                    <declaration name="binding" type="Object" line="2876"/>
                    <declaration name="action" type="Action" line="2877"/>
                    <scope line="2878"/>
                </scope>
            </method>
            <javadoc line="2886">
                This is invoked as the result of a &lt;code&gt;KeyEvent&lt;/code&gt;
                  that was not consumed by the &lt;code&gt;FocusManager&lt;/code&gt;,
                  &lt;code&gt;KeyListeners&lt;/code&gt;, or the component. It will first try
                  &lt;code&gt;WHEN_FOCUSED&lt;/code&gt; bindings,
                  then &lt;code&gt;WHEN_ANCESTOR_OF_FOCUSED_COMPONENT&lt;/code&gt; bindings,
                  and finally &lt;code&gt;WHEN_IN_FOCUSED_WINDOW&lt;/code&gt; bindings.                
                <param>
                    e the unconsumed <code>KeyEvent</code>                    
                </param>
                <param>
                    pressed true if the key is pressed                    
                </param>
                <return>
                    true if there is a key binding for <code>e</code>                    
                </return>
            </javadoc>
            <method name="processKeyBindings" type="boolean" line="2898">
                <params>
                    <param name="e" type="KeyEvent"/>
                    <param name="pressed" type="boolean"/>
                </params>
                <comment line="2903">
                    Get the KeyStroke
                     There may be two keystrokes associated with a low-level key event;
                     in this case a keystroke made of an extended key code has a priority.                    
                </comment>
                <comment line="2921">
                    Do we have a key binding for e?
                     If we have a binding by an extended code, use it.
                     If not, check for regular code binding.                    
                </comment>
                <comment line="2930">
                    We have no key binding. Let&apos;s try the path from our parent to the
                     window excluded. We store the path components so we can avoid
                     asking the same component twice.                    
                </comment>
                <comment line="2945">
                    This is done so that the children of a JInternalFrame are
                     given precedence for WHEN_IN_FOCUSED_WINDOW bindings before
                     other components WHEN_IN_FOCUSED_WINDOW bindings. This also gives
                     more precedence to the WHEN_IN_FOCUSED_WINDOW bindings of the
                     JInternalFrame&apos;s children vs the
                     WHEN_ANCESTOR_OF_FOCUSED_COMPONENT bindings of the parents.
                     maybe generalize from JInternalFrame (like isFocusCycleRoot).                    
                </comment>
                <comment line="2959">
                    No components between the focused component and the window is
                     actually interested by the key event. Let&apos;s try the other
                     JComponent in this window.                    
                </comment>
                <scope line="2899"/>
                <declaration name="ks" type="KeyStroke" line="2905"/>
                <declaration name="ksE" type="KeyStroke" line="2906"/>
                <scope line="2908"/>
                <scope line="2911">
                    <scope line="2914"/>
                </scope>
                <scope line="2923"/>
                <declaration name="parent" type="Container" line="2933"/>
                <scope line="2935">
                    <scope line="2936"/>
                    <scope line="2952"/>
                </scope>
                <scope line="2962"/>
            </method>
            <method name="processKeyBindingsForAllComponents" type="boolean" line="2969">
                <params>
                    <param name="e" type="KeyEvent"/>
                    <param name="container" type="Container"/>
                    <param name="pressed" type="boolean"/>
                </params>
                <scope line="2970">
                    <scope line="2972"/>
                    <scope line="2975"/>
                    <scope line="2978"/>
                </scope>
            </method>
            <javadoc line="2984">
                Registers the text to display in a tool tip.
                  The text displays when the cursor lingers over the component.
                  &lt;p&gt;
                  See &lt;a href=&quot;http://java.sun.com/docs/books/tutorial/uiswing/components/tooltip.html&quot;&gt;How to Use Tool Tips&lt;/a&gt;
                  in &lt;em&gt;The Java Tutorial&lt;/em&gt;
                  for further documentation.                
                <param>
                    text  the string to display; if the text is <code>null</code>,
                      the tool tip is turned off for this component                    
                </param>
                <see>
                    #TOOL_TIP_TEXT_KEY                    
                </see>
                <beaninfo>
                    preferred: true
                      description: The text to display in a tool tip.                    
                </beaninfo>
            </javadoc>
            <method name="setToolTipText" type="void" line="2999">
                <params>
                    <param name="text" type="String"/>
                </params>
                <declaration name="oldText" type="String" line="3000"/>
                <declaration name="toolTipManager" type="ToolTipManager" line="3002"/>
                <scope line="3003">
                    <scope line="3004"/>
                </scope>
                <scope line="3007"/>
            </method>
            <javadoc line="3012">
                Returns the tooltip string that has been set with
                  &lt;code&gt;setToolTipText&lt;/code&gt;.                
                <return>
                    the text of the tool tip                    
                </return>
                <see>
                    #TOOL_TIP_TEXT_KEY                    
                </see>
            </javadoc>
            <method name="getToolTipText" type="String" line="3019"/>
            <javadoc line="3024">
                Returns the string to be used as the tooltip for &lt;i&gt;event&lt;/i&gt;.
                  By default this returns any string set using
                  &lt;code&gt;setToolTipText&lt;/code&gt;.  If a component provides
                  more extensive API to support differing tooltips at different locations,
                  this method should be overridden.                
            </javadoc>
            <method name="getToolTipText" type="String" line="3031">
                <params>
                    <param name="event" type="MouseEvent"/>
                </params>
            </method>
            <javadoc line="3035">
                Returns the tooltip location in this component&apos;s coordinate system.
                  If &lt;code&gt;null&lt;/code&gt; is returned, Swing will choose a location.
                  The default implementation returns &lt;code&gt;null&lt;/code&gt;.                
                <param>
                    event  the <code>MouseEvent</code> that caused the
                      <code>ToolTipManager</code> to show the tooltip                    
                </param>
                <return>
                    always returns <code>null</code>                    
                </return>
            </javadoc>
            <method name="getToolTipLocation" type="Point" line="3044">
                <params>
                    <param name="event" type="MouseEvent"/>
                </params>
            </method>
            <javadoc line="3048">
                Returns the preferred location to display the popup menu in this
                  component&apos;s coordinate system. It is up to the look and feel to
                  honor this property, some may choose to ignore it.
                  If {@code null}, the look and feel will choose a suitable location.                
                <param>
                    event the {@code MouseEvent} that triggered the popup to be
                      shown, or {@code null} if the popup is not being shown as the
                      result of a mouse event                    
                </param>
                <return>
                    location to display the {@code JPopupMenu}, or {@code null}                    
                </return>
                <since>
                    1.5                    
                </since>
            </javadoc>
            <method name="getPopupLocation" type="Point" line="3060">
                <params>
                    <param name="event" type="MouseEvent"/>
                </params>
            </method>
            <javadoc line="3065">
                Returns the instance of &lt;code&gt;JToolTip&lt;/code&gt; that should be used
                  to display the tooltip.
                  Components typically would not override this method,
                  but it can be used to
                  cause different tooltips to be displayed differently.                
                <return>
                    the <code>JToolTip</code> used to display this toolTip                    
                </return>
            </javadoc>
            <method name="createToolTip" type="JToolTip" line="3074">
                <declaration name="tip" type="JToolTip" line="3075"/>
            </method>
            <javadoc line="3080">
                Forwards the &lt;code&gt;scrollRectToVisible()&lt;/code&gt; message to the
                  &lt;code&gt;JComponent&lt;/code&gt;&apos;s parent. Components that can service
                  the request, such as &lt;code&gt;JViewport&lt;/code&gt;,
                  override this method and perform the scrolling.                
                <param>
                    aRect the visible <code>Rectangle</code>                    
                </param>
                <see>
                    JViewport                    
                </see>
            </javadoc>
            <method name="scrollRectToVisible" type="void" line="3089">
                <params>
                    <param name="aRect" type="Rectangle"/>
                </params>
                <declaration name="parent" type="Container" line="3090"/>
                <declaration name="dx" type="int" line="3091"/>
                <scope line="3097">
                    <declaration name="bounds" type="Rectangle" line="3098"/>
                </scope>
                <scope line="3104"/>
            </method>
            <javadoc line="3114">
                Sets the &lt;code&gt;autoscrolls&lt;/code&gt; property.
                  If &lt;code&gt;true&lt;/code&gt; mouse dragged events will be
                  synthetically generated when the mouse is dragged
                  outside of the component&apos;s bounds and mouse motion
                  has paused (while the button continues to be held
                  down). The synthetic events make it appear that the
                  drag gesture has resumed in the direction established when
                  the component&apos;s boundary was crossed.  Components that
                  support autoscrolling must handle &lt;code&gt;mouseDragged&lt;/code&gt;
                  events by calling &lt;code&gt;scrollRectToVisible&lt;/code&gt; with a
                  rectangle that contains the mouse event&apos;s location.  All of
                  the Swing components that support item selection and are
                  typically displayed in a &lt;code&gt;JScrollPane&lt;/code&gt;
                  (&lt;code&gt;JTable&lt;/code&gt;, &lt;code&gt;JList&lt;/code&gt;, &lt;code&gt;JTree&lt;/code&gt;,
                  &lt;code&gt;JTextArea&lt;/code&gt;, and &lt;code&gt;JEditorPane&lt;/code&gt;)
                  already handle mouse dragged events in this way.  To enable
                  autoscrolling in any other component, add a mouse motion
                  listener that calls &lt;code&gt;scrollRectToVisible&lt;/code&gt;.
                  For example, given a &lt;code&gt;JPanel&lt;/code&gt;, &lt;code&gt;myPanel&lt;/code&gt;:
                  &lt;pre&gt;
                  MouseMotionListener doScrollRectToVisible = new MouseMotionAdapter() {
                  public void mouseDragged(MouseEvent e) {
                  Rectangle r = new Rectangle(e.getX(), e.getY(), 1, 1);
                  ((JPanel)e.getSource()).scrollRectToVisible(r);
                  }
                  };
                  myPanel.addMouseMotionListener(doScrollRectToVisible);
                  &lt;/pre&gt;
                  The default value of the &lt;code&gt;autoScrolls&lt;/code&gt;
                  property is &lt;code&gt;false&lt;/code&gt;.                
                <param>
                    autoscrolls if true, synthetic mouse dragged events
                      are generated when the mouse is dragged outside of a component's
                      bounds and the mouse button continues to be held down; otherwise
                      false                    
                </param>
                <see>
                    #getAutoscrolls                    
                </see>
                <see>
                    JViewport                    
                </see>
                <see>
                    JScrollPane                    
                </see>
                <beaninfo>
                    expert: true
                      description: Determines if this component automatically scrolls its contents when dragged.                    
                </beaninfo>
            </javadoc>
            <method name="setAutoscrolls" type="void" line="3158">
                <params>
                    <param name="autoscrolls" type="boolean"/>
                </params>
                <scope line="3160">
                    <scope line="3162"/>
                    <scope line="3166"/>
                </scope>
            </method>
            <javadoc line="3172">
                Gets the &lt;code&gt;autoscrolls&lt;/code&gt; property.                
                <return>
                    the value of the <code>autoscrolls</code> property                    
                </return>
                <see>
                    JViewport                    
                </see>
                <see>
                    #setAutoscrolls                    
                </see>
            </javadoc>
            <method name="getAutoscrolls" type="boolean" line="3179"/>
            <javadoc line="3183">
                Sets the {@code TransferHandler}, which provides support for transfer
                  of data into and out of this component via cut/copy/paste and drag
                  and drop. This may be {@code null} if the component does not support
                  data transfer operations.
                  &lt;p&gt;
                  If the new {@code TransferHandler} is not {@code null}, this method
                  also installs a &lt;b&gt;new&lt;/b&gt; {@code DropTarget} on the component to
                  activate drop handling through the {@code TransferHandler} and activate
                  any built-in support (such as calculating and displaying potential drop
                  locations). If you do not wish for this component to respond in any way
                  to drops, you can disable drop support entirely either by removing the
                  drop target ({@code setDropTarget(null)}) or by de-activating it
                  ({@code getDropTaget().setActive(false)}).
                  &lt;p&gt;
                  If the new {@code TransferHandler} is {@code null}, this method removes
                  the drop target.
                  &lt;p&gt;
                  Under two circumstances, this method does not modify the drop target:
                  First, if the existing drop target on this component was explicitly
                  set by the developer to a {@code non-null} value. Second, if the
                  system property {@code suppressSwingDropSupport} is {@code true}. The
                  default value for the system property is {@code false}.
                  &lt;p&gt;
                  Please see
                  &lt;a href=&quot;http://java.sun.com/docs/books/tutorial/uiswing/misc/dnd.html&quot;&gt;
                  How to Use Drag and Drop and Data Transfer&lt;/a&gt;,
                  a section in &lt;em&gt;The Java Tutorial&lt;/em&gt;, for more information.                
                <param>
                    newHandler the new {@code TransferHandler}                    
                </param>
                <see>
                    TransferHandler                    
                </see>
                <see>
                    #getTransferHandler                    
                </see>
                <since>
                    1.4                    
                </since>
                <beaninfo>
                    bound: true
                      hidden: true
                      description: Mechanism for transfer of data to and from the component                    
                </beaninfo>
            </javadoc>
            <method name="setTransferHandler" type="void" line="3222">
                <params>
                    <param name="newHandler" type="TransferHandler"/>
                </params>
                <declaration name="oldHandler" type="TransferHandler" line="3223"/>
            </method>
            <javadoc line="3231">
                Gets the &lt;code&gt;transferHandler&lt;/code&gt; property.                
                <return>
                    the value of the <code>transferHandler</code> property                    
                </return>
                <see>
                    TransferHandler                    
                </see>
                <see>
                    #setTransferHandler                    
                </see>
                <since>
                    1.4                    
                </since>
            </javadoc>
            <method name="getTransferHandler" type="TransferHandler" line="3240"/>
            <javadoc line="3244">
                Calculates a custom drop location for this type of component,
                  representing where a drop at the given point should insert data.
                  &lt;code&gt;null&lt;/code&gt; is returned if this component doesn&apos;t calculate
                  custom drop locations. In this case, &lt;code&gt;TransferHandler&lt;/code&gt;
                  will provide a default &lt;code&gt;DropLocation&lt;/code&gt; containing just
                  the point.                
                <param>
                    p the point to calculate a drop location for                    
                </param>
                <return>
                    the drop location, or <code>null</code>                    
                </return>
            </javadoc>
            <method name="dropLocationForPoint" type="TransferHandler.DropLocation" line="3255">
                <params>
                    <param name="p" type="Point"/>
                </params>
            </method>
            <javadoc line="3259">
                Called to set or clear the drop location during a DnD operation.
                  In some cases, the component may need to use its internal selection
                  temporarily to indicate the drop location. To help facilitate this,
                  this method returns and accepts as a parameter a state object.
                  This state object can be used to store, and later restore, the selection
                  state. Whatever this method returns will be passed back to it in
                  future calls, as the state parameter. If it wants the DnD system to
                  continue storing the same state, it must pass it back every time.
                  Here&apos;s how this is used:
                  &lt;p&gt;
                  Let&apos;s say that on the first call to this method the component decides
                  to save some state (because it is about to use the selection to show
                  a drop index). It can return a state object to the caller encapsulating
                  any saved selection state. On a second call, let&apos;s say the drop location
                  is being changed to something else. The component doesn&apos;t need to
                  restore anything yet, so it simply passes back the same state object
                  to have the DnD system continue storing it. Finally, let&apos;s say this
                  method is messaged with &lt;code&gt;null&lt;/code&gt;. This means DnD
                  is finished with this component for now, meaning it should restore
                  state. At this point, it can use the state parameter to restore
                  said state, and of course return &lt;code&gt;null&lt;/code&gt; since there&apos;s
                  no longer anything to store.                
                <param>
                    location the drop location (as calculated by
                      <code>dropLocationForPoint</code>) or <code>null</code>
                      if there's no longer a valid drop location                    
                </param>
                <param>
                    state the state object saved earlier for this component,
                      or <code>null</code>                    
                </param>
                <param>
                    forDrop whether or not the method is being called because an
                      actual drop occurred                    
                </param>
                <return>
                    any saved state for this component, or <code>null</code> if none                    
                </return>
            </javadoc>
            <method name="setDropLocation" type="Object" line="3294">
                <params>
                    <param name="location" type="TransferHandler.DropLocation"/>
                    <param name="state" type="Object"/>
                    <param name="forDrop" type="boolean"/>
                </params>
            </method>
            <javadoc line="3299">
                Called to indicate to this component that DnD is done.
                  Needed by &lt;code&gt;JTree&lt;/code&gt;.                
            </javadoc>
            <method name="dndDone" type="void" line="3303"/>
            <javadoc line="3306">
                Processes mouse events occurring on this component by
                  dispatching them to any registered
                  &lt;code&gt;MouseListener&lt;/code&gt; objects, refer to{@link java.awt.Component#processMouseEvent(MouseEvent)}for a complete description of this method.                
                <param>
                    e the mouse event                    
                </param>
                <see>
                    java.awt.Component#processMouseEvent                    
                </see>
                <since>
                    1.5                    
                </since>
            </javadoc>
            <method name="processMouseEvent" type="void" line="3317">
                <params>
                    <param name="e" type="MouseEvent"/>
                </params>
                <scope line="3318"/>
            </method>
            <javadoc line="3324">
                Processes mouse motion events, such as MouseEvent.MOUSE_DRAGGED.                
                <param>
                    e the <code>MouseEvent</code>                    
                </param>
                <see>
                    MouseEvent                    
                </see>
            </javadoc>
            <method name="processMouseMotionEvent" type="void" line="3330">
                <params>
                    <param name="e" type="MouseEvent"/>
                </params>
                <comment line="3334">
                    We don&apos;t want to do the drags when the mouse moves if we&apos;re
                     autoscrolling.  It makes it feel spastic.                    
                </comment>
                <declaration name="dispatch" type="boolean" line="3331"/>
                <scope line="3332"/>
                <scope line="3338"/>
            </method>
            <method name="superProcessMouseMotionEvent" type="void" line="3344">
                <params>
                    <param name="e" type="MouseEvent"/>
                </params>
            </method>
            <javadoc line="3348">
                This is invoked by the &lt;code&gt;RepaintManager&lt;/code&gt; if
                  &lt;code&gt;createImage&lt;/code&gt; is called on the component.                
                <param>
                    newValue true if the double buffer image was created from this component                    
                </param>
            </javadoc>
            <method name="setCreatedDoubleBuffer" type="void" line="3354">
                <params>
                    <param name="newValue" type="boolean"/>
                </params>
            </method>
            <javadoc line="3358">
                Returns true if the &lt;code&gt;RepaintManager&lt;/code&gt;
                  created the double buffer image from the component.                
                <return>
                    true if this component had a double buffer image, false otherwise                    
                </return>
            </javadoc>
            <method name="getCreatedDoubleBuffer" type="boolean" line="3364"/>
            <class name="ActionStandin" line="3368">
                <comment line="3377">
                    This will be non-null if actionListener is an Action.                    
                </comment>
                <comment line="3427">
                    We don&apos;t allow any values to be added.                    
                </comment>
                <comment line="3430">
                    Does nothing, our enabledness is determiend from our asociated
                     action.                    
                </comment>
                <comment line="3477">
                    Get the array of key codes from the AppContext.                    
                </comment>
                <comment line="3738">
                    inner class AccessibleFocusHandler                    
                </comment>
                <comment line="3799">
                    AccessibleContext methods                    
                </comment>
                <comment line="3948">
                    ----- AccessibleExtendedComponent                    
                </comment>
                <comment line="5004">
                    package private                    
                </comment>
                <implements interface="Action"/>
                <javadoc line="3368">
                    &lt;code&gt;ActionStandin&lt;/code&gt; is used as a standin for
                      &lt;code&gt;ActionListeners&lt;/code&gt; that are
                      added via &lt;code&gt;registerKeyboardAction&lt;/code&gt;.                    
                </javadoc>
                <declaration name="actionListener" type="ActionListener" line="3374"/>
                <declaration name="command" type="String" line="3375"/>
                <declaration name="action" type="Action" line="3377"/>
                <method name="ActionStandin" type="constructor" line="3379">
                    <params>
                        <param name="actionListener" type="ActionListener"/>
                        <param name="command" type="String"/>
                    </params>
                    <scope line="3381"/>
                    <scope line="3384"/>
                </method>
                <method name="getValue" type="Object" line="3390">
                    <params>
                        <param name="key" type="String"/>
                    </params>
                    <scope line="3391">
                        <scope line="3392"/>
                        <scope line="3395"/>
                        <scope line="3398"/>
                    </scope>
                </method>
                <method name="isEnabled" type="boolean" line="3405">
                    <comment line="3408">
                        This keeps the old semantics where
                         registerKeyboardAction(null) would essentialy remove
                         the binding. We don&apos;t remove the binding from the
                         InputMap as that would still allow parent InputMaps
                         bindings to be accessed.                        
                    </comment>
                    <scope line="3406"/>
                    <scope line="3414"/>
                </method>
                <method name="actionPerformed" type="void" line="3420">
                    <params>
                        <param name="ae" type="ActionEvent"/>
                    </params>
                    <scope line="3421"/>
                </method>
                <method name="putValue" type="void" line="3427">
                    <params>
                        <param name="key" type="String"/>
                        <param name="value" type="Object"/>
                    </params>
                </method>
                <method name="setEnabled" type="void" line="3431">
                    <params>
                        <param name="b" type="boolean"/>
                    </params>
                </method>
                <method name="addPropertyChangeListener" type="void" line="3434">
                    <params>
                        <param name="listener" type="PropertyChangeListener"/>
                    </params>
                </method>
                <method name="removePropertyChangeListener" type="void" line="3436">
                    <params>
                        <param name="listener" type="PropertyChangeListener"/>
                    </params>
                </method>
            </class>
            <class name="IntVector" line="3442">
                <comment line="3377">
                    This will be non-null if actionListener is an Action.                    
                </comment>
                <comment line="3427">
                    We don&apos;t allow any values to be added.                    
                </comment>
                <comment line="3430">
                    Does nothing, our enabledness is determiend from our asociated
                     action.                    
                </comment>
                <comment line="3477">
                    Get the array of key codes from the AppContext.                    
                </comment>
                <comment line="3738">
                    inner class AccessibleFocusHandler                    
                </comment>
                <comment line="3799">
                    AccessibleContext methods                    
                </comment>
                <comment line="3948">
                    ----- AccessibleExtendedComponent                    
                </comment>
                <comment line="5004">
                    package private                    
                </comment>
                <declaration name="array" type="int" line="3443"/>
                <declaration name="count" type="int" line="3444"/>
                <declaration name="capacity" type="int" line="3445"/>
                <method name="size" type="int" line="3447"/>
                <method name="elementAt" type="int" line="3451">
                    <params>
                        <param name="index" type="int"/>
                    </params>
                </method>
                <method name="addElement" type="void" line="3455">
                    <params>
                        <param name="value" type="int"/>
                    </params>
                    <scope line="3456">
                        <declaration name="newarray" type="int[]" line="3458"/>
                        <scope line="3459"/>
                    </scope>
                </method>
                <method name="setElementAt" type="void" line="3467">
                    <params>
                        <param name="value" type="int"/>
                        <param name="index" type="int"/>
                    </params>
                </method>
            </class>
            <class name="KeyboardState" line="3472">
                <comment line="3377">
                    This will be non-null if actionListener is an Action.                    
                </comment>
                <comment line="3427">
                    We don&apos;t allow any values to be added.                    
                </comment>
                <comment line="3430">
                    Does nothing, our enabledness is determiend from our asociated
                     action.                    
                </comment>
                <comment line="3477">
                    Get the array of key codes from the AppContext.                    
                </comment>
                <comment line="3738">
                    inner class AccessibleFocusHandler                    
                </comment>
                <comment line="3799">
                    AccessibleContext methods                    
                </comment>
                <comment line="3948">
                    ----- AccessibleExtendedComponent                    
                </comment>
                <comment line="5004">
                    package private                    
                </comment>
                <implements interface="Serializable"/>
                <declaration name="keyCodesKey" type="Object" line="3473"/>
                <method name="getKeyCodeArray" type="IntVector" line="3477">
                    <declaration name="iv" type="IntVector" line="3478"/>
                    <scope line="3480"/>
                </method>
                <method name="registerKeyPressed" type="void" line="3487">
                    <params>
                        <param name="keyCode" type="int"/>
                    </params>
                    <declaration name="kca" type="IntVector" line="3488"/>
                    <declaration name="count" type="int" line="3489"/>
                    <declaration name="i" type="int" line="3490"/>
                    <scope line="3491">
                        <scope line="3492"/>
                    </scope>
                </method>
                <method name="registerKeyReleased" type="void" line="3500">
                    <params>
                        <param name="keyCode" type="int"/>
                    </params>
                    <declaration name="kca" type="IntVector" line="3501"/>
                    <declaration name="count" type="int" line="3502"/>
                    <declaration name="i" type="int" line="3503"/>
                    <scope line="3504">
                        <scope line="3505"/>
                    </scope>
                </method>
                <method name="keyIsPressed" type="boolean" line="3512">
                    <params>
                        <param name="keyCode" type="int"/>
                    </params>
                    <declaration name="kca" type="IntVector" line="3513"/>
                    <declaration name="count" type="int" line="3514"/>
                    <declaration name="i" type="int" line="3515"/>
                    <scope line="3516">
                        <scope line="3517"/>
                    </scope>
                </method>
                <javadoc line="3524">
                    Updates internal state of the KeyboardState and returns true
                      if the event should be processed further.                    
                </javadoc>
                <method name="shouldProcess" type="boolean" line="3528">
                    <params>
                        <param name="e" type="KeyEvent"/>
                    </params>
                    <comment line="3537">
                        We are forced to process VK_PRINTSCREEN separately because
                         the Windows doesn&apos;t generate the key pressed event for
                         printscreen and it block the processing of key release
                         event for printscreen.                        
                    </comment>
                    <comment line="3549">
                        Not a known KeyEvent type, bail.                        
                    </comment>
                    <scope line="3531"/>
                    <scope line="3540"/>
                </method>
            </class>
            <declaration name="focusController" type="sun.awt.RequestFocusController" line="3554"/>
            <anonymous_class line="3555">
                <method name="acceptRequestFocus" type="boolean" line="3559">
                    <params>
                        <param name="from" type="Component"/>
                        <param name="to" type="Component"/>
                        <param name="temporary" type="boolean"/>
                        <param name="focusedWindowChangeAllowed" type="boolean"/>
                        <param name="cause" type="sun.awt.CausedFocusEvent.Cause"/>
                    </params>
                    <comment line="3583">
                        We&apos;re currently calling into the InputVerifier
                         for this component, so allow the focus change.                        
                    </comment>
                    <comment line="3593">
                        We&apos;re already in the InputVerifier for
                         currentSource. By resetting the currentSource
                         we ensure that if the InputVerifier for
                         currentSource does a requestFocus, we don&apos;t
                         try and run the InputVerifier again.                        
                    </comment>
                    <scope line="3560"/>
                    <scope line="3564"/>
                    <declaration name="target" type="JComponent" line="3568"/>
                    <scope line="3569"/>
                    <declaration name="jFocusOwner" type="JComponent" line="3573"/>
                    <declaration name="iv" type="InputVerifier" line="3574"/>
                    <scope line="3576"/>
                    <scope line="3578">
                        <declaration name="currentSource" type="Object" line="3579"/>
                        <scope line="3581"/>
                        <scope line="3588"/>
                        <scope line="3590">
                            <scope line="3591"/>
                            <scope line="3599"/>
                        </scope>
                    </scope>
                </method>
            </anonymous_class>
            <javadoc line="3612">
                @deprecated As of JDK version 1.1,
                  replaced by &lt;code&gt;java.awt.Component.setEnabled(boolean)&lt;/code&gt;.                
            </javadoc>
            <method name="enable" type="void" line="3617">
                <scope line="3618">
                    <scope line="3620"/>
                </scope>
            </method>
            <javadoc line="3628">
                @deprecated As of JDK version 1.1,
                  replaced by &lt;code&gt;java.awt.Component.setEnabled(boolean)&lt;/code&gt;.                
            </javadoc>
            <method name="disable" type="void" line="3633">
                <scope line="3634">
                    <scope line="3636"/>
                </scope>
            </method>
            <declaration name="accessibleContext" type="AccessibleContext" line="3644"/>
            <javadoc line="3644">
                The &lt;code&gt;AccessibleContext&lt;/code&gt; associated with this
                  &lt;code&gt;JComponent&lt;/code&gt;.                
            </javadoc>
            <javadoc line="3650">
                Returns the &lt;code&gt;AccessibleContext&lt;/code&gt; associated with this
                  &lt;code&gt;JComponent&lt;/code&gt;.  The method implemented by this base
                  class returns null.  Classes that extend &lt;code&gt;JComponent&lt;/code&gt;
                  should implement this method to return the
                  &lt;code&gt;AccessibleContext&lt;/code&gt; associated with the subclass.                
                <return>
                    the <code>AccessibleContext</code> of this
                      <code>JComponent</code>                    
                </return>
            </javadoc>
            <method name="getAccessibleContext" type="AccessibleContext" line="3660"/>
            <class name="AccessibleJComponent" line="3664">
                <extends class="AccessibleAWTContainer"/>
                <comment line="3377">
                    This will be non-null if actionListener is an Action.                    
                </comment>
                <comment line="3427">
                    We don&apos;t allow any values to be added.                    
                </comment>
                <comment line="3430">
                    Does nothing, our enabledness is determiend from our asociated
                     action.                    
                </comment>
                <comment line="3477">
                    Get the array of key codes from the AppContext.                    
                </comment>
                <comment line="3738">
                    inner class AccessibleFocusHandler                    
                </comment>
                <comment line="3799">
                    AccessibleContext methods                    
                </comment>
                <comment line="3948">
                    ----- AccessibleExtendedComponent                    
                </comment>
                <comment line="5004">
                    package private                    
                </comment>
                <implements interface="AccessibleExtendedComponent"/>
                <javadoc line="3664">
                    Inner class of JComponent used to provide default support for
                      accessibility.  This class is not meant to be used directly by
                      application developers, but is instead meant only to be
                      subclassed by component developers.
                      &lt;p&gt;
                      &lt;strong&gt;Warning:&lt;/strong&gt;
                      Serialized objects of this class will not be compatible with
                      future Swing releases. The current serialization support is
                      appropriate for short term storage or RMI between applications running
                      the same version of Swing.  As of 1.4, support for long term storage
                      of all JavaBeans&lt;sup&gt;&lt;font size=&quot;-2&quot;&gt;TM&lt;/font&gt;&lt;/sup&gt;
                      has been added to the &lt;code&gt;java.beans&lt;/code&gt; package.
                      Please see {@link java.beans.XMLEncoder}.                    
                </javadoc>
                <javadoc line="3682">
                    Though the class is abstract, this should be called by
                      all sub-classes.                    
                </javadoc>
                <method name="AccessibleJComponent" type="constructor" line="3686"/>
                <declaration name="accessibleContainerHandler" type="ContainerListener" line="3690"/>
                <declaration name="accessibleFocusHandler" type="FocusListener" line="3691"/>
                <class name="AccessibleContainerHandler" line="3693">
                    <implements interface="ContainerListener"/>
                    <javadoc line="3693">
                        Fire PropertyChange listener, if one is registered,
                          when children added/removed.                        
                    </javadoc>
                    <method name="componentAdded" type="void" line="3699">
                        <params>
                            <param name="e" type="ContainerEvent"/>
                        </params>
                        <declaration name="c" type="Component" line="3700"/>
                        <scope line="3701"/>
                    </method>
                    <method name="componentRemoved" type="void" line="3707">
                        <params>
                            <param name="e" type="ContainerEvent"/>
                        </params>
                        <declaration name="c" type="Component" line="3708"/>
                        <scope line="3709"/>
                    </method>
                </class>
                <class name="AccessibleFocusHandler" line="3717">
                    <implements interface="FocusListener"/>
                    <javadoc line="3717">
                        Fire PropertyChange listener, if one is registered,
                          when focus events happen                        
                        <since>
                            1.3                            
                        </since>
                    </javadoc>
                    <method name="focusGained" type="void" line="3723">
                        <params>
                            <param name="event" type="FocusEvent"/>
                        </params>
                        <scope line="3724"/>
                    </method>
                    <method name="focusLost" type="void" line="3730">
                        <params>
                            <param name="event" type="FocusEvent"/>
                        </params>
                        <scope line="3731"/>
                    </method>
                </class>
                <javadoc line="3740">
                    Adds a PropertyChangeListener to the listener list.                    
                    <param>
                        listener  the PropertyChangeListener to be added                        
                    </param>
                </javadoc>
                <method name="addPropertyChangeListener" type="void" line="3745">
                    <params>
                        <param name="listener" type="PropertyChangeListener"/>
                    </params>
                    <scope line="3746"/>
                    <scope line="3750"/>
                </method>
                <javadoc line="3757">
                    Removes a PropertyChangeListener from the listener list.
                      This removes a PropertyChangeListener that was registered
                      for all properties.                    
                    <param>
                        listener  the PropertyChangeListener to be removed                        
                    </param>
                </javadoc>
                <method name="removePropertyChangeListener" type="void" line="3764">
                    <params>
                        <param name="listener" type="PropertyChangeListener"/>
                    </params>
                    <scope line="3765"/>
                </method>
                <javadoc line="3774">
                    Recursively search through the border hierarchy (if it exists)
                      for a TitledBorder with a non-null title.  This does a depth
                      first search on first the inside borders then the outside borders.
                      The assumption is that titles make really pretty inside borders
                      but not very pretty outside borders in compound border situations.
                      It&apos;s rather arbitrary, but hopefully decent UI programmers will
                      not create multiple titled borders for the same component.                    
                </javadoc>
                <method name="getBorderTitle" type="String" line="3783">
                    <params>
                        <param name="b" type="Border"/>
                    </params>
                    <declaration name="s" type="String" line="3784"/>
                    <scope line="3785"/>
                    <scope line="3787">
                        <scope line="3789"/>
                    </scope>
                    <scope line="3793"/>
                </method>
                <javadoc line="3800">
                    Gets the accessible name of this object.  This should almost never
                      return java.awt.Component.getName(), as that generally isn&apos;t
                      a localized name, and doesn&apos;t have meaning for the user.  If the
                      object is fundamentally a text object (such as a menu item), the
                      accessible name should be the text of the object (for example,
                      &quot;save&quot;).
                      If the object has a tooltip, the tooltip text may also be an
                      appropriate String to return.                    
                    <return>
                        the localized name of the object -- can be null if this
                          object does not have a name                        
                    </return>
                    <see>
                        AccessibleContext#setAccessibleName                        
                    </see>
                </javadoc>
                <method name="getAccessibleName" type="String" line="3814">
                    <comment line="3818">
                        fallback to the client name property                        
                    </comment>
                    <comment line="3824">
                        fallback to the titled border if it exists                        
                    </comment>
                    <comment line="3830">
                        fallback to the label labeling us if it exists                        
                    </comment>
                    <declaration name="name" type="String" line="3815"/>
                    <scope line="3819"/>
                    <scope line="3825"/>
                    <scope line="3831">
                        <declaration name="o" type="Object" line="3832"/>
                        <scope line="3833">
                            <declaration name="ac" type="AccessibleContext" line="3834"/>
                            <scope line="3835"/>
                        </scope>
                    </scope>
                </method>
                <javadoc line="3843">
                    Gets the accessible description of this object.  This should be
                      a concise, localized description of what this object is - what
                      is its meaning to the user.  If the object has a tooltip, the
                      tooltip text may be an appropriate string to return, assuming
                      it contains a concise description of the object (instead of just
                      the name of the object - for example a &quot;Save&quot; icon on a toolbar that
                      had &quot;save&quot; as the tooltip text shouldn&apos;t return the tooltip
                      text as the description, but something like &quot;Saves the current
                      text document&quot; instead).                    
                    <return>
                        the localized description of the object -- can be null if
                          this object does not have a description                        
                    </return>
                    <see>
                        AccessibleContext#setAccessibleDescription                        
                    </see>
                </javadoc>
                <method name="getAccessibleDescription" type="String" line="3858">
                    <comment line="3862">
                        fallback to the client description property                        
                    </comment>
                    <comment line="3868">
                        fallback to the tool tip text if it exists                        
                    </comment>
                    <comment line="3874">
                        Just in case the subclass overrode the
                         getToolTipText method and actually
                         requires a MouseEvent.
                         [[[FIXME:  WDW - we probably should require this
                         method to take a MouseEvent and just pass it on
                         to getToolTipText.  The swing-feedback traffic
                         leads me to believe getToolTipText might change,
                         though, so I was hesitant to make this change at
                         this time.]]]                        
                    </comment>
                    <comment line="3886">
                        fallback to the label labeling us if it exists                        
                    </comment>
                    <declaration name="description" type="String" line="3859"/>
                    <scope line="3863"/>
                    <scope line="3869">
                        <scope line="3870"/>
                        <scope line="3872"/>
                    </scope>
                    <scope line="3887">
                        <declaration name="o" type="Object" line="3888"/>
                        <scope line="3889">
                            <declaration name="ac" type="AccessibleContext" line="3890"/>
                            <scope line="3891"/>
                        </scope>
                    </scope>
                </method>
                <javadoc line="3900">
                    Gets the role of this object.                    
                    <return>
                        an instance of AccessibleRole describing the role of the
                          object                        
                    </return>
                    <see>
                        AccessibleRole                        
                    </see>
                </javadoc>
                <method name="getAccessibleRole" type="AccessibleRole" line="3907"/>
                <javadoc line="3911">
                    Gets the state of this object.                    
                    <return>
                        an instance of AccessibleStateSet containing the current
                          state set of the object                        
                    </return>
                    <see>
                        AccessibleState                        
                    </see>
                </javadoc>
                <method name="getAccessibleStateSet" type="AccessibleStateSet" line="3918">
                    <declaration name="states" type="AccessibleStateSet" line="3919"/>
                    <scope line="3920"/>
                </method>
                <javadoc line="3926">
                    Returns the number of accessible children in the object.  If all
                      of the children of this object implement Accessible, than this
                      method should return the number of children of this object.                    
                    <return>
                        the number of accessible children in the object.                        
                    </return>
                </javadoc>
                <method name="getAccessibleChildrenCount" type="int" line="3933"/>
                <javadoc line="3937">
                    Returns the nth Accessible child of the object.                    
                    <param>
                        i zero-based index of child                        
                    </param>
                    <return>
                        the nth Accessible child of the object                        
                    </return>
                </javadoc>
                <method name="getAccessibleChild" type="Accessible" line="3943">
                    <params>
                        <param name="i" type="int"/>
                    </params>
                </method>
                <javadoc line="3949">
                    Returns the AccessibleExtendedComponent                    
                    <return>
                        the AccessibleExtendedComponent                        
                    </return>
                </javadoc>
                <method name="getAccessibleExtendedComponent" type="AccessibleExtendedComponent" line="3954"/>
                <javadoc line="3958">
                    Returns the tool tip text                    
                    <return>
                        the tool tip text, if supported, of the object;
                          otherwise, null                        
                    </return>
                    <since>
                        1.4                        
                    </since>
                </javadoc>
                <method name="getToolTipText" type="String" line="3965"/>
                <javadoc line="3969">
                    Returns the titled border text                    
                    <return>
                        the titled border text, if supported, of the object;
                          otherwise, null                        
                    </return>
                    <since>
                        1.4                        
                    </since>
                </javadoc>
                <method name="getTitledBorderText" type="String" line="3976">
                    <declaration name="border" type="Border" line="3977"/>
                    <scope line="3978"/>
                    <scope line="3980"/>
                </method>
                <javadoc line="3985">
                    Returns key bindings associated with this object                    
                    <return>
                        the key bindings, if supported, of the object;
                          otherwise, null                        
                    </return>
                    <see>
                        AccessibleKeyBinding                        
                    </see>
                    <since>
                        1.4                        
                    </since>
                </javadoc>
                <method name="getAccessibleKeyBinding" type="AccessibleKeyBinding" line="3993"/>
            </class>
            <javadoc line="3999">
                Returns an &lt;code&gt;ArrayTable&lt;/code&gt; used for
                  key/value &quot;client properties&quot; for this component. If the
                  &lt;code&gt;clientProperties&lt;/code&gt; table doesn&apos;t exist, an empty one
                  will be created.                
                <return>
                    an ArrayTable                    
                </return>
                <see>
                    #putClientProperty                    
                </see>
                <see>
                    #getClientProperty                    
                </see>
            </javadoc>
            <method name="getClientProperties" type="ArrayTable" line="4009">
                <scope line="4010"/>
            </method>
            <javadoc line="4017">
                Returns the value of the property with the specified key.  Only
                  properties added with &lt;code&gt;putClientProperty&lt;/code&gt; will return
                  a non-&lt;code&gt;null&lt;/code&gt; value.                
                <param>
                    key the being queried                    
                </param>
                <return>
                    the value of this property or <code>null</code>                    
                </return>
                <see>
                    #putClientProperty                    
                </see>
            </javadoc>
            <method name="getClientProperty" type="Object" line="4026">
                <params>
                    <param name="key" type="Object"/>
                </params>
                <scope line="4027"/>
                <scope line="4029"/>
                <scope line="4032"/>
                <scope line="4034">
                    <scope line="4035"/>
                </scope>
            </method>
            <javadoc line="4041">
                Adds an arbitrary key/value &quot;client property&quot; to this component.
                  &lt;p&gt;
                  The &lt;code&gt;get/putClientProperty&lt;/code&gt; methods provide access to
                  a small per-instance hashtable. Callers can use get/putClientProperty
                  to annotate components that were created by another module.
                  For example, a
                  layout manager might store per child constraints this way. For example:
                  &lt;pre&gt;
                  componentA.putClientProperty(&quot;to the left of&quot;, componentB);
                  &lt;/pre&gt;
                  If value is &lt;code&gt;null&lt;/code&gt; this method will remove the property.
                  Changes to client properties are reported with
                  &lt;code&gt;PropertyChange&lt;/code&gt; events.
                  The name of the property (for the sake of PropertyChange
                  events) is &lt;code&gt;key.toString()&lt;/code&gt;.
                  &lt;p&gt;
                  The &lt;code&gt;clientProperty&lt;/code&gt; dictionary is not intended to
                  support large
                  scale extensions to JComponent nor should be it considered an
                  alternative to subclassing when designing a new component.                
                <param>
                    key the new client property key                    
                </param>
                <param>
                    value the new client property value; if <code>null</code>
                      this method will remove the property                    
                </param>
                <see>
                    #getClientProperty                    
                </see>
                <see>
                    #addPropertyChangeListener                    
                </see>
            </javadoc>
            <method name="putClientProperty" type="void" line="4069">
                <params>
                    <param name="key" type="Object"/>
                    <param name="value" type="Object"/>
                </params>
                <comment line="4076">
                    Both the value and ArrayTable are null, implying we don&apos;t
                     have to do anything.                    
                </comment>
                <comment line="4089">
                    old == new == null                    
                </comment>
                <scope line="4070"/>
                <scope line="4074"/>
                <declaration name="clientProperties" type="ArrayTable" line="4079"/>
                <declaration name="oldValue" type="Object" line="4080"/>
                <scope line="4081">
                    <scope line="4083"/>
                    <scope line="4085"/>
                    <scope line="4087"/>
                </scope>
            </method>
            <method name="clientPropertyChanged" type="void" line="4099">
                <params>
                    <param name="key" type="Object"/>
                    <param name="oldValue" type="Object"/>
                    <param name="newValue" type="Object"/>
                </params>
            </method>
            <method name="setUIProperty" type="void" line="4113">
                <params>
                    <param name="propertyName" type="String"/>
                    <param name="value" type="Object"/>
                </params>
                <scope line="4114">
                    <scope line="4115"/>
                </scope>
                <scope line="4119">
                    <scope line="4120"/>
                </scope>
                <scope line="4124">
                    <scope line="4125"/>
                </scope>
                <scope line="4130">
                    <scope line="4131"/>
                </scope>
                <scope line="4136"/>
            </method>
            <javadoc line="4143">
                Sets the focus traversal keys for a given traversal operation for this
                  Component.
                  Refer to{@link java.awt.Component#setFocusTraversalKeys}for a complete description of this method.                
                <param>
                    id one of KeyboardFocusManager.FORWARD_TRAVERSAL_KEYS,
                      KeyboardFocusManager.BACKWARD_TRAVERSAL_KEYS, or
                      KeyboardFocusManager.UP_CYCLE_TRAVERSAL_KEYS                    
                </param>
                <param>
                    keystrokes the Set of AWTKeyStroke for the specified operation                    
                </param>
                <see>
                    java.awt.KeyboardFocusManager#FORWARD_TRAVERSAL_KEYS                    
                </see>
                <see>
                    java.awt.KeyboardFocusManager#BACKWARD_TRAVERSAL_KEYS                    
                </see>
                <see>
                    java.awt.KeyboardFocusManager#UP_CYCLE_TRAVERSAL_KEYS                    
                </see>
                <throws>
                    IllegalArgumentException if id is not one of
                      KeyboardFocusManager.FORWARD_TRAVERSAL_KEYS,
                      KeyboardFocusManager.BACKWARD_TRAVERSAL_KEYS, or
                      KeyboardFocusManager.UP_CYCLE_TRAVERSAL_KEYS, or if keystrokes
                      contains null, or if any Object in keystrokes is not an
                      AWTKeyStroke, or if any keystroke represents a KEY_TYPED event,
                      or if any keystroke already maps to another focus traversal
                      operation for this Component                    
                </throws>
                <since>
                    1.5                    
                </since>
                <beaninfo>
                    bound: true                    
                </beaninfo>
            </javadoc>
            <method name="setFocusTraversalKeys" type="void" line="4171">
                <params>
                    <param name="id" type="int"/>
                    <param name="keystrokes" type="Set<? extends AWTKeyStroke>"/>
                </params>
                <scope line="4172"/>
                <scope line="4174"/>
            </method>
            <javadoc line="4185">
                Returns true if this component is lightweight, that is, if it doesn&apos;t
                  have a native window system peer.                
                <return>
                    true if this component is lightweight                    
                </return>
            </javadoc>
            <method name="isLightweightComponent" type="boolean" line="4191">
                <params>
                    <param name="c" type="Component"/>
                </params>
            </method>
            <javadoc line="4196">
                @deprecated As of JDK 5,
                  replaced by &lt;code&gt;Component.setBounds(int, int, int, int)&lt;/code&gt;.
                  &lt;p&gt;
                  Moves and resizes this component.                
                <param>
                    x  the new horizontal location                    
                </param>
                <param>
                    y  the new vertical location                    
                </param>
                <param>
                    w  the new width                    
                </param>
                <param>
                    h  the new height                    
                </param>
                <see>
                    java.awt.Component#setBounds                    
                </see>
            </javadoc>
            <method name="reshape" type="void" line="4209">
                <params>
                    <param name="x" type="int"/>
                    <param name="y" type="int"/>
                    <param name="w" type="int"/>
                    <param name="h" type="int"/>
                </params>
            </method>
            <javadoc line="4214">
                Stores the bounds of this component into &quot;return value&quot;
                  &lt;code&gt;rv&lt;/code&gt; and returns &lt;code&gt;rv&lt;/code&gt;.
                  If &lt;code&gt;rv&lt;/code&gt; is &lt;code&gt;null&lt;/code&gt; a new &lt;code&gt;Rectangle&lt;/code&gt;
                  is allocated.  This version of &lt;code&gt;getBounds&lt;/code&gt; is useful
                  if the caller wants to avoid allocating a new &lt;code&gt;Rectangle&lt;/code&gt;
                  object on the heap.                
                <param>
                    rv the return value, modified to the component's bounds                    
                </param>
                <return>
                    <code>rv</code>; if <code>rv</code> is <code>null</code>
                      return a newly created <code>Rectangle</code> with this
                      component's bounds                    
                </return>
            </javadoc>
            <method name="getBounds" type="Rectangle" line="4227">
                <params>
                    <param name="rv" type="Rectangle"/>
                </params>
                <scope line="4228"/>
                <scope line="4231"/>
            </method>
            <javadoc line="4238">
                Stores the width/height of this component into &quot;return value&quot;
                  &lt;code&gt;rv&lt;/code&gt; and returns &lt;code&gt;rv&lt;/code&gt;.
                  If &lt;code&gt;rv&lt;/code&gt; is &lt;code&gt;null&lt;/code&gt; a new &lt;code&gt;Dimension&lt;/code&gt;
                  object is allocated.  This version of &lt;code&gt;getSize&lt;/code&gt;
                  is useful if the caller wants to avoid allocating a new
                  &lt;code&gt;Dimension&lt;/code&gt; object on the heap.                
                <param>
                    rv the return value, modified to the component's size                    
                </param>
                <return>
                    <code>rv</code>                    
                </return>
            </javadoc>
            <method name="getSize" type="Dimension" line="4249">
                <params>
                    <param name="rv" type="Dimension"/>
                </params>
                <scope line="4250"/>
                <scope line="4253"/>
            </method>
            <javadoc line="4260">
                Stores the x,y origin of this component into &quot;return value&quot;
                  &lt;code&gt;rv&lt;/code&gt; and returns &lt;code&gt;rv&lt;/code&gt;.
                  If &lt;code&gt;rv&lt;/code&gt; is &lt;code&gt;null&lt;/code&gt; a new &lt;code&gt;Point&lt;/code&gt;
                  is allocated.  This version of &lt;code&gt;getLocation&lt;/code&gt; is useful
                  if the caller wants to avoid allocating a new &lt;code&gt;Point&lt;/code&gt;
                  object on the heap.                
                <param>
                    rv the return value, modified to the component's location                    
                </param>
                <return>
                    <code>rv</code>                    
                </return>
            </javadoc>
            <method name="getLocation" type="Point" line="4271">
                <params>
                    <param name="rv" type="Point"/>
                </params>
                <scope line="4272"/>
                <scope line="4275"/>
            </method>
            <javadoc line="4282">
                Returns the current x coordinate of the component&apos;s origin.
                  This method is preferable to writing
                  &lt;code&gt;component.getBounds().x&lt;/code&gt;, or
                  &lt;code&gt;component.getLocation().x&lt;/code&gt; because it doesn&apos;t cause any
                  heap allocations.                
                <return>
                    the current x coordinate of the component's origin                    
                </return>
            </javadoc>
            <method name="getX" type="int" line="4291"/>
            <javadoc line="4294">
                Returns the current y coordinate of the component&apos;s origin.
                  This method is preferable to writing
                  &lt;code&gt;component.getBounds().y&lt;/code&gt;, or
                  &lt;code&gt;component.getLocation().y&lt;/code&gt; because it doesn&apos;t cause any
                  heap allocations.                
                <return>
                    the current y coordinate of the component's origin                    
                </return>
            </javadoc>
            <method name="getY" type="int" line="4303"/>
            <javadoc line="4306">
                Returns the current width of this component.
                  This method is preferable to writing
                  &lt;code&gt;component.getBounds().width&lt;/code&gt;, or
                  &lt;code&gt;component.getSize().width&lt;/code&gt; because it doesn&apos;t cause any
                  heap allocations.                
                <return>
                    the current width of this component                    
                </return>
            </javadoc>
            <method name="getWidth" type="int" line="4315"/>
            <javadoc line="4318">
                Returns the current height of this component.
                  This method is preferable to writing
                  &lt;code&gt;component.getBounds().height&lt;/code&gt;, or
                  &lt;code&gt;component.getSize().height&lt;/code&gt; because it doesn&apos;t cause any
                  heap allocations.                
                <return>
                    the current height of this component                    
                </return>
            </javadoc>
            <method name="getHeight" type="int" line="4327"/>
            <javadoc line="4329">
                Returns true if this component is completely opaque.
                  &lt;p&gt;
                  An opaque component paints every pixel within its
                  rectangular bounds. A non-opaque component paints only a subset of
                  its pixels or none at all, allowing the pixels underneath it to
                  &quot;show through&quot;.  Therefore, a component that does not fully paint
                  its pixels provides a degree of transparency.
                  &lt;p&gt;
                  Subclasses that guarantee to always completely paint their contents
                  should override this method and return true.                
                <return>
                    true if this component is completely opaque                    
                </return>
                <see>
                    #setOpaque                    
                </see>
            </javadoc>
            <method name="isOpaque" type="boolean" line="4344"/>
            <javadoc line="4348">
                If true the component paints every pixel within its bounds.
                  Otherwise, the component may not paint some or all of its
                  pixels, allowing the underlying pixels to show through.
                  &lt;p&gt;
                  The default value of this property is false for &lt;code&gt;JComponent&lt;/code&gt;.
                  However, the default value for this property on most standard
                  &lt;code&gt;JComponent&lt;/code&gt; subclasses (such as &lt;code&gt;JButton&lt;/code&gt; and
                  &lt;code&gt;JTree&lt;/code&gt;) is look-and-feel dependent.                
                <param>
                    isOpaque  true if this component should be opaque                    
                </param>
                <see>
                    #isOpaque                    
                </see>
                <beaninfo>
                    bound: true
                      expert: true
                      description: The component's opacity                    
                </beaninfo>
            </javadoc>
            <method name="setOpaque" type="void" line="4365">
                <params>
                    <param name="isOpaque" type="boolean"/>
                </params>
                <declaration name="oldValue" type="boolean" line="4366"/>
            </method>
            <javadoc line="4373">
                If the specified rectangle is completely obscured by any of this
                  component&apos;s opaque children then returns true.  Only direct children
                  are considered, more distant descendants are ignored.  A
                  &lt;code&gt;JComponent&lt;/code&gt; is opaque if
                  &lt;code&gt;JComponent.isOpaque()&lt;/code&gt; returns true, other lightweight
                  components are always considered transparent, and heavyweight components
                  are always considered opaque.                
                <param>
                    x  x value of specified rectangle                    
                </param>
                <param>
                    y  y value of specified rectangle                    
                </param>
                <param>
                    width  width of specified rectangle                    
                </param>
                <param>
                    height height of specified rectangle                    
                </param>
                <return>
                    true if the specified rectangle is obscured by an opaque child                    
                </return>
            </javadoc>
            <method name="rectangleIsObscured" type="boolean" line="4389">
                <params>
                    <param name="x" type="int"/>
                    <param name="y" type="int"/>
                    <param name="width" type="int"/>
                    <param name="height" type="int"/>
                </params>
                <comment line="4406">
                    System.out.println(&quot;A) checking opaque: &quot; + ((JComponent)child).isOpaque() + &quot;  &quot; + child);
                                      System.out.print(&quot;B) &quot;);
                                      Thread.dumpStack();                    
                </comment>
                <comment line="4411">
                    Sometimes a heavy weight can have a bound larger than its peer size
                      so we should always draw under heavy weights                    
                </comment>
                <declaration name="numChildren" type="int" line="4390"/>
                <scope line="4392">
                    <declaration name="child" type="Component" line="4393"/>
                    <declaration name="cx" type="int" line="4394"/>
                    <scope line="4402">
                        <scope line="4404"/>
                        <scope line="4409"/>
                    </scope>
                </scope>
            </method>
            <javadoc line="4422">
                Returns the &lt;code&gt;Component&lt;/code&gt;&apos;s &quot;visible rect rectangle&quot; -  the
                  intersection of the visible rectangles for the component &lt;code&gt;c&lt;/code&gt;
                  and all of its ancestors.  The return value is stored in
                  &lt;code&gt;visibleRect&lt;/code&gt;.                
                <param>
                    c  the component                    
                </param>
                <param>
                    visibleRect  a <code>Rectangle</code> computed as the
                      intersection of all visible rectangles for the component
                      <code>c</code> and all of its ancestors -- this is the
                      return value for this method                    
                </param>
                <see>
                    #getVisibleRect                    
                </see>
            </javadoc>
            <method name="computeVisibleRect" type="void" line="4435">
                <params>
                    <param name="c" type="Component"/>
                    <param name="visibleRect" type="Rectangle"/>
                </params>
                <declaration name="p" type="Container" line="4436"/>
                <declaration name="bounds" type="Rectangle" line="4437"/>
                <scope line="4439"/>
                <scope line="4441"/>
            </method>
            <javadoc line="4450">
                Returns the &lt;code&gt;Component&lt;/code&gt;&apos;s &quot;visible rect rectangle&quot; -  the
                  intersection of the visible rectangles for this component
                  and all of its ancestors.  The return value is stored in
                  &lt;code&gt;visibleRect&lt;/code&gt;.                
                <param>
                    visibleRect a <code>Rectangle</code> computed as the
                      intersection of all visible rectangles for this
                      component and all of its ancestors -- this is the return
                      value for this method                    
                </param>
                <see>
                    #getVisibleRect                    
                </see>
            </javadoc>
            <method name="computeVisibleRect" type="void" line="4462">
                <params>
                    <param name="visibleRect" type="Rectangle"/>
                </params>
            </method>
            <javadoc line="4467">
                Returns the &lt;code&gt;Component&lt;/code&gt;&apos;s &quot;visible rectangle&quot; -  the
                  intersection of this component&apos;s visible rectangle,
                  &lt;code&gt;new Rectangle(0, 0, getWidth(), getHeight())&lt;/code&gt;,
                  and all of its ancestors&apos; visible rectangles.                
                <return>
                    the visible rectangle                    
                </return>
            </javadoc>
            <method name="getVisibleRect" type="Rectangle" line="4475">
                <declaration name="visibleRect" type="Rectangle" line="4476"/>
            </method>
            <javadoc line="4482">
                Support for reporting bound property changes for boolean properties.
                  This method can be called when a bound property has changed and it will
                  send the appropriate PropertyChangeEvent to any registered
                  PropertyChangeListeners.                
                <param>
                    propertyName the property whose value has changed                    
                </param>
                <param>
                    oldValue the property's previous value                    
                </param>
                <param>
                    newValue the property's new value                    
                </param>
            </javadoc>
            <method name="firePropertyChange" type="void" line="4493">
                <params>
                    <param name="propertyName" type="String"/>
                    <param name="oldValue" type="boolean"/>
                    <param name="newValue" type="boolean"/>
                </params>
            </method>
            <javadoc line="4498">
                Support for reporting bound property changes for integer properties.
                  This method can be called when a bound property has changed and it will
                  send the appropriate PropertyChangeEvent to any registered
                  PropertyChangeListeners.                
                <param>
                    propertyName the property whose value has changed                    
                </param>
                <param>
                    oldValue the property's previous value                    
                </param>
                <param>
                    newValue the property's new value                    
                </param>
            </javadoc>
            <method name="firePropertyChange" type="void" line="4509">
                <params>
                    <param name="propertyName" type="String"/>
                    <param name="oldValue" type="int"/>
                    <param name="newValue" type="int"/>
                </params>
            </method>
            <method name="firePropertyChange" type="void" line="4515">
                <params>
                    <param name="propertyName" type="String"/>
                    <param name="oldValue" type="char"/>
                    <param name="newValue" type="char"/>
                </params>
            </method>
            <javadoc line="4519">
                Supports reporting constrained property changes.
                  This method can be called when a constrained property has changed
                  and it will send the appropriate &lt;code&gt;PropertyChangeEvent&lt;/code&gt;
                  to any registered &lt;code&gt;VetoableChangeListeners&lt;/code&gt;.                
                <param>
                    propertyName  the name of the property that was listened on                    
                </param>
                <param>
                    oldValue  the old value of the property                    
                </param>
                <param>
                    newValue  the new value of the property                    
                </param>
                <exception>
                    PropertyVetoException when the attempt to set the
                      property is vetoed by the component                    
                </exception>
            </javadoc>
            <method name="fireVetoableChange" type="void" line="4533">
                <params>
                    <param name="propertyName" type="String"/>
                    <param name="oldValue" type="Object"/>
                    <param name="newValue" type="Object"/>
                </params>
                <scope line="4534"/>
            </method>
            <javadoc line="4541">
                Adds a &lt;code&gt;VetoableChangeListener&lt;/code&gt; to the listener list.
                  The listener is registered for all properties.                
                <param>
                    listener  the <code>VetoableChangeListener</code> to be added                    
                </param>
            </javadoc>
            <method name="addVetoableChangeListener" type="void" line="4547">
                <params>
                    <param name="listener" type="VetoableChangeListener"/>
                </params>
                <scope line="4548"/>
            </method>
            <javadoc line="4555">
                Removes a &lt;code&gt;VetoableChangeListener&lt;/code&gt; from the listener list.
                  This removes a &lt;code&gt;VetoableChangeListener&lt;/code&gt; that was registered
                  for all properties.                
                <param>
                    listener  the <code>VetoableChangeListener</code> to be removed                    
                </param>
            </javadoc>
            <method name="removeVetoableChangeListener" type="void" line="4562">
                <params>
                    <param name="listener" type="VetoableChangeListener"/>
                </params>
                <scope line="4563"/>
            </method>
            <javadoc line="4570">
                Returns an array of all the vetoable change listeners
                  registered on this component.                
                <return>
                    all of the component's <code>VetoableChangeListener</code>s
                      or an empty
                      array if no vetoable change listeners are currently registered                    
                </return>
                <see>
                    #addVetoableChangeListener                    
                </see>
                <see>
                    #removeVetoableChangeListener                    
                </see>
                <since>
                    1.4                    
                </since>
            </javadoc>
            <method name="getVetoableChangeListeners" type="VetoableChangeListener[]" line="4583">
                <scope line="4584"/>
            </method>
            <javadoc line="4591">
                Returns the top-level ancestor of this component (either the
                  containing &lt;code&gt;Window&lt;/code&gt; or &lt;code&gt;Applet&lt;/code&gt;),
                  or &lt;code&gt;null&lt;/code&gt; if this component has not
                  been added to any container.                
                <return>
                    the top-level <code>Container</code> that this component is in,
                      or <code>null</code> if not in any container                    
                </return>
            </javadoc>
            <method name="getTopLevelAncestor" type="Container" line="4600">
                <scope line="4601">
                    <scope line="4602"/>
                </scope>
            </method>
            <method name="getAncestorNotifier" type="AncestorNotifier" line="4609"/>
            <javadoc line="4614">
                Registers &lt;code&gt;listener&lt;/code&gt; so that it will receive
                  &lt;code&gt;AncestorEvents&lt;/code&gt; when it or any of its ancestors
                  move or are made visible or invisible.
                  Events are also sent when the component or its ancestors are added
                  or removed from the containment hierarchy.                
                <param>
                    listener  the <code>AncestorListener</code> to register                    
                </param>
                <see>
                    AncestorEvent                    
                </see>
            </javadoc>
            <method name="addAncestorListener" type="void" line="4624">
                <params>
                    <param name="listener" type="AncestorListener"/>
                </params>
                <declaration name="ancestorNotifier" type="AncestorNotifier" line="4625"/>
                <scope line="4626"/>
            </method>
            <javadoc line="4634">
                Unregisters &lt;code&gt;listener&lt;/code&gt; so that it will no longer receive
                  &lt;code&gt;AncestorEvents&lt;/code&gt;.                
                <param>
                    listener  the <code>AncestorListener</code> to be removed                    
                </param>
                <see>
                    #addAncestorListener                    
                </see>
            </javadoc>
            <method name="removeAncestorListener" type="void" line="4641">
                <params>
                    <param name="listener" type="AncestorListener"/>
                </params>
                <declaration name="ancestorNotifier" type="AncestorNotifier" line="4642"/>
                <scope line="4643"/>
                <scope line="4647"/>
            </method>
            <javadoc line="4653">
                Returns an array of all the ancestor listeners
                  registered on this component.                
                <return>
                    all of the component's <code>AncestorListener</code>s
                      or an empty
                      array if no ancestor listeners are currently registered                    
                </return>
                <see>
                    #addAncestorListener                    
                </see>
                <see>
                    #removeAncestorListener                    
                </see>
                <since>
                    1.4                    
                </since>
            </javadoc>
            <method name="getAncestorListeners" type="AncestorListener[]" line="4666">
                <declaration name="ancestorNotifier" type="AncestorNotifier" line="4667"/>
                <scope line="4668"/>
            </method>
            <javadoc line="4674">
                Returns an array of all the objects currently registered
                  as &lt;code&gt;&lt;em&gt;Foo&lt;/em&gt;Listener&lt;/code&gt;s
                  upon this &lt;code&gt;JComponent&lt;/code&gt;.
                  &lt;code&gt;&lt;em&gt;Foo&lt;/em&gt;Listener&lt;/code&gt;s are registered using the
                  &lt;code&gt;add&lt;em&gt;Foo&lt;/em&gt;Listener&lt;/code&gt; method.
                  &lt;p&gt;
                  You can specify the &lt;code&gt;listenerType&lt;/code&gt; argument
                  with a class literal,
                  such as
                  &lt;code&gt;&lt;em&gt;Foo&lt;/em&gt;Listener.class&lt;/code&gt;.
                  For example, you can query a
                  &lt;code&gt;JComponent&lt;/code&gt; &lt;code&gt;c&lt;/code&gt;
                  for its mouse listeners with the following code:
                  &lt;pre&gt;MouseListener[] mls = (MouseListener[])(c.getListeners(MouseListener.class));&lt;/pre&gt;
                  If no such listeners exist, this method returns an empty array.                
                <param>
                    listenerType the type of listeners requested; this parameter
                      should specify an interface that descends from
                      <code>java.util.EventListener</code>                    
                </param>
                <return>
                    an array of all objects registered as
                      <code><em>Foo</em>Listener</code>s on this component,
                      or an empty array if no such
                      listeners have been added                    
                </return>
                <exception>
                    ClassCastException if <code>listenerType</code>
                      doesn't specify a class or interface that implements
                      <code>java.util.EventListener</code>                    
                </exception>
                <since>
                    1.3                    
                </since>
                <see>
                    #getVetoableChangeListeners                    
                </see>
                <see>
                    #getAncestorListeners                    
                </see>
            </javadoc>
            <method name="getListeners" type="T[]" line="4709">
                <params>
                    <param name="listenerType" type="Class<T>"/>
                </params>
                <comment line="4713">
                    AncestorListeners are handled by the AncestorNotifier                    
                </comment>
                <comment line="4717">
                    VetoableChangeListeners are handled by VetoableChangeSupport                    
                </comment>
                <comment line="4721">
                    PropertyChangeListeners are handled by PropertyChangeSupport                    
                </comment>
                <declaration name="result" type="T[]" line="4710"/>
                <scope line="4711"/>
                <scope line="4715"/>
                <scope line="4719"/>
                <scope line="4723"/>
                <scope line="4727"/>
            </method>
            <javadoc line="4733">
                Notifies this component that it now has a parent component.
                  When this method is invoked, the chain of parent components is
                  set up with &lt;code&gt;KeyboardAction&lt;/code&gt; event listeners.
                  This method is called by the toolkit internally and should
                  not be called directly by programs.                
                <see>
                    #registerKeyboardAction                    
                </see>
            </javadoc>
            <method name="addNotify" type="void" line="4742"/>
            <javadoc line="4751">
                Notifies this component that it no longer has a parent component.
                  When this method is invoked, any &lt;code&gt;KeyboardAction&lt;/code&gt;s
                  set up in the the chain of parent components are removed.
                  This method is called by the toolkit internally and should
                  not be called directly by programs.                
                <see>
                    #registerKeyboardAction                    
                </see>
            </javadoc>
            <method name="removeNotify" type="void" line="4760">
                <comment line="4763">
                    This isn&apos;t strictly correct.  The event shouldn&apos;t be
                     fired until *after* the parent is set to null.  But
                     we only get notified before that happens                    
                </comment>
                <scope line="4770"/>
                <scope line="4774"/>
            </method>
            <javadoc line="4780">
                Adds the specified region to the dirty region list if the component
                  is showing.  The component will be repainted after all of the
                  currently pending events have been dispatched.                
                <param>
                    tm  this parameter is not used                    
                </param>
                <param>
                    x  the x value of the dirty region                    
                </param>
                <param>
                    y  the y value of the dirty region                    
                </param>
                <param>
                    width  the width of the dirty region                    
                </param>
                <param>
                    height  the height of the dirty region                    
                </param>
                <see>
                    #isPaintingOrigin()                    
                </see>
                <see>
                    java.awt.Component#isShowing                    
                </see>
                <see>
                    RepaintManager#addDirtyRegion                    
                </see>
            </javadoc>
            <method name="repaint" type="void" line="4794">
                <params>
                    <param name="tm" type="long"/>
                    <param name="x" type="int"/>
                    <param name="y" type="int"/>
                    <param name="width" type="int"/>
                    <param name="height" type="int"/>
                </params>
            </method>
            <javadoc line="4799">
                Adds the specified region to the dirty region list if the component
                  is showing.  The component will be repainted after all of the
                  currently pending events have been dispatched.                
                <param>
                    r a <code>Rectangle</code> containing the dirty region                    
                </param>
                <see>
                    #isPaintingOrigin()                    
                </see>
                <see>
                    java.awt.Component#isShowing                    
                </see>
                <see>
                    RepaintManager#addDirtyRegion                    
                </see>
            </javadoc>
            <method name="repaint" type="void" line="4809">
                <params>
                    <param name="r" type="Rectangle"/>
                </params>
            </method>
            <javadoc line="4814">
                Supports deferred automatic layout.
                  &lt;p&gt;
                  Calls &lt;code&gt;invalidate&lt;/code&gt; and then adds this component&apos;s
                  &lt;code&gt;validateRoot&lt;/code&gt; to a list of components that need to be
                  validated.  Validation will occur after all currently pending
                  events have been dispatched.  In other words after this method
                  is called,  the first validateRoot (if any) found when walking
                  up the containment hierarchy of this component will be validated.
                  By default, &lt;code&gt;JRootPane&lt;/code&gt;, &lt;code&gt;JScrollPane&lt;/code&gt;,
                  and &lt;code&gt;JTextField&lt;/code&gt; return true
                  from &lt;code&gt;isValidateRoot&lt;/code&gt;.
                  &lt;p&gt;
                  This method will automatically be called on this component
                  when a property value changes such that size, location, or
                  internal layout of this component has been affected.  This automatic
                  updating differs from the AWT because programs generally no
                  longer need to invoke &lt;code&gt;validate&lt;/code&gt; to get the contents of the
                  GUI to update.
                  &lt;p&gt;                
                <see>
                    java.awt.Component#invalidate                    
                </see>
                <see>
                    java.awt.Container#validate                    
                </see>
                <see>
                    #isValidateRoot                    
                </see>
                <see>
                    RepaintManager#addInvalidComponent                    
                </see>
            </javadoc>
            <method name="revalidate" type="void" line="4840">
                <comment line="4843">
                    Note: We don&apos;t bother invalidating here as once added
                     to a valid parent invalidate will be invoked (addImpl
                     invokes addNotify which will invoke invalidate on the
                     new Component). Also, if we do add a check to isValid
                     here it can potentially be called before the constructor
                     which was causing some people grief.                    
                </comment>
                <comment line="4856">
                    To avoid a flood of Runnables when constructing GUIs off
                     the EDT, a flag is maintained as to whether or not
                     a Runnable has been scheduled.                    
                </comment>
                <scope line="4841"/>
                <scope line="4850"/>
                <scope line="4854">
                    <scope line="4858">
                        <scope line="4859"/>
                    </scope>
                    <anonymous_class line="4864">
                        <method name="run" type="void" line="4865">
                            <scope line="4866"/>
                        </method>
                    </anonymous_class>
                    <declaration name="callRevalidate" type="Runnable" line="4864"/>
                </scope>
            </method>
            <javadoc line="4876">
                If this method returns true, &lt;code&gt;revalidate&lt;/code&gt; calls by
                  descendants of this component will cause the entire tree
                  beginning with this root to be validated.
                  Returns false by default.  &lt;code&gt;JScrollPane&lt;/code&gt; overrides
                  this method and returns true.                
                <return>
                    always returns false                    
                </return>
                <see>
                    #revalidate                    
                </see>
                <see>
                    java.awt.Component#invalidate                    
                </see>
                <see>
                    java.awt.Container#validate                    
                </see>
                <see>
                    java.awt.Container#isValidateRoot                    
                </see>
            </javadoc>
            <method name="isValidateRoot" type="boolean" line="4890"/>
            <javadoc line="4895">
                Returns true if this component tiles its children -- that is, if
                  it can guarantee that the children will not overlap.  The
                  repainting system is substantially more efficient in this
                  common case.  &lt;code&gt;JComponent&lt;/code&gt; subclasses that can&apos;t make this
                  guarantee, such as &lt;code&gt;JLayeredPane&lt;/code&gt;,
                  should override this method to return false.                
                <return>
                    always returns true                    
                </return>
            </javadoc>
            <method name="isOptimizedDrawingEnabled" type="boolean" line="4905"/>
            <javadoc line="4909">
                Returns {@code true} if a paint triggered on a child component should cause
                  painting to originate from this Component, or one of its ancestors.
                  &lt;p/&gt;
                  Calling {@link #repaint} or {@link #paintImmediately(int,int,int,int)}on a Swing component will result in calling
                  the {@link JComponent#paintImmediately(int,int,int,int)} method of
                  the first ancestor which {@code isPaintingOrigin()} returns {@code true}, if there are any.
                  &lt;p/&gt;{@code JComponent} subclasses that need to be painted when any of their
                  children are repainted should override this method to return {@code true}.                
                <return>
                    always returns {@code false}                    
                </return>
                <see>
                    #paintImmediately(int,int,int,int)                    
                </see>
            </javadoc>
            <method name="isPaintingOrigin" type="boolean" line="4925"/>
            <javadoc line="4929">
                Paints the specified region in this component and all of its
                  descendants that overlap the region, immediately.
                  &lt;p&gt;
                  It&apos;s rarely necessary to call this method.  In most cases it&apos;s
                  more efficient to call repaint, which defers the actual painting
                  and can collapse redundant requests into a single paint call.
                  This method is useful if one needs to update the display while
                  the current event is being dispatched.
                  &lt;p&gt;
                  This method is to be overridden when the dirty region needs to be changed
                  for components that are painting origins.                
                <param>
                    x  the x value of the region to be painted                    
                </param>
                <param>
                    y  the y value of the region to be painted                    
                </param>
                <param>
                    w  the width of the region to be painted                    
                </param>
                <param>
                    h  the height of the region to be painted                    
                </param>
                <see>
                    #repaint                    
                </see>
                <see>
                    #isPaintingOrigin()                    
                </see>
            </javadoc>
            <method name="paintImmediately" type="void" line="4949">
                <params>
                    <param name="x" type="int"/>
                    <param name="y" type="int"/>
                    <param name="w" type="int"/>
                    <param name="h" type="int"/>
                </params>
                <declaration name="c" type="Component" line="4950"/>
                <declaration name="parent" type="Component" line="4951"/>
                <scope line="4953"/>
                <declaration name="paintingOigin" type="JComponent" line="4957"/>
                <scope line="4958">
                    <declaration name="rectangle" type="Rectangle" line="4959"/>
                </scope>
                <scope line="4965">
                    <scope line="4967"/>
                    <scope line="4971"/>
                    <scope line="4975"/>
                </scope>
                <scope line="4979"/>
                <scope line="4981"/>
            </method>
            <javadoc line="4986">
                Paints the specified region now.                
                <param>
                    r a <code>Rectangle</code> containing the region to be painted                    
                </param>
            </javadoc>
            <method name="paintImmediately" type="void" line="4991">
                <params>
                    <param name="r" type="Rectangle"/>
                </params>
            </method>
            <javadoc line="4995">
                Returns whether this component should be guaranteed to be on top.
                  For example, it would make no sense for &lt;code&gt;Menu&lt;/code&gt;s to pop up
                  under another component, so they would always return true.
                  Most components will want to return false, hence that is the default.                
                <return>
                    always returns false                    
                </return>
            </javadoc>
            <method name="alwaysOnTop" type="boolean" line="5004">
                <comment line="5004">
                    package private                    
                </comment>
            </method>
            <method name="setPaintingChild" type="void" line="5008">
                <params>
                    <param name="paintingChild" type="Component"/>
                </params>
            </method>
            <method name="_paintImmediately" type="void" line="5012">
                <params>
                    <param name="x" type="int"/>
                    <param name="y" type="int"/>
                    <param name="w" type="int"/>
                    <param name="h" type="int"/>
                </params>
                <comment line="5027">
                    parent Container&apos;s up to Window or Applet. First container is
                     the direct parent. Note that in testing it was faster to
                     alloc a new Vector vs keeping a stack of them around, and gc
                     seemed to have a minimal effect on this.                    
                </comment>
                <comment line="5044">
                    System.out.println(&quot;1) ************* in _paintImmediately for &quot; + this);                    
                </comment>
                <comment line="5065">
                    Children of c may overlap, three possible cases for the
                     painting region:
                     . Completely obscured by an opaque sibling, in which
                       case there is no need to paint.
                     . Partially obscured by a sibling: need to start
                       painting from c.
                     . Otherwise we aren&apos;t obscured and thus don&apos;t need to
                       start painting from parent.                    
                </comment>
                <comment line="5105">
                    Get rid of any buffer since we draw from here and
                     we might draw something larger                    
                </comment>
                <comment line="5115">
                    look to see if the parent (and therefor this component)
                     is double buffered                    
                </comment>
                <comment line="5123">
                    if we aren&apos;t on top, include the parent&apos;s clip                    
                </comment>
                <comment line="5137">
                    If the clip width or height is negative, don&apos;t bother painting                    
                </comment>
                <comment line="5150">
                    Notify the Components that are going to be painted of the
                     child component to paint to.                    
                </comment>
                <comment line="5189">
                    Reset the painting child for the parent components.                    
                </comment>
                <declaration name="g" type="Graphics" line="5013"/>
                <declaration name="c" type="Container" line="5014"/>
                <declaration name="b" type="Rectangle" line="5015"/>
                <declaration name="tmpX" type="int" line="5017"/>
                <declaration name="offsetX" type="int" line="5018"/>
                <declaration name="hasBuffer" type="boolean" line="5020"/>
                <declaration name="bufferedComponent" type="JComponent" line="5022"/>
                <declaration name="paintingComponent" type="JComponent" line="5023"/>
                <declaration name="repaintManager" type="RepaintManager" line="5025"/>
                <declaration name="path" type="java.util.List&lt;Component&gt;" line="5030"/>
                <declaration name="pIndex" type="int" line="5031"/>
                <declaration name="pCount" type="int" line="5032"/>
                <declaration name="paintImmediatelyClip" type="Rectangle" line="5036"/>
                <declaration name="ontop" type="boolean" line="5045"/>
                <scope line="5046">
                    <scope line="5049"/>
                </scope>
                <declaration name="child" type="Component" line="5054"/>
                <scope line="5057">
                    <declaration name="jc" type="JComponent" line="5058"/>
                    <scope line="5061">
                        <declaration name="resetPC" type="boolean" line="5062"/>
                        <scope line="5072">
                            <scope line="5073"/>
                            <scope line="5076">
                                <declaration name="children" type="Component[]" line="5077"/>
                                <declaration name="i" type="int" line="5078"/>
                                <scope line="5079"/>
                            </scope>
                        </scope>
                        <scope line="5099"/>
                        <scope line="5103"/>
                    </scope>
                    <scope line="5117"/>
                    <scope line="5123">
                        <declaration name="bx" type="int" line="5124"/>
                        <declaration name="by" type="int" line="5125"/>
                    </scope>
                </scope>
                <scope line="5139"/>
                <scope line="5151">
                    <declaration name="comp" type="Component" line="5152"/>
                    <declaration name="i" type="int" line="5153"/>
                    <scope line="5154">
                        <scope line="5156"/>
                    </scope>
                </scope>
                <scope line="5161">
                    <scope line="5162">
                        <scope line="5163">
                            <scope line="5164">
                                <declaration name="rm" type="RepaintManager" line="5165"/>
                                <scope line="5168"/>
                                <scope line="5174"/>
                            </scope>
                            <scope line="5177"/>
                        </scope>
                        <scope line="5182"/>
                    </scope>
                </scope>
                <scope line="5187">
                    <scope line="5189">
                        <declaration name="comp" type="Component" line="5190"/>
                        <declaration name="i" type="int" line="5191"/>
                        <scope line="5192">
                            <scope line="5194"/>
                        </scope>
                    </scope>
                </scope>
            </method>
            <javadoc line="5204">
                Paints to the specified graphics.  This does not set the clip and it
                  does not adjust the Graphics in anyway, callers must do that first.
                  This method is package-private for RepaintManager.PaintManager and
                  its subclasses to call, it is NOT intended for general use outside
                  of that.                
            </javadoc>
            <method name="paintToOffscreen" type="void" line="5212">
                <params>
                    <param name="g" type="Graphics"/>
                    <param name="x" type="int"/>
                    <param name="y" type="int"/>
                    <param name="w" type="int"/>
                    <param name="h" type="int"/>
                    <param name="maxX" type="int"/>
                    <param name="maxY" type="int"/>
                </params>
                <comment line="5220">
                    Called from paintImmediately (RepaintManager) to fill
                     repaint request                    
                </comment>
                <comment line="5224">
                    Called from paint() (AWT) to repair damage                    
                </comment>
                <scope line="5213">
                    <scope line="5215"/>
                    <scope line="5218"/>
                    <scope line="5222">
                        <scope line="5224"/>
                    </scope>
                </scope>
                <scope line="5230"/>
            </method>
            <javadoc line="5236">
                Returns whether or not the region of the specified component is
                  obscured by a sibling.                
                <return>
                    NOT_OBSCURED if non of the siblings above the Component obscure
                      it, COMPLETELY_OBSCURED if one of the siblings completely
                      obscures the Component or PARTIALLY_OBSCURED if the Comonent is
                      only partially obscured.                    
                </return>
            </javadoc>
            <method name="getObscuredState" type="int" line="5246">
                <params>
                    <param name="compIndex" type="int"/>
                    <param name="x" type="int"/>
                    <param name="y" type="int"/>
                    <param name="width" type="int"/>
                    <param name="height" type="int"/>
                </params>
                <declaration name="retValue" type="int" line="5247"/>
                <declaration name="tmpRect" type="Rectangle" line="5248"/>
                <scope line="5250">
                    <declaration name="sibling" type="Component" line="5251"/>
                    <scope line="5252"/>
                    <declaration name="siblingRect" type="Rectangle" line="5255"/>
                    <declaration name="opaque" type="boolean" line="5256"/>
                    <scope line="5257">
                        <scope line="5259">
                            <scope line="5260"/>
                        </scope>
                    </scope>
                    <scope line="5265"/>
                    <scope line="5272"/>
                    <scope line="5280"/>
                </scope>
            </method>
            <javadoc line="5288">
                Returns true, which implies that before checking if a child should
                  be painted it is first check that the child is not obscured by another
                  sibling. This is only checked if &lt;code&gt;isOptimizedDrawingEnabled&lt;/code&gt;
                  returns false.                
                <return>
                    always returns true                    
                </return>
            </javadoc>
            <method name="checkIfChildObscuredBySibling" type="boolean" line="5296"/>
            <method name="setFlag" type="void" line="5301">
                <params>
                    <param name="aFlag" type="int"/>
                    <param name="aValue" type="boolean"/>
                </params>
                <scope line="5302"/>
                <scope line="5304"/>
            </method>
            <method name="getFlag" type="boolean" line="5308">
                <params>
                    <param name="aFlag" type="int"/>
                </params>
                <declaration name="mask" type="int" line="5309"/>
            </method>
            <method name="setWriteObjCounter" type="void" line="5315">
                <params>
                    <param name="comp" type="JComponent"/>
                    <param name="count" type="byte"/>
                </params>
            </method>
            <method name="getWriteObjCounter" type="byte" line="5319">
                <params>
                    <param name="comp" type="JComponent"/>
                </params>
            </method>
            <javadoc line="5325">
                Sets whether this component should use a buffer to paint.
                  If set to true, all the drawing from this component will be done
                  in an offscreen painting buffer. The offscreen painting buffer will
                  the be copied onto the screen.
                  If a &lt;code&gt;Component&lt;/code&gt; is buffered and one of its ancestor
                  is also buffered, the ancestor buffer will be used.                
                <param>
                    aFlag if true, set this component to be double buffered                    
                </param>
            </javadoc>
            <method name="setDoubleBuffered" type="void" line="5335">
                <params>
                    <param name="aFlag" type="boolean"/>
                </params>
            </method>
            <javadoc line="5339">
                Returns whether this component should use a buffer to paint.                
                <return>
                    true if this component is double buffered, otherwise false                    
                </return>
            </javadoc>
            <method name="isDoubleBuffered" type="boolean" line="5344"/>
            <javadoc line="5348">
                Returns the &lt;code&gt;JRootPane&lt;/code&gt; ancestor for this component.                
                <return>
                    the <code>JRootPane</code> that contains this component,
                      or <code>null</code> if no <code>JRootPane</code> is found                    
                </return>
            </javadoc>
            <method name="getRootPane" type="JRootPane" line="5354"/>
            <javadoc line="5361">
                This is called from Component by way of reflection. Do NOT change
                  the name unless you change the code in Component as well.                
            </javadoc>
            <method name="compWriteObjectNotify" type="void" line="5365">
                <comment line="5375">
                    JTableHeader is in a separate package, which prevents it from
                     being able to override this package-private method the way the
                     other components can.  We don&apos;t want to make this method protected
                     because it would introduce public-api for a less-than-desirable
                     serialization scheme, so we compromise with this &apos;instanceof&apos; hack
                     for now.                    
                </comment>
                <declaration name="count" type="byte" line="5366"/>
                <scope line="5368"/>
                <scope line="5382"/>
            </method>
            <class name="ReadObjectCallback" line="5387">
                <comment line="3377">
                    This will be non-null if actionListener is an Action.                    
                </comment>
                <comment line="3427">
                    We don&apos;t allow any values to be added.                    
                </comment>
                <comment line="3430">
                    Does nothing, our enabledness is determiend from our asociated
                     action.                    
                </comment>
                <comment line="3477">
                    Get the array of key codes from the AppContext.                    
                </comment>
                <comment line="3738">
                    inner class AccessibleFocusHandler                    
                </comment>
                <comment line="3799">
                    AccessibleContext methods                    
                </comment>
                <comment line="3948">
                    ----- AccessibleExtendedComponent                    
                </comment>
                <comment line="5004">
                    package private                    
                </comment>
                <implements interface="ObjectInputValidation"/>
                <javadoc line="5387">
                    This object is the &lt;code&gt;ObjectInputStream&lt;/code&gt; callback
                      that&apos;s called after a complete graph of objects (including at least
                      one &lt;code&gt;JComponent&lt;/code&gt;) has been read.
                      It sets the UI property of each Swing component
                      that was read to the current default with &lt;code&gt;updateUI&lt;/code&gt;.
                      &lt;p&gt;
                      As each  component is read in we keep track of the current set of
                      root components here, in the roots vector.  Note that there&apos;s only one
                      &lt;code&gt;ReadObjectCallback&lt;/code&gt; per &lt;code&gt;ObjectInputStream&lt;/code&gt;,
                      they&apos;re stored in the static &lt;code&gt;readObjectCallbacks&lt;/code&gt;
                      hashtable.                    
                    <see>
                        java.io.ObjectInputStream#registerValidation                        
                    </see>
                    <see>
                        SwingUtilities#updateComponentTreeUI                        
                    </see>
                </javadoc>
                <declaration name="roots" type="Vector&lt;JComponent&gt;" line="5405"/>
                <declaration name="inputStream" type="ObjectInputStream" line="5406"/>
                <method name="ReadObjectCallback" type="constructor" line="5408">
                    <params>
                        <param name="s" type="ObjectInputStream"/>
                    </params>
                </method>
                <javadoc line="5413">
                    This is the method that&apos;s called after the entire graph
                      of objects has been read in.  It initializes
                      the UI property of all of the copmonents with
                      &lt;code&gt;SwingUtilities.updateComponentTreeUI&lt;/code&gt;.                    
                </javadoc>
                <method name="validateObject" type="void" line="5419">
                    <scope line="5420">
                        <scope line="5421"/>
                    </scope>
                    <scope line="5425"/>
                </method>
                <javadoc line="5430">
                    If &lt;code&gt;c&lt;/code&gt; isn&apos;t a descendant of a component we&apos;ve already
                      seen, then add it to the roots &lt;code&gt;Vector&lt;/code&gt;.                    
                    <param>
                        c the <code>JComponent</code> to add                        
                    </param>
                </javadoc>
                <method name="registerComponent" type="void" line="5437">
                    <params>
                        <param name="c" type="JComponent"/>
                    </params>
                    <comment line="5439">
                        If the Component c is a descendant of one of the
                         existing roots (or it IS an existing root), we&apos;re done.                        
                    </comment>
                    <comment line="5450">
                        Otherwise: if Component c is an ancestor of any of the
                         existing roots then remove them and add c (the &quot;new root&quot;)
                         to the roots vector.                        
                    </comment>
                    <comment line="5458">
                        !!                        
                    </comment>
                    <scope line="5441">
                        <scope line="5442">
                            <scope line="5443"/>
                        </scope>
                    </scope>
                    <scope line="5453">
                        <declaration name="root" type="JComponent" line="5454"/>
                        <scope line="5455">
                            <scope line="5456"/>
                        </scope>
                    </scope>
                </method>
            </class>
            <javadoc line="5468">
                We use the &lt;code&gt;ObjectInputStream&lt;/code&gt; &quot;registerValidation&quot;
                  callback to update the UI for the entire tree of components
                  after they&apos;ve all been read in.                
                <param>
                    s  the <code>ObjectInputStream</code> from which to read                    
                </param>
            </javadoc>
            <method name="readObject" type="void" line="5477">
                <params>
                    <param name="s" type="ObjectInputStream"/>
                </params>
                <comment line="5481">
                    If there&apos;s no ReadObjectCallback for this stream yet, that is, if
                     this is the first call to JComponent.readObject() for this
                     graph of objects, then create a callback and stash it
                     in the readObjectCallbacks table.  Note that the ReadObjectCallback
                     constructor takes care of calling s.registerValidation().                    
                </comment>
                <comment line="5498">
                    Read back the client properties.                    
                </comment>
                <declaration name="cb" type="ReadObjectCallback" line="5486"/>
                <scope line="5487">
                    <scope line="5488"/>
                    <scope line="5491"/>
                </scope>
                <declaration name="cpCount" type="int" line="5498"/>
                <scope line="5499">
                    <scope line="5501"/>
                </scope>
                <scope line="5506"/>
            </method>
            <javadoc line="5513">
                Before writing a &lt;code&gt;JComponent&lt;/code&gt; to an
                  &lt;code&gt;ObjectOutputStream&lt;/code&gt; we temporarily uninstall its UI.
                  This is tricky to do because we want to uninstall
                  the UI before any of the &lt;code&gt;JComponent&lt;/code&gt;&apos;s children
                  (or its &lt;code&gt;LayoutManager&lt;/code&gt; etc.) are written,
                  and we don&apos;t want to restore the UI until the most derived
                  &lt;code&gt;JComponent&lt;/code&gt; subclass has been been stored.                
                <param>
                    s the <code>ObjectOutputStream</code> in which to write                    
                </param>
            </javadoc>
            <method name="writeObject" type="void" line="5524">
                <params>
                    <param name="s" type="ObjectOutputStream"/>
                </params>
                <scope line="5526">
                    <declaration name="count" type="byte" line="5527"/>
                    <scope line="5529"/>
                </scope>
            </method>
            <javadoc line="5537">
                Returns a string representation of this &lt;code&gt;JComponent&lt;/code&gt;.
                  This method
                  is intended to be used only for debugging purposes, and the
                  content and format of the returned string may vary between
                  implementations. The returned string may be empty but may not
                  be &lt;code&gt;null&lt;/code&gt;.                
                <return>
                    a string representation of this <code>JComponent</code>                    
                </return>
            </javadoc>
            <method name="paramString" type="String" line="5547">
                <comment line="5562">
                    should beef this up a bit                    
                </comment>
                <declaration name="preferredSizeString" type="String" line="5548"/>
                <declaration name="minimumSizeString" type="String" line="5550"/>
                <declaration name="maximumSizeString" type="String" line="5552"/>
                <declaration name="borderString" type="String" line="5554"/>
            </method>
        </class>
    </source>