<?xml version="1.0" encoding="UTF-8"?>
    <source package="sun.invoke.util">
        <class name="BytecodeName" line="28">
            <comment line="258">
                static only class                
            </comment>
            <comment line="565">
                empty escape sequence to avoid a null name or illegal prefix                
            </comment>
            <comment line="569">
                \\ must be first                
            </comment>
            <comment line="571">
                index after \\                
            </comment>
            <comment line="582">
                128 bits                
            </comment>
            <javadoc line="28">
                Utility routines for dealing with bytecode-level names.
                  Includes universal mangling rules for the JVM.
                  &lt;h3&gt;Avoiding Dangerous Characters &lt;/h3&gt;
                  &lt;p&gt;
                  The JVM defines a very small set of characters which are illegal
                  in name spellings.  We will slightly extend and regularize this set
                  into a group of &lt;cite&gt;dangerous characters&lt;/cite&gt;.
                  These characters will then be replaced, in mangled names, by escape sequences.
                  In addition, accidental escape sequences must be further escaped.
                  Finally, a special prefix will be applied if and only if
                  the mangling would otherwise fail to begin with the escape character.
                  This happens to cover the corner case of the null string,
                  and also clearly marks symbols which need demangling.
                  &lt;/p&gt;
                  &lt;p&gt;
                  Dangerous characters are the union of all characters forbidden
                  or otherwise restricted by the JVM specification,
                  plus their mates, if they are brackets
                  (&lt;code&gt;&lt;big&gt;&lt;b&gt;[&lt;/b&gt;&lt;/big&gt;&lt;/code&gt; and &lt;code&gt;&lt;big&gt;&lt;b&gt;]&lt;/b&gt;&lt;/big&gt;&lt;/code&gt;,
                  &lt;code&gt;&lt;big&gt;&lt;b&gt;&amp;lt;&lt;/b&gt;&lt;/big&gt;&lt;/code&gt; and &lt;code&gt;&lt;big&gt;&lt;b&gt;&amp;gt;&lt;/b&gt;&lt;/big&gt;&lt;/code&gt;),
                  plus, arbitrarily, the colon character &lt;code&gt;&lt;big&gt;&lt;b&gt;:&lt;/b&gt;&lt;/big&gt;&lt;/code&gt;.
                  There is no distinction between type, method, and field names.
                  This makes it easier to convert between mangled names of different
                  types, since they do not need to be decoded (demangled).
                  &lt;/p&gt;
                  &lt;p&gt;
                  The escape character is backslash &lt;code&gt;&lt;big&gt;&lt;b&gt;\&lt;/b&gt;&lt;/big&gt;&lt;/code&gt;
                  (also known as reverse solidus).
                  This character is, until now, unheard of in bytecode names,
                  but traditional in the proposed role.
                  &lt;/p&gt;
                  &lt;h3&gt; Replacement Characters &lt;/h3&gt;
                  &lt;p&gt;
                  Every escape sequence is two characters
                  (in fact, two UTF8 bytes) beginning with
                  the escape character and followed by a
                  &lt;cite&gt;replacement character&lt;/cite&gt;.
                  (Since the replacement character is never a backslash,
                  iterated manglings do not double in size.)
                  &lt;/p&gt;
                  &lt;p&gt;
                  Each dangerous character has some rough visual similarity
                  to its corresponding replacement character.
                  This makes mangled symbols easier to recognize by sight.
                  &lt;/p&gt;
                  &lt;p&gt;
                  The dangerous characters are
                  &lt;code&gt;&lt;big&gt;&lt;b&gt;/&lt;/b&gt;&lt;/big&gt;&lt;/code&gt; (forward slash, used to delimit package components),
                  &lt;code&gt;&lt;big&gt;&lt;b&gt;.&lt;/b&gt;&lt;/big&gt;&lt;/code&gt; (dot, also a package delimiter),
                  &lt;code&gt;&lt;big&gt;&lt;b&gt;;&lt;/b&gt;&lt;/big&gt;&lt;/code&gt; (semicolon, used in signatures),
                  &lt;code&gt;&lt;big&gt;&lt;b&gt;$&lt;/b&gt;&lt;/big&gt;&lt;/code&gt; (dollar, used in inner classes and synthetic members),
                  &lt;code&gt;&lt;big&gt;&lt;b&gt;&amp;lt;&lt;/b&gt;&lt;/big&gt;&lt;/code&gt; (left angle),
                  &lt;code&gt;&lt;big&gt;&lt;b&gt;&amp;gt;&lt;/b&gt;&lt;/big&gt;&lt;/code&gt; (right angle),
                  &lt;code&gt;&lt;big&gt;&lt;b&gt;[&lt;/b&gt;&lt;/big&gt;&lt;/code&gt; (left square bracket, used in array types),
                  &lt;code&gt;&lt;big&gt;&lt;b&gt;]&lt;/b&gt;&lt;/big&gt;&lt;/code&gt; (right square bracket, reserved in this scheme for language use),
                  and &lt;code&gt;&lt;big&gt;&lt;b&gt;:&lt;/b&gt;&lt;/big&gt;&lt;/code&gt; (colon, reserved in this scheme for language use).
                  Their replacements are, respectively,
                  &lt;code&gt;&lt;big&gt;&lt;b&gt;|&lt;/b&gt;&lt;/big&gt;&lt;/code&gt; (vertical bar),
                  &lt;code&gt;&lt;big&gt;&lt;b&gt;,&lt;/b&gt;&lt;/big&gt;&lt;/code&gt; (comma),
                  &lt;code&gt;&lt;big&gt;&lt;b&gt;?&lt;/b&gt;&lt;/big&gt;&lt;/code&gt; (question mark),
                  &lt;code&gt;&lt;big&gt;&lt;b&gt;%&lt;/b&gt;&lt;/big&gt;&lt;/code&gt; (percent),
                  &lt;code&gt;&lt;big&gt;&lt;b&gt;^&lt;/b&gt;&lt;/big&gt;&lt;/code&gt; (caret),
                  &lt;code&gt;&lt;big&gt;&lt;b&gt;_&lt;/b&gt;&lt;/big&gt;&lt;/code&gt; (underscore), and
                  &lt;code&gt;&lt;big&gt;&lt;b&gt;{&lt;/b&gt;&lt;/big&gt;&lt;/code&gt; (left curly bracket),
                  &lt;code&gt;&lt;big&gt;&lt;b&gt;}&lt;/b&gt;&lt;/big&gt;&lt;/code&gt; (right curly bracket),
                  &lt;code&gt;&lt;big&gt;&lt;b&gt;!&lt;/b&gt;&lt;/big&gt;&lt;/code&gt; (exclamation mark).
                  In addition, the replacement character for the escape character itself is
                  &lt;code&gt;&lt;big&gt;&lt;b&gt;-&lt;/b&gt;&lt;/big&gt;&lt;/code&gt; (hyphen),
                  and the replacement character for the null prefix is
                  &lt;code&gt;&lt;big&gt;&lt;b&gt;=&lt;/b&gt;&lt;/big&gt;&lt;/code&gt; (equal sign).
                  &lt;/p&gt;
                  &lt;p&gt;
                  An escape character &lt;code&gt;&lt;big&gt;&lt;b&gt;\&lt;/b&gt;&lt;/big&gt;&lt;/code&gt;
                  followed by any of these replacement characters
                  is an escape sequence, and there are no other escape sequences.
                  An equal sign is only part of an escape sequence
                  if it is the second character in the whole string, following a backslash.
                  Two consecutive backslashes do &lt;em&gt;not&lt;/em&gt; form an escape sequence.
                  &lt;/p&gt;
                  &lt;p&gt;
                  Each escape sequence replaces a so-called &lt;cite&gt;original character&lt;/cite&gt;
                  which is either one of the dangerous characters or the escape character.
                  A null prefix replaces an initial null string, not a character.
                  &lt;/p&gt;
                  &lt;p&gt;
                  All this implies that escape sequences cannot overlap and may be
                  determined all at once for a whole string.  Note that a spelling
                  string can contain &lt;cite&gt;accidental escapes&lt;/cite&gt;, apparent escape
                  sequences which must not be interpreted as manglings.
                  These are disabled by replacing their leading backslash with an
                  escape sequence (&lt;code&gt;&lt;big&gt;&lt;b&gt;\-&lt;/b&gt;&lt;/big&gt;&lt;/code&gt;).  To mangle a string, three logical steps
                  are required, though they may be carried out in one pass:
                  &lt;/p&gt;
                  &lt;ol&gt;
                  &lt;li&gt;In each accidental escape, replace the backslash with an escape sequence
                  (&lt;code&gt;&lt;big&gt;&lt;b&gt;\-&lt;/b&gt;&lt;/big&gt;&lt;/code&gt;).&lt;/li&gt;
                  &lt;li&gt;Replace each dangerous character with an escape sequence
                  (&lt;code&gt;&lt;big&gt;&lt;b&gt;\|&lt;/b&gt;&lt;/big&gt;&lt;/code&gt; for &lt;code&gt;&lt;big&gt;&lt;b&gt;/&lt;/b&gt;&lt;/big&gt;&lt;/code&gt;, etc.).&lt;/li&gt;
                  &lt;li&gt;If the first two steps introduced any change, &lt;em&gt;and&lt;/em&gt;
                  if the string does not already begin with a backslash, prepend a null prefix (&lt;code&gt;&lt;big&gt;&lt;b&gt;\=&lt;/b&gt;&lt;/big&gt;&lt;/code&gt;).&lt;/li&gt;
                  &lt;/ol&gt;
                  To demangle a mangled string that begins with an escape,
                  remove any null prefix, and then replace (in parallel)
                  each escape sequence by its original character.
                  &lt;p&gt;Spelling strings which contain accidental
                  escapes &lt;em&gt;must&lt;/em&gt; have them replaced, even if those
                  strings do not contain dangerous characters.
                  This restriction means that mangling a string always
                  requires a scan of the string for escapes.
                  But then, a scan would be required anyway,
                  to check for dangerous characters.
                  &lt;/p&gt;
                  &lt;h3&gt; Nice Properties &lt;/h3&gt;
                  &lt;p&gt;
                  If a bytecode name does not contain any escape sequence,
                  demangling is a no-op:  The string demangles to itself.
                  Such a string is called &lt;cite&gt;self-mangling&lt;/cite&gt;.
                  Almost all strings are self-mangling.
                  In practice, to demangle almost any name &amp;ldquo;found in nature&amp;rdquo;,
                  simply verify that it does not begin with a backslash.
                  &lt;/p&gt;
                  &lt;p&gt;
                  Mangling is a one-to-one function, while demangling
                  is a many-to-one function.
                  A mangled string is defined as &lt;cite&gt;validly mangled&lt;/cite&gt; if
                  it is in fact the unique mangling of its spelling string.
                  Three examples of invalidly mangled strings are &lt;code&gt;&lt;big&gt;&lt;b&gt;\=foo&lt;/b&gt;&lt;/big&gt;&lt;/code&gt;,
                  &lt;code&gt;&lt;big&gt;&lt;b&gt;\-bar&lt;/b&gt;&lt;/big&gt;&lt;/code&gt;, and &lt;code&gt;&lt;big&gt;&lt;b&gt;baz\!&lt;/b&gt;&lt;/big&gt;&lt;/code&gt;, which demangle to &lt;code&gt;&lt;big&gt;&lt;b&gt;foo&lt;/b&gt;&lt;/big&gt;&lt;/code&gt;, &lt;code&gt;&lt;big&gt;&lt;b&gt;\bar&lt;/b&gt;&lt;/big&gt;&lt;/code&gt;, and
                  &lt;code&gt;&lt;big&gt;&lt;b&gt;baz\!&lt;/b&gt;&lt;/big&gt;&lt;/code&gt;, but then remangle to &lt;code&gt;&lt;big&gt;&lt;b&gt;foo&lt;/b&gt;&lt;/big&gt;&lt;/code&gt;, &lt;code&gt;&lt;big&gt;&lt;b&gt;\bar&lt;/b&gt;&lt;/big&gt;&lt;/code&gt;, and &lt;code&gt;&lt;big&gt;&lt;b&gt;\=baz\-!&lt;/b&gt;&lt;/big&gt;&lt;/code&gt;.
                  If a language back-end or runtime is using mangled names,
                  it should never present an invalidly mangled bytecode
                  name to the JVM.  If the runtime encounters one,
                  it should also report an error, since such an occurrence
                  probably indicates a bug in name encoding which
                  will lead to errors in linkage.
                  However, this note does not propose that the JVM verifier
                  detect invalidly mangled names.
                  &lt;/p&gt;
                  &lt;p&gt;
                  As a result of these rules, it is a simple matter to
                  compute validly mangled substrings and concatenations
                  of validly mangled strings, and (with a little care)
                  these correspond to corresponding operations on their
                  spelling strings.
                  &lt;/p&gt;
                  &lt;ul&gt;
                  &lt;li&gt;Any prefix of a validly mangled string is also validly mangled,
                  although a null prefix may need to be removed.&lt;/li&gt;
                  &lt;li&gt;Any suffix of a validly mangled string is also validly mangled,
                  although a null prefix may need to be added.&lt;/li&gt;
                  &lt;li&gt;Two validly mangled strings, when concatenated,
                  are also validly mangled, although any null prefix
                  must be removed from the second string,
                  and a trailing backslash on the first string may need escaping,
                  if it would participate in an accidental escape when followed
                  by the first character of the second string.&lt;/li&gt;
                  &lt;/ul&gt;
                  &lt;p&gt;If languages that include non-Java symbol spellings use this
                  mangling convention, they will enjoy the following advantages:
                  &lt;/p&gt;
                  &lt;ul&gt;
                  &lt;li&gt;They can interoperate via symbols they share in common.&lt;/li&gt;
                  &lt;li&gt;Low-level tools, such as backtrace printers, will have readable displays.&lt;/li&gt;
                  &lt;li&gt;Future JVM and language extensions can safely use the dangerous characters
                  for structuring symbols, but will never interfere with valid spellings.&lt;/li&gt;
                  &lt;li&gt;Runtimes and compilers can use standard libraries for mangling and demangling.&lt;/li&gt;
                  &lt;li&gt;Occasional transliterations and name composition will be simple and regular,
                  for classes, methods, and fields.&lt;/li&gt;
                  &lt;li&gt;Bytecode names will continue to be compact.
                  When mangled, spellings will at most double in length, either in
                  UTF8 or UTF16 format, and most will not change at all.&lt;/li&gt;
                  &lt;/ul&gt;
                  &lt;h3&gt; Suggestions for Human Readable Presentations &lt;/h3&gt;
                  &lt;p&gt;
                  For human readable displays of symbols,
                  it will be better to present a string-like quoted
                  representation of the spelling, because JVM users
                  are generally familiar with such tokens.
                  We suggest using single or double quotes before and after
                  mangled symbols which are not valid Java identifiers,
                  with quotes, backslashes, and non-printing characters
                  escaped as if for literals in the Java language.
                  &lt;/p&gt;
                  &lt;p&gt;
                  For example, an HTML-like spelling
                  &lt;code&gt;&lt;big&gt;&lt;b&gt;&amp;lt;pre&amp;gt;&lt;/b&gt;&lt;/big&gt;&lt;/code&gt; mangles to
                  &lt;code&gt;&lt;big&gt;&lt;b&gt;\^pre\_&lt;/b&gt;&lt;/big&gt;&lt;/code&gt; and could
                  display more cleanly as
                  &lt;code&gt;&lt;big&gt;&lt;b&gt;&apos;&amp;lt;pre&amp;gt;&apos;&lt;/b&gt;&lt;/big&gt;&lt;/code&gt;,
                  with the quotes included.
                  Such string-like conventions are &lt;em&gt;not&lt;/em&gt; suitable
                  for mangled bytecode names, in part because
                  dangerous characters must be eliminated, rather
                  than just quoted.  Otherwise internally structured
                  strings like package prefixes and method signatures
                  could not be reliably parsed.
                  &lt;/p&gt;
                  &lt;p&gt;
                  In such human-readable displays, invalidly mangled
                  names should &lt;em&gt;not&lt;/em&gt; be demangled and quoted,
                  for this would be misleading.  Likewise, JVM symbols
                  which contain dangerous characters (like dots in field
                  names or brackets in method names) should not be
                  simply quoted.  The bytecode names
                  &lt;code&gt;&lt;big&gt;&lt;b&gt;\=phase\,1&lt;/b&gt;&lt;/big&gt;&lt;/code&gt; and
                  &lt;code&gt;&lt;big&gt;&lt;b&gt;phase.1&lt;/b&gt;&lt;/big&gt;&lt;/code&gt; are distinct,
                  and in demangled displays they should be presented as
                  &lt;code&gt;&lt;big&gt;&lt;b&gt;&apos;phase.1&apos;&lt;/b&gt;&lt;/big&gt;&lt;/code&gt; and something like
                  &lt;code&gt;&lt;big&gt;&lt;b&gt;&apos;phase&apos;.1&lt;/b&gt;&lt;/big&gt;&lt;/code&gt;, respectively.
                  &lt;/p&gt;                
                <author>
                    John Rose                    
                </author>
                <version>
                    1.2, 02/06/2008                    
                </version>
                <see>
                    http://blogs.sun.com/jrose/entry/symbolic_freedom_in_the_vm                    
                </see>
            </javadoc>
            <method name="BytecodeName" type="constructor" line="257"/>
            <javadoc line="259">
                Given a source name, produce the corresponding bytecode name.
                  The source name should not be qualified, because any syntactic
                  markers (dots, slashes, dollar signs, colons, etc.) will be mangled.                
                <param>
                    s the source name                    
                </param>
                <return>
                    a valid bytecode name which represents the source name                    
                </return>
            </javadoc>
            <method name="toBytecodeName" type="String" line="265">
                <params>
                    <param name="s" type="String"/>
                </params>
                <declaration name="bn" type="String" line="266"/>
            </method>
            <javadoc line="272">
                Given an unqualified bytecode name, produce the corresponding source name.
                  The bytecode name must not contain dangerous characters.
                  In particular, it must not be qualified or segmented by colon {@code &apos;:&apos;}.                
                <param>
                    s the bytecode name                    
                </param>
                <return>
                    the source name, which may possibly have unsafe characters                    
                </return>
                <throws>
                    IllegalArgumentException if the bytecode name is not {@link #isSafeBytecodeName safe}                    
                </throws>
                <see>
                    #isSafeBytecodeName(java.lang.String)                    
                </see>
            </javadoc>
            <method name="toSourceName" type="String" line="280">
                <params>
                    <param name="s" type="String"/>
                </params>
                <declaration name="sn" type="String" line="282"/>
                <scope line="283"/>
            </method>
            <javadoc line="290">
                Given a bytecode name from a classfile, separate it into
                  components delimited by dangerous characters.
                  Each resulting array element will be either a dangerous character,
                  or else a safe bytecode name.
                  (The safe name might possibly be mangled to hide further dangerous characters.)
                  For example, the qualified class name {@code java/lang/String}will be parsed into the array {@code} 
                  &quot;java&quot;, &apos;/&apos;, &quot;lang&quot;, &apos;/&apos;, &quot;String&quot;}}.
                  The name {@code &amp;lt;init&amp;gt;} will be parsed into { &apos;&amp;lt;&apos;, &quot;init&quot;, &apos;&amp;gt;&apos;}}
                  The name {@code foo/bar$:baz} will be parsed into{@code} 
                  &quot;foo&quot;, &apos;/&apos;, &quot;bar&quot;, &apos;$&apos;, &apos;:&apos;, &quot;baz&quot;}}.
                  The name {@code ::\=:foo:\=bar\!baz} will be parsed into{@code} 
                  &apos;:&apos;, &apos;:&apos;, &quot;&quot;, &apos;:&apos;, &quot;foo&quot;, &apos;:&apos;, &quot;bar:baz&quot;}}.                
            </javadoc>
            <method name="parseBytecodeName" type="Object[]" line="304">
                <params>
                    <param name="s" type="String"/>
                </params>
                <comment line="316">
                    got to end of string or next dangerous char                    
                </comment>
                <comment line="318">
                    normal component                    
                </comment>
                <comment line="332">
                    between passes, build the result array                    
                </comment>
                <declaration name="slen" type="int" line="305"/>
                <declaration name="res" type="Object[]" line="306"/>
                <scope line="307">
                    <declaration name="fillp" type="int" line="308"/>
                    <declaration name="lasti" type="int" line="309"/>
                    <scope line="310">
                        <declaration name="whichDC" type="int" line="311"/>
                        <scope line="312"/>
                        <scope line="317"/>
                        <scope line="324"/>
                    </scope>
                    <scope line="334"/>
                </scope>
            </method>
            <javadoc line="342">
                Given a series of components, create a bytecode name for a classfile.
                  This is the inverse of {@link #parseBytecodeName(java.lang.String)}.
                  Each component must either be an interned one-character string of
                  a dangerous character, or else a safe bytecode name.                
                <param>
                    components a series of name components                    
                </param>
                <return>
                    the concatenation of all components                    
                </return>
                <throws>
                    IllegalArgumentException if any component contains an unsafe
                      character, and is not an interned one-character string                    
                </throws>
                <throws>
                    NullPointerException if any component is null                    
                </throws>
            </javadoc>
            <method name="unparseBytecodeName" type="String" line="353">
                <params>
                    <param name="components" type="Object[]"/>
                </params>
                <comment line="360">
                    usual case                    
                </comment>
                <declaration name="components0" type="Object[]" line="354"/>
                <scope line="355">
                    <declaration name="c" type="Object" line="356"/>
                    <scope line="357">
                        <declaration name="mc" type="String" line="358"/>
                        <scope line="361"/>
                    </scope>
                </scope>
            </method>
            <method name="appendAll" type="String" line="370">
                <params>
                    <param name="components" type="Object[]"/>
                </params>
                <scope line="371">
                    <scope line="372"/>
                </scope>
                <declaration name="slen" type="int" line="377"/>
                <scope line="378"/>
                <declaration name="sb" type="StringBuilder" line="384"/>
                <scope line="385"/>
            </method>
            <javadoc line="391">
                Given a bytecode name, produce the corresponding display name.
                  This is the source name, plus quotes if needed.
                  If the bytecode name contains dangerous characters,
                  assume that they are being used as punctuation,
                  and pass them through unchanged.
                  Non-empty runs of non-dangerous characters are demangled
                  if necessary, and the resulting names are quoted if
                  they are not already valid Java identifiers, or if
                  they contain a dangerous character (i.e., dollar sign &quot;$&quot;).
                  Single quotes are used when quoting.
                  Within quoted names, embedded single quotes and backslashes
                  are further escaped by prepended backslashes.                
                <param>
                    s the original bytecode name (which may be qualified)                    
                </param>
                <return>
                    a human-readable presentation                    
                </return>
            </javadoc>
            <method name="toDisplayName" type="String" line="408">
                <params>
                    <param name="s" type="String"/>
                </params>
                <comment line="414">
                    note that the name is already demangled!                    
                </comment>
                <comment line="415">
                    sn = toSourceName(sn);                    
                </comment>
                <declaration name="components" type="Object[]" line="409"/>
                <scope line="410">
                    <declaration name="sn" type="String" line="413"/>
                    <scope line="416"/>
                </scope>
            </method>
            <method name="isJavaIdent" type="boolean" line="422">
                <params>
                    <param name="s" type="String"/>
                </params>
                <declaration name="slen" type="int" line="423"/>
                <scope line="427"/>
            </method>
            <method name="quoteDisplay" type="String" line="433">
                <params>
                    <param name="s" type="String"/>
                </params>
                <comment line="434">
                    TO DO:  Replace wierd characters in s by C-style escapes.                    
                </comment>
            </method>
            <method name="checkSafeBytecodeName" type="void" line="439">
                <params>
                    <param name="s" type="String"/>
                </params>
                <scope line="440"/>
            </method>
            <javadoc line="445">
                Report whether a simple name is safe as a bytecode name.
                  Such names are acceptable in class files as class, method, and field names.
                  Additionally, they are free of &quot;dangerous&quot; characters, even if those
                  characters are legal in some (or all) names in class files.                
                <param>
                    s the proposed bytecode name                    
                </param>
                <return>
                    true if the name is non-empty and all of its characters are safe                    
                </return>
            </javadoc>
            <method name="isSafeBytecodeName" type="boolean" line="453">
                <params>
                    <param name="s" type="String"/>
                </params>
                <comment line="455">
                    check occurrences of each DANGEROUS char                    
                </comment>
                <comment line="457">
                    not really that dangerous                    
                </comment>
                <scope line="456"/>
            </method>
            <javadoc line="463">
                Report whether a character is safe in a bytecode name.
                  This is true of any unicode character except the following
                  &lt;em&gt;dangerous characters&lt;/em&gt;: {@code &quot;.;:$[]&lt;&gt;/&quot;}.                
                <param>
                    s the proposed character                    
                </param>
                <return>
                    true if the character is safe to use in classfiles                    
                </return>
            </javadoc>
            <method name="isSafeBytecodeChar" type="boolean" line="470">
                <params>
                    <param name="c" type="char"/>
                </params>
            </method>
            <method name="looksMangled" type="boolean" line="474">
                <params>
                    <param name="s" type="String"/>
                </params>
            </method>
            <method name="mangle" type="String" line="478">
                <params>
                    <param name="s" type="String"/>
                </params>
                <comment line="482">
                    build this lazily, when we first need an escape:                    
                </comment>
                <comment line="494">
                    an accidental escape                    
                </comment>
                <comment line="507">
                    build sb if this is the first escape                    
                </comment>
                <comment line="510">
                    mangled names must begin with a backslash:                    
                </comment>
                <comment line="513">
                    append the string so far, which is unremarkable:                    
                </comment>
                <comment line="517">
                    rewrite \ to \-, / to \|, etc.                    
                </comment>
                <declaration name="sb" type="StringBuilder" line="483"/>
                <scope line="485">
                    <declaration name="c" type="char" line="486"/>
                    <declaration name="needEscape" type="boolean" line="488"/>
                    <scope line="489">
                        <scope line="490">
                            <declaration name="c1" type="char" line="491"/>
                            <scope line="493"/>
                        </scope>
                    </scope>
                    <scope line="498"/>
                    <scope line="502"/>
                    <scope line="508"/>
                </scope>
            </method>
            <method name="demangle" type="String" line="527">
                <params>
                    <param name="s" type="String"/>
                </params>
                <comment line="528">
                    build this lazily, when we first meet an escape:                    
                </comment>
                <comment line="539">
                    might be an escape sequence                    
                </comment>
                <comment line="543">
                    build sb if this is the first escape                    
                </comment>
                <comment line="546">
                    append the string so far, which is unremarkable:                    
                </comment>
                <comment line="549">
                    skip both characters                    
                </comment>
                <declaration name="sb" type="StringBuilder" line="529"/>
                <declaration name="stringStart" type="int" line="531"/>
                <scope line="535">
                    <declaration name="c" type="char" line="536"/>
                    <scope line="538">
                        <declaration name="rc" type="char" line="540"/>
                        <declaration name="oc" type="char" line="541"/>
                        <scope line="542">
                            <scope line="544"/>
                        </scope>
                    </scope>
                </scope>
            </method>
            <declaration name="ESCAPE_C" type="char" line="563"/>
            <declaration name="NULL_ESCAPE_C" type="char" line="565"/>
            <declaration name="NULL_ESCAPE" type="String" line="566"/>
            <declaration name="DANGEROUS_CHARS" type="String" line="568"/>
            <declaration name="REPLACEMENT_CHARS" type="String" line="569"/>
            <declaration name="DANGEROUS_CHAR_FIRST_INDEX" type="int" line="570"/>
            <declaration name="DANGEROUS_CHARS_A" type="char[]" line="571"/>
            <declaration name="REPLACEMENT_CHARS_A" type="char[]" line="572"/>
            <declaration name="DANGEROUS_CHARS_CA" type="Character[]" line="573"/>
            <scope line="574">
                <declaration name="dcca" type="Character[]" line="575"/>
            </scope>
            <declaration name="SPECIAL_BITMAP" type="long[]" line="581"/>
            <scope line="582">
                <declaration name="SPECIAL" type="String" line="583"/>
                <scope line="585"/>
            </scope>
            <method name="isSpecial" type="boolean" line="589">
                <params>
                    <param name="c" type="char"/>
                </params>
            </method>
            <method name="replacementOf" type="char" line="595">
                <params>
                    <param name="c" type="char"/>
                </params>
                <declaration name="i" type="int" line="597"/>
            </method>
            <method name="originalOfReplacement" type="char" line="601">
                <params>
                    <param name="c" type="char"/>
                </params>
                <declaration name="i" type="int" line="603"/>
            </method>
            <method name="isDangerous" type="boolean" line="607">
                <params>
                    <param name="c" type="char"/>
                </params>
            </method>
            <method name="indexOfDangerousChar" type="int" line="611">
                <params>
                    <param name="s" type="String"/>
                    <param name="from" type="int"/>
                </params>
                <scope line="612"/>
            </method>
            <method name="lastIndexOfDangerousChar" type="int" line="618">
                <params>
                    <param name="s" type="String"/>
                    <param name="from" type="int"/>
                </params>
                <scope line="619"/>
            </method>
        </class>
    </source>