<?xml version="1.0" encoding="UTF-8"?>
    <source package="sun.invoke.util">
        <import package="java.lang.reflect.Modifier"/>
        <import package="java.lang.reflect.Modifier"/>
        <class name="VerifyAccess" line="4">
            <javadoc line="4">
                This class centralizes information about the JVM&apos;s linkage access control.                
                <author>
                    jrose                    
                </author>
            </javadoc>
            <method name="VerifyAccess" type="constructor" line="9"/>
            <declaration name="PACKAGE_ONLY" type="int" line="11"/>
            <declaration name="ALL_ACCESS_MODES" type="int" line="12"/>
            <declaration name="ALLOW_NESTMATE_ACCESS" type="boolean" line="13"/>
            <javadoc line="14">
                Evaluate the JVM linkage rules for access to the given method
                  on behalf of a caller class which proposes to perform the access.
                  Return true if the caller class has privileges to invoke a method
                  or access a field with the given properties.
                  This requires an accessibility check of the referencing class,
                  plus an accessibility check of the member within the class,
                  which depends on the member&apos;s modifier flags.
                  &lt;p&gt;
                  The relevant properties include the defining class ({@code defc})
                  of the member, and its modifier flags ({@code mods}).
                  Also relevant is the class used to make the initial symbolic reference
                  to the member ({@code refc}).  If this latter class is not distinguished,
                  the defining class should be passed for both arguments ({@code defc == refc}).
                  &lt;h3&gt;JVM Specification, 5.4.4 &quot;Access Control&quot;&lt;/h3&gt;
                  A field or method R is accessible to a class or interface D if
                  and only if any of the following conditions is true:&lt;ul&gt;
                  &lt;li&gt;R is public.
                  &lt;li&gt;R is protected and is declared in a class C, and D is either
                  a subclass of C or C itself.  Furthermore, if R is not
                  static, then the symbolic reference to R must contain a
                  symbolic reference to a class T, such that T is either a
                  subclass of D, a superclass of D or D itself.
                  &lt;li&gt;R is either protected or has default access (that is,
                  neither public nor protected nor private), and is declared
                  by a class in the same runtime package as D.
                  &lt;li&gt;R is private and is declared in D.
                  &lt;/ul&gt;
                  This discussion of access control omits a related restriction
                  on the target of a protected field access or method invocation
                  (the target must be of class D or a subtype of D). That
                  requirement is checked as part of the verification process
                  (5.4.1); it is not part of link-time access control.                
                <param>
                    refc the class used in the symbolic reference to the proposed member                    
                </param>
                <param>
                    defc the class in which the proposed member is actually defined                    
                </param>
                <param>
                    mods modifier flags for the proposed member                    
                </param>
                <param>
                    lookupClass the class for which the access check is being made                    
                </param>
                <return>
                    true iff the the accessing class can access such a member                    
                </return>
            </javadoc>
            <method name="isMemberAccessible" type="boolean" line="53">
                <params>
                    <param name="refc" type="Class&lt;?&gt;"/>
                    <param name="defc" type="Class&lt;?&gt;"/>
                    <param name="mods" type="int"/>
                    <param name="lookupClass" type="Class&lt;?&gt;"/>
                </params>
                <scope line="54">
                    <scope line="55"/>
                    <scope line="58"/>
                </scope>
            </method>
            <method name="isRelatedClass" type="boolean" line="77">
                <params>
                    <param name="refc" type="Class&lt;?&gt;"/>
                    <param name="lookupClass" type="Class&lt;?&gt;"/>
                </params>
            </method>
            <method name="isPublicSuperClass" type="boolean" line="80">
                <params>
                    <param name="defc" type="Class&lt;?&gt;"/>
                    <param name="lookupClass" type="Class&lt;?&gt;"/>
                </params>
            </method>
            <javadoc line="83">
                Evaluate the JVM linkage rules for access to the given class on behalf of caller.
                  &lt;h3&gt;JVM Specification, 5.4.4 &quot;Access Control&quot;&lt;/h3&gt;
                  A class or interface C is accessible to a class or interface D
                  if and only if either of the following conditions are true:&lt;ul&gt;
                  &lt;li&gt;C is public.
                  &lt;li&gt;C and D are members of the same runtime package.
                  &lt;/ul&gt;                
                <param>
                    refc the symbolic reference class to which access is being checked (C)                    
                </param>
                <param>
                    lookupClass the class performing the lookup (D)                    
                </param>
            </javadoc>
            <method name="isClassAccessible" type="boolean" line="94">
                <params>
                    <param name="refc" type="Class&lt;?&gt;"/>
                    <param name="lookupClass" type="Class&lt;?&gt;"/>
                </params>
                <declaration name="mods" type="int" line="95"/>
            </method>
            <javadoc line="100">
                Test if two classes have the same class loader and package qualifier.                
                <param>
                    class1                    
                </param>
                <param>
                    class2                    
                </param>
                <return>
                    whether they are in the same package                    
                </return>
            </javadoc>
            <method name="isSamePackage" type="boolean" line="106">
                <params>
                    <param name="class1" type="Class&lt;?&gt;"/>
                    <param name="class2" type="Class&lt;?&gt;"/>
                </params>
                <declaration name="name1" type="String" line="110"/>
                <declaration name="dot" type="int" line="111"/>
                <scope line="113"/>
            </method>
            <javadoc line="118">
                Return the package name for this class.                
            </javadoc>
            <method name="getPackageName" type="String" line="121">
                <params>
                    <param name="cls" type="Class&lt;?&gt;"/>
                </params>
                <declaration name="name" type="String" line="123"/>
                <declaration name="dot" type="int" line="124"/>
            </method>
            <javadoc line="128">
                Test if two classes are defined as part of the same package member (top-level class).
                  If this is true, they can share private access with each other.                
                <param>
                    class1                    
                </param>
                <param>
                    class2                    
                </param>
                <return>
                    whether they are identical or nested together                    
                </return>
            </javadoc>
            <method name="isSamePackageMember" type="boolean" line="135">
                <params>
                    <param name="class1" type="Class&lt;?&gt;"/>
                    <param name="class2" type="Class&lt;?&gt;"/>
                </params>
            </method>
            <method name="getOutermostEnclosingClass" type="Class&lt;?&gt;" line="141">
                <params>
                    <param name="c" type="Class&lt;?&gt;"/>
                </params>
                <declaration name="pkgmem" type="Class&amp;lt;?&amp;gt;" line="142"/>
            </method>
            <method name="loadersAreRelated" type="boolean" line="146">
                <params>
                    <param name="loader1" type="ClassLoader"/>
                    <param name="loader2" type="ClassLoader"/>
                    <param name="loader1MustBeParent" type="boolean"/>
                </params>
                <scope line="147"/>
                <scope line="150"/>
                <scope line="154"/>
            </method>
            <javadoc line="159">
                Is the class loader of parentClass identical to, or an ancestor of,
                  the class loader of childClass?                
                <param>
                    parentClass                    
                </param>
                <param>
                    childClass                    
                </param>
                <return>
                    whether parentClass precedes or equals childClass in class loader order                    
                </return>
            </javadoc>
            <method name="classLoaderIsAncestor" type="boolean" line="166">
                <params>
                    <param name="parentClass" type="Class&lt;?&gt;"/>
                    <param name="childClass" type="Class&lt;?&gt;"/>
                </params>
            </method>
        </class>
    </source>