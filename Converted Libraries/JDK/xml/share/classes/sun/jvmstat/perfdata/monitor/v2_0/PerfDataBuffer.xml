<?xml version="1.0" encoding="UTF-8"?>
    <source package="sun.jvmstat.perfdata.monitor.v2_0">
        <import package="sun.jvmstat.monitor"/>
        <import package="sun.jvmstat.perfdata.monitor"/>
        <import package="java.util"/>
        <import package="java.util.regex"/>
        <import package="java.nio"/>
        <class name="PerfDataBuffer" line="34">
            <extends class="PerfDataBufferImpl"/>
            <comment line="71">
                These are primarily for documentary purposes and the match up
                 with the PerfDataEntry structure in perfMemory.hpp. They are
                 generally unused in this code, but they are kept consistent with
                 the data structure just in case some unforseen need arrises.                
            </comment>
            <comment line="78">
                sizeof(int)                
            </comment>
            <comment line="80">
                sizeof(int)                
            </comment>
            <comment line="82">
                sizeof(int)                
            </comment>
            <comment line="84">
                sizeof(byte)                
            </comment>
            <comment line="86">
                sizeof(byte)                
            </comment>
            <comment line="88">
                sizeof(byte)                
            </comment>
            <comment line="90">
                sizeof(byte)                
            </comment>
            <comment line="92">
                sizeof(int)                
            </comment>
            <javadoc line="34">
                The concrete implementation of version 2.0 of the HotSpot PerfData
                  Instrumentation buffer. This class is responsible for parsing the
                  instrumentation memory and constructing the necessary objects to
                  represent and access the instrumentation objects contained in the
                  memory buffer.
                  &lt;p&gt;
                  The structure of the 2.0 entry is defined in struct PerfDataEnry
                  as decsribed in perfMemory.hpp. This structure looks like:
                  &lt;pre&gt;
                  typedef struct {
                  jint entry_length;         // entry length in bytes
                  jint name_offset;          // offset to entry name, relative to start
                  // of entry
                  jint vector_length;        // length of the vector. If 0, then scalar.
                  jbyte data_type;           // JNI field descriptor type
                  jbyte flags;               // miscellaneous attribute flags
                  // 0x01 - supported
                  jbyte data_units;          // unit of measure attribute
                  jbyte data_variability;    // variability attribute
                  jbyte data_offset;         // offset to data item, relative to start
                  // of entry.
                  } PerfDataEntry;
                  &lt;/pre&gt;                
                <author>
                    Brian Doherty                    
                </author>
                <since>
                    1.5                    
                </since>
                <see>
                    AbstractPerfDataBuffer                    
                </see>
            </javadoc>
            <declaration name="DEBUG" type="boolean" line="65"/>
            <declaration name="syncWaitMs" type="int" line="66"/>
            <declaration name="EMPTY_LIST" type="ArrayList" line="68"/>
            <declaration name="PERFDATA_ENTRYLENGTH_OFFSET" type="int" line="76"/>
            <declaration name="PERFDATA_ENTRYLENGTH_SIZE" type="int" line="77"/>
            <declaration name="PERFDATA_NAMEOFFSET_OFFSET" type="int" line="78"/>
            <declaration name="PERFDATA_NAMEOFFSET_SIZE" type="int" line="79"/>
            <declaration name="PERFDATA_VECTORLENGTH_OFFSET" type="int" line="80"/>
            <declaration name="PERFDATA_VECTORLENGTH_SIZE" type="int" line="81"/>
            <declaration name="PERFDATA_DATATYPE_OFFSET" type="int" line="82"/>
            <declaration name="PERFDATA_DATATYPE_SIZE" type="int" line="83"/>
            <declaration name="PERFDATA_FLAGS_OFFSET" type="int" line="84"/>
            <declaration name="PERFDATA_FLAGS_SIZE" type="int" line="85"/>
            <declaration name="PERFDATA_DATAUNITS_OFFSET" type="int" line="86"/>
            <declaration name="PERFDATA_DATAUNITS_SIZE" type="int" line="87"/>
            <declaration name="PERFDATA_DATAVAR_OFFSET" type="int" line="88"/>
            <declaration name="PERFDATA_DATAVAR_SIZE" type="int" line="89"/>
            <declaration name="PERFDATA_DATAOFFSET_OFFSET" type="int" line="90"/>
            <declaration name="PERFDATA_DATAOFFSET_SIZE" type="int" line="91"/>
            <declaration name="prologue" type="PerfDataBufferPrologue" line="93"/>
            <declaration name="nextEntry" type="int" line="94"/>
            <declaration name="lastNumEntries" type="long" line="95"/>
            <declaration name="overflow" type="IntegerMonitor" line="96"/>
            <declaration name="insertedMonitors" type="ArrayList&lt;Monitor&gt;" line="97"/>
            <javadoc line="99">
                Construct a PerfDataBuffer instance.
                  &lt;p&gt;
                  This class is dynamically loaded by{@link AbstractPerfDataBuffer#createPerfDataBuffer}, and this
                  constructor is called to instantiate the instance.                
                <param>
                    buffer the buffer containing the instrumentation data                    
                </param>
                <param>
                    lvmid the Local Java Virtual Machine Identifier for this
                      instrumentation buffer.                    
                </param>
            </javadoc>
            <method name="PerfDataBuffer" type="constructor" line="111">
                <params>
                    <param name="buffer" type="ByteBuffer"/>
                    <param name="lvmid" type="int"/>
                </params>
            </method>
            <javadoc line="117">
                {@inheritDoc}                
            </javadoc>
            <method name="buildMonitorMap" type="void" line="120">
                <params>
                    <param name="map" type="Map<String,Monitor>"/>
                </params>
                <comment line="124">
                    start at the beginning of the buffer                    
                </comment>
                <comment line="127">
                    create pseudo monitors                    
                </comment>
                <comment line="130">
                    wait for the target JVM to indicate that it&apos;s intrumentation
                     buffer is safely accessible                    
                </comment>
                <comment line="134">
                    parse the currently defined entries starting at the first entry.                    
                </comment>
                <comment line="137">
                    record the number of entries before parsing the structure                    
                </comment>
                <comment line="140">
                    start parsing                    
                </comment>
                <comment line="147">
                    keep track of the current number of entries in the shared
                     memory for new entry detection purposes. It&apos;s possible for
                     the data structure to be modified while the Map is being
                     built and the entry count in the header might change while
                     we are parsing it. The map will contain all the counters
                     found, but the number recorded in numEntries might be small
                     than what than the number we actually parsed (due to asynchronous
                     updates). This discrepency is handled by ignoring any re-parsed
                     entries when updating the Map in getNewMonitors().                    
                </comment>
                <comment line="160">
                    keep track of the monitors just added.                    
                </comment>
                <declaration name="numEntries" type="int" line="137"/>
                <declaration name="monitor" type="Monitor" line="140"/>
                <scope line="141"/>
            </method>
            <javadoc line="163">
                {@inheritDoc}                
            </javadoc>
            <method name="getNewMonitors" type="void" line="166">
                <params>
                    <param name="map" type="Map<String,Monitor>"/>
                </params>
                <comment line="179">
                    guard against re-parsed entries                    
                </comment>
                <declaration name="numEntries" type="int" line="169"/>
                <scope line="171">
                    <declaration name="monitor" type="Monitor" line="173"/>
                    <scope line="175">
                        <declaration name="name" type="String" line="176"/>
                        <scope line="179">
                            <scope line="181"/>
                        </scope>
                    </scope>
                </scope>
            </method>
            <javadoc line="190">
                {@inheritDoc}                
            </javadoc>
            <method name="getMonitorStatus" type="MonitorStatus" line="193">
                <params>
                    <param name="map" type="Map<String,Monitor>"/>
                </params>
                <comment line="198">
                    load any new monitors                    
                </comment>
                <comment line="201">
                    current implementation doesn&apos;t support deletion of reuse of entries                    
                </comment>
                <declaration name="removed" type="ArrayList" line="201"/>
                <declaration name="inserted" type="ArrayList" line="202"/>
            </method>
            <javadoc line="208">
                Build the pseudo monitors used to map the prolog data into counters.                
            </javadoc>
            <method name="buildPseudoMonitors" type="void" line="211">
                <params>
                    <param name="map" type="Map<String,Monitor>"/>
                </params>
                <declaration name="monitor" type="Monitor" line="212"/>
                <declaration name="name" type="String" line="213"/>
                <declaration name="ib" type="IntBuffer" line="214"/>
                <declaration name="lb" type="LongBuffer" line="248"/>
            </method>
            <javadoc line="254">
                Method that waits until the target jvm indicates that
                  its shared memory is safe to access.                
            </javadoc>
            <method name="synchWithTarget" type="void" line="258">
                <comment line="260">
                    synch must happen with syncWaitMs from now. Default is 5 seconds,
                     which is reasonabally generous and should provide for extreme
                     situations like startup delays due to allocation of large ISM heaps.                    
                </comment>
                <comment line="267">
                    loop waiting for the accessible indicater to be non-zero                    
                </comment>
                <comment line="273">
                    give the target jvm a chance to complete initializatoin                    
                </comment>
                <declaration name="timeLimit" type="long" line="264"/>
                <scope line="268">
                    <scope line="273"/>
                    <scope line="273"/>
                    <scope line="275"/>
                </scope>
            </method>
            <javadoc line="283">
                method to extract the next monitor entry from the instrumentation memory.
                  assumes that nextEntry is the offset into the byte array
                  at which to start the search for the next entry. method leaves
                  next entry pointing to the next entry or to the end of data.                
            </javadoc>
            <method name="getNextMonitorEntry" type="Monitor" line="289">
                <comment line="293">
                    entries are always 4 byte aligned.                    
                </comment>
                <comment line="300">
                    protect againt a corrupted shard memory region.                    
                </comment>
                <comment line="308">
                    check for end of the buffer                    
                </comment>
                <comment line="320">
                    check for valid entry length                    
                </comment>
                <comment line="327">
                    check if last entry occurs before the eof.                    
                </comment>
                <comment line="337">
                    end of data                    
                </comment>
                <comment line="341">
                    we can safely read this entry                    
                </comment>
                <comment line="353">
                    convert common attributes to their object types                    
                </comment>
                <comment line="369">
                    verify that the name_offset is contained within the entry bounds                    
                </comment>
                <comment line="377">
                    verify that the data_offset is contained within the entry bounds                    
                </comment>
                <comment line="385">
                    validate the variability and units fields                    
                </comment>
                <comment line="400">
                    the entry looks good - parse the variable length components                    
                </comment>
                <comment line="402">
                    The name starts at nameOffset and continues up to the first null
                     byte. however, we don&apos;t know the length, but we can approximate it
                     without searching for the null by using the offset for the data
                     field, which follows the name field.                    
                </comment>
                <comment line="411">
                    include possible pad space                    
                </comment>
                <comment line="414">
                    maxNameLength better be less than the total entry length                    
                </comment>
                <comment line="417">
                    collect the characters, but do not collect the null byte,
                     as the String(byte[]) constructor does not ignore it!                    
                </comment>
                <comment line="428">
                    we should before or at the start of the data field                    
                </comment>
                <comment line="431">
                    convert the name bytes into a String                    
                </comment>
                <comment line="434">
                    compute the size of the data item - this includes pad
                     characters used to align the next entry.                    
                </comment>
                <comment line="440">
                    set the position to the start of the data item                    
                </comment>
                <comment line="446">
                    create a scalar Monitor object                    
                </comment>
                <comment line="449">
                    limit buffer size to one long value.                    
                </comment>
                <comment line="453">
                    unexpected type code - coding error or uncoordinated
                     JVM change                    
                </comment>
                <comment line="465">
                    create a vector Monitor object                    
                </comment>
                <comment line="468">
                    only byte arrays of type STRING are currently supported                    
                </comment>
                <comment line="481">
                    limit buffer length to # of chars                    
                </comment>
                <comment line="490">
                    Monotonically increasing byte arrays are not supported                    
                </comment>
                <comment line="499">
                    variability was validated above, so this unexpected                    
                </comment>
                <comment line="503">
                    coding error or uncoordinated JVM change                    
                </comment>
                <comment line="514">
                    setup index to next entry for next iteration of the loop.                    
                </comment>
                <declaration name="monitor" type="Monitor" line="290"/>
                <scope line="293"/>
                <scope line="300"/>
                <scope line="308"/>
                <declaration name="entryStart" type="int" line="316"/>
                <declaration name="entryLength" type="int" line="317"/>
                <scope line="320"/>
                <scope line="327"/>
                <scope line="335"/>
                <declaration name="nameOffset" type="int" line="341"/>
                <declaration name="vectorLength" type="int" line="342"/>
                <declaration name="typeCodeByte" type="byte" line="343"/>
                <declaration name="flags" type="byte" line="344"/>
                <declaration name="unitsByte" type="byte" line="345"/>
                <declaration name="varByte" type="byte" line="346"/>
                <declaration name="dataOffset" type="int" line="347"/>
                <declaration name="units" type="Units" line="353"/>
                <declaration name="variability" type="Variability" line="354"/>
                <declaration name="typeCode" type="TypeCode" line="355"/>
                <declaration name="supported" type="boolean" line="356"/>
                <scope line="358"/>
                <scope line="361"/>
                <scope line="369"/>
                <scope line="377"/>
                <scope line="385"/>
                <scope line="392"/>
                <declaration name="maxNameLength" type="int" line="411"/>
                <declaration name="nameBytes" type="byte[]" line="418"/>
                <declaration name="nameLength" type="int" line="419"/>
                <declaration name="b" type="byte" line="420"/>
                <scope line="421"/>
                <declaration name="name" type="String" line="431"/>
                <declaration name="dataSize" type="int" line="437"/>
                <scope line="444">
                    <scope line="446">
                        <declaration name="lb" type="LongBuffer" line="447"/>
                    </scope>
                    <scope line="451"/>
                </scope>
                <scope line="463">
                    <scope line="465">
                        <scope line="466"/>
                        <declaration name="bb" type="ByteBuffer" line="479"/>
                        <scope line="482"/>
                        <scope line="485"/>
                        <scope line="488"/>
                        <scope line="497"/>
                    </scope>
                    <scope line="501"/>
                </scope>
            </method>
            <javadoc line="518">
                Method to dump debugging information                
            </javadoc>
            <method name="dumpAll" type="void" line="521">
                <params>
                    <param name="map" type="Map<String,Monitor>"/>
                    <param name="lvmid" type="int"/>
                </params>
                <scope line="522">
                    <declaration name="keys" type="Set&lt;String&gt;" line="523"/>
                    <declaration name="j" type="int" line="526"/>
                    <scope line="527">
                        <declaration name="monitor" type="Monitor" line="528"/>
                    </scope>
                </scope>
            </method>
            <javadoc line="538">
                Method to dump the fixed portion of an entry.                
            </javadoc>
            <method name="dump_entry_fixed" type="void" line="544">
                <params>
                    <param name="entry_start" type="int"/>
                    <param name="nameOffset" type="int"/>
                    <param name="vectorLength" type="int"/>
                    <param name="typeCodeByte" type="byte"/>
                    <param name="flags" type="byte"/>
                    <param name="unitsByte" type="byte"/>
                    <param name="varByte" type="byte"/>
                    <param name="dataOffset" type="int"/>
                </params>
                <scope line="545"/>
            </method>
            <method name="dump_entry_variable" type="void" line="565">
                <params>
                    <param name="name" type="String"/>
                    <param name="bb" type="ByteBuffer"/>
                    <param name="size" type="int"/>
                </params>
                <scope line="566">
                    <declaration name="toHex" type="char[]" line="567"/>
                    <declaration name="data" type="ByteBuffer" line="572"/>
                    <declaration name="count" type="int" line="578"/>
                    <scope line="579">
                        <declaration name="b" type="byte" line="580"/>
                        <declaration name="high" type="byte" line="581"/>
                        <declaration name="low" type="byte" line="582"/>
                        <scope line="584"/>
                        <scope line="593"/>
                        <scope line="595"/>
                    </scope>
                    <scope line="599"/>
                </scope>
            </method>
            <method name="logln" type="void" line="605">
                <params>
                    <param name="s" type="String"/>
                </params>
                <scope line="606"/>
            </method>
            <method name="log" type="void" line="611">
                <params>
                    <param name="s" type="String"/>
                </params>
                <scope line="612"/>
            </method>
        </class>
    </source>