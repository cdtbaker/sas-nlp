<?xml version="1.0" encoding="UTF-8"?>
    <source package="sun.jvmstat.perfdata.monitor.v1_0">
        <import package="sun.jvmstat.monitor"/>
        <import package="sun.jvmstat.perfdata.monitor"/>
        <import package="java.util"/>
        <import package="java.util.regex"/>
        <import package="java.nio"/>
        <class name="PerfDataBuffer" line="34">
            <extends class="PerfDataBufferImpl"/>
            <comment line="53">
                the following constants must be kept in sync with struct
                 PerfDataEntry in perfMemory.hpp                
            </comment>
            <comment line="58">
                sizeof(int)                
            </comment>
            <comment line="60">
                sizeof(int)                
            </comment>
            <comment line="62">
                sizeof(int)                
            </comment>
            <comment line="64">
                sizeof(byte)                
            </comment>
            <comment line="66">
                sizeof(byte)                
            </comment>
            <comment line="68">
                sizeof(byte)                
            </comment>
            <comment line="70">
                sizeof(byte)                
            </comment>
            <javadoc line="34">
                The concrete implementation of version 1.0 of the HotSpot PerfData
                  Instrumentation buffer. This class is responsible for parsing the
                  instrumentation memory and constructing the necessary objects to
                  represent and access the instrumentation objects contained in the
                  memory buffer.                
                <author>
                    Brian Doherty                    
                </author>
                <since>
                    1.5                    
                </since>
                <see>
                    AbstractPerfDataBuffer                    
                </see>
            </javadoc>
            <declaration name="DEBUG" type="boolean" line="47"/>
            <declaration name="syncWaitMs" type="int" line="48"/>
            <declaration name="EMPTY_LIST" type="ArrayList" line="50"/>
            <declaration name="PERFDATA_ENTRYLENGTH_OFFSET" type="int" line="56"/>
            <declaration name="PERFDATA_ENTRYLENGTH_SIZE" type="int" line="57"/>
            <declaration name="PERFDATA_NAMELENGTH_OFFSET" type="int" line="58"/>
            <declaration name="PERFDATA_NAMELENGTH_SIZE" type="int" line="59"/>
            <declaration name="PERFDATA_VECTORLENGTH_OFFSET" type="int" line="60"/>
            <declaration name="PERFDATA_VECTORLENGTH_SIZE" type="int" line="61"/>
            <declaration name="PERFDATA_DATATYPE_OFFSET" type="int" line="62"/>
            <declaration name="PERFDATA_DATATYPE_SIZE" type="int" line="63"/>
            <declaration name="PERFDATA_FLAGS_OFFSET" type="int" line="64"/>
            <declaration name="PERFDATA_FLAGS_SIZE" type="int" line="65"/>
            <declaration name="PERFDATA_DATAUNITS_OFFSET" type="int" line="66"/>
            <declaration name="PERFDATA_DATAUNITS_SIZE" type="int" line="67"/>
            <declaration name="PERFDATA_DATAATTR_OFFSET" type="int" line="68"/>
            <declaration name="PERFDATA_DATAATTR_SIZE" type="int" line="69"/>
            <declaration name="PERFDATA_NAME_OFFSET" type="int" line="70"/>
            <declaration name="prologue" type="PerfDataBufferPrologue" line="72"/>
            <declaration name="nextEntry" type="int" line="73"/>
            <declaration name="pollForEntry" type="int" line="74"/>
            <declaration name="perfDataItem" type="int" line="75"/>
            <declaration name="lastModificationTime" type="long" line="76"/>
            <declaration name="lastUsed" type="int" line="77"/>
            <declaration name="overflow" type="IntegerMonitor" line="78"/>
            <declaration name="insertedMonitors" type="ArrayList&lt;Monitor&gt;" line="79"/>
            <javadoc line="81">
                Construct a PerfDataBufferImpl instance.
                  &lt;p&gt;
                  This class is dynamically loaded by{@link AbstractPerfDataBuffer#createPerfDataBuffer}, and this
                  constructor is called to instantiate the instance.                
                <param>
                    buffer the buffer containing the instrumentation data                    
                </param>
                <param>
                    lvmid the Local Java Virtual Machine Identifier for this
                      instrumentation buffer.                    
                </param>
            </javadoc>
            <method name="PerfDataBuffer" type="constructor" line="93">
                <params>
                    <param name="buffer" type="ByteBuffer"/>
                    <param name="lvmid" type="int"/>
                </params>
            </method>
            <javadoc line="99">
                {@inheritDoc}                
            </javadoc>
            <method name="buildMonitorMap" type="void" line="102">
                <params>
                    <param name="map" type="Map<String,Monitor>"/>
                </params>
                <comment line="106">
                    start at the beginning of the buffer                    
                </comment>
                <comment line="109">
                    create pseudo monitors                    
                </comment>
                <comment line="112">
                    position buffer to start of the data section                    
                </comment>
                <comment line="126">
                    set the last modification data. These are set to the values
                     recorded before parsing the data structure. This allows the
                     the data structure to be modified while the Map is being built.
                     The Map may contain more entries than indicated based on the
                     time stamp, but this is handled by ignoring duplicate entries
                     when the Map is updated in getNewMonitors().                    
                </comment>
                <comment line="137">
                    synchronize with the target jvm                    
                </comment>
                <comment line="140">
                    work around 1.4.2 counter inititization bugs                    
                </comment>
                <declaration name="used" type="int" line="116"/>
                <declaration name="modificationTime" type="long" line="117"/>
                <declaration name="m" type="Monitor" line="119"/>
                <scope line="120"/>
            </method>
            <javadoc line="145">
                {@inheritDoc}                
            </javadoc>
            <method name="getNewMonitors" type="void" line="148">
                <params>
                    <param name="map" type="Map<String,Monitor>"/>
                </params>
                <comment line="164">
                    guard against duplicate entries                    
                </comment>
                <comment line="168">
                    insertedMonitors is null when called from pollFor()
                     via buildMonitorMap(). Since we update insertedMonitors
                     at the end of buildMonitorMap(), it&apos;s ok to skip the
                     add here.                    
                </comment>
                <declaration name="used" type="int" line="151"/>
                <declaration name="modificationTime" type="long" line="152"/>
                <scope line="154">
                    <declaration name="monitor" type="Monitor" line="159"/>
                    <scope line="160">
                        <declaration name="name" type="String" line="161"/>
                        <scope line="164">
                            <scope line="173"/>
                        </scope>
                    </scope>
                </scope>
            </method>
            <javadoc line="182">
                {@inheritDoc}                
            </javadoc>
            <method name="getMonitorStatus" type="MonitorStatus" line="185">
                <params>
                    <param name="map" type="Map<String,Monitor>"/>
                </params>
                <comment line="190">
                    load any new monitors                    
                </comment>
                <comment line="193">
                    current implementation doesn&apos;t support deletion or reuse of entries                    
                </comment>
                <declaration name="removed" type="ArrayList" line="193"/>
                <declaration name="inserted" type="ArrayList" line="194"/>
            </method>
            <javadoc line="200">
                Build the pseudo monitors used to map the prolog data into counters.                
            </javadoc>
            <method name="buildPseudoMonitors" type="void" line="203">
                <params>
                    <param name="map" type="Map<String,Monitor>"/>
                </params>
                <declaration name="monitor" type="Monitor" line="204"/>
                <declaration name="name" type="String" line="205"/>
                <declaration name="ib" type="IntBuffer" line="206"/>
                <declaration name="lb" type="LongBuffer" line="240"/>
            </method>
            <javadoc line="246">
                Method to provide a gross level of synchronization with the
                  target monitored jvm.
                  gross synchronization works by polling for the hotspot.rt.hrt.ticks
                  counter, which is the last counter created by the StatSampler
                  initialization code. The counter is updated when the watcher thread
                  starts scheduling tasks, which is the last thing done in vm
                  initialization.                
            </javadoc>
            <method name="synchWithTarget" type="void" line="256">
                <params>
                    <param name="map" type="Map<String,Monitor>"/>
                </params>
                <comment line="258">
                    synch must happen with syncWaitMs from now. Default is 5 seconds,
                     which is reasonabally generous and should provide for extreme
                     situations like startup delays due to allocation of large ISM heaps.                    
                </comment>
                <comment line="268">
                    loop waiting for the ticks counter to be non zero. This is
                     an indication that the jvm is initialized.                    
                </comment>
                <declaration name="timeLimit" type="long" line="262"/>
                <declaration name="name" type="String" line="264"/>
                <declaration name="ticks" type="LongMonitor" line="265"/>
                <scope line="272">
                    <scope line="275"/>
                    <scope line="275"/>
                    <scope line="277"/>
                </scope>
            </method>
            <javadoc line="285">
                Method to poll the instrumentation memory for a counter with
                  the given name. The polling period is bounded by the timeLimit
                  argument.                
            </javadoc>
            <method name="pollFor" type="Monitor" line="291">
                <params>
                    <param name="map" type="Map<String,Monitor>"/>
                    <param name="name" type="String"/>
                    <param name="timeLimit" type="long"/>
                </params>
                <declaration name="monitor" type="Monitor" line="292"/>
                <scope line="297">
                    <scope line="300"/>
                    <scope line="300"/>
                    <declaration name="t" type="long" line="302"/>
                    <scope line="303"/>
                </scope>
            </method>
            <javadoc line="315">
                method to make adjustments for known counter problems. This
                  method depends on the availability of certain counters, which
                  is generally guaranteed by the synchWithTarget() method.                
            </javadoc>
            <method name="kludge" type="void" line="320">
                <params>
                    <param name="map" type="Map<String,Monitor>"/>
                </params>
                <comment line="323">
                    bypass all kludges                    
                </comment>
                <scope line="321"/>
                <declaration name="name" type="String" line="326"/>
                <declaration name="jvm_version" type="StringMonitor" line="327"/>
                <scope line="328"/>
                <declaration name="jvm_name" type="StringMonitor" line="333"/>
                <scope line="334"/>
                <declaration name="args" type="StringMonitor" line="339"/>
                <scope line="340"/>
                <scope line="346">
                    <scope line="347"/>
                </scope>
            </method>
            <javadoc line="353">
                method to repair the 1.4.2 parallel scavenge counters that are
                  incorrectly initialized by the JVM when UseAdaptiveSizePolicy
                  is set. This bug couldn&apos;t be fixed for 1.4.2 FCS due to putback
                  restrictions.                
            </javadoc>
            <method name="kludgeMantis" type="void" line="359">
                <params>
                    <param name="map" type="Map<String,Monitor>"/>
                    <param name="args" type="StringMonitor"/>
                </params>
                <comment line="361">
                    the HotSpot 1.4.2 JVM with the +UseParallelGC option along
                     with its default +UseAdaptiveSizePolicy option has a bug with
                     the initialization of the sizes of the eden and survivor spaces.
                     See bugid 4890736.
                    
                     note - use explicit 1.4.2 counter names here - don&apos;t update
                     to latest counter names or attempt to find aliases.                    
                </comment>
                <comment line="377">
                    HotSpot processes the -XX:Flags.hotspotrc arguments prior to
                     processing the command line arguments. This allows the command
                     line arguments to override any defaults set in .hotspotrc                    
                </comment>
                <comment line="386">
                    ignore the -XX: prefix as it only applies to the arguments
                     passed from the command line (i.e. the invocation api).
                     arguments passed through .hotspotrc omit the -XX: prefix.                    
                </comment>
                <comment line="395">
                    +AggressiveHeap was set, check if -UseAdaptiveSizePolicy
                     is set after +AggressiveHeap.                    
                </comment>
                <comment line="399">
                                        
                </comment>
                <comment line="404">
                    +AggressiveHeap not set, must be +UseParallelGC. The
                     relative position of -UseAdaptiveSizePolicy is not
                     important in this case, as it will override the
                     UseParallelGC default (+UseAdaptiveSizePolicy) if it
                     appears anywhere in the JVM arguments.                    
                </comment>
                <comment line="417">
                    adjust the buggy AdaptiveSizePolicy size counters.                    
                </comment>
                <comment line="419">
                    first remove the real counters.                    
                </comment>
                <comment line="427">
                    get the maximum new generation size                    
                </comment>
                <comment line="431">
                    replace the real counters with pseudo counters that are
                     initialized to to the correct values. The maximum size of
                     the eden and survivor spaces are supposed to be:
                        max_eden_size = new_size - (2alignment).
                        max_survivor_size = new_size - (2alignment).
                     since we don&apos;t know the alignment value used, and because
                     of other parallel scavenge bugs that result in oversized
                     spaces, we just set the maximum size of each space to the
                     full new gen size.                    
                </comment>
                <declaration name="cname" type="String" line="370"/>
                <declaration name="collector" type="StringMonitor" line="371"/>
                <scope line="373">
                    <declaration name="adaptiveSizePolicy" type="boolean" line="374"/>
                    <declaration name="flags" type="StringMonitor" line="382"/>
                    <declaration name="allArgs" type="String" line="383"/>
                    <declaration name="ahi" type="int" line="390"/>
                    <declaration name="aspi" type="int" line="391"/>
                    <scope line="393">
                        <scope line="399"/>
                    </scope>
                    <scope line="402">
                        <scope line="410"/>
                    </scope>
                    <scope line="415">
                        <declaration name="eden_size" type="String" line="419"/>
                        <declaration name="s0_size" type="String" line="420"/>
                        <declaration name="s1_size" type="String" line="421"/>
                        <declaration name="new_max_name" type="String" line="427"/>
                        <declaration name="new_max" type="LongMonitor" line="428"/>
                        <declaration name="monitor" type="Monitor" line="441"/>
                        <declaration name="lb" type="LongBuffer" line="443"/>
                    </scope>
                </scope>
            </method>
            <javadoc line="460">
                method to extract the next monitor entry from the instrumentation memory.
                  assumes that nextEntry is the offset into the byte array
                  at which to start the search for the next entry. method leaves
                  next entry pointing to the next entry or to the end of data.                
            </javadoc>
            <method name="getNextMonitorEntry" type="Monitor" line="466">
                <comment line="470">
                    entries are always 4 byte aligned.                    
                </comment>
                <comment line="476">
                    protect against a corrupted shared memory region.                    
                </comment>
                <comment line="483">
                    check for the end of the buffer                    
                </comment>
                <comment line="495">
                    check for valid entry length                    
                </comment>
                <comment line="501">
                    check if last entry occurs before the eof.                    
                </comment>
                <comment line="511">
                    end of data                    
                </comment>
                <comment line="523">
                    defend against corrupt entries                    
                </comment>
                <comment line="534">
                    read in the perfData item name, casting bytes to chars. skip the
                     null terminator                    
                </comment>
                <comment line="542">
                    convert name into a String                    
                </comment>
                <comment line="558">
                    scalar Types                    
                </comment>
                <comment line="560">
                                        
                </comment>
                <comment line="567">
                    bad data types.                    
                </comment>
                <comment line="574">
                    vector types                    
                </comment>
                <comment line="577">
                    only byte arrays of type STRING are currently supported                    
                </comment>
                <comment line="597">
                    Monotonically increasing byte arrays are not supported                    
                </comment>
                <comment line="606">
                    bad data types.                    
                </comment>
                <comment line="614">
                    setup index to next entry for next iteration of the loop.                    
                </comment>
                <declaration name="monitor" type="Monitor" line="467"/>
                <scope line="470"/>
                <scope line="476"/>
                <scope line="483"/>
                <declaration name="entryStart" type="int" line="491"/>
                <declaration name="entryLength" type="int" line="492"/>
                <scope line="495"/>
                <scope line="501"/>
                <scope line="509"/>
                <declaration name="nameLength" type="int" line="514"/>
                <declaration name="vectorLength" type="int" line="515"/>
                <declaration name="dataType" type="byte" line="516"/>
                <declaration name="flags" type="byte" line="517"/>
                <declaration name="u" type="Units" line="518"/>
                <declaration name="v" type="Variability" line="519"/>
                <declaration name="supported" type="boolean" line="520"/>
                <scope line="523"/>
                <scope line="528"/>
                <declaration name="nameBytes" type="byte[]" line="536"/>
                <scope line="537"/>
                <declaration name="name" type="String" line="542"/>
                <scope line="544"/>
                <scope line="549"/>
                <declaration name="offset" type="int" line="555"/>
                <scope line="556">
                    <scope line="558">
                        <declaration name="lb" type="LongBuffer" line="561"/>
                    </scope>
                    <scope line="565"/>
                </scope>
                <scope line="572">
                    <scope line="574">
                        <scope line="575"/>
                        <declaration name="bb" type="ByteBuffer" line="585"/>
                        <scope line="589"/>
                        <scope line="592"/>
                        <scope line="595"/>
                    </scope>
                    <scope line="604"/>
                </scope>
            </method>
            <javadoc line="618">
                Method to dump debugging information                
            </javadoc>
            <method name="dumpAll" type="void" line="621">
                <params>
                    <param name="map" type="Map"/>
                    <param name="lvmid" type="int"/>
                </params>
                <scope line="622">
                    <declaration name="keys" type="Set" line="623"/>
                    <declaration name="j" type="int" line="626"/>
                    <scope line="627">
                        <declaration name="monitor" type="Monitor" line="628"/>
                    </scope>
                </scope>
            </method>
            <method name="lognl" type="void" line="639">
                <params>
                    <param name="s" type="String"/>
                </params>
                <scope line="640"/>
            </method>
            <method name="log" type="void" line="645">
                <params>
                    <param name="s" type="String"/>
                </params>
                <scope line="646"/>
            </method>
        </class>
    </source>