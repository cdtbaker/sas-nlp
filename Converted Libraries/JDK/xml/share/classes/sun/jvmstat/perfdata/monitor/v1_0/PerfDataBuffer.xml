<?xml version="1.0" encoding="UTF-8"?>
    <source package="sun.jvmstat.perfdata.monitor.v1_0">
        <import package="sun.jvmstat.monitor"/>
        <import package="sun.jvmstat.perfdata.monitor"/>
        <import package="java.util"/>
        <import package="java.util.regex"/>
        <import package="java.nio"/>
        <class name="PerfDataBuffer" line="7">
            <extends class="PerfDataBufferImpl"/>
            <javadoc line="7">
                The concrete implementation of version 1.0 of the HotSpot PerfData
                  Instrumentation buffer. This class is responsible for parsing the
                  instrumentation memory and constructing the necessary objects to
                  represent and access the instrumentation objects contained in the
                  memory buffer.                
                <author>
                    Brian Doherty                    
                </author>
                <since>
                    1.5                    
                </since>
                <see>
                    AbstractPerfDataBuffer                    
                </see>
            </javadoc>
            <declaration name="DEBUG" type="boolean" line="18"/>
            <declaration name="syncWaitMs" type="int" line="19"/>
            <declaration name="EMPTY_LIST" type="ArrayList" line="20"/>
            <declaration name="PERFDATA_ENTRYLENGTH_OFFSET" type="int" line="21"/>
            <declaration name="PERFDATA_ENTRYLENGTH_SIZE" type="int" line="22"/>
            <declaration name="PERFDATA_NAMELENGTH_OFFSET" type="int" line="23"/>
            <declaration name="PERFDATA_NAMELENGTH_SIZE" type="int" line="24"/>
            <declaration name="PERFDATA_VECTORLENGTH_OFFSET" type="int" line="25"/>
            <declaration name="PERFDATA_VECTORLENGTH_SIZE" type="int" line="26"/>
            <declaration name="PERFDATA_DATATYPE_OFFSET" type="int" line="27"/>
            <declaration name="PERFDATA_DATATYPE_SIZE" type="int" line="28"/>
            <declaration name="PERFDATA_FLAGS_OFFSET" type="int" line="29"/>
            <declaration name="PERFDATA_FLAGS_SIZE" type="int" line="30"/>
            <declaration name="PERFDATA_DATAUNITS_OFFSET" type="int" line="31"/>
            <declaration name="PERFDATA_DATAUNITS_SIZE" type="int" line="32"/>
            <declaration name="PERFDATA_DATAATTR_OFFSET" type="int" line="33"/>
            <declaration name="PERFDATA_DATAATTR_SIZE" type="int" line="34"/>
            <declaration name="PERFDATA_NAME_OFFSET" type="int" line="35"/>
            <declaration name="prologue" type="PerfDataBufferPrologue" line="36"/>
            <declaration name="nextEntry" type="int" line="37"/>
            <declaration name="pollForEntry" type="int" line="38"/>
            <declaration name="perfDataItem" type="int" line="39"/>
            <declaration name="lastModificationTime" type="long" line="40"/>
            <declaration name="lastUsed" type="int" line="41"/>
            <declaration name="overflow" type="IntegerMonitor" line="42"/>
            <declaration name="insertedMonitors" type="ArrayList&lt;Monitor&gt;" line="43"/>
            <javadoc line="44">
                Construct a PerfDataBufferImpl instance.
                  &lt;p&gt;
                  This class is dynamically loaded by{@link AbstractPerfDataBuffer#createPerfDataBuffer}, and this
                  constructor is called to instantiate the instance.                
                <param>
                    buffer the buffer containing the instrumentation data                    
                </param>
                <param>
                    lvmid the Local Java Virtual Machine Identifier for this
                      instrumentation buffer.                    
                </param>
            </javadoc>
            <method name="PerfDataBuffer" type="constructor" line="53">
                <params>
                    <param name="buffer" type="ByteBuffer"/>
                    <param name="lvmid" type="int"/>
                </params>
            </method>
            <javadoc line="58">
                {@inheritDoc}                
            </javadoc>
            <method name="buildMonitorMap" type="void" line="61">
                <params>
                    <param name="map" type="Map<String,Monitor>"/>
                </params>
            </method>
            <javadoc line="81">
                {@inheritDoc}                
            </javadoc>
            <method name="getNewMonitors" type="void" line="84">
                <params>
                    <param name="map" type="Map<String,Monitor>"/>
                </params>
            </method>
            <javadoc line="104">
                {@inheritDoc}                
            </javadoc>
            <method name="getMonitorStatus" type="MonitorStatus" line="107">
                <params>
                    <param name="map" type="Map<String,Monitor>"/>
                </params>
            </method>
            <javadoc line="116">
                Build the pseudo monitors used to map the prolog data into counters.                
            </javadoc>
            <method name="buildPseudoMonitors" type="void" line="119">
                <params>
                    <param name="map" type="Map<String,Monitor>"/>
                </params>
                <declaration name="monitor" type="Monitor" line="120"/>
                <declaration name="name" type="String" line="121"/>
                <declaration name="ib" type="IntBuffer" line="122"/>
                <declaration name="lb" type="LongBuffer" line="145"/>
            </method>
            <javadoc line="149">
                Method to provide a gross level of synchronization with the
                  target monitored jvm.
                  gross synchronization works by polling for the hotspot.rt.hrt.ticks
                  counter, which is the last counter created by the StatSampler
                  initialization code. The counter is updated when the watcher thread
                  starts scheduling tasks, which is the last thing done in vm
                  initialization.                
            </javadoc>
            <method name="synchWithTarget" type="void" line="158">
                <params>
                    <param name="map" type="Map<String,Monitor>"/>
                </params>
                <declaration name="timeLimit" type="long" line="159"/>
                <declaration name="name" type="String" line="160"/>
                <declaration name="ticks" type="LongMonitor" line="161"/>
                <scope line="163">
                    <scope line="165"/>
                    <scope line="168"/>
                    <scope line="170"/>
                </scope>
            </method>
            <javadoc line="177">
                Method to poll the instrumentation memory for a counter with
                  the given name. The polling period is bounded by the timeLimit
                  argument.                
            </javadoc>
            <method name="pollFor" type="Monitor" line="182">
                <params>
                    <param name="map" type="Map<String,Monitor>"/>
                    <param name="name" type="String"/>
                    <param name="timeLimit" type="long"/>
                </params>
                <declaration name="monitor" type="Monitor" line="183"/>
                <scope line="186">
                    <scope line="188"/>
                    <scope line="191"/>
                    <declaration name="t" type="long" line="193"/>
                    <scope line="194"/>
                </scope>
            </method>
            <javadoc line="204">
                method to make adjustments for known counter problems. This
                  method depends on the availability of certain counters, which
                  is generally guaranteed by the synchWithTarget() method.                
            </javadoc>
            <method name="kludge" type="void" line="209">
                <params>
                    <param name="map" type="Map<String,Monitor>"/>
                </params>
                <scope line="210"/>
                <declaration name="name" type="String" line="213"/>
                <declaration name="jvm_version" type="StringMonitor" line="214"/>
                <scope line="215"/>
                <declaration name="jvm_name" type="StringMonitor" line="219"/>
                <scope line="220"/>
                <declaration name="args" type="StringMonitor" line="224"/>
                <scope line="225"/>
                <scope line="229">
                    <scope line="230"/>
                </scope>
            </method>
            <javadoc line="235">
                method to repair the 1.4.2 parallel scavenge counters that are
                  incorrectly initialized by the JVM when UseAdaptiveSizePolicy
                  is set. This bug couldn&apos;t be fixed for 1.4.2 FCS due to putback
                  restrictions.                
            </javadoc>
            <method name="kludgeMantis" type="void" line="241">
                <params>
                    <param name="map" type="Map<String,Monitor>"/>
                    <param name="args" type="StringMonitor"/>
                </params>
                <declaration name="cname" type="String" line="242"/>
                <declaration name="collector" type="StringMonitor" line="243"/>
                <scope line="244">
                    <declaration name="adaptiveSizePolicy" type="boolean" line="245"/>
                    <declaration name="flags" type="StringMonitor" line="247"/>
                    <declaration name="allArgs" type="String" line="248"/>
                    <declaration name="ahi" type="int" line="249"/>
                    <declaration name="aspi" type="int" line="250"/>
                    <scope line="251">
                        <scope line="252"/>
                    </scope>
                    <scope line="256">
                        <scope line="257"/>
                    </scope>
                    <scope line="261">
                        <declaration name="eden_size" type="String" line="262"/>
                        <declaration name="s0_size" type="String" line="263"/>
                        <declaration name="s1_size" type="String" line="264"/>
                        <declaration name="new_max_name" type="String" line="268"/>
                        <declaration name="new_max" type="LongMonitor" line="269"/>
                        <declaration name="monitor" type="Monitor" line="270"/>
                        <declaration name="lb" type="LongBuffer" line="271"/>
                    </scope>
                </scope>
            </method>
            <javadoc line="282">
                method to extract the next monitor entry from the instrumentation memory.
                  assumes that nextEntry is the offset into the byte array
                  at which to start the search for the next entry. method leaves
                  next entry pointing to the next entry or to the end of data.                
            </javadoc>
            <method name="getNextMonitorEntry" type="Monitor" line="288">
                <declaration name="monitor" type="Monitor" line="289"/>
                <scope line="290"/>
                <scope line="293"/>
                <scope line="296"/>
                <declaration name="entryStart" type="int" line="301"/>
                <declaration name="entryLength" type="int" line="302"/>
                <scope line="303"/>
                <scope line="306"/>
                <scope line="309"/>
                <declaration name="nameLength" type="int" line="312"/>
                <declaration name="vectorLength" type="int" line="313"/>
                <declaration name="dataType" type="byte" line="314"/>
                <declaration name="flags" type="byte" line="315"/>
                <declaration name="u" type="Units" line="316"/>
                <declaration name="v" type="Variability" line="317"/>
                <declaration name="supported" type="boolean" line="318"/>
                <scope line="319"/>
                <scope line="322"/>
                <declaration name="nameBytes" type="byte[]" line="325"/>
                <scope line="326"/>
                <declaration name="name" type="String" line="329"/>
                <scope line="330"/>
                <scope line="333"/>
                <declaration name="offset" type="int" line="336"/>
                <scope line="337">
                    <scope line="338">
                        <declaration name="lb" type="LongBuffer" line="341"/>
                    </scope>
                    <scope line="346"/>
                </scope>
                <scope line="350">
                    <scope line="351">
                        <scope line="352"/>
                        <declaration name="bb" type="ByteBuffer" line="357"/>
                        <scope line="360"/>
                        <scope line="363"/>
                        <scope line="366"/>
                    </scope>
                    <scope line="371"/>
                </scope>
            </method>
            <javadoc line="378">
                Method to dump debugging information                
            </javadoc>
            <method name="dumpAll" type="void" line="381">
                <params>
                    <param name="map" type="Map"/>
                    <param name="lvmid" type="int"/>
                </params>
                <scope line="382">
                    <declaration name="keys" type="Set" line="383"/>
                    <declaration name="j" type="int" line="385"/>
                    <scope line="386">
                        <declaration name="monitor" type="Monitor" line="387"/>
                    </scope>
                </scope>
            </method>
            <method name="lognl" type="void" line="395">
                <params>
                    <param name="s" type="String"/>
                </params>
                <scope line="396"/>
            </method>
            <method name="log" type="void" line="400">
                <params>
                    <param name="s" type="String"/>
                </params>
                <scope line="401"/>
            </method>
        </class>
    </source>