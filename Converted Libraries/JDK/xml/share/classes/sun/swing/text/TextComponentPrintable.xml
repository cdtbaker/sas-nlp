<?xml version="1.0" encoding="UTF-8"?>
    <source package="sun.swing.text">
        <import package="java.awt.ComponentOrientation"/>
        <import package="java.awt.Dimension"/>
        <import package="java.awt.Font"/>
        <import package="java.awt.FontMetrics"/>
        <import package="java.awt.Graphics"/>
        <import package="java.awt.Graphics2D"/>
        <import package="java.awt.Insets"/>
        <import package="java.awt.Rectangle"/>
        <import package="java.awt.Component"/>
        <import package="java.awt.Container"/>
        <import package="java.awt.font.FontRenderContext"/>
        <import package="java.awt.print.PageFormat"/>
        <import package="java.awt.print.Printable"/>
        <import package="java.awt.print.PrinterException"/>
        <import package="java.text.MessageFormat"/>
        <import package="java.util.ArrayList"/>
        <import package="java.util.Collections"/>
        <import package="java.util.List"/>
        <import package="java.util.concurrent.Callable"/>
        <import package="java.util.concurrent.ExecutionException"/>
        <import package="java.util.concurrent.FutureTask"/>
        <import package="java.util.concurrent.atomic.AtomicReference"/>
        <import package="javax.swing.BorderFactory"/>
        <import package="javax.swing.CellRendererPane"/>
        <import package="javax.swing.JTextField"/>
        <import package="javax.swing.JTextArea"/>
        <import package="javax.swing.JEditorPane"/>
        <import package="javax.swing.JViewport"/>
        <import package="javax.swing.JScrollPane"/>
        <import package="javax.swing.JTextPane"/>
        <import package="javax.swing.SwingUtilities"/>
        <import package="javax.swing.border.Border"/>
        <import package="javax.swing.border.TitledBorder"/>
        <import package="javax.swing.text.BadLocationException"/>
        <import package="javax.swing.text.JTextComponent"/>
        <import package="javax.swing.text.Document"/>
        <import package="javax.swing.text.EditorKit"/>
        <import package="javax.swing.text.AbstractDocument"/>
        <import package="javax.swing.text.html.HTMLDocument"/>
        <import package="javax.swing.text.html.HTML"/>
        <import package="sun.font.FontDesignMetrics"/>
        <import package="sun.swing.text.html.FrameEditorPaneTag"/>
        <class name="TextComponentPrintable" line="44">
            <implements interface="CountingPrintable"/>
            <javadoc line="44">
                An implementation of {@code Printable} to print {@code JTextComponent} with
                  the header and footer.
                  &lt;h1&gt;
                  WARNING: this class is to be used in
                  javax.swing.text.JTextComponent only.
                  &lt;/h1&gt;
                  &lt;p&gt;
                  The implementation creates a new {@code JTextComponent} ({@code printShell})
                  to print the content using the {@code Document}, {@code EditorKit} and
                  rendering-affecting properties from the original {@code JTextComponent}.
                  &lt;p&gt;{@code printShell} is laid out on the first {@code print} invocation.
                  &lt;p&gt;
                  This class can be used on any thread. Part of the implementation is executed
                  on the EDT though.                
                <author>
                    Igor Kushnirskiy                    
                </author>
                <since>
                    1.6                    
                </since>
            </javadoc>
            <declaration name="LIST_SIZE" type="int" line="63"/>
            <declaration name="isLayouted" type="boolean" line="64"/>
            <declaration name="textComponentToPrint" type="JTextComponent" line="65"/>
            <declaration name="frc" type="AtomicReference&lt;FontRenderContext&gt;" line="66"/>
            <declaration name="printShell" type="JTextComponent" line="67"/>
            <javadoc line="67">
                Special text component used to print to the printer.                
            </javadoc>
            <declaration name="headerFormat" type="MessageFormat" line="71"/>
            <declaration name="footerFormat" type="MessageFormat" line="72"/>
            <declaration name="HEADER_FONT_SIZE" type="float" line="73"/>
            <declaration name="FOOTER_FONT_SIZE" type="float" line="74"/>
            <declaration name="headerFont" type="Font" line="75"/>
            <declaration name="footerFont" type="Font" line="76"/>
            <declaration name="rowsMetrics" type="List&lt;IntegerSegment&gt;" line="77"/>
            <javadoc line="77">
                stores metrics for the unhandled rows. The only metrics we need are
                  yStart and yEnd when row is handled by updatePagesMetrics it is removed
                  from the list. Thus the head of the list is the fist row to handle.
                  sorted                
            </javadoc>
            <declaration name="pagesMetrics" type="List&lt;IntegerSegment&gt;" line="84"/>
            <javadoc line="84">
                thread-safe list for storing pages metrics. The only metrics we need are
                  yStart and yEnd.
                  It has to be thread-safe since metrics are calculated on
                  the printing thread and accessed on the EDT thread.
                  sorted                
            </javadoc>
            <javadoc line="92">
                Returns {@code TextComponentPrintable} to print {@code textComponent}.                
                <param>
                    textComponent {@code JTextComponent} to print                    
                </param>
                <param>
                    headerFormat the page header, or {@code null} for none                    
                </param>
                <param>
                    footerFormat the page footer, or {@code null} for none                    
                </param>
                <return>
                    {@code TextComponentPrintable} to print {@code textComponent}                    
                </return>
            </javadoc>
            <method name="getPrintable" type="Printable" line="99">
                <params>
                    <param name="textComponent" type="JTextComponent"/>
                    <param name="headerFormat" type="MessageFormat"/>
                    <param name="footerFormat" type="MessageFormat"/>
                </params>
                <scope line="100">
                    <declaration name="frames" type="List&lt;JEditorPane&gt;" line="101"/>
                    <declaration name="printables" type="List&lt;CountingPrintable&gt;" line="102"/>
                    <scope line="103"/>
                </scope>
                <scope line="108"/>
            </method>
            <javadoc line="112">
                Checks whether the document has frames. Only HTMLDocument might
                  have frames.                
                <param>
                    document the {@code Document} to check                    
                </param>
                <return>
                    {@code true} if the {@code document} has frames                    
                </return>
            </javadoc>
            <method name="isFrameSetDocument" type="boolean" line="118">
                <params>
                    <param name="document" type="Document"/>
                </params>
                <declaration name="ret" type="boolean" line="119"/>
                <scope line="120">
                    <declaration name="htmlDocument" type="HTMLDocument" line="121"/>
                    <scope line="122"/>
                </scope>
            </method>
            <javadoc line="128">
                Returns frames under the {@code editor}.
                  The frames are created if necessary.                
                <param>
                    editor the {@JEditorPane} to find the frames for                    
                </param>
                <return>
                    list of all frames                    
                </return>
            </javadoc>
            <method name="getFrames" type="List<JEditorPane>" line="134">
                <params>
                    <param name="editor" type="JEditorPane"/>
                </params>
                <declaration name="list" type="List&lt;JEditorPane&gt;" line="135"/>
                <scope line="137"/>
            </method>
            <javadoc line="143">
                Adds all {@code JEditorPanes} under {@code container} tagged by {@codeFrameEditorPaneTag} to the {@code list}. It adds only top
                  level {@code JEditorPanes}.  For instance if there is a frame
                  inside the frame it will return the top frame only.                
                <param>
                    c the container to find all frames under                    
                </param>
                <param>
                    list {@code List} to append the results too                    
                </param>
            </javadoc>
            <method name="getFrames" type="void" line="150">
                <params>
                    <param name="container" type="Container"/>
                    <param name="list" type="List<JEditorPane>"/>
                </params>
                <scope line="151">
                    <scope line="152"/>
                    <scope line="155">
                        <scope line="156"/>
                    </scope>
                </scope>
            </method>
            <javadoc line="162">
                Triggers the frames creation for {@code JEditorPane}                
                <param>
                    editor the {@code JEditorPane} to create frames for                    
                </param>
            </javadoc>
            <method name="createFrames" type="void" line="166">
                <params>
                    <param name="editor" type="JEditorPane"/>
                </params>
                <anonymous_class line="167">
                    <method name="run" type="void" line="168">
                        <declaration name="WIDTH" type="int" line="169"/>
                        <declaration name="HEIGHT" type="int" line="170"/>
                        <declaration name="rendererPane" type="CellRendererPane" line="171"/>
                    </method>
                </anonymous_class>
                <declaration name="doCreateFrames" type="Runnable" line="167"/>
                <scope line="177"/>
                <scope line="180">
                    <scope line="181"/>
                    <scope line="184">
                        <scope line="185"/>
                        <scope line="188"/>
                    </scope>
                </scope>
            </method>
            <javadoc line="194">
                Constructs  {@code TextComponentPrintable} to print {@code JTextComponent}{@code textComponent} with {@code headerFormat} and {@code footerFormat}.                
                <param>
                    textComponent {@code JTextComponent} to print                    
                </param>
                <param>
                    headerFormat the page header or {@code null} for none                    
                </param>
                <param>
                    footerFormat the page footer or {@code null} for none                    
                </param>
            </javadoc>
            <method name="TextComponentPrintable" type="constructor" line="200">
                <params>
                    <param name="textComponent" type="JTextComponent"/>
                    <param name="headerFormat" type="MessageFormat"/>
                    <param name="footerFormat" type="MessageFormat"/>
                </params>
            </method>
            <javadoc line="210">
                creates a printShell.
                  It creates closest text component to {@code textComponent}which uses {@code frc} from the {@code TextComponentPrintable}for the {@code getFontMetrics} method.                
                <param>
                    textComponent {@code JTextComponent} to create a
                      printShell for                    
                </param>
                <return>
                    the print shell                    
                </return>
            </javadoc>
            <method name="createPrintShell" type="JTextComponent" line="217">
                <params>
                    <param name="textComponent" type="JTextComponent"/>
                </params>
                <scope line="218"/>
                <scope line="221">
                    <anonymous_class line="222">
                        <method name="call" type="JTextComponent" line="223"/>
                    </anonymous_class>
                    <declaration name="futureCreateShell" type="FutureTask&lt;JTextComponent&gt;" line="222"/>
                    <scope line="229"/>
                    <scope line="232"/>
                    <scope line="235">
                        <declaration name="cause" type="Throwable" line="236"/>
                        <scope line="237"/>
                        <scope line="240"/>
                    </scope>
                </scope>
            </method>
            <method name="createPrintShellOnEDT" type="JTextComponent" line="247">
                <params>
                    <param name="textComponent" type="JTextComponent"/>
                </params>
            </method>
            <javadoc line="323">
                Returns the number of pages in this printable.
                  &lt;p&gt;
                  This number is defined only after {@code print} returns NO_SUCH_PAGE.                
                <return>
                    the number of pages.                    
                </return>
            </javadoc>
            <method name="getNumberOfPages" type="int" line="329"/>
            <javadoc line="332">
                See Printable.print for the API description.
                  There are two parts in the implementation.
                  First part (print) is to be called on the printing thread.
                  Second part (printOnEDT) is to be called on the EDT only.
                  print triggers printOnEDT                
            </javadoc>
            <method name="print" type="int" line="339">
                <params>
                    <param name="graphics" type="Graphics"/>
                    <param name="pf" type="PageFormat"/>
                    <param name="pageIndex" type="int"/>
                </params>
                <scope line="340">
                    <scope line="341"/>
                </scope>
                <declaration name="ret" type="int" line="347"/>
                <scope line="348">
                    <anonymous_class line="349">
                        <method name="call" type="Integer" line="350"/>
                    </anonymous_class>
                    <declaration name="doPrintOnEDT" type="Callable&lt;Integer&gt;" line="349"/>
                    <declaration name="futurePrintOnEDT" type="FutureTask&lt;Integer&gt;" line="355"/>
                    <scope line="357"/>
                    <scope line="360"/>
                    <scope line="363">
                        <declaration name="cause" type="Throwable" line="364"/>
                        <scope line="365"/>
                        <scope line="368"/>
                        <scope line="371"/>
                        <scope line="374"/>
                    </scope>
                </scope>
                <scope line="379"/>
            </method>
            <javadoc line="384">
                The EDT part of the print method.
                  This method is to be called on the EDT only. Layout should be done before
                  calling this method.                
            </javadoc>
            <method name="printOnEDT" type="int" line="389">
                <params>
                    <param name="graphics" type="Graphics"/>
                    <param name="pf" type="PageFormat"/>
                    <param name="pageIndex" type="int"/>
                </params>
            </method>
            <declaration name="needReadLock" type="boolean" line="421"/>
            <javadoc line="422">
                Tries to release document&apos;s readlock
                  Note: Not to be called on the EDT.                
            </javadoc>
            <method name="releaseReadLock" type="void" line="426"/>
            <javadoc line="438">
                Tries to acquire document&apos;s readLock if it was released
                  in releaseReadLock() method.
                  Note: Not to be called on the EDT.                
            </javadoc>
            <method name="acquireReadLock" type="void" line="443"/>
            <javadoc line="462">
                Prepares {@code printShell} for printing.
                  Sets properties from the component to print.
                  Sets width and FontRenderContext.
                  Triggers Views creation for the printShell.
                  There are two parts in the implementation.
                  First part (layout) is to be called on the printing thread.
                  Second part (layoutOnEDT) is to be called on the EDT only.{@code layout} triggers {@code layoutOnEDT}.                
                <param>
                    width width to layout the text for                    
                </param>
            </javadoc>
            <method name="layout" type="void" line="472">
                <params>
                    <param name="width" type="int"/>
                </params>
                <scope line="473">
                    <anonymous_class line="474">
                        <method name="call" type="Object" line="475"/>
                    </anonymous_class>
                    <declaration name="doLayoutOnEDT" type="Callable&lt;Object&gt;" line="474"/>
                    <declaration name="futureLayoutOnEDT" type="FutureTask&lt;Object&gt;" line="481"/>
                    <scope line="484"/>
                    <scope line="487"/>
                    <scope line="490">
                        <declaration name="cause" type="Throwable" line="491"/>
                        <scope line="492"/>
                        <scope line="495"/>
                        <scope line="498"/>
                    </scope>
                    <scope line="502"/>
                </scope>
                <scope line="506"/>
            </method>
            <javadoc line="511">
                The EDT part of layout method.
                  This method is to be called on the EDT only.                
            </javadoc>
            <method name="layoutOnEDT" type="void" line="515">
                <params>
                    <param name="width" type="int"/>
                </params>
            </method>
            <javadoc line="531">
                Calculates pageMetrics for the pages up to the {@code pageIndex} using{@code rowsMetrics}.
                  Metrics are stored in the {@code pagesMetrics}.                
                <param>
                    pageIndex the page to update the metrics for                    
                </param>
                <param>
                    pageHeight the page height                    
                </param>
            </javadoc>
            <method name="updatePagesMetrics" type="void" line="537">
                <params>
                    <param name="pageIndex" type="int"/>
                    <param name="pageHeight" type="int"/>
                </params>
                <scope line="538">
                    <declaration name="lastPage" type="int" line="539"/>
                    <declaration name="pageStart" type="int" line="540"/>
                    <declaration name="rowIndex" type="int" line="541"/>
                    <scope line="542"/>
                    <scope line="544"/>
                    <scope line="547">
                        <scope line="550"/>
                    </scope>
                </scope>
            </method>
            <javadoc line="556">
                Calculates rowsMetrics for the document. The result is stored
                  in the {@code rowsMetrics}.
                  Two steps process.
                  First step is to find yStart and yEnd for the every document position.
                  Second step is to merge all intersected segments ( [yStart, yEnd] ).                
            </javadoc>
            <method name="calculateRowsMetrics" type="void" line="563"/>
            <class name="IntegerSegment" line="603">
                <implements interface="Comparable">
                    <type_params>
                        <type_param name="IntegerSegment"/>
                    </type_params>
                </implements>
                <javadoc line="603">
                    Class to represent segment of integers.
                      we do not call it Segment to avoid confusion with
                      javax.swing.text.Segment                    
                </javadoc>
                <declaration name="start" type="int" line="609"/>
                <declaration name="end" type="int" line="610"/>
                <method name="IntegerSegment" type="constructor" line="611">
                    <params>
                        <param name="start" type="int"/>
                        <param name="end" type="int"/>
                    </params>
                </method>
                <method name="compareTo" type="int" line="615">
                    <params>
                        <param name="object" type="IntegerSegment"/>
                    </params>
                    <declaration name="startsDelta" type="int" line="616"/>
                </method>
                <method name="equals" type="boolean" line="619">
                    <params>
                        <param name="obj" type="Object"/>
                    </params>
                    <scope line="620"/>
                    <scope line="623"/>
                </method>
                <method name="hashCode" type="int" line="627">
                    <declaration name="result" type="int" line="628"/>
                </method>
                <method name="toString" type="String" line="633"/>
            </class>
        </class>
    </source>