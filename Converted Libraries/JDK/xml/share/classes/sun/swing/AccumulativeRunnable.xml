<?xml version="1.0" encoding="UTF-8"?>
    <source package="sun.swing">
        <import package="java.util"/>
        <import package="java.lang.reflect.Array"/>
        <import package="javax.swing.SwingUtilities"/>
        <class name="AccumulativeRunnable" line="31">
            <type_params>
                <type_param name="T"/>
            </type_params>
            <implements interface="Runnable"/>
            <javadoc line="31">
                An abstract class to be used in the cases where we need {@code Runnable}to perform  some actions on an appendable set of data.
                  The set of data might be appended after the {@code Runnable} is
                  sent for the execution. Usually such {@code Runnables} are sent to
                  the EDT.
                  &lt;p&gt;
                  Usage example:
                  &lt;p&gt;
                  Say we want to implement JLabel.setText(String text) which sends{@code text} string to the JLabel.setTextImpl(String text) on the EDT.
                  In the event JLabel.setText is called rapidly many times off the EDT
                  we will get many updates on the EDT but only the last one is important.
                  (Every next updates overrides the previous one.)
                  We might want to implement this {@code setText} in a way that only
                  the last update is delivered.
                  &lt;p&gt;
                  Here is how one can do this using {@code AccumulativeRunnable}:
                  &lt;pre&gt;
                  AccumulativeRunnable&lt;String&gt; doSetTextImpl =
                  new  AccumulativeRunnable&lt;String&gt;() {                
                <Override>
                    protected void run(List&lt;String&gt; args) {
                      //set to the last string being passed
                      setTextImpl(args.get(args.size() - 1));
                      }
                      }
                      void setText(String text) {
                      //add text and send for the execution if needed.
                      doSetTextImpl.add(text);
                      }
                      </pre>
                      <p>
                      Say we want want to implement addDirtyRegion(Rectangle rect)
                      which sends this region to the
                      handleDirtyRegions(List<Rect> regiouns) on the EDT.
                      addDirtyRegions better be accumulated before handling on the EDT.
                      <p>
                      Here is how it can be implemented using AccumulativeRunnable:
                      <pre>
                      AccumulativeRunnable<Rectangle> doHandleDirtyRegions =
                      new AccumulativeRunnable<Rectangle>() {                    
                </Override>
                <Override>
                    protected void run(List&lt;Rectangle&gt; args) {
                      handleDirtyRegions(args);
                      }
                      };
                      void addDirtyRegion(Rectangle rect) {
                      doHandleDirtyRegions.add(rect);
                      }
                      </pre>                    
                </Override>
                <author>
                    Igor Kushnirskiy                    
                </author>
                <param>
                    <T>
                       the type this {@code Runnable} accumulates                    
                </param>
                <since>
                    1.6                    
                </since>
            </javadoc>
            <declaration name="arguments" type="List&lt;T&gt;" line="94"/>
            <method name="run" type="void" line="96"/>
            <javadoc line="96">
                Equivalent to {@code Runnable.run} method with the
                  accumulated arguments to process.                
                <param>
                    args accumulated argumets to process.                    
                </param>
            </javadoc>
            <javadoc line="104">
                {@inheritDoc}&lt;p&gt;
                  This implementation calls {@code run(List&lt;T&gt; args)} mehtod
                  with the list of accumulated arguments.                
            </javadoc>
            <method name="run" type="void" line="111"/>
            <javadoc line="115">
                appends arguments and sends this {@cod Runnable} for the
                  execution if needed.
                  &lt;p&gt;
                  This implementation uses {@see #submit} to send this{@code Runnable} for execution.                
                <param>
                    args the arguments to accumulate                    
                </param>
            </javadoc>
            <method name="add" type="void" line="124">
                <params>
                    <param name="args" type="T"/>
                </params>
                <declaration name="isSubmitted" type="boolean" line="125"/>
                <scope line="126"/>
                <scope line="131"/>
            </method>
            <javadoc line="136">
                Sends this {@code Runnable} for the execution
                  &lt;p&gt;
                  This method is to be executed only from {@code add} method.
                  &lt;p&gt;
                  This implementation uses {@code SwingWorker.invokeLater}.                
            </javadoc>
            <method name="submit" type="void" line="145"/>
            <javadoc line="149">
                Returns accumulated arguments and flashes the arguments storage.                
                <return>
                    accumulated arguments                    
                </return>
            </javadoc>
            <method name="flush" type="List<T>" line="154">
                <declaration name="list" type="List&lt;T&gt;" line="155"/>
            </method>
        </class>
    </source>