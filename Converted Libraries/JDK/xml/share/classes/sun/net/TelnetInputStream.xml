<?xml version="1.0" encoding="UTF-8"?>
    <source package="sun.net">
        <import package="java.io"/>
        <class name="TelnetInputStream" line="3">
            <extends class="FilterInputStream"/>
            <javadoc line="3">
                This class provides input and output streams for telnet clients.
                  This class overrides read to do CRLF processing as specified in
                  RFC 854. The class assumes it is running on a system where lines
                  are terminated with a single newline &lt;LF&gt; character.
                  This is the relevant section of RFC 824 regarding CRLF processing:
                  &lt;pre&gt;
                  The sequence &quot;CR LF&quot;, as defined, will cause the NVT to be
                  positioned at the left margin of the next print line (as would,
                  for example, the sequence &quot;LF CR&quot;).  However, many systems and
                  terminals do not treat CR and LF independently, and will have to
                  go to some effort to simulate their effect.  (For example, some
                  terminals do not have a CR independent of the LF, but on such
                  terminals it may be possible to simulate a CR by backspacing.)
                  Therefore, the sequence &quot;CR LF&quot; must be treated as a single &quot;new
                  line&quot; character and used whenever their combined action is
                  intended; the sequence &quot;CR NUL&quot; must be used where a carriage
                  return alone is actually desired; and the CR character must be
                  avoided in other contexts.  This rule gives assurance to systems
                  which must decide whether to perform a &quot;new line&quot; function or a
                  multiple-backspace that the TELNET stream contains a character
                  following a CR that will allow a rational decision.
                  Note that &quot;CR LF&quot; or &quot;CR NUL&quot; is required in both directions
                  (in the default ASCII mode), to preserve the symmetry of the
                  NVT model.  Even though it may be known in some situations
                  (e.g., with remote echo and suppress go ahead options in
                  effect) that characters are not being sent to an actual
                  printer, nonetheless, for the sake of consistency, the protocol
                  requires that a NUL be inserted following a CR not followed by
                  a LF in the data stream.  The converse of this is that a NUL
                  received in the data stream after a CR (in the absence of
                  options negotiations which explicitly specify otherwise) should
                  be stripped out prior to applying the NVT to local character
                  set mapping.
                  &lt;/pre&gt;                
                <author>
                    Jonathan Payne                    
                </author>
            </javadoc>
            <declaration name="stickyCRLF" type="boolean" line="41"/>
            <javadoc line="41">
                If stickyCRLF is true, then we&apos;re a machine, like an IBM PC,
                  where a Newline is a CR followed by LF.  On UNIX, this is false
                  because Newline is represented with just a LF character.                
            </javadoc>
            <declaration name="seenCR" type="boolean" line="47"/>
            <declaration name="binaryMode" type="boolean" line="48"/>
            <method name="TelnetInputStream" type="constructor" line="49">
                <params>
                    <param name="fd" type="InputStream"/>
                    <param name="binary" type="boolean"/>
                </params>
            </method>
            <method name="setStickyCRLF" type="void" line="53">
                <params>
                    <param name="on" type="boolean"/>
                </params>
            </method>
            <method name="read" type="int" line="56">
                <declaration name="c" type="int" line="58"/>
                <scope line="59"/>
                <scope line="63">
                    <scope line="71"/>
                    <scope line="75"/>
                </scope>
            </method>
            <javadoc line="82">
                read into a byte array                
            </javadoc>
            <method name="read" type="int" line="85">
                <params>
                    <param name="bytes" type="byte"/>
                </params>
            </method>
            <javadoc line="88">
                Read into a byte array at offset &lt;i&gt;off&lt;/i&gt; for length &lt;i&gt;length&lt;/i&gt;
                  bytes.                
            </javadoc>
            <method name="read" type="int" line="92">
                <params>
                    <param name="bytes" type="byte"/>
                    <param name="off" type="int"/>
                    <param name="length" type="int"/>
                </params>
                <declaration name="c" type="int" line="94"/>
                <declaration name="offStart" type="int" line="95"/>
                <scope line="96"/>
            </method>
        </class>
    </source>