<?xml version="1.0" encoding="UTF-8"?>
    <source package="sun.net.httpserver">
        <import package="java.net"/>
        <import package="java.nio"/>
        <import package="java.io"/>
        <import package="java.nio.channels"/>
        <import package="java.util"/>
        <import package="java.util.concurrent"/>
        <import package="java.util.concurrent.locks"/>
        <import package="javax.net.ssl"/>
        <import package="javax.net.ssl.SSLEngineResult"/>
        <import package="com.sun.net.httpserver"/>
        <import package="com.sun.net.httpserver.spi"/>
        <class name="SSLStreams" line="13">
            <javadoc line="13">
                given a non-blocking SocketChannel, it produces
                  (blocking) streams which encrypt/decrypt the SSL content
                  and handle the SSL handshaking automatically.                
            </javadoc>
            <declaration name="sslctx" type="SSLContext" line="19"/>
            <declaration name="chan" type="SocketChannel" line="20"/>
            <declaration name="time" type="TimeSource" line="21"/>
            <declaration name="server" type="ServerImpl" line="22"/>
            <declaration name="engine" type="SSLEngine" line="23"/>
            <declaration name="wrapper" type="EngineWrapper" line="24"/>
            <declaration name="os" type="OutputStream" line="25"/>
            <declaration name="is" type="InputStream" line="26"/>
            <declaration name="handshaking" type="Lock" line="27"/>
            <method name="SSLStreams" type="constructor" line="28">
                <params>
                    <param name="server" type="ServerImpl"/>
                    <param name="sslctx" type="SSLContext"/>
                    <param name="chan" type="SocketChannel"/>
                </params>
                <declaration name="addr" type="InetSocketAddress" line="33"/>
                <declaration name="cfg" type="HttpsConfigurator" line="36"/>
            </method>
            <method name="configureEngine" type="void" line="40">
                <params>
                    <param name="cfg" type="HttpsConfigurator"/>
                    <param name="addr" type="InetSocketAddress"/>
                </params>
                <scope line="41">
                    <declaration name="params" type="Parameters" line="42"/>
                    <declaration name="sslParams" type="SSLParameters" line="44"/>
                    <scope line="45"/>
                    <scope line="48">
                        <scope line="49">
                            <scope line="50"/>
                            <scope line="53"/>
                        </scope>
                        <scope line="58">
                            <scope line="59"/>
                            <scope line="62"/>
                        </scope>
                    </scope>
                </scope>
            </method>
            <class name="Parameters" line="68">
                <extends class="HttpsParameters"/>
                <declaration name="addr" type="InetSocketAddress" line="69"/>
                <declaration name="cfg" type="HttpsConfigurator" line="70"/>
                <method name="Parameters" type="constructor" line="71">
                    <params>
                        <param name="cfg" type="HttpsConfigurator"/>
                        <param name="addr" type="InetSocketAddress"/>
                    </params>
                </method>
                <method name="getClientAddress" type="InetSocketAddress" line="75"/>
                <method name="getHttpsConfigurator" type="HttpsConfigurator" line="78"/>
                <declaration name="params" type="SSLParameters" line="81"/>
                <method name="setSSLParameters" type="void" line="82">
                    <params>
                        <param name="p" type="SSLParameters"/>
                    </params>
                </method>
                <method name="getSSLParameters" type="SSLParameters" line="85"/>
            </class>
            <javadoc line="89">
                cleanup resources allocated inside this object                
            </javadoc>
            <method name="close" type="void" line="92"/>
            <javadoc line="95">
                return the SSL InputStream                
            </javadoc>
            <method name="getInputStream" type="InputStream" line="98">
                <scope line="99"/>
            </method>
            <javadoc line="104">
                return the SSL OutputStream                
            </javadoc>
            <method name="getOutputStream" type="OutputStream" line="107">
                <scope line="108"/>
            </method>
            <method name="getSSLEngine" type="SSLEngine" line="113"/>
            <javadoc line="116">
                request the engine to repeat the handshake on this session
                  the handshake must be driven by reads/writes on the streams
                  Normally, not necessary to call this.                
            </javadoc>
            <method name="beginHandshake" type="void" line="121"/>
            <class name="WrapperResult" line="124">
                <declaration name="result" type="SSLEngineResult" line="125"/>
                <declaration name="buf" type="ByteBuffer" line="126"/>
            </class>
            <declaration name="app_buf_size" type="int" line="128"/>
            <declaration name="packet_buf_size" type="int" line="129"/>
            <declaration name="BufType" type="enum" line="130"/>
            <scope line="130"/>
            <method name="allocate" type="ByteBuffer" line="131">
                <params>
                    <param name="type" type="BufType"/>
                </params>
            </method>
            <method name="allocate" type="ByteBuffer" line="134">
                <params>
                    <param name="type" type="BufType"/>
                    <param name="len" type="int"/>
                </params>
            </method>
            <method name="realloc" type="ByteBuffer" line="161">
                <params>
                    <param name="b" type="ByteBuffer"/>
                    <param name="flip" type="boolean"/>
                    <param name="type" type="BufType"/>
                </params>
                <scope line="162">
                    <declaration name="nsize" type="int" line="163"/>
                    <declaration name="n" type="ByteBuffer" line="164"/>
                    <scope line="165"/>
                </scope>
            </method>
            <class name="EngineWrapper" line="173">
                <javadoc line="173">
                    This is a thin wrapper over SSLEngine and the SocketChannel,
                      which guarantees the ordering of wraps/unwraps with respect to the underlying
                      channel read/writes. It handles the UNDER/OVERFLOW status codes
                      It does not handle the handshaking status codes, or the CLOSED status code
                      though once the engine is closed, any attempt to read/write to it
                      will get an exception.  The overall result is returned.
                      It functions synchronously/blocking                    
                </javadoc>
                <declaration name="chan" type="SocketChannel" line="183"/>
                <declaration name="engine" type="SSLEngine" line="184"/>
                <declaration name="wrapLock" type="Object" line="185"/>
                <declaration name="unwrap_src" type="ByteBuffer" line="186"/>
                <declaration name="closed" type="boolean" line="187"/>
                <declaration name="u_remaining" type="int" line="188"/>
                <method name="EngineWrapper" type="constructor" line="189">
                    <params>
                        <param name="chan" type="SocketChannel"/>
                        <param name="engine" type="SSLEngine"/>
                    </params>
                </method>
                <method name="close" type="void" line="197"/>
                <method name="wrapAndSend" type="WrapperResult" line="199">
                    <params>
                        <param name="src" type="ByteBuffer"/>
                    </params>
                </method>
                <method name="wrapAndSendX" type="WrapperResult" line="202">
                    <params>
                        <param name="src" type="ByteBuffer"/>
                        <param name="ignoreClose" type="boolean"/>
                    </params>
                </method>
                <method name="recvAndUnwrap" type="WrapperResult" line="233">
                    <params>
                        <param name="dst" type="ByteBuffer"/>
                    </params>
                    <declaration name="status" type="Status" line="234"/>
                    <declaration name="r" type="WrapperResult" line="235"/>
                    <scope line="237"/>
                    <declaration name="needData" type="boolean" line="240"/>
                    <scope line="241"/>
                    <scope line="246"/>
                    <scope line="250">
                        <declaration name="x" type="int" line="251"/>
                        <scope line="252">
                            <scope line="253">
                                <scope line="254"/>
                                <scope line="258"/>
                            </scope>
                            <scope line="265">
                                <scope line="266"/>
                                <scope line="269"/>
                            </scope>
                            <scope line="275"/>
                            <scope line="279"/>
                        </scope>
                    </scope>
                </method>
            </class>
            <javadoc line="291">
                send the data in the given ByteBuffer. If a handshake is needed
                  then this is handled within this method. When this call returns,
                  all of the given user data has been sent and any handshake has been
                  completed. Caller should check if engine has been closed.                
            </javadoc>
            <method name="sendData" type="WrapperResult" line="297">
                <params>
                    <param name="src" type="ByteBuffer"/>
                </params>
                <declaration name="r" type="WrapperResult" line="298"/>
                <scope line="299">
                    <declaration name="status" type="Status" line="301"/>
                    <scope line="302"/>
                    <declaration name="hs_status" type="HandshakeStatus" line="306"/>
                    <scope line="307"/>
                </scope>
            </method>
            <javadoc line="313">
                read data thru the engine into the given ByteBuffer. If the
                  given buffer was not large enough, a new one is allocated
                  and returned. This call handles handshaking automatically.
                  Caller should check if engine has been closed.                
            </javadoc>
            <method name="recvData" type="WrapperResult" line="319">
                <params>
                    <param name="dst" type="ByteBuffer"/>
                </params>
            </method>
            <method name="doClosure" type="void" line="338">
                <scope line="339">
                    <declaration name="tmp" type="ByteBuffer" line="341"/>
                    <declaration name="r" type="WrapperResult" line="342"/>
                    <scope line="343"/>
                </scope>
                <scope line="350"/>
            </method>
            <method name="doHandshake" type="void" line="354">
                <params>
                    <param name="hs_status" type="HandshakeStatus"/>
                </params>
            </method>
            <class name="InputStream" line="387">
                <extends class="java.io.InputStream"/>
                <javadoc line="387">
                    represents an SSL input stream. Multiple https requests can
                      be sent over one stream. closing this stream causes an SSL close
                      input.                    
                </javadoc>
                <declaration name="bbuf" type="ByteBuffer" line="393"/>
                <declaration name="closed" type="boolean" line="394"/>
                <declaration name="eof" type="boolean" line="395"/>
                <declaration name="needData" type="boolean" line="396"/>
                <method name="InputStream" type="constructor" line="397"/>
                <method name="read" type="int" line="400">
                    <params>
                        <param name="buf" type="byte[]"/>
                        <param name="off" type="int"/>
                        <param name="len" type="int"/>
                    </params>
                    <scope line="401"/>
                    <scope line="404"/>
                    <declaration name="available" type="int" line="407"/>
                    <scope line="408"/>
                    <scope line="412">
                        <declaration name="r" type="WrapperResult" line="414"/>
                        <scope line="416"/>
                        <scope line="420"/>
                    </scope>
                    <scope line="424"/>
                </method>
                <method name="available" type="int" line="430"/>
                <method name="markSupported" type="boolean" line="433"/>
                <method name="reset" type="void" line="436"/>
                <method name="skip" type="long" line="439">
                    <params>
                        <param name="s" type="long"/>
                    </params>
                    <declaration name="n" type="int" line="440"/>
                    <scope line="441"/>
                    <scope line="444"/>
                    <declaration name="ret" type="int" line="447"/>
                    <scope line="448">
                        <scope line="449"/>
                        <scope line="453">
                            <declaration name="r" type="WrapperResult" line="456"/>
                        </scope>
                    </scope>
                </method>
                <javadoc line="462">
                    close the SSL connection. All data must have been consumed
                      before this is called. Otherwise an exception will be thrown.
                      [Note. May need to revisit this. not quite the normal close() symantics                    
                </javadoc>
                <method name="close" type="void" line="467"/>
                <method name="read" type="int" line="471">
                    <params>
                        <param name="buf" type="byte[]"/>
                    </params>
                </method>
                <declaration name="single" type="byte" line="474"/>
                <method name="read" type="int" line="475">
                    <declaration name="n" type="int" line="476"/>
                    <scope line="477"/>
                    <scope line="480"/>
                </method>
            </class>
            <class name="OutputStream" line="485">
                <extends class="java.io.OutputStream"/>
                <javadoc line="485">
                    represents an SSL output stream. plain text data written to this stream
                      is encrypted by the stream. Multiple HTTPS responses can be sent on
                      one stream. closing this stream initiates an SSL closure                    
                </javadoc>
                <declaration name="buf" type="ByteBuffer" line="491"/>
                <declaration name="closed" type="boolean" line="492"/>
                <declaration name="single" type="byte" line="493"/>
                <method name="OutputStream" type="constructor" line="494"/>
                <method name="write" type="void" line="497">
                    <params>
                        <param name="b" type="int"/>
                    </params>
                </method>
                <method name="write" type="void" line="501">
                    <params>
                        <param name="b" type="byte"/>
                    </params>
                </method>
                <method name="write" type="void" line="504">
                    <params>
                        <param name="b" type="byte"/>
                        <param name="off" type="int"/>
                        <param name="len" type="int"/>
                    </params>
                    <scope line="505"/>
                    <scope line="508">
                        <declaration name="l" type="int" line="509"/>
                        <declaration name="r" type="WrapperResult" line="515"/>
                        <scope line="516">
                            <scope line="518"/>
                        </scope>
                    </scope>
                </method>
                <method name="flush" type="void" line="524"/>
                <method name="close" type="void" line="526"/>
            </class>
        </class>
    </source>