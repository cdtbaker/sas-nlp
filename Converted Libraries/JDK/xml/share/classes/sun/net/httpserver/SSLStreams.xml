<?xml version="1.0" encoding="UTF-8"?>
    <source package="sun.net.httpserver">
        <import package="java.net"/>
        <import package="java.nio"/>
        <import package="java.io"/>
        <import package="java.nio.channels"/>
        <import package="java.util"/>
        <import package="java.util.concurrent"/>
        <import package="java.util.concurrent.locks"/>
        <import package="javax.net.ssl"/>
        <import package="javax.net.ssl.SSLEngineResult"/>
        <import package="com.sun.net.httpserver"/>
        <import package="com.sun.net.httpserver.spi"/>
        <class name="SSLStreams" line="40">
            <comment line="58">
                                
            </comment>
            <comment line="219">
                reallocates the buffer by :-
                 1. creating a new buffer double the size of the old one
                 2. putting the contents of the old buffer into the new one
                 3. set xx_buf_size to the new size if it was smaller than new size
                
                 flip is set to true if the old buffer needs to be flipped
                 before it is copied.                
            </comment>
            <comment line="429">
                we&apos;ve received a close notify. Need to call wrap to send
                 the response                
            </comment>
            <comment line="447">
                do the (complete) handshake after acquiring the handshake lock.
                 If two threads call this at the same time, then we depend
                 on the wrapper methods being idempotent. eg. if wrapAndSend()
                 is called with no data to send then there must be no problem                
            </comment>
            <javadoc line="40">
                given a non-blocking SocketChannel, it produces
                  (blocking) streams which encrypt/decrypt the SSL content
                  and handle the SSL handshaking automatically.                
            </javadoc>
            <declaration name="sslctx" type="SSLContext" line="48"/>
            <declaration name="chan" type="SocketChannel" line="49"/>
            <declaration name="time" type="TimeSource" line="50"/>
            <declaration name="server" type="ServerImpl" line="51"/>
            <declaration name="engine" type="SSLEngine" line="52"/>
            <declaration name="wrapper" type="EngineWrapper" line="53"/>
            <declaration name="os" type="OutputStream" line="54"/>
            <declaration name="is" type="InputStream" line="55"/>
            <declaration name="handshaking" type="Lock" line="58"/>
            <method name="SSLStreams" type="constructor" line="60">
                <params>
                    <param name="server" type="ServerImpl"/>
                    <param name="sslctx" type="SSLContext"/>
                    <param name="chan" type="SocketChannel"/>
                </params>
                <declaration name="addr" type="InetSocketAddress" line="65"/>
                <declaration name="cfg" type="HttpsConfigurator" line="69"/>
            </method>
            <method name="configureEngine" type="void" line="74">
                <params>
                    <param name="cfg" type="HttpsConfigurator"/>
                    <param name="addr" type="InetSocketAddress"/>
                </params>
                <comment line="77">
                    BEGIN_TIGER_EXCLUDE                    
                </comment>
                <comment line="83">
                    END_TIGER_EXCLUDE                    
                </comment>
                <comment line="85">
                                        
                </comment>
                <comment line="91">
                                        
                </comment>
                <comment line="100">
                                        
                </comment>
                <scope line="75">
                    <declaration name="params" type="Parameters" line="76"/>
                    <declaration name="sslParams" type="SSLParameters" line="79"/>
                    <scope line="80"/>
                    <scope line="84">
                        <scope line="86">
                            <scope line="87"/>
                            <scope line="91"/>
                        </scope>
                        <scope line="95">
                            <scope line="96"/>
                            <scope line="100"/>
                        </scope>
                    </scope>
                </scope>
            </method>
            <class name="Parameters" line="106">
                <extends class="HttpsParameters"/>
                <comment line="121">
                    BEGIN_TIGER_EXCLUDE                    
                </comment>
                <comment line="129">
                    END_TIGER_EXCLUDE                    
                </comment>
                <comment line="175">
                    if passed in buffer was not big enough then the
                     a reallocated buffer is returned here                    
                </comment>
                <comment line="255">
                    the number of bytes left in unwrap_src after an unwrap()                    
                </comment>
                <comment line="269">
                    try to wrap and send the data in src. Handles OVERFLOW.
                     Might block if there is an outbound blockage or if another
                     thread is calling wrap(). Also, might not send any data
                     if an unwrap is needed.                    
                </comment>
                <comment line="309">
                    block until a complete message is available and return it
                     in dst, together with the Result. dst may have been re-allocated
                     so caller should check the returned value in Result
                     If handshaking is in progress then, possibly no data is returned                    
                </comment>
                <comment line="502">
                                        
                </comment>
                <declaration name="addr" type="InetSocketAddress" line="107"/>
                <declaration name="cfg" type="HttpsConfigurator" line="108"/>
                <method name="Parameters" type="constructor" line="110">
                    <params>
                        <param name="cfg" type="HttpsConfigurator"/>
                        <param name="addr" type="InetSocketAddress"/>
                    </params>
                </method>
                <method name="getClientAddress" type="InetSocketAddress" line="114"/>
                <method name="getHttpsConfigurator" type="HttpsConfigurator" line="117"/>
                <declaration name="params" type="SSLParameters" line="121"/>
                <method name="setSSLParameters" type="void" line="122">
                    <params>
                        <param name="p" type="SSLParameters"/>
                    </params>
                </method>
                <method name="getSSLParameters" type="SSLParameters" line="125"/>
            </class>
            <javadoc line="131">
                cleanup resources allocated inside this object                
            </javadoc>
            <method name="close" type="void" line="134"/>
            <javadoc line="138">
                return the SSL InputStream                
            </javadoc>
            <method name="getInputStream" type="InputStream" line="141">
                <scope line="142"/>
            </method>
            <javadoc line="148">
                return the SSL OutputStream                
            </javadoc>
            <method name="getOutputStream" type="OutputStream" line="151">
                <scope line="152"/>
            </method>
            <method name="getSSLEngine" type="SSLEngine" line="158"/>
            <javadoc line="162">
                request the engine to repeat the handshake on this session
                  the handshake must be driven by reads/writes on the streams
                  Normally, not necessary to call this.                
            </javadoc>
            <method name="beginHandshake" type="void" line="167"/>
            <class name="WrapperResult" line="171">
                <comment line="121">
                    BEGIN_TIGER_EXCLUDE                    
                </comment>
                <comment line="129">
                    END_TIGER_EXCLUDE                    
                </comment>
                <comment line="175">
                    if passed in buffer was not big enough then the
                     a reallocated buffer is returned here                    
                </comment>
                <comment line="255">
                    the number of bytes left in unwrap_src after an unwrap()                    
                </comment>
                <comment line="269">
                    try to wrap and send the data in src. Handles OVERFLOW.
                     Might block if there is an outbound blockage or if another
                     thread is calling wrap(). Also, might not send any data
                     if an unwrap is needed.                    
                </comment>
                <comment line="309">
                    block until a complete message is available and return it
                     in dst, together with the Result. dst may have been re-allocated
                     so caller should check the returned value in Result
                     If handshaking is in progress then, possibly no data is returned                    
                </comment>
                <comment line="502">
                                        
                </comment>
                <declaration name="result" type="SSLEngineResult" line="172"/>
                <declaration name="buf" type="ByteBuffer" line="177"/>
            </class>
            <declaration name="app_buf_size" type="int" line="180"/>
            <declaration name="packet_buf_size" type="int" line="181"/>
            <method name="allocate" type="ByteBuffer" line="187">
                <params>
                    <param name="type" type="BufType"/>
                </params>
            </method>
            <method name="allocate" type="ByteBuffer" line="191">
                <params>
                    <param name="type" type="BufType"/>
                    <param name="len" type="int"/>
                </params>
                <scope line="193">
                    <declaration name="size" type="int" line="194"/>
                    <scope line="195">
                        <scope line="196">
                            <declaration name="sess" type="SSLSession" line="197"/>
                        </scope>
                        <scope line="200"/>
                    </scope>
                    <scope line="204">
                        <scope line="205">
                            <declaration name="sess" type="SSLSession" line="206"/>
                        </scope>
                        <scope line="209"/>
                    </scope>
                </scope>
            </method>
            <method name="realloc" type="ByteBuffer" line="226">
                <params>
                    <param name="b" type="ByteBuffer"/>
                    <param name="flip" type="boolean"/>
                    <param name="type" type="BufType"/>
                </params>
                <scope line="227">
                    <declaration name="nsize" type="int" line="228"/>
                    <declaration name="n" type="ByteBuffer" line="229"/>
                    <scope line="230"/>
                </scope>
            </method>
            <class name="EngineWrapper" line="238">
                <comment line="121">
                    BEGIN_TIGER_EXCLUDE                    
                </comment>
                <comment line="129">
                    END_TIGER_EXCLUDE                    
                </comment>
                <comment line="175">
                    if passed in buffer was not big enough then the
                     a reallocated buffer is returned here                    
                </comment>
                <comment line="255">
                    the number of bytes left in unwrap_src after an unwrap()                    
                </comment>
                <comment line="269">
                    try to wrap and send the data in src. Handles OVERFLOW.
                     Might block if there is an outbound blockage or if another
                     thread is calling wrap(). Also, might not send any data
                     if an unwrap is needed.                    
                </comment>
                <comment line="309">
                    block until a complete message is available and return it
                     in dst, together with the Result. dst may have been re-allocated
                     so caller should check the returned value in Result
                     If handshaking is in progress then, possibly no data is returned                    
                </comment>
                <comment line="502">
                                        
                </comment>
                <javadoc line="238">
                    This is a thin wrapper over SSLEngine and the SocketChannel,
                      which guarantees the ordering of wraps/unwraps with respect to the underlying
                      channel read/writes. It handles the UNDER/OVERFLOW status codes
                      It does not handle the handshaking status codes, or the CLOSED status code
                      though once the engine is closed, any attempt to read/write to it
                      will get an exception.  The overall result is returned.
                      It functions synchronously/blocking                    
                </javadoc>
                <declaration name="chan" type="SocketChannel" line="249"/>
                <declaration name="engine" type="SSLEngine" line="250"/>
                <declaration name="wrapLock" type="Object" line="251"/>
                <declaration name="unwrap_src" type="ByteBuffer" line="252"/>
                <declaration name="closed" type="boolean" line="253"/>
                <declaration name="u_remaining" type="int" line="254"/>
                <method name="EngineWrapper" type="constructor" line="256">
                    <params>
                        <param name="chan" type="SocketChannel"/>
                        <param name="engine" type="SSLEngine"/>
                    </params>
                </method>
                <method name="close" type="void" line="265"/>
                <method name="wrapAndSend" type="WrapperResult" line="273">
                    <params>
                        <param name="src" type="ByteBuffer"/>
                    </params>
                </method>
                <method name="wrapAndSendX" type="WrapperResult" line="277">
                    <params>
                        <param name="src" type="ByteBuffer"/>
                        <param name="ignoreClose" type="boolean"/>
                    </params>
                    <scope line="278"/>
                    <declaration name="status" type="Status" line="281"/>
                    <declaration name="r" type="WrapperResult" line="282"/>
                    <scope line="283">
                        <scope line="285">
                            <scope line="288"/>
                        </scope>
                        <scope line="292"/>
                        <scope line="296">
                            <declaration name="l" type="int" line="298"/>
                            <scope line="300"/>
                        </scope>
                    </scope>
                </method>
                <method name="recvAndUnwrap" type="WrapperResult" line="313">
                    <params>
                        <param name="dst" type="ByteBuffer"/>
                    </params>
                    <comment line="345">
                                                
                    </comment>
                    <comment line="350">
                        Buffer not full, just need to read more
                         data off the channel. Reset pointers
                         for reading off SocketChannel                        
                    </comment>
                    <declaration name="status" type="Status" line="314"/>
                    <declaration name="r" type="WrapperResult" line="315"/>
                    <scope line="317"/>
                    <declaration name="needData" type="boolean" line="320"/>
                    <scope line="321"/>
                    <scope line="325"/>
                    <scope line="329">
                        <declaration name="x" type="int" line="330"/>
                        <scope line="331">
                            <scope line="332">
                                <scope line="333"/>
                                <scope line="336"/>
                            </scope>
                            <scope line="343">
                                <scope line="344"/>
                                <scope line="349"/>
                            </scope>
                            <scope line="358"/>
                            <scope line="361"/>
                        </scope>
                    </scope>
                </method>
            </class>
            <javadoc line="373">
                send the data in the given ByteBuffer. If a handshake is needed
                  then this is handled within this method. When this call returns,
                  all of the given user data has been sent and any handshake has been
                  completed. Caller should check if engine has been closed.                
            </javadoc>
            <method name="sendData" type="WrapperResult" line="379">
                <params>
                    <param name="src" type="ByteBuffer"/>
                </params>
                <declaration name="r" type="WrapperResult" line="380"/>
                <scope line="381">
                    <declaration name="status" type="Status" line="383"/>
                    <scope line="384"/>
                    <declaration name="hs_status" type="HandshakeStatus" line="388"/>
                    <scope line="391"/>
                </scope>
            </method>
            <javadoc line="398">
                read data thru the engine into the given ByteBuffer. If the
                  given buffer was not large enough, a new one is allocated
                  and returned. This call handles handshaking automatically.
                  Caller should check if engine has been closed.                
            </javadoc>
            <method name="recvData" type="WrapperResult" line="404">
                <params>
                    <param name="dst" type="ByteBuffer"/>
                </params>
                <comment line="405">
                                        
                </comment>
                <declaration name="r" type="WrapperResult" line="406"/>
                <scope line="408">
                    <declaration name="status" type="Status" line="411"/>
                    <scope line="412"/>
                    <declaration name="hs_status" type="HandshakeStatus" line="417"/>
                    <scope line="420"/>
                </scope>
            </method>
            <method name="doClosure" type="void" line="431">
                <scope line="432">
                    <declaration name="tmp" type="ByteBuffer" line="434"/>
                    <declaration name="r" type="WrapperResult" line="435"/>
                    <scope line="436"/>
                </scope>
                <scope line="441"/>
            </method>
            <method name="doHandshake" type="void" line="451">
                <params>
                    <param name="hs_status" type="HandshakeStatus"/>
                </params>
                <comment line="463">
                    run in current thread, because we are already
                     running an external Executor                    
                </comment>
                <comment line="468">
                                        
                </comment>
                <scope line="452">
                    <declaration name="tmp" type="ByteBuffer" line="454"/>
                    <scope line="457">
                        <declaration name="r" type="WrapperResult" line="458"/>
                        <declaration name="task" type="Runnable" line="461"/>
                        <scope line="462"/>
                        <scope line="478"/>
                    </scope>
                </scope>
                <scope line="486"/>
            </method>
            <class name="InputStream" line="491">
                <extends class="java.io.InputStream"/>
                <comment line="121">
                    BEGIN_TIGER_EXCLUDE                    
                </comment>
                <comment line="129">
                    END_TIGER_EXCLUDE                    
                </comment>
                <comment line="175">
                    if passed in buffer was not big enough then the
                     a reallocated buffer is returned here                    
                </comment>
                <comment line="255">
                    the number of bytes left in unwrap_src after an unwrap()                    
                </comment>
                <comment line="269">
                    try to wrap and send the data in src. Handles OVERFLOW.
                     Might block if there is an outbound blockage or if another
                     thread is calling wrap(). Also, might not send any data
                     if an unwrap is needed.                    
                </comment>
                <comment line="309">
                    block until a complete message is available and return it
                     in dst, together with the Result. dst may have been re-allocated
                     so caller should check the returned value in Result
                     If handshaking is in progress then, possibly no data is returned                    
                </comment>
                <comment line="502">
                                        
                </comment>
                <javadoc line="491">
                    represents an SSL input stream. Multiple https requests can
                      be sent over one stream. closing this stream causes an SSL close
                      input.                    
                </javadoc>
                <declaration name="bbuf" type="ByteBuffer" line="498"/>
                <declaration name="closed" type="boolean" line="499"/>
                <declaration name="eof" type="boolean" line="502"/>
                <declaration name="needData" type="boolean" line="504"/>
                <method name="InputStream" type="constructor" line="506"/>
                <method name="read" type="int" line="510">
                    <params>
                        <param name="buf" type="byte[]"/>
                        <param name="off" type="int"/>
                        <param name="len" type="int"/>
                    </params>
                    <comment line="533">
                                                
                    </comment>
                    <scope line="511"/>
                    <scope line="514"/>
                    <declaration name="available" type="int" line="517"/>
                    <scope line="518"/>
                    <scope line="522">
                        <declaration name="r" type="WrapperResult" line="524"/>
                        <scope line="526"/>
                        <scope line="529"/>
                    </scope>
                    <scope line="534"/>
                </method>
                <method name="available" type="int" line="541"/>
                <method name="markSupported" type="boolean" line="545">
                    <comment line="546">
                                                
                    </comment>
                </method>
                <method name="reset" type="void" line="549"/>
                <method name="skip" type="long" line="553">
                    <params>
                        <param name="s" type="long"/>
                    </params>
                    <comment line="573">
                                                
                    </comment>
                    <declaration name="n" type="int" line="554"/>
                    <scope line="555"/>
                    <scope line="558"/>
                    <declaration name="ret" type="int" line="561"/>
                    <scope line="562">
                        <scope line="563"/>
                        <scope line="566">
                            <declaration name="r" type="WrapperResult" line="569"/>
                        </scope>
                    </scope>
                </method>
                <javadoc line="576">
                    close the SSL connection. All data must have been consumed
                      before this is called. Otherwise an exception will be thrown.
                      [Note. May need to revisit this. not quite the normal close() symantics                    
                </javadoc>
                <method name="close" type="void" line="581"/>
                <method name="read" type="int" line="586">
                    <params>
                        <param name="buf" type="byte[]"/>
                    </params>
                </method>
                <declaration name="single" type="byte" line="590"/>
                <method name="read" type="int" line="592">
                    <declaration name="n" type="int" line="593"/>
                    <scope line="594"/>
                    <scope line="596"/>
                </method>
            </class>
            <class name="OutputStream" line="602">
                <extends class="java.io.OutputStream"/>
                <comment line="121">
                    BEGIN_TIGER_EXCLUDE                    
                </comment>
                <comment line="129">
                    END_TIGER_EXCLUDE                    
                </comment>
                <comment line="175">
                    if passed in buffer was not big enough then the
                     a reallocated buffer is returned here                    
                </comment>
                <comment line="255">
                    the number of bytes left in unwrap_src after an unwrap()                    
                </comment>
                <comment line="269">
                    try to wrap and send the data in src. Handles OVERFLOW.
                     Might block if there is an outbound blockage or if another
                     thread is calling wrap(). Also, might not send any data
                     if an unwrap is needed.                    
                </comment>
                <comment line="309">
                    block until a complete message is available and return it
                     in dst, together with the Result. dst may have been re-allocated
                     so caller should check the returned value in Result
                     If handshaking is in progress then, possibly no data is returned                    
                </comment>
                <comment line="502">
                                        
                </comment>
                <javadoc line="602">
                    represents an SSL output stream. plain text data written to this stream
                      is encrypted by the stream. Multiple HTTPS responses can be sent on
                      one stream. closing this stream initiates an SSL closure                    
                </javadoc>
                <declaration name="buf" type="ByteBuffer" line="608"/>
                <declaration name="closed" type="boolean" line="609"/>
                <declaration name="single" type="byte" line="610"/>
                <method name="OutputStream" type="constructor" line="612"/>
                <method name="write" type="void" line="616">
                    <params>
                        <param name="b" type="int"/>
                    </params>
                </method>
                <method name="write" type="void" line="621">
                    <params>
                        <param name="b" type="byte"/>
                    </params>
                </method>
                <method name="write" type="void" line="624">
                    <params>
                        <param name="b" type="byte"/>
                        <param name="off" type="int"/>
                        <param name="len" type="int"/>
                    </params>
                    <scope line="625"/>
                    <scope line="628">
                        <declaration name="l" type="int" line="629"/>
                        <declaration name="r" type="WrapperResult" line="635"/>
                        <scope line="636">
                            <scope line="638"/>
                        </scope>
                    </scope>
                </method>
                <method name="flush" type="void" line="645">
                    <comment line="646">
                                                
                    </comment>
                </method>
                <method name="close" type="void" line="649">
                    <declaration name="r" type="WrapperResult" line="650"/>
                    <declaration name="stat" type="HandshakeStatus" line="653"/>
                    <scope line="655"/>
                </method>
            </class>
        </class>
    </source>