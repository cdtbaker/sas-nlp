<?xml version="1.0" encoding="UTF-8"?>
    <source package="sun.net.www.protocol.http">
        <import package="java.net.URL"/>
        <import package="java.io.IOException"/>
        <import package="java.net.Authenticator.RequestorType"/>
        <import package="java.util.HashMap"/>
        <import package="sun.net.www.HeaderParser"/>
        <import package="sun.misc.BASE64Decoder"/>
        <import package="sun.misc.BASE64Encoder"/>
        <import package="sun.net.www.protocol.http.AuthScheme.NEGOTIATE"/>
        <import package="sun.net.www.protocol.http.AuthScheme.KERBEROS"/>
        <class name="NegotiateAuthentication" line="38">
            <extends class="AuthenticationInfo"/>
            <comment line="52">
                These maps are used to manage the GSS availability for diffrent
                 hosts. The key for both maps is the host name.
                 &lt;code&gt;supported&lt;/code&gt; is set when isSupported is checked,
                 if it&apos;s true, a cached Negotiator is put into &lt;code&gt;cache&lt;/code&gt;.
                 the cache can be used only once, so after the first use, it&apos;s cleaned.                
            </comment>
            <comment line="60">
                The HTTP Negotiate Helper                
            </comment>
            <comment line="211">
                MS will send a final WWW-Authenticate even if the status is already
                 200 OK. The token can be fed into initSecContext() again to determine
                 if the server can be trusted. This is not the same concept as Digest&apos;s
                 Authentication-Info header.
                
                 Currently we ignore this header.                
            </comment>
            <javadoc line="38">
                NegotiateAuthentication:                
                <author>
                    weijun.wang@sun.com                    
                </author>
                <since>
                    1.6                    
                </since>
            </javadoc>
            <declaration name="serialVersionUID" type="long" line="47"/>
            <declaration name="hci" type="HttpCallerInfo" line="49"/>
            <declaration name="supported" type="HashMap&lt;String,Boolean&gt;" line="56"/>
            <declaration name="cache" type="HashMap&lt;String,Negotiator&gt;" line="57"/>
            <declaration name="negotiator" type="Negotiator" line="60"/>
            <javadoc line="62">
                Constructor used for both WWW and proxy entries.                
                <param>
                    hci a schemed object.                    
                </param>
            </javadoc>
            <method name="NegotiateAuthentication" type="constructor" line="66">
                <params>
                    <param name="hci" type="HttpCallerInfo"/>
                </params>
            </method>
            <javadoc line="74">
                @return true if this authentication supports preemptive authorization                
            </javadoc>
            <method name="supportsPreemptiveAuthorization" type="boolean" line="78"/>
            <javadoc line="82">
                Find out if the HttpCallerInfo supports Negotiate protocol. In order to
                  find out yes or no, an initialization of a Negotiator object against it
                  is tried. The generated object will be cached under the name of ths
                  hostname at a success try.&lt;br&gt;
                  If this method is called for the second time on an HttpCallerInfo with
                  the same hostname, the answer is retrieved from cache.                
                <return>
                    true if supported                    
                </return>
            </javadoc>
            <method name="isSupported" type="boolean" line="93">
                <params>
                    <param name="hci" type="HttpCallerInfo"/>
                </params>
                <comment line="108">
                    the only place cache.put is called. here we can make sure
                     the object is valid and the oneToken inside is not null                    
                </comment>
                <scope line="94"/>
                <declaration name="hostname" type="String" line="98"/>
                <scope line="100"/>
                <declaration name="neg" type="Negotiator" line="104"/>
                <scope line="105"/>
                <scope line="111"/>
            </method>
            <javadoc line="117">
                Not supported. Must use the setHeaders() method                
            </javadoc>
            <method name="getHeaderValue" type="String" line="121">
                <params>
                    <param name="url" type="URL"/>
                    <param name="method" type="String"/>
                </params>
            </method>
            <javadoc line="125">
                Check if the header indicates that the current auth. parameters are stale.
                  If so, then replace the relevant field with the new value
                  and return true. Otherwise return false.
                  returning true means the request can be retried with the same userid/password
                  returning false means we have to go back to the user to ask for a new
                  username password.                
            </javadoc>
            <method name="isAuthorizationStale" type="boolean" line="134">
                <params>
                    <param name="header" type="String"/>
                </params>
                <comment line="136">
                                        
                </comment>
            </method>
            <javadoc line="138">
                Set header(s) on the given connection.                
                <param>
                    conn The connection to apply the header(s) to                    
                </param>
                <param>
                    p A source of header values for this connection, not used because
                      HeaderParser converts the fields to lower case, use raw instead                    
                </param>
                <param>
                    raw The raw header field.                    
                </param>
                <return>
                    true if all goes well, false if no headers were set.                    
                </return>
            </javadoc>
            <method name="setHeaders" type="boolean" line="147">
                <params>
                    <param name="conn" type="HttpURLConnection"/>
                    <param name="p" type="HeaderParser"/>
                    <param name="raw" type="String"/>
                </params>
                <scope line="149">
                    <declaration name="response" type="String" line="150"/>
                    <declaration name="incoming" type="byte[]" line="151"/>
                    <declaration name="parts" type="String[]" line="152"/>
                    <scope line="153"/>
                </scope>
                <scope line="161"/>
            </method>
            <javadoc line="166">
                return the first token.                
                <returns>
                    the token                    
                </returns>
                <throws>
                    IOException if &lt;code&gt;Negotiator.getNegotiator()&lt;/code&gt; or
                      &lt;code&gt;Negotiator.firstToken()&lt;/code&gt; failed.                    
                </throws>
            </javadoc>
            <method name="firstToken" type="byte[]" line="172">
                <comment line="179">
                    so that it is only used once                    
                </comment>
                <scope line="174">
                    <scope line="175">
                        <scope line="177"/>
                    </scope>
                </scope>
                <scope line="182">
                    <scope line="184">
                        <declaration name="ioe" type="IOException" line="185"/>
                    </scope>
                </scope>
            </method>
            <javadoc line="193">
                return more tokens                
                <param>
                    token the token to be fed into &lt;code&gt;negotiator.nextToken()&lt;/code&gt;                    
                </param>
                <returns>
                    the token                    
                </returns>
                <throws>
                    IOException if &lt;code&gt;negotiator.nextToken()&lt;/code&gt; throws Exception.
                      May happen if the input token is invalid.                    
                </throws>
            </javadoc>
            <method name="nextToken" type="byte[]" line="200">
                <params>
                    <param name="token" type="byte[]"/>
                </params>
            </method>
            <class name="B64Encoder" line="204">
                <extends class="BASE64Encoder"/>
                <method name="bytesPerLine" type="int" line="205">
                    <comment line="207">
                        as big as it can be, maybe INT_MAX                        
                    </comment>
                </method>
            </class>
        </class>
    </source>