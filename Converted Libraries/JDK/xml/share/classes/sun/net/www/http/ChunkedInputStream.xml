<?xml version="1.0" encoding="UTF-8"?>
    <source package="sun.net.www.http">
        <import package="java.io"/>
        <import package="java.util"/>
        <import package="sun.net"/>
        <import package="sun.net.www"/>
        <class name="ChunkedInputStream" line="33">
            <extends class="InputStream"/>
            <implements interface="Hurryable"/>
            <javadoc line="33">
                A &lt;code&gt;ChunkedInputStream&lt;/code&gt; provides a stream for reading a body of
                  a http message that can be sent as a series of chunks, each with its own
                  size indicator. Optionally the last chunk can be followed by trailers
                  containing entity-header fields.
                  &lt;p&gt;
                  A &lt;code&gt;ChunkedInputStream&lt;/code&gt; is also &lt;code&gt;Hurryable&lt;/code&gt; so it
                  can be hurried to the end of the stream if the bytes are available on
                  the underlying stream.                
            </javadoc>
            <declaration name="in" type="InputStream" line="46"/>
            <javadoc line="46">
                The underlying stream                
            </javadoc>
            <declaration name="hc" type="HttpClient" line="51"/>
            <javadoc line="51">
                The &lt;code&gt;HttpClient&lt;/code&gt; that should be notified when the chunked stream has
                  completed.                
            </javadoc>
            <declaration name="responses" type="MessageHeader" line="57"/>
            <javadoc line="57">
                The &lt;code&gt;MessageHeader&lt;/code&gt; that is populated with any optional trailer
                  that appear after the last chunk.                
            </javadoc>
            <declaration name="chunkSize" type="int" line="63"/>
            <javadoc line="63">
                The size, in bytes, of the chunk that is currently being read.
                  This size is only valid if the current position in the underlying
                  input stream is inside a chunk (ie: state == STATE_READING_CHUNK).                
            </javadoc>
            <declaration name="chunkRead" type="int" line="70"/>
            <javadoc line="70">
                The number of bytes read from the underlying stream for the current
                  chunk. This value is always in the range &lt;code&gt;0&lt;/code&gt; through to
                  &lt;code&gt;chunkSize&lt;/code&gt;                
            </javadoc>
            <declaration name="chunkData" type="byte" line="77"/>
            <javadoc line="77">
                The internal buffer array where chunk data is available for the
                  application to read.                
            </javadoc>
            <declaration name="chunkPos" type="int" line="83"/>
            <javadoc line="83">
                The current position in the buffer. It contains the index
                  of the next byte to read from &lt;code&gt;chunkData&lt;/code&gt;                
            </javadoc>
            <declaration name="chunkCount" type="int" line="89"/>
            <javadoc line="89">
                The index one greater than the index of the last valid byte in the
                  buffer. This value is always in the range &lt;code&gt;0&lt;/code&gt; through
                  &lt;code&gt;chunkData.length&lt;/code&gt;.                
            </javadoc>
            <declaration name="rawData" type="byte" line="96"/>
            <javadoc line="96">
                The internal buffer where bytes from the underlying stream can be
                  read. It may contain bytes representing chunk-size, chunk-data, or
                  trailer fields.                
            </javadoc>
            <declaration name="rawPos" type="int" line="103"/>
            <javadoc line="103">
                The current position in the buffer. It contains the index
                  of the next byte to read from &lt;code&gt;rawData&lt;/code&gt;                
            </javadoc>
            <declaration name="rawCount" type="int" line="109"/>
            <javadoc line="109">
                The index one greater than the index of the last valid byte in the
                  buffer. This value is always in the range &lt;code&gt;0&lt;/code&gt; through
                  &lt;code&gt;rawData.length&lt;/code&gt;.                
            </javadoc>
            <declaration name="error" type="boolean" line="116"/>
            <javadoc line="116">
                Indicates if an error was encountered when processing the chunked
                  stream.                
            </javadoc>
            <declaration name="closed" type="boolean" line="122"/>
            <javadoc line="122">
                Indicates if the chunked stream has been closed using the
                  &lt;code&gt;close&lt;/code&gt; method.                
            </javadoc>
            <declaration name="STATE_AWAITING_CHUNK_HEADER" type="int" line="128"/>
            <javadoc line="128">
                State to indicate that next field should be :-
                  chunk-size [ chunk-extension ] CRLF                
            </javadoc>
            <declaration name="STATE_READING_CHUNK" type="int" line="134"/>
            <javadoc line="134">
                State to indicate that we are currently reading the chunk-data.                
            </javadoc>
            <declaration name="STATE_AWAITING_CHUNK_EOL" type="int" line="139"/>
            <javadoc line="139">
                Indicates that a chunk has been completely read and the next
                  fields to be examine should be CRLF                
            </javadoc>
            <declaration name="STATE_AWAITING_TRAILERS" type="int" line="145"/>
            <javadoc line="145">
                Indicates that all chunks have been read and the next field
                  should be optional trailers or an indication that the chunked
                  stream is complete.                
            </javadoc>
            <declaration name="STATE_DONE" type="int" line="152"/>
            <javadoc line="152">
                State to indicate that the chunked stream is complete and
                  no further bytes should be read from the underlying stream.                
            </javadoc>
            <declaration name="state" type="int" line="158"/>
            <javadoc line="158">
                Indicates the current state.                
            </javadoc>
            <javadoc line="164">
                Check to make sure that this stream has not been closed.                
            </javadoc>
            <method name="ensureOpen" type="void" line="167">
                <scope line="168"/>
            </method>
            <javadoc line="174">
                Ensures there is &lt;code&gt;size&lt;/code&gt; bytes available in
                  &lt;code&gt;rawData&lt;/code&gt;. This requires that we either
                  shift the bytes in use to the begining of the buffer
                  or allocate a large buffer with sufficient space available.                
            </javadoc>
            <method name="ensureRawAvailable" type="void" line="180">
                <params>
                    <param name="size" type="int"/>
                </params>
                <scope line="181">
                    <declaration name="used" type="int" line="182"/>
                    <scope line="183">
                        <declaration name="tmp" type="byte" line="184"/>
                        <scope line="185"/>
                    </scope>
                    <scope line="189">
                        <scope line="190"/>
                    </scope>
                </scope>
            </method>
            <javadoc line="200">
                Close the underlying input stream by either returning it to the
                  keep alive cache or closing the stream.
                  &lt;p&gt;
                  As a chunked stream is inheritly persistent (see HTTP 1.1 RFC) the
                  underlying stream can be returned to the keep alive cache if the
                  stream can be completely read without error.                
            </javadoc>
            <method name="closeUnderlying" type="void" line="208">
                <scope line="209"/>
                <scope line="213"/>
                <scope line="215">
                    <scope line="216"/>
                </scope>
            </method>
            <javadoc line="224">
                Attempt to read the remainder of a chunk directly into the
                  caller&apos;s buffer.
                  &lt;p&gt;
                  Return the number of bytes read.                
            </javadoc>
            <method name="fastRead" type="int" line="230">
                <params>
                    <param name="b" type="byte[]"/>
                    <param name="off" type="int"/>
                    <param name="len" type="int"/>
                </params>
                <comment line="233">
                    assert state == STATE_READING_CHUNKS;                    
                </comment>
                <declaration name="remaining" type="int" line="234"/>
                <declaration name="cnt" type="int" line="235"/>
                <scope line="236">
                    <declaration name="nread" type="int" line="237"/>
                    <scope line="238"/>
                    <scope line="240"/>
                    <scope line="244">
                        <scope line="246"/>
                    </scope>
                </scope>
                <scope line="253"/>
            </method>
            <javadoc line="258">
                Process any outstanding bytes that have already been read into
                  &lt;code&gt;rawData&lt;/code&gt;.
                  &lt;p&gt;
                  The parsing of the chunked stream is performed as a state machine with
                  &lt;code&gt;state&lt;/code&gt; representing the current state of the processing.
                  &lt;p&gt;
                  Returns when either all the outstanding bytes in rawData have been
                  processed or there is insufficient bytes available to continue
                  processing. When the latter occurs &lt;code&gt;rawPos&lt;/code&gt; will not have
                  been updated and thus the processing can be restarted once further
                  bytes have been read into &lt;code&gt;rawData&lt;/code&gt;.                
            </javadoc>
            <method name="processRaw" type="void" line="271">
                <comment line="280">
                    We are awaiting a line with a chunk header                    
                </comment>
                <comment line="284">
                    Find \n to indicate end of chunk header. If not found when there is
                     insufficient bytes in the raw buffer to parse a chunk header.                    
                </comment>
                <comment line="299">
                    Extract the chunk size from the header (ignoring extensions).                    
                </comment>
                <comment line="314">
                    Chunk has been parsed so move rawPos to first byte of chunk
                     data.                    
                </comment>
                <comment line="321">
                    A chunk size of 0 means EOF.                    
                </comment>
                <comment line="332">
                    We are awaiting raw entity data (some may have already been
                     read). chunkSize is the size of the chunk; chunkRead is the
                     total read from the underlying stream to date.                    
                </comment>
                <comment line="338">
                                        
                </comment>
                <comment line="343">
                    Compute the number of bytes of chunk data available in the
                     raw buffer.                    
                </comment>
                <comment line="349">
                    Expand or compact chunkData if needed.                    
                </comment>
                <comment line="365">
                    Copy the chunk data into chunkData so that it&apos;s available
                     to the read methods.                    
                </comment>
                <comment line="374">
                    If all the chunk has been copied into chunkData then the next
                     token should be CRLF.                    
                </comment>
                <comment line="386">
                    Awaiting CRLF after the chunk                    
                </comment>
                <comment line="390">
                                        
                </comment>
                <comment line="405">
                    Move onto the next chunk                    
                </comment>
                <comment line="412">
                    Last chunk has been read so not we&apos;re waiting for optional
                     trailers.                    
                </comment>
                <comment line="418">
                    Do we have an entire line in the raw buffer?                    
                </comment>
                <comment line="441">
                    Stream done so close underlying stream.                    
                </comment>
                <comment line="452">
                    Extract any tailers and append them to the message
                     headers.                    
                </comment>
                <comment line="466">
                    Move onto the next trailer.                    
                </comment>
                <comment line="472">
                                        
                </comment>
                <declaration name="pos" type="int" line="272"/>
                <declaration name="i" type="int" line="273"/>
                <scope line="275">
                    <scope line="288">
                        <scope line="289"/>
                    </scope>
                    <scope line="294"/>
                    <declaration name="header" type="String" line="301"/>
                    <scope line="302"/>
                    <scope line="306"/>
                    <scope line="308"/>
                    <scope line="323"/>
                    <scope line="325"/>
                    <scope line="338"/>
                    <declaration name="copyLen" type="int" line="346"/>
                    <scope line="351">
                        <declaration name="cnt" type="int" line="352"/>
                        <scope line="353">
                            <declaration name="tmp" type="byte" line="354"/>
                        </scope>
                        <scope line="357"/>
                    </scope>
                    <scope line="377"/>
                    <scope line="379"/>
                    <scope line="390"/>
                    <scope line="394"/>
                    <scope line="398"/>
                    <scope line="421">
                        <scope line="422"/>
                    </scope>
                    <scope line="427"/>
                    <scope line="431"/>
                    <scope line="435"/>
                    <scope line="443"/>
                    <declaration name="trailer" type="String" line="455"/>
                    <scope line="457"/>
                    <declaration name="key" type="String" line="460"/>
                    <declaration name="value" type="String" line="461"/>
                </scope>
            </method>
            <javadoc line="476">
                Reads any available bytes from the underlying stream into
                  &lt;code&gt;rawData&lt;/code&gt; and returns the number of bytes of
                  chunk data available in &lt;code&gt;chunkData&lt;/code&gt; that the
                  application can read.                
            </javadoc>
            <method name="readAheadNonBlocking" type="int" line="482">
                <comment line="485">
                    If there&apos;s anything available on the underlying stream then we read
                     it into the raw buffer and process it. Processing ensures that any
                     available chunk data is made available in chunkData.                    
                </comment>
                <comment line="493">
                                        
                </comment>
                <comment line="504">
                                        
                </comment>
                <comment line="509">
                    Process the raw bytes that have been read.                    
                </comment>
                <comment line="515">
                    Return the number of chunked bytes available to read                    
                </comment>
                <declaration name="avail" type="int" line="489"/>
                <scope line="490">
                    <declaration name="nread" type="int" line="495"/>
                    <scope line="496"/>
                    <scope line="498"/>
                    <scope line="502"/>
                </scope>
            </method>
            <javadoc line="520">
                Reads from the underlying stream until there is chunk data
                  available in &lt;code&gt;chunkData&lt;/code&gt; for the application to
                  read.                
            </javadoc>
            <method name="readAheadBlocking" type="int" line="525">
                <comment line="529">
                    All of chunked response has been read to return EOF.                    
                </comment>
                <comment line="536">
                    We must read into the raw buffer so make sure there is space
                     available. We use a size of 32 to avoid too much chunk data
                     being read into the raw buffer.                    
                </comment>
                <comment line="550">
                    If we hit EOF it means there&apos;s a problem as we should never
                     attempt to read once the last chunk and trailers have been
                     received.                    
                </comment>
                <comment line="560">
                    Process the bytes from the underlying stream                    
                </comment>
                <comment line="568">
                    Return the number of chunked bytes available to read                    
                </comment>
                <scope line="527">
                    <scope line="531"/>
                    <declaration name="nread" type="int" line="541"/>
                    <scope line="542"/>
                    <scope line="544"/>
                    <scope line="554"/>
                </scope>
            </method>
            <javadoc line="573">
                Read ahead in either blocking or non-blocking mode. This method
                  is typically used when we run out of available bytes in
                  &lt;code&gt;chunkData&lt;/code&gt; or we need to determine how many bytes
                  are available on the input stream.                
            </javadoc>
            <method name="readAhead" type="int" line="579">
                <params>
                    <param name="allowBlocking" type="boolean"/>
                </params>
                <comment line="582">
                    Last chunk already received - return EOF                    
                </comment>
                <comment line="589">
                    Reset positioncount if data in chunkData is exhausted.                    
                </comment>
                <comment line="597">
                    Read ahead blocking or non-blocking                    
                </comment>
                <scope line="584"/>
                <scope line="591"/>
                <scope line="599"/>
                <scope line="601"/>
            </method>
            <javadoc line="606">
                Creates a &lt;code&gt;ChunkedInputStream&lt;/code&gt; and saves its  arguments, for
                  later use.                
                <param>
                    in   the underlying input stream.                    
                </param>
                <param>
                    hc   the HttpClient                    
                </param>
                <param>
                    responses   the MessageHeader that should be populated with optional
                      trailers.                    
                </param>
            </javadoc>
            <method name="ChunkedInputStream" type="constructor" line="615">
                <params>
                    <param name="in" type="InputStream"/>
                    <param name="hc" type="HttpClient"/>
                    <param name="responses" type="MessageHeader"/>
                </params>
                <comment line="618">
                                        
                </comment>
                <comment line="623">
                    Set our initial state to indicate that we are first starting to
                     look for a chunk header.                    
                </comment>
            </method>
            <javadoc line="629">
                See
                  the general contract of the &lt;code&gt;read&lt;/code&gt;
                  method of &lt;code&gt;InputStream&lt;/code&gt;.                
                <return>
                    the next byte of data, or <code>-1</code> if the end of the
                      stream is reached.                    
                </return>
                <exception>
                    IOException  if an I/O error occurs.                    
                </exception>
                <see>
                    java.io.FilterInputStream#in                    
                </see>
            </javadoc>
            <method name="read" type="int" line="639">
                <scope line="641">
                    <scope line="642"/>
                </scope>
            </method>
            <javadoc line="650">
                Reads bytes from this stream into the specified byte array, starting at
                  the given offset.                
                <param>
                    b     destination buffer.                    
                </param>
                <param>
                    off   offset at which to start storing bytes.                    
                </param>
                <param>
                    len   maximum number of bytes to read.                    
                </param>
                <return>
                    the number of bytes read, or <code>-1</code> if the end of
                      the stream has been reached.                    
                </return>
                <exception>
                    IOException  if an I/O error occurs.                    
                </exception>
            </javadoc>
            <method name="read" type="int" line="663">
                <params>
                    <param name="b" type="byte"/>
                    <param name="off" type="int"/>
                    <param name="len" type="int"/>
                </params>
                <comment line="675">
                    Optimization: if we&apos;re in the middle of the chunk read
                     directly from the underlying stream into the caller&apos;s
                     buffer                    
                </comment>
                <comment line="684">
                    We&apos;re not in the middle of a chunk so we must read ahead
                     until there is some chunk data available.                    
                </comment>
                <comment line="690">
                                        
                </comment>
                <scope line="666"/>
                <scope line="668"/>
                <declaration name="avail" type="int" line="672"/>
                <scope line="673">
                    <scope line="679"/>
                    <scope line="688"/>
                </scope>
                <declaration name="cnt" type="int" line="692"/>
            </method>
            <javadoc line="699">
                Returns the number of bytes that can be read from this input
                  stream without blocking.                
                <return>
                    the number of bytes that can be read from this input
                      stream without blocking.                    
                </return>
                <exception>
                    IOException  if an I/O error occurs.                    
                </exception>
                <see>
                    java.io.FilterInputStream#in                    
                </see>
            </javadoc>
            <method name="available" type="int" line="708">
                <declaration name="avail" type="int" line="711"/>
                <scope line="712"/>
                <scope line="718"/>
                <scope line="720"/>
            </method>
            <javadoc line="725">
                Close the stream by either returning the connection to the
                  keep alive cache or closing the underlying stream.
                  &lt;p&gt;
                  If the chunked response hasn&apos;t been completely read we
                  try to &quot;hurry&quot; to the end of the response. If this is
                  possible (without blocking) then the connection can be
                  returned to the keep alive cache.                
                <exception>
                    IOException  if an I/O error occurs.                    
                </exception>
            </javadoc>
            <method name="close" type="void" line="736">
                <scope line="737"/>
            </method>
            <javadoc line="744">
                Hurry the input stream by reading everything from the underlying
                  stream. If the last chunk (and optional trailers) can be read without
                  blocking then the stream is considered hurried.
                  &lt;p&gt;
                  Note that if an error has occured or we can&apos;t get to last chunk
                  without blocking then this stream can&apos;t be hurried and should be
                  closed.                
            </javadoc>
            <method name="hurry" type="boolean" line="753">
                <scope line="754"/>
                <scope line="758"/>
                <scope line="760"/>
                <scope line="764"/>
            </method>
        </class>
    </source>