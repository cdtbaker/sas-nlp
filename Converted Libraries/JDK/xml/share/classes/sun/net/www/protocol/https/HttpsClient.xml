<?xml version="1.0" encoding="UTF-8"?>
    <source package="sun.net.www.protocol.https">
        <import package="java.io.IOException"/>
        <import package="java.io.UnsupportedEncodingException"/>
        <import package="java.io.PrintStream"/>
        <import package="java.io.BufferedOutputStream"/>
        <import package="java.net.Socket"/>
        <import package="java.net.SocketException"/>
        <import package="java.net.URL"/>
        <import package="java.net.UnknownHostException"/>
        <import package="java.net.InetSocketAddress"/>
        <import package="java.net.Proxy"/>
        <import package="java.net.CookieHandler"/>
        <import package="java.security.Principal"/>
        <import package="java.security.cert"/>
        <import package="java.util.StringTokenizer"/>
        <import package="java.util.Vector"/>
        <import package="java.security.AccessController"/>
        <import package="javax.security.auth.x500.X500Principal"/>
        <import package="javax.net.ssl"/>
        <import package="sun.net.www.http.HttpClient"/>
        <import package="sun.security.action"/>
        <import package="sun.security.util.HostnameChecker"/>
        <import package="sun.security.ssl.SSLSocketImpl"/>
        <class name="HttpsClient" line="24">
            <extends class="HttpClient"/>
            <implements interface="HandshakeCompletedListener"/>
            <javadoc line="24">
                This class provides HTTPS client URL support, building on the standard
                  &quot;sun.net.www&quot; HTTP protocol handler.  HTTPS is the same protocol as HTTP,
                  but differs in the transport layer which it uses:  &lt;UL&gt;
                  &lt;LI&gt;There&apos;s a &lt;em&gt;Secure Sockets Layer&lt;/em&gt; between TCP
                  and the HTTP protocol code.
                  &lt;LI&gt;It uses a different default TCP port.
                  &lt;LI&gt;It doesn&apos;t use application level proxies, which can see and
                  manipulate HTTP user level data, compromising privacy.  It uses
                  low level tunneling instead, which hides HTTP protocol and data
                  from all third parties.  (Traffic analysis is still possible).
                  &lt;LI&gt;It does basic server authentication, to protect
                  against &quot;URL spoofing&quot; attacks.  This involves deciding
                  whether the X.509 certificate chain identifying the server
                  is trusted, and verifying that the name of the server is
                  found in the certificate.  (The application may enable an
                  anonymous SSL cipher suite, and such checks are not done
                  for anonymous ciphers.)
                  &lt;LI&gt;It exposes key SSL session attributes, specifically the
                  cipher suite in use and the server&apos;s X509 certificates, to
                  application software which knows about this protocol handler.
                  &lt;/UL&gt;
                  &lt;P&gt; System properties used include:  &lt;UL&gt;
                  &lt;LI&gt;&lt;em&gt;https.proxyHost&lt;/em&gt; ... the host supporting SSL
                  tunneling using the conventional CONNECT syntax
                  &lt;LI&gt;&lt;em&gt;https.proxyPort&lt;/em&gt; ... port to use on proxyHost
                  &lt;LI&gt;&lt;em&gt;https.cipherSuites&lt;/em&gt; ... comma separated list of
                  SSL cipher suite names to enable.
                  &lt;LI&gt;&lt;em&gt;http.nonProxyHosts&lt;/em&gt; ...
                  &lt;/UL&gt;                
                <author>
                    David Brownell                    
                </author>
                <author>
                    Bill Foote                    
                </author>
            </javadoc>
            <declaration name="httpsPortNumber" type="int" line="58"/>
            <declaration name="defaultHVCanonicalName" type="String" line="59"/>
            <javadoc line="60">
                Returns the default HTTPS port (443)                
            </javadoc>
            <method name="getDefaultPort" type="int" line="63"/>
            <declaration name="hv" type="HostnameVerifier" line="66"/>
            <declaration name="sslSocketFactory" type="SSLSocketFactory" line="67"/>
            <declaration name="session" type="SSLSession" line="68"/>
            <method name="getCipherSuites" type="String[]" line="69">
                <declaration name="ciphers" type="String" line="70"/>
                <declaration name="cipherString" type="String" line="71"/>
                <scope line="72"/>
                <scope line="75">
                    <declaration name="tokenizer" type="StringTokenizer" line="76"/>
                    <declaration name="v" type="Vector&lt;String&gt;" line="77"/>
                </scope>
            </method>
            <method name="getProtocols" type="String[]" line="85">
                <declaration name="protocols" type="String" line="86"/>
                <declaration name="protocolString" type="String" line="87"/>
                <scope line="88"/>
                <scope line="91">
                    <declaration name="tokenizer" type="StringTokenizer" line="92"/>
                    <declaration name="v" type="Vector&lt;String&gt;" line="93"/>
                    <scope line="97"/>
                </scope>
            </method>
            <method name="getUserAgent" type="String" line="103">
                <declaration name="userAgent" type="String" line="104"/>
                <scope line="105"/>
            </method>
            <method name="newHttpProxy" type="Proxy" line="110">
                <params>
                    <param name="proxyHost" type="String"/>
                    <param name="proxyPort" type="int"/>
                </params>
                <declaration name="saddr" type="InetSocketAddress" line="111"/>
                <declaration name="phost" type="String" line="112"/>
                <declaration name="pport" type="int" line="113"/>
                <scope line="114">
                    <anonymous_class line="115">
                        <method name="run" type="InetSocketAddress" line="116"/>
                    </anonymous_class>
                </scope>
                <scope line="122"/>
            </method>
            <javadoc line="126">
                Create an HTTPS client URL.  Traffic will be tunneled through any
                  intermediate nodes rather than proxied, so that confidentiality
                  of data exchanged can be preserved.  However, note that all the
                  anonymous SSL flavors are subject to &quot;person-in-the-middle&quot;
                  attacks against confidentiality.  If you enable use of those
                  flavors, you may be giving up the protection you get through
                  SSL tunneling.
                  Use New to get new HttpsClient. This constructor is meant to be
                  used only by New method. New properly checks for URL spoofing.                
                <param>
                    URL https URL with which a connection must be established                    
                </param>
            </javadoc>
            <method name="HttpsClient" type="constructor" line="138">
                <params>
                    <param name="sf" type="SSLSocketFactory"/>
                    <param name="url" type="URL"/>
                </params>
            </method>
            <javadoc line="141">
                Create an HTTPS client URL.  Traffic will be tunneled through
                  the specified proxy server.                
            </javadoc>
            <method name="HttpsClient" type="constructor" line="145">
                <params>
                    <param name="sf" type="SSLSocketFactory"/>
                    <param name="url" type="URL"/>
                    <param name="proxyHost" type="String"/>
                    <param name="proxyPort" type="int"/>
                </params>
            </method>
            <javadoc line="148">
                Create an HTTPS client URL.  Traffic will be tunneled through
                  the specified proxy server, with a connect timeout                
            </javadoc>
            <method name="HttpsClient" type="constructor" line="152">
                <params>
                    <param name="sf" type="SSLSocketFactory"/>
                    <param name="url" type="URL"/>
                    <param name="proxyHost" type="String"/>
                    <param name="proxyPort" type="int"/>
                    <param name="connectTimeout" type="int"/>
                </params>
            </method>
            <javadoc line="155">
                Same as previous constructor except using a Proxy                
            </javadoc>
            <method name="HttpsClient" type="constructor" line="158">
                <params>
                    <param name="sf" type="SSLSocketFactory"/>
                    <param name="url" type="URL"/>
                    <param name="proxy" type="Proxy"/>
                    <param name="connectTimeout" type="int"/>
                </params>
                <scope line="165"/>
                <anonymous_class line="169">
                    <method name="run" type="CookieHandler" line="170"/>
                </anonymous_class>
            </method>
            <method name="New" type="HttpClient" line="177">
                <params>
                    <param name="sf" type="SSLSocketFactory"/>
                    <param name="url" type="URL"/>
                    <param name="hv" type="HostnameVerifier"/>
                </params>
            </method>
            <javadoc line="180">
                See HttpClient for the model for this method.                
            </javadoc>
            <method name="New" type="HttpClient" line="183">
                <params>
                    <param name="sf" type="SSLSocketFactory"/>
                    <param name="url" type="URL"/>
                    <param name="hv" type="HostnameVerifier"/>
                    <param name="useCache" type="boolean"/>
                </params>
            </method>
            <javadoc line="186">
                Get a HTTPS client to the URL.  Traffic will be tunneled through
                  the specified proxy server.                
            </javadoc>
            <method name="New" type="HttpClient" line="190">
                <params>
                    <param name="sf" type="SSLSocketFactory"/>
                    <param name="url" type="URL"/>
                    <param name="hv" type="HostnameVerifier"/>
                    <param name="proxyHost" type="String"/>
                    <param name="proxyPort" type="int"/>
                </params>
            </method>
            <method name="New" type="HttpClient" line="193">
                <params>
                    <param name="sf" type="SSLSocketFactory"/>
                    <param name="url" type="URL"/>
                    <param name="hv" type="HostnameVerifier"/>
                    <param name="proxyHost" type="String"/>
                    <param name="proxyPort" type="int"/>
                    <param name="useCache" type="boolean"/>
                </params>
            </method>
            <method name="New" type="HttpClient" line="196">
                <params>
                    <param name="sf" type="SSLSocketFactory"/>
                    <param name="url" type="URL"/>
                    <param name="hv" type="HostnameVerifier"/>
                    <param name="proxyHost" type="String"/>
                    <param name="proxyPort" type="int"/>
                    <param name="useCache" type="boolean"/>
                    <param name="connectTimeout" type="int"/>
                </params>
            </method>
            <method name="New" type="HttpClient" line="199">
                <params>
                    <param name="sf" type="SSLSocketFactory"/>
                    <param name="url" type="URL"/>
                    <param name="hv" type="HostnameVerifier"/>
                    <param name="p" type="Proxy"/>
                    <param name="useCache" type="boolean"/>
                    <param name="connectTimeout" type="int"/>
                </params>
                <declaration name="ret" type="HttpsClient" line="200"/>
                <scope line="201">
                    <scope line="203"/>
                </scope>
                <scope line="207"/>
                <scope line="210">
                    <declaration name="security" type="SecurityManager" line="211"/>
                    <scope line="212"/>
                </scope>
            </method>
            <method name="setHostnameVerifier" type="void" line="220">
                <params>
                    <param name="hv" type="HostnameVerifier"/>
                </params>
            </method>
            <method name="setSSLSocketFactory" type="void" line="223">
                <params>
                    <param name="sf" type="SSLSocketFactory"/>
                </params>
            </method>
            <method name="getSSLSocketFactory" type="SSLSocketFactory" line="226"/>
            <javadoc line="229">
                The following method, createSocket, is defined in NetworkClient
                  and overridden here so that the socket facroty is used to create
                  new sockets.                
            </javadoc>
            <method name="createSocket" type="Socket" line="234">
                <scope line="235"/>
                <scope line="238">
                    <declaration name="t" type="Throwable" line="239"/>
                    <scope line="240"/>
                    <scope line="243"/>
                </scope>
            </method>
            <method name="needsTunneling" type="boolean" line="248"/>
            <method name="afterConnect" type="void" line="251">
                <scope line="252">
                    <declaration name="s" type="SSLSocket" line="253"/>
                    <declaration name="factory" type="SSLSocketFactory" line="254"/>
                    <scope line="255">
                        <scope line="256"/>
                        <scope line="259">
                            <scope line="261"/>
                        </scope>
                    </scope>
                    <scope line="266">
                        <scope line="267"/>
                        <scope line="270"/>
                    </scope>
                    <declaration name="protocols" type="String[]" line="274"/>
                    <declaration name="ciphers" type="String[]" line="275"/>
                    <scope line="276"/>
                    <scope line="279"/>
                    <declaration name="needToCheckSpoofing" type="boolean" line="283"/>
                    <declaration name="identification" type="String" line="284"/>
                    <scope line="285">
                        <scope line="286"/>
                    </scope>
                    <scope line="290">
                        <declaration name="isDefaultHostnameVerifier" type="boolean" line="291"/>
                        <scope line="292">
                            <declaration name="canonicalName" type="String" line="293"/>
                            <scope line="294"/>
                        </scope>
                        <scope line="298"/>
                        <scope line="301">
                            <declaration name="paramaters" type="SSLParameters" line="302"/>
                        </scope>
                    </scope>
                    <scope line="311"/>
                    <scope line="314"/>
                    <scope line="317"/>
                </scope>
                <scope line="321"/>
            </method>
            <method name="checkURLSpoofing" type="void" line="325">
                <params>
                    <param name="hostnameVerifier" type="HostnameVerifier"/>
                </params>
                <declaration name="host" type="String" line="326"/>
                <scope line="327"/>
                <declaration name="peerCerts" type="Certificate[]" line="330"/>
                <declaration name="cipher" type="String" line="331"/>
                <scope line="332">
                    <declaration name="checker" type="HostnameChecker" line="333"/>
                    <scope line="334">
                        <scope line="335"/>
                    </scope>
                    <scope line="339">
                        <declaration name="peerCert" type="X509Certificate" line="341"/>
                        <scope line="342"/>
                        <scope line="345"/>
                    </scope>
                </scope>
                <scope line="352"/>
                <scope line="354"/>
                <scope line="356"/>
                <scope line="359"/>
            </method>
            <method name="putInKeepAliveCache" type="void" line="366"/>
            <method name="closeIdleConnection" type="void" line="369">
                <declaration name="http" type="HttpClient" line="370"/>
                <scope line="371"/>
            </method>
            <javadoc line="375">
                Returns the cipher suite in use on this connection.                
            </javadoc>
            <method name="getCipherSuite" type="String" line="378"/>
            <javadoc line="381">
                Returns the certificate chain the client sent to the
                  server, or null if the client did not authenticate.                
            </javadoc>
            <method name="getLocalCertificates" type="java.security.cert.Certificate[]" line="385"/>
            <javadoc line="388">
                Returns the certificate chain with which the server
                  authenticated itself, or throw a SSLPeerUnverifiedException
                  if the server did not authenticate.                
            </javadoc>
            <method name="getServerCertificates" type="java.security.cert.Certificate[]" line="393"/>
            <javadoc line="396">
                Returns the X.509 certificate chain with which the server
                  authenticated itself, or null if the server did not authenticate.                
            </javadoc>
            <method name="getServerCertificateChain" type="javax.security.cert.X509Certificate[]" line="400"/>
            <javadoc line="403">
                Returns the principal with which the server authenticated
                  itself, or throw a SSLPeerUnverifiedException if the
                  server did not authenticate.                
            </javadoc>
            <method name="getPeerPrincipal" type="Principal" line="408">
                <declaration name="principal" type="Principal" line="409"/>
                <scope line="410"/>
                <scope line="413">
                    <declaration name="certs" type="java.security.cert.Certificate[]" line="414"/>
                </scope>
            </method>
            <javadoc line="419">
                Returns the principal the client sent to the
                  server, or null if the client did not authenticate.                
            </javadoc>
            <method name="getLocalPrincipal" type="Principal" line="423">
                <declaration name="principal" type="Principal" line="424"/>
                <scope line="425"/>
                <scope line="428">
                    <declaration name="certs" type="java.security.cert.Certificate[]" line="430"/>
                    <scope line="431"/>
                </scope>
            </method>
            <javadoc line="437">
                This method implements the SSL HandshakeCompleted callback,
                  remembering the resulting session so that it may be queried
                  for the current cipher suite and peer certificates.  Servers
                  sometimes re-initiate handshaking, so the session in use on
                  a given connection may change.  When sessions change, so may
                  peer identities and cipher suites.                
            </javadoc>
            <method name="handshakeCompleted" type="void" line="445">
                <params>
                    <param name="event" type="HandshakeCompletedEvent"/>
                </params>
            </method>
            <javadoc line="448">
                @return the proxy host being used for this client, or null
                  if we&apos;re not going through a proxy                
            </javadoc>
            <method name="getProxyHostUsed" type="String" line="452">
                <scope line="453"/>
                <scope line="456"/>
            </method>
            <javadoc line="460">
                @return the proxy port being used for this client.  Meaningless
                  if getProxyHostUsed() gives null.                
            </javadoc>
            <method name="getProxyPortUsed" type="int" line="464"/>
        </class>
    </source>