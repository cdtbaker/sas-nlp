<?xml version="1.0" encoding="UTF-8"?>
    <source package="sun.net.www.protocol.https">
        <import package="java.io.IOException"/>
        <import package="java.io.UnsupportedEncodingException"/>
        <import package="java.io.PrintStream"/>
        <import package="java.io.BufferedOutputStream"/>
        <import package="java.net.Socket"/>
        <import package="java.net.SocketException"/>
        <import package="java.net.URL"/>
        <import package="java.net.UnknownHostException"/>
        <import package="java.net.InetSocketAddress"/>
        <import package="java.net.Proxy"/>
        <import package="java.net.CookieHandler"/>
        <import package="java.security.Principal"/>
        <import package="java.security.cert"/>
        <import package="java.util.StringTokenizer"/>
        <import package="java.util.Vector"/>
        <import package="java.security.AccessController"/>
        <import package="javax.security.auth.x500.X500Principal"/>
        <import package="javax.net.ssl"/>
        <import package="sun.net.www.http.HttpClient"/>
        <import package="sun.security.action"/>
        <import package="sun.security.util.HostnameChecker"/>
        <import package="sun.security.ssl.SSLSocketImpl"/>
        <class name="HttpsClient" line="56">
            <extends class="HttpClient"/>
            <comment line="104">
                final for export control reasons (access to APIs); remove with care                
            </comment>
            <comment line="108">
                STATIC STATE and ACCESSORS THERETO                
            </comment>
            <comment line="110">
                HTTPS uses a different default port number than HTTP.                
            </comment>
            <comment line="113">
                default HostnameVerifier class canonical name                
            </comment>
            <comment line="124">
                HttpClient.proxyDisabled will always be false, because we don&apos;t
                 use an application-level HTTP proxy.  We might tunnel through
                 our http proxy, though.                
            </comment>
            <comment line="129">
                INSTANCE DATA                
            </comment>
            <comment line="131">
                last negotiated SSL session                
            </comment>
            <comment line="192">
                should remove once HttpClient.newHttpProxy is putback                
            </comment>
            <comment line="208">
                CONSTRUCTOR, FACTORY                
            </comment>
            <comment line="283">
                This code largely ripped off from HttpClient.New, and
                 it uses the same keepalive cache.                
            </comment>
            <comment line="349">
                METHODS                
            </comment>
            <comment line="548">
                Server identity checking is done according to RFC 2818: HTTP over TLS
                 Section 3.1 Server Identity                
            </comment>
            <comment line="622">
                Close an idle connection to this URL (if it exists in the cache).                
            </comment>
            <implements interface="HandshakeCompletedListener"/>
            <javadoc line="56">
                This class provides HTTPS client URL support, building on the standard
                  &quot;sun.net.www&quot; HTTP protocol handler.  HTTPS is the same protocol as HTTP,
                  but differs in the transport layer which it uses:  &lt;UL&gt;
                  &lt;LI&gt;There&apos;s a &lt;em&gt;Secure Sockets Layer&lt;/em&gt; between TCP
                  and the HTTP protocol code.
                  &lt;LI&gt;It uses a different default TCP port.
                  &lt;LI&gt;It doesn&apos;t use application level proxies, which can see and
                  manipulate HTTP user level data, compromising privacy.  It uses
                  low level tunneling instead, which hides HTTP protocol and data
                  from all third parties.  (Traffic analysis is still possible).
                  &lt;LI&gt;It does basic server authentication, to protect
                  against &quot;URL spoofing&quot; attacks.  This involves deciding
                  whether the X.509 certificate chain identifying the server
                  is trusted, and verifying that the name of the server is
                  found in the certificate.  (The application may enable an
                  anonymous SSL cipher suite, and such checks are not done
                  for anonymous ciphers.)
                  &lt;LI&gt;It exposes key SSL session attributes, specifically the
                  cipher suite in use and the server&apos;s X509 certificates, to
                  application software which knows about this protocol handler.
                  &lt;/UL&gt;
                  &lt;P&gt; System properties used include:  &lt;UL&gt;
                  &lt;LI&gt;&lt;em&gt;https.proxyHost&lt;/em&gt; ... the host supporting SSL
                  tunneling using the conventional CONNECT syntax
                  &lt;LI&gt;&lt;em&gt;https.proxyPort&lt;/em&gt; ... port to use on proxyHost
                  &lt;LI&gt;&lt;em&gt;https.cipherSuites&lt;/em&gt; ... comma separated list of
                  SSL cipher suite names to enable.
                  &lt;LI&gt;&lt;em&gt;http.nonProxyHosts&lt;/em&gt; ...
                  &lt;/UL&gt;                
                <author>
                    David Brownell                    
                </author>
                <author>
                    Bill Foote                    
                </author>
            </javadoc>
            <declaration name="httpsPortNumber" type="int" line="110"/>
            <declaration name="defaultHVCanonicalName" type="String" line="113"/>
            <javadoc line="116">
                Returns the default HTTPS port (443)                
            </javadoc>
            <method name="getDefaultPort" type="int" line="118"/>
            <declaration name="hv" type="HostnameVerifier" line="120"/>
            <declaration name="sslSocketFactory" type="SSLSocketFactory" line="121"/>
            <declaration name="session" type="SSLSession" line="131"/>
            <method name="getCipherSuites" type="String[]" line="133">
                <comment line="135">
                    If ciphers are assigned, sort them into an array.                    
                </comment>
                <declaration name="ciphers" type="String" line="137"/>
                <declaration name="cipherString" type="String" line="138"/>
                <scope line="141"/>
                <scope line="143">
                    <declaration name="tokenizer" type="StringTokenizer" line="144"/>
                    <declaration name="v" type="Vector&lt;String&gt;" line="145"/>
                </scope>
            </method>
            <method name="getProtocols" type="String[]" line="157">
                <comment line="159">
                    If protocols are assigned, sort them into an array.                    
                </comment>
                <declaration name="protocols" type="String" line="161"/>
                <declaration name="protocolString" type="String" line="162"/>
                <scope line="165"/>
                <scope line="167">
                    <declaration name="tokenizer" type="StringTokenizer" line="168"/>
                    <declaration name="v" type="Vector&lt;String&gt;" line="169"/>
                    <scope line="175"/>
                </scope>
            </method>
            <method name="getUserAgent" type="String" line="182">
                <declaration name="userAgent" type="String" line="183"/>
                <scope line="185"/>
            </method>
            <method name="newHttpProxy" type="Proxy" line="192">
                <params>
                    <param name="proxyHost" type="String"/>
                    <param name="proxyPort" type="int"/>
                </params>
                <declaration name="saddr" type="InetSocketAddress" line="193"/>
                <declaration name="phost" type="String" line="194"/>
                <declaration name="pport" type="int" line="195"/>
                <scope line="196">
                    <anonymous_class line="198">
                        <method name="run" type="InetSocketAddress" line="199"/>
                    </anonymous_class>
                </scope>
                <scope line="202"/>
            </method>
            <javadoc line="210">
                Create an HTTPS client URL.  Traffic will be tunneled through any
                  intermediate nodes rather than proxied, so that confidentiality
                  of data exchanged can be preserved.  However, note that all the
                  anonymous SSL flavors are subject to &quot;person-in-the-middle&quot;
                  attacks against confidentiality.  If you enable use of those
                  flavors, you may be giving up the protection you get through
                  SSL tunneling.
                  Use New to get new HttpsClient. This constructor is meant to be
                  used only by New method. New properly checks for URL spoofing.                
                <param>
                    URL https URL with which a connection must be established                    
                </param>
            </javadoc>
            <method name="HttpsClient" type="constructor" line="226">
                <params>
                    <param name="sf" type="SSLSocketFactory"/>
                    <param name="url" type="URL"/>
                </params>
                <comment line="228">
                    HttpClient-level proxying is always disabled,
                     because we override doConnect to do tunneling instead.                    
                </comment>
            </method>
            <javadoc line="232">
                Create an HTTPS client URL.  Traffic will be tunneled through
                  the specified proxy server.                
            </javadoc>
            <method name="HttpsClient" type="constructor" line="237">
                <params>
                    <param name="sf" type="SSLSocketFactory"/>
                    <param name="url" type="URL"/>
                    <param name="proxyHost" type="String"/>
                    <param name="proxyPort" type="int"/>
                </params>
            </method>
            <javadoc line="241">
                Create an HTTPS client URL.  Traffic will be tunneled through
                  the specified proxy server, with a connect timeout                
            </javadoc>
            <method name="HttpsClient" type="constructor" line="247">
                <params>
                    <param name="sf" type="SSLSocketFactory"/>
                    <param name="url" type="URL"/>
                    <param name="proxyHost" type="String"/>
                    <param name="proxyPort" type="int"/>
                    <param name="connectTimeout" type="int"/>
                </params>
            </method>
            <javadoc line="254">
                Same as previous constructor except using a Proxy                
            </javadoc>
            <method name="HttpsClient" type="constructor" line="259">
                <params>
                    <param name="sf" type="SSLSocketFactory"/>
                    <param name="url" type="URL"/>
                    <param name="proxy" type="Proxy"/>
                    <param name="connectTimeout" type="int"/>
                </params>
                <comment line="272">
                    get the cookieHandler if there is any                    
                </comment>
                <scope line="267"/>
                <anonymous_class line="273">
                    <method name="run" type="CookieHandler" line="274"/>
                </anonymous_class>
            </method>
            <method name="New" type="HttpClient" line="286">
                <params>
                    <param name="sf" type="SSLSocketFactory"/>
                    <param name="url" type="URL"/>
                    <param name="hv" type="HostnameVerifier"/>
                </params>
            </method>
            <javadoc line="290">
                See HttpClient for the model for this method.                
            </javadoc>
            <method name="New" type="HttpClient" line="292">
                <params>
                    <param name="sf" type="SSLSocketFactory"/>
                    <param name="url" type="URL"/>
                    <param name="hv" type="HostnameVerifier"/>
                    <param name="useCache" type="boolean"/>
                </params>
            </method>
            <javadoc line="296">
                Get a HTTPS client to the URL.  Traffic will be tunneled through
                  the specified proxy server.                
            </javadoc>
            <method name="New" type="HttpClient" line="301">
                <params>
                    <param name="sf" type="SSLSocketFactory"/>
                    <param name="url" type="URL"/>
                    <param name="hv" type="HostnameVerifier"/>
                    <param name="proxyHost" type="String"/>
                    <param name="proxyPort" type="int"/>
                </params>
            </method>
            <method name="New" type="HttpClient" line="307">
                <params>
                    <param name="sf" type="SSLSocketFactory"/>
                    <param name="url" type="URL"/>
                    <param name="hv" type="HostnameVerifier"/>
                    <param name="proxyHost" type="String"/>
                    <param name="proxyPort" type="int"/>
                    <param name="useCache" type="boolean"/>
                </params>
            </method>
            <method name="New" type="HttpClient" line="314">
                <params>
                    <param name="sf" type="SSLSocketFactory"/>
                    <param name="url" type="URL"/>
                    <param name="hv" type="HostnameVerifier"/>
                    <param name="proxyHost" type="String"/>
                    <param name="proxyPort" type="int"/>
                    <param name="useCache" type="boolean"/>
                    <param name="connectTimeout" type="int"/>
                </params>
            </method>
            <method name="New" type="HttpClient" line="325">
                <params>
                    <param name="sf" type="SSLSocketFactory"/>
                    <param name="url" type="URL"/>
                    <param name="hv" type="HostnameVerifier"/>
                    <param name="p" type="Proxy"/>
                    <param name="useCache" type="boolean"/>
                    <param name="connectTimeout" type="int"/>
                </params>
                <comment line="329">
                                        
                </comment>
                <declaration name="ret" type="HttpsClient" line="326"/>
                <scope line="327">
                    <scope line="330"/>
                </scope>
                <scope line="334"/>
                <scope line="336">
                    <declaration name="security" type="SecurityManager" line="337"/>
                    <scope line="338"/>
                </scope>
            </method>
            <method name="setHostnameVerifier" type="void" line="349">
                <params>
                    <param name="hv" type="HostnameVerifier"/>
                </params>
            </method>
            <method name="setSSLSocketFactory" type="void" line="353">
                <params>
                    <param name="sf" type="SSLSocketFactory"/>
                </params>
            </method>
            <method name="getSSLSocketFactory" type="SSLSocketFactory" line="357"/>
            <javadoc line="361">
                The following method, createSocket, is defined in NetworkClient
                  and overridden here so that the socket facroty is used to create
                  new sockets.                
            </javadoc>
            <method name="createSocket" type="Socket" line="367">
                <comment line="372">
                    bug 6771432
                     javax.net.SocketFactory throws a SocketException with an
                     UnsupportedOperationException as its cause to indicate that
                     unconnected sockets have not been implemented.                    
                </comment>
                <scope line="368"/>
                <scope line="370">
                    <declaration name="t" type="Throwable" line="377"/>
                    <scope line="378"/>
                    <scope line="380"/>
                </scope>
            </method>
            <method name="needsTunneling" type="boolean" line="388"/>
            <method name="afterConnect" type="void" line="394">
                <comment line="410">
                    If we fail to connect through the tunnel, try it
                     locally, as a last resort.  If this doesn&apos;t work,
                     throw the original exception.                    
                </comment>
                <comment line="420">
                    Force handshaking, so that we get any authentication.
                     Register a handshake callback so our session state tracks any
                     later session renegotiations.                    
                </comment>
                <comment line="435">
                    We have two hostname verification approaches. One is in
                     SSL/TLS socket layer, where the algorithm is configured with
                     SSLParameters.setEndpointIdentificationAlgorithm(), and the
                     hostname verification is done by X509ExtendedTrustManager when
                     the algorithm is &quot;HTTPS&quot;. The other one is in HTTPS layer,
                     where the algorithm is customized by
                     HttpsURLConnection.setHostnameVerifier(), and the hostname
                     verification is done by HostnameVerifier when the default
                     rules for hostname verification fail.
                    
                     The relationship between two hostname verification approaches
                     likes the following:
                    
                                   |             EIA algorithm
                                   +----------------------------------------------
                                   |     null      |   HTTPS    |   LDAP/other   |
                     -------------------------------------------------------------
                         |         |1              |2           |3               |
                     HNV | default | Set HTTPS EIA | use EIA    | HTTPS          |
                         |--------------------------------------------------------
                         | non -   |4              |5           |6               |
                         | default | HTTPS/HNV     | use EIA    | HTTPS/HNV      |
                     -------------------------------------------------------------
                    
                     Abbreviation:
                         EIA: the endpoint identification algorithm in SSL/TLS
                               socket layer
                         HNV: the hostname verification object in HTTPS layer
                     Notes:
                         case 1. default HNV and EIA is null
                               Set EIA as HTTPS, hostname check done in SSL/TLS
                               layer.
                         case 2. default HNV and EIA is HTTPS
                               Use existing EIA, hostname check done in SSL/TLS
                               layer.
                         case 3. default HNV and EIA is other than HTTPS
                               Use existing EIA, EIA check done in SSL/TLS
                               layer, then do HTTPS check in HTTPS layer.
                         case 4. non-default HNV and EIA is null
                               No EIA, no EIA check done in SSL/TLS layer, then do
                               HTTPS check in HTTPS layer using HNV as override.
                         case 5. non-default HNV and EIA is HTTPS
                               Use existing EIA, hostname check done in SSL/TLS
                               layer. No HNV override possible. We will review this
                               decision and may update the architecture for JDK 7.
                         case 6. non-default HNV and EIA is other than HTTPS
                               Use existing EIA, EIA check done in SSL/TLS layer,
                               then do HTTPS check in HTTPS layer as override.                    
                </comment>
                <comment line="488">
                    Do not check server identity again out of SSLSocket,
                     the endpoint will be identified during TLS handshaking
                     in SSLSocket.                    
                </comment>
                <comment line="492">
                    else, we don&apos;t understand the identification algorithm,
                     need to check URL spoofing here.                    
                </comment>
                <comment line="497">
                    We prefer to let the SSLSocket do the spoof checks, but if
                     the application has specified a HostnameVerifier (HNV),
                     we will always use that.                    
                </comment>
                <comment line="507">
                    Unlikely to happen! As the behavior is the same as the
                     default hostname verifier, so we prefer to let the
                     SSLSocket do the spoof checks.                    
                </comment>
                <comment line="514">
                    If the HNV is the default from HttpsURLConnection, we
                     will do the spoof checks in SSLSocket.                    
                </comment>
                <comment line="526">
                    change the serverSocket and serverOutput                    
                </comment>
                <comment line="536">
                    check URL spoofing if it has not been checked under handshaking                    
                </comment>
                <comment line="541">
                    if we are reusing a cached https session,
                     we don&apos;t need to do handshaking etc. But we do need to
                     set the ssl session                    
                </comment>
                <scope line="395">
                    <declaration name="s" type="SSLSocket" line="396"/>
                    <declaration name="factory" type="SSLSocketFactory" line="397"/>
                    <scope line="398">
                        <scope line="399"/>
                        <scope line="402">
                            <scope line="404"/>
                        </scope>
                    </scope>
                    <scope line="408">
                        <scope line="412"/>
                        <scope line="414"/>
                    </scope>
                    <declaration name="protocols" type="String[]" line="424"/>
                    <declaration name="ciphers" type="String[]" line="425"/>
                    <scope line="426"/>
                    <scope line="429"/>
                    <declaration name="needToCheckSpoofing" type="boolean" line="482"/>
                    <declaration name="identification" type="String" line="483"/>
                    <scope line="485">
                        <scope line="486"/>
                    </scope>
                    <scope line="493">
                        <declaration name="isDefaultHostnameVerifier" type="boolean" line="494"/>
                        <scope line="499">
                            <declaration name="canonicalName" type="String" line="500"/>
                            <scope line="502"/>
                        </scope>
                        <scope line="505"/>
                        <scope line="512">
                            <declaration name="paramaters" type="SSLParameters" line="515"/>
                        </scope>
                    </scope>
                    <scope line="527"/>
                    <scope line="531"/>
                    <scope line="536"/>
                </scope>
                <scope line="539"/>
            </method>
            <method name="checkURLSpoofing" type="void" line="550">
                <params>
                    <param name="hostnameVerifier" type="HostnameVerifier"/>
                </params>
                <comment line="552">
                    Get authenticated server name, if any                    
                </comment>
                <comment line="557">
                    if IPv6 strip off the &quot;[]&quot;                    
                </comment>
                <comment line="568">
                    Use ciphersuite to determine whether Kerberos is present.                    
                </comment>
                <comment line="574">
                    X.509                    
                </comment>
                <comment line="576">
                    get the subject&apos;s certificate                    
                </comment>
                <comment line="589">
                    if it doesn&apos;t throw an exception, we passed. Return.                    
                </comment>
                <comment line="594">
                    client explicitly changed default policy and enabled
                     anonymous ciphers; we can&apos;t check the standard policy
                    
                     ignore                    
                </comment>
                <comment line="600">
                    ignore                    
                </comment>
                <declaration name="host" type="String" line="554"/>
                <scope line="557"/>
                <declaration name="peerCerts" type="Certificate[]" line="561"/>
                <declaration name="cipher" type="String" line="562"/>
                <scope line="563">
                    <declaration name="checker" type="HostnameChecker" line="564"/>
                    <scope line="568">
                        <scope line="569"/>
                    </scope>
                    <scope line="573">
                        <declaration name="peerCert" type="X509Certificate" line="578"/>
                        <scope line="580"/>
                        <scope line="582"/>
                    </scope>
                </scope>
                <scope line="591"/>
                <scope line="598"/>
                <scope line="602"/>
                <scope line="605"/>
            </method>
            <method name="putInKeepAliveCache" type="void" line="617"/>
            <method name="closeIdleConnection" type="void" line="625">
                <declaration name="http" type="HttpClient" line="626"/>
                <scope line="627"/>
            </method>
            <javadoc line="632">
                Returns the cipher suite in use on this connection.                
            </javadoc>
            <method name="getCipherSuite" type="String" line="635"/>
            <javadoc line="639">
                Returns the certificate chain the client sent to the
                  server, or null if the client did not authenticate.                
            </javadoc>
            <method name="getLocalCertificates" type="java.security.cert.Certificate[]" line="643"/>
            <javadoc line="647">
                Returns the certificate chain with which the server
                  authenticated itself, or throw a SSLPeerUnverifiedException
                  if the server did not authenticate.                
            </javadoc>
            <method name="getServerCertificates" type="java.security.cert.Certificate[]" line="654"/>
            <javadoc line="658">
                Returns the X.509 certificate chain with which the server
                  authenticated itself, or null if the server did not authenticate.                
            </javadoc>
            <method name="getServerCertificateChain" type="javax.security.cert.X509Certificate[]" line="664"/>
            <javadoc line="668">
                Returns the principal with which the server authenticated
                  itself, or throw a SSLPeerUnverifiedException if the
                  server did not authenticate.                
            </javadoc>
            <method name="getPeerPrincipal" type="Principal" line="675">
                <comment line="681">
                    if the provider does not support it, fallback to peer certs.
                     return the X500Principal of the end-entity cert.                    
                </comment>
                <declaration name="principal" type="Principal" line="676"/>
                <scope line="677"/>
                <scope line="679">
                    <declaration name="certs" type="java.security.cert.Certificate[]" line="682"/>
                </scope>
            </method>
            <javadoc line="690">
                Returns the principal the client sent to the
                  server, or null if the client did not authenticate.                
            </javadoc>
            <method name="getLocalPrincipal" type="Principal" line="695">
                <comment line="702">
                    if the provider does not support it, fallback to local certs.
                     return the X500Principal of the end-entity cert.                    
                </comment>
                <declaration name="principal" type="Principal" line="696"/>
                <scope line="697"/>
                <scope line="699">
                    <declaration name="certs" type="java.security.cert.Certificate[]" line="703"/>
                    <scope line="705"/>
                </scope>
            </method>
            <javadoc line="713">
                This method implements the SSL HandshakeCompleted callback,
                  remembering the resulting session so that it may be queried
                  for the current cipher suite and peer certificates.  Servers
                  sometimes re-initiate handshaking, so the session in use on
                  a given connection may change.  When sessions change, so may
                  peer identities and cipher suites.                
            </javadoc>
            <method name="handshakeCompleted" type="void" line="722">
                <params>
                    <param name="event" type="HandshakeCompletedEvent"/>
                </params>
            </method>
            <javadoc line="726">
                @return the proxy host being used for this client, or null
                  if we&apos;re not going through a proxy                
            </javadoc>
            <method name="getProxyHostUsed" type="String" line="731">
                <scope line="732"/>
                <scope line="734"/>
            </method>
            <javadoc line="739">
                @return the proxy port being used for this client.  Meaningless
                  if getProxyHostUsed() gives null.                
            </javadoc>
            <method name="getProxyPortUsed" type="int" line="744"/>
        </class>
    </source>