<?xml version="1.0" encoding="UTF-8"?>
    <source package="sun.net.www.http">
        <import package="java.io"/>
        <import package="java.net"/>
        <import package="java.util.Locale"/>
        <import package="sun.net.NetworkClient"/>
        <import package="sun.net.ProgressSource"/>
        <import package="sun.net.www.MessageHeader"/>
        <import package="sun.net.www.HeaderParser"/>
        <import package="sun.net.www.MeteredStream"/>
        <import package="sun.net.www.ParseUtil"/>
        <import package="sun.net.www.protocol.http.HttpURLConnection"/>
        <import package="sun.util.logging.PlatformLogger"/>
        <class name="HttpClient" line="40">
            <extends class="NetworkClient"/>
            <comment line="46">
                whether this httpclient comes from the cache                
            </comment>
            <comment line="53">
                Http requests we send                
            </comment>
            <comment line="56">
                Http data we send with the headers                
            </comment>
            <comment line="59">
                true if we are in streaming mode (fixed length or chunked)                
            </comment>
            <comment line="62">
                if we&apos;ve had one io error                
            </comment>
            <comment line="83">
                All proxying (generic as well as instance-specific) may be
                 disabled through use of this flag                
            </comment>
            <comment line="88">
                are we using proxy in this instance?                
            </comment>
            <comment line="90">
                target host, port for the URL                
            </comment>
            <comment line="94">
                                
            </comment>
            <comment line="99">
                retryPostProp is true by default so as to preserve behavior                
            </comment>
            <comment line="100">
                from previous releases.                
            </comment>
            <comment line="103">
                                
            </comment>
            <comment line="104">
                                
            </comment>
            <comment line="122">
                                
            </comment>
            <comment line="125">
                Traffic capture tool, if configured. See HttpCapture class for info                
            </comment>
            <comment line="182">
                This package-only CTOR should only be used for FTP piggy-backed on HTTP
                 HTTP URL&apos;s that use this won&apos;t take advantage of keep-alive.
                 Additionally, this constructor may be used as a last resort when the
                 first HttpClient gotten through New() failed (probably bc of a
                 Keep-Alive mismatch).
                
                 XXX That documentation is wrong ... it&apos;s not package-private any more                
            </comment>
            <comment line="226">
                This constructor gives &quot;ultimate&quot; flexibility, including the ability
                 to bypass implicit proxying.  Sometimes we need to be using tunneling
                 (transport or network level) instead of proxying (application level),
                 for example when we don&apos;t want the application level data to become
                 visible to third parties.
                
                 @param url               the URL to which we&apos;re connecting
                 @param proxy             proxy to use for this URL (e.g. forwarding)
                 @param proxyPort         proxy port to use for this URL
                 @param proxyDisabled     true to disable default proxying                
            </comment>
            <comment line="252">
                This class has no public constructor for HTTP.  This method is used to
                 get an HttpClient to the specifed URL.  If there&apos;s currently an
                 active HttpClient to that serverport, you&apos;ll get that one.                
            </comment>
            <comment line="332">
                return it to the cache as still usable, if:
                 1) It&apos;s keeping alive, AND
                 2) It still has some connections left, AND
                 3) It hasn&apos;t had a error (PrintStream.checkError())
                 4) It hasn&apos;t timed out
                
                 If this client is not keepingAlive, it should have been
                 removed from the cache in the parseHeaders() method.                
            </comment>
            <comment line="371">
                Close an idle connection to this URL (if it exists in the
                 cache).                
            </comment>
            <comment line="382">
                We&apos;re very particular here about what our InputStream to the server
                 looks like for reasons that are apparent if you can decipher the
                 method parseHTTP().  That&apos;s why this method is overidden from the
                 superclass.                
            </comment>
            <comment line="404">
                Returns true if the http request should be tunneled through proxy.
                 An example where this is the case is Https.                
            </comment>
            <comment line="412">
                Returns true if this httpclient is from cache                
            </comment>
            <comment line="419">
                Finish any work left after the socket connection is
                 established.  In the normal http case, it&apos;s a NO-OP. Subclass
                 may need to override this. An example is Https, where for
                 direct connection to the origin server, ssl handshake needs to
                 be done; for proxy tunneling, the socket needs to be converted
                 into an SSL socket before ssl handshake can take place.                
            </comment>
            <comment line="431">
                call openServer in a privileged block                
            </comment>
            <comment line="450">
                call super.openServer                
            </comment>
            <comment line="460">
                                
            </comment>
            <comment line="910">
                                
            </comment>
            <javadoc line="40">
                @author Herb Jellinek                
                <author>
                    Dave Brown                    
                </author>
            </javadoc>
            <declaration name="cachedHttpClient" type="boolean" line="46"/>
            <declaration name="inCache" type="boolean" line="48"/>
            <declaration name="cookieHandler" type="CookieHandler" line="50"/>
            <declaration name="requests" type="MessageHeader" line="53"/>
            <declaration name="poster" type="PosterOutputStream" line="56"/>
            <declaration name="streaming" type="boolean" line="59"/>
            <declaration name="failedOnce" type="boolean" line="62"/>
            <declaration name="ignoreContinue" type="boolean" line="64"/>
            <javadoc line="64">
                Response code for CONTINUE                
            </javadoc>
            <declaration name="HTTP_CONTINUE" type="int" line="66"/>
            <declaration name="httpPortNumber" type="int" line="68"/>
            <javadoc line="68">
                Default port number for http daemons. REMIND: make these private                
            </javadoc>
            <javadoc line="71">
                return default port number (subclasses may override)                
            </javadoc>
            <method name="getDefaultPort" type="int" line="72"/>
            <method name="getDefaultPort" type="int" line="74">
                <params>
                    <param name="proto" type="String"/>
                </params>
            </method>
            <declaration name="proxyDisabled" type="boolean" line="85"/>
            <declaration name="usingProxy" type="boolean" line="88"/>
            <declaration name="host" type="String" line="90"/>
            <declaration name="port" type="int" line="91"/>
            <declaration name="kac" type="KeepAliveCache" line="94"/>
            <declaration name="keepAliveProp" type="boolean" line="96"/>
            <declaration name="retryPostProp" type="boolean" line="100"/>
            <declaration name="keepingAlive" type="boolean" line="102"/>
            <declaration name="keepAliveConnections" type="int" line="103"/>
            <declaration name="keepAliveTimeout" type="int" line="105"/>
            <javadoc line="105">
                Idle timeout value, in milliseconds. Zero means infinity,
                  iff keepingAlive=true.
                  Unfortunately, we can&apos;t always believe this one.  If I&apos;m connected
                  through a Netscape proxy to a server that sent me a keep-alive
                  time of 15 sec, the proxy unilaterally terminates my connection
                  after 5 sec.  So we have to hard code our effective timeout to
                  4 sec for the case where we&apos;re using a proxy. SIGH                
            </javadoc>
            <declaration name="cacheRequest" type="CacheRequest" line="115"/>
            <javadoc line="115">
                whether the response is to be cached                
            </javadoc>
            <declaration name="url" type="URL" line="118"/>
            <javadoc line="118">
                Url being fetched.                
            </javadoc>
            <declaration name="reuse" type="boolean" line="122"/>
            <declaration name="capture" type="HttpCapture" line="125"/>
            <javadoc line="127">
                A NOP method kept for backwards binary compatibility                
                <deprecated>
                    -- system properties are no longer cached.                    
                </deprecated>
            </javadoc>
            <method name="resetProperties" type="void" line="132"/>
            <method name="getKeepAliveTimeout" type="int" line="135"/>
            <scope line="139">
                <declaration name="keepAlive" type="String" line="140"/>
                <declaration name="retryPost" type="String" line="143"/>
                <scope line="146"/>
                <scope line="148"/>
                <scope line="152"/>
            </scope>
            <javadoc line="159">
                @return true iff http keep alive is set (i.e. enabled).  Defaults
                  to true if the system property http.keepAlive isn&apos;t set.                
            </javadoc>
            <method name="getHttpKeepAliveSet" type="boolean" line="163"/>
            <method name="HttpClient" type="constructor" line="168"/>
            <method name="HttpClient" type="constructor" line="172">
                <params>
                    <param name="url" type="URL"/>
                </params>
            </method>
            <method name="HttpClient" type="constructor" line="177">
                <params>
                    <param name="url" type="URL"/>
                    <param name="proxyDisabled" type="boolean"/>
                </params>
            </method>
            <method name="HttpClient" type="constructor" line="190">
                <params>
                    <param name="url" type="URL"/>
                    <param name="proxyHost" type="String"/>
                    <param name="proxyPort" type="int"/>
                </params>
            </method>
            <method name="HttpClient" type="constructor" line="194">
                <params>
                    <param name="url" type="URL"/>
                    <param name="p" type="Proxy"/>
                    <param name="to" type="int"/>
                </params>
                <comment line="204">
                    get the cookieHandler if there is any                    
                </comment>
                <scope line="199"/>
                <anonymous_class line="206">
                    <method name="run" type="CookieHandler" line="207"/>
                </anonymous_class>
            </method>
            <method name="newHttpProxy" type="Proxy" line="217">
                <params>
                    <param name="proxyHost" type="String"/>
                    <param name="proxyPort" type="int"/>
                    <param name="proto" type="String"/>
                </params>
                <declaration name="pport" type="int" line="220"/>
                <declaration name="saddr" type="InetSocketAddress" line="221"/>
            </method>
            <method name="HttpClient" type="constructor" line="239">
                <params>
                    <param name="url" type="URL"/>
                    <param name="proxyHost" type="String"/>
                    <param name="proxyPort" type="int"/>
                    <param name="proxyDisabled" type="boolean"/>
                </params>
            </method>
            <method name="HttpClient" type="constructor" line="246">
                <params>
                    <param name="url" type="URL"/>
                    <param name="proxyHost" type="String"/>
                    <param name="proxyPort" type="int"/>
                    <param name="proxyDisabled" type="boolean"/>
                    <param name="to" type="int"/>
                </params>
            </method>
            <method name="New" type="HttpClient" line="256">
                <params>
                    <param name="url" type="URL"/>
                </params>
            </method>
            <method name="New" type="HttpClient" line="261">
                <params>
                    <param name="url" type="URL"/>
                    <param name="useCache" type="boolean"/>
                </params>
            </method>
            <method name="New" type="HttpClient" line="266">
                <params>
                    <param name="url" type="URL"/>
                    <param name="p" type="Proxy"/>
                    <param name="to" type="int"/>
                    <param name="useCache" type="boolean"/>
                </params>
                <comment line="271">
                                        
                </comment>
                <comment line="287">
                    We cannot return this connection to the cache as it&apos;s                    
                </comment>
                <comment line="288">
                    KeepAliveTimeout will get reset. We simply close the connection.                    
                </comment>
                <comment line="289">
                    This should be fine as it is very rare that a connection                    
                </comment>
                <comment line="290">
                    to the same host will not use the same proxy.                    
                </comment>
                <scope line="267"/>
                <declaration name="ret" type="HttpClient" line="270"/>
                <scope line="272">
                    <scope line="274">
                        <scope line="276">
                            <scope line="277">
                                <declaration name="logger" type="PlatformLogger" line="281"/>
                                <scope line="282"/>
                            </scope>
                        </scope>
                        <scope line="286">
                            <scope line="291"/>
                        </scope>
                    </scope>
                </scope>
                <scope line="299"/>
                <scope line="301">
                    <declaration name="security" type="SecurityManager" line="302"/>
                    <scope line="303">
                        <scope line="304"/>
                        <scope line="306"/>
                    </scope>
                </scope>
            </method>
            <method name="New" type="HttpClient" line="315">
                <params>
                    <param name="url" type="URL"/>
                    <param name="p" type="Proxy"/>
                    <param name="to" type="int"/>
                </params>
            </method>
            <method name="New" type="HttpClient" line="321">
                <params>
                    <param name="url" type="URL"/>
                    <param name="proxyHost" type="String"/>
                    <param name="proxyPort" type="int"/>
                    <param name="useCache" type="boolean"/>
                </params>
            </method>
            <method name="New" type="HttpClient" line="327">
                <params>
                    <param name="url" type="URL"/>
                    <param name="proxyHost" type="String"/>
                    <param name="proxyPort" type="int"/>
                    <param name="useCache" type="boolean"/>
                    <param name="to" type="int"/>
                </params>
            </method>
            <method name="finished" type="void" line="341">
                <comment line="342">
                                        
                </comment>
                <comment line="348">
                    This connection is keepingAlive &amp;&amp; still valid.
                     Return it to the cache.                    
                </comment>
                <scope line="347"/>
                <scope line="352"/>
            </method>
            <method name="putInKeepAliveCache" type="void" line="357">
                <scope line="358"/>
            </method>
            <method name="isInKeepAliveCache" type="boolean" line="366"/>
            <method name="closeIdleConnection" type="void" line="374">
                <declaration name="http" type="HttpClient" line="375"/>
                <scope line="376"/>
            </method>
            <method name="openServer" type="void" line="387">
                <params>
                    <param name="server" type="String"/>
                    <param name="port" type="int"/>
                </params>
                <scope line="389">
                    <declaration name="out" type="OutputStream" line="390"/>
                    <scope line="391"/>
                </scope>
                <scope line="397"/>
            </method>
            <method name="needsTunneling" type="boolean" line="407"/>
            <method name="isCachedConnection" type="boolean" line="414"/>
            <method name="afterConnect" type="void" line="426">
                <comment line="427">
                    NO-OP. Needs to be overwritten by HttpsClient                    
                </comment>
            </method>
            <method name="privilegedOpenServer" type="void" line="435">
                <params>
                    <param name="server" type="InetSocketAddress"/>
                </params>
                <scope line="436">
                    <anonymous_class line="438">
                        <method name="run" type="Void" line="439"/>
                    </anonymous_class>
                </scope>
                <scope line="444"/>
            </method>
            <method name="superOpenServer" type="void" line="455">
                <params>
                    <param name="proxyHost" type="String"/>
                    <param name="proxyPort" type="int"/>
                </params>
            </method>
            <method name="openServer" type="void" line="461">
                <comment line="469">
                    already opened                    
                </comment>
                <comment line="482">
                    make direct connection                    
                </comment>
                <comment line="489">
                    we&apos;re opening some other kind of url, most likely an
                     ftp url.                    
                </comment>
                <comment line="498">
                    make direct connection                    
                </comment>
                <declaration name="security" type="SecurityManager" line="463"/>
                <scope line="465"/>
                <scope line="469"/>
                <scope line="474">
                    <scope line="476"/>
                    <scope line="481"/>
                </scope>
                <scope line="488">
                    <scope line="492"/>
                    <scope line="497"/>
                </scope>
            </method>
            <method name="getURLFile" type="String" line="506">
                <comment line="512">
                    proxyDisabled is set by subclass HttpsClient!                    
                </comment>
                <comment line="516">
                    Do not use URLStreamHandler.toExternalForm as the fragment                    
                </comment>
                <comment line="517">
                    should not be part of the RequestURI. It should be an                    
                </comment>
                <comment line="518">
                    absolute URI which does not have a fragment part.                    
                </comment>
                <declaration name="fileName" type="String" line="508"/>
                <scope line="515">
                    <declaration name="result" type="StringBuffer" line="519"/>
                    <scope line="522"/>
                    <scope line="526"/>
                    <scope line="529"/>
                </scope>
            </method>
            <javadoc line="542">
                @deprecated                
            </javadoc>
            <method name="writeRequests" type="void" line="546">
                <params>
                    <param name="head" type="MessageHeader"/>
                </params>
            </method>
            <method name="writeRequests" type="void" line="553">
                <params>
                    <param name="head" type="MessageHeader"/>
                    <param name="pos" type="PosterOutputStream"/>
                </params>
            </method>
            <method name="writeRequests" type="void" line="564">
                <params>
                    <param name="head" type="MessageHeader"/>
                    <param name="pos" type="PosterOutputStream"/>
                    <param name="streaming" type="boolean"/>
                </params>
            </method>
            <javadoc line="569">
                Parse the first line of the HTTP request.  It usually looks
                  something like: &quot;HTTP/1.0 &lt;number&gt; comment\r\n&quot;.                
            </javadoc>
            <method name="parseHTTP" type="boolean" line="573">
                <params>
                    <param name="responses" type="MessageHeader"/>
                    <param name="pi" type="ProgressSource"/>
                    <param name="httpuc" type="HttpURLConnection"/>
                </params>
                <comment line="574">
                    If &quot;HTTP&quot; is found in the beginning, return true.  Let
                     HttpURLConnection parse the mime header itself.
                    
                     If this isn&apos;t valid HTTP, then we don&apos;t try to parse a header
                     out of the beginning of the response into the responses,
                     and instead just queue up the output stream to it&apos;s very beginning.
                     This seems most reasonable, and is what the NN browser does.                    
                </comment>
                <comment line="591">
                    We don&apos;t want to retry the request when the app. sets a timeout                    
                </comment>
                <comment line="592">
                    but don&apos;t close the server if timeout while waiting for 100-continue                    
                </comment>
                <comment line="603">
                    do not retry the request                    
                </comment>
                <comment line="605">
                    try once more                    
                </comment>
                <scope line="583">
                    <scope line="585"/>
                </scope>
                <scope line="590">
                    <scope line="593"/>
                </scope>
                <scope line="597">
                    <scope line="600">
                        <scope line="602"/>
                        <scope line="604">
                            <scope line="607"/>
                        </scope>
                    </scope>
                </scope>
            </method>
            <method name="parseHTTPHeader" type="boolean" line="621">
                <params>
                    <param name="responses" type="MessageHeader"/>
                    <param name="pi" type="ProgressSource"/>
                    <param name="httpuc" type="HttpURLConnection"/>
                </params>
                <comment line="622">
                    If &quot;HTTP&quot; is found in the beginning, return true.  Let
                     HttpURLConnection parse the mime header itself.
                    
                     If this isn&apos;t valid HTTP, then we don&apos;t try to parse a header
                     out of the beginning of the response into the responses,
                     and instead just queue up the output stream to it&apos;s very beginning.
                     This seems most reasonable, and is what the NN browser does.                    
                </comment>
                <comment line="652">
                    is valid HTTP - response started w/ &quot;HTTP/1.&quot;                    
                </comment>
                <comment line="655">
                    we&apos;ve finished parsing http headers                    
                </comment>
                <comment line="656">
                    check if there are any applicable cookies to set (in cache)                    
                </comment>
                <comment line="659">
                    NOTE: That cast from Map shouldn&apos;t be necessary but                    
                </comment>
                <comment line="660">
                    a bug in javac is triggered under certain circumstances                    
                </comment>
                <comment line="661">
                    So we do put the cast in as a workaround until                    
                </comment>
                <comment line="662">
                    it is resolved.                    
                </comment>
                <comment line="667">
                    decide if we&apos;re keeping alive:
                     This is a bit tricky.  There&apos;s a spec, but most current
                     servers (10196) that support this differ in dialects.
                     If the serverclient misunderstand each other, the
                     protocol should fall back onto HTTP1.0, no keep-alive.                    
                </comment>
                <comment line="673">
                    not likely a proxy will return this                    
                </comment>
                <comment line="680">
                    some servers, notably Apache1.1, send something like:
                     &quot;Keep-Alive: timeout=15, max=1&quot; which we should respect.                    
                </comment>
                <comment line="686">
                                        
                </comment>
                <comment line="691">
                    We&apos;re talking 1.1 or later. Keep persistent until
                     the server says to close.                    
                </comment>
                <comment line="696">
                    The only Connection token we understand is close.
                     Paranoia: if there is any Connection header then
                     treat as non-persistent.                    
                </comment>
                <comment line="710">
                    do not retry the request                    
                </comment>
                <comment line="725">
                    we can&apos;t vouche for what this is....                    
                </comment>
                <comment line="736">
                    should have no leadingtrailing LWS
                     expedite the typical case by assuming it has
                     form &quot;HTTP1.x &lt;WS&gt; 2XX &lt;mumble&gt;&quot;                    
                </comment>
                <comment line="754">
                    Set things up to parse the entity body of the reply.
                     We should be smarter about avoid pointless work when
                     the HTTP method and response code indicate there will be
                     no entity body to parse.                    
                </comment>
                <comment line="764">
                    If keep alive not specified then close after the stream
                     has completed.                    
                </comment>
                <comment line="777">
                    If it&apos;s a keep alive connection then we will keep
                     (alive if :-
                     1. content-length is specified, or
                     2. &quot;Not-Modified&quot; or &quot;No-Content&quot; responses - RFC 2616 states that
                        204 or 304 response must not include a message body.                    
                </comment>
                <comment line="808">
                    Previously we were keeping alive, and now we&apos;re not.  Remove
                     this from the cache (but only here, once) - otherwise we get
                     multiple removes and the cache count gets messed up.                    
                </comment>
                <comment line="816">
                                        
                </comment>
                <comment line="819">
                    In this case, content length is well known, so it is okay                    
                </comment>
                <comment line="820">
                    to wrap the input stream with KeepAliveStream/MeteredStream.                    
                </comment>
                <comment line="823">
                    Progress monitor is enabled                    
                </comment>
                <comment line="828">
                    Wrap KeepAliveStream if keep alive is enabled.                    
                </comment>
                <comment line="841">
                    In this case, content length is unknown - the input                    
                </comment>
                <comment line="842">
                    stream would simply be a regular InputStream or                    
                </comment>
                <comment line="843">
                    ChunkedInputStream.                    
                </comment>
                <comment line="846">
                    Progress monitoring is enabled.                    
                </comment>
                <comment line="850">
                    Wrap MeteredStream for tracking indeterministic                    
                </comment>
                <comment line="851">
                    progress, even if the input stream is ChunkedInputStream.                    
                </comment>
                <comment line="855">
                    Progress monitoring is disabled, and there is no                    
                </comment>
                <comment line="856">
                    need to wrap an unknown length input stream.                    
                </comment>
                <comment line="858">
                    ** This is an no-op **                    
                </comment>
                <declaration name="ret" type="boolean" line="634"/>
                <declaration name="b" type="byte[]" line="635"/>
                <scope line="637">
                    <declaration name="nread" type="int" line="638"/>
                    <scope line="640">
                        <declaration name="r" type="int" line="641"/>
                        <scope line="642"/>
                    </scope>
                    <declaration name="keep" type="String" line="647"/>
                    <scope line="652">
                        <scope line="657">
                            <declaration name="uri" type="URI" line="658"/>
                        </scope>
                        <scope line="673"/>
                        <scope line="676"/>
                        <scope line="679">
                            <declaration name="p" type="HeaderParser" line="683"/>
                            <scope line="685"/>
                        </scope>
                        <scope line="690">
                            <scope line="695"/>
                            <scope line="702"/>
                        </scope>
                    </scope>
                    <scope line="706">
                        <scope line="707">
                            <scope line="709"/>
                            <scope line="711">
                                <scope line="715"/>
                            </scope>
                        </scope>
                    </scope>
                    <scope line="724"/>
                </scope>
                <scope line="728"/>
                <declaration name="code" type="int" line="732"/>
                <scope line="733">
                    <declaration name="resp" type="String" line="734"/>
                    <declaration name="ind" type="int" line="740"/>
                </scope>
                <scope line="745"/>
                <scope line="747"/>
                <declaration name="cl" type="long" line="752"/>
                <declaration name="te" type="String" line="760"/>
                <scope line="761">
                    <scope line="768"/>
                    <scope line="771"/>
                </scope>
                <scope line="775">
                    <declaration name="cls" type="String" line="784"/>
                    <scope line="785">
                        <scope line="786"/>
                        <scope line="788"/>
                    </scope>
                    <declaration name="requestLine" type="String" line="792"/>
                    <scope line="797"/>
                    <scope line="804"/>
                    <scope line="807"/>
                </scope>
                <scope line="818">
                    <scope line="822"/>
                    <scope line="827">
                        <declaration name="logger" type="PlatformLogger" line="829"/>
                        <scope line="830"/>
                    </scope>
                    <scope line="836"/>
                </scope>
                <scope line="840">
                    <scope line="845"/>
                    <scope line="854"/>
                </scope>
                <scope line="861"/>
            </method>
            <method name="getInputStream" type="InputStream" line="869"/>
            <method name="getOutputStream" type="OutputStream" line="873"/>
            <method name="toString" type="String" line="878"/>
            <method name="isKeepingAlive" type="boolean" line="882"/>
            <method name="setCacheRequest" type="void" line="886">
                <params>
                    <param name="cacheRequest" type="CacheRequest"/>
                </params>
            </method>
            <method name="getCacheRequest" type="CacheRequest" line="890"/>
            <method name="finalize" type="void" line="895">
                <comment line="896">
                    This should do nothing.  The stream finalizer will                    
                </comment>
                <comment line="897">
                    close the fd.                    
                </comment>
            </method>
            <method name="setDoNotRetry" type="void" line="900">
                <params>
                    <param name="value" type="boolean"/>
                </params>
                <comment line="901">
                    failedOnce is used to determine if a request should be retried.                    
                </comment>
            </method>
            <method name="setIgnoreContinue" type="void" line="905">
                <params>
                    <param name="value" type="boolean"/>
                </params>
            </method>
            <method name="closeServer" type="void" line="911">
                <scope line="912"/>
                <scope line="915"/>
            </method>
            <javadoc line="918">
                @return the proxy host being used for this client, or null
                  if we&apos;re not going through a proxy                
            </javadoc>
            <method name="getProxyHostUsed" type="String" line="922">
                <scope line="923"/>
                <scope line="925"/>
            </method>
            <javadoc line="930">
                @return the proxy port being used for this client.  Meaningless
                  if getProxyHostUsed() gives null.                
            </javadoc>
            <method name="getProxyPortUsed" type="int" line="934"/>
        </class>
    </source>