<?xml version="1.0" encoding="UTF-8"?>
    <source package="sun.net.www.protocol.http">
        <import package="java.net.URL"/>
        <import package="java.net.URLConnection"/>
        <import package="java.net.ProtocolException"/>
        <import package="java.net.HttpRetryException"/>
        <import package="java.net.PasswordAuthentication"/>
        <import package="java.net.Authenticator"/>
        <import package="java.net.InetAddress"/>
        <import package="java.net.UnknownHostException"/>
        <import package="java.net.SocketTimeoutException"/>
        <import package="java.net.Proxy"/>
        <import package="java.net.ProxySelector"/>
        <import package="java.net.URI"/>
        <import package="java.net.InetSocketAddress"/>
        <import package="java.net.CookieHandler"/>
        <import package="java.net.ResponseCache"/>
        <import package="java.net.CacheResponse"/>
        <import package="java.net.SecureCacheResponse"/>
        <import package="java.net.CacheRequest"/>
        <import package="java.net.Authenticator.RequestorType"/>
        <import package="java.io"/>
        <import package="java.util.Date"/>
        <import package="java.util.Map"/>
        <import package="java.util.List"/>
        <import package="java.util.Locale"/>
        <import package="java.util.StringTokenizer"/>
        <import package="java.util.Iterator"/>
        <import package="java.util.HashSet"/>
        <import package="java.util.HashMap"/>
        <import package="java.util.Set"/>
        <import package="sun.net"/>
        <import package="sun.net.www"/>
        <import package="sun.net.www.http.HttpClient"/>
        <import package="sun.net.www.http.PosterOutputStream"/>
        <import package="sun.net.www.http.ChunkedInputStream"/>
        <import package="sun.net.www.http.ChunkedOutputStream"/>
        <import package="sun.util.logging.PlatformLogger"/>
        <import package="java.text.SimpleDateFormat"/>
        <import package="java.util.TimeZone"/>
        <import package="java.net.MalformedURLException"/>
        <import package="java.nio.ByteBuffer"/>
        <import package="sun.net.www.protocol.http.AuthScheme.BASIC"/>
        <import package="sun.net.www.protocol.http.AuthScheme.DIGEST"/>
        <import package="sun.net.www.protocol.http.AuthScheme.NTLM"/>
        <import package="sun.net.www.protocol.http.AuthScheme.NEGOTIATE"/>
        <import package="sun.net.www.protocol.http.AuthScheme.KERBEROS"/>
        <import package="sun.net.www.protocol.http.AuthScheme.UNKNOWN"/>
        <class name="HttpURLConnection" line="75">
            <extends class="java.net.HttpURLConnection"/>
            <comment line="88">
                                
            </comment>
            <comment line="92">
                Not all servers support the (Proxy)-Authentication-Info headers.
                 By default, we don&apos;t require them to be sent                
            </comment>
            <comment line="106">
                System properties related to error stream handling:
                
                 sun.net.http.errorstream.enableBuffering = &lt;boolean&gt;
                
                 With the above system property set to true (default is false),
                 when the response code is &gt;=400, the HTTP handler will try to
                 buffer the response body (up to a certain amount and within a
                 time limit). Thus freeing up the underlying socket connection
                 for reuse. The rationale behind this is that usually when the
                 server responds with a &gt;=400 error (client error or server
                 error, such as 404 file not found), the server will send a
                 small response body to explain who to contact and what to do to
                 recover. With this property set to true, even if the
                 application doesn&apos;t call getErrorStream(), read the response
                 body, and then call close(), the underlying socket connection
                 can still be kept-alive and reused. The following two system
                 properties provide further control to the error stream
                 buffering behaviour.
                
                 sun.net.http.errorstream.timeout = &lt;int&gt;
                     the timeout (in millisec) waiting the error stream
                     to be buffered; default is 300 ms
                
                 sun.net.http.errorstream.bufferSize = &lt;int&gt;
                     the size (in bytes) to use for the buffering the error stream;
                     default is 4k                
            </comment>
            <comment line="136">
                                
            </comment>
            <comment line="139">
                timeout waiting for read for buffered error stream;                
            </comment>
            <comment line="143">
                buffer size for buffered error stream;                
            </comment>
            <comment line="147">
                Restrict setting of request headers through the public api
                 consistent with JavaScript XMLHttpRequest2 with a few
                 exceptions. Disallowed headers are silently ignored for
                 backwards compatibility reasons rather than throwing a
                 SecurityException. For example, some applets set the
                 Host header since old JREs did not implement HTTP 1.1.
                 Additionally, any header starting with Sec- is
                 disallowed.
                
                 The following headers are allowed for historical reasons:
                
                 Accept-Charset, Accept-Encoding, Cookie, Cookie2, Date,
                 Referer, TE, User-Agent, headers beginning with Proxy-.
                
                 The following headers are allowed in a limited form:
                
                 Connection: close
                
                 See http:www.w3.orgTRXMLHttpRequest2.                
            </comment>
            <comment line="250">
                the following http request headers should NOT have their values
                 returned for security reasons.                
            </comment>
            <comment line="257">
                also exclude system cookies when any might be set                
            </comment>
            <comment line="272">
                the cached response, and cached response headers and body                
            </comment>
            <comment line="277">
                                
            </comment>
            <comment line="281">
                                
            </comment>
            <comment line="284">
                                
            </comment>
            <comment line="289">
                We only have a single static authenticator for now.
                 REMIND:  backwards compatibility with JDK 1.1.  Should be
                 eliminated for JDK 2.0.                
            </comment>
            <comment line="295">
                all the headers we send
                 NOTE: do NOT dump out the content of &apos;requests&apos; in the
                 output or stacktrace since it may contain security-sensitive
                 headers such as those defined in EXCLUDE_HEADERS.                
            </comment>
            <comment line="302">
                                
            </comment>
            <comment line="303">
                                
            </comment>
            <comment line="306">
                                
            </comment>
            <comment line="310">
                                
            </comment>
            <comment line="311">
                                
            </comment>
            <comment line="313">
                                
            </comment>
            <comment line="317">
                                
            </comment>
            <comment line="320">
                                
            </comment>
            <comment line="326">
                                
            </comment>
            <comment line="329">
                                
            </comment>
            <comment line="331">
                                
            </comment>
            <comment line="333">
                                
            </comment>
            <comment line="336">
                                
            </comment>
            <comment line="339">
                                
            </comment>
            <comment line="342">
                Remembered Exception, we will throw it again if somebody                
            </comment>
            <comment line="346">
                                
            </comment>
            <comment line="349">
                                
            </comment>
            <comment line="363">
                Redefine timeouts from java.net.URLConnection as we need -1 to mean
                 not set. This is to ensure backward compatibility.                
            </comment>
            <comment line="369">
                                
            </comment>
            <comment line="373">
                privileged request password authentication                
            </comment>
            <comment line="426">
                Checks the validity of http message header and whether the header
                 is restricted and throws IllegalArgumentException if invalid or
                 restricted.                
            </comment>
            <comment line="439">
                                
            </comment>
            <comment line="444">
                                
            </comment>
            <comment line="453">
                checks the validity of http message header and throws
                 IllegalArgumentException if invalid.                
            </comment>
            <comment line="486">
                adds the standard keyval pairs to reqests if necessary &amp; write to
                 given PrintStream                
            </comment>
            <comment line="809">
                Same as java.net.URL.hostsEqual                
            </comment>
            <comment line="844">
                overridden in HTTPS subclass                
            </comment>
            <comment line="990">
                subclass HttpsClient will overwrite &amp; return an instance of HttpsClient                
            </comment>
            <comment line="996">
                subclass HttpsClient will overwrite &amp; return an instance of HttpsClient                
            </comment>
            <comment line="1053">
                Allowable inputoutput sequences:
                 [interpreted as POSTPUT]
                 - get output, [write output,] get input, [read input]
                 - get output, [write output]
                 [interpreted as GET]
                 - get input, [read input]
                 Disallowed:
                 - get input, [read input,] get output, [write output]                
            </comment>
            <comment line="1148">
                get applicable cookies based on the uri and request headers
                 add them to the existing request headers                
            </comment>
            <comment line="1650">
                Creates a chained exception that has the same type as
                 original exception and with the same message. Right now,
                 there is no convenient APIs for doing so.                
            </comment>
            <comment line="2240">
                inclose will be true if called from close(), in which case we
                 force the call to check because this is the last chance to do so.
                 If not in close(), then the authentication info could arrive in a trailer
                 field, which we have not read yet.                
            </comment>
            <comment line="2279">
                The request URI used in the request line for this request.
                 Also, needed for digest authentication                
            </comment>
            <comment line="2292">
                Tells us whether to follow a redirect.  If so, it
                 closes the connection (break any keep-alive) and
                 resets the url, re-connects, and resets the request
                 property.                
            </comment>
            <comment line="2412">
                                
            </comment>
            <comment line="2701">
                Set a property for authentication.  This can safely disregard
                 the connected test.                
            </comment>
            <comment line="2862">
                The purpose of this wrapper is just to capture the close() call
                 so we can check authentication information that may have
                 arrived in a Trailer field                
            </comment>
            <javadoc line="75">
                A class to represent an HTTP connection to a remote object.                
            </javadoc>
            <declaration name="HTTP_CONNECT" type="String" line="82"/>
            <declaration name="version" type="String" line="84"/>
            <declaration name="userAgent" type="String" line="85"/>
            <declaration name="defaultmaxRedirects" type="int" line="88"/>
            <declaration name="maxRedirects" type="int" line="89"/>
            <declaration name="validateProxy" type="boolean" line="94"/>
            <declaration name="validateServer" type="boolean" line="95"/>
            <declaration name="strOutputStream" type="StreamingOutputStream" line="97"/>
            <declaration name="RETRY_MSG1" type="String" line="98"/>
            <declaration name="RETRY_MSG2" type="String" line="100"/>
            <declaration name="RETRY_MSG3" type="String" line="102"/>
            <declaration name="enableESBuffer" type="boolean" line="136"/>
            <declaration name="timeout4ESBuffer" type="int" line="140"/>
            <declaration name="bufSize4ES" type="int" line="144"/>
            <declaration name="allowRestrictedHeaders" type="boolean" line="167"/>
            <declaration name="restrictedHeaderSet" type="Set&lt;String&gt;" line="168"/>
            <declaration name="restrictedHeaders" type="String[]" line="169"/>
            <scope line="194">
                <declaration name="agent" type="String" line="200"/>
                <scope line="202"/>
                <scope line="204"/>
                <scope line="221"/>
                <scope line="228"/>
                <scope line="235">
                    <scope line="237"/>
                </scope>
                <scope line="240"/>
            </scope>
            <declaration name="httpVersion" type="String" line="245"/>
            <declaration name="acceptString" type="String" line="246"/>
            <declaration name="EXCLUDE_HEADERS" type="String[]" line="251"/>
            <declaration name="EXCLUDE_HEADERS2" type="String[]" line="257"/>
            <declaration name="http" type="HttpClient" line="264"/>
            <declaration name="handler" type="Handler" line="265"/>
            <declaration name="instProxy" type="Proxy" line="266"/>
            <declaration name="cookieHandler" type="CookieHandler" line="268"/>
            <declaration name="cacheHandler" type="ResponseCache" line="269"/>
            <declaration name="cachedResponse" type="CacheResponse" line="272"/>
            <declaration name="cachedHeaders" type="MessageHeader" line="273"/>
            <declaration name="cachedInputStream" type="InputStream" line="274"/>
            <declaration name="ps" type="PrintStream" line="277"/>
            <declaration name="errorStream" type="InputStream" line="281"/>
            <declaration name="setUserCookies" type="boolean" line="284"/>
            <declaration name="userCookies" type="String" line="285"/>
            <declaration name="userCookies2" type="String" line="286"/>
            <declaration name="defaultAuth" type="HttpAuthenticator" line="292"/>
            <declaration name="requests" type="MessageHeader" line="299"/>
            <declaration name="domain" type="String" line="302"/>
            <declaration name="digestparams" type="DigestAuthentication.Parameters" line="303"/>
            <declaration name="currentProxyCredentials" type="AuthenticationInfo" line="306"/>
            <declaration name="currentServerCredentials" type="AuthenticationInfo" line="307"/>
            <declaration name="needToCheck" type="boolean" line="308"/>
            <declaration name="doingNTLM2ndStage" type="boolean" line="309"/>
            <declaration name="doingNTLMp2ndStage" type="boolean" line="310"/>
            <declaration name="tryTransparentNTLMServer" type="boolean" line="313"/>
            <declaration name="tryTransparentNTLMProxy" type="boolean" line="314"/>
            <declaration name="authObj" type="Object" line="317"/>
            <declaration name="isUserServerAuth" type="boolean" line="320"/>
            <declaration name="isUserProxyAuth" type="boolean" line="321"/>
            <declaration name="serverAuthKey" type="String" line="323"/>
            <declaration name="pi" type="ProgressSource" line="326"/>
            <declaration name="responses" type="MessageHeader" line="329"/>
            <declaration name="inputStream" type="InputStream" line="331"/>
            <declaration name="poster" type="PosterOutputStream" line="333"/>
            <declaration name="setRequests" type="boolean" line="336"/>
            <declaration name="failedOnce" type="boolean" line="339"/>
            <declaration name="rememberedException" type="Exception" line="343"/>
            <declaration name="reuseClient" type="HttpClient" line="346"/>
            <declaration name="tunnelState" type="TunnelState" line="360"/>
            <declaration name="connectTimeout" type="int" line="365"/>
            <declaration name="readTimeout" type="int" line="366"/>
            <declaration name="logger" type="PlatformLogger" line="369"/>
            <method name="privilegedRequestPasswordAuthentication" type="PasswordAuthentication" line="385">
                <params>
                    <param name="host" type="String"/>
                    <param name="addr" type="InetAddress"/>
                    <param name="port" type="int"/>
                    <param name="protocol" type="String"/>
                    <param name="prompt" type="String"/>
                    <param name="scheme" type="String"/>
                    <param name="url" type="URL"/>
                    <param name="authType" type="RequestorType"/>
                </params>
                <anonymous_class line="387">
                    <method name="run" type="PasswordAuthentication" line="388">
                        <scope line="389"/>
                        <declaration name="pass" type="PasswordAuthentication" line="392"/>
                        <scope line="395"/>
                    </method>
                </anonymous_class>
            </method>
            <method name="isRestrictedHeader" type="boolean" line="403">
                <params>
                    <param name="key" type="String"/>
                    <param name="value" type="String"/>
                </params>
                <comment line="411">
                    Exceptions to restricted headers:
                    
                     Allow &quot;Connection: close&quot;.                    
                </comment>
                <scope line="404"/>
                <scope line="409">
                    <scope line="415"/>
                </scope>
                <scope line="419"/>
            </method>
            <method name="isExternalMessageHeaderAllowed" type="boolean" line="430">
                <params>
                    <param name="key" type="String"/>
                    <param name="value" type="String"/>
                </params>
                <scope line="432"/>
            </method>
            <method name="getHttpLogger" type="PlatformLogger" line="439"/>
            <method name="authObj" type="Object" line="444"/>
            <method name="authObj" type="void" line="448">
                <params>
                    <param name="authObj" type="Object"/>
                </params>
            </method>
            <method name="checkMessageHeader" type="void" line="456">
                <params>
                    <param name="key" type="String"/>
                    <param name="value" type="String"/>
                </params>
                <comment line="475">
                    ok, check the next occurrence                    
                </comment>
                <declaration name="LF" type="char" line="457"/>
                <declaration name="index" type="int" line="458"/>
                <scope line="459"/>
                <scope line="463">
                    <scope line="464"/>
                    <scope line="469">
                        <scope line="471">
                            <declaration name="c" type="char" line="472"/>
                            <scope line="473"/>
                        </scope>
                    </scope>
                </scope>
            </method>
            <method name="writeRequests" type="void" line="488">
                <comment line="490">
                    print all message headers in the MessageHeader
                     onto the wire - all the ones we&apos;ve set and any
                     others that have been set                    
                </comment>
                <comment line="494">
                    send any pre-emptive authentication                    
                </comment>
                <comment line="500">
                    We&apos;re very particular about the order in which we
                     set the request headers here.  The order should not
                     matter, but some careless CGI programs have been
                     written to expect a very particular order of the
                     standard headers.  To name names, the order in which
                     Navigator3.0 sends them.  In particular, we make sure
                     to send Content-type: &lt;&gt; and Content-length:&lt;&gt; second
                     to last and last, respectively, in the case of a POST
                     request.                    
                </comment>
                <comment line="526">
                    For HTTP1.1 the default behavior is to keep connections alive.
                     However, we may be talking to a 1.0 server so we should set
                     keep-alive just in case, except if we have encountered an error
                     or if keep alive is disabled via a system property                    
                </comment>
                <comment line="533">
                    Try keep-alive only on first attempt                    
                </comment>
                <comment line="541">
                    RFC 2616 HTTP1.1 section 14.10 says:
                     HTTP1.1 applications that do not support persistent
                     connections MUST include the &quot;close&quot; connection option
                     in every message                    
                </comment>
                <comment line="549">
                    Set modified since if necessary                    
                </comment>
                <comment line="553">
                    use the preferred date format according to RFC 2068(HTTP1.1),
                     RFC 822 and RFC 1123                    
                </comment>
                <comment line="560">
                    check for preemptive authorization                    
                </comment>
                <comment line="563">
                    Sets &quot;Authorization&quot;                    
                </comment>
                <comment line="579">
                                        
                </comment>
                <comment line="589">
                                        
                </comment>
                <comment line="591">
                                        
                </comment>
                <comment line="608">
                    get applicable cookies based on the uri and request headers
                     add them to the existing request headers                    
                </comment>
                <comment line="624">
                    try once more                    
                </comment>
                <scope line="494"/>
                <scope line="497">
                    <scope line="512"/>
                    <declaration name="port" type="int" line="517"/>
                    <declaration name="host" type="String" line="518"/>
                    <scope line="519"/>
                    <scope line="533">
                        <scope line="534"/>
                        <scope line="536"/>
                    </scope>
                    <scope line="539"/>
                    <declaration name="modTime" type="long" line="549"/>
                    <scope line="550">
                        <declaration name="date" type="Date" line="551"/>
                        <declaration name="fo" type="SimpleDateFormat" line="554"/>
                    </scope>
                    <declaration name="sauth" type="AuthenticationInfo" line="560"/>
                    <scope line="561"/>
                    <scope line="567"/>
                    <declaration name="chunked" type="boolean" line="572"/>
                    <scope line="574">
                        <scope line="575"/>
                        <scope line="578">
                            <scope line="579"/>
                            <scope line="582"/>
                        </scope>
                    </scope>
                    <scope line="587">
                        <scope line="589"/>
                    </scope>
                    <scope line="597">
                        <scope line="598">
                            <scope line="600"/>
                        </scope>
                    </scope>
                </scope>
                <scope line="613"/>
                <scope line="617">
                    <declaration name="proxyHost" type="String" line="618"/>
                    <declaration name="proxyPort" type="int" line="619"/>
                    <scope line="621"/>
                    <scope line="623">
                        <scope line="625"/>
                        <scope line="627"/>
                    </scope>
                </scope>
            </method>
            <javadoc line="640">
                Create a new HttpClient object, bypassing the cache of
                  HTTP client objects/connections.                
                <param>
                    url       the URL being accessed                    
                </param>
            </javadoc>
            <method name="setNewClient" type="void" line="647">
                <params>
                    <param name="url" type="URL"/>
                </params>
            </method>
            <javadoc line="651">
                Obtain a HttpsClient object. Use the cached copy if specified.                
                <param>
                    url       the URL being accessed                    
                </param>
                <param>
                    useCache  whether the cached connection should be used
                      if present                    
                </param>
            </javadoc>
            <method name="setNewClient" type="void" line="659">
                <params>
                    <param name="url" type="URL"/>
                    <param name="useCache" type="boolean"/>
                </params>
            </method>
            <javadoc line="665">
                Create a new HttpClient object, set up so that it uses
                  per-instance proxying to the given HTTP proxy.  This
                  bypasses the cache of HTTP client objects/connections.                
                <param>
                    url       the URL being accessed                    
                </param>
                <param>
                    proxyHost the proxy host to use                    
                </param>
                <param>
                    proxyPort the proxy port to use                    
                </param>
            </javadoc>
            <method name="setProxiedClient" type="void" line="675">
                <params>
                    <param name="url" type="URL"/>
                    <param name="proxyHost" type="String"/>
                    <param name="proxyPort" type="int"/>
                </params>
            </method>
            <javadoc line="679">
                Obtain a HttpClient object, set up so that it uses per-instance
                  proxying to the given HTTP proxy. Use the cached copy of HTTP
                  client objects/connections if specified.                
                <param>
                    url       the URL being accessed                    
                </param>
                <param>
                    proxyHost the proxy host to use                    
                </param>
                <param>
                    proxyPort the proxy port to use                    
                </param>
                <param>
                    useCache  whether the cached connection should be used
                      if present                    
                </param>
            </javadoc>
            <method name="setProxiedClient" type="void" line="693">
                <params>
                    <param name="url" type="URL"/>
                    <param name="proxyHost" type="String"/>
                    <param name="proxyPort" type="int"/>
                    <param name="useCache" type="boolean"/>
                </params>
            </method>
            <method name="proxiedConnect" type="void" line="700">
                <params>
                    <param name="url" type="URL"/>
                    <param name="proxyHost" type="String"/>
                    <param name="proxyPort" type="int"/>
                    <param name="useCache" type="boolean"/>
                </params>
            </method>
            <method name="HttpURLConnection" type="constructor" line="706">
                <params>
                    <param name="u" type="URL"/>
                    <param name="handler" type="Handler"/>
                </params>
                <comment line="708">
                    we set proxy == null to distinguish this case with the case
                     when per connection proxy is set                    
                </comment>
            </method>
            <method name="HttpURLConnection" type="constructor" line="712">
                <params>
                    <param name="u" type="URL"/>
                    <param name="host" type="String"/>
                    <param name="port" type="int"/>
                </params>
            </method>
            <javadoc line="716">
                this constructor is used by other protocol handlers such as ftp
                  that want to use http to fetch urls on their behalf.                
            </javadoc>
            <method name="HttpURLConnection" type="constructor" line="718">
                <params>
                    <param name="u" type="URL"/>
                    <param name="p" type="Proxy"/>
                </params>
            </method>
            <method name="HttpURLConnection" type="constructor" line="722">
                <params>
                    <param name="u" type="URL"/>
                    <param name="p" type="Proxy"/>
                    <param name="handler" type="Handler"/>
                </params>
                <comment line="730">
                    Application set Proxies should not have access to cookies                    
                </comment>
                <comment line="734">
                                        
                </comment>
                <scope line="728">
                    <scope line="731"/>
                    <scope line="733"/>
                </scope>
                <scope line="734">
                    <anonymous_class line="736">
                        <method name="run" type="CookieHandler" line="737"/>
                    </anonymous_class>
                </scope>
                <anonymous_class line="743">
                    <method name="run" type="ResponseCache" line="744"/>
                </anonymous_class>
            </method>
            <javadoc line="750">
                Use java.net.Authenticator.setDefault() instead.                
            </javadoc>
            <method name="setDefaultAuthenticator" type="void" line="753">
                <params>
                    <param name="a" type="HttpAuthenticator"/>
                </params>
            </method>
            <javadoc line="757">
                opens a stream allowing redirects only to the same host.                
            </javadoc>
            <method name="openConnectionCheckRedirects" type="InputStream" line="762">
                <params>
                    <param name="c" type="URLConnection"/>
                </params>
                <comment line="773">
                    We want to open the input stream before
                     getting headers, because getHeaderField()
                     et al swallow IOExceptions.                    
                </comment>
                <declaration name="redir" type="boolean" line="763"/>
                <declaration name="redirects" type="int" line="764"/>
                <declaration name="in" type="InputStream" line="765"/>
                <scope line="767">
                    <scope line="768"/>
                    <scope line="778">
                        <declaration name="http" type="HttpURLConnection" line="779"/>
                        <declaration name="stat" type="int" line="780"/>
                        <scope line="782">
                            <declaration name="base" type="URL" line="783"/>
                            <declaration name="loc" type="String" line="784"/>
                            <declaration name="target" type="URL" line="785"/>
                            <scope line="786"/>
                            <scope line="795"/>
                        </scope>
                    </scope>
                </scope>
            </method>
            <method name="hostsEqual" type="boolean" line="811">
                <params>
                    <param name="u1" type="URL"/>
                    <param name="u2" type="URL"/>
                </params>
                <comment line="823">
                    Have to resolve addresses before comparing, otherwise
                     names like tachyon and tachyon.eng would compare different                    
                </comment>
                <declaration name="h1" type="String" line="812"/>
                <declaration name="h2" type="String" line="813"/>
                <scope line="815"/>
                <scope line="817"/>
                <scope line="819"/>
                <declaration name="result" type="boolean" line="824"/>
                <anonymous_class line="827">
                    <method name="run" type="Void" line="828">
                        <scope line="829">
                            <declaration name="a1" type="InetAddress" line="830"/>
                            <declaration name="a2" type="InetAddress" line="831"/>
                        </scope>
                        <scope line="833"/>
                        <scope line="834"/>
                    </method>
                </anonymous_class>
            </method>
            <method name="connect" type="void" line="845"/>
            <method name="checkReuseConnection" type="boolean" line="849">
                <scope line="850"/>
                <scope line="853"/>
            </method>
            <method name="plainConnect" type="void" line="864">
                <comment line="869">
                    try to see if request can be served from local cache                    
                </comment>
                <comment line="889">
                    ignore and commence normal connection                    
                </comment>
                <comment line="899">
                    Try to open connections using the following scheme,
                     return on the first one that&apos;s successful:
                     1) if (instProxy != null)
                            connect to instProxy; raise exception if failed
                     2) else use system default ProxySelector
                     3) is 2) fails, make direct connection                    
                </comment>
                <comment line="907">
                    no instance Proxy is set                    
                </comment>
                <comment line="908">
                    Do we have to use a proxy?                    
                </comment>
                <comment line="932">
                    make sure to construct new connection if first
                     attempt failed                    
                </comment>
                <comment line="947">
                    fallback to direct connection                    
                </comment>
                <comment line="959">
                    No proxy selector, create http client with no proxy                    
                </comment>
                <comment line="964">
                    make sure to construct new connection if first
                     attempt failed                    
                </comment>
                <comment line="975">
                    make sure to construct new connection if first
                     attempt failed                    
                </comment>
                <comment line="986">
                    constructor to HTTP client calls openserver                    
                </comment>
                <scope line="865"/>
                <scope line="869">
                    <scope line="870">
                        <declaration name="uri" type="URI" line="871"/>
                        <scope line="872">
                            <scope line="875"/>
                            <scope line="878"/>
                            <scope line="882"/>
                        </scope>
                    </scope>
                    <scope line="887"/>
                    <scope line="890"/>
                    <scope line="893"/>
                </scope>
                <scope line="897">
                    <scope line="906">
                        <anonymous_class line="912">
                            <method name="run" type="ProxySelector" line="913"/>
                        </anonymous_class>
                        <declaration name="sel" type="ProxySelector" line="910"/>
                        <scope line="917">
                            <declaration name="uri" type="URI" line="918"/>
                            <scope line="919"/>
                            <declaration name="it" type="Iterator&lt;Proxy&gt;" line="922"/>
                            <declaration name="p" type="Proxy" line="923"/>
                            <scope line="924">
                                <scope line="926">
                                    <scope line="927"/>
                                    <scope line="930"/>
                                    <scope line="936">
                                        <scope line="937"/>
                                    </scope>
                                </scope>
                                <scope line="942">
                                    <scope line="943">
                                        <scope line="945"/>
                                    </scope>
                                    <scope line="951"/>
                                </scope>
                            </scope>
                        </scope>
                        <scope line="957">
                            <scope line="959"/>
                            <scope line="962"/>
                        </scope>
                    </scope>
                    <scope line="969">
                        <scope line="970"/>
                        <scope line="973"/>
                    </scope>
                </scope>
                <scope line="982"/>
            </method>
            <method name="getNewHttpClient" type="HttpClient" line="991">
                <params>
                    <param name="url" type="URL"/>
                    <param name="p" type="Proxy"/>
                    <param name="connectTimeout" type="int"/>
                </params>
            </method>
            <method name="getNewHttpClient" type="HttpClient" line="998">
                <params>
                    <param name="url" type="URL"/>
                    <param name="p" type="Proxy"/>
                    <param name="connectTimeout" type="int"/>
                    <param name="useCache" type="boolean"/>
                </params>
            </method>
            <method name="expect100Continue" type="void" line="1002">
                <comment line="1004">
                    Expect: 100-Continue was set, so check the return code for
                     Acceptance                    
                </comment>
                <comment line="1010">
                    5s read timeout in case the server doesn&apos;t understand
                     Expect: 100-Continue                    
                </comment>
                <comment line="1026">
                    Can&apos;t use getResponseCode() yet                    
                </comment>
                <comment line="1028">
                    Parse the response which is of the form:
                     HTTP/1.1 417 Expectation Failed
                     HTTP/1.1 100 Continue                    
                </comment>
                <comment line="1035">
                    Response code is 2nd token on the line                    
                </comment>
                <comment line="1050">
                    Proceed                    
                </comment>
                <declaration name="oldTimeout" type="int" line="1005"/>
                <declaration name="enforceTimeOut" type="boolean" line="1006"/>
                <declaration name="timedOut" type="boolean" line="1007"/>
                <scope line="1008"/>
                <scope line="1015"/>
                <scope line="1017">
                    <scope line="1018"/>
                </scope>
                <scope line="1024">
                    <declaration name="resp" type="String" line="1026"/>
                    <scope line="1030">
                        <declaration name="sa" type="String[]" line="1031"/>
                        <scope line="1033"/>
                        <scope line="1037"/>
                    </scope>
                    <scope line="1040"/>
                </scope>
            </method>
            <method name="getOutputStream" type="OutputStream" line="1064">
                <comment line="1074">
                    Backward compatibility                    
                </comment>
                <comment line="1082">
                    if there&apos;s already an input stream open, throw an exception                    
                </comment>
                <comment line="1107">
                                        
                </comment>
                <comment line="1110">
                                        
                </comment>
                <comment line="1131">
                    Save the response code which may have been set while enforcing
                     the 100-continue. disconnectInternal() forces it to -1                    
                </comment>
                <scope line="1066">
                    <scope line="1067"/>
                    <scope line="1072"/>
                    <scope line="1076"/>
                    <scope line="1082"/>
                    <declaration name="expectContinue" type="boolean" line="1089"/>
                    <declaration name="expects" type="String" line="1090"/>
                    <scope line="1091"/>
                    <scope line="1096"/>
                    <scope line="1100"/>
                    <scope line="1104">
                        <scope line="1105">
                            <scope line="1106"/>
                            <scope line="1109">
                                <declaration name="length" type="long" line="1110"/>
                                <scope line="1111"/>
                                <scope line="1113"/>
                            </scope>
                        </scope>
                    </scope>
                    <scope line="1120">
                        <scope line="1121"/>
                    </scope>
                </scope>
                <scope line="1126"/>
                <scope line="1129">
                    <declaration name="i" type="int" line="1132"/>
                </scope>
                <scope line="1136"/>
            </method>
            <method name="streaming" type="boolean" line="1142"/>
            <method name="setCookieHeader" type="void" line="1151">
                <comment line="1154">
                    we only want to capture the user defined Cookies once, as
                     they cannot be changed by user code after we are connected,
                     only internally.                    
                </comment>
                <comment line="1169">
                    remove old Cookie header before setting new one.                    
                </comment>
                <comment line="1188">
                    ignore all entries that don&apos;t have &quot;Cookie&quot;
                     or &quot;Cookie2&quot; as keys                    
                </comment>
                <comment line="1200">
                    strip off the trailing &apos;; &apos;                    
                </comment>
                <comment line="1204">
                    no-op                    
                </comment>
                <comment line="1225">
                    end of getting cookies                    
                </comment>
                <scope line="1152">
                    <scope line="1156">
                        <scope line="1157">
                            <declaration name="k" type="int" line="1158"/>
                        </scope>
                    </scope>
                    <declaration name="uri" type="URI" line="1172"/>
                    <scope line="1173">
                        <scope line="1174"/>
                        <declaration name="cookies" type="Map&lt;String,List&lt;String&gt;&gt;" line="1177"/>
                        <scope line="1180">
                            <scope line="1181"/>
                            <scope line="1185">
                                <declaration name="key" type="String" line="1186"/>
                                <scope line="1190"/>
                                <declaration name="l" type="List&lt;String&gt;" line="1193"/>
                                <scope line="1194">
                                    <declaration name="cookieValue" type="StringBuilder" line="1195"/>
                                    <scope line="1196"/>
                                    <scope line="1200"/>
                                    <scope line="1202"/>
                                </scope>
                            </scope>
                        </scope>
                    </scope>
                    <scope line="1209">
                        <declaration name="k" type="int" line="1210"/>
                    </scope>
                    <scope line="1216">
                        <declaration name="k" type="int" line="1217"/>
                    </scope>
                </scope>
            </method>
            <method name="getInputStream" type="InputStream" line="1229">
                <comment line="1253">
                                        
                </comment>
                <comment line="1267">
                    Failed Negotiate
                    
                     In some cases, the Negotiate auth is supported for the
                     remote host but the negotiate process still fails (For
                     example, if the web page is located on a backend server
                     and delegation is needed but fails). The authentication
                     process will start again, and we need to detect this
                     kind of failure and do proper fallback (say, to NTLM).
                    
                     In order to achieve this, the inNegotiate flag is set
                     when the first negotiate challenge is met (and reset
                     if authentication is finished). If a fresh new negotiate
                     challenge (no parameter) is found while inNegotiate is
                     set, we know there&apos;s a failed auth attempt recently.
                     Here we&apos;ll ignore the header line so that fallback
                     can be practiced.
                    
                     inNegotiateProxy is for proxy authentication.                    
                </comment>
                <comment line="1290">
                    If the user has set either of these headers then do not remove them                    
                </comment>
                <comment line="1303">
                    Check if URL should be metered                    
                </comment>
                <comment line="1311">
                    REMIND: This exists to fix the HttpsURLConnection subclass.
                     Hotjava needs to run on JDK1.1FCS.  Do proper fix once a
                     proper solution for SSL can be found.                    
                </comment>
                <comment line="1338">
                    Read comments labeled &quot;Failed Negotiate&quot; for details.                    
                </comment>
                <comment line="1356">
                    changes: add a 3rd parameter to the constructor of
                     AuthenticationHeader, so that NegotiateAuthentication.
                     isSupported can be tested.
                     The other 2 appearances of &quot;new AuthenticationHeader&quot; is
                     altered in similar ways.                    
                </comment>
                <comment line="1378">
                                        
                </comment>
                <comment line="1403">
                    cache proxy authentication info                    
                </comment>
                <comment line="1405">
                    cache auth info on success, domain header not relevant.                    
                </comment>
                <comment line="1416">
                    Read comments labeled &quot;Failed Negotiate&quot; for details.                    
                </comment>
                <comment line="1445">
                                        
                </comment>
                <comment line="1462">
                    don&apos;t let things loop ad nauseum                    
                </comment>
                <comment line="1468">
                                        
                </comment>
                <comment line="1479">
                    cache server authentication info                    
                </comment>
                <comment line="1481">
                    cache auth info on success                    
                </comment>
                <comment line="1485">
                    check if the path is shorter than the existing entry                    
                </comment>
                <comment line="1489">
                                        
                </comment>
                <comment line="1492">
                    remove the entry and create a new one                    
                </comment>
                <comment line="1501">
                    what we cache is based on the domain list in the request                    
                </comment>
                <comment line="1511">
                                        
                </comment>
                <comment line="1521">
                    some flags should be reset to its initialized form so that
                     even after a redirect the necessary checks can still be
                     preformed.                    
                </comment>
                <comment line="1527">
                    serverAuthentication = null;                    
                </comment>
                <comment line="1541">
                    a flag need to clean                    
                </comment>
                <comment line="1545">
                    if we should follow a redirect, then the followRedirects()
                     method will disconnect() and re-connect us to the new
                     location                    
                </comment>
                <comment line="1551">
                    redirecting HTTP response may have set cookie, so
                     need to re-generate request header                    
                </comment>
                <comment line="1579">
                    give cache a chance to save response in cache                    
                </comment>
                <comment line="1585">
                    use reflection to get to the public
                     HttpsURLConnection instance saved in
                     DelegateHttpsURLConnection                    
                </comment>
                <comment line="1590">
                    ignored; use &apos;this&apos;                    
                </comment>
                <comment line="1592">
                    ignored; use &apos;this&apos;                    
                </comment>
                <comment line="1632">
                    buffer the error stream if bytes &lt; 4k
                     and it can be buffered within 1 second                    
                </comment>
                <scope line="1231"/>
                <scope line="1236">
                    <scope line="1239"/>
                </scope>
                <scope line="1244"/>
                <scope line="1248">
                    <scope line="1249"/>
                    <scope line="1254"/>
                </scope>
                <declaration name="redirects" type="int" line="1259"/>
                <declaration name="respCode" type="int" line="1260"/>
                <declaration name="cl" type="long" line="1261"/>
                <declaration name="serverAuthentication" type="AuthenticationInfo" line="1262"/>
                <declaration name="proxyAuthentication" type="AuthenticationInfo" line="1263"/>
                <declaration name="srvHdr" type="AuthenticationHeader" line="1264"/>
                <declaration name="inNegotiate" type="boolean" line="1286"/>
                <declaration name="inNegotiateProxy" type="boolean" line="1287"/>
                <scope line="1293">
                    <scope line="1294">
                        <scope line="1298"/>
                        <declaration name="meteredInput" type="boolean" line="1303"/>
                        <scope line="1305"/>
                        <scope line="1316"/>
                        <scope line="1320"/>
                        <scope line="1326"/>
                        <scope line="1330">
                            <scope line="1331"/>
                            <declaration name="dontUseNegotiate" type="boolean" line="1338"/>
                            <declaration name="iter" type="Iterator" line="1339"/>
                            <scope line="1340">
                                <declaration name="value" type="String" line="1341"/>
                                <scope line="1343">
                                    <scope line="1344"/>
                                    <scope line="1346"/>
                                </scope>
                            </scope>
                            <declaration name="authhdr" type="AuthenticationHeader" line="1361"/>
                            <scope line="1368">
                                <scope line="1371"/>
                            </scope>
                            <scope line="1376">
                                <declaration name="raw" type="String" line="1378"/>
                                <scope line="1381"/>
                                <scope line="1387"/>
                            </scope>
                        </scope>
                        <scope line="1395"/>
                        <scope line="1403"/>
                        <scope line="1408">
                            <scope line="1409"/>
                            <declaration name="dontUseNegotiate" type="boolean" line="1416"/>
                            <declaration name="iter" type="Iterator" line="1417"/>
                            <scope line="1418">
                                <declaration name="value" type="String" line="1419"/>
                                <scope line="1421">
                                    <scope line="1422"/>
                                    <scope line="1424"/>
                                </scope>
                            </scope>
                            <declaration name="raw" type="String" line="1439"/>
                            <scope line="1440">
                                <scope line="1442">
                                    <scope line="1443"/>
                                    <scope line="1452"/>
                                </scope>
                                <scope line="1459"/>
                            </scope>
                            <scope line="1465">
                                <scope line="1468"/>
                            </scope>
                        </scope>
                        <scope line="1479">
                            <scope line="1482">
                                <scope line="1483">
                                    <declaration name="npath" type="String" line="1485"/>
                                    <declaration name="opath" type="String" line="1486"/>
                                    <scope line="1487"/>
                                    <declaration name="a" type="BasicAuthentication" line="1492"/>
                                </scope>
                            </scope>
                            <scope line="1499">
                                <declaration name="srv" type="DigestAuthentication" line="1501"/>
                                <declaration name="tok" type="StringTokenizer" line="1503"/>
                                <declaration name="realm" type="String" line="1504"/>
                                <declaration name="pw" type="PasswordAuthentication" line="1505"/>
                                <scope line="1507">
                                    <declaration name="path" type="String" line="1508"/>
                                    <scope line="1509">
                                        <declaration name="u" type="URL" line="1511"/>
                                        <declaration name="d" type="DigestAuthentication" line="1512"/>
                                    </scope>
                                    <scope line="1515"/>
                                </scope>
                            </scope>
                        </scope>
                        <scope line="1534"/>
                        <scope line="1536"/>
                        <scope line="1543"/>
                        <scope line="1557"/>
                        <scope line="1559"/>
                        <scope line="1563">
                            <scope line="1565"/>
                        </scope>
                        <scope line="1576">
                            <scope line="1577">
                                <declaration name="uri" type="URI" line="1579"/>
                                <scope line="1580">
                                    <declaration name="uconn" type="URLConnection" line="1581"/>
                                    <scope line="1582">
                                        <scope line="1583"/>
                                        <scope line="1588"/>
                                        <scope line="1590"/>
                                    </scope>
                                    <declaration name="cacheRequest" type="CacheRequest" line="1594"/>
                                    <scope line="1596"/>
                                </scope>
                            </scope>
                        </scope>
                        <scope line="1604"/>
                        <scope line="1608">
                            <scope line="1609"/>
                            <scope line="1611"/>
                        </scope>
                    </scope>
                </scope>
                <scope line="1624"/>
                <scope line="1628">
                    <declaration name="te" type="String" line="1633"/>
                    <scope line="1635"/>
                </scope>
                <scope line="1639">
                    <scope line="1640"/>
                    <scope line="1643"/>
                </scope>
            </method>
            <method name="getChainedException" type="IOException" line="1654">
                <params>
                    <param name="rememberedException" type="IOException"/>
                </params>
                <scope line="1655">
                    <declaration name="args" type="Object[]" line="1656"/>
                    <anonymous_class line="1659">
                        <method name="run" type="IOException" line="1660"/>
                    </anonymous_class>
                    <declaration name="chainedException" type="IOException" line="1657"/>
                </scope>
                <scope line="1669"/>
            </method>
            <method name="getErrorStream" type="InputStream" line="1675">
                <comment line="1678">
                    Client Error 4xx and Server Error 5xx                    
                </comment>
                <scope line="1676">
                    <scope line="1678"/>
                    <scope line="1680"/>
                </scope>
            </method>
            <javadoc line="1687">
                set or reset proxy authentication info in request headers
                  after receiving a 407 error. In the case of NTLM however,
                  receiving a 407 is normal and we just skip the stale check
                  because ntlm does not support this feature.                
            </javadoc>
            <method name="resetProxyAuthentication" type="AuthenticationInfo" line="1694">
                <params>
                    <param name="proxyAuthentication" type="AuthenticationInfo"/>
                    <param name="auth" type="AuthenticationHeader"/>
                </params>
                <comment line="1700">
                                        
                </comment>
                <scope line="1696">
                    <declaration name="raw" type="String" line="1697"/>
                    <scope line="1698">
                        <declaration name="value" type="String" line="1700"/>
                        <scope line="1701">
                            <declaration name="digestProxy" type="DigestAuthentication" line="1702"/>
                            <scope line="1704"/>
                            <scope line="1706"/>
                        </scope>
                        <scope line="1709"/>
                    </scope>
                    <scope line="1715"/>
                </scope>
            </method>
            <javadoc line="1724">
                Returns the tunnel state.                
                <return>
                    the state                    
                </return>
            </javadoc>
            <method name="tunnelState" type="TunnelState" line="1729"/>
            <javadoc line="1733">
                Set the tunneling status.                
                <param>
                    the state                    
                </param>
            </javadoc>
            <method name="setTunnelState" type="void" line="1738">
                <params>
                    <param name="tunnelState" type="TunnelState"/>
                </params>
            </method>
            <javadoc line="1742">
                establish a tunnel through proxy server                
            </javadoc>
            <method name="doTunneling" type="void" line="1745">
                <comment line="1754">
                    save current requests so that they can be restored after tunnel is setup.                    
                </comment>
                <comment line="1758">
                    Read comments labeled &quot;Failed Negotiate&quot; for details.                    
                </comment>
                <comment line="1762">
                                        
                </comment>
                <comment line="1769">
                    send the &quot;CONNECT&quot; request to establish a tunnel
                     through proxy server                    
                </comment>
                <comment line="1774">
                    There is no need to track progress in HTTP Tunneling,
                     so ProgressSource is null.                    
                </comment>
                <comment line="1778">
                                        
                </comment>
                <comment line="1788">
                    Read comments labeled &quot;Failed Negotiate&quot; for details.                    
                </comment>
                <comment line="1835">
                    cache proxy authentication info                    
                </comment>
                <comment line="1837">
                    cache auth info on success, domain header not relevant.                    
                </comment>
                <comment line="1845">
                    we don&apos;t know how to deal with other response code
                     so disconnect and report error                    
                </comment>
                <comment line="1863">
                    restore original request headers                    
                </comment>
                <comment line="1866">
                    reset responses                    
                </comment>
                <declaration name="retryTunnel" type="int" line="1746"/>
                <declaration name="statusLine" type="String" line="1747"/>
                <declaration name="respCode" type="int" line="1748"/>
                <declaration name="proxyAuthentication" type="AuthenticationInfo" line="1749"/>
                <declaration name="proxyHost" type="String" line="1750"/>
                <declaration name="proxyPort" type="int" line="1751"/>
                <declaration name="savedRequests" type="MessageHeader" line="1754"/>
                <declaration name="inNegotiateProxy" type="boolean" line="1758"/>
                <scope line="1760">
                    <scope line="1764">
                        <scope line="1765"/>
                        <scope line="1778"/>
                        <declaration name="st" type="StringTokenizer" line="1783"/>
                        <scope line="1786">
                            <declaration name="dontUseNegotiate" type="boolean" line="1788"/>
                            <declaration name="iter" type="Iterator" line="1789"/>
                            <scope line="1790">
                                <declaration name="value" type="String" line="1791"/>
                                <scope line="1793">
                                    <scope line="1794"/>
                                    <scope line="1796"/>
                                </scope>
                            </scope>
                            <declaration name="authhdr" type="AuthenticationHeader" line="1805"/>
                            <scope line="1811">
                                <scope line="1814"/>
                            </scope>
                            <scope line="1821">
                                <declaration name="raw" type="String" line="1822"/>
                                <scope line="1825"/>
                            </scope>
                        </scope>
                        <scope line="1835"/>
                        <scope line="1840"/>
                    </scope>
                    <scope line="1851"/>
                </scope>
                <scope line="1856">
                    <scope line="1857"/>
                </scope>
            </method>
            <method name="connectRequestURI" type="String" line="1869">
                <params>
                    <param name="url" type="URL"/>
                </params>
                <declaration name="host" type="String" line="1870"/>
                <declaration name="port" type="int" line="1871"/>
            </method>
            <javadoc line="1877">
                send a CONNECT request for establishing a tunnel to proxy server                
            </javadoc>
            <method name="sendCONNECTRequest" type="void" line="1880">
                <comment line="1884">
                    setRequests == true indicates the std. request headers
                     have been set in (previous) requests.
                     so the first one must be the http method (GET, etc.).
                     we need to set it to CONNECT soon, remove this one first.
                     otherwise, there may have 2 http methods in headers                    
                </comment>
                <comment line="1901">
                    Not really necessary for a tunnel, but can&apos;t hurt                    
                </comment>
                <comment line="1910">
                                        
                </comment>
                <comment line="1916">
                    remove CONNECT header                    
                </comment>
                <declaration name="port" type="int" line="1881"/>
                <declaration name="host" type="String" line="1894"/>
                <scope line="1895"/>
                <scope line="1903"/>
                <scope line="1910"/>
            </method>
            <javadoc line="1919">
                Sets pre-emptive proxy authentication in header                
            </javadoc>
            <method name="setPreemptiveProxyAuthentication" type="void" line="1922">
                <params>
                    <param name="requests" type="MessageHeader"/>
                </params>
                <comment line="1941">
                    Sets &quot;Proxy-authorization&quot;                    
                </comment>
                <declaration name="pauth" type="AuthenticationInfo" line="1923"/>
                <scope line="1926">
                    <declaration name="value" type="String" line="1927"/>
                    <scope line="1928">
                        <declaration name="digestProxy" type="DigestAuthentication" line="1929"/>
                        <scope line="1930"/>
                        <scope line="1933"/>
                    </scope>
                    <scope line="1936"/>
                </scope>
            </method>
            <javadoc line="1946">
                Gets the authentication for an HTTP proxy, and applies it to
                  the connection.                
            </javadoc>
            <method name="getHttpProxyAuthentication" type="AuthenticationInfo" line="1950">
                <params>
                    <param name="authhdr" type="AuthenticationHeader"/>
                </params>
                <comment line="1952">
                                        
                </comment>
                <comment line="1995">
                    User will have an unknown host.                    
                </comment>
                <comment line="2018">
                    tryTransparentNTLMProxy will always be true the first
                     time around, but verify that the platform supports it                    
                </comment>
                <comment line="2033">
                    If we are not trying transparent authentication then
                     we need to have a PasswordAuthentication instance. For
                     transparent authentication (Windows only) the username
                     and password will be picked up from the current logged
                     on users credentials.                    
                </comment>
                <comment line="2044">
                                        
                </comment>
                <comment line="2060">
                    For backwards compatibility, we also try defaultAuth
                     REMIND:  Get rid of this for JDK2.0.                    
                </comment>
                <comment line="2070">
                    not in cache by default - cache on success                    
                </comment>
                <declaration name="ret" type="AuthenticationInfo" line="1952"/>
                <declaration name="raw" type="String" line="1953"/>
                <declaration name="host" type="String" line="1954"/>
                <declaration name="port" type="int" line="1955"/>
                <scope line="1956">
                    <declaration name="p" type="HeaderParser" line="1957"/>
                    <declaration name="realm" type="String" line="1958"/>
                    <declaration name="scheme" type="String" line="1959"/>
                    <declaration name="authScheme" type="AuthScheme" line="1960"/>
                    <scope line="1961"/>
                    <scope line="1963"/>
                    <scope line="1965"/>
                    <scope line="1968"/>
                    <scope line="1971"/>
                    <scope line="1980">
                        <declaration name="addr" type="InetAddress" line="1983"/>
                        <scope line="1984">
                            <declaration name="finalHost" type="String" line="1985"/>
                            <anonymous_class line="1987">
                                <method name="run" type="InetAddress" line="1989"/>
                            </anonymous_class>
                        </scope>
                        <scope line="1993"/>
                        <declaration name="a" type="PasswordAuthentication" line="1996"/>
                        <scope line="2000"/>
                        <scope line="2008">
                            <declaration name="params" type="DigestAuthentication.Parameters" line="2009"/>
                        </scope>
                        <scope line="2016">
                            <scope line="2020"/>
                            <scope line="2025"/>
                            <scope line="2027"/>
                            <scope line="2039"/>
                        </scope>
                    </scope>
                    <scope line="2063">
                        <scope line="2064">
                            <declaration name="u" type="URL" line="2065"/>
                            <declaration name="a" type="String" line="2066"/>
                            <scope line="2067"/>
                        </scope>
                        <scope line="2071"/>
                    </scope>
                    <scope line="2074">
                        <scope line="2075"/>
                    </scope>
                </scope>
                <scope line="2080"/>
            </method>
            <javadoc line="2086">
                Gets the authentication for an HTTP server, and applies it to
                  the connection.                
                <param>
                    authHdr the AuthenticationHeader which tells what auth scheme is
                      prefered.                    
                </param>
            </javadoc>
            <method name="getServerAuthentication" type="AuthenticationInfo" line="2092">
                <params>
                    <param name="authhdr" type="AuthenticationHeader"/>
                </params>
                <comment line="2094">
                                        
                </comment>
                <comment line="2097">
                                        
                </comment>
                <comment line="2128">
                    User will have addr = null                    
                </comment>
                <comment line="2131">
                    replacing -1 with default port for a protocol                    
                </comment>
                <comment line="2166">
                                        
                </comment>
                <comment line="2171">
                    tryTransparentNTLMServer will always be true the first
                     time around, but verify that the platform supports it                    
                </comment>
                <comment line="2177">
                    If the platform supports transparent authentication
                     then check if we are in a secure environment                    
                </comment>
                <comment line="2194">
                    If we are not trying transparent authentication then
                     we need to have a PasswordAuthentication instance. For
                     transparent authentication (Windows only) the username
                     and password will be picked up from the current logged
                     on users credentials.                    
                </comment>
                <comment line="2205">
                                        
                </comment>
                <comment line="2216">
                    For backwards compatibility, we also try defaultAuth
                     REMIND:  Get rid of this for JDK2.0.                    
                </comment>
                <comment line="2224">
                    not in cache by default - cache on success                    
                </comment>
                <declaration name="ret" type="AuthenticationInfo" line="2094"/>
                <declaration name="raw" type="String" line="2095"/>
                <scope line="2097">
                    <declaration name="p" type="HeaderParser" line="2098"/>
                    <declaration name="realm" type="String" line="2099"/>
                    <declaration name="scheme" type="String" line="2100"/>
                    <declaration name="authScheme" type="AuthScheme" line="2101"/>
                    <scope line="2102"/>
                    <scope line="2104"/>
                    <scope line="2106"/>
                    <scope line="2109"/>
                    <scope line="2112"/>
                    <declaration name="addr" type="InetAddress" line="2122"/>
                    <scope line="2123">
                        <scope line="2124"/>
                        <scope line="2126"/>
                    </scope>
                    <declaration name="port" type="int" line="2131"/>
                    <scope line="2132"/>
                    <scope line="2135">
                        <declaration name="a" type="PasswordAuthentication" line="2144"/>
                        <scope line="2148"/>
                        <scope line="2156"/>
                        <scope line="2162">
                            <declaration name="url1" type="URL" line="2163"/>
                            <scope line="2164"/>
                            <scope line="2166"/>
                            <scope line="2173">
                                <scope line="2179"/>
                            </scope>
                            <scope line="2185"/>
                            <scope line="2187"/>
                            <scope line="2200"/>
                        </scope>
                    </scope>
                    <scope line="2219">
                        <declaration name="a" type="String" line="2220"/>
                        <scope line="2221"/>
                    </scope>
                    <scope line="2227">
                        <scope line="2228"/>
                    </scope>
                </scope>
                <scope line="2233"/>
            </method>
            <method name="checkResponseCredentials" type="void" line="2244">
                <params>
                    <param name="inClose" type="boolean"/>
                </params>
                <scope line="2245">
                    <scope line="2249">
                        <declaration name="raw" type="String" line="2250"/>
                        <scope line="2251">
                            <declaration name="da" type="DigestAuthentication" line="2252"/>
                        </scope>
                    </scope>
                    <scope line="2259">
                        <declaration name="raw" type="String" line="2260"/>
                        <scope line="2261">
                            <declaration name="da" type="DigestAuthentication" line="2262"/>
                        </scope>
                    </scope>
                    <scope line="2268"/>
                </scope>
                <scope line="2271"/>
            </method>
            <declaration name="requestURI" type="String" line="2282"/>
            <method name="getRequestURI" type="String" line="2284">
                <scope line="2285"/>
            </method>
            <method name="followRedirect" type="boolean" line="2296">
                <comment line="2309">
                    this should be present - if not, we have no choice
                     but to go forward w the response we got                    
                </comment>
                <comment line="2322">
                    treat loc as a relative URI to conform to popular browsers                    
                </comment>
                <comment line="2333">
                    clear out old response headers!!!!                    
                </comment>
                <comment line="2336">
                    This means we must re-request the resource through the
                     proxy denoted in the &quot;Location:&quot; field of the response.
                     Judging by the spec, the string in the Location header
                     _should_ denote a URL - let&apos;s hope for &quot;http:my.proxy.org&quot;
                     Make a new HttpClient to the proxy, using HttpClient&apos;s
                     Instance-specific proxy fields, but note we&apos;re still fetching
                     the same URL.                    
                </comment>
                <comment line="2357">
                    maintain previous headers, just change the name
                     of the file we&apos;re getting                    
                </comment>
                <comment line="2360">
                    force it to be recalculated                    
                </comment>
                <comment line="2362">
                    The HTTP1.1 spec says that a redirect from a POST
                     should not be immediately turned into a GET, and
                     that some HTTP1.0 clients incorrectly did this.
                     Correct behavior redirects a POST to another POST.
                     Unfortunately, since most browsers have this incorrect
                     behavior, the web works this way now.  Typical usage
                     seems to be:
                       POST a login code or passwd to a web page.
                       after validation, the server redirects to another
                         (welcome) page
                       The second request is (erroneously) expected to be GET
                    
                     We will do the incorrect thing (POST--&gt;GET) by default.
                     We will provide the capability to do the &quot;right&quot; thing
                     (POST--&gt;POST) by a system property, &quot;http.strictPostRedirect=true&quot;                    
                </comment>
                <comment line="2388">
                    Even after a connect() call, http variable still can be
                     null, if a ResponseCache has been installed and it returns
                     a non-null CacheResponse instance. So check nullity before using it.
                    
                     And further, if http is null, there&apos;s no need to do anything
                     about request headers because successive http session will use
                     cachedInputStreamcachedHeaders anyway, which is returned by
                     CacheResponse.                    
                </comment>
                <scope line="2297"/>
                <declaration name="stat" type="int" line="2301"/>
                <scope line="2303"/>
                <declaration name="loc" type="String" line="2306"/>
                <scope line="2307"/>
                <declaration name="locUrl" type="URL" line="2313"/>
                <scope line="2314">
                    <scope line="2316"/>
                </scope>
                <scope line="2320"/>
                <scope line="2325"/>
                <scope line="2328"/>
                <scope line="2334">
                    <declaration name="proxyHost" type="String" line="2343"/>
                    <declaration name="proxyPort" type="int" line="2344"/>
                    <declaration name="security" type="SecurityManager" line="2346"/>
                    <scope line="2347"/>
                </scope>
                <scope line="2355">
                    <scope line="2360"/>
                    <scope line="2384">
                        <scope line="2396">
                            <declaration name="port" type="int" line="2399"/>
                            <declaration name="host" type="String" line="2400"/>
                            <scope line="2401"/>
                        </scope>
                    </scope>
                </scope>
            </method>
            <declaration name="cdata" type="byte[]" line="2412"/>
            <javadoc line="2414">
                Reset (without disconnecting the TCP conn) in order to do another transaction with this instance                
            </javadoc>
            <method name="reset" type="void" line="2417">
                <comment line="2420">
                                        
                </comment>
                <comment line="2425">
                    we want to read the rest of the response without using the
                     hurry mechanism, because that would close the connection
                     if everything is not available immediately                    
                </comment>
                <comment line="2431">
                                        
                </comment>
                <comment line="2434">
                    raw stream, which will block on read, so only read
                     the expected number of bytes, probably 0                    
                </comment>
                <declaration name="is" type="InputStream" line="2421"/>
                <scope line="2422">
                    <scope line="2423">
                        <scope line="2429">
                            <scope line="2431"/>
                        </scope>
                        <scope line="2432">
                            <declaration name="cl" type="long" line="2436"/>
                            <declaration name="n" type="int" line="2437"/>
                            <declaration name="cls" type="String" line="2438"/>
                            <scope line="2439">
                                <scope line="2440"/>
                                <scope line="2442"/>
                            </scope>
                            <scope line="2446">
                                <scope line="2447"/>
                                <scope line="2449"/>
                            </scope>
                        </scope>
                    </scope>
                    <scope line="2454"/>
                    <scope line="2460">
                        <scope line="2461"/>
                    </scope>
                    <scope line="2464"/>
                </scope>
            </method>
            <javadoc line="2471">
                Disconnect from the web server at the first 401 error. Do not
                  disconnect when using a proxy, a good proxy should have already
                  closed the connection to the web server.                
            </javadoc>
            <method name="disconnectWeb" type="void" line="2476">
                <comment line="2480">
                    clean up, particularly, skip the content part
                     of a 401 error response                    
                </comment>
                <scope line="2477"/>
                <scope line="2482"/>
            </method>
            <javadoc line="2487">
                Disconnect from the server (for internal use)                
            </javadoc>
            <method name="disconnectInternal" type="void" line="2490">
                <scope line="2493"/>
                <scope line="2497"/>
            </method>
            <javadoc line="2504">
                Disconnect from the server (public API)                
            </javadoc>
            <method name="disconnect" type="void" line="2507">
                <comment line="2517">
                    If we have an input stream this means we received a response
                     from the server. That stream may have been read to EOF and
                     dependening on the stream type may already be closed or the
                     the http client may be returned to the keep-alive cache.
                     If the http client has been returned to the keep-alive cache
                     it may be closed (idle timeout) or may be allocated to
                     another request.
                    
                     In other to avoid timing issues we close the input stream
                     which will either close the underlying connection or return
                     the client to the cache. If there&apos;s a possibility that the
                     client has been returned to the cache (ie: stream is a keep
                     alive stream or a chunked input stream) then we remove an
                     idle connection to the server. Note that this approach
                     can be considered an approximation in that we may close a
                     different idle connection to that used by the request.
                     Additionally it&apos;s possible that we close two connections
                     - the first becuase it wasn&apos;t an EOF (and couldn&apos;t be
                     hurried) - the second, another idle connection to the
                     same server. The is okay because &quot;disconnect&quot; is an
                     indication that the application doesn&apos;t intend to access
                     this http server for a while.                    
                </comment>
                <comment line="2545">
                    un-synchronized                    
                </comment>
                <comment line="2552">
                    if the connection is persistent it may have been closed
                     or returned to the keep-alive cache. If it&apos;s been returned
                     to the keep-alive cache then we would like to close it
                     but it may have been allocated                    
                </comment>
                <comment line="2563">
                    We are deliberatly being disconnected so HttpClient
                     should not try to resend the request no matter what stage
                     of the connection we are in.                    
                </comment>
                <comment line="2571">
                    poster = null;                    
                </comment>
                <scope line="2510"/>
                <scope line="2515">
                    <scope line="2541">
                        <declaration name="hc" type="HttpClient" line="2542"/>
                        <declaration name="ka" type="boolean" line="2545"/>
                        <scope line="2547"/>
                        <scope line="2549"/>
                        <scope line="2556"/>
                    </scope>
                    <scope line="2561"/>
                </scope>
                <scope line="2575"/>
            </method>
            <method name="usingProxy" type="boolean" line="2580">
                <scope line="2581"/>
            </method>
            <javadoc line="2587">
                Gets a header field by name. Returns null if not known.                
                <param>
                    name the name of the header field                    
                </param>
            </javadoc>
            <method name="getHeaderField" type="String" line="2592">
                <params>
                    <param name="name" type="String"/>
                </params>
                <scope line="2593"/>
                <scope line="2595"/>
                <scope line="2597"/>
            </method>
            <javadoc line="2604">
                Returns an unmodifiable Map of the header fields.
                  The Map keys are Strings that represent the
                  response-header field names. Each Map value is an
                  unmodifiable List of Strings that represents
                  the corresponding field values.                
                <return>
                    a Map of header fields                    
                </return>
                <since>
                    1.4                    
                </since>
            </javadoc>
            <method name="getHeaderFields" type="Map<String,List<String>>" line="2615">
                <scope line="2616"/>
                <scope line="2618"/>
                <scope line="2620"/>
            </method>
            <javadoc line="2627">
                Gets a header field by index. Returns null if not known.                
                <param>
                    n the index of the header field                    
                </param>
            </javadoc>
            <method name="getHeaderField" type="String" line="2632">
                <params>
                    <param name="n" type="int"/>
                </params>
                <scope line="2633"/>
                <scope line="2635"/>
                <scope line="2637"/>
            </method>
            <javadoc line="2643">
                Gets a header field by index. Returns null if not known.                
                <param>
                    n the index of the header field                    
                </param>
            </javadoc>
            <method name="getHeaderFieldKey" type="String" line="2648">
                <params>
                    <param name="n" type="int"/>
                </params>
                <scope line="2649"/>
                <scope line="2651"/>
                <scope line="2653"/>
            </method>
            <javadoc line="2660">
                Sets request property. If a property with the key already
                  exists, overwrite its value with the new value.                
                <param>
                    value the value to be set                    
                </param>
            </javadoc>
            <method name="setRequestProperty" type="void" line="2666">
                <params>
                    <param name="key" type="String"/>
                    <param name="value" type="String"/>
                </params>
                <scope line="2672"/>
            </method>
            <javadoc line="2677">
                Adds a general request property specified by a
                  key-value pair.  This method will not overwrite
                  existing values associated with the same key.                
                <param>
                    key     the keyword by which the request is known
                      (e.g., "<code>accept</code>").                    
                </param>
                <param>
                    value  the value associated with it.                    
                </param>
                <see>
                    #getRequestProperties(java.lang.String)                    
                </see>
                <since>
                    1.4                    
                </since>
            </javadoc>
            <method name="addRequestProperty" type="void" line="2689">
                <params>
                    <param name="key" type="String"/>
                    <param name="value" type="String"/>
                </params>
                <scope line="2695"/>
            </method>
            <method name="setAuthenticationProperty" type="void" line="2704">
                <params>
                    <param name="key" type="String"/>
                    <param name="value" type="String"/>
                </params>
            </method>
            <method name="getRequestProperty" type="String" line="2710">
                <params>
                    <param name="key" type="String"/>
                </params>
                <comment line="2716">
                    don&apos;t return headers containing security sensitive information                    
                </comment>
                <scope line="2711"/>
                <scope line="2716">
                    <scope line="2717"/>
                </scope>
                <scope line="2721">
                    <scope line="2722"/>
                    <scope line="2725"/>
                </scope>
            </method>
            <javadoc line="2732">
                Returns an unmodifiable Map of general request
                  properties for this connection. The Map keys
                  are Strings that represent the request-header
                  field names. Each Map value is a unmodifiable List
                  of Strings that represents the corresponding
                  field values.                
                <return>
                    a Map of the general request properties for this connection.                    
                </return>
                <throws>
                    IllegalStateException if already connected                    
                </throws>
                <since>
                    1.4                    
                </since>
            </javadoc>
            <method name="getRequestProperties" type="Map<String,List<String>>" line="2745">
                <comment line="2750">
                    exclude headers containing security-sensitive info                    
                </comment>
                <comment line="2754">
                    The cookies in the requests message headers may have
                     been modified. Use the saved user cookies instead.                    
                </comment>
                <scope line="2750"/>
                <declaration name="userCookiesMap" type="Map" line="2757"/>
                <scope line="2758">
                    <scope line="2760"/>
                    <scope line="2763"/>
                </scope>
            </method>
            <method name="setConnectTimeout" type="void" line="2771">
                <params>
                    <param name="timeout" type="int"/>
                </params>
            </method>
            <javadoc line="2778">
                Returns setting for connect timeout.
                  &lt;p&gt;
                  0 return implies that the option is disabled
                  (i.e., timeout of infinity).                
                <return>
                    an <code>int</code> that indicates the connect timeout
                      value in milliseconds                    
                </return>
                <see>
                    java.net.URLConnection#setConnectTimeout(int)                    
                </see>
                <see>
                    java.net.URLConnection#connect()                    
                </see>
                <since>
                    1.5                    
                </since>
            </javadoc>
            <method name="getConnectTimeout" type="int" line="2791"/>
            <javadoc line="2795">
                Sets the read timeout to a specified timeout, in
                  milliseconds. A non-zero value specifies the timeout when
                  reading from Input stream when a connection is established to a
                  resource. If the timeout expires before there is data available
                  for read, a java.net.SocketTimeoutException is raised. A
                  timeout of zero is interpreted as an infinite timeout.
                  &lt;p&gt; Some non-standard implementation of this method ignores the
                  specified timeout. To see the read timeout set, please call
                  getReadTimeout().                
                <param>
                    timeout an <code>int</code> that specifies the timeout
                      value to be used in milliseconds                    
                </param>
                <throws>
                    IllegalArgumentException if the timeout parameter is negative                    
                </throws>
                <see>
                    java.net.URLConnectiongetReadTimeout()                    
                </see>
                <see>
                    java.io.InputStream#read()                    
                </see>
                <since>
                    1.5                    
                </since>
            </javadoc>
            <method name="setReadTimeout" type="void" line="2816">
                <params>
                    <param name="timeout" type="int"/>
                </params>
            </method>
            <javadoc line="2822">
                Returns setting for read timeout. 0 return implies that the
                  option is disabled (i.e., timeout of infinity).                
                <return>
                    an <code>int</code> that indicates the read timeout
                      value in milliseconds                    
                </return>
                <see>
                    java.net.URLConnection#setReadTimeout(int)                    
                </see>
                <see>
                    java.io.InputStream#read()                    
                </see>
                <since>
                    1.5                    
                </since>
            </javadoc>
            <method name="getReadTimeout" type="int" line="2834"/>
            <method name="getMethod" type="String" line="2838"/>
            <method name="mapToMessageHeader" type="MessageHeader" line="2842">
                <params>
                    <param name="map" type="Map<String,List<String>>"/>
                </params>
                <declaration name="headers" type="MessageHeader" line="2843"/>
                <scope line="2844"/>
                <scope line="2847">
                    <declaration name="key" type="String" line="2848"/>
                    <declaration name="values" type="List&lt;String&gt;" line="2849"/>
                    <scope line="2850">
                        <scope line="2851"/>
                        <scope line="2853"/>
                    </scope>
                </scope>
            </method>
            <class name="HttpInputStream" line="2865">
                <extends class="FilterInputStream"/>
                <comment line="351">
                                        
                </comment>
                <comment line="354">
                                        
                </comment>
                <comment line="357">
                                        
                </comment>
                <comment line="2997">
                    skip() calls read() in order to ensure that entire response gets                    
                </comment>
                <comment line="3112">
                    this is called to check that all the bytes
                     that were supposed to be written were written
                     and that the stream is now closed().                    
                </comment>
                <comment line="3162">
                    when this method is called, it&apos;s either the case that cl &gt; 0, or
                     if chunk-encoded, cl = -1; in other words, cl can&apos;t be 0                    
                </comment>
                <declaration name="cacheRequest" type="CacheRequest" line="2866"/>
                <declaration name="outputStream" type="OutputStream" line="2867"/>
                <declaration name="marked" type="boolean" line="2868"/>
                <declaration name="inCache" type="int" line="2869"/>
                <declaration name="markCount" type="int" line="2870"/>
                <method name="HttpInputStream" type="constructor" line="2872">
                    <params>
                        <param name="is" type="InputStream"/>
                    </params>
                </method>
                <method name="HttpInputStream" type="constructor" line="2878">
                    <params>
                        <param name="is" type="InputStream"/>
                        <param name="cacheRequest" type="CacheRequest"/>
                    </params>
                    <scope line="2881"/>
                    <scope line="2883"/>
                </method>
                <javadoc line="2890">
                    Marks the current position in this input stream. A subsequent
                      call to the &lt;code&gt;reset&lt;/code&gt; method repositions this stream at
                      the last marked position so that subsequent reads re-read the same
                      bytes.
                      &lt;p&gt;
                      The &lt;code&gt;readlimit&lt;/code&gt; argument tells this input stream to
                      allow that many bytes to be read before the mark position gets
                      invalidated.
                      &lt;p&gt;
                      This method simply performs &lt;code&gt;in.mark(readlimit)&lt;/code&gt;.                    
                    <param>
                        readlimit   the maximum limit of bytes that can be read before
                          the mark position becomes invalid.                        
                    </param>
                    <see>
                        java.io.FilterInputStream#in                        
                    </see>
                    <see>
                        java.io.FilterInputStream#reset()                        
                    </see>
                </javadoc>
                <method name="mark" type="void" line="2908">
                    <params>
                        <param name="readlimit" type="int"/>
                    </params>
                    <scope line="2910"/>
                </method>
                <javadoc line="2916">
                    Repositions this stream to the position at the time the
                      &lt;code&gt;mark&lt;/code&gt; method was last called on this input stream.
                      &lt;p&gt;
                      This method
                      simply performs &lt;code&gt;in.reset()&lt;/code&gt;.
                      &lt;p&gt;
                      Stream marks are intended to be used in
                      situations where you need to read ahead a little to see what&apos;s in
                      the stream. Often this is most easily done by invoking some
                      general parser. If the stream is of the type handled by the
                      parse, it just chugs along happily. If the stream is not of
                      that type, the parser should toss an exception when it fails.
                      If this happens within readlimit bytes, it allows the outer
                      code to reset the stream and try another parser.                    
                    <exception>
                        IOException  if the stream has not been marked or if the
                          mark has been invalidated.                        
                    </exception>
                    <see>
                        java.io.FilterInputStream#in                        
                    </see>
                    <see>
                        java.io.FilterInputStream#mark(int)                        
                    </see>
                </javadoc>
                <method name="reset" type="void" line="2938">
                    <scope line="2940"/>
                </method>
                <method name="read" type="int" line="2947">
                    <scope line="2948">
                        <declaration name="b" type="byte[]" line="2949"/>
                        <declaration name="ret" type="int" line="2950"/>
                    </scope>
                    <scope line="2952">
                        <scope line="2953"/>
                    </scope>
                </method>
                <method name="read" type="int" line="2961">
                    <params>
                        <param name="b" type="byte[]"/>
                    </params>
                </method>
                <method name="read" type="int" line="2966">
                    <params>
                        <param name="b" type="byte[]"/>
                        <param name="off" type="int"/>
                        <param name="len" type="int"/>
                    </params>
                    <comment line="2971">
                        write to cache                        
                    </comment>
                    <scope line="2967">
                        <declaration name="newLen" type="int" line="2968"/>
                        <declaration name="nWrite" type="int" line="2969"/>
                        <scope line="2971">
                            <scope line="2972"/>
                            <scope line="2975"/>
                        </scope>
                        <scope line="2979"/>
                        <scope line="2984"/>
                    </scope>
                    <scope line="2988">
                        <scope line="2989"/>
                    </scope>
                </method>
                <declaration name="skipBuffer" type="byte[]" line="2999"/>
                <declaration name="SKIP_BUFFER_SIZE" type="int" line="3000"/>
                <method name="skip" type="long" line="3003">
                    <params>
                        <param name="n" type="long"/>
                    </params>
                    <declaration name="remaining" type="long" line="3005"/>
                    <declaration name="nr" type="int" line="3006"/>
                    <declaration name="localSkipBuffer" type="byte[]" line="3010"/>
                    <scope line="3012"/>
                    <scope line="3016">
                        <scope line="3019"/>
                    </scope>
                </method>
                <method name="close" type="void" line="3029">
                    <scope line="3030">
                        <scope line="3031">
                            <scope line="3032"/>
                            <scope line="3034"/>
                        </scope>
                    </scope>
                    <scope line="3039">
                        <scope line="3040"/>
                    </scope>
                    <scope line="3044"/>
                </method>
            </class>
            <class name="StreamingOutputStream" line="3051">
                <extends class="FilterOutputStream"/>
                <comment line="351">
                                        
                </comment>
                <comment line="354">
                                        
                </comment>
                <comment line="357">
                                        
                </comment>
                <comment line="2997">
                    skip() calls read() in order to ensure that entire response gets                    
                </comment>
                <comment line="3112">
                    this is called to check that all the bytes
                     that were supposed to be written were written
                     and that the stream is now closed().                    
                </comment>
                <comment line="3162">
                    when this method is called, it&apos;s either the case that cl &gt; 0, or
                     if chunk-encoded, cl = -1; in other words, cl can&apos;t be 0                    
                </comment>
                <declaration name="expected" type="long" line="3053"/>
                <declaration name="written" type="long" line="3054"/>
                <declaration name="closed" type="boolean" line="3055"/>
                <declaration name="error" type="boolean" line="3056"/>
                <declaration name="errorExcp" type="IOException" line="3057"/>
                <javadoc line="3059">
                    expectedLength == -1 if the stream is chunked
                      expectedLength &gt; 0 if the stream is fixed content-length
                      In the 2nd case, we make sure the expected number of
                      of bytes are actually written                    
                </javadoc>
                <method name="StreamingOutputStream" type="constructor" line="3065">
                    <params>
                        <param name="os" type="OutputStream"/>
                        <param name="expectedLength" type="long"/>
                    </params>
                </method>
                <method name="write" type="void" line="3074">
                    <params>
                        <param name="b" type="int"/>
                    </params>
                    <scope line="3077"/>
                </method>
                <method name="write" type="void" line="3084">
                    <params>
                        <param name="b" type="byte[]"/>
                    </params>
                </method>
                <method name="write" type="void" line="3089">
                    <params>
                        <param name="b" type="byte[]"/>
                        <param name="off" type="int"/>
                        <param name="len" type="int"/>
                    </params>
                    <scope line="3092"/>
                </method>
                <method name="checkError" type="void" line="3099">
                    <scope line="3100"/>
                    <scope line="3103"/>
                    <scope line="3106"/>
                </method>
                <method name="writtenOK" type="boolean" line="3115"/>
                <method name="close" type="void" line="3120">
                    <comment line="3127">
                                                
                    </comment>
                    <comment line="3134">
                                                
                    </comment>
                    <comment line="3136">
                                                
                    </comment>
                    <comment line="3137">
                                                
                    </comment>
                    <comment line="3138">
                                                
                    </comment>
                    <scope line="3121"/>
                    <scope line="3125">
                        <scope line="3127"/>
                    </scope>
                    <scope line="3134">
                        <declaration name="o" type="OutputStream" line="3138"/>
                    </scope>
                </method>
            </class>
            <class name="ErrorStream" line="3147">
                <extends class="InputStream"/>
                <comment line="351">
                                        
                </comment>
                <comment line="354">
                                        
                </comment>
                <comment line="357">
                                        
                </comment>
                <comment line="2997">
                    skip() calls read() in order to ensure that entire response gets                    
                </comment>
                <comment line="3112">
                    this is called to check that all the bytes
                     that were supposed to be written were written
                     and that the stream is now closed().                    
                </comment>
                <comment line="3162">
                    when this method is called, it&apos;s either the case that cl &gt; 0, or
                     if chunk-encoded, cl = -1; in other words, cl can&apos;t be 0                    
                </comment>
                <declaration name="buffer" type="ByteBuffer" line="3148"/>
                <declaration name="is" type="InputStream" line="3149"/>
                <method name="ErrorStream" type="constructor" line="3151">
                    <params>
                        <param name="buf" type="ByteBuffer"/>
                    </params>
                </method>
                <method name="ErrorStream" type="constructor" line="3156">
                    <params>
                        <param name="buf" type="ByteBuffer"/>
                        <param name="is" type="InputStream"/>
                    </params>
                </method>
                <method name="getErrorStream" type="InputStream" line="3163">
                    <params>
                        <param name="is" type="InputStream"/>
                        <param name="cl" type="long"/>
                        <param name="http" type="HttpClient"/>
                    </params>
                    <comment line="3166">
                        cl can&apos;t be 0; this following is here for extra precaution                        
                    </comment>
                    <comment line="3172">
                        set SO_TIMEOUT to 1/5th of the total timeout
                         remember the old timeout value so that we can restore it                        
                    </comment>
                    <comment line="3179">
                        the chunked case                        
                    </comment>
                    <comment line="3196">
                        chunked ended
                         if chunked ended prematurely,
                         an IOException would be thrown                        
                    </comment>
                    <comment line="3201">
                        the server sends less than cl bytes of data                        
                    </comment>
                    <comment line="3212">
                        reset SO_TIMEOUT to old value                        
                    </comment>
                    <comment line="3215">
                        if count &lt; cl at this point, we will not try to reuse
                         the connection                        
                    </comment>
                    <comment line="3218">
                        since we haven&apos;t read anything,
                         we will return the underlying
                         inputstream back to the application                        
                    </comment>
                    <comment line="3223">
                        put the connection into keep-alive cache
                         the inputstream will try to do the right thing                        
                    </comment>
                    <comment line="3228">
                        we read part of the response body                        
                    </comment>
                    <comment line="3235">
                        ioex.printStackTrace();                        
                    </comment>
                    <scope line="3166"/>
                    <scope line="3170">
                        <declaration name="oldTimeout" type="int" line="3173"/>
                        <declaration name="expected" type="long" line="3176"/>
                        <declaration name="isChunked" type="boolean" line="3177"/>
                        <scope line="3179"/>
                        <scope line="3182"/>
                        <scope line="3185">
                            <declaration name="exp" type="int" line="3186"/>
                            <declaration name="buffer" type="byte[]" line="3187"/>
                            <declaration name="count" type="int" line="3188"/>
                            <scope line="3189">
                                <scope line="3190">
                                    <scope line="3193">
                                        <scope line="3194"/>
                                    </scope>
                                </scope>
                                <scope line="3206"/>
                            </scope>
                            <scope line="3216"/>
                            <scope line="3221"/>
                            <scope line="3226"/>
                        </scope>
                    </scope>
                    <scope line="3233"/>
                </method>
                <method name="available" type="int" line="3240">
                    <scope line="3241"/>
                    <scope line="3243"/>
                </method>
                <method name="read" type="int" line="3248">
                    <declaration name="b" type="byte[]" line="3249"/>
                    <declaration name="ret" type="int" line="3250"/>
                </method>
                <method name="read" type="int" line="3255">
                    <params>
                        <param name="b" type="byte[]"/>
                    </params>
                </method>
                <method name="read" type="int" line="3260">
                    <params>
                        <param name="b" type="byte[]"/>
                        <param name="off" type="int"/>
                        <param name="len" type="int"/>
                    </params>
                    <declaration name="rem" type="int" line="3261"/>
                    <scope line="3262">
                        <declaration name="ret" type="int" line="3263"/>
                    </scope>
                    <scope line="3266">
                        <scope line="3267"/>
                        <scope line="3269"/>
                    </scope>
                </method>
                <method name="close" type="void" line="3276">
                    <scope line="3278"/>
                </method>
            </class>
        </class>
        <class name="EmptyInputStream" line="3285">
            <extends class="InputStream"/>
            <comment line="88">
                                
            </comment>
            <comment line="92">
                Not all servers support the (Proxy)-Authentication-Info headers.
                 By default, we don&apos;t require them to be sent                
            </comment>
            <comment line="106">
                System properties related to error stream handling:
                
                 sun.net.http.errorstream.enableBuffering = &lt;boolean&gt;
                
                 With the above system property set to true (default is false),
                 when the response code is &gt;=400, the HTTP handler will try to
                 buffer the response body (up to a certain amount and within a
                 time limit). Thus freeing up the underlying socket connection
                 for reuse. The rationale behind this is that usually when the
                 server responds with a &gt;=400 error (client error or server
                 error, such as 404 file not found), the server will send a
                 small response body to explain who to contact and what to do to
                 recover. With this property set to true, even if the
                 application doesn&apos;t call getErrorStream(), read the response
                 body, and then call close(), the underlying socket connection
                 can still be kept-alive and reused. The following two system
                 properties provide further control to the error stream
                 buffering behaviour.
                
                 sun.net.http.errorstream.timeout = &lt;int&gt;
                     the timeout (in millisec) waiting the error stream
                     to be buffered; default is 300 ms
                
                 sun.net.http.errorstream.bufferSize = &lt;int&gt;
                     the size (in bytes) to use for the buffering the error stream;
                     default is 4k                
            </comment>
            <comment line="136">
                                
            </comment>
            <comment line="139">
                timeout waiting for read for buffered error stream;                
            </comment>
            <comment line="143">
                buffer size for buffered error stream;                
            </comment>
            <comment line="147">
                Restrict setting of request headers through the public api
                 consistent with JavaScript XMLHttpRequest2 with a few
                 exceptions. Disallowed headers are silently ignored for
                 backwards compatibility reasons rather than throwing a
                 SecurityException. For example, some applets set the
                 Host header since old JREs did not implement HTTP 1.1.
                 Additionally, any header starting with Sec- is
                 disallowed.
                
                 The following headers are allowed for historical reasons:
                
                 Accept-Charset, Accept-Encoding, Cookie, Cookie2, Date,
                 Referer, TE, User-Agent, headers beginning with Proxy-.
                
                 The following headers are allowed in a limited form:
                
                 Connection: close
                
                 See http:www.w3.orgTRXMLHttpRequest2.                
            </comment>
            <comment line="250">
                the following http request headers should NOT have their values
                 returned for security reasons.                
            </comment>
            <comment line="257">
                also exclude system cookies when any might be set                
            </comment>
            <comment line="272">
                the cached response, and cached response headers and body                
            </comment>
            <comment line="277">
                                
            </comment>
            <comment line="281">
                                
            </comment>
            <comment line="284">
                                
            </comment>
            <comment line="289">
                We only have a single static authenticator for now.
                 REMIND:  backwards compatibility with JDK 1.1.  Should be
                 eliminated for JDK 2.0.                
            </comment>
            <comment line="295">
                all the headers we send
                 NOTE: do NOT dump out the content of &apos;requests&apos; in the
                 output or stacktrace since it may contain security-sensitive
                 headers such as those defined in EXCLUDE_HEADERS.                
            </comment>
            <comment line="302">
                                
            </comment>
            <comment line="303">
                                
            </comment>
            <comment line="306">
                                
            </comment>
            <comment line="310">
                                
            </comment>
            <comment line="311">
                                
            </comment>
            <comment line="313">
                                
            </comment>
            <comment line="317">
                                
            </comment>
            <comment line="320">
                                
            </comment>
            <comment line="326">
                                
            </comment>
            <comment line="329">
                                
            </comment>
            <comment line="331">
                                
            </comment>
            <comment line="333">
                                
            </comment>
            <comment line="336">
                                
            </comment>
            <comment line="339">
                                
            </comment>
            <comment line="342">
                Remembered Exception, we will throw it again if somebody                
            </comment>
            <comment line="346">
                                
            </comment>
            <comment line="349">
                                
            </comment>
            <comment line="363">
                Redefine timeouts from java.net.URLConnection as we need -1 to mean
                 not set. This is to ensure backward compatibility.                
            </comment>
            <comment line="369">
                                
            </comment>
            <comment line="373">
                privileged request password authentication                
            </comment>
            <comment line="426">
                Checks the validity of http message header and whether the header
                 is restricted and throws IllegalArgumentException if invalid or
                 restricted.                
            </comment>
            <comment line="439">
                                
            </comment>
            <comment line="444">
                                
            </comment>
            <comment line="453">
                checks the validity of http message header and throws
                 IllegalArgumentException if invalid.                
            </comment>
            <comment line="486">
                adds the standard keyval pairs to reqests if necessary &amp; write to
                 given PrintStream                
            </comment>
            <comment line="809">
                Same as java.net.URL.hostsEqual                
            </comment>
            <comment line="844">
                overridden in HTTPS subclass                
            </comment>
            <comment line="990">
                subclass HttpsClient will overwrite &amp; return an instance of HttpsClient                
            </comment>
            <comment line="996">
                subclass HttpsClient will overwrite &amp; return an instance of HttpsClient                
            </comment>
            <comment line="1053">
                Allowable inputoutput sequences:
                 [interpreted as POSTPUT]
                 - get output, [write output,] get input, [read input]
                 - get output, [write output]
                 [interpreted as GET]
                 - get input, [read input]
                 Disallowed:
                 - get input, [read input,] get output, [write output]                
            </comment>
            <comment line="1148">
                get applicable cookies based on the uri and request headers
                 add them to the existing request headers                
            </comment>
            <comment line="1650">
                Creates a chained exception that has the same type as
                 original exception and with the same message. Right now,
                 there is no convenient APIs for doing so.                
            </comment>
            <comment line="2240">
                inclose will be true if called from close(), in which case we
                 force the call to check because this is the last chance to do so.
                 If not in close(), then the authentication info could arrive in a trailer
                 field, which we have not read yet.                
            </comment>
            <comment line="2279">
                The request URI used in the request line for this request.
                 Also, needed for digest authentication                
            </comment>
            <comment line="2292">
                Tells us whether to follow a redirect.  If so, it
                 closes the connection (break any keep-alive) and
                 resets the url, re-connects, and resets the request
                 property.                
            </comment>
            <comment line="2412">
                                
            </comment>
            <comment line="2701">
                Set a property for authentication.  This can safely disregard
                 the connected test.                
            </comment>
            <comment line="2862">
                The purpose of this wrapper is just to capture the close() call
                 so we can check authentication information that may have
                 arrived in a Trailer field                
            </comment>
            <javadoc line="3285">
                An input stream that just returns EOF.  This is for
                  HTTP URLConnections that are KeepAlive &amp;&amp; use the
                  HEAD method - i.e., stream not dead, but nothing to be read.                
            </javadoc>
            <method name="available" type="int" line="3293"/>
            <method name="read" type="int" line="3297"/>
        </class>
    </source>