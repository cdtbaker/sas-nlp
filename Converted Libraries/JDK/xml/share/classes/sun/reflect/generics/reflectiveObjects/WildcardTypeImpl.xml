<?xml version="1.0" encoding="UTF-8"?>
    <source package="sun.reflect.generics.reflectiveObjects">
        <import package="java.lang.reflect.Type"/>
        <import package="java.lang.reflect.WildcardType"/>
        <import package="sun.reflect.generics.factory.GenericsFactory"/>
        <import package="sun.reflect.generics.tree.FieldTypeSignature"/>
        <import package="sun.reflect.generics.visitor.Reifier"/>
        <import package="java.util.Arrays"/>
        <class name="WildcardTypeImpl" line="37">
            <extends class="LazyReflectiveObjectGenerator"/>
            <comment line="43">
                upper bounds - evaluated lazily                
            </comment>
            <comment line="45">
                lower bounds - evaluated lazily                
            </comment>
            <comment line="47">
                The ASTs for the bounds. We are required to evaluate the bounds
                 lazily, so we store these at least until we are first asked
                 for the bounds. This also neatly solves the
                 problem with F-bounds - you can&apos;t reify them before the formal
                 is defined.                
            </comment>
            <comment line="55">
                constructor is private to enforce access through static factory                
            </comment>
            <comment line="80">
                Accessors                
            </comment>
            <comment line="82">
                accessor for ASTs for upper bounds. Must not be called after upper
                 bounds have been evaluated, because we might throw the ASTs
                 away (but that is not thread-safe, is it?)                
            </comment>
            <comment line="90">
                accessor for ASTs for lower bounds. Must not be called after lower
                 bounds have been evaluated, because we might throw the ASTs
                 away (but that is not thread-safe, is it?)                
            </comment>
            <implements interface="WildcardType"/>
            <javadoc line="37">
                Implementation of WildcardType interface for core reflection.                
            </javadoc>
            <declaration name="upperBounds" type="Type[]" line="43"/>
            <declaration name="lowerBounds" type="Type[]" line="45"/>
            <declaration name="upperBoundASTs" type="FieldTypeSignature[]" line="51"/>
            <declaration name="lowerBoundASTs" type="FieldTypeSignature[]" line="52"/>
            <method name="WildcardTypeImpl" type="constructor" line="57">
                <params>
                    <param name="ubs" type="FieldTypeSignature[]"/>
                    <param name="lbs" type="FieldTypeSignature[]"/>
                    <param name="f" type="GenericsFactory"/>
                </params>
            </method>
            <javadoc line="63">
                Factory method.                
                <param>
                    ubs - an array of ASTs representing the upper bounds for the type
                      variable to be created                    
                </param>
                <param>
                    lbs - an array of ASTs representing the lower bounds for the type
                      variable to be created                    
                </param>
                <param>
                    f - a factory that can be used to manufacture reflective
                      objects that represent the bounds of this wildcard type                    
                </param>
                <return>
                    a wild card type with the requested bounds and factory                    
                </return>
            </javadoc>
            <method name="make" type="WildcardTypeImpl" line="75">
                <params>
                    <param name="ubs" type="FieldTypeSignature[]"/>
                    <param name="lbs" type="FieldTypeSignature[]"/>
                    <param name="f" type="GenericsFactory"/>
                </params>
            </method>
            <method name="getUpperBoundASTs" type="FieldTypeSignature[]" line="84">
                <comment line="86">
                    check that upper bounds were not evaluated yet                    
                </comment>
            </method>
            <method name="getLowerBoundASTs" type="FieldTypeSignature[]" line="92">
                <comment line="94">
                    check that lower bounds were not evaluated yet                    
                </comment>
            </method>
            <javadoc line="98">
                Returns an array of &lt;tt&gt;Type&lt;/tt&gt; objects representing the  upper
                  bound(s) of this type variable.  Note that if no upper bound is
                  explicitly declared, the upper bound is &lt;tt&gt;Object&lt;/tt&gt;.
                  &lt;p&gt;For each upper bound B :
                  &lt;ul&gt;
                  &lt;li&gt;if B is a parameterized type or a type variable, it is created,
                  (see {@link #ParameterizedType} for the details of the creation
                  process for parameterized types).
                  &lt;li&gt;Otherwise, B is resolved.
                  &lt;/ul&gt;                
                <return>
                    an array of Types representing the upper bound(s) of this
                      type variable                    
                </return>
                <throws>
                    <tt>TypeNotPresentException</tt> if any of the
                      bounds refers to a non-existent type declaration                    
                </throws>
                <throws>
                    <tt>MalformedParameterizedTypeException</tt> if any of the
                      bounds refer to a parameterized type that cannot be instantiated
                      for any reason                    
                </throws>
            </javadoc>
            <method name="getUpperBounds" type="Type[]" line="119">
                <comment line="121">
                    lazily initialize bounds if necessary                    
                </comment>
                <comment line="123">
                    get AST                    
                </comment>
                <comment line="125">
                    allocate result array; note that
                     keeping ts and bounds separate helps with threads                    
                </comment>
                <comment line="128">
                    iterate over bound trees, reifying each in turn                    
                </comment>
                <comment line="134">
                    cache result                    
                </comment>
                <comment line="136">
                    could throw away upper bound ASTs here; thread safety?                    
                </comment>
                <comment line="138">
                    return cached bounds                    
                </comment>
                <scope line="121">
                    <declaration name="fts" type="FieldTypeSignature[]" line="122"/>
                    <declaration name="ts" type="Type[]" line="126"/>
                    <scope line="128">
                        <declaration name="r" type="Reifier" line="129"/>
                    </scope>
                </scope>
            </method>
            <javadoc line="140">
                Returns an array of &lt;tt&gt;Type&lt;/tt&gt; objects representing the
                  lower bound(s) of this type variable.  Note that if no lower bound is
                  explicitly declared, the lower bound is the type of &lt;tt&gt;null&lt;/tt&gt;.
                  In this case, a zero length array is returned.
                  &lt;p&gt;For each lower bound B :
                  &lt;ul&gt;
                  &lt;li&gt;if B is a parameterized type or a type variable, it is created,
                  (see {@link #ParameterizedType} for the details of the creation
                  process for parameterized types).
                  &lt;li&gt;Otherwise, B is resolved.
                  &lt;/ul&gt;                
                <return>
                    an array of Types representing the lower bound(s) of this
                      type variable                    
                </return>
                <throws>
                    <tt>TypeNotPresentException</tt> if any of the
                      bounds refers to a non-existent type declaration                    
                </throws>
                <throws>
                    <tt>MalformedParameterizedTypeException</tt> if any of the
                      bounds refer to a parameterized type that cannot be instantiated
                      for any reason                    
                </throws>
            </javadoc>
            <method name="getLowerBounds" type="Type[]" line="162">
                <comment line="164">
                    lazily initialize bounds if necessary                    
                </comment>
                <comment line="166">
                    get AST                    
                </comment>
                <comment line="167">
                    allocate result array; note that
                     keeping ts and bounds separate helps with threads                    
                </comment>
                <comment line="170">
                    iterate over bound trees, reifying each in turn                    
                </comment>
                <comment line="176">
                    cache result                    
                </comment>
                <comment line="178">
                    could throw away lower bound ASTs here; thread safety?                    
                </comment>
                <comment line="180">
                    return cached bounds                    
                </comment>
                <scope line="164">
                    <declaration name="fts" type="FieldTypeSignature[]" line="165"/>
                    <declaration name="ts" type="Type[]" line="168"/>
                    <scope line="170">
                        <declaration name="r" type="Reifier" line="171"/>
                    </scope>
                </scope>
            </method>
            <method name="toString" type="String" line="182">
                <declaration name="lowerBounds" type="Type[]" line="183"/>
                <declaration name="bounds" type="Type[]" line="184"/>
                <declaration name="sb" type="StringBuilder" line="185"/>
                <scope line="189">
                    <declaration name="upperBounds" type="Type[]" line="190"/>
                    <scope line="191"/>
                </scope>
                <declaration name="first" type="boolean" line="200"/>
                <scope line="201"/>
            </method>
            <method name="equals" type="boolean" line="215">
                <params>
                    <param name="o" type="Object"/>
                </params>
                <scope line="216">
                    <declaration name="that" type="WildcardType" line="217"/>
                </scope>
            </method>
            <method name="hashCode" type="int" line="228">
                <declaration name="lowerBounds" type="Type[]" line="229"/>
                <declaration name="upperBounds" type="Type[]" line="230"/>
            </method>
        </class>
    </source>