<?xml version="1.0" encoding="UTF-8"?>
    <source package="sun.reflect.generics.visitor">
        <import package="java.lang.reflect.Type"/>
        <import package="java.util.List"/>
        <import package="java.util.Iterator"/>
        <import package="sun.reflect.generics.tree"/>
        <import package="sun.reflect.generics.factory"/>
        <class name="Reifier" line="37">
            <comment line="64">
                Helper method. Visits an array of TypeArgument and produces
                 reified Type array.                
            </comment>
            <implements interface="TypeTreeVisitor">
                <type_params>
                    <type_param name="Type"/>
                </type_params>
            </implements>
            <javadoc line="37">
                Visitor that converts AST to reified types.                
            </javadoc>
            <declaration name="resultType" type="Type" line="41"/>
            <declaration name="factory" type="GenericsFactory" line="42"/>
            <method name="Reifier" type="constructor" line="44">
                <params>
                    <param name="f" type="GenericsFactory"/>
                </params>
            </method>
            <method name="getFactory" type="GenericsFactory" line="48"/>
            <javadoc line="50">
                Factory method. The resulting visitor will convert an AST
                  representing generic signatures into corresponding reflective
                  objects, using the provided factory, &lt;tt&gt;f&lt;/tt&gt;.                
                <param>
                    f - a factory that can be used to manufacture reflective
                      objects returned by this visitor                    
                </param>
                <return>
                    A visitor that can be used to reify ASTs representing
                      generic type information into reflective objects                    
                </return>
            </javadoc>
            <method name="make" type="Reifier" line="59">
                <params>
                    <param name="f" type="GenericsFactory"/>
                </params>
            </method>
            <method name="reifyTypeArguments" type="Type[]" line="65">
                <params>
                    <param name="tas" type="TypeArgument[]"/>
                </params>
                <declaration name="ts" type="Type[]" line="66"/>
                <scope line="67"/>
            </method>
            <javadoc line="75">
                Accessor for the result of the last visit by this visitor,                
                <return>
                    The type computed by this visitor based on its last
                      visit                    
                </return>
            </javadoc>
            <method name="getResult" type="Type" line="80"/>
            <method name="visitFormalTypeParameter" type="void" line="82">
                <params>
                    <param name="ftp" type="FormalTypeParameter"/>
                </params>
            </method>
            <method name="visitClassTypeSignature" type="void" line="88">
                <params>
                    <param name="ct" type="ClassTypeSignature"/>
                </params>
                <comment line="90">
                    This method examines the pathname stored in ct, which has the form
                     n1.n2...nk&lt;targs&gt;....
                     where n1 ... nk-1 might not exist OR
                     nk might not exist (but not both). It may be that k equals 1.
                     The idea is that nk is the simple class type name that has
                     any type parameters associated with it.
                      We process this path in two phases.
                      First, we scan until we reach nk (if it exists).
                      If nk does not exist, this identifies a raw class n1 ... nk-1
                     which we can return.
                     if nk does exist, we begin the 2nd phase.
                     Here nk defines a parameterized type. Every further step nj (j &gt; k)
                     down the path must also be represented as a parameterized type,
                     whose owner is the representation of the previous step in the path,
                     n{j-1}.                    
                </comment>
                <comment line="106">
                    extract iterator on list of simple class type sigs                    
                </comment>
                <comment line="114">
                    phase 1: iterate over simple class types until
                     we are either done or we hit one with non-empty type parameters                    
                </comment>
                <comment line="122">
                    Now, either sc is the last element of the list, or
                     it has type arguments (or both)                    
                </comment>
                <comment line="125">
                    Create the raw type                    
                </comment>
                <comment line="127">
                    if there are no type arguments                    
                </comment>
                <comment line="129">
                    we have surely reached the end of the path                    
                </comment>
                <comment line="131">
                    the result is the raw type                    
                </comment>
                <comment line="134">
                    otherwise, we have type arguments, so we create a parameterized
                     type, whose declaration is the raw type c, and whose owner is
                     the declaring class of c (if any). This latter fact is indicated
                     by passing null as the owner.
                     First, we reify the type arguments                    
                </comment>
                <comment line="142">
                    phase 2: iterate over remaining simple class types                    
                </comment>
                <comment line="147">
                    build up raw class name                    
                </comment>
                <comment line="148">
                    obtain raw class                    
                </comment>
                <comment line="149">
                    reify params                    
                </comment>
                <comment line="150">
                    Create a parameterized type, based on type args, raw type
                     and previous owner                    
                </comment>
                <declaration name="scts" type="List&lt;SimpleClassTypeSignature&gt;" line="106"/>
                <declaration name="iter" type="Iterator&lt;SimpleClassTypeSignature&gt;" line="108"/>
                <declaration name="sc" type="SimpleClassTypeSignature" line="109"/>
                <declaration name="n" type="StringBuilder" line="110"/>
                <declaration name="dollar" type="boolean" line="111"/>
                <scope line="115"/>
                <declaration name="c" type="Type" line="125"/>
                <scope line="127"/>
                <scope line="131">
                    <declaration name="pts" type="Type[]" line="138"/>
                    <declaration name="owner" type="Type" line="140"/>
                    <scope line="143"/>
                </scope>
            </method>
            <method name="visitArrayTypeSignature" type="void" line="157">
                <params>
                    <param name="a" type="ArrayTypeSignature"/>
                </params>
                <comment line="159">
                    extract and reify component type                    
                </comment>
                <declaration name="ct" type="Type" line="160"/>
            </method>
            <method name="visitTypeVariableSignature" type="void" line="164">
                <params>
                    <param name="tv" type="TypeVariableSignature"/>
                </params>
            </method>
            <method name="visitWildcard" type="void" line="168">
                <params>
                    <param name="w" type="Wildcard"/>
                </params>
            </method>
            <method name="visitSimpleClassTypeSignature" type="void" line="173">
                <params>
                    <param name="sct" type="SimpleClassTypeSignature"/>
                </params>
            </method>
            <method name="visitBottomSignature" type="void" line="177">
                <params>
                    <param name="b" type="BottomSignature"/>
                </params>
            </method>
            <method name="visitByteSignature" type="void" line="181">
                <params>
                    <param name="b" type="ByteSignature"/>
                </params>
            </method>
            <method name="visitBooleanSignature" type="void" line="185">
                <params>
                    <param name="b" type="BooleanSignature"/>
                </params>
            </method>
            <method name="visitShortSignature" type="void" line="189">
                <params>
                    <param name="s" type="ShortSignature"/>
                </params>
            </method>
            <method name="visitCharSignature" type="void" line="193">
                <params>
                    <param name="c" type="CharSignature"/>
                </params>
            </method>
            <method name="visitIntSignature" type="void" line="197">
                <params>
                    <param name="i" type="IntSignature"/>
                </params>
            </method>
            <method name="visitLongSignature" type="void" line="201">
                <params>
                    <param name="l" type="LongSignature"/>
                </params>
            </method>
            <method name="visitFloatSignature" type="void" line="205">
                <params>
                    <param name="f" type="FloatSignature"/>
                </params>
            </method>
            <method name="visitDoubleSignature" type="void" line="209">
                <params>
                    <param name="d" type="DoubleSignature"/>
                </params>
            </method>
            <method name="visitVoidDescriptor" type="void" line="213">
                <params>
                    <param name="v" type="VoidDescriptor"/>
                </params>
            </method>
        </class>
    </source>