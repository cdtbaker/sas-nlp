<?xml version="1.0" encoding="UTF-8"?>
    <source package="sun.reflect.generics.parser">
        <import package="java.lang.reflect.GenericSignatureFormatError"/>
        <import package="java.util"/>
        <import package="sun.reflect.generics.tree"/>
        <class name="SignatureParser" line="34">
            <comment line="42">
                The input is conceptually a character stream (though currently it&apos;s
                 a string). This is slightly different than traditional parsers,
                 because there is no lexical scanner performing tokenization.
                 Having a separate tokenizer does not fit with the nature of the
                 input format.
                 Other than the absence of a tokenizer, this parser is a classic
                 recursive descent parser. Its structure corresponds as closely
                 as possible to the grammar in the JVMS.
                
                 A note on asserts vs. errors: The code contains assertions
                 in situations that should never occur. An assertion failure
                 indicates a failure of the parser logic. A common pattern
                 is an assertion that the current input is a particular
                 character. This is often paired with a separate check
                 that this is the case, which seems redundant. For example:
                
                 assert(current() != x);
                 if (current != x {error(&quot;expected an x&quot;);
                
                 where x is some character constant.
                 The assertion inidcates, that, as currently written,
                 the code should nver reach this point unless the input is an
                 x. On the other hand, the test is there to check the legality
                 of the input wrt to a given production. It may be that at a later
                 time the code might be called directly, and if the input is
                 invalid, the parser should flag an error in accordance
                 with its logic.                
            </comment>
            <comment line="70">
                the input signature                
            </comment>
            <comment line="71">
                index into the input                
            </comment>
            <comment line="72">
                used to mark end of input                
            </comment>
            <comment line="76">
                private constructor - enforces use of static factory                
            </comment>
            <comment line="79">
                Utility methods.                
            </comment>
            <comment line="81">
                Most parsing routines use the following routines to access the
                 input stream, and advance it as necessary.
                 This makes it easy to adapt the parser to operate on streams
                 of various kinds as well as strings.                
            </comment>
            <comment line="86">
                returns current element of the input and advances the input                
            </comment>
            <comment line="94">
                returns current element of the input                
            </comment>
            <comment line="102">
                advance the input                
            </comment>
            <comment line="108">
                Match c against a &quot;set&quot; of characters                
            </comment>
            <comment line="116">
                Error handling routine. Encapsulates error handling.
                 Takes a string error message as argument.
                 Currently throws a GenericSignatureFormatError.                
            </comment>
            <comment line="179">
                Parsing routines.
                 As a rule, the parsing routines access the input using the
                 utilities current(), getNext() and/or advance().
                 The convention is that when a parsing routine is invoked
                 it expects the current input to be the first character it should parse
                 and when it completes parsing, it leaves the input at the first
                 character after the input parses.                
            </comment>
            <comment line="187">
                parse a class signature based on the implicit input.                
            </comment>
            <comment line="342">
                TypeVariableSignature -&gt; T identifier                
            </comment>
            <comment line="358">
                ArrayTypeSignature -&gt; [ TypeSignature                
            </comment>
            <comment line="366">
                TypeSignature -&gt; BaseType | FieldTypeSignature                
            </comment>
            <comment line="450">
                parse a method signature based on the implicit input.                
            </comment>
            <comment line="461">
                (TypeSignature*)                
            </comment>
            <comment line="471">
                TypeSignature*                
            </comment>
            <comment line="503">
                ReturnType -&gt; V | TypeSignature                
            </comment>
            <comment line="512">
                ThrowSignature*                
            </comment>
            <comment line="523">
                ThrowSignature -&gt; ^ FieldTypeSignature                
            </comment>
            <javadoc line="34">
                Parser for type signatures, as defined in the Java Virtual
                  // Machine Specification (JVMS) chapter 4.
                  Converts the signatures into an abstract syntax tree (AST) representation.
                  // See the package sun.reflect.generics.tree for details of the AST.                
            </javadoc>
            <declaration name="input" type="char[]" line="69"/>
            <declaration name="index" type="int" line="70"/>
            <declaration name="EOI" type="char" line="72"/>
            <declaration name="DEBUG" type="boolean" line="73"/>
            <method name="SignatureParser" type="constructor" line="76"/>
            <method name="getNext" type="char" line="86">
                <scope line="88"/>
                <scope line="90"/>
            </method>
            <method name="current" type="char" line="94">
                <scope line="96"/>
                <scope line="98"/>
            </method>
            <method name="advance" type="void" line="102"/>
            <method name="matches" type="boolean" line="108">
                <params>
                    <param name="c" type="char"/>
                    <param name="set" type="char"/>
                </params>
                <scope line="109"/>
            </method>
            <method name="error" type="Error" line="119">
                <params>
                    <param name="errorMsg" type="String"/>
                </params>
            </method>
            <javadoc line="124">
                Static factory method. Produces a parser instance.                
                <return>
                    an instance of &lt;tt&gt;SignatureParser&lt;/tt&gt;                    
                </return>
            </javadoc>
            <method name="make" type="SignatureParser" line="128"/>
            <javadoc line="132">
                Parses a class signature (as defined in the JVMS, chapter 4)
                  and produces an abstract syntax tree representing it.                
                <param>
                    s a string representing the input class signature                    
                </param>
                <return>
                    An abstract syntax tree for a class signature
                      corresponding to the input string                    
                </return>
                <throws>
                    GenericSignatureFormatError if the input is not a valid
                      class signature                    
                </throws>
            </javadoc>
            <method name="parseClassSig" type="ClassSignature" line="141">
                <params>
                    <param name="s" type="String"/>
                </params>
            </method>
            <javadoc line="147">
                Parses a method signature (as defined in the JVMS, chapter 4)
                  and produces an abstract syntax tree representing it.                
                <param>
                    s a string representing the input method signature                    
                </param>
                <return>
                    An abstract syntax tree for a method signature
                      corresponding to the input string                    
                </return>
                <throws>
                    GenericSignatureFormatError if the input is not a valid
                      method signature                    
                </throws>
            </javadoc>
            <method name="parseMethodSig" type="MethodTypeSignature" line="156">
                <params>
                    <param name="s" type="String"/>
                </params>
            </method>
            <javadoc line="163">
                Parses a type signature
                  and produces an abstract syntax tree representing it.                
                <param>
                    s a string representing the input type signature                    
                </param>
                <return>
                    An abstract syntax tree for a type signature
                      corresponding to the input string                    
                </return>
                <throws>
                    GenericSignatureFormatError if the input is not a valid
                      type signature                    
                </throws>
            </javadoc>
            <method name="parseTypeSig" type="TypeSignature" line="172">
                <params>
                    <param name="s" type="String"/>
                </params>
            </method>
            <method name="parseClassSignature" type="ClassSignature" line="187"/>
            <method name="parseZeroOrMoreFormalTypeParameters" type="FormalTypeParameter[]" line="194">
                <scope line="195"/>
                <scope line="196"/>
            </method>
            <method name="parseFormalTypeParameters" type="FormalTypeParameter[]" line="200">
                <comment line="204">
                    should not have been called at all                    
                </comment>
                <declaration name="ftps" type="Collection&lt;FormalTypeParameter&gt;" line="201"/>
                <scope line="204"/>
                <scope line="207"/>
                <declaration name="ftpa" type="FormalTypeParameter[]" line="211"/>
            </method>
            <method name="parseFormalTypeParameter" type="FormalTypeParameter" line="215">
                <declaration name="id" type="String" line="216"/>
                <declaration name="bs" type="FieldTypeSignature[]" line="217"/>
            </method>
            <method name="parseIdentifier" type="String" line="221">
                <declaration name="result" type="StringBuilder" line="222"/>
                <scope line="223">
                    <declaration name="c" type="char" line="224"/>
                    <scope line="233"/>
                </scope>
            </method>
            <method name="parseFieldTypeSignature" type="FieldTypeSignature" line="243"/>
            <method name="parseClassTypeSignature" type="ClassTypeSignature" line="255">
                <scope line="257"/>
                <declaration name="scts" type="List&lt;SimpleClassTypeSignature&gt;" line="259"/>
            </method>
            <method name="parseSimpleClassTypeSignature" type="SimpleClassTypeSignature" line="270">
                <params>
                    <param name="dollar" type="boolean"/>
                </params>
                <declaration name="id" type="String" line="271"/>
                <declaration name="c" type="char" line="272"/>
                <scope line="277"/>
                <scope line="280"/>
            </method>
            <method name="parseClassTypeSignatureSuffix" type="void" line="284">
                <params>
                    <param name="scts" type="List<SimpleClassTypeSignature>"/>
                </params>
                <scope line="285">
                    <declaration name="dollar" type="boolean" line="286"/>
                </scope>
            </method>
            <method name="parseTypeArgumentsOpt" type="TypeArgument[]" line="292">
                <scope line="293"/>
                <scope line="294"/>
            </method>
            <method name="parseTypeArguments" type="TypeArgument[]" line="297">
                <comment line="305">
                    (matches(current(),  &apos;+&apos;, &apos;-&apos;, &apos;L&apos;, &apos;[&apos;, &apos;T&apos;, &apos;*&apos;)) {                    
                </comment>
                <declaration name="tas" type="Collection&lt;TypeArgument&gt;" line="298"/>
                <scope line="300"/>
                <scope line="303"/>
                <declaration name="taa" type="TypeArgument[]" line="308"/>
            </method>
            <method name="parseTypeArgument" type="TypeArgument" line="312">
                <comment line="323">
                    bottom                    
                </comment>
                <comment line="329">
                    bottom                    
                </comment>
                <declaration name="ub" type="FieldTypeSignature[]" line="313"/>
                <declaration name="ta" type="TypeArgument[]" line="316"/>
                <declaration name="c" type="char" line="317"/>
                <scope line="319"/>
                <scope line="325"/>
                <scope line="331"/>
            </method>
            <method name="parseTypeVariableSignature" type="TypeVariableSignature" line="343">
                <scope line="345"/>
                <declaration name="ts" type="TypeVariableSignature" line="347"/>
                <scope line="349"/>
            </method>
            <method name="parseArrayTypeSignature" type="ArrayTypeSignature" line="359">
                <scope line="360"/>
            </method>
            <method name="parseTypeSignature" type="TypeSignature" line="367"/>
            <method name="parseBaseType" type="BaseType" line="381">
                <scope line="407"/>
            </method>
            <method name="parseZeroOrMoreBounds" type="FieldTypeSignature[]" line="414">
                <comment line="422">
                    empty class bound                    
                </comment>
                <comment line="425">
                    parse class bound                    
                </comment>
                <comment line="429">
                    zero or more interface bounds                    
                </comment>
                <declaration name="fts" type="Collection&lt;FieldTypeSignature&gt;" line="415"/>
                <scope line="418">
                    <scope line="429"/>
                </scope>
                <declaration name="fta" type="FieldTypeSignature[]" line="435"/>
            </method>
            <method name="parseSuperInterfaces" type="ClassTypeSignature[]" line="439">
                <declaration name="cts" type="Collection&lt;ClassTypeSignature&gt;" line="440"/>
                <scope line="442"/>
                <declaration name="cta" type="ClassTypeSignature[]" line="445"/>
            </method>
            <method name="parseMethodTypeSignature" type="MethodTypeSignature" line="450">
                <declaration name="ets" type="FieldTypeSignature[]" line="451"/>
            </method>
            <method name="parseFormalParameters" type="TypeSignature[]" line="461">
                <scope line="462"/>
                <declaration name="pts" type="TypeSignature[]" line="464"/>
                <scope line="465"/>
            </method>
            <method name="parseZeroOrMoreTypeSignatures" type="TypeSignature[]" line="471">
                <comment line="494">
                    while( matches(current(),
                    &apos;B&apos;, &apos;C&apos;, &apos;D&apos;, &apos;F&apos;, &apos;I&apos;, &apos;J&apos;, &apos;S&apos;, &apos;Z&apos;, &apos;L&apos;, &apos;T&apos;, &apos;[&apos;)
                    ) {
                    ts.add(parseTypeSignature());                    
                </comment>
                <declaration name="ts" type="Collection&lt;TypeSignature&gt;" line="472"/>
                <declaration name="stop" type="boolean" line="473"/>
                <scope line="474">
                    <scope line="486"/>
                </scope>
                <declaration name="ta" type="TypeSignature[]" line="498"/>
            </method>
            <method name="parseReturnType" type="ReturnType" line="504">
                <scope line="505"/>
            </method>
            <method name="parseZeroOrMoreThrowsSignatures" type="FieldTypeSignature[]" line="512">
                <declaration name="ets" type="Collection&lt;FieldTypeSignature&gt;" line="513"/>
                <scope line="515"/>
                <declaration name="eta" type="FieldTypeSignature[]" line="518"/>
            </method>
            <method name="parseThrowsSignature" type="FieldTypeSignature" line="524">
                <scope line="526"/>
            </method>
        </class>
    </source>