<?xml version="1.0" encoding="UTF-8"?>
    <source package="sun.reflect">
        <import package="java.lang.reflect.Field"/>
        <import package="java.lang.reflect.Method"/>
        <import package="java.lang.reflect.Constructor"/>
        <import package="java.lang.reflect.Modifier"/>
        <import package="java.security.AccessController"/>
        <import package="java.security.Permission"/>
        <import package="java.security.PrivilegedAction"/>
        <class name="ReflectionFactory" line="36">
            <comment line="55">
                Provides access to package-private mechanisms in java.lang.reflect                
            </comment>
            <comment line="58">
                &quot;Inflation&quot; mechanism. Loading bytecodes to implement
                 Method.invoke() and Constructor.newInstance() currently costs
                 3-4x more than an invocation via native code for the first
                 invocation (though subsequent invocations have been benchmarked
                 to be over 20x faster). Unfortunately this cost increases
                 startup time for certain applications that use reflection
                 intensively (but only once per class) to bootstrap themselves.
                 To avoid this penalty we reuse the existing JVM entry points
                 for the first few invocations of Methods and Constructors and
                 then switch to the bytecode-based implementations.
                
                 Package-private to be accessible to NativeMethodAccessorImpl
                 and NativeConstructorAccessorImpl                
            </comment>
            <comment line="121">
                --------------------------------------------------------------------------
                
                 Routines used by java.lang.reflect                
            </comment>
            <comment line="200">
                --------------------------------------------------------------------------
                
                 Routines used by java.lang                
            </comment>
            <comment line="318">
                --------------------------------------------------------------------------
                
                 Routines used by serialization                
            </comment>
            <comment line="354">
                --------------------------------------------------------------------------
                
                 Internals only below this point                
            </comment>
            <javadoc line="36">
                &lt;P&gt; The master factory for all reflective objects, both those in
                  java.lang.reflect (Fields, Methods, Constructors) as well as their
                  delegates (FieldAccessors, MethodAccessors, ConstructorAccessors).
                  &lt;/P&gt;
                  &lt;P&gt; The methods in this class are extremely unsafe and can cause
                  subversion of both the language and the verifier. For this reason,
                  they are all instance methods, and access to the constructor of
                  this factory is guarded by a security check, in similar style to{@link sun.misc.Unsafe}. &lt;/P&gt;                
            </javadoc>
            <declaration name="initted" type="boolean" line="50"/>
            <declaration name="reflectionFactoryAccessPerm" type="Permission" line="51"/>
            <declaration name="soleInstance" type="ReflectionFactory" line="53"/>
            <declaration name="langReflectAccess" type="LangReflectAccess" line="55"/>
            <declaration name="noInflation" type="boolean" line="71"/>
            <declaration name="inflationThreshold" type="int" line="72"/>
            <method name="ReflectionFactory" type="constructor" line="74"/>
            <class name="GetReflectionFactoryAction" line="77">
                <implements interface="PrivilegedAction">
                    <type_params>
                        <type_param name="ReflectionFactory"/>
                    </type_params>
                </implements>
                <javadoc line="77">
                    A convenience class for acquiring the capability to instantiate
                      reflective objects.  Use this instead of a raw call to {@link #getReflectionFactory} in order to avoid being limited by the
                      permissions of your callers.
                      &lt;p&gt;An instance of this class can be used as the argument of
                      &lt;code&gt;AccessController.doPrivileged&lt;/code&gt;.                    
                </javadoc>
                <method name="run" type="ReflectionFactory" line="88"/>
            </class>
            <javadoc line="93">
                Provides the caller with the capability to instantiate reflective
                  objects.
                  &lt;p&gt; First, if there is a security manager, its
                  &lt;code&gt;checkPermission&lt;/code&gt; method is called with a {@link java.lang.RuntimePermission} with target
                  &lt;code&gt;&quot;reflectionFactoryAccess&quot;&lt;/code&gt;.  This may result in a
                  security exception.
                  &lt;p&gt; The returned &lt;code&gt;ReflectionFactory&lt;/code&gt; object should be
                  carefully guarded by the caller, since it can be used to read and
                  write private data and invoke private methods, as well as to load
                  unverified bytecodes.  It must never be passed to untrusted code.                
                <exception>
                    SecurityException if a security manager exists and its
                      <code>checkPermission</code> method doesn't allow
                      access to the RuntimePermission "reflectionFactoryAccess".                    
                </exception>
            </javadoc>
            <method name="getReflectionFactory" type="ReflectionFactory" line="111">
                <comment line="115">
                    TO DO: security.checkReflectionFactoryAccess();                    
                </comment>
                <declaration name="security" type="SecurityManager" line="112"/>
                <scope line="113"/>
            </method>
            <javadoc line="126">
                Called only by java.lang.reflect.Modifier&apos;s static initializer                
            </javadoc>
            <method name="setLangReflectAccess" type="void" line="127">
                <params>
                    <param name="access" type="LangReflectAccess"/>
                </params>
            </method>
            <javadoc line="131">
                Note: this routine can cause the declaring class for the field
                  be initialized and therefore must not be called until the
                  first get/set of this field.                
                <param>
                    field the field                    
                </param>
                <param>
                    override true if caller has overridden aaccessibility                    
                </param>
            </javadoc>
            <method name="newFieldAccessor" type="FieldAccessor" line="138">
                <params>
                    <param name="field" type="Field"/>
                    <param name="override" type="boolean"/>
                </params>
            </method>
            <method name="newMethodAccessor" type="MethodAccessor" line="143">
                <params>
                    <param name="method" type="Method"/>
                </params>
                <scope line="146"/>
                <scope line="154">
                    <declaration name="acc" type="NativeMethodAccessorImpl" line="155"/>
                    <declaration name="res" type="DelegatingMethodAccessorImpl" line="157"/>
                </scope>
            </method>
            <method name="newConstructorAccessor" type="ConstructorAccessor" line="164">
                <params>
                    <param name="c" type="Constructor"/>
                </params>
                <comment line="176">
                    Bootstrapping issue: since we use Class.newInstance() in
                     the ConstructorAccessor generation process, we have to
                     break the cycle here.                    
                </comment>
                <declaration name="declaringClass" type="Class&lt;?&gt;" line="167"/>
                <scope line="168"/>
                <scope line="171"/>
                <scope line="179"/>
                <scope line="183"/>
                <scope line="189">
                    <declaration name="acc" type="NativeConstructorAccessorImpl" line="190"/>
                    <declaration name="res" type="DelegatingConstructorAccessorImpl" line="192"/>
                </scope>
            </method>
            <javadoc line="205">
                Creates a new java.lang.reflect.Field. Access checks as per
                  java.lang.reflect.AccessibleObject are not overridden.                
            </javadoc>
            <method name="newField" type="Field" line="214">
                <params>
                    <param name="declaringClass" type="Class<?>"/>
                    <param name="name" type="String"/>
                    <param name="type" type="Class<?>"/>
                    <param name="modifiers" type="int"/>
                    <param name="slot" type="int"/>
                    <param name="signature" type="String"/>
                    <param name="annotations" type="byte[]"/>
                </params>
            </method>
            <javadoc line="224">
                Creates a new java.lang.reflect.Method. Access checks as per
                  java.lang.reflect.AccessibleObject are not overridden.                
            </javadoc>
            <method name="newMethod" type="Method" line="237">
                <params>
                    <param name="declaringClass" type="Class<?>"/>
                    <param name="name" type="String"/>
                    <param name="parameterTypes" type="Class<?>[]"/>
                    <param name="returnType" type="Class<?>"/>
                    <param name="checkedExceptions" type="Class<?>[]"/>
                    <param name="modifiers" type="int"/>
                    <param name="slot" type="int"/>
                    <param name="signature" type="String"/>
                    <param name="annotations" type="byte[]"/>
                    <param name="parameterAnnotations" type="byte[]"/>
                    <param name="annotationDefault" type="byte[]"/>
                </params>
            </method>
            <javadoc line="251">
                Creates a new java.lang.reflect.Constructor. Access checks as
                  per java.lang.reflect.AccessibleObject are not overridden.                
            </javadoc>
            <method name="newConstructor" type="Constructor" line="261">
                <params>
                    <param name="declaringClass" type="Class<?>"/>
                    <param name="parameterTypes" type="Class<?>[]"/>
                    <param name="checkedExceptions" type="Class<?>[]"/>
                    <param name="modifiers" type="int"/>
                    <param name="slot" type="int"/>
                    <param name="signature" type="String"/>
                    <param name="annotations" type="byte[]"/>
                    <param name="parameterAnnotations" type="byte[]"/>
                </params>
            </method>
            <javadoc line="272">
                Gets the MethodAccessor object for a java.lang.reflect.Method                
            </javadoc>
            <method name="getMethodAccessor" type="MethodAccessor" line="273">
                <params>
                    <param name="m" type="Method"/>
                </params>
            </method>
            <javadoc line="277">
                Sets the MethodAccessor object for a java.lang.reflect.Method                
            </javadoc>
            <method name="setMethodAccessor" type="void" line="278">
                <params>
                    <param name="m" type="Method"/>
                    <param name="accessor" type="MethodAccessor"/>
                </params>
            </method>
            <javadoc line="282">
                Gets the ConstructorAccessor object for a
                  java.lang.reflect.Constructor                
            </javadoc>
            <method name="getConstructorAccessor" type="ConstructorAccessor" line="284">
                <params>
                    <param name="c" type="Constructor"/>
                </params>
            </method>
            <javadoc line="288">
                Sets the ConstructorAccessor object for a
                  java.lang.reflect.Constructor                
            </javadoc>
            <method name="setConstructorAccessor" type="void" line="292">
                <params>
                    <param name="c" type="Constructor"/>
                    <param name="accessor" type="ConstructorAccessor"/>
                </params>
            </method>
            <javadoc line="296">
                Makes a copy of the passed method. The returned method is a
                  &quot;child&quot; of the passed one; see the comments in Method.java for
                  details.                
            </javadoc>
            <method name="copyMethod" type="Method" line="299">
                <params>
                    <param name="arg" type="Method"/>
                </params>
            </method>
            <javadoc line="303">
                Makes a copy of the passed field. The returned field is a
                  &quot;child&quot; of the passed one; see the comments in Field.java for
                  details.                
            </javadoc>
            <method name="copyField" type="Field" line="306">
                <params>
                    <param name="arg" type="Field"/>
                </params>
            </method>
            <javadoc line="310">
                Makes a copy of the passed constructor. The returned
                  constructor is a &quot;child&quot; of the passed one; see the comments
                  in Constructor.java for details.                
            </javadoc>
            <method name="copyConstructor" type="Constructor<T>" line="313">
                <params>
                    <param name="arg" type="Constructor<T>"/>
                </params>
            </method>
            <method name="newConstructorForSerialization" type="Constructor" line="325">
                <params>
                    <param name="classToInstantiate" type="Class<?>"/>
                    <param name="constructorToCall" type="Constructor"/>
                </params>
                <comment line="327">
                    Fast path                    
                </comment>
                <scope line="327"/>
                <declaration name="acc" type="ConstructorAccessor" line="331"/>
                <declaration name="c" type="Constructor" line="337"/>
            </method>
            <method name="inflationThreshold" type="int" line="358"/>
            <javadoc line="362">
                We have to defer full initialization of this class until after
                  the static initializer is run since java.lang.reflect.Method&apos;s
                  static initializer (more properly, that for
                  java.lang.reflect.AccessibleObject) causes this class&apos;s to be
                  run, before the system properties are set up.                
            </javadoc>
            <method name="checkInitted" type="void" line="367">
                <comment line="373">
                    Tests to ensure the system properties table is fully
                     initialized. This is needed because reflection code is
                     called very early in the initialization process (before
                     command-line arguments have been parsed and therefore
                     these user-settable properties installed.) We assume that
                     if System.out is non-null then the System class has been
                     fully initialized and that the bulk of the startup code
                     has been run.                    
                </comment>
                <comment line="383">
                    java.lang.System not yet fully initialized                    
                </comment>
                <anonymous_class line="370">
                    <method name="run" type="Void" line="371">
                        <comment line="373">
                            Tests to ensure the system properties table is fully
                             initialized. This is needed because reflection code is
                             called very early in the initialization process (before
                             command-line arguments have been parsed and therefore
                             these user-settable properties installed.) We assume that
                             if System.out is non-null then the System class has been
                             fully initialized and that the bulk of the startup code
                             has been run.                            
                        </comment>
                        <comment line="383">
                            java.lang.System not yet fully initialized                            
                        </comment>
                        <scope line="381"/>
                        <declaration name="val" type="String" line="386"/>
                        <scope line="387"/>
                        <scope line="392">
                            <scope line="393"/>
                            <scope line="395"/>
                        </scope>
                    </method>
                </anonymous_class>
            </method>
            <method name="langReflectAccess" type="LangReflectAccess" line="408">
                <comment line="411">
                    Call a static method to get class java.lang.reflect.Modifier
                     initialized. Its static initializer will cause
                     setLangReflectAccess() to be called from the context of the
                     java.lang.reflect package.                    
                </comment>
                <scope line="409"/>
            </method>
        </class>
    </source>