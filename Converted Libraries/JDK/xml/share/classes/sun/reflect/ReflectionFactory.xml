<?xml version="1.0" encoding="UTF-8"?>
    <source package="sun.reflect">
        <import package="java.lang.reflect.Field"/>
        <import package="java.lang.reflect.Method"/>
        <import package="java.lang.reflect.Constructor"/>
        <import package="java.lang.reflect.Modifier"/>
        <import package="java.security.AccessController"/>
        <import package="java.security.Permission"/>
        <import package="java.security.PrivilegedAction"/>
        <class name="ReflectionFactory" line="36">
            <comment line="55">
                Provides access to package-private mechanisms in java.lang.reflect                
            </comment>
            <comment line="58">
                                
            </comment>
            <comment line="59">
                &quot;Inflation&quot; mechanism. Loading bytecodes to implement                
            </comment>
            <comment line="60">
                Method.invoke() and Constructor.newInstance() currently costs                
            </comment>
            <comment line="61">
                3-4x more than an invocation via native code for the first                
            </comment>
            <comment line="62">
                invocation (though subsequent invocations have been benchmarked                
            </comment>
            <comment line="63">
                to be over 20x faster). Unfortunately this cost increases                
            </comment>
            <comment line="64">
                startup time for certain applications that use reflection                
            </comment>
            <comment line="65">
                intensively (but only once per class) to bootstrap themselves.                
            </comment>
            <comment line="66">
                To avoid this penalty we reuse the existing JVM entry points                
            </comment>
            <comment line="67">
                for the first few invocations of Methods and Constructors and                
            </comment>
            <comment line="68">
                then switch to the bytecode-based implementations.                
            </comment>
            <comment line="69">
                                
            </comment>
            <comment line="70">
                Package-private to be accessible to NativeMethodAccessorImpl                
            </comment>
            <comment line="71">
                and NativeConstructorAccessorImpl                
            </comment>
            <comment line="121">
                --------------------------------------------------------------------------                
            </comment>
            <comment line="122">
                                
            </comment>
            <comment line="123">
                Routines used by java.lang.reflect                
            </comment>
            <comment line="124">
                                
            </comment>
            <comment line="125">
                                
            </comment>
            <comment line="200">
                --------------------------------------------------------------------------                
            </comment>
            <comment line="201">
                                
            </comment>
            <comment line="202">
                Routines used by java.lang                
            </comment>
            <comment line="203">
                                
            </comment>
            <comment line="204">
                                
            </comment>
            <comment line="318">
                --------------------------------------------------------------------------                
            </comment>
            <comment line="319">
                                
            </comment>
            <comment line="320">
                Routines used by serialization                
            </comment>
            <comment line="321">
                                
            </comment>
            <comment line="322">
                                
            </comment>
            <comment line="354">
                --------------------------------------------------------------------------                
            </comment>
            <comment line="355">
                                
            </comment>
            <comment line="356">
                Internals only below this point                
            </comment>
            <comment line="357">
                                
            </comment>
            <javadoc line="36">
                &lt;P&gt; The master factory for all reflective objects, both those in
                  java.lang.reflect (Fields, Methods, Constructors) as well as their
                  delegates (FieldAccessors, MethodAccessors, ConstructorAccessors).
                  &lt;/P&gt;
                  &lt;P&gt; The methods in this class are extremely unsafe and can cause
                  subversion of both the language and the verifier. For this reason,
                  they are all instance methods, and access to the constructor of
                  this factory is guarded by a security check, in similar style to{@link sun.misc.Unsafe}. &lt;/P&gt;                
            </javadoc>
            <declaration name="initted" type="boolean" line="50"/>
            <declaration name="reflectionFactoryAccessPerm" type="Permission" line="51"/>
            <declaration name="soleInstance" type="ReflectionFactory" line="53"/>
            <declaration name="langReflectAccess" type="LangReflectAccess" line="55"/>
            <declaration name="noInflation" type="boolean" line="71"/>
            <declaration name="inflationThreshold" type="int" line="72"/>
            <method name="ReflectionFactory" type="constructor" line="74"/>
            <class name="GetReflectionFactoryAction" line="77">
                <implements interface="PrivilegedAction">
                    <type_params>
                        <type_param name="ReflectionFactory"/>
                    </type_params>
                </implements>
                <javadoc line="77">
                    A convenience class for acquiring the capability to instantiate
                      reflective objects.  Use this instead of a raw call to {@link #getReflectionFactory} in order to avoid being limited by the
                      permissions of your callers.
                      &lt;p&gt;An instance of this class can be used as the argument of
                      &lt;code&gt;AccessController.doPrivileged&lt;/code&gt;.                    
                </javadoc>
                <method name="run" type="ReflectionFactory" line="88"/>
            </class>
            <javadoc line="93">
                Provides the caller with the capability to instantiate reflective
                  objects.
                  &lt;p&gt; First, if there is a security manager, its
                  &lt;code&gt;checkPermission&lt;/code&gt; method is called with a {@link java.lang.RuntimePermission} with target
                  &lt;code&gt;&quot;reflectionFactoryAccess&quot;&lt;/code&gt;.  This may result in a
                  security exception.
                  &lt;p&gt; The returned &lt;code&gt;ReflectionFactory&lt;/code&gt; object should be
                  carefully guarded by the caller, since it can be used to read and
                  write private data and invoke private methods, as well as to load
                  unverified bytecodes.  It must never be passed to untrusted code.                
                <exception>
                    SecurityException if a security manager exists and its
                      <code>checkPermission</code> method doesn't allow
                      access to the RuntimePermission "reflectionFactoryAccess".                    
                </exception>
            </javadoc>
            <method name="getReflectionFactory" type="ReflectionFactory" line="111">
                <comment line="114">
                    TO DO: security.checkReflectionFactoryAccess();                    
                </comment>
                <declaration name="security" type="SecurityManager" line="112"/>
                <scope line="113"/>
            </method>
            <javadoc line="126">
                Called only by java.lang.reflect.Modifier&apos;s static initializer                
            </javadoc>
            <method name="setLangReflectAccess" type="void" line="127">
                <params>
                    <param name="access" type="LangReflectAccess"/>
                </params>
            </method>
            <javadoc line="131">
                Note: this routine can cause the declaring class for the field
                  be initialized and therefore must not be called until the
                  first get/set of this field.                
                <param>
                    field the field                    
                </param>
                <param>
                    override true if caller has overridden aaccessibility                    
                </param>
            </javadoc>
            <method name="newFieldAccessor" type="FieldAccessor" line="138">
                <params>
                    <param name="field" type="Field"/>
                    <param name="override" type="boolean"/>
                </params>
            </method>
            <method name="newMethodAccessor" type="MethodAccessor" line="143">
                <params>
                    <param name="method" type="Method"/>
                </params>
                <scope line="146"/>
                <scope line="154">
                    <declaration name="acc" type="NativeMethodAccessorImpl" line="155"/>
                    <declaration name="res" type="DelegatingMethodAccessorImpl" line="157"/>
                </scope>
            </method>
            <method name="newConstructorAccessor" type="ConstructorAccessor" line="164">
                <params>
                    <param name="c" type="Constructor"/>
                </params>
                <comment line="175">
                    Bootstrapping issue: since we use Class.newInstance() in                    
                </comment>
                <comment line="176">
                    the ConstructorAccessor generation process, we have to                    
                </comment>
                <comment line="177">
                    break the cycle here.                    
                </comment>
                <declaration name="declaringClass" type="Class&lt;?&gt;" line="167"/>
                <scope line="168"/>
                <scope line="171"/>
                <scope line="179"/>
                <scope line="183"/>
                <scope line="189">
                    <declaration name="acc" type="NativeConstructorAccessorImpl" line="190"/>
                    <declaration name="res" type="DelegatingConstructorAccessorImpl" line="192"/>
                </scope>
            </method>
            <javadoc line="205">
                Creates a new java.lang.reflect.Field. Access checks as per
                  java.lang.reflect.AccessibleObject are not overridden.                
            </javadoc>
            <method name="newField" type="Field" line="214">
                <params>
                    <param name="declaringClass" type="Class<?>"/>
                    <param name="name" type="String"/>
                    <param name="type" type="Class<?>"/>
                    <param name="modifiers" type="int"/>
                    <param name="slot" type="int"/>
                    <param name="signature" type="String"/>
                    <param name="annotations" type="byte[]"/>
                </params>
            </method>
            <javadoc line="224">
                Creates a new java.lang.reflect.Method. Access checks as per
                  java.lang.reflect.AccessibleObject are not overridden.                
            </javadoc>
            <method name="newMethod" type="Method" line="237">
                <params>
                    <param name="declaringClass" type="Class<?>"/>
                    <param name="name" type="String"/>
                    <param name="parameterTypes" type="Class<?>[]"/>
                    <param name="returnType" type="Class<?>"/>
                    <param name="checkedExceptions" type="Class<?>[]"/>
                    <param name="modifiers" type="int"/>
                    <param name="slot" type="int"/>
                    <param name="signature" type="String"/>
                    <param name="annotations" type="byte[]"/>
                    <param name="parameterAnnotations" type="byte[]"/>
                    <param name="annotationDefault" type="byte[]"/>
                </params>
            </method>
            <javadoc line="251">
                Creates a new java.lang.reflect.Constructor. Access checks as
                  per java.lang.reflect.AccessibleObject are not overridden.                
            </javadoc>
            <method name="newConstructor" type="Constructor" line="261">
                <params>
                    <param name="declaringClass" type="Class<?>"/>
                    <param name="parameterTypes" type="Class<?>[]"/>
                    <param name="checkedExceptions" type="Class<?>[]"/>
                    <param name="modifiers" type="int"/>
                    <param name="slot" type="int"/>
                    <param name="signature" type="String"/>
                    <param name="annotations" type="byte[]"/>
                    <param name="parameterAnnotations" type="byte[]"/>
                </params>
            </method>
            <javadoc line="272">
                Gets the MethodAccessor object for a java.lang.reflect.Method                
            </javadoc>
            <method name="getMethodAccessor" type="MethodAccessor" line="273">
                <params>
                    <param name="m" type="Method"/>
                </params>
            </method>
            <javadoc line="277">
                Sets the MethodAccessor object for a java.lang.reflect.Method                
            </javadoc>
            <method name="setMethodAccessor" type="void" line="278">
                <params>
                    <param name="m" type="Method"/>
                    <param name="accessor" type="MethodAccessor"/>
                </params>
            </method>
            <javadoc line="282">
                Gets the ConstructorAccessor object for a
                  java.lang.reflect.Constructor                
            </javadoc>
            <method name="getConstructorAccessor" type="ConstructorAccessor" line="284">
                <params>
                    <param name="c" type="Constructor"/>
                </params>
            </method>
            <javadoc line="288">
                Sets the ConstructorAccessor object for a
                  java.lang.reflect.Constructor                
            </javadoc>
            <method name="setConstructorAccessor" type="void" line="292">
                <params>
                    <param name="c" type="Constructor"/>
                    <param name="accessor" type="ConstructorAccessor"/>
                </params>
            </method>
            <javadoc line="296">
                Makes a copy of the passed method. The returned method is a
                  &quot;child&quot; of the passed one; see the comments in Method.java for
                  details.                
            </javadoc>
            <method name="copyMethod" type="Method" line="299">
                <params>
                    <param name="arg" type="Method"/>
                </params>
            </method>
            <javadoc line="303">
                Makes a copy of the passed field. The returned field is a
                  &quot;child&quot; of the passed one; see the comments in Field.java for
                  details.                
            </javadoc>
            <method name="copyField" type="Field" line="306">
                <params>
                    <param name="arg" type="Field"/>
                </params>
            </method>
            <javadoc line="310">
                Makes a copy of the passed constructor. The returned
                  constructor is a &quot;child&quot; of the passed one; see the comments
                  in Constructor.java for details.                
            </javadoc>
            <method name="copyConstructor" type="Constructor<T>" line="313">
                <params>
                    <param name="arg" type="Constructor<T>"/>
                </params>
            </method>
            <method name="newConstructorForSerialization" type="Constructor" line="325">
                <params>
                    <param name="classToInstantiate" type="Class<?>"/>
                    <param name="constructorToCall" type="Constructor"/>
                </params>
                <comment line="326">
                    Fast path                    
                </comment>
                <scope line="327"/>
                <declaration name="acc" type="ConstructorAccessor" line="331"/>
                <declaration name="c" type="Constructor" line="337"/>
            </method>
            <method name="inflationThreshold" type="int" line="358"/>
            <javadoc line="362">
                We have to defer full initialization of this class until after
                  the static initializer is run since java.lang.reflect.Method&apos;s
                  static initializer (more properly, that for
                  java.lang.reflect.AccessibleObject) causes this class&apos;s to be
                  run, before the system properties are set up.                
            </javadoc>
            <method name="checkInitted" type="void" line="367">
                <comment line="372">
                    Tests to ensure the system properties table is fully                    
                </comment>
                <comment line="373">
                    initialized. This is needed because reflection code is                    
                </comment>
                <comment line="374">
                    called very early in the initialization process (before                    
                </comment>
                <comment line="375">
                    command-line arguments have been parsed and therefore                    
                </comment>
                <comment line="376">
                    these user-settable properties installed.) We assume that                    
                </comment>
                <comment line="377">
                    if System.out is non-null then the System class has been                    
                </comment>
                <comment line="378">
                    fully initialized and that the bulk of the startup code                    
                </comment>
                <comment line="379">
                    has been run.                    
                </comment>
                <comment line="382">
                    java.lang.System not yet fully initialized                    
                </comment>
                <anonymous_class line="370">
                    <method name="run" type="Void" line="371">
                        <comment line="372">
                            Tests to ensure the system properties table is fully                            
                        </comment>
                        <comment line="373">
                            initialized. This is needed because reflection code is                            
                        </comment>
                        <comment line="374">
                            called very early in the initialization process (before                            
                        </comment>
                        <comment line="375">
                            command-line arguments have been parsed and therefore                            
                        </comment>
                        <comment line="376">
                            these user-settable properties installed.) We assume that                            
                        </comment>
                        <comment line="377">
                            if System.out is non-null then the System class has been                            
                        </comment>
                        <comment line="378">
                            fully initialized and that the bulk of the startup code                            
                        </comment>
                        <comment line="379">
                            has been run.                            
                        </comment>
                        <comment line="382">
                            java.lang.System not yet fully initialized                            
                        </comment>
                        <scope line="381"/>
                        <declaration name="val" type="String" line="386"/>
                        <scope line="387"/>
                        <scope line="392">
                            <scope line="393"/>
                            <scope line="395"/>
                        </scope>
                    </method>
                </anonymous_class>
            </method>
            <method name="langReflectAccess" type="LangReflectAccess" line="408">
                <comment line="410">
                    Call a static method to get class java.lang.reflect.Modifier                    
                </comment>
                <comment line="411">
                    initialized. Its static initializer will cause                    
                </comment>
                <comment line="412">
                    setLangReflectAccess() to be called from the context of the                    
                </comment>
                <comment line="413">
                    java.lang.reflect package.                    
                </comment>
                <scope line="409"/>
            </method>
        </class>
    </source>