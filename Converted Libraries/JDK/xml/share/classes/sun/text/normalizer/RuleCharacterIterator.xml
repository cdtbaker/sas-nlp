<?xml version="1.0" encoding="UTF-8"?>
    <source package="sun.text.normalizer">
        <import package="java.text.ParsePosition"/>
        <class name="RuleCharacterIterator" line="3">
            <javadoc line="3">
                An iterator that returns 32-bit code points.  This class is deliberately
                  &lt;em&gt;not&lt;/em&gt; related to any of the JDK or ICU4J character iterator classes
                  in order to minimize complexity.                
                <author>
                    Alan Liu                    
                </author>
                <since>
                    ICU 2.8                    
                </since>
            </javadoc>
            <declaration name="text" type="String" line="11"/>
            <javadoc line="11">
                Text being iterated.                
            </javadoc>
            <declaration name="pos" type="ParsePosition" line="15"/>
            <javadoc line="15">
                Position of iterator.                
            </javadoc>
            <declaration name="sym" type="SymbolTable" line="19"/>
            <javadoc line="19">
                Symbol table used to parse and dereference variables.  May be null.                
            </javadoc>
            <declaration name="buf" type="char[]" line="23"/>
            <javadoc line="23">
                Current variable expansion, or null if none.                
            </javadoc>
            <declaration name="bufPos" type="int" line="27"/>
            <javadoc line="27">
                Position within buf[].  Meaningless if buf == null.                
            </javadoc>
            <declaration name="isEscaped" type="boolean" line="31"/>
            <javadoc line="31">
                Flag indicating whether the last character was parsed from an escape.                
            </javadoc>
            <declaration name="DONE" type="int" line="35"/>
            <javadoc line="35">
                Value returned when there are no more characters to iterate.                
            </javadoc>
            <declaration name="PARSE_VARIABLES" type="int" line="39"/>
            <javadoc line="39">
                Bitmask option to enable parsing of variable names.  If (options &amp;
                  PARSE_VARIABLES) != 0, then an embedded variable will be expanded to
                  its value.  Variables are parsed using the SymbolTable API.                
            </javadoc>
            <declaration name="PARSE_ESCAPES" type="int" line="45"/>
            <javadoc line="45">
                Bitmask option to enable parsing of escape sequences.  If (options &amp;
                  PARSE_ESCAPES) != 0, then an embedded escape sequence will be expanded
                  to its value.  Escapes are parsed using Utility.unescapeAt().                
            </javadoc>
            <declaration name="SKIP_WHITESPACE" type="int" line="51"/>
            <javadoc line="51">
                Bitmask option to enable skipping of whitespace.  If (options &amp;
                  SKIP_WHITESPACE) != 0, then whitespace characters will be silently
                  skipped, as if they were not present in the input.  Whitespace
                  characters are defined by UCharacterProperty.isRuleWhiteSpace().                
            </javadoc>
            <javadoc line="58">
                Constructs an iterator over the given text, starting at the given
                  position.                
                <param>
                    text the text to be iterated                    
                </param>
                <param>
                    sym the symbol table, or null if there is none.  If sym is null,
                      then variables will not be deferenced, even if the PARSE_VARIABLES
                      option is set.                    
                </param>
                <param>
                    pos upon input, the index of the next character to return.  If a
                      variable has been dereferenced, then pos will &lt;em&gt;not&lt;/em&gt; increment as
                      characters of the variable value are iterated.                    
                </param>
            </javadoc>
            <method name="RuleCharacterIterator" type="constructor" line="69">
                <params>
                    <param name="text" type="String"/>
                    <param name="sym" type="SymbolTable"/>
                    <param name="pos" type="ParsePosition"/>
                </params>
                <scope line="70"/>
            </method>
            <javadoc line="78">
                Returns true if this iterator has no more characters to return.                
            </javadoc>
            <method name="atEnd" type="boolean" line="81"/>
            <javadoc line="84">
                Returns the next character using the given options, or DONE if there
                  are no more characters, and advance the position to the next
                  character.                
                <param>
                    options one or more of the following options, bitwise-OR-ed
                      together: PARSE_VARIABLES, PARSE_ESCAPES, SKIP_WHITESPACE.                    
                </param>
                <return>
                    the current 32-bit code point, or DONE                    
                </return>
            </javadoc>
            <method name="next" type="int" line="92">
                <params>
                    <param name="options" type="int"/>
                </params>
                <declaration name="c" type="int" line="93"/>
                <scope line="95">
                    <scope line="98">
                        <declaration name="name" type="String" line="99"/>
                        <scope line="100"/>
                        <scope line="105"/>
                        <scope line="108"/>
                    </scope>
                    <scope line="113"/>
                    <scope line="116">
                        <declaration name="offset" type="int" line="117"/>
                        <scope line="121"/>
                    </scope>
                </scope>
            </method>
            <javadoc line="129">
                Returns true if the last character returned by next() was
                  escaped.  This will only be the case if the option passed in to
                  next() included PARSE_ESCAPED and the next character was an
                  escape sequence.                
            </javadoc>
            <method name="isEscaped" type="boolean" line="135"/>
            <javadoc line="138">
                Returns true if this iterator is currently within a variable expansion.                
            </javadoc>
            <method name="inVariable" type="boolean" line="141"/>
            <javadoc line="144">
                Returns an object which, when later passed to setPos(), will
                  restore this iterator&apos;s position.  Usage idiom:
                  RuleCharacterIterator iterator = ...;
                  Object pos = iterator.getPos(null); // allocate position object
                  for (;;) {
                  pos = iterator.getPos(pos); // reuse position object
                  int c = iterator.next(...);
                  ...
                  }
                  iterator.setPos(pos);                
                <param>
                    p a position object previously returned by getPos(),
                      or null.  If not null, it will be updated and returned.  If
                      null, a new position object will be allocated and returned.                    
                </param>
                <return>
                    a position object which may be passed to setPos(),
                      either `p,&apos; or if `p&apos; == null, a newly-allocated object                    
                </return>
            </javadoc>
            <method name="getPos" type="Object" line="161">
                <params>
                    <param name="p" type="Object"/>
                </params>
                <scope line="162"/>
                <declaration name="a" type="Object[]" line="165"/>
                <declaration name="v" type="int[]" line="167"/>
            </method>
            <javadoc line="172">
                Restores this iterator to the position it had when getPos()
                  returned the given object.                
                <param>
                    p a position object previously returned by getPos()                    
                </param>
            </javadoc>
            <method name="setPos" type="void" line="177">
                <params>
                    <param name="p" type="Object"/>
                </params>
                <declaration name="a" type="Object[]" line="178"/>
                <declaration name="v" type="int[]" line="180"/>
            </method>
            <javadoc line="184">
                Skips ahead past any ignored characters, as indicated by the given
                  options.  This is useful in conjunction with the lookahead() method.
                  Currently, this only has an effect for SKIP_WHITESPACE.                
                <param>
                    options one or more of the following options, bitwise-OR-ed
                      together: PARSE_VARIABLES, PARSE_ESCAPES, SKIP_WHITESPACE.                    
                </param>
            </javadoc>
            <method name="skipIgnored" type="void" line="191">
                <params>
                    <param name="options" type="int"/>
                </params>
                <scope line="192">
                    <scope line="193">
                        <declaration name="a" type="int" line="194"/>
                    </scope>
                </scope>
            </method>
            <javadoc line="200">
                Returns a string containing the remainder of the characters to be
                  returned by this iterator, without any option processing.  If the
                  iterator is currently within a variable expansion, this will only
                  extend to the end of the variable expansion.  This method is provided
                  so that iterators may interoperate with string-based APIs.  The typical
                  sequence of calls is to call skipIgnored(), then call lookahead(), then
                  parse the string returned by lookahead(), then call jumpahead() to
                  resynchronize the iterator.                
                <return>
                    a string containing the characters to be returned by future
                      calls to next()                    
                </return>
            </javadoc>
            <method name="lookahead" type="String" line="212">
                <scope line="213"/>
                <scope line="216"/>
            </method>
            <javadoc line="220">
                Advances the position by the given number of 16-bit code units.
                  This is useful in conjunction with the lookahead() method.                
                <param>
                    count the number of 16-bit code units to jump over                    
                </param>
            </javadoc>
            <method name="jumpahead" type="void" line="225">
                <params>
                    <param name="count" type="int"/>
                </params>
                <scope line="226"/>
                <scope line="229">
                    <scope line="231"/>
                    <scope line="234"/>
                </scope>
                <scope line="238">
                    <declaration name="i" type="int" line="239"/>
                    <scope line="241"/>
                </scope>
            </method>
            <javadoc line="246">
                Returns the current 32-bit code point without parsing escapes, parsing
                  variables, or skipping whitespace.                
                <return>
                    the current 32-bit code point                    
                </return>
            </javadoc>
            <method name="_current" type="int" line="251">
                <scope line="252"/>
                <scope line="255">
                    <declaration name="i" type="int" line="256"/>
                </scope>
            </method>
            <javadoc line="260">
                Advances the position by the given amount.                
                <param>
                    count the number of 16-bit code units to advance past                    
                </param>
            </javadoc>
            <method name="_advance" type="void" line="264">
                <params>
                    <param name="count" type="int"/>
                </params>
                <scope line="265">
                    <scope line="267"/>
                </scope>
                <scope line="271">
                    <scope line="273"/>
                </scope>
            </method>
        </class>
    </source>