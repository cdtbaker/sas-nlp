<?xml version="1.0" encoding="UTF-8"?>
    <source package="sun.text.normalizer">
        <import package="java.text.ParsePosition"/>
        <class name="RuleCharacterIterator" line="50">
            <comment line="60">
                TODO: Ideas for later.  (Do not implement if not needed, lest the                
            </comment>
            <comment line="61">
                code coverage numbers go down due to unused methods.)                
            </comment>
            <comment line="62">
                1. Add a copy constructor, equals() method, clone() method.                
            </comment>
            <comment line="63">
                2. Rather than return DONE, throw an exception if the end                
            </comment>
            <comment line="64">
                is reached -- this is an alternate usage model, probably not useful.                
            </comment>
            <comment line="65">
                3. Return isEscaped from next().  If this happens,                
            </comment>
            <comment line="66">
                don&apos;t keep an isEscaped member variable.                
            </comment>
            <javadoc line="50">
                An iterator that returns 32-bit code points.  This class is deliberately
                  &lt;em&gt;not&lt;/em&gt; related to any of the JDK or ICU4J character iterator classes
                  in order to minimize complexity.                
                <author>
                    Alan Liu                    
                </author>
                <since>
                    ICU 2.8                    
                </since>
            </javadoc>
            <declaration name="text" type="String" line="67"/>
            <javadoc line="67">
                Text being iterated.                
            </javadoc>
            <declaration name="pos" type="ParsePosition" line="72"/>
            <javadoc line="72">
                Position of iterator.                
            </javadoc>
            <declaration name="sym" type="SymbolTable" line="77"/>
            <javadoc line="77">
                Symbol table used to parse and dereference variables.  May be null.                
            </javadoc>
            <declaration name="buf" type="char[]" line="82"/>
            <javadoc line="82">
                Current variable expansion, or null if none.                
            </javadoc>
            <declaration name="bufPos" type="int" line="87"/>
            <javadoc line="87">
                Position within buf[].  Meaningless if buf == null.                
            </javadoc>
            <declaration name="isEscaped" type="boolean" line="92"/>
            <javadoc line="92">
                Flag indicating whether the last character was parsed from an escape.                
            </javadoc>
            <declaration name="DONE" type="int" line="97"/>
            <javadoc line="97">
                Value returned when there are no more characters to iterate.                
            </javadoc>
            <declaration name="PARSE_VARIABLES" type="int" line="102"/>
            <javadoc line="102">
                Bitmask option to enable parsing of variable names.  If (options &amp;
                  PARSE_VARIABLES) != 0, then an embedded variable will be expanded to
                  its value.  Variables are parsed using the SymbolTable API.                
            </javadoc>
            <declaration name="PARSE_ESCAPES" type="int" line="109"/>
            <javadoc line="109">
                Bitmask option to enable parsing of escape sequences.  If (options &amp;
                  PARSE_ESCAPES) != 0, then an embedded escape sequence will be expanded
                  to its value.  Escapes are parsed using Utility.unescapeAt().                
            </javadoc>
            <declaration name="SKIP_WHITESPACE" type="int" line="116"/>
            <javadoc line="116">
                Bitmask option to enable skipping of whitespace.  If (options &amp;
                  SKIP_WHITESPACE) != 0, then whitespace characters will be silently
                  skipped, as if they were not present in the input.  Whitespace
                  characters are defined by UCharacterProperty.isRuleWhiteSpace().                
            </javadoc>
            <javadoc line="124">
                Constructs an iterator over the given text, starting at the given
                  position.                
                <param>
                    text the text to be iterated                    
                </param>
                <param>
                    sym the symbol table, or null if there is none.  If sym is null,
                      then variables will not be deferenced, even if the PARSE_VARIABLES
                      option is set.                    
                </param>
                <param>
                    pos upon input, the index of the next character to return.  If a
                      variable has been dereferenced, then pos will <em>not</em> increment as
                      characters of the variable value are iterated.                    
                </param>
            </javadoc>
            <method name="RuleCharacterIterator" type="constructor" line="136">
                <params>
                    <param name="text" type="String"/>
                    <param name="sym" type="SymbolTable"/>
                    <param name="pos" type="ParsePosition"/>
                </params>
                <scope line="137"/>
            </method>
            <javadoc line="146">
                Returns true if this iterator has no more characters to return.                
            </javadoc>
            <method name="atEnd" type="boolean" line="149"/>
            <javadoc line="153">
                Returns the next character using the given options, or DONE if there
                  are no more characters, and advance the position to the next
                  character.                
                <param>
                    options one or more of the following options, bitwise-OR-ed
                      together: PARSE_VARIABLES, PARSE_ESCAPES, SKIP_WHITESPACE.                    
                </param>
                <return>
                    the current 32-bit code point, or DONE                    
                </return>
            </javadoc>
            <method name="next" type="int" line="161">
                <params>
                    <param name="options" type="int"/>
                </params>
                <comment line="172">
                    If name == null there was an isolated SYMBOL_REF;                    
                </comment>
                <comment line="173">
                    return it.  Caller must be prepared for this.                    
                </comment>
                <comment line="183">
                    Handle empty variable value                    
                </comment>
                <declaration name="c" type="int" line="162"/>
                <scope line="165">
                    <scope line="170">
                        <declaration name="name" type="String" line="171"/>
                        <scope line="174"/>
                        <scope line="179"/>
                        <scope line="184"/>
                    </scope>
                    <scope line="191"/>
                    <scope line="195">
                        <declaration name="offset" type="int" line="196"/>
                        <scope line="200"/>
                    </scope>
                </scope>
            </method>
            <javadoc line="211">
                Returns true if the last character returned by next() was
                  escaped.  This will only be the case if the option passed in to
                  next() included PARSE_ESCAPED and the next character was an
                  escape sequence.                
            </javadoc>
            <method name="isEscaped" type="boolean" line="217"/>
            <javadoc line="221">
                Returns true if this iterator is currently within a variable expansion.                
            </javadoc>
            <method name="inVariable" type="boolean" line="224"/>
            <javadoc line="228">
                Returns an object which, when later passed to setPos(), will
                  restore this iterator&apos;s position.  Usage idiom:
                  RuleCharacterIterator iterator = ...;
                  Object pos = iterator.getPos(null); // allocate position object
                  for (;;) {
                  pos = iterator.getPos(pos); // reuse position object
                  int c = iterator.next(...);
                  ...
                  }
                  iterator.setPos(pos);                
                <param>
                    p a position object previously returned by getPos(),
                      or null.  If not null, it will be updated and returned.  If
                      null, a new position object will be allocated and returned.                    
                </param>
                <return>
                    a position object which may be passed to setPos(),
                      either `p,' or if `p' == null, a newly-allocated object                    
                </return>
            </javadoc>
            <method name="getPos" type="Object" line="247">
                <params>
                    <param name="p" type="Object"/>
                </params>
                <scope line="248"/>
                <declaration name="a" type="Object[]" line="251"/>
                <declaration name="v" type="int[]" line="253"/>
            </method>
            <javadoc line="259">
                Restores this iterator to the position it had when getPos()
                  returned the given object.                
                <param>
                    p a position object previously returned by getPos()                    
                </param>
            </javadoc>
            <method name="setPos" type="void" line="264">
                <params>
                    <param name="p" type="Object"/>
                </params>
                <declaration name="a" type="Object[]" line="265"/>
                <declaration name="v" type="int[]" line="267"/>
            </method>
            <javadoc line="272">
                Skips ahead past any ignored characters, as indicated by the given
                  options.  This is useful in conjunction with the lookahead() method.
                  Currently, this only has an effect for SKIP_WHITESPACE.                
                <param>
                    options one or more of the following options, bitwise-OR-ed
                      together: PARSE_VARIABLES, PARSE_ESCAPES, SKIP_WHITESPACE.                    
                </param>
            </javadoc>
            <method name="skipIgnored" type="void" line="280">
                <params>
                    <param name="options" type="int"/>
                </params>
                <scope line="281">
                    <scope line="282">
                        <declaration name="a" type="int" line="283"/>
                    </scope>
                </scope>
            </method>
            <javadoc line="290">
                Returns a string containing the remainder of the characters to be
                  returned by this iterator, without any option processing.  If the
                  iterator is currently within a variable expansion, this will only
                  extend to the end of the variable expansion.  This method is provided
                  so that iterators may interoperate with string-based APIs.  The typical
                  sequence of calls is to call skipIgnored(), then call lookahead(), then
                  parse the string returned by lookahead(), then call jumpahead() to
                  resynchronize the iterator.                
                <return>
                    a string containing the characters to be returned by future
                      calls to next()                    
                </return>
            </javadoc>
            <method name="lookahead" type="String" line="302">
                <scope line="303"/>
                <scope line="305"/>
            </method>
            <javadoc line="310">
                Advances the position by the given number of 16-bit code units.
                  This is useful in conjunction with the lookahead() method.                
                <param>
                    count the number of 16-bit code units to jump over                    
                </param>
            </javadoc>
            <method name="jumpahead" type="void" line="315">
                <params>
                    <param name="count" type="int"/>
                </params>
                <scope line="316"/>
                <scope line="319">
                    <scope line="321"/>
                    <scope line="324"/>
                </scope>
                <scope line="327">
                    <declaration name="i" type="int" line="328"/>
                    <scope line="330"/>
                </scope>
            </method>
            <javadoc line="336">
                Returns the current 32-bit code point without parsing escapes, parsing
                  variables, or skipping whitespace.                
                <return>
                    the current 32-bit code point                    
                </return>
            </javadoc>
            <method name="_current" type="int" line="341">
                <scope line="342"/>
                <scope line="344">
                    <declaration name="i" type="int" line="345"/>
                </scope>
            </method>
            <javadoc line="350">
                Advances the position by the given amount.                
                <param>
                    count the number of 16-bit code units to advance past                    
                </param>
            </javadoc>
            <method name="_advance" type="void" line="354">
                <params>
                    <param name="count" type="int"/>
                </params>
                <scope line="355">
                    <scope line="357"/>
                </scope>
                <scope line="360">
                    <scope line="362"/>
                </scope>
            </method>
        </class>
    </source>