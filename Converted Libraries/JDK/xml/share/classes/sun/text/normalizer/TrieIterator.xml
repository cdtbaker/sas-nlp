<?xml version="1.0" encoding="UTF-8"?>
    <source package="sun.text.normalizer">
        <class name="TrieIterator" line="2">
            <implements interface="RangeValueIterator"/>
            <javadoc line="2">
                &lt;p&gt;Class enabling iteration of the values in a Trie.&lt;/p&gt;
                  &lt;p&gt;Result of each iteration contains the interval of codepoints that have
                  the same value type and the value type itself.&lt;/p&gt;
                  &lt;p&gt;The comparison of each codepoint value is done via extract(), which the
                  default implementation is to return the value as it is.&lt;/p&gt;
                  &lt;p&gt;Method extract() can be overwritten to perform manipulations on
                  codepoint values in order to perform specialized comparison.&lt;/p&gt;
                  &lt;p&gt;TrieIterator is designed to be a generic iterator for the CharTrie
                  and the IntTrie, hence to accommodate both types of data, the return
                  result will be in terms of int (32 bit) values.&lt;/p&gt;
                  &lt;p&gt;See com.ibm.icu.text.UCharacterTypeIterator for examples of use.&lt;/p&gt;
                  &lt;p&gt;Notes for porting utrie_enum from icu4c to icu4j:&lt;br&gt;
                  Internally, icu4c&apos;s utrie_enum performs all iterations in its body. In Java
                  sense, the caller will have to pass a object with a callback function
                  UTrieEnumRange(const void context, UChar32 start, UChar32 limit,
                  uint32_t value) into utrie_enum. utrie_enum will then find ranges of
                  codepoints with the same value as determined by
                  UTrieEnumValue(const void context, uint32_t value). for each range,
                  utrie_enum calls the callback function to perform a task. In this way,
                  icu4c performs the iteration within utrie_enum.
                  To follow the JDK model, icu4j is slightly different from icu4c.
                  Instead of requesting the caller to implement an object for a callback.
                  The caller will have to implement a subclass of TrieIterator, fleshing out
                  the method extract(int) (equivalent to UTrieEnumValue). Independent of icu4j,
                  the caller will have to code his own iteration and flesh out the task
                  (equivalent to UTrieEnumRange) to be performed in the iteration loop.
                  &lt;/p&gt;
                  &lt;p&gt;There are basically 3 usage scenarios for porting:&lt;/p&gt;
                  &lt;p&gt;1) UTrieEnumValue is the only implemented callback then just implement a
                  subclass of TrieIterator and override the extract(int) method. The
                  extract(int) method is analogus to UTrieEnumValue callback.
                  &lt;/p&gt;
                  &lt;p&gt;2) UTrieEnumValue and UTrieEnumRange both are implemented then implement
                  a subclass of TrieIterator, override the extract method and iterate, e.g
                  &lt;/p&gt;
                  &lt;p&gt;utrie_enum(&amp;normTrie, _enumPropertyStartsValue, _enumPropertyStartsRange,
                  set);&lt;br&gt;
                  In Java :&lt;br&gt;
                  &lt;pre&gt;
                  class TrieIteratorImpl extends TrieIterator{
                  public TrieIteratorImpl(Trie data){
                  super(data);
                  }
                  public int extract(int value){
                  // port the implementation of _enumPropertyStartsValue here
                  }
                  }
                  ....
                  TrieIterator fcdIter  = new TrieIteratorImpl(fcdTrieImpl.fcdTrie);
                  while(fcdIter.next(result)) {
                  // port the implementation of _enumPropertyStartsRange
                  }
                  &lt;/pre&gt;
                  &lt;/p&gt;
                  &lt;p&gt;3) UTrieEnumRange is the only implemented callback then just implement
                  the while loop, when utrie_enum is called
                  &lt;pre&gt;
                  // utrie_enum(&amp;fcdTrie, NULL, _enumPropertyStartsRange, set);
                  TrieIterator fcdIter  = new TrieIterator(fcdTrieImpl.fcdTrie);
                  while(fcdIter.next(result)){
                  set.add(result.start);
                  }
                  &lt;/pre&gt;
                  &lt;/p&gt;                
                <author>
                    synwee                    
                </author>
                <see>
                    com.ibm.icu.impl.Trie                    
                </see>
                <see>
                    com.ibm.icu.lang.UCharacterTypeIterator                    
                </see>
                <since>
                    release 2.1, Jan 17 2002                    
                </since>
            </javadoc>
            <javadoc line="73">
                TrieEnumeration constructor                
                <param>
                    trie to be used                    
                </param>
                <exception>
                    IllegalArgumentException throw when argument is null.                    
                </exception>
            </javadoc>
            <method name="TrieIterator" type="constructor" line="78">
                <params>
                    <param name="trie" type="Trie"/>
                </params>
                <scope line="79"/>
            </method>
            <javadoc line="86">
                &lt;p&gt;Returns true if we are not at the end of the iteration, false
                  otherwise.&lt;/p&gt;
                  &lt;p&gt;The next set of codepoints with the same value type will be
                  calculated during this call and returned in the arguement element.&lt;/p&gt;                
                <param>
                    element return result                    
                </param>
                <return>
                    true if we are not at the end of the iteration, false otherwise.                    
                </return>
                <exception>
                    NoSuchElementException - if no more elements exist.                    
                </exception>
                <see>
                    com.ibm.icu.util.RangeValueIterator.Element                    
                </see>
            </javadoc>
            <method name="next" type="boolean" line="96">
                <params>
                    <param name="element" type="Element"/>
                </params>
                <scope line="97"/>
                <scope line="100"/>
            </method>
            <javadoc line="106">
                Resets the iterator to the beginning of the iteration                
            </javadoc>
            <method name="reset" type="void" line="109">
                <scope line="114"/>
                <scope line="117"/>
            </method>
            <javadoc line="123">
                Called by next() to extracts a 32 bit value from a trie value
                  used for comparison.
                  This method is to be overwritten if special manipulation is to be done
                  to retrieve a relevant comparison.
                  The default function is to return the value as it is.                
                <param>
                    value a value from the trie                    
                </param>
                <return>
                    extracted value                    
                </return>
            </javadoc>
            <method name="extract" type="int" line="132">
                <params>
                    <param name="value" type="int"/>
                </params>
            </method>
            <javadoc line="135">
                Set the result values                
                <param>
                    element return result object                    
                </param>
                <param>
                    start codepoint of range                    
                </param>
                <param>
                    limit (end + 1) codepoint of range                    
                </param>
                <param>
                    value common value of range                    
                </param>
            </javadoc>
            <method name="setResult" type="void" line="142">
                <params>
                    <param name="element" type="Element"/>
                    <param name="start" type="int"/>
                    <param name="limit" type="int"/>
                    <param name="value" type="int"/>
                </params>
            </method>
            <javadoc line="147">
                Finding the next element.
                  This method is called just before returning the result of
                  next().
                  We always store the next element before it is requested.
                  In the case that we have to continue calculations into the
                  supplementary planes, a false will be returned.                
                <param>
                    element return result object                    
                </param>
                <return>
                    true if the next range is found, false if we have to proceed to
                      the supplementary range.                    
                </return>
            </javadoc>
            <method name="calculateNextBMPElement" type="boolean" line="158">
                <params>
                    <param name="element" type="Element"/>
                </params>
                <declaration name="currentBlock" type="int" line="159"/>
                <declaration name="currentValue" type="int" line="160"/>
                <scope line="164"/>
                <scope line="168">
                    <scope line="170"/>
                    <scope line="173"/>
                    <scope line="177"/>
                </scope>
            </method>
            <javadoc line="186">
                Finds the next supplementary element.
                  For each entry in the trie, the value to be delivered is passed through
                  extract().
                  We always store the next element before it is requested.
                  Called after calculateNextBMP() completes its round of BMP characters.
                  There is a slight difference in the usage of m_currentCodepoint_
                  here as compared to calculateNextBMP(). Though both represents the
                  lower bound of the next element, in calculateNextBMP() it gets set
                  at the start of any loop, where-else, in calculateNextSupplementary()
                  since m_currentCodepoint_ already contains the lower bound of the
                  next element (passed down from calculateNextBMP()), we keep it till
                  the end before resetting it to the new value.
                  Note, if there are no more iterations, it will never get to here.
                  Blocked out by next().                
                <param>
                    element return result object                    
                </param>
            </javadoc>
            <method name="calculateNextSupplementaryElement" type="void" line="203">
                <params>
                    <param name="element" type="Element"/>
                </params>
                <declaration name="currentValue" type="int" line="204"/>
                <declaration name="currentBlock" type="int" line="205"/>
                <scope line="208">
                    <scope line="209"/>
                    <scope line="216"/>
                </scope>
                <declaration name="nextLead" type="int" line="222"/>
                <scope line="223">
                    <declaration name="leadBlock" type="int" line="224"/>
                    <scope line="225">
                        <scope line="226"/>
                    </scope>
                    <scope line="238"/>
                    <scope line="242">
                        <scope line="243"/>
                    </scope>
                    <scope line="253">
                        <scope line="255"/>
                    </scope>
                </scope>
            </method>
            <javadoc line="265">
                Internal block value calculations
                  Performs calculations on a data block to find codepoints in m_nextBlock_
                  after the index m_nextBlockIndex_ that has the same value.
                  Note m__ variables at this point is the next codepoint whose value
                  has not been calculated.
                  But when returned with false, it will be the last codepoint whose
                  value has been calculated.                
                <param>
                    currentValue the value which other codepoints are tested against                    
                </param>
                <return>
                    true if the whole block has the same value as currentValue or if
                      the whole block has been calculated, false otherwise.                    
                </return>
            </javadoc>
            <method name="checkBlockDetail" type="boolean" line="277">
                <params>
                    <param name="currentValue" type="int"/>
                </params>
                <scope line="278">
                    <scope line="280"/>
                </scope>
            </method>
            <javadoc line="288">
                Internal block value calculations
                  Performs calculations on a data block to find codepoints in m_nextBlock_
                  that has the same value.
                  Will call checkBlockDetail() if highlevel check fails.
                  Note m__ variables at this point is the next codepoint whose value
                  has not been calculated.                
                <param>
                    currentBlock the initial block containing all currentValue                    
                </param>
                <param>
                    currentValue the value which other codepoints are tested against                    
                </param>
                <return>
                    true if the whole block has the same value as currentValue or if
                      the whole block has been calculated, false otherwise.                    
                </return>
            </javadoc>
            <method name="checkBlock" type="boolean" line="300">
                <params>
                    <param name="currentBlock" type="int"/>
                    <param name="currentValue" type="int"/>
                </params>
                <scope line="302"/>
                <scope line="305">
                    <scope line="306"/>
                </scope>
                <scope line="313">
                    <scope line="314"/>
                </scope>
            </method>
            <javadoc line="320">
                Internal block value calculations
                  Performs calculations on multiple data blocks for a set of trail
                  surrogates to find codepoints in m_nextBlock_ that has the same value.
                  Will call checkBlock() for internal block checks.
                  Note m__ variables at this point is the next codepoint whose value
                  has not been calculated.                
                <param>
                    currentBlock the initial block containing all currentValue                    
                </param>
                <param>
                    currentValue the value which other codepoints are tested against                    
                </param>
                <return>
                    true if the whole block has the same value as currentValue or if
                      the whole block has been calculated, false otherwise.                    
                </return>
            </javadoc>
            <method name="checkTrailBlock" type="boolean" line="332">
                <params>
                    <param name="currentBlock" type="int"/>
                    <param name="currentValue" type="int"/>
                </params>
                <scope line="333">
                    <scope line="335"/>
                </scope>
            </method>
            <javadoc line="343">
                Checks if we are beginning at the start of a initial block.
                  If we are then the rest of the codepoints in this initial block
                  has the same values.
                  We increment m_nextCodepoint_ and relevant data members if so.
                  This is used only in for the supplementary codepoints because
                  the offset to the trail indexes could be 0.                
                <return>
                    true if we are at the start of a initial block.                    
                </return>
            </javadoc>
            <method name="checkNullNextTrailIndex" type="boolean" line="352">
                <scope line="353">
                    <declaration name="nextLead" type="int" line="355"/>
                    <declaration name="leadBlock" type="int" line="356"/>
                    <scope line="357"/>
                </scope>
            </method>
            <declaration name="BMP_INDEX_LENGTH_" type="int" line="367"/>
            <javadoc line="367">
                Size of the stage 1 BMP indexes                
            </javadoc>
            <declaration name="LEAD_SURROGATE_MIN_VALUE_" type="int" line="371"/>
            <javadoc line="371">
                Lead surrogate minimum value                
            </javadoc>
            <declaration name="TRAIL_SURROGATE_MIN_VALUE_" type="int" line="375"/>
            <javadoc line="375">
                Trail surrogate minimum value                
            </javadoc>
            <declaration name="TRAIL_SURROGATE_COUNT_" type="int" line="379"/>
            <javadoc line="379">
                Number of trail surrogate                
            </javadoc>
            <declaration name="TRAIL_SURROGATE_INDEX_BLOCK_LENGTH_" type="int" line="383"/>
            <javadoc line="383">
                Number of stage 1 indexes for supplementary calculations that maps to
                  each lead surrogate character.
                  See second pass into getRawOffset for the trail surrogate character.
                  10 for significant number of bits for trail surrogates, 5 for what we
                  discard during shifting.                
            </javadoc>
            <declaration name="DATA_BLOCK_LENGTH_" type="int" line="391"/>
            <javadoc line="391">
                Number of data values in a stage 2 (data array) block.                
            </javadoc>
            <declaration name="m_trie_" type="Trie" line="395"/>
            <javadoc line="395">
                Trie instance                
            </javadoc>
            <declaration name="m_initialValue_" type="int" line="399"/>
            <javadoc line="399">
                Initial value for trie values                
            </javadoc>
            <declaration name="m_currentCodepoint_" type="int" line="403"/>
            <javadoc line="403">
                Next element results and data.                
            </javadoc>
            <declaration name="m_nextCodepoint_" type="int" line="407"/>
            <declaration name="m_nextValue_" type="int" line="408"/>
            <declaration name="m_nextIndex_" type="int" line="409"/>
            <declaration name="m_nextBlock_" type="int" line="410"/>
            <declaration name="m_nextBlockIndex_" type="int" line="411"/>
            <declaration name="m_nextTrailIndexOffset_" type="int" line="412"/>
        </class>
    </source>