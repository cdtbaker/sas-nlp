<?xml version="1.0" encoding="UTF-8"?>
    <source package="sun.text.normalizer">
        <class name="TrieIterator" line="39">
            <comment line="113">
                public constructor ---------------------------------------------                
            </comment>
            <comment line="132">
                public methods -------------------------------------------------                
            </comment>
            <comment line="176">
                protected methods ----------------------------------------------                
            </comment>
            <comment line="192">
                private methods ------------------------------------------------                
            </comment>
            <comment line="498">
                private data members --------------------------------------------                
            </comment>
            <implements interface="RangeValueIterator"/>
            <javadoc line="39">
                &lt;p&gt;Class enabling iteration of the values in a Trie.&lt;/p&gt;
                  &lt;p&gt;Result of each iteration contains the interval of codepoints that have
                  the same value type and the value type itself.&lt;/p&gt;
                  &lt;p&gt;The comparison of each codepoint value is done via extract(), which the
                  default implementation is to return the value as it is.&lt;/p&gt;
                  &lt;p&gt;Method extract() can be overwritten to perform manipulations on
                  codepoint values in order to perform specialized comparison.&lt;/p&gt;
                  &lt;p&gt;TrieIterator is designed to be a generic iterator for the CharTrie
                  and the IntTrie, hence to accommodate both types of data, the return
                  result will be in terms of int (32 bit) values.&lt;/p&gt;
                  &lt;p&gt;See com.ibm.icu.text.UCharacterTypeIterator for examples of use.&lt;/p&gt;
                  &lt;p&gt;Notes for porting utrie_enum from icu4c to icu4j:&lt;br&gt;
                  Internally, icu4c&apos;s utrie_enum performs all iterations in its body. In Java
                  sense, the caller will have to pass a object with a callback function
                  UTrieEnumRange(const void context, UChar32 start, UChar32 limit,
                  uint32_t value) into utrie_enum. utrie_enum will then find ranges of
                  codepoints with the same value as determined by
                  UTrieEnumValue(const void context, uint32_t value). for each range,
                  utrie_enum calls the callback function to perform a task. In this way,
                  icu4c performs the iteration within utrie_enum.
                  To follow the JDK model, icu4j is slightly different from icu4c.
                  Instead of requesting the caller to implement an object for a callback.
                  The caller will have to implement a subclass of TrieIterator, fleshing out
                  the method extract(int) (equivalent to UTrieEnumValue). Independent of icu4j,
                  the caller will have to code his own iteration and flesh out the task
                  (equivalent to UTrieEnumRange) to be performed in the iteration loop.
                  &lt;/p&gt;
                  &lt;p&gt;There are basically 3 usage scenarios for porting:&lt;/p&gt;
                  &lt;p&gt;1) UTrieEnumValue is the only implemented callback then just implement a
                  subclass of TrieIterator and override the extract(int) method. The
                  extract(int) method is analogus to UTrieEnumValue callback.
                  &lt;/p&gt;
                  &lt;p&gt;2) UTrieEnumValue and UTrieEnumRange both are implemented then implement
                  a subclass of TrieIterator, override the extract method and iterate, e.g
                  &lt;/p&gt;
                  &lt;p&gt;utrie_enum(&amp;normTrie, _enumPropertyStartsValue, _enumPropertyStartsRange,
                  set);&lt;br&gt;
                  In Java :&lt;br&gt;
                  &lt;pre&gt;
                  class TrieIteratorImpl extends TrieIterator{
                  public TrieIteratorImpl(Trie data){
                  super(data);
                  }
                  public int extract(int value){
                  // port the implementation of _enumPropertyStartsValue here
                  }
                  }
                  ....
                  TrieIterator fcdIter  = new TrieIteratorImpl(fcdTrieImpl.fcdTrie);
                  while(fcdIter.next(result)) {
                  // port the implementation of _enumPropertyStartsRange
                  }
                  &lt;/pre&gt;
                  &lt;/p&gt;
                  &lt;p&gt;3) UTrieEnumRange is the only implemented callback then just implement
                  the while loop, when utrie_enum is called
                  &lt;pre&gt;
                  // utrie_enum(&amp;fcdTrie, NULL, _enumPropertyStartsRange, set);
                  TrieIterator fcdIter  = new TrieIterator(fcdTrieImpl.fcdTrie);
                  while(fcdIter.next(result)){
                  set.add(result.start);
                  }
                  &lt;/pre&gt;
                  &lt;/p&gt;                
                <author>
                    synwee                    
                </author>
                <see>
                    com.ibm.icu.impl.Trie                    
                </see>
                <see>
                    com.ibm.icu.lang.UCharacterTypeIterator                    
                </see>
                <since>
                    release 2.1, Jan 17 2002                    
                </since>
            </javadoc>
            <javadoc line="114">
                TrieEnumeration constructor                
                <param>
                    trie to be used                    
                </param>
                <exception>
                    IllegalArgumentException throw when argument is null.                    
                </exception>
            </javadoc>
            <method name="TrieIterator" type="constructor" line="120">
                <params>
                    <param name="trie" type="Trie"/>
                </params>
                <comment line="127">
                    synwee: check that extract belongs to the child class                    
                </comment>
                <scope line="121"/>
            </method>
            <javadoc line="133">
                &lt;p&gt;Returns true if we are not at the end of the iteration, false
                  otherwise.&lt;/p&gt;
                  &lt;p&gt;The next set of codepoints with the same value type will be
                  calculated during this call and returned in the arguement element.&lt;/p&gt;                
                <param>
                    element return result                    
                </param>
                <return>
                    true if we are not at the end of the iteration, false otherwise.                    
                </return>
                <exception>
                    NoSuchElementException - if no more elements exist.                    
                </exception>
                <see>
                    com.ibm.icu.util.RangeValueIterator.Element                    
                </see>
            </javadoc>
            <method name="next" type="boolean" line="144">
                <params>
                    <param name="element" type="Element"/>
                </params>
                <scope line="145"/>
                <scope line="149"/>
            </method>
            <javadoc line="156">
                Resets the iterator to the beginning of the iteration                
            </javadoc>
            <method name="reset" type="void" line="160">
                <scope line="165"/>
                <scope line="168"/>
            </method>
            <javadoc line="177">
                Called by next() to extracts a 32 bit value from a trie value
                  used for comparison.
                  This method is to be overwritten if special manipulation is to be done
                  to retrieve a relevant comparison.
                  The default function is to return the value as it is.                
                <param>
                    value a value from the trie                    
                </param>
                <return>
                    extracted value                    
                </return>
            </javadoc>
            <method name="extract" type="int" line="187">
                <params>
                    <param name="value" type="int"/>
                </params>
            </method>
            <javadoc line="193">
                Set the result values                
                <param>
                    element return result object                    
                </param>
                <param>
                    start codepoint of range                    
                </param>
                <param>
                    limit (end + 1) codepoint of range                    
                </param>
                <param>
                    value common value of range                    
                </param>
            </javadoc>
            <method name="setResult" type="void" line="202">
                <params>
                    <param name="element" type="Element"/>
                    <param name="start" type="int"/>
                    <param name="limit" type="int"/>
                    <param name="value" type="int"/>
                </params>
            </method>
            <javadoc line="208">
                Finding the next element.
                  This method is called just before returning the result of
                  next().
                  We always store the next element before it is requested.
                  In the case that we have to continue calculations into the
                  supplementary planes, a false will be returned.                
                <param>
                    element return result object                    
                </param>
                <return>
                    true if the next range is found, false if we have to proceed to
                      the supplementary range.                    
                </return>
            </javadoc>
            <method name="calculateNextBMPElement" type="boolean" line="220">
                <params>
                    <param name="element" type="Element"/>
                </params>
                <comment line="232">
                    synwee check that next block index == 0 here
                     enumerate BMP - the main loop enumerates data blocks                    
                </comment>
                <comment line="236">
                    because of the way the character is split to form the index
                     the lead surrogate and trail surrogate can not be in the
                     mid of a block                    
                </comment>
                <comment line="240">
                    skip lead surrogate code units,
                     go to lead surrogate codepoints                    
                </comment>
                <comment line="245">
                    go back to regular BMP code points                    
                </comment>
                <comment line="256">
                    step one back since this value has not been                    
                </comment>
                <comment line="257">
                    retrieved yet.                    
                </comment>
                <declaration name="currentBlock" type="int" line="221"/>
                <declaration name="currentValue" type="int" line="222"/>
                <scope line="226"/>
                <scope line="233">
                    <scope line="238"/>
                    <scope line="243"/>
                    <scope line="249"/>
                </scope>
            </method>
            <javadoc line="260">
                Finds the next supplementary element.
                  For each entry in the trie, the value to be delivered is passed through
                  extract().
                  We always store the next element before it is requested.
                  Called after calculateNextBMP() completes its round of BMP characters.
                  There is a slight difference in the usage of m_currentCodepoint_
                  here as compared to calculateNextBMP(). Though both represents the
                  lower bound of the next element, in calculateNextBMP() it gets set
                  at the start of any loop, where-else, in calculateNextSupplementary()
                  since m_currentCodepoint_ already contains the lower bound of the
                  next element (passed down from calculateNextBMP()), we keep it till
                  the end before resetting it to the new value.
                  Note, if there are no more iterations, it will never get to here.
                  Blocked out by next().                
                <param>
                    element return result object                    
                </param>
            </javadoc>
            <method name="calculateNextSupplementaryElement" type="void" line="278">
                <params>
                    <param name="element" type="Element"/>
                </params>
                <comment line="287">
                    this piece is only called when we are in the middle of a lead
                     surrogate block                    
                </comment>
                <comment line="295">
                    we have cleared one block                    
                </comment>
                <comment line="306">
                    enumerate supplementary code points                    
                </comment>
                <comment line="308">
                    lead surrogate access                    
                </comment>
                <comment line="313">
                    no entries for a whole block of lead surrogates                    
                </comment>
                <comment line="325">
                    number of total affected supplementary codepoints in one
                     block
                     this is not a simple addition of
                     DATA_BLOCK_SUPPLEMENTARY_LENGTH since we need to consider
                     that we might have moved some of the codepoints                    
                </comment>
                <comment line="339">
                    enumerate trail surrogates for this lead surrogate                    
                </comment>
                <comment line="344">
                    no data for this lead surrogate                    
                </comment>
                <comment line="367">
                    deliver last range                    
                </comment>
                <declaration name="currentValue" type="int" line="279"/>
                <declaration name="currentBlock" type="int" line="280"/>
                <scope line="285">
                    <scope line="288"/>
                    <scope line="297"/>
                </scope>
                <declaration name="nextLead" type="int" line="304"/>
                <scope line="306">
                    <declaration name="leadBlock" type="int" line="308"/>
                    <scope line="311">
                        <scope line="313"/>
                    </scope>
                    <scope line="334"/>
                    <scope line="342">
                        <scope line="344"/>
                    </scope>
                    <scope line="354">
                        <scope line="356"/>
                    </scope>
                </scope>
            </method>
            <javadoc line="371">
                Internal block value calculations
                  Performs calculations on a data block to find codepoints in m_nextBlock_
                  after the index m_nextBlockIndex_ that has the same value.
                  Note m__ variables at this point is the next codepoint whose value
                  has not been calculated.
                  But when returned with false, it will be the last codepoint whose
                  value has been calculated.                
                <param>
                    currentValue the value which other codepoints are tested against                    
                </param>
                <return>
                    true if the whole block has the same value as currentValue or if
                      the whole block has been calculated, false otherwise.                    
                </return>
            </javadoc>
            <method name="checkBlockDetail" type="boolean" line="384">
                <params>
                    <param name="currentValue" type="int"/>
                </params>
                <scope line="385">
                    <scope line="388"/>
                </scope>
            </method>
            <javadoc line="397">
                Internal block value calculations
                  Performs calculations on a data block to find codepoints in m_nextBlock_
                  that has the same value.
                  Will call checkBlockDetail() if highlevel check fails.
                  Note m__ variables at this point is the next codepoint whose value
                  has not been calculated.                
                <param>
                    currentBlock the initial block containing all currentValue                    
                </param>
                <param>
                    currentValue the value which other codepoints are tested against                    
                </param>
                <return>
                    true if the whole block has the same value as currentValue or if
                      the whole block has been calculated, false otherwise.                    
                </return>
            </javadoc>
            <method name="checkBlock" type="boolean" line="410">
                <params>
                    <param name="currentBlock" type="int"/>
                    <param name="currentValue" type="int"/>
                </params>
                <comment line="416">
                    the block is the same as the previous one, filled with
                     currentValue                    
                </comment>
                <comment line="421">
                    this is the all-initial-value block                    
                </comment>
                <scope line="414"/>
                <scope line="419">
                    <scope line="421"/>
                </scope>
                <scope line="428">
                    <scope line="429"/>
                </scope>
            </method>
            <javadoc line="436">
                Internal block value calculations
                  Performs calculations on multiple data blocks for a set of trail
                  surrogates to find codepoints in m_nextBlock_ that has the same value.
                  Will call checkBlock() for internal block checks.
                  Note m__ variables at this point is the next codepoint whose value
                  has not been calculated.                
                <param>
                    currentBlock the initial block containing all currentValue                    
                </param>
                <param>
                    currentValue the value which other codepoints are tested against                    
                </param>
                <return>
                    true if the whole block has the same value as currentValue or if
                      the whole block has been calculated, false otherwise.                    
                </return>
            </javadoc>
            <method name="checkTrailBlock" type="boolean" line="450">
                <params>
                    <param name="currentBlock" type="int"/>
                    <param name="currentValue" type="int"/>
                </params>
                <comment line="452">
                    enumerate code points for this lead surrogate                    
                </comment>
                <comment line="455">
                    if we ever reach here, we are at the start of a new block                    
                </comment>
                <comment line="457">
                    copy of most of the body of the BMP loop                    
                </comment>
                <scope line="453">
                    <scope line="457"/>
                </scope>
            </method>
            <javadoc line="466">
                Checks if we are beginning at the start of a initial block.
                  If we are then the rest of the codepoints in this initial block
                  has the same values.
                  We increment m_nextCodepoint_ and relevant data members if so.
                  This is used only in for the supplementary codepoints because
                  the offset to the trail indexes could be 0.                
                <return>
                    true if we are at the start of a initial block.                    
                </return>
            </javadoc>
            <method name="checkNullNextTrailIndex" type="boolean" line="476">
                <scope line="477">
                    <declaration name="nextLead" type="int" line="479"/>
                    <declaration name="leadBlock" type="int" line="480"/>
                    <scope line="483"/>
                </scope>
            </method>
            <declaration name="BMP_INDEX_LENGTH_" type="int" line="499"/>
            <javadoc line="499">
                Size of the stage 1 BMP indexes                
            </javadoc>
            <declaration name="LEAD_SURROGATE_MIN_VALUE_" type="int" line="504"/>
            <javadoc line="504">
                Lead surrogate minimum value                
            </javadoc>
            <declaration name="TRAIL_SURROGATE_MIN_VALUE_" type="int" line="508"/>
            <javadoc line="508">
                Trail surrogate minimum value                
            </javadoc>
            <declaration name="TRAIL_SURROGATE_COUNT_" type="int" line="512"/>
            <javadoc line="512">
                Number of trail surrogate                
            </javadoc>
            <declaration name="TRAIL_SURROGATE_INDEX_BLOCK_LENGTH_" type="int" line="516"/>
            <javadoc line="516">
                Number of stage 1 indexes for supplementary calculations that maps to
                  each lead surrogate character.
                  See second pass into getRawOffset for the trail surrogate character.
                  10 for significant number of bits for trail surrogates, 5 for what we
                  discard during shifting.                
            </javadoc>
            <declaration name="DATA_BLOCK_LENGTH_" type="int" line="525"/>
            <javadoc line="525">
                Number of data values in a stage 2 (data array) block.                
            </javadoc>
            <declaration name="m_trie_" type="Trie" line="530"/>
            <javadoc line="530">
                Trie instance                
            </javadoc>
            <declaration name="m_initialValue_" type="int" line="534"/>
            <javadoc line="534">
                Initial value for trie values                
            </javadoc>
            <declaration name="m_currentCodepoint_" type="int" line="538"/>
            <javadoc line="538">
                Next element results and data.                
            </javadoc>
            <declaration name="m_nextCodepoint_" type="int" line="542"/>
            <declaration name="m_nextValue_" type="int" line="543"/>
            <declaration name="m_nextIndex_" type="int" line="544"/>
            <declaration name="m_nextBlock_" type="int" line="545"/>
            <declaration name="m_nextBlockIndex_" type="int" line="546"/>
            <declaration name="m_nextTrailIndexOffset_" type="int" line="547"/>
        </class>
    </source>