<?xml version="1.0" encoding="UTF-8"?>
    <source package="sun.text.normalizer">
        <import package="java.text.ParsePosition"/>
        <import package="java.util.Iterator"/>
        <import package="java.util.TreeSet"/>
        <class name="UnicodeSet" line="43">
            <comment line="279">
                LOW &lt;= all valid values. ZERO for codepoints                
            </comment>
            <comment line="280">
                HIGH &gt; all valid values. 10000 for code units.                
            </comment>
            <comment line="281">
                110000 for codepoints                
            </comment>
            <comment line="295">
                length used; list may be longer to minimize reallocs                
            </comment>
            <comment line="296">
                MUST be terminated with HIGH                
            </comment>
            <comment line="297">
                internal buffer                
            </comment>
            <comment line="298">
                internal buffer                
            </comment>
            <comment line="300">
                NOTE: normally the field should be of type SortedSet; but that is missing a public clone!!                
            </comment>
            <comment line="301">
                is not private so that UnicodeSetIterator can get access                
            </comment>
            <comment line="315">
                initial storage. Must be &gt;= 0                
            </comment>
            <comment line="316">
                extra amount for growth. Must be &gt;= 0                
            </comment>
            <comment line="326">
                ----------------------------------------------------------------                
            </comment>
            <comment line="327">
                Public API                
            </comment>
            <comment line="328">
                ----------------------------------------------------------------                
            </comment>
            <comment line="538">
                for internal use, after checkFrozen has been called                
            </comment>
            <comment line="564">
                for internal use only, after checkFrozen has been called                
            </comment>
            <comment line="899">
                ----------------------------------------------------------------                
            </comment>
            <comment line="900">
                Implementation: Pattern parsing                
            </comment>
            <comment line="901">
                ----------------------------------------------------------------                
            </comment>
            <comment line="1322">
                ----------------------------------------------------------------                
            </comment>
            <comment line="1323">
                Implementation: Utility methods                
            </comment>
            <comment line="1324">
                ----------------------------------------------------------------                
            </comment>
            <comment line="1351">
                ----------------------------------------------------------------                
            </comment>
            <comment line="1352">
                Implementation: Fundamental operations                
            </comment>
            <comment line="1353">
                ----------------------------------------------------------------                
            </comment>
            <comment line="1355">
                polarity = 0, 3 is normal: x xor y                
            </comment>
            <comment line="1356">
                polarity = 1, 2: x xor ~y == x === y                
            </comment>
            <comment line="1399">
                polarity = 0 is normal: x union y                
            </comment>
            <comment line="1400">
                polarity = 2: x union ~y                
            </comment>
            <comment line="1401">
                polarity = 1: ~x union y                
            </comment>
            <comment line="1402">
                polarity = 3: ~x union ~y                
            </comment>
            <comment line="1497">
                polarity = 0 is normal: x intersect y                
            </comment>
            <comment line="1498">
                polarity = 2: x intersect ~y == set-minus                
            </comment>
            <comment line="1499">
                polarity = 1: ~x intersect y                
            </comment>
            <comment line="1500">
                polarity = 3: ~x intersect ~y                
            </comment>
            <comment line="1572">
                ----------------------------------------------------------------                
            </comment>
            <comment line="1573">
                Generic filter-based scanning code                
            </comment>
            <comment line="1574">
                ----------------------------------------------------------------                
            </comment>
            <comment line="1580">
                VersionInfo for unassigned characters                
            </comment>
            <comment line="1851">
                ----------------------------------------------------------------                
            </comment>
            <comment line="1852">
                Case folding API                
            </comment>
            <comment line="1853">
                ----------------------------------------------------------------                
            </comment>
            <implements interface="UnicodeMatcher"/>
            <javadoc line="43">
                A mutable set of Unicode characters and multicharacter strings.  Objects of this class
                  represent &lt;em&gt;character classes&lt;/em&gt; used in regular expressions.
                  A character specifies a subset of Unicode code points.  Legal
                  code points are U+0000 to U+10FFFF, inclusive.
                  &lt;p&gt;The UnicodeSet class is not designed to be subclassed.
                  &lt;p&gt;&lt;code&gt;UnicodeSet&lt;/code&gt; supports two APIs. The first is the
                  &lt;em&gt;operand&lt;/em&gt; API that allows the caller to modify the value of
                  a &lt;code&gt;UnicodeSet&lt;/code&gt; object. It conforms to Java 2&apos;s
                  &lt;code&gt;java.util.Set&lt;/code&gt; interface, although
                  &lt;code&gt;UnicodeSet&lt;/code&gt; does not actually implement that
                  interface. All methods of &lt;code&gt;Set&lt;/code&gt; are supported, with the
                  modification that they take a character range or single character
                  instead of an &lt;code&gt;Object&lt;/code&gt;, and they take a
                  &lt;code&gt;UnicodeSet&lt;/code&gt; instead of a &lt;code&gt;Collection&lt;/code&gt;.  The
                  operand API may be thought of in terms of boolean logic: a boolean
                  OR is implemented by &lt;code&gt;add&lt;/code&gt;, a boolean AND is implemented
                  by &lt;code&gt;retain&lt;/code&gt;, a boolean XOR is implemented by
                  &lt;code&gt;complement&lt;/code&gt; taking an argument, and a boolean NOT is
                  implemented by &lt;code&gt;complement&lt;/code&gt; with no argument.  In terms
                  of traditional set theory function names, &lt;code&gt;add&lt;/code&gt; is a
                  union, &lt;code&gt;retain&lt;/code&gt; is an intersection, &lt;code&gt;remove&lt;/code&gt;
                  is an asymmetric difference, and &lt;code&gt;complement&lt;/code&gt; with no
                  argument is a set complement with respect to the superset range
                  &lt;code&gt;MIN_VALUE-MAX_VALUE&lt;/code&gt;
                  &lt;p&gt;The second API is the
                  &lt;code&gt;applyPattern()&lt;/code&gt;/&lt;code&gt;toPattern()&lt;/code&gt; API from the
                  &lt;code&gt;java.text.Format&lt;/code&gt;-derived classes.  Unlike the
                  methods that add characters, add categories, and control the logic
                  of the set, the method &lt;code&gt;applyPattern()&lt;/code&gt; sets all
                  attributes of a &lt;code&gt;UnicodeSet&lt;/code&gt; at once, based on a
                  string pattern.
                  &lt;p&gt;&lt;b&gt;Pattern syntax&lt;/b&gt;&lt;/p&gt;
                  Patterns are accepted by the constructors and the
                  &lt;code&gt;applyPattern()&lt;/code&gt; methods and returned by the
                  &lt;code&gt;toPattern()&lt;/code&gt; method.  These patterns follow a syntax
                  similar to that employed by version 8 regular expression character
                  classes.  Here are some simple examples:
                  &lt;blockquote&gt;
                  &lt;table&gt;
                  &lt;tr align=&quot;top&quot;&gt;
                  &lt;td nowrap valign=&quot;top&quot; align=&quot;left&quot;&gt;&lt;code&gt;[]&lt;/code&gt;&lt;/td&gt;
                  &lt;td valign=&quot;top&quot;&gt;No characters&lt;/td&gt;
                  &lt;/tr&gt;&lt;tr align=&quot;top&quot;&gt;
                  &lt;td nowrap valign=&quot;top&quot; align=&quot;left&quot;&gt;&lt;code&gt;[a]&lt;/code&gt;&lt;/td&gt;
                  &lt;td valign=&quot;top&quot;&gt;The character &apos;a&apos;&lt;/td&gt;
                  &lt;/tr&gt;&lt;tr align=&quot;top&quot;&gt;
                  &lt;td nowrap valign=&quot;top&quot; align=&quot;left&quot;&gt;&lt;code&gt;[ae]&lt;/code&gt;&lt;/td&gt;
                  &lt;td valign=&quot;top&quot;&gt;The characters &apos;a&apos; and &apos;e&apos;&lt;/td&gt;
                  &lt;/tr&gt;
                  &lt;tr&gt;
                  &lt;td nowrap valign=&quot;top&quot; align=&quot;left&quot;&gt;&lt;code&gt;[a-e]&lt;/code&gt;&lt;/td&gt;
                  &lt;td valign=&quot;top&quot;&gt;The characters &apos;a&apos; through &apos;e&apos; inclusive, in Unicode code
                  point order&lt;/td&gt;
                  &lt;/tr&gt;
                  &lt;tr&gt;
                  &lt;td nowrap valign=&quot;top&quot; align=&quot;left&quot;&gt;&lt;code&gt;[\\u4E01]&lt;/code&gt;&lt;/td&gt;
                  &lt;td valign=&quot;top&quot;&gt;The character U+4E01&lt;/td&gt;
                  &lt;/tr&gt;
                  &lt;tr&gt;
                  &lt;td nowrap valign=&quot;top&quot; align=&quot;left&quot;&gt;&lt;code&gt;[a{ab}{ac}]&lt;/code&gt;&lt;/td&gt;
                  &lt;td valign=&quot;top&quot;&gt;The character &apos;a&apos; and the multicharacter strings &amp;quot;ab&amp;quot; and
                  &amp;quot;ac&amp;quot;&lt;/td&gt;
                  &lt;/tr&gt;
                  &lt;tr&gt;
                  &lt;td nowrap valign=&quot;top&quot; align=&quot;left&quot;&gt;&lt;code&gt;[\p{Lu}]&lt;/code&gt;&lt;/td&gt;
                  &lt;td valign=&quot;top&quot;&gt;All characters in the general category Uppercase Letter&lt;/td&gt;
                  &lt;/tr&gt;
                  &lt;/table&gt;
                  &lt;/blockquote&gt;
                  Any character may be preceded by a backslash in order to remove any special
                  meaning.  White space characters, as defined by UCharacterProperty.isRuleWhiteSpace(), are
                  ignored, unless they are escaped.
                  &lt;p&gt;Property patterns specify a set of characters having a certain
                  property as defined by the Unicode standard.  Both the POSIX-like
                  &quot;[:Lu:]&quot; and the Perl-like syntax &quot;\p{Lu}&quot; are recognized.  For a
                  complete list of supported property patterns, see the User&apos;s Guide
                  for UnicodeSet at
                  &lt;a href=&quot;http://www.icu-project.org/userguide/unicodeSet.html&quot;&gt;
                  http://www.icu-project.org/userguide/unicodeSet.html&lt;/a&gt;.
                  Actual determination of property data is defined by the underlying
                  Unicode database as implemented by UCharacter.
                  &lt;p&gt;Patterns specify individual characters, ranges of characters, and
                  Unicode property sets.  When elements are concatenated, they
                  specify their union.  To complement a set, place a &apos;^&apos; immediately
                  after the opening &apos;[&apos;.  Property patterns are inverted by modifying
                  their delimiters; &quot;[:^foo]&quot; and &quot;\P{foo}&quot;.  In any other location,
                  &apos;^&apos; has no special meaning.
                  &lt;p&gt;Ranges are indicated by placing two a &apos;-&apos; between two
                  characters, as in &quot;a-z&quot;.  This specifies the range of all
                  characters from the left to the right, in Unicode order.  If the
                  left character is greater than or equal to the
                  right character it is a syntax error.  If a &apos;-&apos; occurs as the first
                  character after the opening &apos;[&apos; or &apos;[^&apos;, or if it occurs as the
                  last character before the closing &apos;]&apos;, then it is taken as a
                  literal.  Thus &quot;[a\\-b]&quot;, &quot;[-ab]&quot;, and &quot;[ab-]&quot; all indicate the same
                  set of three characters, &apos;a&apos;, &apos;b&apos;, and &apos;-&apos;.
                  &lt;p&gt;Sets may be intersected using the &apos;&amp;&apos; operator or the asymmetric
                  set difference may be taken using the &apos;-&apos; operator, for example,
                  &quot;[[:L:]&amp;[\\u0000-\\u0FFF]]&quot; indicates the set of all Unicode letters
                  with values less than 4096.  Operators (&apos;&amp;&apos; and &apos;|&apos;) have equal
                  precedence and bind left-to-right.  Thus
                  &quot;[[:L:]-[a-z]-[\\u0100-\\u01FF]]&quot; is equivalent to
                  &quot;[[[:L:]-[a-z]]-[\\u0100-\\u01FF]]&quot;.  This only really matters for
                  difference; intersection is commutative.
                  &lt;table&gt;
                  &lt;tr valign=top&gt;&lt;td nowrap&gt;&lt;code&gt;[a]&lt;/code&gt;&lt;td&gt;The set containing &apos;a&apos;
                  &lt;tr valign=top&gt;&lt;td nowrap&gt;&lt;code&gt;[a-z]&lt;/code&gt;&lt;td&gt;The set containing &apos;a&apos;
                  through &apos;z&apos; and all letters in between, in Unicode order
                  &lt;tr valign=top&gt;&lt;td nowrap&gt;&lt;code&gt;[^a-z]&lt;/code&gt;&lt;td&gt;The set containing
                  all characters but &apos;a&apos; through &apos;z&apos;,
                  that is, U+0000 through &apos;a&apos;-1 and &apos;z&apos;+1 through U+10FFFF
                  &lt;tr valign=top&gt;&lt;td nowrap&gt;&lt;code&gt;[[&lt;em&gt;pat1&lt;/em&gt;][&lt;em&gt;pat2&lt;/em&gt;]]&lt;/code&gt;
                  &lt;td&gt;The union of sets specified by &lt;em&gt;pat1&lt;/em&gt; and &lt;em&gt;pat2&lt;/em&gt;
                  &lt;tr valign=top&gt;&lt;td nowrap&gt;&lt;code&gt;[[&lt;em&gt;pat1&lt;/em&gt;]&amp;[&lt;em&gt;pat2&lt;/em&gt;]]&lt;/code&gt;
                  &lt;td&gt;The intersection of sets specified by &lt;em&gt;pat1&lt;/em&gt; and &lt;em&gt;pat2&lt;/em&gt;
                  &lt;tr valign=top&gt;&lt;td nowrap&gt;&lt;code&gt;[[&lt;em&gt;pat1&lt;/em&gt;]-[&lt;em&gt;pat2&lt;/em&gt;]]&lt;/code&gt;
                  &lt;td&gt;The asymmetric difference of sets specified by &lt;em&gt;pat1&lt;/em&gt; and
                  &lt;em&gt;pat2&lt;/em&gt;
                  &lt;tr valign=top&gt;&lt;td nowrap&gt;&lt;code&gt;[:Lu:] or \p{Lu}&lt;/code&gt;
                  &lt;td&gt;The set of characters having the specified
                  Unicode property; in
                  this case, Unicode uppercase letters
                  &lt;tr valign=top&gt;&lt;td nowrap&gt;&lt;code&gt;[:^Lu:] or \P{Lu}&lt;/code&gt;
                  &lt;td&gt;The set of characters &lt;em&gt;not&lt;/em&gt; having the given
                  Unicode property
                  &lt;/table&gt;
                  &lt;p&gt;&lt;b&gt;Warning&lt;/b&gt;: you cannot add an empty string (&quot;&quot;) to a UnicodeSet.&lt;/p&gt;
                  &lt;p&gt;&lt;b&gt;Formal syntax&lt;/b&gt;&lt;/p&gt;
                  &lt;blockquote&gt;
                  &lt;table&gt;
                  &lt;tr align=&quot;top&quot;&gt;
                  &lt;td nowrap valign=&quot;top&quot; align=&quot;right&quot;&gt;&lt;code&gt;pattern :=&amp;nbsp; &lt;/code&gt;&lt;/td&gt;
                  &lt;td valign=&quot;top&quot;&gt;&lt;code&gt;(&apos;[&apos; &apos;^&apos;? item &apos;]&apos;) |
                  property&lt;/code&gt;&lt;/td&gt;
                  &lt;/tr&gt;
                  &lt;tr align=&quot;top&quot;&gt;
                  &lt;td nowrap valign=&quot;top&quot; align=&quot;right&quot;&gt;&lt;code&gt;item :=&amp;nbsp; &lt;/code&gt;&lt;/td&gt;
                  &lt;td valign=&quot;top&quot;&gt;&lt;code&gt;char | (char &apos;-&apos; char) | pattern-expr&lt;br&gt;
                  &lt;/code&gt;&lt;/td&gt;
                  &lt;/tr&gt;
                  &lt;tr align=&quot;top&quot;&gt;
                  &lt;td nowrap valign=&quot;top&quot; align=&quot;right&quot;&gt;&lt;code&gt;pattern-expr :=&amp;nbsp; &lt;/code&gt;&lt;/td&gt;
                  &lt;td valign=&quot;top&quot;&gt;&lt;code&gt;pattern | pattern-expr pattern |
                  pattern-expr op pattern&lt;br&gt;
                  &lt;/code&gt;&lt;/td&gt;
                  &lt;/tr&gt;
                  &lt;tr align=&quot;top&quot;&gt;
                  &lt;td nowrap valign=&quot;top&quot; align=&quot;right&quot;&gt;&lt;code&gt;op :=&amp;nbsp; &lt;/code&gt;&lt;/td&gt;
                  &lt;td valign=&quot;top&quot;&gt;&lt;code&gt;&apos;&amp;amp;&apos; | &apos;-&apos;&lt;br&gt;
                  &lt;/code&gt;&lt;/td&gt;
                  &lt;/tr&gt;
                  &lt;tr align=&quot;top&quot;&gt;
                  &lt;td nowrap valign=&quot;top&quot; align=&quot;right&quot;&gt;&lt;code&gt;special :=&amp;nbsp; &lt;/code&gt;&lt;/td&gt;
                  &lt;td valign=&quot;top&quot;&gt;&lt;code&gt;&apos;[&apos; | &apos;]&apos; | &apos;-&apos;&lt;br&gt;
                  &lt;/code&gt;&lt;/td&gt;
                  &lt;/tr&gt;
                  &lt;tr align=&quot;top&quot;&gt;
                  &lt;td nowrap valign=&quot;top&quot; align=&quot;right&quot;&gt;&lt;code&gt;char :=&amp;nbsp; &lt;/code&gt;&lt;/td&gt;
                  &lt;td valign=&quot;top&quot;&gt;&lt;em&gt;any character that is not&lt;/em&gt;&lt;code&gt; special&lt;br&gt;
                  | (&apos;\\&apos; &lt;/code&gt;&lt;em&gt;any character&lt;/em&gt;&lt;code&gt;)&lt;br&gt;
                  | (&apos;&amp;#92;u&apos; hex hex hex hex)&lt;br&gt;
                  &lt;/code&gt;&lt;/td&gt;
                  &lt;/tr&gt;
                  &lt;tr align=&quot;top&quot;&gt;
                  &lt;td nowrap valign=&quot;top&quot; align=&quot;right&quot;&gt;&lt;code&gt;hex :=&amp;nbsp; &lt;/code&gt;&lt;/td&gt;
                  &lt;td valign=&quot;top&quot;&gt;&lt;em&gt;any character for which
                  &lt;/em&gt;&lt;code&gt;Character.digit(c, 16)&lt;/code&gt;&lt;em&gt;
                  returns a non-negative result&lt;/em&gt;&lt;/td&gt;
                  &lt;/tr&gt;
                  &lt;tr&gt;
                  &lt;td nowrap valign=&quot;top&quot; align=&quot;right&quot;&gt;&lt;code&gt;property :=&amp;nbsp; &lt;/code&gt;&lt;/td&gt;
                  &lt;td valign=&quot;top&quot;&gt;&lt;em&gt;a Unicode property set pattern&lt;/td&gt;
                  &lt;/tr&gt;
                  &lt;/table&gt;
                  &lt;br&gt;
                  &lt;table border=&quot;1&quot;&gt;
                  &lt;tr&gt;
                  &lt;td&gt;Legend: &lt;table&gt;
                  &lt;tr&gt;
                  &lt;td nowrap valign=&quot;top&quot;&gt;&lt;code&gt;a := b&lt;/code&gt;&lt;/td&gt;
                  &lt;td width=&quot;20&quot; valign=&quot;top&quot;&gt;&amp;nbsp; &lt;/td&gt;
                  &lt;td valign=&quot;top&quot;&gt;&lt;code&gt;a&lt;/code&gt; may be replaced by &lt;code&gt;b&lt;/code&gt; &lt;/td&gt;
                  &lt;/tr&gt;
                  &lt;tr&gt;
                  &lt;td nowrap valign=&quot;top&quot;&gt;&lt;code&gt;a?&lt;/code&gt;&lt;/td&gt;
                  &lt;td valign=&quot;top&quot;&gt;&lt;/td&gt;
                  &lt;td valign=&quot;top&quot;&gt;zero or one instance of &lt;code&gt;a&lt;/code&gt;&lt;br&gt;
                  &lt;/td&gt;
                  &lt;/tr&gt;
                  &lt;tr&gt;
                  &lt;td nowrap valign=&quot;top&quot;&gt;&lt;code&gt;a&lt;/code&gt;&lt;/td&gt;
                  &lt;td valign=&quot;top&quot;&gt;&lt;/td&gt;
                  &lt;td valign=&quot;top&quot;&gt;one or more instances of &lt;code&gt;a&lt;/code&gt;&lt;br&gt;
                  &lt;/td&gt;
                  &lt;/tr&gt;
                  &lt;tr&gt;
                  &lt;td nowrap valign=&quot;top&quot;&gt;&lt;code&gt;a | b&lt;/code&gt;&lt;/td&gt;
                  &lt;td valign=&quot;top&quot;&gt;&lt;/td&gt;
                  &lt;td valign=&quot;top&quot;&gt;either &lt;code&gt;a&lt;/code&gt; or &lt;code&gt;b&lt;/code&gt;&lt;br&gt;
                  &lt;/td&gt;
                  &lt;/tr&gt;
                  &lt;tr&gt;
                  &lt;td nowrap valign=&quot;top&quot;&gt;&lt;code&gt;&apos;a&apos;&lt;/code&gt;&lt;/td&gt;
                  &lt;td valign=&quot;top&quot;&gt;&lt;/td&gt;
                  &lt;td valign=&quot;top&quot;&gt;the literal string between the quotes &lt;/td&gt;
                  &lt;/tr&gt;
                  &lt;/table&gt;
                  &lt;/td&gt;
                  &lt;/tr&gt;
                  &lt;/table&gt;
                  &lt;/blockquote&gt;
                  &lt;p&gt;To iterate over contents of UnicodeSet, use UnicodeSetIterator class.                
                <author>
                    Alan Liu                    
                </author>
                <stable>
                    ICU 2.0                    
                </stable>
                <see>
                    UnicodeSetIterator                    
                </see>
            </javadoc>
            <declaration name="LOW" type="int" line="278"/>
            <declaration name="HIGH" type="int" line="279"/>
            <declaration name="MIN_VALUE" type="int" line="282"/>
            <javadoc line="282">
                Minimum value that can be stored in a UnicodeSet.                
                <stable>
                    ICU 2.0                    
                </stable>
            </javadoc>
            <declaration name="MAX_VALUE" type="int" line="288"/>
            <javadoc line="288">
                Maximum value that can be stored in a UnicodeSet.                
                <stable>
                    ICU 2.0                    
                </stable>
            </javadoc>
            <declaration name="len" type="int" line="294"/>
            <declaration name="list" type="int[]" line="295"/>
            <declaration name="rangeList" type="int[]" line="296"/>
            <declaration name="buffer" type="int[]" line="297"/>
            <declaration name="strings" type="TreeSet" line="301"/>
            <declaration name="pat" type="String" line="303"/>
            <javadoc line="303">
                The pattern representation of this set.  This may not be the
                  most economical pattern.  It is the pattern supplied to
                  applyPattern(), with variables substituted and whitespace
                  removed.  For sets constructed without applyPattern(), or
                  modified using the non-pattern API, this string will be null,
                  indicating that toPattern() must generate a pattern
                  representation from the inversion list.                
            </javadoc>
            <declaration name="START_EXTRA" type="int" line="314"/>
            <declaration name="GROW_EXTRA" type="int" line="315"/>
            <declaration name="INCLUSIONS" type="UnicodeSet" line="317"/>
            <javadoc line="317">
                A set of all characters _except_ the second through last characters of
                  certain ranges.  These ranges are ranges of characters whose
                  properties are all exactly alike, e.g. CJK Ideographs from
                  U+4E00 to U+9FA5.                
            </javadoc>
            <javadoc line="329">
                Constructs an empty set.                
                <stable>
                    ICU 2.0                    
                </stable>
            </javadoc>
            <method name="UnicodeSet" type="constructor" line="333"/>
            <javadoc line="338">
                Constructs a set containing the given range. If &lt;code&gt;end &gt;
                  start&lt;/code&gt; then an empty set is created.                
                <param>
                    start first character, inclusive, of range                    
                </param>
                <param>
                    end last character, inclusive, of range                    
                </param>
                <stable>
                    ICU 2.0                    
                </stable>
            </javadoc>
            <method name="UnicodeSet" type="constructor" line="346">
                <params>
                    <param name="start" type="int"/>
                    <param name="end" type="int"/>
                </params>
            </method>
            <javadoc line="351">
                Constructs a set from the given pattern.  See the class description
                  for the syntax of the pattern language.  Whitespace is ignored.                
                <param>
                    pattern a string specifying what characters are in the set                    
                </param>
                <exception>
                    java.lang.IllegalArgumentException if the pattern contains
                      a syntax error.                    
                </exception>
                <stable>
                    ICU 2.0                    
                </stable>
            </javadoc>
            <method name="UnicodeSet" type="constructor" line="359">
                <params>
                    <param name="pattern" type="String"/>
                </params>
            </method>
            <javadoc line="364">
                Make this object represent the same set as &lt;code&gt;other&lt;/code&gt;.                
                <param>
                    other a <code>UnicodeSet</code> whose value will be
                      copied to this object                    
                </param>
                <stable>
                    ICU 2.0                    
                </stable>
            </javadoc>
            <method name="set" type="UnicodeSet" line="370">
                <params>
                    <param name="other" type="UnicodeSet"/>
                </params>
            </method>
            <javadoc line="378">
                Modifies this set to represent the set specified by the given pattern.
                  See the class description for the syntax of the pattern language.
                  Whitespace is ignored.                
                <param>
                    pattern a string specifying what characters are in the set                    
                </param>
                <exception>
                    java.lang.IllegalArgumentException if the pattern
                      contains a syntax error.                    
                </exception>
                <stable>
                    ICU 2.0                    
                </stable>
            </javadoc>
            <method name="applyPattern" type="UnicodeSet" line="387">
                <params>
                    <param name="pattern" type="String"/>
                </params>
            </method>
            <javadoc line="391">
                Append the &lt;code&gt;toPattern()&lt;/code&gt; representation of a
                  string to the given &lt;code&gt;StringBuffer&lt;/code&gt;.                
            </javadoc>
            <method name="_appendToPat" type="void" line="395">
                <params>
                    <param name="buf" type="StringBuffer"/>
                    <param name="s" type="String"/>
                    <param name="escapeUnprintable" type="boolean"/>
                </params>
                <scope line="396"/>
            </method>
            <javadoc line="401">
                Append the &lt;code&gt;toPattern()&lt;/code&gt; representation of a
                  character to the given &lt;code&gt;StringBuffer&lt;/code&gt;.                
            </javadoc>
            <method name="_appendToPat" type="void" line="405">
                <params>
                    <param name="buf" type="StringBuffer"/>
                    <param name="c" type="int"/>
                    <param name="escapeUnprintable" type="boolean"/>
                </params>
                <comment line="407">
                    Use hex escape notation (&lt;backslash&gt;uxxxx or &lt;backslash&gt;Uxxxxxxxx) for anything                    
                </comment>
                <comment line="408">
                    unprintable                    
                </comment>
                <comment line="413">
                    Okay to let &apos;:&apos; pass through                    
                </comment>
                <comment line="415">
                    SET_OPEN:                    
                </comment>
                <comment line="416">
                    SET_CLOSE:                    
                </comment>
                <comment line="417">
                    HYPHEN:                    
                </comment>
                <comment line="418">
                    COMPLEMENT:                    
                </comment>
                <comment line="419">
                    INTERSECTION:                    
                </comment>
                <comment line="420">
                    BACKSLASH:                    
                </comment>
                <comment line="428">
                    Escape whitespace                    
                </comment>
                <scope line="406">
                    <scope line="409"/>
                </scope>
                <scope line="429"/>
            </method>
            <javadoc line="437">
                Append a string representation of this set to result.  This will be
                  a cleaned version of the string passed to applyPattern(), if there
                  is one.  Otherwise it will be generated.                
            </javadoc>
            <method name="_toPattern" type="StringBuffer" line="443">
                <params>
                    <param name="result" type="StringBuffer"/>
                    <param name="escapeUnprintable" type="boolean"/>
                </params>
                <comment line="451">
                    If the unprintable character is preceded by an odd                    
                </comment>
                <comment line="452">
                    number of backslashes, then it has been escaped.                    
                </comment>
                <comment line="453">
                    Before unescaping it, we delete the final                    
                </comment>
                <comment line="454">
                    backslash.                    
                </comment>
                <scope line="444">
                    <declaration name="i" type="int" line="445"/>
                    <declaration name="backslashCount" type="int" line="446"/>
                    <scope line="447">
                        <declaration name="c" type="int" line="448"/>
                        <scope line="450">
                            <scope line="455"/>
                        </scope>
                        <scope line="460">
                            <scope line="462"/>
                            <scope line="464"/>
                        </scope>
                    </scope>
                </scope>
            </method>
            <javadoc line="475">
                Generate and append a string representation of this set to result.
                  This does not use this.pat, the cleaned up copy of the string
                  passed to applyPattern().                
                <param>
                    includeStrings if false, doesn't include the strings.                    
                </param>
                <stable>
                    ICU 3.8                    
                </stable>
            </javadoc>
            <method name="_generatePattern" type="StringBuffer" line="483">
                <params>
                    <param name="result" type="StringBuffer"/>
                    <param name="escapeUnprintable" type="boolean"/>
                    <param name="includeStrings" type="boolean"/>
                </params>
                <comment line="488">
                    If the set contains at least 2 intervals and includes both                    
                </comment>
                <comment line="489">
                    MIN_VALUE and MAX_VALUE, then the inverse representation will                    
                </comment>
                <comment line="490">
                    be more economical.                    
                </comment>
                <comment line="495">
                    Emit the inverse                    
                </comment>
                <comment line="511">
                    Default; emit the ranges as pairs                    
                </comment>
                <declaration name="count" type="int" line="486"/>
                <scope line="493">
                    <scope line="498">
                        <declaration name="start" type="int" line="499"/>
                        <declaration name="end" type="int" line="500"/>
                        <scope line="502">
                            <scope line="503"/>
                        </scope>
                    </scope>
                </scope>
                <scope line="512">
                    <scope line="513">
                        <declaration name="start" type="int" line="514"/>
                        <declaration name="end" type="int" line="515"/>
                        <scope line="517">
                            <scope line="518"/>
                        </scope>
                    </scope>
                </scope>
                <scope line="526">
                    <declaration name="it" type="Iterator" line="527"/>
                    <scope line="528"/>
                </scope>
            </method>
            <method name="add_unchecked" type="UnicodeSet" line="538">
                <params>
                    <param name="start" type="int"/>
                    <param name="end" type="int"/>
                </params>
                <scope line="539"/>
                <scope line="542"/>
                <scope line="545"/>
                <scope line="547"/>
            </method>
            <javadoc line="553">
                Adds the specified character to this set if it is not already
                  present.  If this set already contains the specified character,
                  the call leaves this set unchanged.                
                <stable>
                    ICU 2.0                    
                </stable>
            </javadoc>
            <method name="add" type="UnicodeSet" line="559">
                <params>
                    <param name="c" type="int"/>
                </params>
            </method>
            <method name="add_unchecked" type="UnicodeSet" line="564">
                <params>
                    <param name="c" type="int"/>
                </params>
                <comment line="569">
                    find smallest i such that c &lt; list[i]                    
                </comment>
                <comment line="570">
                    if odd, then it is IN the set                    
                </comment>
                <comment line="571">
                    if even, then it is OUT of the set                    
                </comment>
                <comment line="574">
                    already in set?                    
                </comment>
                <comment line="577">
                    HIGH is 0x110000                    
                </comment>
                <comment line="578">
                    assert(list[len-1] == HIGH);                    
                </comment>
                <comment line="580">
                    empty = [HIGH]                    
                </comment>
                <comment line="581">
                    [start_0, limit_0, start_1, limit_1, HIGH]                    
                </comment>
                <comment line="583">
                    [..., start_k-1, limit_k-1, start_k, limit_k, ..., HIGH]                    
                </comment>
                <comment line="584">
                    ^                    
                </comment>
                <comment line="585">
                    list[i]                    
                </comment>
                <comment line="587">
                    i == 0 means c is before the first range                    
                </comment>
                <comment line="590">
                    c is before start of next range                    
                </comment>
                <comment line="592">
                    if we touched the HIGH mark, then add a new one                    
                </comment>
                <comment line="598">
                    collapse adjacent ranges                    
                </comment>
                <comment line="600">
                    [..., start_k-1, c, c, limit_k, ..., HIGH]                    
                </comment>
                <comment line="601">
                    ^                    
                </comment>
                <comment line="602">
                    list[i]                    
                </comment>
                <comment line="609">
                    c is after end of prior range                    
                </comment>
                <comment line="611">
                    no need to chcek for collapse here                    
                </comment>
                <comment line="615">
                    At this point we know the new char is not adjacent to                    
                </comment>
                <comment line="616">
                    any existing ranges, and it is not 10FFFF.                    
                </comment>
                <comment line="619">
                    [..., start_k-1, limit_k-1, start_k, limit_k, ..., HIGH]                    
                </comment>
                <comment line="620">
                    ^                    
                </comment>
                <comment line="621">
                    list[i]                    
                </comment>
                <comment line="623">
                    [..., start_k-1, limit_k-1, c, c+1, start_k, limit_k, ..., HIGH]                    
                </comment>
                <comment line="624">
                    ^                    
                </comment>
                <comment line="625">
                    list[i]                    
                </comment>
                <comment line="627">
                    Don&apos;t use ensureCapacity() to save on copying.                    
                </comment>
                <comment line="628">
                    NOTE: This has no measurable impact on performance,                    
                </comment>
                <comment line="629">
                    but it might help in some usage patterns.                    
                </comment>
                <scope line="565"/>
                <declaration name="i" type="int" line="572"/>
                <scope line="589">
                    <scope line="593"/>
                    <scope line="597"/>
                </scope>
                <scope line="608"/>
                <scope line="614">
                    <scope line="630">
                        <declaration name="temp" type="int[]" line="631"/>
                    </scope>
                    <scope line="635"/>
                </scope>
            </method>
            <javadoc line="648">
                Adds the specified multicharacter to this set if it is not already
                  present.  If this set already contains the multicharacter,
                  the call leaves this set unchanged.
                  Thus &quot;ch&quot; =&gt; {&quot;ch&quot;}
                  &lt;br&gt;&lt;b&gt;Warning: you cannot add an empty string (&quot;&quot;) to a UnicodeSet.&lt;/b&gt;                
                <param>
                    s the source string                    
                </param>
                <return>
                    this object, for chaining                    
                </return>
                <stable>
                    ICU 2.0                    
                </stable>
            </javadoc>
            <method name="add" type="UnicodeSet" line="658">
                <params>
                    <param name="s" type="String"/>
                </params>
                <declaration name="cp" type="int" line="659"/>
                <scope line="660"/>
                <scope line="663"/>
            </method>
            <javadoc line="669">
                @return a code point IF the string consists of a single one.
                  otherwise returns -1.                
                <param>
                    string to test                    
                </param>
            </javadoc>
            <method name="getSingleCP" type="int" line="674">
                <params>
                    <param name="s" type="String"/>
                </params>
                <comment line="681">
                    at this point, len = 2                    
                </comment>
                <comment line="683">
                    is surrogate pair                    
                </comment>
                <scope line="675"/>
                <declaration name="cp" type="int" line="682"/>
                <scope line="683"/>
            </method>
            <javadoc line="689">
                Complements the specified range in this set.  Any character in
                  the range will be removed if it is in this set, or will be
                  added if it is not in this set.  If &lt;code&gt;end &gt; start&lt;/code&gt;
                  then an empty range is complemented, leaving the set unchanged.                
                <param>
                    start first character, inclusive, of range to be removed
                      from this set.                    
                </param>
                <param>
                    end last character, inclusive, of range to be removed
                      from this set.                    
                </param>
                <stable>
                    ICU 2.0                    
                </stable>
            </javadoc>
            <method name="complement" type="UnicodeSet" line="701">
                <params>
                    <param name="start" type="int"/>
                    <param name="end" type="int"/>
                </params>
                <scope line="702"/>
                <scope line="705"/>
                <scope line="708"/>
            </method>
            <javadoc line="715">
                This is equivalent to
                  &lt;code&gt;complement(MIN_VALUE, MAX_VALUE)&lt;/code&gt;.                
                <stable>
                    ICU 2.0                    
                </stable>
            </javadoc>
            <method name="complement" type="UnicodeSet" line="720">
                <scope line="721"/>
                <scope line="724"/>
            </method>
            <javadoc line="734">
                Returns true if this set contains the given character.                
                <param>
                    c character to be checked for containment                    
                </param>
                <return>
                    true if the test condition is met                    
                </return>
                <stable>
                    ICU 2.0                    
                </stable>
            </javadoc>
            <method name="contains" type="boolean" line="740">
                <params>
                    <param name="c" type="int"/>
                </params>
                <comment line="745">
                    Set i to the index of the start item greater than ch
                     We know we will terminate without length test!
                    int i = -1;
                    while (true) {
                    if (c &lt; list[++i]) break;
                    }                    
                </comment>
                <comment line="756">
                    return true if odd                    
                </comment>
                <scope line="741"/>
                <declaration name="i" type="int" line="754"/>
            </method>
            <javadoc line="759">
                Returns the smallest value i such that c &lt; list[i].  Caller
                  must ensure that c is a legal value or this method will enter
                  an infinite loop.  This method performs a binary search.                
                <param>
                    c a character in the range MIN_VALUE..MAX_VALUE
                      inclusive                    
                </param>
                <return>
                    the smallest integer i in the range 0..len-1,
                      inclusive, such that c < list[i]                    
                </return>
            </javadoc>
            <method name="findCodePoint" type="int" line="768">
                <params>
                    <param name="c" type="int"/>
                </params>
                <comment line="769">
                    Examples:
                    findCodePoint(c)
                    set              list[]         c=0 1 3 4 7 8
                    ===              ==============   ===========
                    []               [110000]         0 0 0 0 0 0
                    [\u0000-\u0003]  [0, 4, 110000]   1 1 1 2 2 2
                    [\u0004-\u0007]  [4, 8, 110000]   0 0 0 1 1 2
                    [:all:]          [0, 110000]      1 1 1 1 1 1                    
                </comment>
                <comment line="779">
                    Return the smallest i such that c &lt; list[i].  Assume                    
                </comment>
                <comment line="780">
                    list[len - 1] == HIGH and that c is legal (0..HIGH-1).                    
                </comment>
                <comment line="782">
                    High runner test.  c is often after the last range, so an                    
                </comment>
                <comment line="783">
                    initial check for this condition pays off.                    
                </comment>
                <comment line="787">
                    invariant: c &gt;= list[lo]                    
                </comment>
                <comment line="788">
                    invariant: c &lt; list[hi]                    
                </comment>
                <declaration name="lo" type="int" line="785"/>
                <declaration name="hi" type="int" line="786"/>
                <scope line="789">
                    <declaration name="i" type="int" line="790"/>
                    <scope line="792"/>
                    <scope line="794"/>
                </scope>
            </method>
            <javadoc line="800">
                Adds all of the elements in the specified set to this set if
                  they&apos;re not already present.  This operation effectively
                  modifies this set so that its value is the &lt;i&gt;union&lt;/i&gt; of the two
                  sets.  The behavior of this operation is unspecified if the specified
                  collection is modified while the operation is in progress.                
                <param>
                    c set whose elements are to be added to this set.                    
                </param>
                <stable>
                    ICU 2.0                    
                </stable>
            </javadoc>
            <method name="addAll" type="UnicodeSet" line="810">
                <params>
                    <param name="c" type="UnicodeSet"/>
                </params>
            </method>
            <javadoc line="816">
                Retains only the elements in this set that are contained in the
                  specified set.  In other words, removes from this set all of
                  its elements that are not contained in the specified set.  This
                  operation effectively modifies this set so that its value is
                  the &lt;i&gt;intersection&lt;/i&gt; of the two sets.                
                <param>
                    c set that defines which elements this set will retain.                    
                </param>
                <stable>
                    ICU 2.0                    
                </stable>
            </javadoc>
            <method name="retainAll" type="UnicodeSet" line="826">
                <params>
                    <param name="c" type="UnicodeSet"/>
                </params>
            </method>
            <javadoc line="832">
                Removes from this set all of its elements that are contained in the
                  specified set.  This operation effectively modifies this
                  set so that its value is the &lt;i&gt;asymmetric set difference&lt;/i&gt; of
                  the two sets.                
                <param>
                    c set that defines which elements will be removed from
                      this set.                    
                </param>
                <stable>
                    ICU 2.0                    
                </stable>
            </javadoc>
            <method name="removeAll" type="UnicodeSet" line="842">
                <params>
                    <param name="c" type="UnicodeSet"/>
                </params>
            </method>
            <javadoc line="848">
                Removes all of the elements from this set.  This set will be
                  empty after this call returns.                
                <stable>
                    ICU 2.0                    
                </stable>
            </javadoc>
            <method name="clear" type="UnicodeSet" line="853"/>
            <javadoc line="861">
                Iteration method that returns the number of ranges contained in
                  this set.                
                <see>
                    #getRangeStart                    
                </see>
                <see>
                    #getRangeEnd                    
                </see>
                <stable>
                    ICU 2.0                    
                </stable>
            </javadoc>
            <method name="getRangeCount" type="int" line="868"/>
            <javadoc line="872">
                Iteration method that returns the first character in the
                  specified range of this set.                
                <exception>
                    ArrayIndexOutOfBoundsException if index is outside
                      the range <code>0..getRangeCount()-1</code>                    
                </exception>
                <see>
                    #getRangeCount                    
                </see>
                <see>
                    #getRangeEnd                    
                </see>
                <stable>
                    ICU 2.0                    
                </stable>
            </javadoc>
            <method name="getRangeStart" type="int" line="881">
                <params>
                    <param name="index" type="int"/>
                </params>
            </method>
            <javadoc line="885">
                Iteration method that returns the last character in the
                  specified range of this set.                
                <exception>
                    ArrayIndexOutOfBoundsException if index is outside
                      the range <code>0..getRangeCount()-1</code>                    
                </exception>
                <see>
                    #getRangeStart                    
                </see>
                <see>
                    #getRangeEnd                    
                </see>
                <stable>
                    ICU 2.0                    
                </stable>
            </javadoc>
            <method name="getRangeEnd" type="int" line="894">
                <params>
                    <param name="index" type="int"/>
                </params>
            </method>
            <javadoc line="902">
                Parses the given pattern, starting at the given position.  The character
                  at pattern.charAt(pos.getIndex()) must be &apos;[&apos;, or the parse fails.
                  Parsing continues until the corresponding closing &apos;]&apos;.  If a syntax error
                  is encountered between the opening and closing brace, the parse fails.
                  Upon return from a successful parse, the ParsePosition is updated to
                  point to the character following the closing &apos;]&apos;, and an inversion
                  list for the parsed pattern is returned.  This method
                  calls itself recursively to parse embedded subpatterns.                
                <param>
                    pattern the string containing the pattern to be parsed.  The
                      portion of the string from pos.getIndex(), which must be a '[', to the
                      corresponding closing ']', is parsed.                    
                </param>
                <param>
                    pos upon entry, the position at which to being parsing.  The
                      character at pattern.charAt(pos.getIndex()) must be a '['.  Upon return
                      from a successful parse, pos.getIndex() is either the character after the
                      closing ']' of the parsed pattern, or pattern.length() if the closing ']'
                      is the last character of the pattern string.                    
                </param>
                <return>
                    an inversion list for the parsed substring
                      of <code>pattern</code>                    
                </return>
                <exception>
                    java.lang.IllegalArgumentException if the parse fails.                    
                </exception>
            </javadoc>
            <method name="applyPattern" type="UnicodeSet" line="927">
                <params>
                    <param name="pattern" type="String"/>
                    <param name="pos" type="ParsePosition"/>
                    <param name="symbols" type="SymbolTable"/>
                    <param name="options" type="int"/>
                </params>
                <comment line="929">
                    Need to build the pattern in a temporary string because                    
                </comment>
                <comment line="930">
                    _applyPattern calls add() etc., which set pat to empty.                    
                </comment>
                <comment line="947">
                    Skip over trailing whitespace                    
                </comment>
                <declaration name="parsePositionWasNull" type="boolean" line="931"/>
                <scope line="932"/>
                <declaration name="rebuiltPat" type="StringBuffer" line="936"/>
                <declaration name="chars" type="RuleCharacterIterator" line="937"/>
                <scope line="940"/>
                <scope line="944">
                    <declaration name="i" type="int" line="945"/>
                    <scope line="948"/>
                    <scope line="952"/>
                </scope>
            </method>
            <javadoc line="960">
                Parse the pattern from the given RuleCharacterIterator.  The
                  iterator is advanced over the parsed pattern.                
                <param>
                    chars iterator over the pattern characters.  Upon return
                      it will be advanced to the first character after the parsed
                      pattern, or the end of the iteration if all characters are
                      parsed.                    
                </param>
                <param>
                    symbols symbol table to use to parse and dereference
                      variables, or null if none.                    
                </param>
                <param>
                    rebuiltPat the pattern that was parsed, rebuilt or
                      copied from the input pattern, as appropriate.                    
                </param>
                <param>
                    options a bit mask of zero or more of the following:
                      IGNORE_SPACE, CASE.                    
                </param>
            </javadoc>
            <method name="applyPattern" type="void" line="975">
                <params>
                    <param name="chars" type="RuleCharacterIterator"/>
                    <param name="symbols" type="SymbolTable"/>
                    <param name="rebuiltPat" type="StringBuffer"/>
                    <param name="options" type="int"/>
                </params>
                <comment line="976">
                    Syntax characters: [ ] ^ - &amp; { }                    
                </comment>
                <comment line="978">
                    Recognized special forms for chars, sets: c-c s-s s&amp;s                    
                </comment>
                <comment line="991">
                    mode: 0=before [, 1=between [...], 2=after ]                    
                </comment>
                <comment line="992">
                    lastItem: 0=none, 1=char, 2=set                    
                </comment>
                <comment line="1002">
                    Debugging assertion                    
                </comment>
                <comment line="1014">
                    -------- Check for property pattern                    
                </comment>
                <comment line="1016">
                    setMode: 0=none, 1=unicodeset, 2=propertypat, 3=preparsed                    
                </comment>
                <comment line="1022">
                    -------- Parse &apos;[&apos; of opening delimiter OR nested set.                    
                </comment>
                <comment line="1023">
                    If there is a nested set, use `setMode&apos; to define how                    
                </comment>
                <comment line="1024">
                    the set should be parsed.  If the &apos;[&apos; is part of the                    
                </comment>
                <comment line="1025">
                    opening delimiter for this pattern, parse special                    
                </comment>
                <comment line="1026">
                    strings &quot;[&quot;, &quot;[^&quot;, &quot;[-&quot;, and &quot;[^-&quot;.  Check for stand-in                    
                </comment>
                <comment line="1027">
                    characters representing a nested set in the symbol                    
                </comment>
                <comment line="1028">
                    table.                    
                </comment>
                <comment line="1031">
                    Prepare to backup if necessary                    
                </comment>
                <comment line="1038">
                    backup                    
                </comment>
                <comment line="1041">
                    Handle opening &apos;[&apos; delimiter                    
                </comment>
                <comment line="1044">
                    prepare to backup                    
                </comment>
                <comment line="1050">
                    prepare to backup                    
                </comment>
                <comment line="1054">
                    Fall through to handle special leading &apos;-&apos;;                    
                </comment>
                <comment line="1055">
                    otherwise restart loop for nested [], \p{}, etc.                    
                </comment>
                <comment line="1058">
                    Fall through to handle literal &apos;-&apos; below                    
                </comment>
                <comment line="1060">
                    backup                    
                </comment>
                <comment line="1065">
                    may be null                    
                </comment>
                <comment line="1077">
                    -------- Handle a nested set.  This either is inline in                    
                </comment>
                <comment line="1078">
                    the pattern or represented by a stand-in that has                    
                </comment>
                <comment line="1079">
                    previously been parsed and was looked up in the symbol                    
                </comment>
                <comment line="1080">
                    table.                    
                </comment>
                <comment line="1108">
                    `nested&apos; already parsed                    
                </comment>
                <comment line="1116">
                    Entire pattern is a category; leave parse loop                    
                </comment>
                <comment line="1144">
                    -------- Parse special (syntax) characters.  If the                    
                </comment>
                <comment line="1145">
                    current character is not special, or if it is escaped,                    
                </comment>
                <comment line="1146">
                    then fall through and handle it below.                    
                </comment>
                <comment line="1155">
                    Treat final trailing &apos;-&apos; as a literal                    
                </comment>
                <comment line="1171">
                    Treat final trailing &apos;-&apos; as a literal                    
                </comment>
                <comment line="1218">
                    We have new string. Add it to set and continue;                    
                </comment>
                <comment line="1219">
                    we don&apos;t need to drop through to the further                    
                </comment>
                <comment line="1220">
                    processing                    
                </comment>
                <comment line="1227">
                    symbols  nosymbols                    
                </comment>
                <comment line="1228">
                    [a-$]   error    error (ambiguous)                    
                </comment>
                <comment line="1229">
                    [a$]    anchor   anchor                    
                </comment>
                <comment line="1230">
                    [a-$x]  var &quot;x&quot;* literal &apos;$&apos;                    
                </comment>
                <comment line="1231">
                    [a-$.]  error    literal &apos;$&apos;                    
                </comment>
                <comment line="1232">
                    *We won&apos;t get here in the case of var &quot;x&quot;                    
                </comment>
                <comment line="1240">
                    literal &apos;$&apos;                    
                </comment>
                <comment line="1259">
                    -------- Parse literal characters.  This includes both                    
                </comment>
                <comment line="1260">
                    escaped chars (&quot;\u4E01&quot;) and non-syntax characters                    
                </comment>
                <comment line="1261">
                    (&quot;a&quot;).                    
                </comment>
                <comment line="1271">
                    Don&apos;t allow redundant (a-a) or empty (b-a) ranges;                    
                </comment>
                <comment line="1272">
                    these are most likely typos.                    
                </comment>
                <comment line="1306">
                    Use the rebuilt pattern (pat) only if necessary.  Prefer the                    
                </comment>
                <comment line="1307">
                    generated pattern.                    
                </comment>
                <declaration name="opts" type="int" line="980"/>
                <scope line="982"/>
                <declaration name="patBuf" type="StringBuffer" line="986"/>
                <declaration name="usePat" type="boolean" line="987"/>
                <declaration name="scratch" type="UnicodeSet" line="988"/>
                <declaration name="backup" type="Object" line="989"/>
                <declaration name="lastItem" type="int" line="993"/>
                <declaration name="op" type="char" line="994"/>
                <declaration name="invert" type="boolean" line="996"/>
                <scope line="1000">
                    <scope line="1001">
                        <scope line="1005"/>
                    </scope>
                    <declaration name="c" type="int" line="1010"/>
                    <declaration name="literal" type="boolean" line="1011"/>
                    <declaration name="nested" type="UnicodeSet" line="1012"/>
                    <declaration name="setMode" type="int" line="1017"/>
                    <scope line="1018"/>
                    <scope line="1030">
                        <scope line="1036">
                            <scope line="1037"/>
                            <scope line="1040">
                                <scope line="1047"/>
                                <scope line="1056"/>
                                <scope line="1059"/>
                            </scope>
                        </scope>
                        <scope line="1064">
                            <declaration name="m" type="UnicodeMatcher" line="1065"/>
                            <scope line="1066">
                                <scope line="1067"/>
                                <scope line="1070"/>
                            </scope>
                        </scope>
                    </scope>
                    <scope line="1082">
                        <scope line="1083">
                            <scope line="1084"/>
                        </scope>
                        <scope line="1092"/>
                        <scope line="1096"/>
                        <scope line="1115"/>
                    </scope>
                    <scope line="1140"/>
                    <scope line="1148">
                        <scope line="1151"/>
                        <scope line="1156"/>
                        <scope line="1159"/>
                        <scope line="1166">
                            <scope line="1167"/>
                            <scope line="1170">
                                <scope line="1175"/>
                            </scope>
                        </scope>
                        <scope line="1184"/>
                        <scope line="1192"/>
                        <scope line="1195"/>
                        <scope line="1200"/>
                        <scope line="1202"/>
                        <declaration name="ok" type="boolean" line="1205"/>
                        <scope line="1206">
                            <scope line="1209"/>
                        </scope>
                        <scope line="1215"/>
                        <declaration name="anchor" type="boolean" line="1236"/>
                        <scope line="1237"/>
                        <scope line="1242">
                            <scope line="1243"/>
                        </scope>
                    </scope>
                    <scope line="1269">
                        <scope line="1270"/>
                    </scope>
                    <scope line="1280"/>
                    <scope line="1287"/>
                </scope>
                <scope line="1296"/>
                <scope line="1302"/>
                <scope line="1308"/>
                <scope line="1310"/>
            </method>
            <method name="syntaxError" type="void" line="1315">
                <params>
                    <param name="chars" type="RuleCharacterIterator"/>
                    <param name="msg" type="String"/>
                </params>
            </method>
            <method name="ensureCapacity" type="void" line="1325">
                <params>
                    <param name="newLen" type="int"/>
                </params>
                <declaration name="temp" type="int[]" line="1327"/>
            </method>
            <method name="ensureBufferCapacity" type="void" line="1332">
                <params>
                    <param name="newLen" type="int"/>
                </params>
            </method>
            <javadoc line="1337">
                Assumes start &lt;= end.                
            </javadoc>
            <method name="range" type="int[]" line="1340">
                <params>
                    <param name="start" type="int"/>
                    <param name="end" type="int"/>
                </params>
                <scope line="1341"/>
                <scope line="1343"/>
            </method>
            <method name="xor" type="UnicodeSet" line="1357">
                <params>
                    <param name="other" type="int[]"/>
                    <param name="otherLen" type="int"/>
                    <param name="polarity" type="int"/>
                </params>
                <comment line="1364">
                    skip base if already LOW                    
                </comment>
                <comment line="1371">
                    simplest of all the routines                    
                </comment>
                <comment line="1372">
                    sort the values, discarding identicals!                    
                </comment>
                <comment line="1380">
                    at this point, a == b                    
                </comment>
                <comment line="1381">
                    discard both values!                    
                </comment>
                <comment line="1384">
                    DONE!                    
                </comment>
                <comment line="1390">
                    swap list and buffer                    
                </comment>
                <declaration name="i" type="int" line="1359"/>
                <declaration name="a" type="int" line="1360"/>
                <declaration name="b" type="int" line="1361"/>
                <scope line="1362">
                    <scope line="1364"/>
                </scope>
                <scope line="1368"/>
                <scope line="1373">
                    <scope line="1374"/>
                    <scope line="1377"/>
                    <scope line="1380"/>
                    <scope line="1384"/>
                </scope>
                <declaration name="temp" type="int[]" line="1391"/>
            </method>
            <method name="add" type="UnicodeSet" line="1403">
                <params>
                    <param name="other" type="int[]"/>
                    <param name="otherLen" type="int"/>
                    <param name="polarity" type="int"/>
                </params>
                <comment line="1408">
                    change from xor is that we have to check overlapping pairs                    
                </comment>
                <comment line="1409">
                    polarity bit 1 means a is second, bit 2 means b is.                    
                </comment>
                <comment line="1413">
                    both first; take lower if unequal                    
                </comment>
                <comment line="1414">
                    take a                    
                </comment>
                <comment line="1415">
                    Back up over overlapping ranges in buffer[]                    
                </comment>
                <comment line="1417">
                    Pick latter end value in buffer[] vs. list[]                    
                </comment>
                <comment line="1420">
                    No overlap                    
                </comment>
                <comment line="1424">
                    Common if/else code factored out                    
                </comment>
                <comment line="1426">
                    take b                    
                </comment>
                <comment line="1435">
                    a == b, take a, drop b                    
                </comment>
                <comment line="1437">
                    This is symmetrical; it doesn&apos;t matter if                    
                </comment>
                <comment line="1438">
                    we backtrack with a or b. - liu                    
                </comment>
                <comment line="1442">
                    No overlap                    
                </comment>
                <comment line="1451">
                    both second; take higher if unequal, and drop other                    
                </comment>
                <comment line="1452">
                    take a                    
                </comment>
                <comment line="1455">
                    take b                    
                </comment>
                <comment line="1459">
                    factored common code                    
                </comment>
                <comment line="1462">
                    a second, b first; if b &lt; a, overlap                    
                </comment>
                <comment line="1463">
                    no overlap, take a                    
                </comment>
                <comment line="1465">
                    OVERLAP, drop b                    
                </comment>
                <comment line="1467">
                    a == b, drop both!                    
                </comment>
                <comment line="1473">
                    a first, b second; if a &lt; b, overlap                    
                </comment>
                <comment line="1474">
                    no overlap, take b                    
                </comment>
                <comment line="1476">
                    OVERLAP, drop a                    
                </comment>
                <comment line="1478">
                    a == b, drop both!                    
                </comment>
                <comment line="1486">
                    terminate                    
                </comment>
                <comment line="1488">
                    swap list and buffer                    
                </comment>
                <declaration name="i" type="int" line="1405"/>
                <declaration name="a" type="int" line="1406"/>
                <declaration name="b" type="int" line="1407"/>
                <scope line="1411">
                    <scope line="1414">
                        <scope line="1416"/>
                        <scope line="1419"/>
                    </scope>
                    <scope line="1426">
                        <scope line="1427"/>
                        <scope line="1429"/>
                    </scope>
                    <scope line="1435">
                        <scope line="1439"/>
                        <scope line="1441"/>
                    </scope>
                    <scope line="1452"/>
                    <scope line="1455"/>
                    <scope line="1463"/>
                    <scope line="1465"/>
                    <scope line="1467"/>
                    <scope line="1474"/>
                    <scope line="1476"/>
                    <scope line="1478"/>
                </scope>
                <declaration name="temp" type="int[]" line="1489"/>
            </method>
            <method name="retain" type="UnicodeSet" line="1501">
                <params>
                    <param name="other" type="int[]"/>
                    <param name="otherLen" type="int"/>
                    <param name="polarity" type="int"/>
                </params>
                <comment line="1506">
                    change from xor is that we have to check overlapping pairs                    
                </comment>
                <comment line="1507">
                    polarity bit 1 means a is second, bit 2 means b is.                    
                </comment>
                <comment line="1511">
                    both first; drop the smaller                    
                </comment>
                <comment line="1512">
                    drop a                    
                </comment>
                <comment line="1514">
                    drop b                    
                </comment>
                <comment line="1516">
                    a == b, take one, drop other                    
                </comment>
                <comment line="1522">
                    both second; take lower if unequal                    
                </comment>
                <comment line="1523">
                    take a                    
                </comment>
                <comment line="1525">
                    take b                    
                </comment>
                <comment line="1527">
                    a == b, take one, drop other                    
                </comment>
                <comment line="1533">
                    a second, b first;                    
                </comment>
                <comment line="1534">
                    NO OVERLAP, drop a                    
                </comment>
                <comment line="1536">
                    OVERLAP, take b                    
                </comment>
                <comment line="1538">
                    a == b, drop both!                    
                </comment>
                <comment line="1544">
                    a first, b second; if a &lt; b, overlap                    
                </comment>
                <comment line="1545">
                    no overlap, drop b                    
                </comment>
                <comment line="1547">
                    OVERLAP, take a                    
                </comment>
                <comment line="1549">
                    a == b, drop both!                    
                </comment>
                <comment line="1557">
                    terminate                    
                </comment>
                <comment line="1559">
                    swap list and buffer                    
                </comment>
                <declaration name="i" type="int" line="1503"/>
                <declaration name="a" type="int" line="1504"/>
                <declaration name="b" type="int" line="1505"/>
                <scope line="1509">
                    <scope line="1512"/>
                    <scope line="1514"/>
                    <scope line="1516"/>
                    <scope line="1523"/>
                    <scope line="1525"/>
                    <scope line="1527"/>
                    <scope line="1534"/>
                    <scope line="1536"/>
                    <scope line="1538"/>
                    <scope line="1545"/>
                    <scope line="1547"/>
                    <scope line="1549"/>
                </scope>
                <declaration name="temp" type="int[]" line="1560"/>
            </method>
            <method name="max" type="int" line="1567">
                <params>
                    <param name="a" type="int"/>
                    <param name="b" type="int"/>
                </params>
            </method>
            <interface name="Filter">
                <method name="contains" type="boolean" line="1576"/>
            </interface>
            <declaration name="NO_VERSION" type="VersionInfo" line="1580"/>
            <class name="VersionFilter" line="1582">
                <implements interface="Filter"/>
                <declaration name="version" type="VersionInfo" line="1583"/>
                <method name="VersionFilter" type="constructor" line="1585">
                    <params>
                        <param name="version" type="VersionInfo"/>
                    </params>
                </method>
                <method name="contains" type="boolean" line="1587">
                    <params>
                        <param name="ch" type="int"/>
                    </params>
                    <comment line="1589">
                        Reference comparison ok; VersionInfo caches and reuses                        
                    </comment>
                    <comment line="1590">
                        unique objects.                        
                    </comment>
                    <declaration name="v" type="VersionInfo" line="1588"/>
                </method>
            </class>
            <method name="getInclusions" type="UnicodeSet" line="1596">
                <params>
                    <param name="src" type="int"/>
                </params>
                <scope line="1597"/>
                <scope line="1600">
                    <declaration name="incl" type="UnicodeSet" line="1601"/>
                </scope>
            </method>
            <javadoc line="1614">
                Generic filter-based scanning code for UCD property UnicodeSets.                
            </javadoc>
            <method name="applyFilter" type="UnicodeSet" line="1617">
                <params>
                    <param name="filter" type="Filter"/>
                    <param name="src" type="int"/>
                </params>
                <comment line="1618">
                    Walk through all Unicode characters, noting the start                    
                </comment>
                <comment line="1619">
                    and end of each range for which filter.contain(c) is                    
                </comment>
                <comment line="1620">
                    true.  Add each range to a set.                    
                </comment>
                <comment line="1621">
                                        
                </comment>
                <comment line="1622">
                    To improve performance, use the INCLUSIONS set, which                    
                </comment>
                <comment line="1623">
                    encodes information about character ranges that are known                    
                </comment>
                <comment line="1624">
                    to have identical properties, such as the CJK Ideographs                    
                </comment>
                <comment line="1625">
                    from U+4E00 to U+9FA5.  INCLUSIONS contains all characters                    
                </comment>
                <comment line="1626">
                    except the first characters of such ranges.                    
                </comment>
                <comment line="1627">
                                        
                </comment>
                <comment line="1628">
                    TODO Where possible, instead of scanning over code points,                    
                </comment>
                <comment line="1629">
                    use internal property data to initialize UnicodeSets for                    
                </comment>
                <comment line="1630">
                    those properties.  Scanning code points is slow.                    
                </comment>
                <comment line="1639">
                    get current range                    
                </comment>
                <comment line="1643">
                    for all the code points in the range, process                    
                </comment>
                <comment line="1645">
                    only add to the unicodeset on inflection points --                    
                </comment>
                <comment line="1646">
                    where the hasProperty value changes to false                    
                </comment>
                <declaration name="startHasProperty" type="int" line="1634"/>
                <declaration name="inclusions" type="UnicodeSet" line="1635"/>
                <declaration name="limitRange" type="int" line="1636"/>
                <scope line="1638">
                    <declaration name="start" type="int" line="1640"/>
                    <declaration name="end" type="int" line="1641"/>
                    <scope line="1644">
                        <scope line="1647">
                            <scope line="1648"/>
                        </scope>
                        <scope line="1651"/>
                    </scope>
                </scope>
                <scope line="1657"/>
            </method>
            <javadoc line="1664">
                Remove leading and trailing rule white space and compress
                  internal rule white space to a single space character.                
                <see>
                    UCharacterProperty#isRuleWhiteSpace                    
                </see>
            </javadoc>
            <method name="mungeCharName" type="String" line="1670">
                <params>
                    <param name="source" type="String"/>
                </params>
                <comment line="1680">
                    convert to &apos; &apos;                    
                </comment>
                <declaration name="buf" type="StringBuffer" line="1671"/>
                <scope line="1672">
                    <declaration name="ch" type="int" line="1673"/>
                    <scope line="1675">
                        <scope line="1677"/>
                    </scope>
                </scope>
                <scope line="1685"/>
            </method>
            <javadoc line="1691">
                Modifies this set to contain those code points which have the
                  given value for the given property.  Prior contents of this
                  set are lost.                
                <param>
                    propertyAlias                    
                </param>
                <param>
                    valueAlias                    
                </param>
                <param>
                    symbols if not null, then symbols are first called to see if a property
                      is available. If true, then everything else is skipped.                    
                </param>
                <return>
                    this set                    
                </return>
                <stable>
                    ICU 3.2                    
                </stable>
            </javadoc>
            <method name="applyPropertyAlias" type="UnicodeSet" line="1703">
                <params>
                    <param name="propertyAlias" type="String"/>
                    <param name="valueAlias" type="String"/>
                    <param name="symbols" type="SymbolTable"/>
                </params>
                <comment line="1706">
                    Must munge name, since                    
                </comment>
                <comment line="1707">
                    VersionInfo.getInstance() does not do                    
                </comment>
                <comment line="1708">
                    &apos;loose&apos; matching.                    
                </comment>
                <scope line="1704">
                    <scope line="1705">
                        <declaration name="version" type="VersionInfo" line="1709"/>
                    </scope>
                </scope>
            </method>
            <javadoc line="1717">
                Return true if the given iterator appears to point at a
                  property pattern.  Regardless of the result, return with the
                  iterator unchanged.                
                <param>
                    chars iterator over the pattern characters.  Upon return
                      it will be unchanged.                    
                </param>
                <param>
                    iterOpts RuleCharacterIterator options                    
                </param>
            </javadoc>
            <method name="resemblesPropertyPattern" type="boolean" line="1726">
                <params>
                    <param name="chars" type="RuleCharacterIterator"/>
                    <param name="iterOpts" type="int"/>
                </params>
                <declaration name="result" type="boolean" line="1727"/>
                <declaration name="pos" type="Object" line="1729"/>
                <declaration name="c" type="int" line="1730"/>
                <scope line="1731">
                    <declaration name="d" type="int" line="1732"/>
                </scope>
            </method>
            <javadoc line="1740">
                Parse the given property pattern at the given parse position.                
                <param>
                    symbols TODO                    
                </param>
            </javadoc>
            <method name="applyPropertyPattern" type="UnicodeSet" line="1744">
                <params>
                    <param name="pattern" type="String"/>
                    <param name="ppos" type="ParsePosition"/>
                    <param name="symbols" type="SymbolTable"/>
                </params>
                <comment line="1747">
                    On entry, ppos should point to one of the following locations:                    
                </comment>
                <comment line="1749">
                    Minimum length is 5 characters, e.g. \p{L}                    
                </comment>
                <comment line="1754">
                    true for [:pat:], false for \p{pat} \P{pat} \N{pat}                    
                </comment>
                <comment line="1755">
                    true for \N{pat}, o/w false                    
                </comment>
                <comment line="1758">
                    Look for an opening [:, [:^, \p, or \P                    
                </comment>
                <comment line="1773">
                    Syntax error; &quot;\p&quot; or &quot;\P&quot; not followed by &quot;{&quot;                    
                </comment>
                <comment line="1777">
                    Open delimiter not seen                    
                </comment>
                <comment line="1781">
                    Look for the matching close delimiter, either :] or }                    
                </comment>
                <comment line="1784">
                    Syntax error; close delimiter missing                    
                </comment>
                <comment line="1788">
                    Look for an &apos;=&apos; sign.  If this is present, we will parse a                    
                </comment>
                <comment line="1789">
                    medium \p{gc=Cf} or long \p{GeneralCategory=Format}                    
                </comment>
                <comment line="1790">
                    pattern.                    
                </comment>
                <comment line="1794">
                    Equals seen; parse medium/long pattern                    
                </comment>
                <comment line="1800">
                    Handle case where no &apos;=&apos; is seen, and \N{}                    
                </comment>
                <comment line="1804">
                    Handle \N{name}                    
                </comment>
                <comment line="1806">
                    This is a little inefficient since it means we have to                    
                </comment>
                <comment line="1807">
                    parse &quot;na&quot; back to UProperty.NAME even though we already                    
                </comment>
                <comment line="1808">
                    know it&apos;s UProperty.NAME.  If we refactor the API to                    
                </comment>
                <comment line="1809">
                    support args of (int, String) then we can remove                    
                </comment>
                <comment line="1810">
                    &quot;na&quot; and make this a little more efficient.                    
                </comment>
                <comment line="1822">
                    Move to the limit position after the close delimiter                    
                </comment>
                <declaration name="pos" type="int" line="1745"/>
                <scope line="1750"/>
                <declaration name="posix" type="boolean" line="1754"/>
                <declaration name="isName" type="boolean" line="1755"/>
                <declaration name="invert" type="boolean" line="1756"/>
                <scope line="1759">
                    <scope line="1762"/>
                </scope>
                <scope line="1767">
                    <declaration name="c" type="char" line="1768"/>
                    <scope line="1772"/>
                </scope>
                <scope line="1776"/>
                <declaration name="close" type="int" line="1782"/>
                <scope line="1783"/>
                <declaration name="equals" type="int" line="1791"/>
                <declaration name="propName" type="String" line="1792"/>
                <scope line="1793"/>
                <scope line="1799">
                    <scope line="1805"/>
                </scope>
                <scope line="1818"/>
            </method>
            <javadoc line="1828">
                Parse a property pattern.                
                <param>
                    chars iterator over the pattern characters.  Upon return
                      it will be advanced to the first character after the parsed
                      pattern, or the end of the iteration if all characters are
                      parsed.                    
                </param>
                <param>
                    rebuiltPat the pattern that was parsed, rebuilt or
                      copied from the input pattern, as appropriate.                    
                </param>
                <param>
                    symbols TODO                    
                </param>
            </javadoc>
            <method name="applyPropertyPattern" type="void" line="1839">
                <params>
                    <param name="chars" type="RuleCharacterIterator"/>
                    <param name="rebuiltPat" type="StringBuffer"/>
                    <param name="symbols" type="SymbolTable"/>
                </params>
                <declaration name="patStr" type="String" line="1840"/>
                <declaration name="pos" type="ParsePosition" line="1841"/>
                <scope line="1843"/>
            </method>
            <declaration name="IGNORE_SPACE" type="int" line="1854"/>
            <javadoc line="1854">
                Bitmask for constructor and applyPattern() indicating that
                  white space should be ignored.  If set, ignore characters for
                  which UCharacterProperty.isRuleWhiteSpace() returns true,
                  unless they are quoted or escaped.  This may be ORed together
                  with other selectors.                
                <stable>
                    ICU 3.8                    
                </stable>
            </javadoc>
        </class>
    </source>