<?xml version="1.0" encoding="UTF-8"?>
    <source package="sun.text.bidi">
        <import package="java.io.IOException"/>
        <import package="java.lang.reflect.Array"/>
        <import package="java.lang.reflect.Field"/>
        <import package="java.lang.reflect.Method"/>
        <import package="java.lang.reflect.InvocationTargetException"/>
        <import package="java.text.AttributedCharacterIterator"/>
        <import package="java.text.Bidi"/>
        <import package="java.util.Arrays"/>
        <import package="java.util.MissingResourceException"/>
        <import package="sun.text.normalizer.UBiDiProps"/>
        <import package="sun.text.normalizer.UCharacter"/>
        <import package="sun.text.normalizer.UTF16"/>
        <class name="BidiBase" line="14">
            <javadoc line="14">
                &lt;h2&gt;Bidi algorithm for ICU&lt;/h2&gt;
                  This is an implementation of the Unicode Bidirectional algorithm. The
                  algorithm is defined in the &lt;a
                  href=&quot;http://www.unicode.org/unicode/reports/tr9/&quot;&gt;Unicode Standard Annex #9&lt;/a&gt;,
                  version 13, also described in The Unicode Standard, Version 4.0 .
                  &lt;p&gt;
                  Note: Libraries that perform a bidirectional algorithm and reorder strings
                  accordingly are sometimes called &quot;Storage Layout Engines&quot;. ICU&apos;s Bidi and
                  shaping (ArabicShaping) classes can be used at the core of such &quot;Storage
                  Layout Engines&quot;.
                  &lt;h3&gt;General remarks about the API:&lt;/h3&gt;
                  The &amp;quot;limit&amp;quot; of a sequence of characters is the position just after
                  their last character, i.e., one more than that position.
                  &lt;p&gt;
                  Some of the API methods provide access to &amp;quot;runs&amp;quot;. Such a
                  &amp;quot;run&amp;quot; is defined as a sequence of characters that are at the same
                  embedding level after performing the Bidi algorithm.
                  &lt;p&gt;
                  &lt;h3&gt;Basic concept: paragraph&lt;/h3&gt;
                  A piece of text can be divided into several paragraphs by characters
                  with the Bidi class &lt;code&gt;Block Separator&lt;/code&gt;. For handling of
                  paragraphs, see:
                  &lt;ul&gt;
                  &lt;li&gt;{@link #countParagraphs}&lt;li&gt;{@link #getParaLevel}&lt;li&gt;{@link #getParagraph}&lt;li&gt;{@link #getParagraphByIndex}&lt;/ul&gt;
                  &lt;h3&gt;Basic concept: text direction&lt;/h3&gt;
                  The direction of a piece of text may be:
                  &lt;ul&gt;
                  &lt;li&gt;{@link #LTR}&lt;li&gt;{@link #RTL}&lt;li&gt;{@link #MIXED}&lt;/ul&gt;
                  &lt;h3&gt;Basic concept: levels&lt;/h3&gt;
                  Levels in this API represent embedding levels according to the Unicode
                  Bidirectional Algorithm.
                  Their low-order bit (even/odd value) indicates the visual direction.&lt;p&gt;
                  Levels can be abstract values when used for the
                  &lt;code&gt;paraLevel&lt;/code&gt; and &lt;code&gt;embeddingLevels&lt;/code&gt;
                  arguments of &lt;code&gt;setPara()&lt;/code&gt;; there:
                  &lt;ul&gt;
                  &lt;li&gt;the high-order bit of an &lt;code&gt;embeddingLevels[]&lt;/code&gt;
                  value indicates whether the using application is
                  specifying the level of a character to &lt;i&gt;override&lt;/i&gt; whatever the
                  Bidi implementation would resolve it to.&lt;/li&gt;
                  &lt;li&gt;&lt;code&gt;paraLevel&lt;/code&gt; can be set to the
                  pseudo-level values &lt;code&gt;LEVEL_DEFAULT_LTR&lt;/code&gt;
                  and &lt;code&gt;LEVEL_DEFAULT_RTL&lt;/code&gt;.&lt;/li&gt;
                  &lt;/ul&gt;
                  &lt;p&gt;The related constants are not real, valid level values.
                  &lt;code&gt;DEFAULT_XXX&lt;/code&gt; can be used to specify
                  a default for the paragraph level for
                  when the &lt;code&gt;setPara()&lt;/code&gt; method
                  shall determine it but there is no
                  strongly typed character in the input.&lt;p&gt;
                  Note that the value for &lt;code&gt;LEVEL_DEFAULT_LTR&lt;/code&gt; is even
                  and the one for &lt;code&gt;LEVEL_DEFAULT_RTL&lt;/code&gt; is odd,
                  just like with normal LTR and RTL level values -
                  these special values are designed that way. Also, the implementation
                  assumes that MAX_EXPLICIT_LEVEL is odd.
                  &lt;ul&gt;&lt;b&gt;See Also:&lt;/b&gt;
                  &lt;li&gt;{@link #LEVEL_DEFAULT_LTR}&lt;li&gt;{@link #LEVEL_DEFAULT_RTL}&lt;li&gt;{@link #LEVEL_OVERRIDE}&lt;li&gt;{@link #MAX_EXPLICIT_LEVEL}&lt;li&gt;{@link #setPara}&lt;/ul&gt;
                  &lt;h3&gt;Basic concept: Reordering Mode&lt;/h3&gt;
                  Reordering mode values indicate which variant of the Bidi algorithm to
                  use.
                  &lt;ul&gt;&lt;b&gt;See Also:&lt;/b&gt;
                  &lt;li&gt;{@link #setReorderingMode}&lt;li&gt;{@link #REORDER_DEFAULT}&lt;li&gt;{@link #REORDER_NUMBERS_SPECIAL}&lt;li&gt;{@link #REORDER_GROUP_NUMBERS_WITH_R}&lt;li&gt;{@link #REORDER_RUNS_ONLY}&lt;li&gt;{@link #REORDER_INVERSE_NUMBERS_AS_L}&lt;li&gt;{@link #REORDER_INVERSE_LIKE_DIRECT}&lt;li&gt;{@link #REORDER_INVERSE_FOR_NUMBERS_SPECIAL}&lt;/ul&gt;
                  &lt;h3&gt;Basic concept: Reordering Options&lt;/h3&gt;
                  Reordering options can be applied during Bidi text transformations.
                  &lt;ul&gt;&lt;b&gt;See Also:&lt;/b&gt;
                  &lt;li&gt;{@link #setReorderingOptions}&lt;li&gt;{@link #OPTION_DEFAULT}&lt;li&gt;{@link #OPTION_INSERT_MARKS}&lt;li&gt;{@link #OPTION_REMOVE_CONTROLS}&lt;li&gt;{@link #OPTION_STREAMING}&lt;/ul&gt;                
                <author>
                    Simon Montagu, Matitiahu Allouche (ported from C code written by Markus W. Scherer)                    
                </author>
                <stable>
                    ICU 3.8
                      &lt;h4&gt; Sample code for the ICU Bidi API &lt;/h4&gt;
                      &lt;h5&gt;Rendering a paragraph with the ICU Bidi API&lt;/h5&gt;
                      This is (hypothetical) sample code that illustrates how the ICU Bidi API
                      could be used to render a paragraph of text. Rendering code depends highly on
                      the graphics system, therefore this sample code must make a lot of
                      assumptions, which may or may not match any existing graphics system&apos;s
                      properties.
                      &lt;p&gt;
                      The basic assumptions are:
                      &lt;/p&gt;
                      &lt;ul&gt;
                      &lt;li&gt;Rendering is done from left to right on a horizontal line.&lt;/li&gt;
                      &lt;li&gt;A run of single-style, unidirectional text can be rendered at once.
                      &lt;/li&gt;
                      &lt;li&gt;Such a run of text is passed to the graphics system with characters
                      (code units) in logical order.&lt;/li&gt;
                      &lt;li&gt;The line-breaking algorithm is very complicated and Locale-dependent -
                      and therefore its implementation omitted from this sample code.&lt;/li&gt;
                      &lt;/ul&gt;
                      &lt;pre&gt;
                      package com.ibm.icu.dev.test.bidi;
                      import com.ibm.icu.text.Bidi;
                      import com.ibm.icu.text.BidiRun;
                      public class Sample {
                      static final int styleNormal = 0;
                      static final int styleSelected = 1;
                      static final int styleBold = 2;
                      static final int styleItalics = 4;
                      static final int styleSuper=8;
                      static final int styleSub = 16;
                      static class StyleRun {
                      int limit;
                      int style;
                      public StyleRun(int limit, int style) {
                      this.limit = limit;
                      this.style = style;
                      }
                      }
                      static class Bounds {
                      int start;
                      int limit;
                      public Bounds(int start, int limit) {
                      this.start = start;
                      this.limit = limit;
                      }
                      }
                      static int getTextWidth(String text, int start, int limit,
                      StyleRun[] styleRuns, int styleRunCount) {
                      // simplistic way to compute the width
                      return limit - start;
                      }
                      // set limit and StyleRun limit for a line
                      // from text[start] and from styleRuns[styleRunStart]
                      // using Bidi.getLogicalRun(...)
                      // returns line width
                      static int getLineBreak(String text, Bounds line, Bidi para,
                      StyleRun styleRuns[], Bounds styleRun) {
                      // dummy return
                      return 0;
                      }
                      // render runs on a line sequentially, always from left to right
                      // prepare rendering a new line
                      static void startLine(byte textDirection, int lineWidth) {
                      System.out.println();
                      }
                      // render a run of text and advance to the right by the run width
                      // the text[start..limit-1] is always in logical order
                      static void renderRun(String text, int start, int limit,
                      byte textDirection, int style) {
                      }
                      // We could compute a cross-product
                      // from the style runs with the directional runs
                      // and then reorder it.
                      // Instead, here we iterate over each run type
                      // and render the intersections -
                      // with shortcuts in simple (and common) cases.
                      // renderParagraph() is the main function.
                      // render a directional run with
                      // (possibly) multiple style runs intersecting with it
                      static void renderDirectionalRun(String text, int start, int limit,
                      byte direction, StyleRun styleRuns[],
                      int styleRunCount) {
                      int i;
                      // iterate over style runs
                      if (direction == Bidi.LTR) {
                      int styleLimit;
                      for (i = 0; i &lt; styleRunCount; ++i) {
                      styleLimit = styleRuns[i].limit;
                      if (start &lt; styleLimit) {
                      if (styleLimit &gt; limit) {
                      styleLimit = limit;
                      }
                      renderRun(text, start, styleLimit,
                      direction, styleRuns[i].style);
                      if (styleLimit == limit) {
                      break;
                      }
                      start = styleLimit;
                      }
                      }
                      } else {
                      int styleStart;
                      for (i = styleRunCount-1; i &gt;= 0; --i) {
                      if (i &gt; 0) {
                      styleStart = styleRuns[i-1].limit;
                      } else {
                      styleStart = 0;
                      }
                      if (limit &gt;= styleStart) {
                      if (styleStart &lt; start) {
                      styleStart = start;
                      }
                      renderRun(text, styleStart, limit, direction,
                      styleRuns[i].style);
                      if (styleStart == start) {
                      break;
                      }
                      limit = styleStart;
                      }
                      }
                      }
                      }
                      // the line object represents text[start..limit-1]
                      static void renderLine(Bidi line, String text, int start, int limit,
                      StyleRun styleRuns[], int styleRunCount) {
                      byte direction = line.getDirection();
                      if (direction != Bidi.MIXED) {
                      // unidirectional
                      if (styleRunCount &lt;= 1) {
                      renderRun(text, start, limit, direction, styleRuns[0].style);
                      } else {
                      renderDirectionalRun(text, start, limit, direction,
                      styleRuns, styleRunCount);
                      }
                      } else {
                      // mixed-directional
                      int count, i;
                      BidiRun run;
                      try {
                      count = line.countRuns();
                      } catch (IllegalStateException e) {
                      e.printStackTrace();
                      return;
                      }
                      if (styleRunCount &lt;= 1) {
                      int style = styleRuns[0].style;
                      // iterate over directional runs
                      for (i = 0; i &lt; count; ++i) {
                      run = line.getVisualRun(i);
                      renderRun(text, run.getStart(), run.getLimit(),
                      run.getDirection(), style);
                      }
                      } else {
                      // iterate over both directional and style runs
                      for (i = 0; i &lt; count; ++i) {
                      run = line.getVisualRun(i);
                      renderDirectionalRun(text, run.getStart(),
                      run.getLimit(), run.getDirection(),
                      styleRuns, styleRunCount);
                      }
                      }
                      }
                      }
                      static void renderParagraph(String text, byte textDirection,
                      StyleRun styleRuns[], int styleRunCount,
                      int lineWidth) {
                      int length = text.length();
                      Bidi para = new Bidi();
                      try {
                      para.setPara(text,
                      textDirection != 0 ? Bidi.LEVEL_DEFAULT_RTL
                      : Bidi.LEVEL_DEFAULT_LTR,
                      null);
                      } catch (Exception e) {
                      e.printStackTrace();
                      return;
                      }
                      byte paraLevel = (byte)(1 &amp; para.getParaLevel());
                      StyleRun styleRun = new StyleRun(length, styleNormal);
                      if (styleRuns == null || styleRunCount &lt;= 0) {
                      styleRuns = new StyleRun[1];
                      styleRunCount = 1;
                      styleRuns[0] = styleRun;
                      }
                      // assume styleRuns[styleRunCount-1].limit&gt;=length
                      int width = getTextWidth(text, 0, length, styleRuns, styleRunCount);
                      if (width &lt;= lineWidth) {
                      // everything fits onto one line
                      // prepare rendering a new line from either left or right
                      startLine(paraLevel, width);
                      renderLine(para, text, 0, length, styleRuns, styleRunCount);
                      } else {
                      // we need to render several lines
                      Bidi line = new Bidi(length, 0);
                      int start = 0, limit;
                      int styleRunStart = 0, styleRunLimit;
                      for (;;) {
                      limit = length;
                      styleRunLimit = styleRunCount;
                      width = getLineBreak(text, new Bounds(start, limit),
                      para, styleRuns,
                      new Bounds(styleRunStart, styleRunLimit));
                      try {
                      line = para.setLine(start, limit);
                      } catch (Exception e) {
                      e.printStackTrace();
                      return;
                      }
                      // prepare rendering a new line
                      // from either left or right
                      startLine(paraLevel, width);
                      if (styleRunStart &gt; 0) {
                      int newRunCount = styleRuns.length - styleRunStart;
                      StyleRun[] newRuns = new StyleRun[newRunCount];
                      System.arraycopy(styleRuns, styleRunStart, newRuns, 0,
                      newRunCount);
                      renderLine(line, text, start, limit, newRuns,
                      styleRunLimit - styleRunStart);
                      } else {
                      renderLine(line, text, start, limit, styleRuns,
                      styleRunLimit - styleRunStart);
                      }
                      if (limit == length) {
                      break;
                      }
                      start = limit;
                      styleRunStart = styleRunLimit - 1;
                      if (start &gt;= styleRuns[styleRunStart].limit) {
                      ++styleRunStart;
                      }
                      }
                      }
                      }
                      public static void main(String[] args)
                      {
                      renderParagraph(&quot;Some Latin text...&quot;, Bidi.LTR, null, 0, 80);
                      renderParagraph(&quot;Some Hebrew text...&quot;, Bidi.RTL, null, 0, 60);
                      }
                      }
                      &lt;/pre&gt;                    
                </stable>
            </javadoc>
            <class name="Point" line="325">
                <declaration name="pos" type="int" line="326"/>
                <declaration name="flag" type="int" line="327"/>
            </class>
            <class name="InsertPoints" line="329">
                <declaration name="size" type="int" line="330"/>
                <declaration name="confirmed" type="int" line="331"/>
                <declaration name="points" type="Point[]" line="332"/>
            </class>
            <declaration name="INTERNAL_LEVEL_DEFAULT_LTR" type="byte" line="334"/>
            <javadoc line="334">
                Paragraph level setting&lt;p&gt;
                  Constant indicating that the base direction depends on the first strong
                  directional character in the text according to the Unicode Bidirectional
                  Algorithm. If no strong directional character is present,
                  then set the paragraph level to 0 (left-to-right).&lt;p&gt;
                  If this value is used in conjunction with reordering modes
                  &lt;code&gt;REORDER_INVERSE_LIKE_DIRECT&lt;/code&gt; or
                  &lt;code&gt;REORDER_INVERSE_FOR_NUMBERS_SPECIAL&lt;/code&gt;, the text to reorder
                  is assumed to be visual LTR, and the text after reordering is required
                  to be the corresponding logical string with appropriate contextual
                  direction. The direction of the result string will be RTL if either
                  the righmost or leftmost strong character of the source text is RTL
                  or Arabic Letter, the direction will be LTR otherwise.&lt;p&gt;
                  If reordering option &lt;code&gt;OPTION_INSERT_MARKS&lt;/code&gt; is set, an RLM may
                  be added at the beginning of the result string to ensure round trip
                  (that the result string, when reordered back to visual, will produce
                  the original source text).                
                <see>
                    #REORDER_INVERSE_LIKE_DIRECT                    
                </see>
                <see>
                    #REORDER_INVERSE_FOR_NUMBERS_SPECIAL                    
                </see>
                <stable>
                    ICU 3.8                    
                </stable>
            </javadoc>
            <declaration name="INTERNAL_LEVEL_DEFAULT_RTL" type="byte" line="357"/>
            <javadoc line="357">
                Paragraph level setting&lt;p&gt;
                  Constant indicating that the base direction depends on the first strong
                  directional character in the text according to the Unicode Bidirectional
                  Algorithm. If no strong directional character is present,
                  then set the paragraph level to 1 (right-to-left).&lt;p&gt;
                  If this value is used in conjunction with reordering modes
                  &lt;code&gt;REORDER_INVERSE_LIKE_DIRECT&lt;/code&gt; or
                  &lt;code&gt;REORDER_INVERSE_FOR_NUMBERS_SPECIAL&lt;/code&gt;, the text to reorder
                  is assumed to be visual LTR, and the text after reordering is required
                  to be the corresponding logical string with appropriate contextual
                  direction. The direction of the result string will be RTL if either
                  the righmost or leftmost strong character of the source text is RTL
                  or Arabic Letter, or if the text contains no strong character;
                  the direction will be LTR otherwise.&lt;p&gt;
                  If reordering option &lt;code&gt;OPTION_INSERT_MARKS&lt;/code&gt; is set, an RLM may
                  be added at the beginning of the result string to ensure round trip
                  (that the result string, when reordered back to visual, will produce
                  the original source text).                
                <see>
                    #REORDER_INVERSE_LIKE_DIRECT                    
                </see>
                <see>
                    #REORDER_INVERSE_FOR_NUMBERS_SPECIAL                    
                </see>
                <stable>
                    ICU 3.8                    
                </stable>
            </javadoc>
            <declaration name="MAX_EXPLICIT_LEVEL" type="byte" line="381"/>
            <javadoc line="381">
                Maximum explicit embedding level.
                  (The maximum resolved level can be up to &lt;code&gt;MAX_EXPLICIT_LEVEL+1&lt;/code&gt;).                
                <stable>
                    ICU 3.8                    
                </stable>
            </javadoc>
            <declaration name="INTERNAL_LEVEL_OVERRIDE" type="byte" line="387"/>
            <javadoc line="387">
                Bit flag for level input.
                  Overrides directional properties.                
                <stable>
                    ICU 3.8                    
                </stable>
            </javadoc>
            <declaration name="MAP_NOWHERE" type="int" line="393"/>
            <javadoc line="393">
                Special value which can be returned by the mapping methods when a
                  logical index has no corresponding visual index or vice-versa. This may
                  happen for the logical-to-visual mapping of a Bidi control when option
                  &lt;code&gt;OPTION_REMOVE_CONTROLS&lt;/code&gt; is
                  specified. This can also happen for the visual-to-logical mapping of a
                  Bidi mark (LRM or RLM) inserted by option
                  &lt;code&gt;OPTION_INSERT_MARKS&lt;/code&gt;.                
                <see>
                    #getVisualIndex                    
                </see>
                <see>
                    #getVisualMap                    
                </see>
                <see>
                    #getLogicalIndex                    
                </see>
                <see>
                    #getLogicalMap                    
                </see>
                <see>
                    #OPTION_INSERT_MARKS                    
                </see>
                <see>
                    #OPTION_REMOVE_CONTROLS                    
                </see>
                <stable>
                    ICU 3.8                    
                </stable>
            </javadoc>
            <declaration name="MIXED" type="byte" line="410"/>
            <javadoc line="410">
                Mixed-directional text.                
                <stable>
                    ICU 3.8                    
                </stable>
            </javadoc>
            <declaration name="DO_MIRRORING" type="short" line="415"/>
            <javadoc line="415">
                option bit for writeReordered():
                  replace characters with the &quot;mirrored&quot; property in RTL runs
                  by their mirror-image mappings                
                <see>
                    #writeReordered                    
                </see>
                <stable>
                    ICU 3.8                    
                </stable>
            </javadoc>
            <declaration name="REORDER_DEFAULT" type="short" line="423"/>
            <javadoc line="423">
                Reordering mode: Regular Logical to Visual Bidi algorithm according to Unicode.                
                <see>
                    #setReorderingMode                    
                </see>
                <stable>
                    ICU 3.8                    
                </stable>
            </javadoc>
            <declaration name="REORDER_NUMBERS_SPECIAL" type="short" line="429"/>
            <javadoc line="429">
                Reordering mode: Logical to Visual algorithm which handles numbers in
                  a way which mimicks the behavior of Windows XP.                
                <see>
                    #setReorderingMode                    
                </see>
                <stable>
                    ICU 3.8                    
                </stable>
            </javadoc>
            <declaration name="REORDER_GROUP_NUMBERS_WITH_R" type="short" line="436"/>
            <javadoc line="436">
                Reordering mode: Logical to Visual algorithm grouping numbers with
                  adjacent R characters (reversible algorithm).                
                <see>
                    #setReorderingMode                    
                </see>
                <stable>
                    ICU 3.8                    
                </stable>
            </javadoc>
            <declaration name="REORDER_RUNS_ONLY" type="short" line="443"/>
            <javadoc line="443">
                Reordering mode: Reorder runs only to transform a Logical LTR string
                  to the logical RTL string with the same display, or vice-versa.&lt;br&gt;
                  If this mode is set together with option
                  &lt;code&gt;OPTION_INSERT_MARKS&lt;/code&gt;, some Bidi controls in the source
                  text may be removed and other controls may be added to produce the
                  minimum combination which has the required display.                
                <see>
                    #OPTION_INSERT_MARKS                    
                </see>
                <see>
                    #setReorderingMode                    
                </see>
                <stable>
                    ICU 3.8                    
                </stable>
            </javadoc>
            <declaration name="REORDER_INVERSE_NUMBERS_AS_L" type="short" line="455"/>
            <javadoc line="455">
                Reordering mode: Visual to Logical algorithm which handles numbers
                  like L (same algorithm as selected by &lt;code&gt;setInverse(true)&lt;/code&gt;.                
                <see>
                    #setInverse                    
                </see>
                <see>
                    #setReorderingMode                    
                </see>
                <stable>
                    ICU 3.8                    
                </stable>
            </javadoc>
            <declaration name="REORDER_INVERSE_LIKE_DIRECT" type="short" line="463"/>
            <javadoc line="463">
                Reordering mode: Visual to Logical algorithm equivalent to the regular
                  Logical to Visual algorithm.                
                <see>
                    #setReorderingMode                    
                </see>
                <stable>
                    ICU 3.8                    
                </stable>
            </javadoc>
            <declaration name="REORDER_INVERSE_FOR_NUMBERS_SPECIAL" type="short" line="470"/>
            <javadoc line="470">
                Reordering mode: Inverse Bidi (Visual to Logical) algorithm for the
                  &lt;code&gt;REORDER_NUMBERS_SPECIAL&lt;/code&gt; Bidi algorithm.                
                <see>
                    #setReorderingMode                    
                </see>
                <stable>
                    ICU 3.8                    
                </stable>
            </javadoc>
            <declaration name="REORDER_LAST_LOGICAL_TO_VISUAL" type="short" line="477"/>
            <declaration name="OPTION_INSERT_MARKS" type="int" line="478"/>
            <javadoc line="478">
                Option bit for &lt;code&gt;setReorderingOptions&lt;/code&gt;:
                  insert Bidi marks (LRM or RLM) when needed to ensure correct result of
                  a reordering to a Logical order
                  &lt;p&gt;This option must be set or reset before calling
                  &lt;code&gt;setPara&lt;/code&gt;.&lt;/p&gt;
                  &lt;p&gt;This option is significant only with reordering modes which generate
                  a result with Logical order, specifically.&lt;/p&gt;
                  &lt;ul&gt;
                  &lt;li&gt;&lt;code&gt;REORDER_RUNS_ONLY&lt;/code&gt;&lt;/li&gt;
                  &lt;li&gt;&lt;code&gt;REORDER_INVERSE_NUMBERS_AS_L&lt;/code&gt;&lt;/li&gt;
                  &lt;li&gt;&lt;code&gt;REORDER_INVERSE_LIKE_DIRECT&lt;/code&gt;&lt;/li&gt;
                  &lt;li&gt;&lt;code&gt;REORDER_INVERSE_FOR_NUMBERS_SPECIAL&lt;/code&gt;&lt;/li&gt;
                  &lt;/ul&gt;
                  &lt;p&gt;If this option is set in conjunction with reordering mode
                  &lt;code&gt;REORDER_INVERSE_NUMBERS_AS_L&lt;/code&gt; or with calling
                  &lt;code&gt;setInverse(true)&lt;/code&gt;, it implies option
                  &lt;code&gt;INSERT_LRM_FOR_NUMERIC&lt;/code&gt; in calls to method
                  &lt;code&gt;writeReordered()&lt;/code&gt;.&lt;/p&gt;
                  &lt;p&gt;For other reordering modes, a minimum number of LRM or RLM characters
                  will be added to the source text after reordering it so as to ensure
                  round trip, i.e. when applying the inverse reordering mode on the
                  resulting logical text with removal of Bidi marks
                  (option &lt;code&gt;OPTION_REMOVE_CONTROLS&lt;/code&gt; set before calling
                  &lt;code&gt;setPara()&lt;/code&gt; or option
                  &lt;code&gt;REMOVE_BIDI_CONTROLS&lt;/code&gt; in
                  &lt;code&gt;writeReordered&lt;/code&gt;), the result will be identical to the
                  source text in the first transformation.
                  &lt;p&gt;This option will be ignored if specified together with option
                  &lt;code&gt;OPTION_REMOVE_CONTROLS&lt;/code&gt;. It inhibits option
                  &lt;code&gt;REMOVE_BIDI_CONTROLS&lt;/code&gt; in calls to method
                  &lt;code&gt;writeReordered()&lt;/code&gt; and it implies option
                  &lt;code&gt;INSERT_LRM_FOR_NUMERIC&lt;/code&gt; in calls to method
                  &lt;code&gt;writeReordered()&lt;/code&gt; if the reordering mode is
                  &lt;code&gt;REORDER_INVERSE_NUMBERS_AS_L&lt;/code&gt;.&lt;/p&gt;                
                <see>
                    #setReorderingMode                    
                </see>
                <see>
                    #setReorderingOptions                    
                </see>
                <see>
                    #INSERT_LRM_FOR_NUMERIC                    
                </see>
                <see>
                    #REMOVE_BIDI_CONTROLS                    
                </see>
                <see>
                    #OPTION_REMOVE_CONTROLS                    
                </see>
                <see>
                    #REORDER_RUNS_ONLY                    
                </see>
                <see>
                    #REORDER_INVERSE_NUMBERS_AS_L                    
                </see>
                <see>
                    #REORDER_INVERSE_LIKE_DIRECT                    
                </see>
                <see>
                    #REORDER_INVERSE_FOR_NUMBERS_SPECIAL                    
                </see>
                <stable>
                    ICU 3.8                    
                </stable>
            </javadoc>
            <declaration name="OPTION_REMOVE_CONTROLS" type="int" line="525"/>
            <javadoc line="525">
                Option bit for &lt;code&gt;setReorderingOptions&lt;/code&gt;:
                  remove Bidi control characters
                  &lt;p&gt;This option must be set or reset before calling
                  &lt;code&gt;setPara&lt;/code&gt;.&lt;/p&gt;
                  &lt;p&gt;This option nullifies option
                  &lt;code&gt;OPTION_INSERT_MARKS&lt;/code&gt;. It inhibits option
                  &lt;code&gt;INSERT_LRM_FOR_NUMERIC&lt;/code&gt; in calls to method
                  &lt;code&gt;writeReordered()&lt;/code&gt; and it implies option
                  &lt;code&gt;REMOVE_BIDI_CONTROLS&lt;/code&gt; in calls to that method.&lt;/p&gt;                
                <see>
                    #setReorderingMode                    
                </see>
                <see>
                    #setReorderingOptions                    
                </see>
                <see>
                    #OPTION_INSERT_MARKS                    
                </see>
                <see>
                    #INSERT_LRM_FOR_NUMERIC                    
                </see>
                <see>
                    #REMOVE_BIDI_CONTROLS                    
                </see>
                <stable>
                    ICU 3.8                    
                </stable>
            </javadoc>
            <declaration name="OPTION_STREAMING" type="int" line="543"/>
            <javadoc line="543">
                Option bit for &lt;code&gt;setReorderingOptions&lt;/code&gt;:
                  process the output as part of a stream to be continued
                  &lt;p&gt;This option must be set or reset before calling
                  &lt;code&gt;setPara&lt;/code&gt;.&lt;/p&gt;
                  &lt;p&gt;This option specifies that the caller is interested in processing
                  large text object in parts. The results of the successive calls are
                  expected to be concatenated by the caller. Only the call for the last
                  part will have this option bit off.&lt;/p&gt;
                  &lt;p&gt;When this option bit is on, &lt;code&gt;setPara()&lt;/code&gt; may process
                  less than the full source text in order to truncate the text at a
                  meaningful boundary. The caller should call
                  &lt;code&gt;getProcessedLength()&lt;/code&gt; immediately after calling
                  &lt;code&gt;setPara()&lt;/code&gt; in order to determine how much of the source
                  text has been processed. Source text beyond that length should be
                  resubmitted in following calls to &lt;code&gt;setPara&lt;/code&gt;. The
                  processed length may be less than the length of the source text if a
                  character preceding the last character of the source text constitutes a
                  reasonable boundary (like a block separator) for text to be continued.&lt;br&gt;
                  If the last character of the source text constitutes a reasonable
                  boundary, the whole text will be processed at once.&lt;br&gt;
                  If nowhere in the source text there exists
                  such a reasonable boundary, the processed length will be zero.&lt;br&gt;
                  The caller should check for such an occurrence and do one of the following:
                  &lt;ul&gt;&lt;li&gt;submit a larger amount of text with a better chance to include
                  a reasonable boundary.&lt;/li&gt;
                  &lt;li&gt;resubmit the same text after turning off option
                  &lt;code&gt;OPTION_STREAMING&lt;/code&gt;.&lt;/li&gt;&lt;/ul&gt;
                  In all cases, this option should be turned off before processing the last
                  part of the text.&lt;/p&gt;
                  &lt;p&gt;When the &lt;code&gt;OPTION_STREAMING&lt;/code&gt; option is used, it is
                  recommended to call &lt;code&gt;orderParagraphsLTR()&lt;/code&gt; with argument
                  &lt;code&gt;orderParagraphsLTR&lt;/code&gt; set to &lt;code&gt;true&lt;/code&gt; before calling
                  &lt;code&gt;setPara()&lt;/code&gt; so that later paragraphs may be concatenated to
                  previous paragraphs on the right.
                  &lt;/p&gt;                
                <see>
                    #setReorderingMode                    
                </see>
                <see>
                    #setReorderingOptions                    
                </see>
                <see>
                    #getProcessedLength                    
                </see>
                <see>
                    #orderParagraphsLTR                    
                </see>
                <stable>
                    ICU 3.8                    
                </stable>
            </javadoc>
            <declaration name="L" type="byte" line="586"/>
            <declaration name="R" type="byte" line="587"/>
            <declaration name="EN" type="byte" line="588"/>
            <declaration name="ES" type="byte" line="589"/>
            <declaration name="ET" type="byte" line="590"/>
            <declaration name="AN" type="byte" line="591"/>
            <declaration name="CS" type="byte" line="592"/>
            <declaration name="B" type="byte" line="593"/>
            <declaration name="S" type="byte" line="594"/>
            <declaration name="WS" type="byte" line="595"/>
            <declaration name="ON" type="byte" line="596"/>
            <declaration name="LRE" type="byte" line="597"/>
            <declaration name="LRO" type="byte" line="598"/>
            <declaration name="AL" type="byte" line="599"/>
            <declaration name="RLE" type="byte" line="600"/>
            <declaration name="RLO" type="byte" line="601"/>
            <declaration name="PDF" type="byte" line="602"/>
            <declaration name="NSM" type="byte" line="603"/>
            <declaration name="BN" type="byte" line="604"/>
            <declaration name="MASK_R_AL" type="int" line="605"/>
            <declaration name="CR" type="char" line="606"/>
            <declaration name="LF" type="char" line="607"/>
            <declaration name="LRM_BEFORE" type="int" line="608"/>
            <declaration name="LRM_AFTER" type="int" line="609"/>
            <declaration name="RLM_BEFORE" type="int" line="610"/>
            <declaration name="RLM_AFTER" type="int" line="611"/>
            <declaration name="paraBidi" type="BidiBase" line="612"/>
            <declaration name="bdp" type="UBiDiProps" line="613"/>
            <declaration name="text" type="char[]" line="614"/>
            <declaration name="originalLength" type="int" line="615"/>
            <declaration name="length" type="int" line="616"/>
            <declaration name="resultLength" type="int" line="617"/>
            <declaration name="mayAllocateText" type="boolean" line="618"/>
            <declaration name="mayAllocateRuns" type="boolean" line="619"/>
            <declaration name="dirPropsMemory" type="byte[]" line="620"/>
            <declaration name="levelsMemory" type="byte[]" line="621"/>
            <declaration name="dirProps" type="byte[]" line="622"/>
            <declaration name="levels" type="byte[]" line="623"/>
            <declaration name="orderParagraphsLTR" type="boolean" line="624"/>
            <declaration name="paraLevel" type="byte" line="625"/>
            <declaration name="defaultParaLevel" type="byte" line="626"/>
            <declaration name="impTabPair" type="ImpTabPair" line="627"/>
            <declaration name="direction" type="byte" line="628"/>
            <declaration name="flags" type="int" line="629"/>
            <declaration name="lastArabicPos" type="int" line="630"/>
            <declaration name="trailingWSStart" type="int" line="631"/>
            <declaration name="paraCount" type="int" line="632"/>
            <declaration name="parasMemory" type="int[]" line="633"/>
            <declaration name="paras" type="int[]" line="634"/>
            <declaration name="simpleParas" type="int[]" line="635"/>
            <declaration name="runCount" type="int" line="636"/>
            <declaration name="runsMemory" type="BidiRun[]" line="637"/>
            <declaration name="runs" type="BidiRun[]" line="638"/>
            <declaration name="simpleRuns" type="BidiRun[]" line="639"/>
            <declaration name="logicalToVisualRunsMap" type="int[]" line="640"/>
            <declaration name="isGoodLogicalToVisualRunsMap" type="boolean" line="641"/>
            <declaration name="insertPoints" type="InsertPoints" line="642"/>
            <declaration name="controlCount" type="int" line="643"/>
            <method name="DirPropFlag" type="int" line="644">
                <params>
                    <param name="dir" type="byte"/>
                </params>
            </method>
            <declaration name="CONTEXT_RTL_SHIFT" type="byte" line="647"/>
            <declaration name="CONTEXT_RTL" type="byte" line="648"/>
            <method name="NoContextRTL" type="byte" line="649">
                <params>
                    <param name="dir" type="byte"/>
                </params>
            </method>
            <method name="DirPropFlagNC" type="int" line="652">
                <params>
                    <param name="dir" type="byte"/>
                </params>
            </method>
            <declaration name="DirPropFlagMultiRuns" type="int" line="655"/>
            <declaration name="DirPropFlagLR" type="int" line="656"/>
            <declaration name="DirPropFlagE" type="int" line="657"/>
            <declaration name="DirPropFlagO" type="int" line="658"/>
            <method name="DirPropFlagLR" type="int" line="659">
                <params>
                    <param name="level" type="byte"/>
                </params>
            </method>
            <method name="DirPropFlagE" type="int" line="662">
                <params>
                    <param name="level" type="byte"/>
                </params>
            </method>
            <method name="DirPropFlagO" type="int" line="665">
                <params>
                    <param name="level" type="byte"/>
                </params>
            </method>
            <declaration name="MASK_LTR" type="int" line="668"/>
            <declaration name="MASK_RTL" type="int" line="669"/>
            <declaration name="MASK_LRX" type="int" line="670"/>
            <declaration name="MASK_RLX" type="int" line="671"/>
            <declaration name="MASK_EXPLICIT" type="int" line="672"/>
            <declaration name="MASK_BN_EXPLICIT" type="int" line="673"/>
            <declaration name="MASK_B_S" type="int" line="674"/>
            <declaration name="MASK_WS" type="int" line="675"/>
            <declaration name="MASK_N" type="int" line="676"/>
            <declaration name="MASK_POSSIBLE_N" type="int" line="677"/>
            <declaration name="MASK_EMBEDDING" type="int" line="678"/>
            <method name="GetLRFromLevel" type="byte" line="679">
                <params>
                    <param name="level" type="byte"/>
                </params>
            </method>
            <method name="IsDefaultLevel" type="boolean" line="682">
                <params>
                    <param name="level" type="byte"/>
                </params>
            </method>
            <method name="GetParaLevelAt" type="byte" line="685">
                <params>
                    <param name="index" type="int"/>
                </params>
            </method>
            <method name="IsBidiControlChar" type="boolean" line="688">
                <params>
                    <param name="c" type="int"/>
                </params>
            </method>
            <method name="verifyValidPara" type="void" line="691">
                <scope line="692"/>
            </method>
            <method name="verifyValidParaOrLine" type="void" line="696">
                <declaration name="para" type="BidiBase" line="697"/>
                <scope line="698"/>
                <scope line="701"/>
            </method>
            <method name="verifyRange" type="void" line="705">
                <params>
                    <param name="index" type="int"/>
                    <param name="start" type="int"/>
                    <param name="limit" type="int"/>
                </params>
                <scope line="706"/>
            </method>
            <method name="verifyIndex" type="void" line="710">
                <params>
                    <param name="index" type="int"/>
                    <param name="start" type="int"/>
                    <param name="limit" type="int"/>
                </params>
                <scope line="711"/>
            </method>
            <javadoc line="715">
                Allocate a &lt;code&gt;Bidi&lt;/code&gt; object with preallocated memory
                  for internal structures.
                  This method provides a &lt;code&gt;Bidi&lt;/code&gt; object like the default constructor
                  but it also preallocates memory for internal structures
                  according to the sizings supplied by the caller.&lt;p&gt;
                  The preallocation can be limited to some of the internal memory
                  by setting some values to 0 here. That means that if, e.g.,
                  &lt;code&gt;maxRunCount&lt;/code&gt; cannot be reasonably predetermined and should not
                  be set to &lt;code&gt;maxLength&lt;/code&gt; (the only failproof value) to avoid
                  wasting  memory, then &lt;code&gt;maxRunCount&lt;/code&gt; could be set to 0 here
                  and the internal structures that are associated with it will be allocated
                  on demand, just like with the default constructor.                
                <param>
                    maxLength is the maximum text or line length that internal memory
                      will be preallocated for. An attempt to associate this object with a
                      longer text will fail, unless this value is 0, which leaves the allocation
                      up to the implementation.                    
                </param>
                <param>
                    maxRunCount is the maximum anticipated number of same-level runs
                      that internal memory will be preallocated for. An attempt to access
                      visual runs on an object that was not preallocated for as many runs
                      as the text was actually resolved to will fail,
                      unless this value is 0, which leaves the allocation up to the implementation.&lt;br&gt;&lt;br&gt;
                      The number of runs depends on the actual text and maybe anywhere between
                      1 and &lt;code&gt;maxLength&lt;/code&gt;. It is typically small.                    
                </param>
                <throws>
                    IllegalArgumentException if maxLength or maxRunCount is less than 0                    
                </throws>
                <stable>
                    ICU 3.8                    
                </stable>
            </javadoc>
            <method name="BidiBase" type="constructor" line="742">
                <params>
                    <param name="maxLength" type="int"/>
                    <param name="maxRunCount" type="int"/>
                </params>
                <scope line="743"/>
                <scope line="746"/>
                <scope line="749"/>
                <scope line="752"/>
                <scope line="756"/>
                <scope line="759">
                    <scope line="760"/>
                </scope>
                <scope line="764"/>
            </method>
            <method name="getMemory" type="Object" line="768">
                <params>
                    <param name="label" type="String"/>
                    <param name="array" type="Object"/>
                    <param name="arrayClass" type="Class"/>
                    <param name="mayAllocate" type="boolean"/>
                    <param name="sizeNeeded" type="int"/>
                </params>
                <declaration name="len" type="int" line="769"/>
                <scope line="770"/>
                <scope line="773">
                    <scope line="774"/>
                </scope>
                <scope line="779"/>
                <scope line="782"/>
            </method>
            <method name="getDirPropsMemory" type="void" line="786">
                <params>
                    <param name="mayAllocate" type="boolean"/>
                    <param name="len" type="int"/>
                </params>
                <declaration name="array" type="Object" line="787"/>
            </method>
            <method name="getDirPropsMemory" type="void" line="790">
                <params>
                    <param name="len" type="int"/>
                </params>
            </method>
            <method name="getLevelsMemory" type="void" line="793">
                <params>
                    <param name="mayAllocate" type="boolean"/>
                    <param name="len" type="int"/>
                </params>
                <declaration name="array" type="Object" line="794"/>
            </method>
            <method name="getLevelsMemory" type="void" line="797">
                <params>
                    <param name="len" type="int"/>
                </params>
            </method>
            <method name="getRunsMemory" type="void" line="800">
                <params>
                    <param name="mayAllocate" type="boolean"/>
                    <param name="len" type="int"/>
                </params>
                <declaration name="array" type="Object" line="801"/>
            </method>
            <method name="getRunsMemory" type="void" line="804">
                <params>
                    <param name="len" type="int"/>
                </params>
            </method>
            <method name="getInitialDirPropsMemory" type="void" line="807">
                <params>
                    <param name="len" type="int"/>
                </params>
            </method>
            <method name="getInitialLevelsMemory" type="void" line="810">
                <params>
                    <param name="len" type="int"/>
                </params>
            </method>
            <method name="getInitialParasMemory" type="void" line="813">
                <params>
                    <param name="len" type="int"/>
                </params>
                <declaration name="array" type="Object" line="814"/>
            </method>
            <method name="getInitialRunsMemory" type="void" line="817">
                <params>
                    <param name="len" type="int"/>
                </params>
            </method>
            <method name="getDirProps" type="void" line="820">
                <declaration name="i" type="int" line="821"/>
                <declaration name="uchar" type="int" line="823"/>
                <declaration name="dirProp" type="byte" line="824"/>
                <declaration name="paraDirDefault" type="byte" line="825"/>
                <declaration name="isDefaultLevel" type="boolean" line="826"/>
                <declaration name="NOT_CONTEXTUAL" type="int" line="829"/>
                <declaration name="LOOKING_FOR_STRONG" type="int" line="830"/>
                <declaration name="FOUND_STRONG_CHAR" type="int" line="831"/>
                <declaration name="state" type="int" line="832"/>
                <declaration name="paraStart" type="int" line="833"/>
                <declaration name="paraDir" type="byte" line="834"/>
                <declaration name="lastStrongDir" type="byte" line="835"/>
                <declaration name="lastStrongLTR" type="int" line="836"/>
                <scope line="837"/>
                <scope line="843"/>
                <scope line="847">
                    <scope line="855">
                        <scope line="857"/>
                    </scope>
                    <scope line="862">
                        <scope line="863">
                            <scope line="865">
                                <scope line="867"/>
                            </scope>
                        </scope>
                        <scope line="873">
                            <scope line="875">
                                <scope line="877"/>
                            </scope>
                        </scope>
                    </scope>
                    <scope line="884"/>
                    <scope line="888"/>
                    <scope line="891"/>
                    <scope line="895">
                        <scope line="896">
                            <scope line="897"/>
                            <scope line="900"/>
                        </scope>
                    </scope>
                </scope>
                <scope line="909"/>
                <scope line="913"/>
            </method>
            <method name="directionFromFlags" type="byte" line="917">
                <scope line="918"/>
                <scope line="921"/>
                <scope line="924"/>
            </method>
            <method name="resolveExplicitLevels" type="byte" line="928">
                <declaration name="i" type="int" line="929"/>
                <declaration name="dirProp" type="byte" line="930"/>
                <declaration name="level" type="byte" line="931"/>
                <declaration name="dirct" type="byte" line="932"/>
                <declaration name="paraIndex" type="int" line="933"/>
                <scope line="935"/>
                <scope line="937">
                    <scope line="938"/>
                </scope>
                <scope line="942">
                    <declaration name="embeddingLevel" type="byte" line="943"/>
                    <declaration name="newLevel" type="byte" line="944"/>
                    <declaration name="stackTop" type="byte" line="945"/>
                    <declaration name="stack" type="byte[]" line="946"/>
                    <declaration name="countOver60" type="int" line="947"/>
                    <declaration name="countOver61" type="int" line="948"/>
                    <scope line="950">
                        <scope line="956">
                            <scope line="960"/>
                        </scope>
                        <scope line="964"/>
                        <scope line="967"/>
                        <scope line="975">
                            <scope line="979"/>
                        </scope>
                        <scope line="983"/>
                        <scope line="989"/>
                        <scope line="992"/>
                        <scope line="995"/>
                        <scope line="1006">
                            <scope line="1008"/>
                        </scope>
                        <scope line="1018">
                            <scope line="1020"/>
                            <scope line="1023"/>
                        </scope>
                        <scope line="1027"/>
                    </scope>
                    <scope line="1034"/>
                    <scope line="1037"/>
                </scope>
            </method>
            <method name="checkExplicitLevels" type="byte" line="1044">
                <declaration name="dirProp" type="byte" line="1045"/>
                <declaration name="i" type="int" line="1046"/>
                <declaration name="level" type="byte" line="1048"/>
                <declaration name="paraIndex" type="int" line="1049"/>
                <scope line="1050">
                    <scope line="1051"/>
                    <scope line="1054">
                        <scope line="1055"/>
                        <scope line="1058"/>
                    </scope>
                    <scope line="1064"/>
                    <scope line="1068"/>
                    <scope line="1071"/>
                    <scope line="1074">
                        <scope line="1075"/>
                    </scope>
                </scope>
                <scope line="1080"/>
            </method>
            <declaration name="IMPTABPROPS_COLUMNS" type="int" line="1085"/>
            <javadoc line="1085">
                                
            </javadoc>
            <declaration name="IMPTABPROPS_RES" type="int" line="1088"/>
            <method name="GetStateProps" type="short" line="1089">
                <params>
                    <param name="cell" type="short"/>
                </params>
            </method>
            <method name="GetActionProps" type="short" line="1092">
                <params>
                    <param name="cell" type="short"/>
                </params>
            </method>
            <declaration name="groupProp" type="short" line="1095"/>
            <declaration name="_L" type="short" line="1096"/>
            <declaration name="_R" type="short" line="1097"/>
            <declaration name="_EN" type="short" line="1098"/>
            <declaration name="_AN" type="short" line="1099"/>
            <declaration name="_ON" type="short" line="1100"/>
            <declaration name="_S" type="short" line="1101"/>
            <declaration name="_B" type="short" line="1102"/>
            <declaration name="impTabProps" type="short" line="1103"/>
            <javadoc line="1103">
                                
            </javadoc>
            <declaration name="IMPTABLEVELS_COLUMNS" type="int" line="1106"/>
            <javadoc line="1106">
                                
            </javadoc>
            <declaration name="IMPTABLEVELS_RES" type="int" line="1109"/>
            <method name="GetState" type="short" line="1110">
                <params>
                    <param name="cell" type="byte"/>
                </params>
            </method>
            <method name="GetAction" type="short" line="1113">
                <params>
                    <param name="cell" type="byte"/>
                </params>
            </method>
            <class name="ImpTabPair" line="1116">
                <declaration name="imptab" type="byte[][][]" line="1117"/>
                <declaration name="impact" type="short[][]" line="1118"/>
                <method name="ImpTabPair" type="constructor" line="1119">
                    <params>
                        <param name="table1" type="byte[][]"/>
                        <param name="table2" type="byte[][]"/>
                        <param name="act1" type="short[]"/>
                        <param name="act2" type="short[]"/>
                    </params>
                </method>
            </class>
            <declaration name="impTabL_DEFAULT" type="byte" line="1124"/>
            <javadoc line="1124">
                                
            </javadoc>
            <declaration name="impTabR_DEFAULT" type="byte" line="1127"/>
            <declaration name="impAct0" type="short[]" line="1128"/>
            <declaration name="impTab_DEFAULT" type="ImpTabPair" line="1129"/>
            <declaration name="impTabL_NUMBERS_SPECIAL" type="byte" line="1130"/>
            <declaration name="impTab_NUMBERS_SPECIAL" type="ImpTabPair" line="1131"/>
            <declaration name="impTabL_GROUP_NUMBERS_WITH_R" type="byte" line="1132"/>
            <declaration name="impTabR_GROUP_NUMBERS_WITH_R" type="byte" line="1133"/>
            <declaration name="impTab_GROUP_NUMBERS_WITH_R" type="ImpTabPair" line="1134"/>
            <declaration name="impTabL_INVERSE_NUMBERS_AS_L" type="byte" line="1135"/>
            <declaration name="impTabR_INVERSE_NUMBERS_AS_L" type="byte" line="1136"/>
            <declaration name="impTab_INVERSE_NUMBERS_AS_L" type="ImpTabPair" line="1137"/>
            <declaration name="impTabR_INVERSE_LIKE_DIRECT" type="byte" line="1138"/>
            <declaration name="impAct1" type="short[]" line="1139"/>
            <declaration name="impTab_INVERSE_LIKE_DIRECT" type="ImpTabPair" line="1140"/>
            <declaration name="impTabL_INVERSE_LIKE_DIRECT_WITH_MARKS" type="byte" line="1141"/>
            <declaration name="impTabR_INVERSE_LIKE_DIRECT_WITH_MARKS" type="byte" line="1142"/>
            <declaration name="impAct2" type="short" line="1143"/>
            <declaration name="impTab_INVERSE_LIKE_DIRECT_WITH_MARKS" type="ImpTabPair" line="1144"/>
            <declaration name="impTab_INVERSE_FOR_NUMBERS_SPECIAL" type="ImpTabPair" line="1145"/>
            <declaration name="impTabL_INVERSE_FOR_NUMBERS_SPECIAL_WITH_MARKS" type="byte" line="1146"/>
            <declaration name="impTab_INVERSE_FOR_NUMBERS_SPECIAL_WITH_MARKS" type="ImpTabPair" line="1147"/>
            <class name="LevState" line="1148">
                <declaration name="impTab" type="byte[][]" line="1149"/>
                <declaration name="impAct" type="short[]" line="1150"/>
                <declaration name="startON" type="int" line="1151"/>
                <declaration name="startL2EN" type="int" line="1152"/>
                <declaration name="lastStrongRTL" type="int" line="1153"/>
                <declaration name="state" type="short" line="1154"/>
                <declaration name="runLevel" type="byte" line="1155"/>
            </class>
            <declaration name="FIRSTALLOC" type="int" line="1157"/>
            <method name="addPoint" type="void" line="1158">
                <params>
                    <param name="pos" type="int"/>
                    <param name="flag" type="int"/>
                </params>
                <declaration name="point" type="Point" line="1159"/>
                <declaration name="len" type="int" line="1160"/>
                <scope line="1161"/>
                <scope line="1165">
                    <declaration name="savePoints" type="Point[]" line="1166"/>
                </scope>
            </method>
            <method name="processPropertySeq" type="void" line="1175">
                <params>
                    <param name="levState" type="LevState"/>
                    <param name="_prop" type="short"/>
                    <param name="start" type="int"/>
                    <param name="limit" type="int"/>
                </params>
                <declaration name="cell" type="byte" line="1176"/>
                <declaration name="impTab" type="byte[][]" line="1177"/>
                <declaration name="impAct" type="short[]" line="1178"/>
                <declaration name="oldStateSeq" type="short" line="1179"/>
                <declaration name="level" type="byte" line="1180"/>
                <declaration name="start0" type="int" line="1181"/>
                <scope line="1188">
                    <scope line="1197"/>
                    <scope line="1201">
                        <scope line="1204"/>
                        <scope line="1207"/>
                    </scope>
                    <scope line="1213"/>
                    <scope line="1218"/>
                    <scope line="1230">
                        <scope line="1231"/>
                        <scope line="1235"/>
                    </scope>
                    <scope line="1242"/>
                    <scope line="1251"/>
                    <scope line="1253"/>
                    <scope line="1265"/>
                    <scope line="1272">
                        <scope line="1273"/>
                    </scope>
                    <scope line="1282">
                        <scope line="1283">
                            <scope line="1284"/>
                            <scope line="1287"/>
                        </scope>
                        <scope line="1291"/>
                    </scope>
                    <scope line="1300">
                        <scope line="1301"/>
                    </scope>
                </scope>
                <scope line="1310">
                    <scope line="1312"/>
                </scope>
            </method>
            <method name="resolveImplicitLevels" type="void" line="1317">
                <params>
                    <param name="start" type="int"/>
                    <param name="limit" type="int"/>
                    <param name="sor" type="short"/>
                    <param name="eor" type="short"/>
                </params>
                <declaration name="levState" type="LevState" line="1318"/>
                <declaration name="i" type="int" line="1319"/>
                <declaration name="oldStateImp" type="short" line="1320"/>
                <declaration name="gprop" type="short" line="1321"/>
                <declaration name="nextStrongProp" type="short" line="1322"/>
                <declaration name="nextStrongPos" type="int" line="1323"/>
                <scope line="1331"/>
                <scope line="1334"/>
                <scope line="1339">
                    <scope line="1340"/>
                    <scope line="1343">
                        <declaration name="prop" type="short" line="1344"/>
                    </scope>
                    <scope line="1352"/>
                    <scope line="1355"/>
                </scope>
            </method>
            <method name="adjustWSLevels" type="void" line="1382">
                <declaration name="i" type="int" line="1383"/>
                <scope line="1384">
                    <declaration name="flag" type="int" line="1385"/>
                    <scope line="1387">
                        <scope line="1388">
                            <scope line="1389"/>
                            <scope line="1392"/>
                        </scope>
                        <scope line="1396">
                            <scope line="1398"/>
                            <scope line="1401"/>
                            <scope line="1405"/>
                        </scope>
                    </scope>
                </scope>
            </method>
            <method name="Bidi_Min" type="int" line="1413">
                <params>
                    <param name="x" type="int"/>
                    <param name="y" type="int"/>
                </params>
            </method>
            <method name="Bidi_Abs" type="int" line="1416">
                <params>
                    <param name="x" type="int"/>
                </params>
            </method>
            <javadoc line="1419">
                Perform the Unicode Bidi algorithm. It is defined in the
                  &lt;a href=&quot;http://www.unicode.org/unicode/reports/tr9/&quot;&gt;Unicode Standard Annex #9&lt;/a&gt;,
                  version 13,
                  also described in The Unicode Standard, Version 4.0 .&lt;p&gt;
                  This method takes a piece of plain text containing one or more paragraphs,
                  with or without externally specified embedding levels from &lt;i&gt;styled&lt;/i&gt;
                  text and computes the left-right-directionality of each character.&lt;p&gt;
                  If the entire text is all of the same directionality, then
                  the method may not perform all the steps described by the algorithm,
                  i.e., some levels may not be the same as if all steps were performed.
                  This is not relevant for unidirectional text.&lt;br&gt;
                  For example, in pure LTR text with numbers the numbers would get
                  a resolved level of 2 higher than the surrounding text according to
                  the algorithm. This implementation may set all resolved levels to
                  the same value in such a case.&lt;p&gt;
                  The text can be composed of multiple paragraphs. Occurrence of a block
                  separator in the text terminates a paragraph, and whatever comes next starts
                  a new paragraph. The exception to this rule is when a Carriage Return (CR)
                  is followed by a Line Feed (LF). Both CR and LF are block separators, but
                  in that case, the pair of characters is considered as terminating the
                  preceding paragraph, and a new paragraph will be started by a character
                  coming after the LF.
                  Although the text is passed here as a &lt;code&gt;String&lt;/code&gt;, it is
                  stored internally as an array of characters. Therefore the
                  documentation will refer to indexes of the characters in the text.                
                <param>
                    text contains the text that the Bidi algorithm will be performed
                      on. This text can be retrieved with &lt;code&gt;getText()&lt;/code&gt; or
                      &lt;code&gt;getTextAsString&lt;/code&gt;.&lt;br&gt;                    
                </param>
                <param>
                    paraLevel specifies the default level for the text;
                      it is typically 0 (LTR) or 1 (RTL).
                      If the method shall determine the paragraph level from the text,
                      then &lt;code&gt;paraLevel&lt;/code&gt; can be set to
                      either &lt;code&gt;LEVEL_DEFAULT_LTR&lt;/code&gt;
                      or &lt;code&gt;LEVEL_DEFAULT_RTL&lt;/code&gt;; if the text contains multiple
                      paragraphs, the paragraph level shall be determined separately for
                      each paragraph; if a paragraph does not include any strongly typed
                      character, then the desired default is used (0 for LTR or 1 for RTL).
                      Any other value between 0 and &lt;code&gt;MAX_EXPLICIT_LEVEL&lt;/code&gt;
                      is also valid, with odd levels indicating RTL.                    
                </param>
                <param>
                    embeddingLevels (in) may be used to preset the embedding and override levels,
                      ignoring characters like LRE and PDF in the text.
                      A level overrides the directional property of its corresponding
                      (same index) character if the level has the
                      &lt;code&gt;LEVEL_OVERRIDE&lt;/code&gt; bit set.&lt;br&gt;&lt;br&gt;
                      Except for that bit, it must be
                      &lt;code&gt;paraLevel&lt;=embeddingLevels[]&lt;=MAX_EXPLICIT_LEVEL&lt;/code&gt;,
                      with one exception: a level of zero may be specified for a
                      paragraph separator even if &lt;code&gt;paraLevel&amp;gt;0&lt;/code&gt; when multiple
                      paragraphs are submitted in the same call to &lt;code&gt;setPara()&lt;/code&gt;.&lt;br&gt;&lt;br&gt;
                      &lt;strong&gt;Caution: &lt;/strong&gt;A reference to this array, not a copy
                      of the levels, will be stored in the &lt;code&gt;Bidi&lt;/code&gt; object;
                      the &lt;code&gt;embeddingLevels&lt;/code&gt;
                      should not be modified to avoid unexpected results on subsequent
                      Bidi operations. However, the &lt;code&gt;setPara()&lt;/code&gt; and
                      &lt;code&gt;setLine()&lt;/code&gt; methods may modify some or all of the
                      levels.&lt;br&gt;&lt;br&gt;
                      &lt;strong&gt;Note:&lt;/strong&gt; the &lt;code&gt;embeddingLevels&lt;/code&gt; array must
                      have one entry for each character in &lt;code&gt;text&lt;/code&gt;.                    
                </param>
                <throws>
                    IllegalArgumentException if the values in embeddingLevels are
                      not within the allowed range                    
                </throws>
                <see>
                    #LEVEL_DEFAULT_LTR                    
                </see>
                <see>
                    #LEVEL_DEFAULT_RTL                    
                </see>
                <see>
                    #LEVEL_OVERRIDE                    
                </see>
                <see>
                    #MAX_EXPLICIT_LEVEL                    
                </see>
                <stable>
                    ICU 3.8                    
                </stable>
            </javadoc>
            <method name="setPara" type="void" line="1486">
                <params>
                    <param name="text" type="String"/>
                    <param name="paraLevel" type="byte"/>
                    <param name="embeddingLevels" type="byte[]"/>
                </params>
                <scope line="1487"/>
                <scope line="1490"/>
            </method>
            <javadoc line="1494">
                Perform the Unicode Bidi algorithm. It is defined in the
                  &lt;a href=&quot;http://www.unicode.org/unicode/reports/tr9/&quot;&gt;Unicode Standard Annex #9&lt;/a&gt;,
                  version 13,
                  also described in The Unicode Standard, Version 4.0 .&lt;p&gt;
                  This method takes a piece of plain text containing one or more paragraphs,
                  with or without externally specified embedding levels from &lt;i&gt;styled&lt;/i&gt;
                  text and computes the left-right-directionality of each character.&lt;p&gt;
                  If the entire text is all of the same directionality, then
                  the method may not perform all the steps described by the algorithm,
                  i.e., some levels may not be the same as if all steps were performed.
                  This is not relevant for unidirectional text.&lt;br&gt;
                  For example, in pure LTR text with numbers the numbers would get
                  a resolved level of 2 higher than the surrounding text according to
                  the algorithm. This implementation may set all resolved levels to
                  the same value in such a case.&lt;p&gt;
                  The text can be composed of multiple paragraphs. Occurrence of a block
                  separator in the text terminates a paragraph, and whatever comes next starts
                  a new paragraph. The exception to this rule is when a Carriage Return (CR)
                  is followed by a Line Feed (LF). Both CR and LF are block separators, but
                  in that case, the pair of characters is considered as terminating the
                  preceding paragraph, and a new paragraph will be started by a character
                  coming after the LF.
                  The text is stored internally as an array of characters. Therefore the
                  documentation will refer to indexes of the characters in the text.                
                <param>
                    chars contains the text that the Bidi algorithm will be performed
                      on. This text can be retrieved with &lt;code&gt;getText()&lt;/code&gt; or
                      &lt;code&gt;getTextAsString&lt;/code&gt;.&lt;br&gt;                    
                </param>
                <param>
                    paraLevel specifies the default level for the text;
                      it is typically 0 (LTR) or 1 (RTL).
                      If the method shall determine the paragraph level from the text,
                      then &lt;code&gt;paraLevel&lt;/code&gt; can be set to
                      either &lt;code&gt;LEVEL_DEFAULT_LTR&lt;/code&gt;
                      or &lt;code&gt;LEVEL_DEFAULT_RTL&lt;/code&gt;; if the text contains multiple
                      paragraphs, the paragraph level shall be determined separately for
                      each paragraph; if a paragraph does not include any strongly typed
                      character, then the desired default is used (0 for LTR or 1 for RTL).
                      Any other value between 0 and &lt;code&gt;MAX_EXPLICIT_LEVEL&lt;/code&gt;
                      is also valid, with odd levels indicating RTL.                    
                </param>
                <param>
                    embeddingLevels (in) may be used to preset the embedding and
                      override levels, ignoring characters like LRE and PDF in the text.
                      A level overrides the directional property of its corresponding
                      (same index) character if the level has the
                      &lt;code&gt;LEVEL_OVERRIDE&lt;/code&gt; bit set.&lt;br&gt;&lt;br&gt;
                      Except for that bit, it must be
                      &lt;code&gt;paraLevel&lt;=embeddingLevels[]&lt;=MAX_EXPLICIT_LEVEL&lt;/code&gt;,
                      with one exception: a level of zero may be specified for a
                      paragraph separator even if &lt;code&gt;paraLevel&amp;gt;0&lt;/code&gt; when multiple
                      paragraphs are submitted in the same call to &lt;code&gt;setPara()&lt;/code&gt;.&lt;br&gt;&lt;br&gt;
                      &lt;strong&gt;Caution: &lt;/strong&gt;A reference to this array, not a copy
                      of the levels, will be stored in the &lt;code&gt;Bidi&lt;/code&gt; object;
                      the &lt;code&gt;embeddingLevels&lt;/code&gt;
                      should not be modified to avoid unexpected results on subsequent
                      Bidi operations. However, the &lt;code&gt;setPara()&lt;/code&gt; and
                      &lt;code&gt;setLine()&lt;/code&gt; methods may modify some or all of the
                      levels.&lt;br&gt;&lt;br&gt;
                      &lt;strong&gt;Note:&lt;/strong&gt; the &lt;code&gt;embeddingLevels&lt;/code&gt; array must
                      have one entry for each character in &lt;code&gt;text&lt;/code&gt;.                    
                </param>
                <throws>
                    IllegalArgumentException if the values in embeddingLevels are
                      not within the allowed range                    
                </throws>
                <see>
                    #LEVEL_DEFAULT_LTR                    
                </see>
                <see>
                    #LEVEL_DEFAULT_RTL                    
                </see>
                <see>
                    #LEVEL_OVERRIDE                    
                </see>
                <see>
                    #MAX_EXPLICIT_LEVEL                    
                </see>
                <stable>
                    ICU 3.8                    
                </stable>
            </javadoc>
            <method name="setPara" type="void" line="1560">
                <params>
                    <param name="chars" type="char[]"/>
                    <param name="paraLevel" type="byte"/>
                    <param name="embeddingLevels" type="byte[]"/>
                </params>
                <scope line="1561"/>
                <scope line="1564"/>
                <scope line="1579"/>
                <scope line="1582"/>
                <scope line="1585">
                    <scope line="1586"/>
                    <scope line="1590"/>
                    <scope line="1594"/>
                </scope>
                <scope line="1608"/>
                <scope line="1613"/>
                <scope line="1617"/>
                <scope line="1622"/>
                <scope line="1637"/>
                <scope line="1640">
                    <declaration name="start" type="int" line="1641"/>
                    <declaration name="level" type="byte" line="1642"/>
                    <declaration name="sor" type="short" line="1643"/>
                    <scope line="1646"/>
                    <scope line="1649"/>
                    <scope line="1652">
                        <scope line="1655"/>
                        <scope line="1658"/>
                        <scope line="1661"/>
                        <scope line="1663"/>
                        <scope line="1666"/>
                        <scope line="1669"/>
                        <scope line="1672"/>
                        <scope line="1675"/>
                        <scope line="1678">
                            <scope line="1679"/>
                        </scope>
                    </scope>
                </scope>
            </method>
            <javadoc line="1693">
                Perform the Unicode Bidi algorithm on a given paragraph, as defined in the
                  &lt;a href=&quot;http://www.unicode.org/unicode/reports/tr9/&quot;&gt;Unicode Standard Annex #9&lt;/a&gt;,
                  version 13,
                  also described in The Unicode Standard, Version 4.0 .&lt;p&gt;
                  This method takes a paragraph of text and computes the
                  left-right-directionality of each character. The text should not
                  contain any Unicode block separators.&lt;p&gt;
                  The RUN_DIRECTION attribute in the text, if present, determines the base
                  direction (left-to-right or right-to-left). If not present, the base
                  direction is computed using the Unicode Bidirectional Algorithm,
                  defaulting to left-to-right if there are no strong directional characters
                  in the text. This attribute, if present, must be applied to all the text
                  in the paragraph.&lt;p&gt;
                  The BIDI_EMBEDDING attribute in the text, if present, represents
                  embedding level information. Negative values from -1 to -62 indicate
                  overrides at the absolute value of the level. Positive values from 1 to
                  62 indicate embeddings. Where values are zero or not defined, the base
                  embedding level as determined by the base direction is assumed.&lt;p&gt;
                  The NUMERIC_SHAPING attribute in the text, if present, converts European
                  digits to other decimal digits before running the bidi algorithm. This
                  attribute, if present, must be applied to all the text in the paragraph.
                  If the entire text is all of the same directionality, then
                  the method may not perform all the steps described by the algorithm,
                  i.e., some levels may not be the same as if all steps were performed.
                  This is not relevant for unidirectional text.&lt;br&gt;
                  For example, in pure LTR text with numbers the numbers would get
                  a resolved level of 2 higher than the surrounding text according to
                  the algorithm. This implementation may set all resolved levels to
                  the same value in such a case.&lt;p&gt;                
                <param>
                    paragraph a paragraph of text with optional character and
                      paragraph attribute information                    
                </param>
                <stable>
                    ICU 3.8                    
                </stable>
            </javadoc>
            <method name="setPara" type="void" line="1727">
                <params>
                    <param name="paragraph" type="AttributedCharacterIterator"/>
                </params>
                <declaration name="paraLvl" type="byte" line="1728"/>
                <declaration name="runDirection" type="Boolean" line="1729"/>
                <declaration name="shaper" type="Object" line="1730"/>
                <scope line="1731"/>
                <scope line="1734"/>
                <declaration name="lvls" type="byte[]" line="1737"/>
                <declaration name="len" type="int" line="1738"/>
                <declaration name="embeddingLevels" type="byte[]" line="1739"/>
                <declaration name="txt" type="char[]" line="1740"/>
                <declaration name="i" type="int" line="1741"/>
                <declaration name="ch" type="char" line="1742"/>
                <scope line="1743">
                    <declaration name="embedding" type="Integer" line="1745"/>
                    <scope line="1746">
                        <declaration name="level" type="byte" line="1747"/>
                        <scope line="1748"/>
                        <scope line="1750"/>
                        <scope line="1754"/>
                    </scope>
                </scope>
                <scope line="1762"/>
            </method>
            <javadoc line="1767">
                Specify whether block separators must be allocated level zero,
                  so that successive paragraphs will progress from left to right.
                  This method must be called before &lt;code&gt;setPara()&lt;/code&gt;.
                  Paragraph separators (B) may appear in the text.  Setting them to level zero
                  means that all paragraph separators (including one possibly appearing
                  in the last text position) are kept in the reordered text after the text
                  that they follow in the source text.
                  When this feature is not enabled, a paragraph separator at the last
                  position of the text before reordering will go to the first position
                  of the reordered text when the paragraph level is odd.                
                <param>
                    ordarParaLTR specifies whether paragraph separators (B) must
                      receive level 0, so that successive paragraphs progress from left to right.                    
                </param>
                <see>
                    #setPara                    
                </see>
                <stable>
                    ICU 3.8                    
                </stable>
            </javadoc>
            <method name="orderParagraphsLTR" type="void" line="1783">
                <params>
                    <param name="ordarParaLTR" type="boolean"/>
                </params>
            </method>
            <javadoc line="1786">
                Get the directionality of the text.                
                <return>
                    a value of &lt;code&gt;LTR&lt;/code&gt;, &lt;code&gt;RTL&lt;/code&gt; or &lt;code&gt;MIXED&lt;/code&gt;
                      that indicates if the entire text
                      represented by this object is unidirectional,
                      and which direction, or if it is mixed-directional.                    
                </return>
                <throws>
                    IllegalStateException if this call is not preceded by a successful
                      call to &lt;code&gt;setPara&lt;/code&gt; or &lt;code&gt;setLine&lt;/code&gt;                    
                </throws>
                <see>
                    #LTR                    
                </see>
                <see>
                    #RTL                    
                </see>
                <see>
                    #MIXED                    
                </see>
                <stable>
                    ICU 3.8                    
                </stable>
            </javadoc>
            <method name="getDirection" type="byte" line="1799"/>
            <javadoc line="1803">
                Get the length of the text.                
                <return>
                    The length of the text that the &lt;code&gt;Bidi&lt;/code&gt; object was
                      created for.                    
                </return>
                <throws>
                    IllegalStateException if this call is not preceded by a successful
                      call to &lt;code&gt;setPara&lt;/code&gt; or &lt;code&gt;setLine&lt;/code&gt;                    
                </throws>
                <stable>
                    ICU 3.8                    
                </stable>
            </javadoc>
            <method name="getLength" type="int" line="1811"/>
            <javadoc line="1815">
                Get the paragraph level of the text.                
                <return>
                    The paragraph level. If there are multiple paragraphs, their
                      level may vary if the required paraLevel is LEVEL_DEFAULT_LTR or
                      LEVEL_DEFAULT_RTL.  In that case, the level of the first paragraph
                      is returned.                    
                </return>
                <throws>
                    IllegalStateException if this call is not preceded by a successful
                      call to &lt;code&gt;setPara&lt;/code&gt; or &lt;code&gt;setLine&lt;/code&gt;                    
                </throws>
                <see>
                    #LEVEL_DEFAULT_LTR                    
                </see>
                <see>
                    #LEVEL_DEFAULT_RTL                    
                </see>
                <see>
                    #getParagraph                    
                </see>
                <see>
                    #getParagraphByIndex                    
                </see>
                <stable>
                    ICU 3.8                    
                </stable>
            </javadoc>
            <method name="getParaLevel" type="byte" line="1829"/>
            <javadoc line="1833">
                Get the index of a paragraph, given a position within the text.&lt;p&gt;                
                <param>
                    charIndex is the index of a character within the text, in the
                      range &lt;code&gt;[0..getProcessedLength()-1]&lt;/code&gt;.                    
                </param>
                <return>
                    The index of the paragraph containing the specified position,
                      starting from 0.                    
                </return>
                <throws>
                    IllegalStateException if this call is not preceded by a successful
                      call to &lt;code&gt;setPara&lt;/code&gt; or &lt;code&gt;setLine&lt;/code&gt;                    
                </throws>
                <throws>
                    IllegalArgumentException if charIndex is not within the legal range                    
                </throws>
                <see>
                    com.ibm.icu.text.BidiRun                    
                </see>
                <see>
                    #getProcessedLength                    
                </see>
                <stable>
                    ICU 3.8                    
                </stable>
            </javadoc>
            <method name="getParagraphIndex" type="int" line="1846">
                <params>
                    <param name="charIndex" type="int"/>
                </params>
                <declaration name="bidi" type="BidiBase" line="1848"/>
                <declaration name="paraIndex" type="int" line="1850"/>
                <scope line="1851"/>
            </method>
            <javadoc line="1855">
                &lt;code&gt;setLine()&lt;/code&gt; returns a &lt;code&gt;Bidi&lt;/code&gt; object to
                  contain the reordering information, especially the resolved levels,
                  for all the characters in a line of text. This line of text is
                  specified by referring to a &lt;code&gt;Bidi&lt;/code&gt; object representing
                  this information for a piece of text containing one or more paragraphs,
                  and by specifying a range of indexes in this text.&lt;p&gt;
                  In the new line object, the indexes will range from 0 to &lt;code&gt;limit-start-1&lt;/code&gt;.&lt;p&gt;
                  This is used after calling &lt;code&gt;setPara()&lt;/code&gt;
                  for a piece of text, and after line-breaking on that text.
                  It is not necessary if each paragraph is treated as a single line.&lt;p&gt;
                  After line-breaking, rules (L1) and (L2) for the treatment of
                  trailing WS and for reordering are performed on
                  a &lt;code&gt;Bidi&lt;/code&gt; object that represents a line.&lt;p&gt;
                  &lt;strong&gt;Important: &lt;/strong&gt;the line &lt;code&gt;Bidi&lt;/code&gt; object may
                  reference data within the global text &lt;code&gt;Bidi&lt;/code&gt; object.
                  You should not alter the content of the global text object until
                  you are finished using the line object.                
                <param>
                    start is the line&apos;s first index into the text.                    
                </param>
                <param>
                    limit is just behind the line&apos;s last index into the text
                      (its last index +1).                    
                </param>
                <return>
                    a &lt;code&gt;Bidi&lt;/code&gt; object that will now represent a line of the text.                    
                </return>
                <throws>
                    IllegalStateException if this call is not preceded by a successful
                      call to &lt;code&gt;setPara&lt;/code&gt;                    
                </throws>
                <throws>
                    IllegalArgumentException if start and limit are not in the range
                      &lt;code&gt;0&amp;lt;=start&amp;lt;limit&amp;lt;=getProcessedLength()&lt;/code&gt;,
                      or if the specified line crosses a paragraph boundary                    
                </throws>
                <see>
                    #setPara                    
                </see>
                <see>
                    #getProcessedLength                    
                </see>
                <stable>
                    ICU 3.8                    
                </stable>
            </javadoc>
            <method name="setLine" type="Bidi" line="1886">
                <params>
                    <param name="bidi" type="Bidi"/>
                    <param name="bidiBase" type="BidiBase"/>
                    <param name="newBidi" type="Bidi"/>
                    <param name="newBidiBase" type="BidiBase"/>
                    <param name="start" type="int"/>
                    <param name="limit" type="int"/>
                </params>
            </method>
            <javadoc line="1892">
                Get the level for one character.                
                <param>
                    charIndex the index of a character.                    
                </param>
                <return>
                    The level for the character at &lt;code&gt;charIndex&lt;/code&gt;.                    
                </return>
                <throws>
                    IllegalStateException if this call is not preceded by a successful
                      call to &lt;code&gt;setPara&lt;/code&gt; or &lt;code&gt;setLine&lt;/code&gt;                    
                </throws>
                <throws>
                    IllegalArgumentException if charIndex is not in the range
                      &lt;code&gt;0&amp;lt;=charIndex&amp;lt;getProcessedLength()&lt;/code&gt;                    
                </throws>
                <see>
                    #getProcessedLength                    
                </see>
                <stable>
                    ICU 3.8                    
                </stable>
            </javadoc>
            <method name="getLevelAt" type="byte" line="1903">
                <params>
                    <param name="charIndex" type="int"/>
                </params>
                <scope line="1904"/>
            </method>
            <javadoc line="1911">
                Get an array of levels for each character.&lt;p&gt;
                  Note that this method may allocate memory under some
                  circumstances, unlike &lt;code&gt;getLevelAt()&lt;/code&gt;.                
                <return>
                    The levels array for the text,
                      or &lt;code&gt;null&lt;/code&gt; if an error occurs.                    
                </return>
                <throws>
                    IllegalStateException if this call is not preceded by a successful
                      call to &lt;code&gt;setPara&lt;/code&gt; or &lt;code&gt;setLine&lt;/code&gt;                    
                </throws>
                <stable>
                    ICU 3.8                    
                </stable>
            </javadoc>
            <method name="getLevels" type="byte[]" line="1921">
                <scope line="1923"/>
            </method>
            <javadoc line="1928">
                Get the number of runs.
                  This method may invoke the actual reordering on the
                  &lt;code&gt;Bidi&lt;/code&gt; object, after &lt;code&gt;setPara()&lt;/code&gt;
                  may have resolved only the levels of the text. Therefore,
                  &lt;code&gt;countRuns()&lt;/code&gt; may have to allocate memory,
                  and may throw an exception if it fails to do so.                
                <return>
                    The number of runs.                    
                </return>
                <throws>
                    IllegalStateException if this call is not preceded by a successful
                      call to &lt;code&gt;setPara&lt;/code&gt; or &lt;code&gt;setLine&lt;/code&gt;                    
                </throws>
                <stable>
                    ICU 3.8                    
                </stable>
            </javadoc>
            <method name="countRuns" type="int" line="1940"/>
            <javadoc line="1945">
                Get a visual-to-logical index map (array) for the characters in the
                  &lt;code&gt;Bidi&lt;/code&gt; (paragraph or line) object.
                  &lt;p&gt;
                  Some values in the map may be &lt;code&gt;MAP_NOWHERE&lt;/code&gt; if the
                  corresponding text characters are Bidi marks inserted in the visual
                  output by the option &lt;code&gt;OPTION_INSERT_MARKS&lt;/code&gt;.
                  &lt;p&gt;
                  When the visual output is altered by using options of
                  &lt;code&gt;writeReordered()&lt;/code&gt; such as &lt;code&gt;INSERT_LRM_FOR_NUMERIC&lt;/code&gt;,
                  &lt;code&gt;KEEP_BASE_COMBINING&lt;/code&gt;, &lt;code&gt;OUTPUT_REVERSE&lt;/code&gt;,
                  &lt;code&gt;REMOVE_BIDI_CONTROLS&lt;/code&gt;, the logical positions returned may not
                  be correct. It is advised to use, when possible, reordering options
                  such as {@link #OPTION_INSERT_MARKS} and {@link #OPTION_REMOVE_CONTROLS}.                
                <return>
                    an array of &lt;code&gt;getResultLength()&lt;/code&gt;
                      indexes which will reflect the reordering of the characters.&lt;br&gt;&lt;br&gt;
                      The index map will result in
                      &lt;code&gt;indexMap[visualIndex]==logicalIndex&lt;/code&gt;, where
                      &lt;code&gt;indexMap&lt;/code&gt; represents the returned array.                    
                </return>
                <throws>
                    IllegalStateException if this call is not preceded by a successful
                      call to &lt;code&gt;setPara&lt;/code&gt; or &lt;code&gt;setLine&lt;/code&gt;                    
                </throws>
                <see>
                    #getLogicalMap                    
                </see>
                <see>
                    #getLogicalIndex                    
                </see>
                <see>
                    #getResultLength                    
                </see>
                <see>
                    #MAP_NOWHERE                    
                </see>
                <see>
                    #OPTION_INSERT_MARKS                    
                </see>
                <see>
                    #writeReordered                    
                </see>
                <stable>
                    ICU 3.8                    
                </stable>
            </javadoc>
            <method name="getVisualMap" type="int[]" line="1974">
                <scope line="1976"/>
            </method>
            <javadoc line="1981">
                This is a convenience method that does not use a &lt;code&gt;Bidi&lt;/code&gt; object.
                  It is intended to be used for when an application has determined the levels
                  of objects (character sequences) and just needs to have them reordered (L2).
                  This is equivalent to using &lt;code&gt;getVisualMap()&lt;/code&gt; on a
                  &lt;code&gt;Bidi&lt;/code&gt; object.                
                <param>
                    levels is an array of levels that have been determined by
                      the application.                    
                </param>
                <return>
                    an array of &lt;code&gt;levels.length&lt;/code&gt;
                      indexes which will reflect the reordering of the characters.&lt;p&gt;
                      The index map will result in
                      &lt;code&gt;indexMap[visualIndex]==logicalIndex&lt;/code&gt;, where
                      &lt;code&gt;indexMap&lt;/code&gt; represents the returned array.                    
                </return>
                <stable>
                    ICU 3.8                    
                </stable>
            </javadoc>
            <method name="reorderVisual" type="int[]" line="1996">
                <params>
                    <param name="levels" type="byte[]"/>
                </params>
            </method>
            <declaration name="INTERNAL_DIRECTION_DEFAULT_LEFT_TO_RIGHT" type="int" line="1999"/>
            <javadoc line="1999">
                Constant indicating that the base direction depends on the first strong
                  directional character in the text according to the Unicode Bidirectional
                  Algorithm. If no strong directional character is present, the base
                  direction is left-to-right.                
                <stable>
                    ICU 3.8                    
                </stable>
            </javadoc>
            <declaration name="INTERMAL_DIRECTION_DEFAULT_RIGHT_TO_LEFT" type="int" line="2007"/>
            <javadoc line="2007">
                Constant indicating that the base direction depends on the first strong
                  directional character in the text according to the Unicode Bidirectional
                  Algorithm. If no strong directional character is present, the base
                  direction is right-to-left.                
                <stable>
                    ICU 3.8                    
                </stable>
            </javadoc>
            <javadoc line="2015">
                Create Bidi from the given text, embedding, and direction information.
                  The embeddings array may be null. If present, the values represent
                  embedding level information. Negative values from -1 to -61 indicate
                  overrides at the absolute value of the level. Positive values from 1 to
                  61 indicate embeddings. Where values are zero, the base embedding level
                  as determined by the base direction is assumed.&lt;p&gt;
                  Note: this constructor calls setPara() internally.                
                <param>
                    text an array containing the paragraph of text to process.                    
                </param>
                <param>
                    textStart the index into the text array of the start of the
                      paragraph.                    
                </param>
                <param>
                    embeddings an array containing embedding values for each character
                      in the paragraph. This can be null, in which case it is assumed
                      that there is no external embedding information.                    
                </param>
                <param>
                    embStart the index into the embedding array of the start of the
                      paragraph.                    
                </param>
                <param>
                    paragraphLength the length of the paragraph in the text and
                      embeddings arrays.                    
                </param>
                <param>
                    flags a collection of flags that control the algorithm. The
                      algorithm understands the flags DIRECTION_LEFT_TO_RIGHT,
                      DIRECTION_RIGHT_TO_LEFT, DIRECTION_DEFAULT_LEFT_TO_RIGHT, and
                      DIRECTION_DEFAULT_RIGHT_TO_LEFT. Other values are reserved.                    
                </param>
                <throws>
                    IllegalArgumentException if the values in embeddings are
                      not within the allowed range                    
                </throws>
                <see>
                    #DIRECTION_LEFT_TO_RIGHT                    
                </see>
                <see>
                    #DIRECTION_RIGHT_TO_LEFT                    
                </see>
                <see>
                    #DIRECTION_DEFAULT_LEFT_TO_RIGHT                    
                </see>
                <see>
                    #DIRECTION_DEFAULT_RIGHT_TO_LEFT                    
                </see>
                <stable>
                    ICU 3.8                    
                </stable>
            </javadoc>
            <method name="BidiBase" type="constructor" line="2045">
                <params>
                    <param name="text" type="char[]"/>
                    <param name="textStart" type="int"/>
                    <param name="embeddings" type="byte[]"/>
                    <param name="embStart" type="int"/>
                    <param name="paragraphLength" type="int"/>
                    <param name="flags" type="int"/>
                </params>
                <declaration name="paraLvl" type="byte" line="2047"/>
                <declaration name="paraEmbeddings" type="byte[]" line="2063"/>
                <scope line="2064"/>
                <scope line="2067">
                    <declaration name="lev" type="byte" line="2069"/>
                    <scope line="2070">
                        <scope line="2072"/>
                        <scope line="2075">
                            <scope line="2077"/>
                        </scope>
                    </scope>
                </scope>
                <scope line="2084"/>
                <scope line="2087">
                    <declaration name="paraText" type="char[]" line="2088"/>
                </scope>
            </method>
            <javadoc line="2093">
                Return true if the line is not left-to-right or right-to-left. This means
                  it either has mixed runs of left-to-right and right-to-left text, or the
                  base direction differs from the direction of the only run of text.                
                <return>
                    true if the line is not left-to-right or right-to-left.                    
                </return>
                <throws>
                    IllegalStateException if this call is not preceded by a successful
                      call to &lt;code&gt;setPara&lt;/code&gt;                    
                </throws>
                <stable>
                    ICU 3.8                    
                </stable>
            </javadoc>
            <method name="isMixed" type="boolean" line="2102"/>
            <javadoc line="2105">
                Return true if the line is all left-to-right text and the base direction
                  is left-to-right.                
                <return>
                    true if the line is all left-to-right text and the base direction
                      is left-to-right.                    
                </return>
                <throws>
                    IllegalStateException if this call is not preceded by a successful
                      call to &lt;code&gt;setPara&lt;/code&gt;                    
                </throws>
                <stable>
                    ICU 3.8                    
                </stable>
            </javadoc>
            <method name="isLeftToRight" type="boolean" line="2114"/>
            <javadoc line="2117">
                Return true if the line is all right-to-left text, and the base direction
                  is right-to-left                
                <return>
                    true if the line is all right-to-left text, and the base
                      direction is right-to-left                    
                </return>
                <throws>
                    IllegalStateException if this call is not preceded by a successful
                      call to &lt;code&gt;setPara&lt;/code&gt;                    
                </throws>
                <stable>
                    ICU 3.8                    
                </stable>
            </javadoc>
            <method name="isRightToLeft" type="boolean" line="2126"/>
            <javadoc line="2129">
                Return true if the base direction is left-to-right                
                <return>
                    true if the base direction is left-to-right                    
                </return>
                <throws>
                    IllegalStateException if this call is not preceded by a successful
                      call to &lt;code&gt;setPara&lt;/code&gt; or &lt;code&gt;setLine&lt;/code&gt;                    
                </throws>
                <stable>
                    ICU 3.8                    
                </stable>
            </javadoc>
            <method name="baseIsLeftToRight" type="boolean" line="2136"/>
            <javadoc line="2139">
                Return the base level (0 if left-to-right, 1 if right-to-left).                
                <return>
                    the base level                    
                </return>
                <throws>
                    IllegalStateException if this call is not preceded by a successful
                      call to &lt;code&gt;setPara&lt;/code&gt; or &lt;code&gt;setLine&lt;/code&gt;                    
                </throws>
                <stable>
                    ICU 3.8                    
                </stable>
            </javadoc>
            <method name="getBaseLevel" type="int" line="2146"/>
            <javadoc line="2149">
                Compute the logical to visual run mapping                
            </javadoc>
            <method name="getLogicalToVisualRunsMap" type="void" line="2152">
                <scope line="2153"/>
                <declaration name="count" type="int" line="2156"/>
                <scope line="2157"/>
                <declaration name="i" type="int" line="2160"/>
                <declaration name="keys" type="long[]" line="2161"/>
                <scope line="2162"/>
                <scope line="2166"/>
            </method>
            <javadoc line="2172">
                Return the level of the nth logical run in this line.                
                <param>
                    run the index of the run, between 0 and &lt;code&gt;countRuns()-1&lt;/code&gt;                    
                </param>
                <return>
                    the level of the run                    
                </return>
                <throws>
                    IllegalStateException if this call is not preceded by a successful
                      call to &lt;code&gt;setPara&lt;/code&gt; or &lt;code&gt;setLine&lt;/code&gt;                    
                </throws>
                <throws>
                    IllegalArgumentException if &lt;code&gt;run&lt;/code&gt; is not in
                      the range &lt;code&gt;0&amp;lt;=run&amp;lt;countRuns()&lt;/code&gt;                    
                </throws>
                <stable>
                    ICU 3.8                    
                </stable>
            </javadoc>
            <method name="getRunLevel" type="int" line="2182">
                <params>
                    <param name="run" type="int"/>
                </params>
                <scope line="2185"/>
            </method>
            <javadoc line="2192">
                Return the index of the character at the start of the nth logical run in
                  this line, as an offset from the start of the line.                
                <param>
                    run the index of the run, between 0 and &lt;code&gt;countRuns()&lt;/code&gt;                    
                </param>
                <return>
                    the start of the run                    
                </return>
                <throws>
                    IllegalStateException if this call is not preceded by a successful
                      call to &lt;code&gt;setPara&lt;/code&gt; or &lt;code&gt;setLine&lt;/code&gt;                    
                </throws>
                <throws>
                    IllegalArgumentException if &lt;code&gt;run&lt;/code&gt; is not in
                      the range &lt;code&gt;0&amp;lt;=run&amp;lt;countRuns()&lt;/code&gt;                    
                </throws>
                <stable>
                    ICU 3.8                    
                </stable>
            </javadoc>
            <method name="getRunStart" type="int" line="2203">
                <params>
                    <param name="run" type="int"/>
                </params>
                <scope line="2206"/>
                <scope line="2209"/>
            </method>
            <javadoc line="2216">
                Return the index of the character past the end of the nth logical run in
                  this line, as an offset from the start of the line. For example, this
                  will return the length of the line for the last run on the line.                
                <param>
                    run the index of the run, between 0 and &lt;code&gt;countRuns()&lt;/code&gt;                    
                </param>
                <return>
                    the limit of the run                    
                </return>
                <throws>
                    IllegalStateException if this call is not preceded by a successful
                      call to &lt;code&gt;setPara&lt;/code&gt; or &lt;code&gt;setLine&lt;/code&gt;                    
                </throws>
                <throws>
                    IllegalArgumentException if &lt;code&gt;run&lt;/code&gt; is not in
                      the range &lt;code&gt;0&amp;lt;=run&amp;lt;countRuns()&lt;/code&gt;                    
                </throws>
                <stable>
                    ICU 3.8                    
                </stable>
            </javadoc>
            <method name="getRunLimit" type="int" line="2228">
                <params>
                    <param name="run" type="int"/>
                </params>
                <scope line="2231"/>
                <declaration name="idx" type="int" line="2236"/>
                <declaration name="len" type="int" line="2237"/>
            </method>
            <javadoc line="2240">
                Return true if the specified text requires bidi analysis. If this returns
                  false, the text will display left-to-right. Clients can then avoid
                  constructing a Bidi object. Text in the Arabic Presentation Forms area of
                  Unicode is presumed to already be shaped and ordered for display, and so
                  will not cause this method to return true.                
                <param>
                    text the text containing the characters to test                    
                </param>
                <param>
                    start the start of the range of characters to test                    
                </param>
                <param>
                    limit the limit of the range of characters to test                    
                </param>
                <return>
                    true if the range of characters requires bidi analysis                    
                </return>
                <stable>
                    ICU 3.8                    
                </stable>
            </javadoc>
            <method name="requiresBidi" type="boolean" line="2252">
                <params>
                    <param name="text" type="char[]"/>
                    <param name="start" type="int"/>
                    <param name="limit" type="int"/>
                </params>
                <declaration name="RTLMask" type="int" line="2253"/>
                <scope line="2254"/>
                <scope line="2257">
                    <scope line="2258">
                        <scope line="2259"/>
                    </scope>
                    <scope line="2263"/>
                </scope>
            </method>
            <javadoc line="2269">
                Reorder the objects in the array into visual order based on their levels.
                  This is a utility method to use when you have a collection of objects
                  representing runs of text in logical order, each run containing text at a
                  single level. The elements at &lt;code&gt;index&lt;/code&gt; from
                  &lt;code&gt;objectStart&lt;/code&gt; up to &lt;code&gt;objectStart + count&lt;/code&gt; in the
                  objects array will be reordered into visual order assuming
                  each run of text has the level indicated by the corresponding element in
                  the levels array (at &lt;code&gt;index - objectStart + levelStart&lt;/code&gt;).                
                <param>
                    levels an array representing the bidi level of each object                    
                </param>
                <param>
                    levelStart the start position in the levels array                    
                </param>
                <param>
                    objects the array of objects to be reordered into visual order                    
                </param>
                <param>
                    objectStart the start position in the objects array                    
                </param>
                <param>
                    count the number of objects to reorder                    
                </param>
                <stable>
                    ICU 3.8                    
                </stable>
            </javadoc>
            <method name="reorderVisually" type="void" line="2285">
                <params>
                    <param name="levels" type="byte[]"/>
                    <param name="levelStart" type="int"/>
                    <param name="objects" type="Object[]"/>
                    <param name="objectStart" type="int"/>
                    <param name="count" type="int"/>
                </params>
                <scope line="2286"/>
                <scope line="2289"/>
                <scope line="2292"/>
                <declaration name="reorderLevels" type="byte[]" line="2295"/>
                <declaration name="indexMap" type="int[]" line="2297"/>
                <declaration name="temp" type="Object[]" line="2298"/>
                <scope line="2300"/>
            </method>
            <javadoc line="2304">
                Display the bidi internal state, used in debugging.                
            </javadoc>
            <method name="toString" type="String" line="2307">
                <declaration name="buf" type="StringBuffer" line="2308"/>
                <scope line="2313"/>
                <scope line="2316">
                    <scope line="2319"/>
                </scope>
                <scope line="2327"/>
            </method>
            <class name="TextAttributeConstants" line="2335">
                <javadoc line="2335">
                    A class that provides access to constants defined by
                      java.awt.font.TextAttribute without creating a static dependency.                    
                </javadoc>
                <declaration name="clazz" type="Class&amp;lt;?&amp;gt;" line="2340"/>
                <declaration name="RUN_DIRECTION" type="AttributedCharacterIterator.Attribute" line="2341"/>
                <javadoc line="2341">
                    TextAttribute instances (or a fake Attribute type if
                      java.awt.font.TextAttribute is not present)                    
                </javadoc>
                <declaration name="NUMERIC_SHAPING" type="AttributedCharacterIterator.Attribute" line="2346"/>
                <declaration name="BIDI_EMBEDDING" type="AttributedCharacterIterator.Attribute" line="2347"/>
                <declaration name="RUN_DIRECTION_LTR" type="Boolean" line="2348"/>
                <javadoc line="2348">
                    TextAttribute.RUN_DIRECTION_LTR                    
                </javadoc>
                <method name="getClass" type="Class&lt;?&gt;" line="2352">
                    <params>
                        <param name="name" type="String"/>
                    </params>
                    <scope line="2353"/>
                    <scope line="2356"/>
                </method>
                <method name="getStaticField" type="Object" line="2360">
                    <params>
                        <param name="clazz" type="Class&lt;?&gt;"/>
                        <param name="name" type="String"/>
                    </params>
                    <scope line="2361">
                        <declaration name="f" type="Field" line="2362"/>
                    </scope>
                    <scope line="2365"/>
                </method>
                <method name="getTextAttribute" type="AttributedCharacterIterator.Attribute" line="2369">
                    <params>
                        <param name="name" type="String"/>
                    </params>
                    <scope line="2370">
                        <anonymous_class line="2371"/>
                    </scope>
                    <scope line="2375"/>
                </method>
            </class>
            <class name="NumericShapings" line="2380">
                <javadoc line="2380">
                    A class that provides access to java.awt.font.NumericShaping without
                      creating a static dependency.                    
                </javadoc>
                <declaration name="clazz" type="Class&amp;lt;?&amp;gt;" line="2385"/>
                <declaration name="shapeMethod" type="Method" line="2386"/>
                <method name="getClass" type="Class&lt;?&gt;" line="2387">
                    <params>
                        <param name="name" type="String"/>
                    </params>
                    <scope line="2388"/>
                    <scope line="2391"/>
                </method>
                <method name="getMethod" type="Method" line="2395">
                    <params>
                        <param name="clazz" type="Class&lt;?&gt;"/>
                        <param name="name" type="String"/>
                        <param name="paramTypes" type="Class&lt;?&gt;"/>
                    </params>
                    <scope line="2396">
                        <scope line="2397"/>
                        <scope line="2400"/>
                    </scope>
                    <scope line="2404"/>
                </method>
                <javadoc line="2408">
                    Invokes NumericShaping shape(text,start,count) method.                    
                </javadoc>
                <method name="shape" type="void" line="2411">
                    <params>
                        <param name="shaper" type="Object"/>
                        <param name="text" type="char[]"/>
                        <param name="start" type="int"/>
                        <param name="count" type="int"/>
                    </params>
                    <scope line="2413"/>
                    <scope line="2416">
                        <declaration name="cause" type="Throwable" line="2417"/>
                    </scope>
                    <scope line="2421"/>
                </method>
            </class>
        </class>
    </source>