<?xml version="1.0" encoding="UTF-8"?>
    <source package="sun.tools.java">
        <import package="java.util.Hashtable"/>
        <import package="java.io.PrintStream"/>
        <import package="java.util.Enumeration"/>
        <class name="Identifier" line="32">
            <comment line="208">
                Explanation:
                 Since much of the compiler&apos;s low-level name resolution code
                 operates in terms of Identifier objects.  This includes the
                 code which walks around the file system and reports what
                 classes are where.  It is important to get nesting information
                 right as early as possible, since it affects the spelling of
                 signatures.  Thus, the low-level import and resolve code must
                 be able Identifier type must be able to report the nesting
                 of types, which implied that that information must be carried
                 by Identifiers--or that the low-level interfaces be significantly
                 changed.                
            </comment>
            <comment line="287">
                Unfortunately, the current structure of the compiler requires                
            </comment>
            <comment line="288">
                that the resolveName() family of methods (which appear in                
            </comment>
            <comment line="289">
                Environment.java, Context.java, and ClassDefinition.java) raise                
            </comment>
            <comment line="290">
                no exceptions and emit no errors.  When we are in resolveName()                
            </comment>
            <comment line="291">
                and we find a method that is ambiguous, we need to                
            </comment>
            <comment line="292">
                unambiguously mark it as such, so that later stages of the                
            </comment>
            <comment line="293">
                compiler realize that they should give an ambig.class rather than                
            </comment>
            <comment line="294">
                a class.not.found error.  To mark it we add a special prefix                
            </comment>
            <comment line="295">
                which cannot occur in the program source.  The routines below                
            </comment>
            <comment line="296">
                are used to check, add, and remove this prefix.                
            </comment>
            <comment line="297">
                (part of solution for 4059855).                
            </comment>
            <implements interface="Constants"/>
            <javadoc line="32">
                A class to represent identifiers.&lt;p&gt;
                  An identifier instance is very similar to a String. The difference
                  is that identifier can&apos;t be instanciated directly, instead they are
                  looked up in a hash table. This means that identifiers with the same
                  name map to the same identifier object. This makes comparisons of
                  identifiers much faster.&lt;p&gt;
                  A lot of identifiers are qualified, that is they have &apos;.&apos;s in them.
                  Each qualified identifier is chopped up into the qualifier and the
                  name. The qualifier is cached in the value field.&lt;p&gt;
                  Unqualified identifiers can have a type. This type is an integer that
                  can be used by a scanner as a token value. This value has to be set
                  using the setType method.&lt;p&gt;
                  WARNING: The contents of this source file are not part of any
                  supported API.  Code that depends on them does so at its own risk:
                  they are subject to change or removal without notice.                
                <author>
                    Arthur van Hoff                    
                </author>
            </javadoc>
            <declaration name="hash" type="Hashtable" line="58"/>
            <javadoc line="58">
                The hashtable of identifiers                
            </javadoc>
            <declaration name="name" type="String" line="63"/>
            <javadoc line="63">
                The name of the identifier                
            </javadoc>
            <declaration name="value" type="Object" line="68"/>
            <javadoc line="68">
                The value of the identifier, for keywords this is an
                  instance of class Integer, for qualified names this is
                  another identifier (the qualifier).                
            </javadoc>
            <declaration name="typeObject" type="Type" line="75"/>
            <javadoc line="75">
                The Type which corresponds to this Identifier.  This is used as
                  cache for Type.tClass() and shouldn&apos;t be used outside of that
                  context.                
            </javadoc>
            <declaration name="ipos" type="int" line="82"/>
            <javadoc line="82">
                The index of INNERCLASS_PREFIX in the name, or -1 if none.                
            </javadoc>
            <javadoc line="87">
                Construct an identifier. Don&apos;t call this directly,
                  use lookup instead.                
                <see>
                    Identifier.lookup                    
                </see>
            </javadoc>
            <method name="Identifier" type="constructor" line="92">
                <params>
                    <param name="name" type="String"/>
                </params>
            </method>
            <javadoc line="97">
                Get the type of the identifier.                
            </javadoc>
            <method name="getType" type="int" line="100"/>
            <javadoc line="105">
                Set the type of the identifier.                
            </javadoc>
            <method name="setType" type="void" line="108">
                <params>
                    <param name="t" type="int"/>
                </params>
                <comment line="110">
                    System.out.println(&quot;type(&quot; + this + &quot;)=&quot; + t);                    
                </comment>
            </method>
            <javadoc line="113">
                Lookup an identifier.                
            </javadoc>
            <method name="lookup" type="Identifier" line="116">
                <params>
                    <param name="s" type="String"/>
                </params>
                <comment line="117">
                    System.out.println(&quot;lookup(&quot; + s + &quot;)&quot;);                    
                </comment>
                <declaration name="id" type="Identifier" line="118"/>
                <scope line="119"/>
            </method>
            <javadoc line="125">
                Lookup a qualified identifier.                
            </javadoc>
            <method name="lookup" type="Identifier" line="128">
                <params>
                    <param name="q" type="Identifier"/>
                    <param name="n" type="Identifier"/>
                </params>
                <comment line="129">
                    lookup(&quot;&quot;, x) =&gt; x                    
                </comment>
                <comment line="131">
                    lookup(lookupInner(c, &quot;&quot;), n) =&gt; lookupInner(c, lookup(&quot;&quot;, n))                    
                </comment>
                <declaration name="id" type="Identifier" line="134"/>
            </method>
            <javadoc line="140">
                Lookup an inner identifier.
                  (Note:  n can be idNull.)                
            </javadoc>
            <method name="lookupInner" type="Identifier" line="144">
                <params>
                    <param name="c" type="Identifier"/>
                    <param name="n" type="Identifier"/>
                </params>
                <declaration name="id" type="Identifier" line="145"/>
                <scope line="146"/>
                <scope line="151"/>
            </method>
            <javadoc line="158">
                Convert to a string.                
            </javadoc>
            <method name="toString" type="String" line="161"/>
            <javadoc line="165">
                Check if the name is qualified (ie: it contains a &apos;.&apos;).                
            </javadoc>
            <method name="isQualified" type="boolean" line="168">
                <comment line="174">
                    back up over previous dot                    
                </comment>
                <scope line="169">
                    <declaration name="idot" type="int" line="170"/>
                    <declaration name="index" type="int" line="175"/>
                </scope>
            </method>
            <javadoc line="181">
                Return the qualifier. The null identifier is returned if
                  the name was not qualified.  The qualifier does not include
                  any inner part of the name.                
            </javadoc>
            <method name="getQualifier" type="Identifier" line="186"/>
            <javadoc line="190">
                Return the unqualified name.
                  In the case of an inner name, the unqualified name
                  will itself contain components.                
            </javadoc>
            <method name="getName" type="Identifier" line="195"/>
            <declaration name="INNERCLASS_PREFIX" type="char" line="200"/>
            <javadoc line="200">
                A space character, which precedes the first inner class
                  name in a qualified name, and thus marks the qualification
                  as involving inner classes, instead of merely packages.&lt;p&gt;
                  Ex:  &lt;tt&gt;java.util.Vector. Enumerator&lt;/tt&gt;.                
            </javadoc>
            <javadoc line="220">
                Check if the name is inner (ie: it contains a &apos; &apos;).                
            </javadoc>
            <method name="isInner" type="boolean" line="223"/>
            <javadoc line="227">
                Return the class name, without its qualifier,
                  and with any nesting flattened into a new qualfication structure.
                  If the original identifier is inner,
                  the result will be qualified, and can be further
                  decomposed by means of &lt;tt&gt;getQualifier&lt;/tt&gt; and &lt;tt&gt;getName&lt;/tt&gt;.
                  &lt;p&gt;
                  For example:
                  &lt;pre&gt;
                  Identifier id = Identifier.lookup(&quot;pkg.Foo. Bar&quot;);
                  id.getName().name      =&gt;  &quot;Foo. Bar&quot;
                  id.getFlatName().name  =&gt;  &quot;Foo.Bar&quot;
                  &lt;/pre&gt;                
            </javadoc>
            <method name="getFlatName" type="Identifier" line="241">
                <comment line="247">
                    last component is idNull                    
                </comment>
                <comment line="254">
                    Not inner.  Just return the same as getName()                    
                </comment>
                <scope line="242"/>
                <scope line="245">
                    <scope line="246"/>
                    <declaration name="n" type="String" line="250"/>
                    <declaration name="t" type="String" line="251"/>
                </scope>
            </method>
            <method name="getTopName" type="Identifier" line="258"/>
            <javadoc line="263">
                Yet another way to slice qualified identifiers:
                  The head of an identifier is its first qualifier component,
                  and the tail is the rest of them.                
            </javadoc>
            <method name="getHead" type="Identifier" line="268">
                <declaration name="id" type="Identifier" line="269"/>
            </method>
            <javadoc line="275">
                @see getHead                
            </javadoc>
            <method name="getTail" type="Identifier" line="278">
                <declaration name="id" type="Identifier" line="279"/>
            </method>
            <declaration name="ambigPrefix" type="String" line="298"/>
            <javadoc line="298">
                A special prefix to add to ambiguous names.                
            </javadoc>
            <javadoc line="303">
                Determine whether an Identifier has been marked as ambiguous.                
            </javadoc>
            <method name="hasAmbigPrefix" type="boolean" line="306"/>
            <javadoc line="310">
                Add ambigPrefix to `this&apos; to make a new Identifier marked as
                  ambiguous.  It is important that this new Identifier not refer
                  to an existing class.                
            </javadoc>
            <method name="addAmbigPrefix" type="Identifier" line="315"/>
            <javadoc line="319">
                Remove the ambigPrefix from `this&apos; to get the original identifier.                
            </javadoc>
            <method name="removeAmbigPrefix" type="Identifier" line="322">
                <scope line="323"/>
                <scope line="325"/>
            </method>
        </class>
    </source>