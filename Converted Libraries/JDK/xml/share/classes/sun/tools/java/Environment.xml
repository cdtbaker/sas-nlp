<?xml version="1.0" encoding="UTF-8"?>
    <source package="sun.tools.java">
        <import package="java.util.Stack"/>
        <import package="java.io.IOException"/>
        <import package="sun.tools.tree.Context"/>
        <import package="java.io.File"/>
        <class name="Environment" line="6">
            <implements interface="Constants"/>
            <javadoc line="6">
                This class defines the environment for a compilation.
                  It is used to load classes, resolve class names and
                  report errors. It is an abstract class, a subclass
                  must define implementations for some of the functions.&lt;p&gt;
                  An environment has a source object associated with it.
                  This is the thing against which errors are reported, it
                  is usually a file name, a field or a class.&lt;p&gt;
                  Environments can be nested to change the source object.&lt;p&gt;
                  WARNING: The contents of this source file are not part of any
                  supported API.  Code that depends on them does so at its own risk:
                  they are subject to change or removal without notice.                
                <author>
                    Arthur van Hoff                    
                </author>
            </javadoc>
            <declaration name="env" type="Environment" line="21"/>
            <javadoc line="21">
                The actual environment to which everything is forwarded.                
            </javadoc>
            <declaration name="encoding" type="String" line="25"/>
            <javadoc line="25">
                External character encoding name                
            </javadoc>
            <declaration name="source" type="Object" line="29"/>
            <javadoc line="29">
                The object that is currently being parsed/compiled.
                  It is either a file name (String) or a field (MemberDefinition)
                  or a class (ClassDeclaration or ClassDefinition).                
            </javadoc>
            <method name="Environment" type="constructor" line="35">
                <params>
                    <param name="env" type="Environment"/>
                    <param name="source" type="Object"/>
                </params>
            </method>
            <method name="Environment" type="constructor" line="40"/>
            <javadoc line="43">
                Tells whether an Identifier refers to a package which should be
                  exempt from the &quot;exists&quot; check in Imports#resolve().                
            </javadoc>
            <method name="isExemptPackage" type="boolean" line="47">
                <params>
                    <param name="id" type="Identifier"/>
                </params>
            </method>
            <javadoc line="50">
                Return a class declaration given a fully qualified class name.                
            </javadoc>
            <method name="getClassDeclaration" type="ClassDeclaration" line="53">
                <params>
                    <param name="nm" type="Identifier"/>
                </params>
            </method>
            <javadoc line="56">
                Return a class definition given a fully qualified class name.
                  &lt;p&gt;
                  Should be called only with &apos;internal&apos; class names, i.e., the result
                  of a call to &apos;resolveName&apos; or a synthetic class name.                
            </javadoc>
            <method name="getClassDefinition" type="ClassDefinition" line="62">
                <params>
                    <param name="nm" type="Identifier"/>
                </params>
                <scope line="63">
                    <declaration name="c" type="ClassDefinition" line="64"/>
                    <declaration name="tail" type="Identifier" line="65"/>
                    <scope line="66">
                        <declaration name="head" type="Identifier" line="68"/>
                        <declaration name="hname" type="String" line="69"/>
                        <scope line="70">
                            <declaration name="localClass" type="ClassDefinition" line="71"/>
                            <scope line="72"/>
                        </scope>
                        <scope line="77">
                            <scope line="78">
                                <scope line="79"/>
                            </scope>
                        </scope>
                    </scope>
                </scope>
            </method>
            <javadoc line="91">
                Return a class declaration given a type. Only works for
                  class types.                
            </javadoc>
            <method name="getClassDeclaration" type="ClassDeclaration" line="95">
                <params>
                    <param name="t" type="Type"/>
                </params>
            </method>
            <javadoc line="98">
                Return a class definition given a type. Only works for
                  class types.                
            </javadoc>
            <method name="getClassDefinition" type="ClassDefinition" line="102">
                <params>
                    <param name="t" type="Type"/>
                </params>
            </method>
            <javadoc line="105">
                Check if a class exists (without actually loading it).
                  (Since inner classes cannot in general be examined without
                  loading source, this method does not accept inner names.)                
            </javadoc>
            <method name="classExists" type="boolean" line="110">
                <params>
                    <param name="nm" type="Identifier"/>
                </params>
            </method>
            <method name="classExists" type="boolean" line="113">
                <params>
                    <param name="t" type="Type"/>
                </params>
            </method>
            <javadoc line="116">
                Get the package path for a package                
            </javadoc>
            <method name="getPackage" type="Package" line="119">
                <params>
                    <param name="pkg" type="Identifier"/>
                </params>
            </method>
            <javadoc line="122">
                Load the definition of a class.                
            </javadoc>
            <method name="loadDefinition" type="void" line="125">
                <params>
                    <param name="c" type="ClassDeclaration"/>
                </params>
            </method>
            <javadoc line="128">
                Return the source of the environment (ie: the thing being compiled/parsed).                
            </javadoc>
            <method name="getSource" type="Object" line="131"/>
            <javadoc line="134">
                Resolve a type. Make sure that all the classes referred to by
                  the type have a definition.  Report errors.  Return true if
                  the type is well-formed.  Presently used for types appearing
                  in member declarations, which represent named types internally as
                  qualified identifiers.  Type names appearing in local variable
                  declarations and within expressions are represented as identifier
                  or field expressions, and are resolved by &apos;toType&apos;, which delegates
                  handling of the non-inner portion of the name to this method.
                  &lt;p&gt;
                  In &apos;toType&apos;, the various stages of qualification are represented by
                  separate AST nodes.  Here, we are given a single identifier which
                  contains the entire qualification structure.  It is not possible in
                  general to set the error location to the exact position of a component
                  that is in error, so an error message must refer to the entire qualified
                  name.  An attempt to keep track of the string length of the components of
                  the name and to offset the location accordingly fails because the initial
                  prefix of the name may have been rewritten by an earlier call to
                  &apos;resolveName&apos;.  See &apos;SourceMember.resolveTypeStructure&apos;.  The situation
                  is actually even worse than this, because only a single location is
                  passed in for an entire declaration, which may contain many type names.
                  All error messages are thus poorly localized.  These checks should be
                  done while traversing the parse tree for the type, not the type descriptor.
                  &lt;p&gt;
                  DESIGN NOTE:
                  As far as I can tell, the two-stage resolution of names represented in
                  string form is an artifact of the late implementation of inner classes
                  and the use of mangled names internally within the compiler.  All
                  qualified names should have their hiearchical structure made explicit
                  in the parse tree at the phase at which they are presented for static
                  semantic checking.  This would affect class names appearing in &apos;extends&apos;,
                  &apos;implements&apos;, and &apos;throws&apos; clauses, as well as in member declarations.                
            </javadoc>
            <method name="resolve" type="boolean" line="167">
                <params>
                    <param name="where" type="long"/>
                    <param name="c" type="ClassDefinition"/>
                    <param name="t" type="Type"/>
                </params>
                <scope line="170">
                    <declaration name="def" type="ClassDefinition" line="171"/>
                    <scope line="172">
                        <declaration name="nm" type="Identifier" line="173"/>
                        <scope line="174"/>
                        <scope line="178"/>
                    </scope>
                    <scope line="184"/>
                    <scope line="188">
                        <scope line="189">
                            <scope line="190"/>
                        </scope>
                        <scope line="194"/>
                    </scope>
                </scope>
                <declaration name="ok" type="boolean" line="205"/>
                <declaration name="args" type="Type" line="206"/>
                <scope line="207"/>
            </method>
            <javadoc line="214">
                Given its fully-qualified name, verify that a class is defined and accessible.
                  Used to check components of qualified names in contexts where a class is expected.
                  Like &apos;resolve&apos;, but is given a single type name, not a type descriptor.                
            </javadoc>
            <method name="resolveByName" type="boolean" line="219">
                <params>
                    <param name="where" type="long"/>
                    <param name="c" type="ClassDefinition"/>
                    <param name="nm" type="Identifier"/>
                </params>
            </method>
            <method name="resolveExtendsByName" type="boolean" line="222">
                <params>
                    <param name="where" type="long"/>
                    <param name="c" type="ClassDefinition"/>
                    <param name="nm" type="Identifier"/>
                </params>
            </method>
            <method name="resolveByName" type="boolean" line="225">
                <params>
                    <param name="where" type="long"/>
                    <param name="c" type="ClassDefinition"/>
                    <param name="nm" type="Identifier"/>
                    <param name="isExtends" type="boolean"/>
                </params>
                <declaration name="def" type="ClassDefinition" line="226"/>
                <scope line="227">
                    <scope line="228"/>
                    <declaration name="decl" type="ClassDeclaration" line="232"/>
                    <scope line="233"/>
                </scope>
                <scope line="238"/>
                <scope line="242">
                    <scope line="243">
                        <scope line="244"/>
                    </scope>
                    <scope line="248"/>
                </scope>
            </method>
            <javadoc line="256">
                Like &apos;getClassDefinition(env)&apos;, but check access on each component.
                  Currently called only by &apos;resolve&apos; above.  It is doubtful that calls
                  to &apos;getClassDefinition(env)&apos; are appropriate now.                
            </javadoc>
            <method name="getQualifiedClassDefinition" type="ClassDefinition" line="261">
                <params>
                    <param name="where" type="long"/>
                    <param name="nm" type="Identifier"/>
                    <param name="ctxClass" type="ClassDefinition"/>
                    <param name="isExtends" type="boolean"/>
                </params>
                <scope line="262">
                    <declaration name="c" type="ClassDefinition" line="263"/>
                    <declaration name="tail" type="Identifier" line="264"/>
                    <scope line="265">
                        <declaration name="head" type="Identifier" line="267"/>
                        <declaration name="hname" type="String" line="268"/>
                        <scope line="269">
                            <declaration name="localClass" type="ClassDefinition" line="270"/>
                            <scope line="271"/>
                        </scope>
                        <scope line="276">
                            <scope line="277">
                                <scope line="278">
                                    <declaration name="rdecl" type="ClassDeclaration" line="279"/>
                                    <declaration name="fdecl" type="ClassDeclaration" line="281"/>
                                    <scope line="282"/>
                                </scope>
                            </scope>
                        </scope>
                    </scope>
                </scope>
            </method>
            <javadoc line="295">
                Resolve the names within a type, returning the adjusted type.
                  Adjust class names to reflect scoping.
                  Do not report errors.
                  &lt;p&gt;
                  NOTE: It would be convenient to check for errors here, such as
                  verifying that each component of a qualified name exists and is
                  accessible.  Why must this be done in a separate phase?
                  &lt;p&gt;
                  If the &apos;synth&apos; argument is true, indicating that the member whose
                  type is being resolved is synthetic, names are resolved with respect
                  to the package scope.  (Fix for 4097882)                
            </javadoc>
            <method name="resolveNames" type="Type" line="308">
                <params>
                    <param name="c" type="ClassDefinition"/>
                    <param name="t" type="Type"/>
                    <param name="synth" type="boolean"/>
                </params>
                <scope line="312">
                    <declaration name="name" type="Identifier" line="313"/>
                    <declaration name="rname" type="Identifier" line="314"/>
                    <scope line="315"/>
                    <scope line="318"/>
                    <scope line="321"/>
                </scope>
                <scope line="330">
                    <declaration name="ret" type="Type" line="331"/>
                    <declaration name="rret" type="Type" line="332"/>
                    <declaration name="args" type="Type" line="333"/>
                    <declaration name="rargs" type="Type" line="334"/>
                    <declaration name="changed" type="boolean" line="335"/>
                    <scope line="336">
                        <declaration name="arg" type="Type" line="337"/>
                        <declaration name="rarg" type="Type" line="338"/>
                        <scope line="340"/>
                    </scope>
                    <scope line="344"/>
                </scope>
            </method>
            <javadoc line="352">
                Resolve a class name, using only package and import directives.
                  Report no errors.
                  &lt;p&gt;                
            </javadoc>
            <method name="resolveName" type="Identifier" line="357">
                <params>
                    <param name="name" type="Identifier"/>
                </params>
                <scope line="358">
                    <declaration name="rhead" type="Identifier" line="359"/>
                    <scope line="360"/>
                    <scope line="363"/>
                    <scope line="366"/>
                    <scope line="369"/>
                </scope>
                <scope line="373"/>
                <scope line="376">
                    <scope line="377"/>
                    <scope line="380"/>
                </scope>
                <scope line="384">
                    <declaration name="imports" type="Imports" line="385"/>
                </scope>
            </method>
            <javadoc line="390">
                Discover if name consists of a package prefix, followed by the
                  name of a class (that actually exists), followed possibly by
                  some inner class names.  If we can&apos;t find a class that exists,
                  return the name unchanged.
                  &lt;p&gt;
                  This routine is used after a class name fails to
                  be resolved by means of imports or inner classes.
                  However, import processing uses this routine directly,
                  since import names must be exactly qualified to start with.                
            </javadoc>
            <method name="resolvePackageQualifiedName" type="Identifier" line="401">
                <params>
                    <param name="name" type="Identifier"/>
                </params>
                <declaration name="tail" type="Identifier" line="402"/>
                <scope line="403">
                    <scope line="404"/>
                    <scope line="407"/>
                    <declaration name="nm" type="Identifier" line="412"/>
                </scope>
            </method>
            <javadoc line="419">
                Resolve a class name, using only package and import directives.                
            </javadoc>
            <method name="resolve" type="Identifier" line="422">
                <params>
                    <param name="nm" type="Identifier"/>
                </params>
            </method>
            <javadoc line="426">
                Get the imports used to resolve class names.                
            </javadoc>
            <method name="getImports" type="Imports" line="429"/>
            <javadoc line="433">
                Create a new class.                
            </javadoc>
            <method name="makeClassDefinition" type="ClassDefinition" line="436">
                <params>
                    <param name="origEnv" type="Environment"/>
                    <param name="where" type="long"/>
                    <param name="name" type="IdentifierToken"/>
                    <param name="doc" type="String"/>
                    <param name="modifiers" type="int"/>
                    <param name="superClass" type="IdentifierToken"/>
                    <param name="interfaces" type="IdentifierToken"/>
                    <param name="outerClass" type="ClassDefinition"/>
                </params>
            </method>
            <javadoc line="440">
                Create a new field.                
            </javadoc>
            <method name="makeMemberDefinition" type="MemberDefinition" line="443">
                <params>
                    <param name="origEnv" type="Environment"/>
                    <param name="where" type="long"/>
                    <param name="clazz" type="ClassDefinition"/>
                    <param name="doc" type="String"/>
                    <param name="modifiers" type="int"/>
                    <param name="type" type="Type"/>
                    <param name="name" type="Identifier"/>
                    <param name="argNames" type="IdentifierToken"/>
                    <param name="expIds" type="IdentifierToken"/>
                    <param name="value" type="Object"/>
                </params>
            </method>
            <javadoc line="447">
                Returns true if the given method is applicable to the given arguments                
            </javadoc>
            <method name="isApplicable" type="boolean" line="450">
                <params>
                    <param name="m" type="MemberDefinition"/>
                    <param name="args" type="Type"/>
                </params>
                <declaration name="mType" type="Type" line="451"/>
                <declaration name="mArgs" type="Type" line="453"/>
            </method>
            <javadoc line="458">
                Returns true if &quot;best&quot; is in every argument at least as good as &quot;other&quot;                
            </javadoc>
            <method name="isMoreSpecific" type="boolean" line="461">
                <params>
                    <param name="best" type="MemberDefinition"/>
                    <param name="other" type="MemberDefinition"/>
                </params>
                <declaration name="bestType" type="Type" line="462"/>
                <declaration name="otherType" type="Type" line="463"/>
                <declaration name="result" type="boolean" line="464"/>
            </method>
            <javadoc line="467">
                Returns true if &quot;from&quot; is a more specific type than &quot;to&quot;                
            </javadoc>
            <method name="isMoreSpecific" type="boolean" line="470">
                <params>
                    <param name="from" type="Type"/>
                    <param name="to" type="Type"/>
                </params>
            </method>
            <javadoc line="473">
                Return true if an implicit cast from this type to
                  the given type is allowed.                
            </javadoc>
            <method name="implicitCast" type="boolean" line="477">
                <params>
                    <param name="from" type="Type"/>
                    <param name="to" type="Type"/>
                </params>
                <declaration name="toTypeCode" type="int" line="479"/>
                <scope line="498"/>
                <scope line="501">
                    <scope line="502"/>
                    <scope line="507"/>
                    <scope line="510"/>
                </scope>
                <scope line="515">
                    <declaration name="fromDef" type="ClassDefinition" line="516"/>
                    <declaration name="toDef" type="ClassDefinition" line="517"/>
                </scope>
                <scope line="520"/>
            </method>
            <javadoc line="525">
                Return true if an explicit cast from this type to
                  the given type is allowed.                
            </javadoc>
            <method name="explicitCast" type="boolean" line="529">
                <params>
                    <param name="from" type="Type"/>
                    <param name="to" type="Type"/>
                </params>
                <scope line="530"/>
                <scope line="533"/>
                <scope line="536">
                    <declaration name="fromClass" type="ClassDefinition" line="537"/>
                    <declaration name="toClass" type="ClassDefinition" line="538"/>
                    <scope line="539"/>
                    <scope line="542"/>
                    <scope line="545"/>
                </scope>
                <scope line="550">
                    <scope line="551">
                        <declaration name="t1" type="Type" line="552"/>
                        <declaration name="t2" type="Type" line="553"/>
                        <scope line="554"/>
                        <scope line="558"/>
                    </scope>
                </scope>
            </method>
            <javadoc line="566">
                Flags.                
            </javadoc>
            <method name="getFlags" type="int" line="569"/>
            <javadoc line="572">
                Debugging flags.  There used to be a method debug()
                  that has been replaced because -g has changed meaning
                  (it now cooperates with -O and line number, variable
                  range and source file info can be toggled separately).                
            </javadoc>
            <method name="debug_lines" type="boolean" line="578"/>
            <method name="debug_vars" type="boolean" line="581"/>
            <method name="debug_source" type="boolean" line="584"/>
            <javadoc line="587">
                Optimization flags.  There used to be a method optimize()
                  that has been replaced because -O has changed meaning in
                  javac to be replaced with -O and -O:interclass.                
            </javadoc>
            <method name="opt" type="boolean" line="592"/>
            <method name="opt_interclass" type="boolean" line="595"/>
            <javadoc line="598">
                Verbose                
            </javadoc>
            <method name="verbose" type="boolean" line="601"/>
            <javadoc line="604">
                Dump debugging stuff                
            </javadoc>
            <method name="dump" type="boolean" line="607"/>
            <javadoc line="610">
                Verbose                
            </javadoc>
            <method name="warnings" type="boolean" line="613"/>
            <javadoc line="616">
                Dependencies                
            </javadoc>
            <method name="dependencies" type="boolean" line="619"/>
            <javadoc line="622">
                Print Dependencies to stdout                
            </javadoc>
            <method name="print_dependencies" type="boolean" line="625"/>
            <javadoc line="628">
                Deprecation warnings are enabled.                
            </javadoc>
            <method name="deprecation" type="boolean" line="631"/>
            <javadoc line="634">
                Do not support virtual machines before version 1.2.
                  This option is not supported and is only here for testing purposes.                
            </javadoc>
            <method name="version12" type="boolean" line="638"/>
            <javadoc line="641">
                Floating point is strict by default                
            </javadoc>
            <method name="strictdefault" type="boolean" line="644"/>
            <javadoc line="647">
                Release resources, if any.                
            </javadoc>
            <method name="shutdown" type="void" line="650">
                <scope line="651"/>
            </method>
            <javadoc line="655">
                Issue an error.
                  source   - the input source, usually a file name string
                  offset   - the offset in the source of the error
                  err      - the error number (as defined in this interface)
                  arg1     - an optional argument to the error (null if not applicable)
                  arg2     - a second optional argument to the error (null if not applicable)
                  arg3     - a third optional argument to the error (null if not applicable)                
            </javadoc>
            <method name="error" type="void" line="664">
                <params>
                    <param name="source" type="Object"/>
                    <param name="where" type="long"/>
                    <param name="err" type="String"/>
                    <param name="arg1" type="Object"/>
                    <param name="arg2" type="Object"/>
                    <param name="arg3" type="Object"/>
                </params>
            </method>
            <method name="error" type="void" line="667">
                <params>
                    <param name="where" type="long"/>
                    <param name="err" type="String"/>
                    <param name="arg1" type="Object"/>
                    <param name="arg2" type="Object"/>
                    <param name="arg3" type="Object"/>
                </params>
            </method>
            <method name="error" type="void" line="670">
                <params>
                    <param name="where" type="long"/>
                    <param name="err" type="String"/>
                    <param name="arg1" type="Object"/>
                    <param name="arg2" type="Object"/>
                </params>
            </method>
            <method name="error" type="void" line="673">
                <params>
                    <param name="where" type="long"/>
                    <param name="err" type="String"/>
                    <param name="arg1" type="Object"/>
                </params>
            </method>
            <method name="error" type="void" line="676">
                <params>
                    <param name="where" type="long"/>
                    <param name="err" type="String"/>
                </params>
            </method>
            <javadoc line="679">
                Output a string. This can either be an error message or something
                  for debugging. This should be used instead of println.                
            </javadoc>
            <method name="output" type="void" line="683">
                <params>
                    <param name="msg" type="String"/>
                </params>
            </method>
            <declaration name="debugging" type="boolean" line="686"/>
            <method name="debugOutput" type="void" line="687">
                <params>
                    <param name="msg" type="Object"/>
                </params>
            </method>
            <javadoc line="690">
                set character encoding name                
            </javadoc>
            <method name="setCharacterEncoding" type="void" line="693">
                <params>
                    <param name="encoding" type="String"/>
                </params>
            </method>
            <javadoc line="696">
                Return character encoding name                
            </javadoc>
            <method name="getCharacterEncoding" type="String" line="699"/>
            <javadoc line="702">
                Return major version to use in generated class files.                
            </javadoc>
            <method name="getMajorVersion" type="short" line="705"/>
            <javadoc line="709">
                Return minor version to use in generated class files.                
            </javadoc>
            <method name="getMinorVersion" type="short" line="712"/>
            <javadoc line="716">
                get coverage flag                
            </javadoc>
            <method name="coverage" type="boolean" line="719"/>
            <javadoc line="722">
                get flag of generation the coverage data file                
            </javadoc>
            <method name="covdata" type="boolean" line="725"/>
            <javadoc line="728">
                Return the coverage data file                
            </javadoc>
            <method name="getcovFile" type="File" line="731"/>
            <declaration name="dependtrace" type="boolean" line="734"/>
            <javadoc line="734">
                Debug tracing.
                  Currently, this code is used only for tracing the loading and
                  checking of classes, particularly the demand-driven aspects.
                  This code should probably be integrated with &apos;debugOutput&apos; above,
                  but we need to give more thought to the issue of classifying debugging
                  messages and allowing those only those of interest to be enabled.
                  Calls to these methods are generally conditioned on the final variable
                  &apos;Constants.tracing&apos;, which allows the calls to be completely omitted
                  in a production release to avoid space and time overhead.                
            </javadoc>
            <method name="dtEnter" type="void" line="746">
                <params>
                    <param name="s" type="String"/>
                </params>
            </method>
            <method name="dtExit" type="void" line="749">
                <params>
                    <param name="s" type="String"/>
                </params>
            </method>
            <method name="dtEvent" type="void" line="752">
                <params>
                    <param name="s" type="String"/>
                </params>
            </method>
            <declaration name="dumpmodifiers" type="boolean" line="755"/>
            <javadoc line="755">
                Enable diagnostic dump of class modifier bits, including those
                  in InnerClasses attributes, as they are written to the classfile.
                  In the future, may also enable dumping field and method modifiers.                
            </javadoc>
            <method name="dumpModifiers" type="boolean" line="761"/>
        </class>
    </source>