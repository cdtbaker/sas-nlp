<?xml version="1.0" encoding="UTF-8"?>
    <source package="sun.tools.java">
        <import package="java.util.Stack"/>
        <import package="java.io.IOException"/>
        <import package="sun.tools.tree.Context"/>
        <import package="java.io.File"/>
        <class name="Environment" line="35">
            <comment line="936">
                JCOV                
            </comment>
            <comment line="958">
                end JCOV                
            </comment>
            <implements interface="Constants"/>
            <javadoc line="35">
                This class defines the environment for a compilation.
                  It is used to load classes, resolve class names and
                  report errors. It is an abstract class, a subclass
                  must define implementations for some of the functions.&lt;p&gt;
                  An environment has a source object associated with it.
                  This is the thing against which errors are reported, it
                  is usually a file name, a field or a class.&lt;p&gt;
                  Environments can be nested to change the source object.&lt;p&gt;
                  WARNING: The contents of this source file are not part of any
                  supported API.  Code that depends on them does so at its own risk:
                  they are subject to change or removal without notice.                
                <author>
                    Arthur van Hoff                    
                </author>
            </javadoc>
            <declaration name="env" type="Environment" line="55"/>
            <javadoc line="55">
                The actual environment to which everything is forwarded.                
            </javadoc>
            <declaration name="encoding" type="String" line="60"/>
            <javadoc line="60">
                External character encoding name                
            </javadoc>
            <declaration name="source" type="Object" line="65"/>
            <javadoc line="65">
                The object that is currently being parsed/compiled.
                  It is either a file name (String) or a field (MemberDefinition)
                  or a class (ClassDeclaration or ClassDefinition).                
            </javadoc>
            <method name="Environment" type="constructor" line="72">
                <params>
                    <param name="env" type="Environment"/>
                    <param name="source" type="Object"/>
                </params>
                <comment line="75">
                    a small optimization                    
                </comment>
            </method>
            <method name="Environment" type="constructor" line="78"/>
            <javadoc line="82">
                Tells whether an Identifier refers to a package which should be
                  exempt from the &quot;exists&quot; check in Imports#resolve().                
            </javadoc>
            <method name="isExemptPackage" type="boolean" line="86">
                <params>
                    <param name="id" type="Identifier"/>
                </params>
            </method>
            <javadoc line="90">
                Return a class declaration given a fully qualified class name.                
            </javadoc>
            <method name="getClassDeclaration" type="ClassDeclaration" line="93">
                <params>
                    <param name="nm" type="Identifier"/>
                </params>
            </method>
            <javadoc line="97">
                Return a class definition given a fully qualified class name.
                  &lt;p&gt;
                  Should be called only with &apos;internal&apos; class names, i.e., the result
                  of a call to &apos;resolveName&apos; or a synthetic class name.                
            </javadoc>
            <method name="getClassDefinition" type="ClassDefinition" line="103">
                <params>
                    <param name="nm" type="Identifier"/>
                </params>
                <comment line="112">
                    System.out.println(&quot;CLASS: &quot; + c + &quot; HEAD: &quot; + head + &quot; TAIL: &quot; + tail);                    
                </comment>
                <comment line="114">
                    If the name is of the form &apos;ClassName.N$localName&apos;, where N is
                     a number, the field &apos;N$localName&apos; may not necessarily be a member
                     of the class named by &apos;ClassName&apos;, but might be a member of some
                     inaccessible class contained within it.  We use &apos;getLocalClass&apos;
                     to do the lookup in this case.  This is part of a fix for bugid
                     4054523 and 4030421.  See also &apos;BatchEnvironment.makeClassDefinition&apos;.
                     This should also work for anonymous class names of the form
                     &apos;ClassName.N&apos;.  Note that the &apos;.&apos; qualifications get converted to
                     &apos;$&apos; characters when determining the external name of the class and
                     the name of the class file.                    
                </comment>
                <comment line="142">
                    System.out.println(&quot;FOUND &quot; + c + &quot; FOR &quot; + nm);                    
                </comment>
                <scope line="104">
                    <declaration name="c" type="ClassDefinition" line="105"/>
                    <declaration name="tail" type="Identifier" line="106"/>
                    <scope line="108">
                        <declaration name="head" type="Identifier" line="110"/>
                        <declaration name="hname" type="String" line="112"/>
                        <scope line="124">
                            <declaration name="localClass" type="ClassDefinition" line="125"/>
                            <scope line="126"/>
                        </scope>
                        <scope line="130">
                            <scope line="132">
                                <scope line="133"/>
                            </scope>
                        </scope>
                    </scope>
                </scope>
            </method>
            <javadoc line="148">
                Return a class declaration given a type. Only works for
                  class types.                
            </javadoc>
            <method name="getClassDeclaration" type="ClassDeclaration" line="152">
                <params>
                    <param name="t" type="Type"/>
                </params>
            </method>
            <javadoc line="156">
                Return a class definition given a type. Only works for
                  class types.                
            </javadoc>
            <method name="getClassDefinition" type="ClassDefinition" line="160">
                <params>
                    <param name="t" type="Type"/>
                </params>
            </method>
            <javadoc line="164">
                Check if a class exists (without actually loading it).
                  (Since inner classes cannot in general be examined without
                  loading source, this method does not accept inner names.)                
            </javadoc>
            <method name="classExists" type="boolean" line="169">
                <params>
                    <param name="nm" type="Identifier"/>
                </params>
            </method>
            <method name="classExists" type="boolean" line="173">
                <params>
                    <param name="t" type="Type"/>
                </params>
            </method>
            <javadoc line="177">
                Get the package path for a package                
            </javadoc>
            <method name="getPackage" type="Package" line="180">
                <params>
                    <param name="pkg" type="Identifier"/>
                </params>
            </method>
            <javadoc line="184">
                Load the definition of a class.                
            </javadoc>
            <method name="loadDefinition" type="void" line="187">
                <params>
                    <param name="c" type="ClassDeclaration"/>
                </params>
            </method>
            <javadoc line="191">
                Return the source of the environment (ie: the thing being compiled/parsed).                
            </javadoc>
            <method name="getSource" type="Object" line="194"/>
            <javadoc line="198">
                Resolve a type. Make sure that all the classes referred to by
                  the type have a definition.  Report errors.  Return true if
                  the type is well-formed.  Presently used for types appearing
                  in member declarations, which represent named types internally as
                  qualified identifiers.  Type names appearing in local variable
                  declarations and within expressions are represented as identifier
                  or field expressions, and are resolved by &apos;toType&apos;, which delegates
                  handling of the non-inner portion of the name to this method.
                  &lt;p&gt;
                  In &apos;toType&apos;, the various stages of qualification are represented by
                  separate AST nodes.  Here, we are given a single identifier which
                  contains the entire qualification structure.  It is not possible in
                  general to set the error location to the exact position of a component
                  that is in error, so an error message must refer to the entire qualified
                  name.  An attempt to keep track of the string length of the components of
                  the name and to offset the location accordingly fails because the initial
                  prefix of the name may have been rewritten by an earlier call to
                  &apos;resolveName&apos;.  See &apos;SourceMember.resolveTypeStructure&apos;.  The situation
                  is actually even worse than this, because only a single location is
                  passed in for an entire declaration, which may contain many type names.
                  All error messages are thus poorly localized.  These checks should be
                  done while traversing the parse tree for the type, not the type descriptor.
                  &lt;p&gt;
                  DESIGN NOTE:
                  As far as I can tell, the two-stage resolution of names represented in
                  string form is an artifact of the late implementation of inner classes
                  and the use of mangled names internally within the compiler.  All
                  qualified names should have their hiearchical structure made explicit
                  in the parse tree at the phase at which they are presented for static
                  semantic checking.  This would affect class names appearing in &apos;extends&apos;,
                  &apos;implements&apos;, and &apos;throws&apos; clauses, as well as in member declarations.                
            </javadoc>
            <method name="resolve" type="boolean" line="231">
                <params>
                    <param name="where" type="long"/>
                    <param name="c" type="ClassDefinition"/>
                    <param name="t" type="Type"/>
                </params>
                <comment line="239">
                    elicit complaints about ambiguity                    
                </comment>
                <comment line="243">
                    Reported error location may be imprecise
                     if the name is qualified.                    
                </comment>
                <comment line="246">
                    return false later                    
                </comment>
                <comment line="253">
                    For now, report &quot;class.and.package&quot; only when the code
                     is going to fail anyway.                    
                </comment>
                <comment line="264">
                    This error message is also emitted for &apos;new&apos; expressions.
                     error(where, &quot;class.not.found&quot;, e.name, &quot;declaration&quot;);                    
                </comment>
                <scope line="233">
                    <declaration name="def" type="ClassDefinition" line="234"/>
                    <scope line="235">
                        <declaration name="nm" type="Identifier" line="236"/>
                        <scope line="237"/>
                        <scope line="241"/>
                    </scope>
                    <scope line="248"/>
                    <scope line="251">
                        <scope line="254">
                            <scope line="256"/>
                        </scope>
                        <scope line="260"/>
                    </scope>
                </scope>
                <declaration name="ok" type="boolean" line="275"/>
                <declaration name="args" type="Type" line="276"/>
                <scope line="277"/>
            </method>
            <javadoc line="285">
                Given its fully-qualified name, verify that a class is defined and accessible.
                  Used to check components of qualified names in contexts where a class is expected.
                  Like &apos;resolve&apos;, but is given a single type name, not a type descriptor.                
            </javadoc>
            <method name="resolveByName" type="boolean" line="290">
                <params>
                    <param name="where" type="long"/>
                    <param name="c" type="ClassDefinition"/>
                    <param name="nm" type="Identifier"/>
                </params>
            </method>
            <method name="resolveExtendsByName" type="boolean" line="294">
                <params>
                    <param name="where" type="long"/>
                    <param name="c" type="ClassDefinition"/>
                    <param name="nm" type="Identifier"/>
                </params>
            </method>
            <method name="resolveByName" type="boolean" line="299">
                <params>
                    <param name="where" type="long"/>
                    <param name="c" type="ClassDefinition"/>
                    <param name="nm" type="Identifier"/>
                    <param name="isExtends" type="boolean"/>
                </params>
                <comment line="304">
                    elicit complaints about ambiguity                    
                </comment>
                <comment line="312">
                    return false later                    
                </comment>
                <comment line="318">
                    For now, report &quot;class.and.package&quot; only when the code
                     is going to fail anyway.                    
                </comment>
                <declaration name="def" type="ClassDefinition" line="300"/>
                <scope line="301">
                    <scope line="302"/>
                    <declaration name="decl" type="ClassDeclaration" line="306"/>
                    <scope line="309"/>
                </scope>
                <scope line="313"/>
                <scope line="316">
                    <scope line="319">
                        <scope line="321"/>
                    </scope>
                    <scope line="325"/>
                </scope>
            </method>
            <javadoc line="334">
                Like &apos;getClassDefinition(env)&apos;, but check access on each component.
                  Currently called only by &apos;resolve&apos; above.  It is doubtful that calls
                  to &apos;getClassDefinition(env)&apos; are appropriate now.                
            </javadoc>
            <method name="getQualifiedClassDefinition" type="ClassDefinition" line="343">
                <params>
                    <param name="where" type="long"/>
                    <param name="nm" type="Identifier"/>
                    <param name="ctxClass" type="ClassDefinition"/>
                    <param name="isExtends" type="boolean"/>
                </params>
                <comment line="352">
                    System.out.println(&quot;CLASS: &quot; + c + &quot; HEAD: &quot; + head + &quot; TAIL: &quot; + tail);                    
                </comment>
                <comment line="354">
                    Handle synthesized names of local and anonymous classes.
                     See &apos;getClassDefinition(env)&apos; above.                    
                </comment>
                <comment line="370">
                    This check is presumably applicable even if the
                     original source-code name (expanded by &apos;resolveNames&apos;)
                     was a simple, unqualified name.  Hopefully, JLS 2e
                     will clarify the matter.                    
                </comment>
                <comment line="379">
                    Reported error location is imprecise.                    
                </comment>
                <comment line="382">
                    The JLS 6.6.2 restrictions on access to protected members
                     depend in an essential way upon the syntactic form of the name.
                     Since the compiler has previously expanded the class names
                     here into fully-qualified form (&apos;resolveNames&apos;), this check
                     cannot be performed here.  Unfortunately, the original names
                     are clobbered during &apos;basicCheck&apos;, which is also the phase that
                     resolves the inheritance structure, required to implement the
                     access restrictions.  Pending a large-scale revision of the
                     name-resolution machinery, we forgo this check, with the result
                     that the JLS 6.6.2 restrictions are not enforced for some cases
                     of qualified access to inner classes.  Some qualified names are
                     resolved elsewhere via a different mechanism, and will be
                     treated correctly -- see &apos;FieldExpression.checkCommon&apos;.                    
                </comment>
                <comment line="395">
                    ---------------------------------------
                    if (f.isProtected()) {
                    Type rty = Type.tClass(rdecl.getName());  hack
                    if (!ctxClass.protectedAccess(env, f, rty)) {
                     Reported error location is imprecise.
                    env.error(where, &quot;invalid.protected.type.use&quot;,
                    head, ctxClass, rty);
                    }
                    }                    
                </comment>
                <comment line="411">
                    System.out.println(&quot;FOUND &quot; + c + &quot; FOR &quot; + nm);                    
                </comment>
                <scope line="344">
                    <declaration name="c" type="ClassDefinition" line="345"/>
                    <declaration name="tail" type="Identifier" line="346"/>
                    <scope line="348">
                        <declaration name="head" type="Identifier" line="350"/>
                        <declaration name="hname" type="String" line="352"/>
                        <scope line="356">
                            <declaration name="localClass" type="ClassDefinition" line="357"/>
                            <scope line="358"/>
                        </scope>
                        <scope line="362">
                            <scope line="364">
                                <scope line="365">
                                    <declaration name="rdecl" type="ClassDeclaration" line="366"/>
                                    <declaration name="fdecl" type="ClassDeclaration" line="368"/>
                                    <scope line="377"/>
                                </scope>
                            </scope>
                        </scope>
                    </scope>
                </scope>
            </method>
            <javadoc line="416">
                Resolve the names within a type, returning the adjusted type.
                  Adjust class names to reflect scoping.
                  Do not report errors.
                  &lt;p&gt;
                  NOTE: It would be convenient to check for errors here, such as
                  verifying that each component of a qualified name exists and is
                  accessible.  Why must this be done in a separate phase?
                  &lt;p&gt;
                  If the &apos;synth&apos; argument is true, indicating that the member whose
                  type is being resolved is synthetic, names are resolved with respect
                  to the package scope.  (Fix for 4097882)                
            </javadoc>
            <method name="resolveNames" type="Type" line="429">
                <params>
                    <param name="c" type="ClassDefinition"/>
                    <param name="t" type="Type"/>
                    <param name="synth" type="boolean"/>
                </params>
                <scope line="432">
                    <declaration name="name" type="Identifier" line="433"/>
                    <declaration name="rname" type="Identifier" line="434"/>
                    <scope line="435"/>
                    <scope line="437"/>
                    <scope line="440"/>
                </scope>
                <scope line="450">
                    <declaration name="ret" type="Type" line="451"/>
                    <declaration name="rret" type="Type" line="452"/>
                    <declaration name="args" type="Type" line="453"/>
                    <declaration name="rargs" type="Type" line="454"/>
                    <declaration name="changed" type="boolean" line="455"/>
                    <scope line="456">
                        <declaration name="arg" type="Type" line="457"/>
                        <declaration name="rarg" type="Type" line="458"/>
                        <scope line="460"/>
                    </scope>
                    <scope line="464"/>
                </scope>
            </method>
            <javadoc line="473">
                Resolve a class name, using only package and import directives.
                  Report no errors.
                  &lt;p&gt;                
            </javadoc>
            <method name="resolveName" type="Identifier" line="478">
                <params>
                    <param name="name" type="Identifier"/>
                </params>
                <comment line="480">
                    This logic is pretty exactly parallel to that of
                     ClassDefinition.resolveName().                    
                </comment>
                <comment line="483">
                    Try to resolve the first identifier component,
                     because inner class names take precedence over
                     package prefixes.  (Cf. ClassDefinition.resolveName.)                    
                </comment>
                <comment line="489">
                    The first identifier component refers to an
                     ambiguous class.  Limp on.  We throw away the
                     rest of the classname as it is irrelevant.
                     (part of solution for 4059855).                    
                </comment>
                <comment line="503">
                    return partially-resolved name someone else can fail on                    
                </comment>
                <comment line="510">
                    Don&apos;t force a resolution of the name if it is ambiguous.
                     Forcing the resolution would tack the current package
                     name onto the front of the class, which would be wrong.
                     Instead, mark the name as ambiguous and let a later stage
                     find the error by calling env.resolve(name).
                     (part of solution for 4059855).                    
                </comment>
                <comment line="523">
                    last chance to make something halfway sensible                    
                </comment>
                <scope line="481">
                    <declaration name="rhead" type="Identifier" line="485"/>
                    <scope line="487"/>
                    <scope line="495"/>
                    <scope line="498"/>
                    <scope line="501"/>
                </scope>
                <scope line="506"/>
                <scope line="508">
                    <scope line="516"/>
                    <scope line="518"/>
                </scope>
                <scope line="521">
                    <declaration name="imports" type="Imports" line="523"/>
                </scope>
            </method>
            <javadoc line="530">
                Discover if name consists of a package prefix, followed by the
                  name of a class (that actually exists), followed possibly by
                  some inner class names.  If we can&apos;t find a class that exists,
                  return the name unchanged.
                  &lt;p&gt;
                  This routine is used after a class name fails to
                  be resolved by means of imports or inner classes.
                  However, import processing uses this routine directly,
                  since import names must be exactly qualified to start with.                
            </javadoc>
            <method name="resolvePackageQualifiedName" type="Identifier" line="541">
                <params>
                    <param name="name" type="Identifier"/>
                </params>
                <declaration name="tail" type="Identifier" line="542"/>
                <scope line="543">
                    <scope line="544"/>
                    <scope line="547"/>
                    <declaration name="nm" type="Identifier" line="552"/>
                </scope>
            </method>
            <javadoc line="561">
                Resolve a class name, using only package and import directives.                
            </javadoc>
            <method name="resolve" type="Identifier" line="564">
                <params>
                    <param name="nm" type="Identifier"/>
                </params>
                <comment line="566">
                    a pretty useless no-op                    
                </comment>
            </method>
            <javadoc line="569">
                Get the imports used to resolve class names.                
            </javadoc>
            <method name="getImports" type="Imports" line="572">
                <comment line="574">
                    lame default                    
                </comment>
            </method>
            <javadoc line="577">
                Create a new class.                
            </javadoc>
            <method name="makeClassDefinition" type="ClassDefinition" line="585">
                <params>
                    <param name="origEnv" type="Environment"/>
                    <param name="where" type="long"/>
                    <param name="name" type="IdentifierToken"/>
                    <param name="doc" type="String"/>
                    <param name="modifiers" type="int"/>
                    <param name="superClass" type="IdentifierToken"/>
                    <param name="interfaces" type="IdentifierToken"/>
                    <param name="outerClass" type="ClassDefinition"/>
                </params>
                <comment line="587">
                    lame default                    
                </comment>
            </method>
            <javadoc line="592">
                Create a new field.                
            </javadoc>
            <method name="makeMemberDefinition" type="MemberDefinition" line="601">
                <params>
                    <param name="origEnv" type="Environment"/>
                    <param name="where" type="long"/>
                    <param name="clazz" type="ClassDefinition"/>
                    <param name="doc" type="String"/>
                    <param name="modifiers" type="int"/>
                    <param name="type" type="Type"/>
                    <param name="name" type="Identifier"/>
                    <param name="argNames" type="IdentifierToken"/>
                    <param name="expIds" type="IdentifierToken"/>
                    <param name="value" type="Object"/>
                </params>
                <comment line="603">
                    lame default                    
                </comment>
            </method>
            <javadoc line="607">
                Returns true if the given method is applicable to the given arguments                
            </javadoc>
            <method name="isApplicable" type="boolean" line="611">
                <params>
                    <param name="m" type="MemberDefinition"/>
                    <param name="args" type="Type"/>
                </params>
                <declaration name="mType" type="Type" line="612"/>
                <declaration name="mArgs" type="Type" line="615"/>
            </method>
            <javadoc line="625">
                Returns true if &quot;best&quot; is in every argument at least as good as &quot;other&quot;                
            </javadoc>
            <method name="isMoreSpecific" type="boolean" line="629">
                <params>
                    <param name="best" type="MemberDefinition"/>
                    <param name="other" type="MemberDefinition"/>
                </params>
                <comment line="635">
                    System.out.println(&quot;isMoreSpecific: &quot; + best + &quot;/&quot; + other
                                          + &quot; =&gt; &quot; + result);                    
                </comment>
                <declaration name="bestType" type="Type" line="630"/>
                <declaration name="otherType" type="Type" line="631"/>
                <declaration name="result" type="boolean" line="632"/>
            </method>
            <javadoc line="639">
                Returns true if &quot;from&quot; is a more specific type than &quot;to&quot;                
            </javadoc>
            <method name="isMoreSpecific" type="boolean" line="643">
                <params>
                    <param name="from" type="Type"/>
                    <param name="to" type="Type"/>
                </params>
            </method>
            <javadoc line="647">
                Return true if an implicit cast from this type to
                  the given type is allowed.                
            </javadoc>
            <method name="implicitCast" type="boolean" line="651">
                <params>
                    <param name="from" type="Type"/>
                    <param name="to" type="Type"/>
                </params>
                <comment line="683">
                    both are arrays.  recurse down both until one isn&apos;t an array                    
                </comment>
                <declaration name="toTypeCode" type="int" line="655"/>
                <scope line="678"/>
                <scope line="681">
                    <scope line="683"/>
                    <scope line="688"/>
                    <scope line="690"/>
                </scope>
                <scope line="696">
                    <declaration name="fromDef" type="ClassDefinition" line="697"/>
                    <declaration name="toDef" type="ClassDefinition" line="698"/>
                </scope>
                <scope line="701"/>
            </method>
            <javadoc line="708">
                Return true if an explicit cast from this type to
                  the given type is allowed.                
            </javadoc>
            <method name="explicitCast" type="boolean" line="712">
                <params>
                    <param name="from" type="Type"/>
                    <param name="to" type="Type"/>
                </params>
                <comment line="732">
                    The code here used to omit this case.  If both types
                     involved in a cast are interfaces, then JLS 5.5 requires
                     that we do a simple test -- make sure none of the methods
                     in toClass and fromClass have the same signature but
                     different return types.  (bug number 4028359)                    
                </comment>
                <scope line="713"/>
                <scope line="716"/>
                <scope line="719">
                    <declaration name="fromClass" type="ClassDefinition" line="720"/>
                    <declaration name="toClass" type="ClassDefinition" line="721"/>
                    <scope line="722"/>
                    <scope line="726"/>
                    <scope line="736"/>
                </scope>
                <scope line="744">
                    <scope line="745">
                        <declaration name="t1" type="Type" line="746"/>
                        <declaration name="t2" type="Type" line="747"/>
                        <scope line="749"/>
                        <scope line="754"/>
                    </scope>
                </scope>
            </method>
            <javadoc line="764">
                Flags.                
            </javadoc>
            <method name="getFlags" type="int" line="767"/>
            <javadoc line="771">
                Debugging flags.  There used to be a method debug()
                  that has been replaced because -g has changed meaning
                  (it now cooperates with -O and line number, variable
                  range and source file info can be toggled separately).                
            </javadoc>
            <method name="debug_lines" type="boolean" line="777"/>
            <method name="debug_vars" type="boolean" line="780"/>
            <method name="debug_source" type="boolean" line="783"/>
            <javadoc line="787">
                Optimization flags.  There used to be a method optimize()
                  that has been replaced because -O has changed meaning in
                  javac to be replaced with -O and -O:interclass.                
            </javadoc>
            <method name="opt" type="boolean" line="792"/>
            <method name="opt_interclass" type="boolean" line="795"/>
            <javadoc line="799">
                Verbose                
            </javadoc>
            <method name="verbose" type="boolean" line="802"/>
            <javadoc line="806">
                Dump debugging stuff                
            </javadoc>
            <method name="dump" type="boolean" line="809"/>
            <javadoc line="813">
                Verbose                
            </javadoc>
            <method name="warnings" type="boolean" line="816"/>
            <javadoc line="820">
                Dependencies                
            </javadoc>
            <method name="dependencies" type="boolean" line="823"/>
            <javadoc line="827">
                Print Dependencies to stdout                
            </javadoc>
            <method name="print_dependencies" type="boolean" line="830"/>
            <javadoc line="834">
                Deprecation warnings are enabled.                
            </javadoc>
            <method name="deprecation" type="boolean" line="837"/>
            <javadoc line="841">
                Do not support virtual machines before version 1.2.
                  This option is not supported and is only here for testing purposes.                
            </javadoc>
            <method name="version12" type="boolean" line="845"/>
            <javadoc line="849">
                Floating point is strict by default                
            </javadoc>
            <method name="strictdefault" type="boolean" line="852"/>
            <javadoc line="856">
                Release resources, if any.                
            </javadoc>
            <method name="shutdown" type="void" line="859">
                <scope line="860"/>
            </method>
            <javadoc line="865">
                Issue an error.
                  source   - the input source, usually a file name string
                  offset   - the offset in the source of the error
                  err      - the error number (as defined in this interface)
                  arg1     - an optional argument to the error (null if not applicable)
                  arg2     - a second optional argument to the error (null if not applicable)
                  arg3     - a third optional argument to the error (null if not applicable)                
            </javadoc>
            <method name="error" type="void" line="874">
                <params>
                    <param name="source" type="Object"/>
                    <param name="where" type="long"/>
                    <param name="err" type="String"/>
                    <param name="arg1" type="Object"/>
                    <param name="arg2" type="Object"/>
                    <param name="arg3" type="Object"/>
                </params>
            </method>
            <method name="error" type="void" line="877">
                <params>
                    <param name="where" type="long"/>
                    <param name="err" type="String"/>
                    <param name="arg1" type="Object"/>
                    <param name="arg2" type="Object"/>
                    <param name="arg3" type="Object"/>
                </params>
            </method>
            <method name="error" type="void" line="880">
                <params>
                    <param name="where" type="long"/>
                    <param name="err" type="String"/>
                    <param name="arg1" type="Object"/>
                    <param name="arg2" type="Object"/>
                </params>
            </method>
            <method name="error" type="void" line="883">
                <params>
                    <param name="where" type="long"/>
                    <param name="err" type="String"/>
                    <param name="arg1" type="Object"/>
                </params>
            </method>
            <method name="error" type="void" line="886">
                <params>
                    <param name="where" type="long"/>
                    <param name="err" type="String"/>
                </params>
            </method>
            <javadoc line="890">
                Output a string. This can either be an error message or something
                  for debugging. This should be used instead of println.                
            </javadoc>
            <method name="output" type="void" line="894">
                <params>
                    <param name="msg" type="String"/>
                </params>
            </method>
            <declaration name="debugging" type="boolean" line="898"/>
            <method name="debugOutput" type="void" line="900">
                <params>
                    <param name="msg" type="Object"/>
                </params>
            </method>
            <javadoc line="905">
                set character encoding name                
            </javadoc>
            <method name="setCharacterEncoding" type="void" line="908">
                <params>
                    <param name="encoding" type="String"/>
                </params>
            </method>
            <javadoc line="912">
                Return character encoding name                
            </javadoc>
            <method name="getCharacterEncoding" type="String" line="915"/>
            <javadoc line="919">
                Return major version to use in generated class files.                
            </javadoc>
            <method name="getMajorVersion" type="short" line="922">
                <comment line="924">
                    needed for javah                    
                </comment>
            </method>
            <javadoc line="927">
                Return minor version to use in generated class files.                
            </javadoc>
            <method name="getMinorVersion" type="short" line="930">
                <comment line="932">
                    needed for javah                    
                </comment>
            </method>
            <javadoc line="936">
                get coverage flag                
            </javadoc>
            <method name="coverage" type="boolean" line="939"/>
            <javadoc line="943">
                get flag of generation the coverage data file                
            </javadoc>
            <method name="covdata" type="boolean" line="946"/>
            <javadoc line="950">
                Return the coverage data file                
            </javadoc>
            <method name="getcovFile" type="File" line="953"/>
            <declaration name="dependtrace" type="boolean" line="959"/>
            <javadoc line="959">
                Debug tracing.
                  Currently, this code is used only for tracing the loading and
                  checking of classes, particularly the demand-driven aspects.
                  This code should probably be integrated with &apos;debugOutput&apos; above,
                  but we need to give more thought to the issue of classifying debugging
                  messages and allowing those only those of interest to be enabled.
                  Calls to these methods are generally conditioned on the final variable
                  &apos;Constants.tracing&apos;, which allows the calls to be completely omitted
                  in a production release to avoid space and time overhead.                
            </javadoc>
            <method name="dtEnter" type="void" line="975">
                <params>
                    <param name="s" type="String"/>
                </params>
            </method>
            <method name="dtExit" type="void" line="979">
                <params>
                    <param name="s" type="String"/>
                </params>
            </method>
            <method name="dtEvent" type="void" line="983">
                <params>
                    <param name="s" type="String"/>
                </params>
            </method>
            <declaration name="dumpmodifiers" type="boolean" line="987"/>
            <javadoc line="987">
                Enable diagnostic dump of class modifier bits, including those
                  in InnerClasses attributes, as they are written to the classfile.
                  In the future, may also enable dumping field and method modifiers.                
            </javadoc>
            <method name="dumpModifiers" type="boolean" line="996"/>
        </class>
    </source>