<?xml version="1.0" encoding="UTF-8"?>
    <source package="sun.tools.java">
        <import package="sun.tools.tree.Node"/>
        <import package="sun.tools.tree.Vset"/>
        <import package="sun.tools.tree.Expression"/>
        <import package="sun.tools.tree.Statement"/>
        <import package="sun.tools.tree.Context"/>
        <import package="sun.tools.asm.Assembler"/>
        <import package="java.io.PrintStream"/>
        <import package="java.util.Vector"/>
        <import package="java.util.Map"/>
        <import package="java.util.HashMap"/>
        <class name="MemberDefinition" line="39">
            <comment line="446">
                -----------------------------------------------------------------
                 The code in this section is intended to test certain kinds of
                 compatibility between methods.  There are two kinds of compatibility
                 that the compiler may need to test.  The first is whether one
                 method can legally override another.  The second is whether two
                 method definitions can legally coexist.  We use the word `meet&apos;
                 to mean the intersection of two legally coexisting methods.
                 For more information on these kinds of compatibility, see the
                 comments/code for checkOverride() and checkMeet() below.                
            </comment>
            <comment line="828">
                -----------------------------------------------------------------                
            </comment>
            <implements interface="Constants"/>
            <javadoc line="39">
                This class defines a member of a Java class:
                  a variable, a method, or an inner class.
                  WARNING: The contents of this source file are not part of any
                  supported API.  Code that depends on them does so at its own risk:
                  they are subject to change or removal without notice.                
            </javadoc>
            <declaration name="where" type="long" line="49"/>
            <declaration name="modifiers" type="int" line="50"/>
            <declaration name="type" type="Type" line="51"/>
            <declaration name="documentation" type="String" line="52"/>
            <declaration name="expIds" type="IdentifierToken" line="53"/>
            <declaration name="exp" type="ClassDeclaration" line="54"/>
            <declaration name="value" type="Node" line="55"/>
            <declaration name="clazz" type="ClassDefinition" line="56"/>
            <declaration name="name" type="Identifier" line="57"/>
            <declaration name="innerClass" type="ClassDefinition" line="58"/>
            <declaration name="nextMember" type="MemberDefinition" line="59"/>
            <declaration name="nextMatch" type="MemberDefinition" line="60"/>
            <declaration name="accessPeer" type="MemberDefinition" line="61"/>
            <declaration name="superAccessMethod" type="boolean" line="62"/>
            <javadoc line="64">
                Constructor                
            </javadoc>
            <method name="MemberDefinition" type="constructor" line="69">
                <params>
                    <param name="where" type="long"/>
                    <param name="clazz" type="ClassDefinition"/>
                    <param name="modifiers" type="int"/>
                    <param name="type" type="Type"/>
                    <param name="name" type="Identifier"/>
                    <param name="expIds" type="IdentifierToken"/>
                    <param name="value" type="Node"/>
                </params>
                <scope line="70"/>
            </method>
            <javadoc line="82">
                Constructor for an inner class.
                  Inner classes are represented as fields right along with
                  variables and methods for simplicity of data structure,
                  and to reflect properly the textual declaration order.
                  &lt;p&gt;
                  This constructor calls the generic constructor for this
                  class, extracting all necessary values from the innerClass.                
            </javadoc>
            <method name="MemberDefinition" type="constructor" line="91">
                <params>
                    <param name="innerClass" type="ClassDefinition"/>
                </params>
            </method>
            <declaration name="proxyCache" type="Map" line="101"/>
            <javadoc line="101">
                A cache of previously created proxy members.  Used to ensure
                  uniqueness of proxy objects.  See the makeProxyMember method
                  defined below.                
            </javadoc>
            <javadoc line="108">
                Create a member which is externally the same as `field&apos; but
                  is defined in class `classDef&apos;.  This is used by code
                  in sun.tools.tree.(MethodExpression,FieldExpression) as
                  part of the fix for bug 4135692.
                  Proxy members should not be added, ala addMember(), to classes.
                  They are merely &quot;stand-ins&quot; to produce modified MethodRef
                  constant pool entries during code generation.
                  We keep a cache of previously created proxy members not to
                  save time or space, but to ensure uniqueness of the proxy
                  member for any (field,classDef) pair.  If these are not made
                  unique then we can end up generating duplicate MethodRef
                  constant pool entries during code generation.                
            </javadoc>
            <method name="makeProxyMember" type="MemberDefinition" line="126">
                <params>
                    <param name="field" type="MemberDefinition"/>
                    <param name="classDef" type="ClassDefinition"/>
                    <param name="env" type="Environment"/>
                </params>
                <comment line="134">
                    System.out.println(&quot;Key is : &quot; + key);                    
                </comment>
                <scope line="128"/>
                <declaration name="key" type="String" line="132"/>
                <declaration name="proxy" type="MemberDefinition" line="134"/>
            </method>
            <javadoc line="149">
                Get the position in the input                
            </javadoc>
            <method name="getWhere" type="long" line="152"/>
            <javadoc line="156">
                Get the class declaration                
            </javadoc>
            <method name="getClassDeclaration" type="ClassDeclaration" line="159"/>
            <javadoc line="163">
                A stub.  Subclasses can do more checking.                
            </javadoc>
            <method name="resolveTypeStructure" type="void" line="166">
                <params>
                    <param name="env" type="Environment"/>
                </params>
            </method>
            <javadoc line="169">
                Get the class declaration in which the field is actually defined                
            </javadoc>
            <method name="getDefiningClassDeclaration" type="ClassDeclaration" line="172"/>
            <javadoc line="176">
                Get the class definition                
            </javadoc>
            <method name="getClassDefinition" type="ClassDefinition" line="179"/>
            <javadoc line="183">
                Get the field&apos;s top-level enclosing class                
            </javadoc>
            <method name="getTopClass" type="ClassDefinition" line="186"/>
            <javadoc line="190">
                Get the field&apos;s modifiers                
            </javadoc>
            <method name="getModifiers" type="int" line="193"/>
            <method name="subModifiers" type="void" line="196">
                <params>
                    <param name="mod" type="int"/>
                </params>
            </method>
            <method name="addModifiers" type="void" line="199">
                <params>
                    <param name="mod" type="int"/>
                </params>
            </method>
            <javadoc line="203">
                Get the field&apos;s type                
            </javadoc>
            <method name="getType" type="Type" line="206"/>
            <javadoc line="210">
                Get the field&apos;s name                
            </javadoc>
            <method name="getName" type="Identifier" line="213"/>
            <javadoc line="217">
                Get arguments (a vector of LocalMember)                
            </javadoc>
            <method name="getArguments" type="Vector" line="220"/>
            <javadoc line="224">
                Get the exceptions that are thrown by this method.                
            </javadoc>
            <method name="getExceptions" type="ClassDeclaration[]" line="227">
                <params>
                    <param name="env" type="Environment"/>
                </params>
                <comment line="233">
                    we should have translated this already!                    
                </comment>
                <scope line="228"/>
            </method>
            <method name="getExceptionIds" type="IdentifierToken[]" line="238"/>
            <javadoc line="242">
                Get an inner class.                
            </javadoc>
            <method name="getInnerClass" type="ClassDefinition" line="245"/>
            <javadoc line="249">
                Is this a synthetic field which holds a copy of,
                  or reference to, a local variable or enclosing instance?                
            </javadoc>
            <method name="isUplevelValue" type="boolean" line="253">
                <scope line="254"/>
                <declaration name="name" type="String" line="257"/>
            </method>
            <method name="isAccessMethod" type="boolean" line="263">
                <comment line="265">
                    This no longer works, because access methods
                     for constructors do not use the standard naming
                     scheme.
                        return isSynthetic() &amp;&amp; isMethod()
                            &amp;&amp; name.toString().startsWith(prefixAccess);
                     Assume that a method is an access method if it has
                     an access peer.  NOTE: An access method will not be
                     recognized as such until &apos;setAccessMethodTarget&apos; has
                     been called on it.                    
                </comment>
            </method>
            <javadoc line="276">
                Is this a synthetic method which provides access to a
                  visible private member?                
            </javadoc>
            <method name="getAccessMethodTarget" type="MemberDefinition" line="280">
                <comment line="284">
                    perhaps skip over another access for the same field                    
                </comment>
                <scope line="281">
                    <scope line="282">
                        <scope line="284"/>
                    </scope>
                </scope>
            </method>
            <method name="setAccessMethodTarget" type="void" line="293">
                <params>
                    <param name="target" type="MemberDefinition"/>
                </params>
                <comment line="296">
                    -------------------
                    if (!isAccessMethod() || accessPeer != null ||
                    target.accessPeer != null) {
                    throw new CompilerError(&quot;accessPeer&quot;);
                    }                    
                </comment>
                <scope line="294">
                    <scope line="301"/>
                </scope>
            </method>
            <javadoc line="308">
                If this method is a getter for a private field, return the setter.                
            </javadoc>
            <method name="getAccessUpdateMember" type="MemberDefinition" line="311">
                <scope line="312">
                    <scope line="313">
                        <scope line="314"/>
                    </scope>
                </scope>
            </method>
            <method name="setAccessUpdateMember" type="void" line="322">
                <params>
                    <param name="updater" type="MemberDefinition"/>
                </params>
                <scope line="323">
                    <scope line="325"/>
                </scope>
            </method>
            <javadoc line="333">
                Is this an access method for a field selection or method call
                  of the form &apos;...super.foo&apos; or &apos;...super.foo()&apos;?                
            </javadoc>
            <method name="isSuperAccessMethod" type="boolean" line="337"/>
            <javadoc line="341">
                Mark this member as an access method for a field selection
                  or method call via the &apos;super&apos; keyword.                
            </javadoc>
            <method name="setIsSuperAccessMethod" type="void" line="345">
                <params>
                    <param name="b" type="boolean"/>
                </params>
            </method>
            <javadoc line="349">
                Tell if this is a final variable without an initializer.
                  Such variables are subject to definite single assignment.                
            </javadoc>
            <method name="isBlankFinal" type="boolean" line="353"/>
            <method name="isNeverNull" type="boolean" line="357">
                <comment line="360">
                    loc$x and this$C are never null                    
                </comment>
                <scope line="358"/>
            </method>
            <javadoc line="365">
                Get the field&apos;s final value (may return null)                
            </javadoc>
            <method name="getValue" type="Node" line="368">
                <params>
                    <param name="env" type="Environment"/>
                </params>
            </method>
            <method name="getValue" type="Node" line="371"/>
            <method name="setValue" type="void" line="374">
                <params>
                    <param name="value" type="Node"/>
                </params>
            </method>
            <method name="getInitialValue" type="Object" line="377"/>
            <javadoc line="381">
                Get the next field or the next match                
            </javadoc>
            <method name="getNextMember" type="MemberDefinition" line="384"/>
            <method name="getNextMatch" type="MemberDefinition" line="387"/>
            <javadoc line="391">
                Get the field&apos;s documentation                
            </javadoc>
            <method name="getDocumentation" type="String" line="394"/>
            <javadoc line="398">
                Request a check of the field definition.                
            </javadoc>
            <method name="check" type="void" line="401">
                <params>
                    <param name="env" type="Environment"/>
                </params>
            </method>
            <javadoc line="404">
                Really check the field definition.                
            </javadoc>
            <method name="check" type="Vset" line="407">
                <params>
                    <param name="env" type="Environment"/>
                    <param name="ctx" type="Context"/>
                    <param name="vset" type="Vset"/>
                </params>
            </method>
            <javadoc line="411">
                Generate code                
            </javadoc>
            <method name="code" type="void" line="414">
                <params>
                    <param name="env" type="Environment"/>
                    <param name="asm" type="Assembler"/>
                </params>
            </method>
            <method name="codeInit" type="void" line="417">
                <params>
                    <param name="env" type="Environment"/>
                    <param name="ctx" type="Context"/>
                    <param name="asm" type="Assembler"/>
                </params>
            </method>
            <javadoc line="421">
                Tells whether to report a deprecation error for this field.                
            </javadoc>
            <method name="reportDeprecated" type="boolean" line="424">
                <params>
                    <param name="env" type="Environment"/>
                </params>
            </method>
            <javadoc line="428">
                Check if a field can reach another field (only considers
                  forward references, not the access modifiers).                
            </javadoc>
            <method name="canReach" type="boolean" line="432">
                <params>
                    <param name="env" type="Environment"/>
                    <param name="f" type="MemberDefinition"/>
                </params>
                <comment line="438">
                    They are located in the same class, and are either both
                     static or both non-static.  Check the initialization order.                    
                </comment>
                <scope line="436"/>
            </method>
            <declaration name="PUBLIC_ACCESS" type="int" line="455"/>
            <javadoc line="455">
                Constants used by getAccessLevel() to represent the access
                  modifiers as numbers.                
            </javadoc>
            <declaration name="PROTECTED_ACCESS" type="int" line="460"/>
            <declaration name="PACKAGE_ACCESS" type="int" line="461"/>
            <declaration name="PRIVATE_ACCESS" type="int" line="462"/>
            <javadoc line="464">
                Return the access modifier of this member as a number.  The idea
                  is that this number may be used to check properties like &quot;the
                  access modifier of x is more restrictive than the access
                  modifier of y&quot; with a simple inequality test:
                  &quot;x.getAccessLevel() &gt; y.getAccessLevel.
                  This is an internal utility method.                
            </javadoc>
            <method name="getAccessLevel" type="int" line="473">
                <comment line="475">
                    Could just compute this once instead of recomputing.
                     Check to see if this is worth it.                    
                </comment>
                <scope line="476"/>
                <scope line="478"/>
                <scope line="480"/>
                <scope line="482"/>
                <scope line="484"/>
            </method>
            <javadoc line="489">
                Munge our error message to report whether the override conflict
                  came from an inherited method or a declared method.                
            </javadoc>
            <method name="reportError" type="void" line="495">
                <params>
                    <param name="env" type="Environment"/>
                    <param name="errorString" type="String"/>
                    <param name="clazz" type="ClassDeclaration"/>
                    <param name="method" type="MemberDefinition"/>
                </params>
                <comment line="499">
                    For example:
                     &quot;Instance method BLAH inherited from CLASSBLAH1 cannot be
                      overridden by the static method declared in CLASSBLAH2.&quot;                    
                </comment>
                <comment line="506">
                    For example:
                     &quot;In CLASSBLAH1, instance method BLAH inherited from CLASSBLAH2
                      cannot be overridden by the static method inherited from
                      CLASSBLAH3.&quot;                    
                </comment>
                <comment line="511">
                    &quot;inherit.&quot; + errorString,                    
                </comment>
                <comment line="513">
                    clazz,                    
                </comment>
                <scope line="497"/>
                <scope line="504"/>
            </method>
            <javadoc line="518">
                Convenience method to see if two methods return the same type                
            </javadoc>
            <method name="sameReturnType" type="boolean" line="521">
                <params>
                    <param name="method" type="MemberDefinition"/>
                </params>
                <comment line="523">
                    Make sure both are methods.                    
                </comment>
                <scope line="523"/>
                <declaration name="myReturnType" type="Type" line="527"/>
                <declaration name="yourReturnType" type="Type" line="528"/>
            </method>
            <javadoc line="533">
                Check to see if `this&apos; can override/hide `method&apos;.  Caller is
                  responsible for verifying that `method&apos; has the same signature
                  as `this&apos;.  Caller is also responsible for verifying that
                  `method&apos; is visible to the class where this override is occurring.
                  This method is called for the case when class B extends A and both
                  A and B define some method.
                  &lt;pre&gt;
                  A - void foo() throws e1
                  |
                  |
                  B - void foo() throws e2
                  &lt;/pre&gt;                
            </javadoc>
            <method name="checkOverride" type="boolean" line="547">
                <params>
                    <param name="env" type="Environment"/>
                    <param name="method" type="MemberDefinition"/>
                </params>
            </method>
            <javadoc line="551">
                Checks whether `this&apos; can override `method&apos;.  It `clazz&apos; is
                  null, it reports the errors in the class where `this&apos; is
                  declared.  If `clazz&apos; is not null, it reports the error in `clazz&apos;.                
            </javadoc>
            <method name="checkOverride" type="boolean" line="558">
                <params>
                    <param name="env" type="Environment"/>
                    <param name="method" type="MemberDefinition"/>
                    <param name="clazz" type="ClassDeclaration"/>
                </params>
                <comment line="560">
                    This section of code is largely based on section 8.4.6.3
                     of the JLS.                    
                </comment>
                <comment line="565">
                    Sanity                    
                </comment>
                <comment line="570">
                    Suppress checks for synthetic methods, as the compiler presumably
                     knows what it is doing, e.g., access methods.                    
                </comment>
                <comment line="573">
                    Sanity check: We generally do not intend for one synthetic
                     method to override another, though hiding of static members
                     is expected.  This check may need to be changed if new uses
                     of synthetic methods are devised.
                    
                     Query: this code was copied from elsewhere.  What
                     exactly is the role of the !isStatic() in the test?                    
                </comment>
                <comment line="583">
                    //////////////////////////////////////////////////////////
                     NMG 2003-01-28 removed the following test because it is
                     invalidated by bridge methods inserted by the &quot;generic&quot;
                     (1.5) Java compiler.  In 1.5, this code is used,
                     indirectly, by rmic
                    
                     throw new CompilerError(&quot;checkOverride() synthetic&quot;);                    
                </comment>
                <comment line="593">
                    We trust the compiler.  (Ha!)  We&apos;re done checking.                    
                </comment>
                <comment line="597">
                    Our caller should have verified that the method had the
                     same signature.                    
                </comment>
                <comment line="605">
                    It is forbidden to `override&apos; a static method with an instance
                     method.                    
                </comment>
                <comment line="612">
                    It is forbidden to `hide&apos; an instance method with a static
                     method.                    
                </comment>
                <comment line="619">
                    We cannot override a final method.                    
                </comment>
                <comment line="625">
                    Give a warning when we override a deprecated method with
                     a non-deprecated one.
                    
                     We bend over backwards to suppress this warning if
                     the `method&apos; has not been already compiled or
                     `this&apos; has been already compiled.                    
                </comment>
                <comment line="637">
                    Visibility may not be more restrictive                    
                </comment>
                <comment line="643">
                    Return type equality                    
                </comment>
                <comment line="645">
                    //////////////////////////////////////////////////////////
                     PCJ 2003-07-30 removed the following error because it is
                     invalidated by the covariant return type feature of the
                     1.5 compiler.  The resulting check is now much looser
                     than the actual 1.5 language spec, but that should be OK
                     because this code is only still used by rmic.  See 4892308.
                    
                     reportError(env, &quot;override.different.return&quot;, clazz, method);
                     success = false;                    
                </comment>
                <comment line="657">
                    Exception agreeement                    
                </comment>
                <declaration name="success" type="boolean" line="562"/>
                <scope line="565"/>
                <scope line="571">
                    <scope line="581"/>
                </scope>
                <scope line="599"/>
                <scope line="606"/>
                <scope line="613"/>
                <scope line="619"/>
                <scope line="631"/>
                <scope line="637"/>
                <scope line="643"/>
                <scope line="657"/>
            </method>
            <javadoc line="666">
                Check to see if two method definitions are compatible, that is
                  do they have a `meet&apos;.  The meet of two methods is essentially
                  and `intersection&apos; of
                  two methods.  This method is called when some class C inherits
                  declarations for some method foo from two parents (superclass,
                  interfaces) but it does not, itself, have a declaration of foo.
                  Caller is responsible for making sure that both methods are
                  indeed visible in clazz.
                  &lt;pre&gt;
                  A - void foo() throws e1
                  \
                  \     B void foo() throws e2
                  \   /
                  \ /
                  C
                  &lt;/pre&gt;                
            </javadoc>
            <method name="checkMeet" type="boolean" line="686">
                <params>
                    <param name="env" type="Environment"/>
                    <param name="method" type="MemberDefinition"/>
                    <param name="clazz" type="ClassDeclaration"/>
                </params>
                <comment line="688">
                    This section of code is largely based on Section 8.4.6
                     and 9.4.1 of the JLS.                    
                </comment>
                <comment line="691">
                    Sanity                    
                </comment>
                <comment line="696">
                    Check for both non-abstract.                    
                </comment>
                <comment line="701">
                    If either method is non-abstract, then we need to check that
                     the abstract method can be properly overridden.  We call
                     the checkOverride method to check this and generate any errors.
                     This test must follow the previous test.                    
                </comment>
                <comment line="711">
                    Both methods are abstract.                    
                </comment>
                <comment line="713">
                    Our caller should have verified that the method has the
                     same signature.                    
                </comment>
                <comment line="721">
                    Check for return type equality                    
                </comment>
                <comment line="723">
                    More args?                    
                </comment>
                <comment line="731">
                    We don&apos;t have to check visibility -- there always
                     potentially exists a meet.  Similarly with exceptions.                    
                </comment>
                <comment line="734">
                    There does exist a meet.                    
                </comment>
                <scope line="691"/>
                <scope line="696"/>
                <scope line="704"/>
                <scope line="706"/>
                <scope line="715"/>
                <scope line="721"/>
            </method>
            <javadoc line="737">
                This method is meant to be used to determine if one of two inherited
                  methods could override the other.  Unlike checkOverride(), failure
                  is not an error.  This method is only meant to be called after
                  checkMeet() has succeeded on the two methods.
                  If you call couldOverride() without doing a checkMeet() first, then
                  you are on your own.                
            </javadoc>
            <method name="couldOverride" type="boolean" line="747">
                <params>
                    <param name="env" type="Environment"/>
                    <param name="method" type="MemberDefinition"/>
                </params>
                <comment line="750">
                    Sanity                    
                </comment>
                <comment line="755">
                    couldOverride() is only called with `this&apos; and `method&apos; both
                     being inherited methods.  Neither of them is defined in the
                     class which we are currently working on.  Even though an
                     abstract method defined *in* a class can override a non-abstract
                     method defined in a superclass, an abstract method inherited
                     from an interface *never* can override a non-abstract method.
                     This comment may sound odd, but that&apos;s the way inheritance is.
                     The following check makes sure we aren&apos;t trying to override
                     an inherited non-abstract definition with an abstract definition
                     from an interface.                    
                </comment>
                <comment line="769">
                    Visibility should be less restrictive                    
                </comment>
                <comment line="774">
                    Exceptions                    
                </comment>
                <comment line="779">
                    Potentially some deprecation warnings could be given here
                     when we merge two abstract methods, one of which is deprecated.
                     This is not currently reported.                    
                </comment>
                <scope line="750"/>
                <scope line="764"/>
                <scope line="769"/>
                <scope line="774"/>
            </method>
            <javadoc line="785">
                Check to see if the exceptions of `this&apos; fit within the
                  exceptions of `method&apos;.                
            </javadoc>
            <method name="exceptionsFit" type="boolean" line="790">
                <params>
                    <param name="env" type="Environment"/>
                    <param name="method" type="MemberDefinition"/>
                </params>
                <comment line="792">
                    my exceptions                    
                </comment>
                <comment line="793">
                    parent&apos;s                    
                </comment>
                <comment line="795">
                    This code is taken nearly verbatim from the old implementation
                     of checkOverride() in SourceClass.                    
                </comment>
                <comment line="813">
                    the throws was neither something declared by a parent,
                     nor one of the ignorables.                    
                </comment>
                <comment line="818">
                    We were unable to find one of the exceptions.                    
                </comment>
                <comment line="824">
                    All of the exceptions `fit&apos;.                    
                </comment>
                <declaration name="e1" type="ClassDeclaration" line="791"/>
                <declaration name="e2" type="ClassDeclaration" line="792"/>
                <scope line="797">
                    <scope line="798">
                        <declaration name="c1" type="ClassDefinition" line="799"/>
                        <scope line="800">
                            <scope line="801"/>
                        </scope>
                    </scope>
                    <scope line="816"/>
                </scope>
            </method>
            <javadoc line="829">
                Checks                
            </javadoc>
            <method name="isPublic" type="boolean" line="832"/>
            <method name="isPrivate" type="boolean" line="835"/>
            <method name="isProtected" type="boolean" line="838"/>
            <method name="isPackagePrivate" type="boolean" line="841"/>
            <method name="isFinal" type="boolean" line="844"/>
            <method name="isStatic" type="boolean" line="847"/>
            <method name="isSynchronized" type="boolean" line="850"/>
            <method name="isAbstract" type="boolean" line="853"/>
            <method name="isNative" type="boolean" line="856"/>
            <method name="isVolatile" type="boolean" line="859"/>
            <method name="isTransient" type="boolean" line="862"/>
            <method name="isMethod" type="boolean" line="865"/>
            <method name="isVariable" type="boolean" line="868"/>
            <method name="isSynthetic" type="boolean" line="871"/>
            <method name="isDeprecated" type="boolean" line="874"/>
            <method name="isStrict" type="boolean" line="877"/>
            <method name="isInnerClass" type="boolean" line="880"/>
            <method name="isInitializer" type="boolean" line="883"/>
            <method name="isConstructor" type="boolean" line="886"/>
            <method name="isLocal" type="boolean" line="889"/>
            <method name="isInlineable" type="boolean" line="892">
                <params>
                    <param name="env" type="Environment"/>
                    <param name="fromFinal" type="boolean"/>
                </params>
            </method>
            <javadoc line="897">
                Check if constant:  Will it inline away to a constant?                
            </javadoc>
            <method name="isConstant" type="boolean" line="900">
                <comment line="904">
                    If an infinite regress requeries this name,
                     deny that it is a constant.                    
                </comment>
                <scope line="901">
                    <scope line="902"/>
                    <scope line="907"/>
                </scope>
            </method>
            <javadoc line="914">
                toString                
            </javadoc>
            <method name="toString" type="String" line="917">
                <declaration name="name" type="Identifier" line="918"/>
                <scope line="919"/>
                <scope line="921">
                    <declaration name="buf" type="StringBuffer" line="922"/>
                    <declaration name="argTypes" type="Type" line="925"/>
                    <scope line="926">
                        <scope line="927"/>
                    </scope>
                </scope>
                <scope line="934"/>
            </method>
            <javadoc line="940">
                Print for debugging                
            </javadoc>
            <method name="print" type="void" line="943">
                <params>
                    <param name="out" type="PrintStream"/>
                </params>
                <scope line="944"/>
                <scope line="947"/>
                <scope line="950"/>
                <scope line="953"/>
                <scope line="956"/>
                <scope line="959"/>
                <scope line="962"/>
                <scope line="965"/>
                <scope line="968"/>
                <scope line="971"/>
            </method>
            <method name="cleanup" type="void" line="977">
                <params>
                    <param name="env" type="Environment"/>
                </params>
                <comment line="988">
                    will never be inlined                    
                </comment>
                <scope line="979">
                    <declaration name="cost" type="int" line="980"/>
                    <scope line="981"/>
                    <scope line="986"/>
                    <scope line="989">
                        <scope line="990">
                            <scope line="991"/>
                        </scope>
                        <scope line="995"/>
                    </scope>
                    <scope line="997"/>
                </scope>
                <scope line="1001">
                    <scope line="1002"/>
                </scope>
            </method>
        </class>
    </source>