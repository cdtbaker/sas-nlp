<?xml version="1.0" encoding="UTF-8"?>
    <source package="sun.tools.java">
        <import package="java.io.IOException"/>
        <import package="java.io.InputStream"/>
        <import package="java.util.Hashtable"/>
        <class name="Scanner" line="32">
            <comment line="119">
                Token values.                
            </comment>
            <comment line="129">
                Radix, when reading int or long                
            </comment>
            <comment line="131">
                A doc comment preceding the most recent token                
            </comment>
            <comment line="136">
                A growable character buffer.                
            </comment>
            <comment line="147">
                The following two methods have been hand-inlined in
                 scanDocComment.  If you make changes here, you should
                 check to see if scanDocComment also needs modification.                
            </comment>
            <comment line="757">
                We have a token that parses as a number.  Is this token possibly zero?
                 i.e. does it have a non-zero value in the mantissa?                
            </comment>
            <implements interface="Constants"/>
            <javadoc line="32">
                A Scanner for Java tokens. Errors are reported
                  to the environment object.&lt;p&gt;
                  The scanner keeps track of the current token,
                  the value of the current token (if any), and the start
                  position of the current token.&lt;p&gt;
                  The scan() method advances the scanner to the next
                  token in the input.&lt;p&gt;
                  The match() method is used to quickly match opening
                  brackets (ie: &apos;(&apos;, &apos;{&apos;, or &apos;[&apos;) with their closing
                  counter part. This is useful during error recovery.&lt;p&gt;
                  An position consists of: ((linenr &lt;&lt; WHEREOFFSETBITS) | offset)
                  this means that both the line number and the exact offset into
                  the file are encoded in each position value.&lt;p&gt;
                  The compiler treats either &quot;\n&quot;, &quot;\r&quot; or &quot;\r\n&quot; as the
                  end of a line.&lt;p&gt;
                  WARNING: The contents of this source file are not part of any
                  supported API.  Code that depends on them does so at its own risk:
                  they are subject to change or removal without notice.                
                <author>
                    Arthur van Hoff                    
                </author>
            </javadoc>
            <declaration name="OFFSETINC" type="long" line="63"/>
            <javadoc line="63">
                The increment for each character.                
            </javadoc>
            <declaration name="LINEINC" type="long" line="68"/>
            <javadoc line="68">
                The increment for each line.                
            </javadoc>
            <declaration name="EOF" type="int" line="73"/>
            <javadoc line="73">
                End of input                
            </javadoc>
            <declaration name="env" type="Environment" line="78"/>
            <javadoc line="78">
                Where errors are reported                
            </javadoc>
            <declaration name="in" type="ScannerInputReader" line="83"/>
            <javadoc line="83">
                Input reader                
            </javadoc>
            <declaration name="scanComments" type="boolean" line="88"/>
            <javadoc line="88">
                If true, present all comments as tokens.
                  Contents are not saved, but positions are recorded accurately,
                  so the comment can be recovered from the text.
                  Line terminations are also returned as comment tokens,
                  and may be distinguished by their start and end positions,
                  which are equal (meaning, these tokens contain no chars).                
            </javadoc>
            <declaration name="token" type="int" line="98"/>
            <javadoc line="98">
                Current token                
            </javadoc>
            <declaration name="pos" type="long" line="103"/>
            <javadoc line="103">
                The position of the current token                
            </javadoc>
            <declaration name="prevPos" type="long" line="108"/>
            <javadoc line="108">
                The position of the previous token                
            </javadoc>
            <declaration name="ch" type="int" line="113"/>
            <javadoc line="113">
                The current character                
            </javadoc>
            <declaration name="charValue" type="char" line="121"/>
            <declaration name="intValue" type="int" line="122"/>
            <declaration name="longValue" type="long" line="123"/>
            <declaration name="floatValue" type="float" line="124"/>
            <declaration name="doubleValue" type="double" line="125"/>
            <declaration name="stringValue" type="String" line="126"/>
            <declaration name="idValue" type="Identifier" line="127"/>
            <declaration name="radix" type="int" line="128"/>
            <declaration name="docComment" type="String" line="133"/>
            <declaration name="count" type="int" line="138"/>
            <declaration name="buffer" type="char" line="139"/>
            <method name="growBuffer" type="void" line="140">
                <declaration name="newBuffer" type="char" line="141"/>
            </method>
            <method name="putc" type="void" line="149">
                <params>
                    <param name="ch" type="int"/>
                </params>
                <scope line="150"/>
            </method>
            <method name="bufferString" type="String" line="156"/>
            <javadoc line="160">
                Create a scanner to scan an input stream.                
            </javadoc>
            <method name="Scanner" type="constructor" line="163">
                <params>
                    <param name="env" type="Environment"/>
                    <param name="in" type="InputStream"/>
                </params>
            </method>
            <javadoc line="168">
                Setup input from the given input stream,
                  and scan the first token from it.                
            </javadoc>
            <method name="useInputStream" type="void" line="172">
                <params>
                    <param name="in" type="InputStream"/>
                </params>
                <scope line="173"/>
                <scope line="175"/>
            </method>
            <javadoc line="186">
                Create a scanner to scan an input stream.                
            </javadoc>
            <method name="Scanner" type="constructor" line="189">
                <params>
                    <param name="env" type="Environment"/>
                </params>
                <comment line="192">
                    Expect the subclass to call useInputStream at the right time.                    
                </comment>
            </method>
            <javadoc line="194">
                Define a keyword.                
            </javadoc>
            <method name="defineKeyword" type="void" line="197">
                <params>
                    <param name="val" type="int"/>
                </params>
            </method>
            <javadoc line="201">
                Initialized keyword and token Hashtables                
            </javadoc>
            <scope line="204"/>
            <javadoc line="269">
                Scan a comment. This method should be
                  called once the initial /,  and the next
                  character have been read.                
            </javadoc>
            <method name="skipComment" type="void" line="274">
                <scope line="275">
                    <scope line="282"/>
                </scope>
            </method>
            <javadoc line="295">
                Scan a doc comment. This method should be called
                  once the initial /,  and  have been read. It gathers
                  the content of the comment (witout leading spaces and &apos;&apos;s)
                  in the string buffer.                
            </javadoc>
            <method name="scanDocComment" type="String" line="301">
                <comment line="303">
                    Note: this method has been hand-optimized to yield
                     better performance.  This was done after it was noted
                     that javadoc spent a great deal of its time here.
                     This should also help the performance of the compiler
                     as well -- it scans the doc comments to find
                     @deprecated tags.
                    
                     The logic of the method has been completely rewritten
                     to avoid the use of flags that need to be looked at
                     for every character read.  Members that are accessed
                     more than once have been stored in local variables.
                     The methods putc() and bufferString() have been
                     inlined by hand.  Extra cases have been added to
                     switch statements to trick the compiler into generating
                     a tableswitch instead of a lookupswitch.
                    
                     This implementation aims to preserve the previous
                     behavior of this method.                    
                </comment>
                <comment line="324">
                    Put `in&apos; in a local variable.                    
                </comment>
                <comment line="327">
                    We maintain the buffer locally rather than calling putc().                    
                </comment>
                <comment line="331">
                    We are called pointing at the second star of the doc
                     comment:
                    
                     Input: /** the rest of the comment ... */
                              ^
                    
                     We rely on this in the code below.                    
                </comment>
                <comment line="339">
                    Consume any number of stars.                    
                </comment>
                <comment line="343">
                    Is the comment of the form /**/, /***/, /****/, etc.?                    
                </comment>
                <comment line="345">
                    Set ch and return                    
                </comment>
                <comment line="350">
                    Skip a newline on the first line of the comment.                    
                </comment>
                <comment line="356">
                    The outerLoop processes the doc comment, looping once
                     for each line.  For each line, it first strips off
                     whitespace, then it consumes any stars, then it
                     puts the rest of the line into our buffer.                    
                </comment>
                <comment line="362">
                    The wsLoop consumes whitespace from the beginning
                     of each line.                    
                </comment>
                <comment line="369">
                    We could check for other forms of whitespace
                     as well, but this is left as is for minimum
                     disturbance of functionality.
                    
                     Just skip whitespace.                    
                </comment>
                <comment line="377">
                    We have added extra cases here to trick the
                     compiler into using a tableswitch instead of
                     a lookupswitch.  They can be removed without
                     a change in meaning.                    
                </comment>
                <comment line="386">
                    We&apos;ve seen something that isn&apos;t whitespace,
                     jump out.                    
                </comment>
                <comment line="390">
                    end wsLoop.                    
                </comment>
                <comment line="392">
                    Are there stars here?  If so, consume them all
                     and check for the end of comment.                    
                </comment>
                <comment line="395">
                    Skip all of the stars...                    
                </comment>
                <comment line="400">
                    ...then check for the closing slash.                    
                </comment>
                <comment line="402">
                    We&apos;re done with the doc comment.
                     Set ch and break out.                    
                </comment>
                <comment line="409">
                    The textLoop processes the rest of the characters
                     on the line, adding them to our buffer.                    
                </comment>
                <comment line="415">
                    We&apos;ve seen a premature EOF.  Break out
                     of the loop.                    
                </comment>
                <comment line="422">
                    Is this just a star?  Or is this the
                     end of a comment?                    
                </comment>
                <comment line="426">
                    This is the end of the comment,
                     set ch and return our buffer.                    
                </comment>
                <comment line="431">
                    This is just an ordinary star.  Add it to
                     the buffer.                    
                </comment>
                <comment line="441">
                    We&apos;ve seen a newline.  Add it to our
                     buffer and break out of this loop,
                     starting fresh on a new line.                    
                </comment>
                <comment line="452">
                    Again, the extra cases here are a trick
                     to get the compiler to generate a tableswitch.                    
                </comment>
                <comment line="462">
                    Add the character to our buffer.                    
                </comment>
                <comment line="471">
                    end textLoop                    
                </comment>
                <comment line="472">
                    end outerLoop                    
                </comment>
                <comment line="474">
                    We have scanned our doc comment.  It is stored in
                     buffer.  The previous implementation of scanDocComment
                     stripped off all trailing spaces and stars from the comment.
                     We will do this as well, so as to cause a minimum of
                     disturbance.  Is this what we want?                    
                </comment>
                <comment line="489">
                    And again, the extra cases here are a trick
                     to get the compiler to generate a tableswitch.                    
                </comment>
                <comment line="504">
                    Return the text of the doc comment.                    
                </comment>
                <declaration name="c" type="int" line="321"/>
                <declaration name="in" type="ScannerInputReader" line="324"/>
                <declaration name="buffer" type="char[]" line="327"/>
                <declaration name="count" type="int" line="328"/>
                <scope line="343"/>
                <scope line="350"/>
                <scope line="359">
                    <scope line="364"/>
                    <scope line="393">
                        <scope line="395"/>
                        <scope line="400"/>
                    </scope>
                    <scope line="411">
                        <scope line="424"/>
                        <scope line="432"/>
                        <scope line="443"/>
                        <scope line="462"/>
                    </scope>
                </scope>
                <scope line="478">
                    <declaration name="i" type="int" line="479"/>
                    <scope line="481"/>
                </scope>
                <scope line="505"/>
            </method>
            <javadoc line="510">
                Scan a number. The first digit of the number should be the current
                  character.  We may be scanning hex, decimal, or octal at this point                
            </javadoc>
            <method name="scanNumber" type="void" line="514">
                <comment line="518">
                    used to detect invalid hex number 0xL                    
                </comment>
                <comment line="522">
                    save character in buffer                    
                </comment>
                <comment line="528">
                    an illegal character                    
                </comment>
                <comment line="533">
                    We can&apos;t yet throw an error if reading an octal.  We might
                     discover we&apos;re really reading a real.                    
                </comment>
                <comment line="558">
                    fall through                    
                </comment>
                <comment line="563">
                    an illegal character                    
                </comment>
                <comment line="570">
                    skip over &apos;l&apos;                    
                </comment>
                <comment line="576">
                    if the first character is a &apos;0&apos; and this is the second
                     letter, then read in a hexadecimal number.  Otherwise, error.                    
                </comment>
                <comment line="583">
                    we&apos;ll get an illegal character error                    
                </comment>
                <comment line="592">
                    while true                    
                </comment>
                <comment line="594">
                    We have just finished reading the number.  The next thing better
                     not be a letter or digit.
                     Note:  There will be deprecation warnings against these uses
                     of Character.isJavaLetterOrDigit and Character.isJavaLetter.
                     Do not fix them yet; allow the compiler to run on pre-JDK1.1 VMs.                    
                </comment>
                <comment line="606">
                    A bogus octal literal.                    
                </comment>
                <comment line="611">
                    A hex literal with no digits, 0xL, for example.                    
                </comment>
                <comment line="617">
                    Check for overflow.  Note that base 10 literals
                     have different rules than base 8 and 16.                    
                </comment>
                <comment line="626">
                    Give a specific error message which tells
                     the user the range.                    
                </comment>
                <comment line="646">
                    Give a specific error message which tells
                     the user the range.                    
                </comment>
                <declaration name="seenNonOctal" type="boolean" line="515"/>
                <declaration name="overflow" type="boolean" line="516"/>
                <declaration name="seenDigit" type="boolean" line="517"/>
                <declaration name="value" type="long" line="519"/>
                <scope line="523">
                    <scope line="539"/>
                    <scope line="543"/>
                    <scope line="546"/>
                    <scope line="553"/>
                    <scope line="577"/>
                    <scope line="581"/>
                </scope>
                <scope line="598">
                    <scope line="600"/>
                </scope>
                <scope line="604"/>
                <scope line="609"/>
                <scope line="614">
                    <scope line="615">
                        <scope line="622"/>
                    </scope>
                    <scope line="641">
                        <scope line="642"/>
                    </scope>
                </scope>
            </method>
            <javadoc line="665">
                Scan a float.  We are either looking at the decimal, or we have already
                  seen it and put it into the buffer.  We haven&apos;t seen an exponent.
                  Scan a float.  Should be called with the current character is either
                  the &apos;e&apos;, &apos;E&apos; or &apos;.&apos;                
            </javadoc>
            <method name="scanReal" type="void" line="671">
                <comment line="691">
                    we&apos;ll get a format error                    
                </comment>
                <comment line="699">
                    this isn&apos;t an error, though!                    
                </comment>
                <comment line="704">
                    skip over &apos;f&apos;                    
                </comment>
                <comment line="709">
                    skip over &apos;d&apos;                    
                </comment>
                <comment line="710">
                    fall through                    
                </comment>
                <comment line="713">
                    sswitch                    
                </comment>
                <comment line="714">
                    loop                    
                </comment>
                <comment line="716">
                    we have just finished reading the number.  The next thing better
                     not be a letter or digit.                    
                </comment>
                <declaration name="seenExponent" type="boolean" line="672"/>
                <declaration name="isSingleFloat" type="boolean" line="673"/>
                <declaration name="lastChar" type="char" line="674"/>
                <scope line="675"/>
                <scope line="681"/>
                <scope line="717">
                    <scope line="719"/>
                </scope>
                <scope line="723">
                    <scope line="725">
                        <scope line="728"/>
                        <scope line="730">
                            <declaration name="string" type="String" line="731"/>
                            <scope line="733"/>
                            <scope line="735"/>
                        </scope>
                        <scope line="738">
                            <declaration name="string" type="String" line="739"/>
                            <scope line="741"/>
                            <scope line="743"/>
                        </scope>
                    </scope>
                    <scope line="747"/>
                </scope>
            </method>
            <method name="looksLikeZero" type="boolean" line="758">
                <params>
                    <param name="token" type="String"/>
                </params>
                <declaration name="length" type="int" line="759"/>
                <scope line="760"/>
            </method>
            <javadoc line="774">
                Scan an escape character.                
                <return>
                    the character or -1 if it escaped an
                      end-of-line.                    
                </return>
            </javadoc>
            <method name="scanEscapeChar" type="int" line="779">
                <declaration name="p" type="long" line="780"/>
                <scope line="784">
                    <declaration name="n" type="int" line="785"/>
                    <scope line="786">
                        <scope line="794"/>
                    </scope>
                    <scope line="801"/>
                </scope>
            </method>
            <javadoc line="822">
                Scan a string. The current character
                  should be the opening &quot; of the string.                
            </javadoc>
            <method name="scanString" type="void" line="826">
                <comment line="832">
                    Scan a String                    
                </comment>
                <scope line="832">
                    <scope line="851">
                        <declaration name="c" type="int" line="852"/>
                        <scope line="853"/>
                    </scope>
                </scope>
            </method>
            <javadoc line="867">
                Scan a character. The current character should be
                  the opening &apos; of the character constant.                
            </javadoc>
            <method name="scanCharacter" type="void" line="871">
                <comment line="882">
                    There are two standard problems this case deals with.  One
                     is the malformed single quote constant (i.e. the programmer
                     uses &apos;&apos;&apos; instead of &apos;\&apos;&apos;) and the other is the empty
                     character constant (i.e. &apos;&apos;).  Just consume any number of
                     single quotes and emit an error message.                    
                </comment>
                <declaration name="c" type="int" line="876"/>
                <scope line="889"/>
                <scope line="906"/>
                <scope line="908">
                    <scope line="910"/>
                </scope>
            </method>
            <javadoc line="926">
                Scan an Identifier. The current character should
                  be the first character of the identifier.                
            </javadoc>
            <method name="scanIdentifier" type="void" line="930">
                <scope line="933">
                    <scope line="954"/>
                </scope>
            </method>
            <javadoc line="963">
                The ending position of the current token                
            </javadoc>
            <method name="getEndPos" type="long" line="967">
                <comment line="967">
                    Note: This should be part of the pos itself.                    
                </comment>
            </method>
            <javadoc line="971">
                If the current token is IDENT, return the identifier occurrence.
                  It will be freshly allocated.                
            </javadoc>
            <method name="getIdToken" type="IdentifierToken" line="975"/>
            <javadoc line="979">
                Scan the next token.                
                <return>
                    the position of the previous token.                    
                </return>
            </javadoc>
            <method name="scan" type="long" line="983"/>
            <method name="xscan" type="long" line="987">
                <comment line="1004">
                    Avoid this path the next time around.
                     Do not just call in.read; we want to present
                     a null token (and also avoid read-ahead).                    
                </comment>
                <comment line="1019">
                    Parse a // comment                    
                </comment>
                <comment line="1299">
                    Our one concession to DOS.                    
                </comment>
                <declaration name="in" type="ScannerInputReader" line="988"/>
                <declaration name="retPos" type="long" line="989"/>
                <scope line="992">
                    <scope line="1001"/>
                    <scope line="1020"/>
                    <scope line="1028"/>
                    <scope line="1030"/>
                    <scope line="1033"/>
                    <scope line="1163"/>
                    <scope line="1189"/>
                    <scope line="1239"/>
                    <scope line="1248"/>
                    <scope line="1257"/>
                    <scope line="1266"/>
                    <scope line="1275"/>
                    <scope line="1299"/>
                    <scope line="1309"/>
                </scope>
            </method>
            <javadoc line="1320">
                Scan to a matching &apos;}&apos;, &apos;]&apos; or &apos;)&apos;. The current token must be
                  a &apos;{&apos;, &apos;[&apos; or &apos;(&apos;;                
            </javadoc>
            <method name="match" type="void" line="1324">
                <params>
                    <param name="open" type="int"/>
                    <param name="close" type="int"/>
                </params>
                <declaration name="depth" type="int" line="1325"/>
                <scope line="1327">
                    <scope line="1329"/>
                    <scope line="1331">
                        <scope line="1332"/>
                    </scope>
                    <scope line="1335"/>
                </scope>
            </method>
        </class>
    </source>