<?xml version="1.0" encoding="UTF-8"?>
    <source package="sun.tools.java">
        <import package="sun.tools.tree"/>
        <import package="java.io.IOException"/>
        <import package="java.io.InputStream"/>
        <import package="java.util.Enumeration"/>
        <import package="java.util.Vector"/>
        <class name="Parser" line="34">
            <extends class="Scanner"/>
            <comment line="109">
                Note:  The duplication of methods allows pre-1.1 classes to
                 be binary compatible with the new version of the parser,
                 which now passes IdentifierTokens to the semantics phase,
                 rather than just Identifiers.  This change is necessary,
                 since the parser is no longer responsible for managing the
                 resolution of type names.  (That caused the &quot;Vector&quot; bug.)
                
                 In a future release, the old &quot;plain-Identifier&quot; methods will
                 go away, and the corresponding &quot;IdentifierToken&quot; methods
                 may become abstract.                
            </comment>
            <comment line="270">
                A growable array of nodes. It is used as a growable
                 buffer to hold argument lists and expression lists.
                 I&apos;m not using Vector to make it more efficient.                
            </comment>
            <comment line="1501">
                Dealing with argument lists, I&apos;m not using
                 Vector for efficiency.                
            </comment>
            <comment line="1838">
                Current strict/default state of floating point.  This is
                 set and reset with a stack discipline around methods and named
                 classes.  Only M_STRICTFP may be set in this word.  try...
                 finally is not needed to protect setting and resetting because
                 there are no error messages based on FPstate.                
            </comment>
            <comment line="2105">
                Design Note: We ought to disinherit Parser from Scanner.
                 We also should split out the interface ParserActions from
                 Parser, and make BatchParser implement ParserActions,
                 not extend Parser.  This would split scanning, parsing,
                 and class building into distinct responsibility areas.
                 (Perhaps tree building could be virtualized too.)                
            </comment>
            <implements interface="ParserActions"/>
            <implements interface="Constants"/>
            <javadoc line="34">
                This class is used to parse Java statements and expressions.
                  The result is a parse tree.&lt;p&gt;
                  This class implements an operator precedence parser. Errors are
                  reported to the Environment object, if the error can&apos;t be
                  resolved immediately, a SyntaxError exception is thrown.&lt;p&gt;
                  Error recovery is implemented by catching SyntaxError exceptions
                  and discarding input tokens until an input token is reached that
                  is possibly a legal continuation.&lt;p&gt;
                  The parse tree that is constructed represents the input
                  exactly (no rewrites to simpler forms). This is important
                  if the resulting tree is to be used for code formatting in
                  a programming environment. Currently only documentation comments
                  are retained.&lt;p&gt;
                  The parsing algorithm does NOT use any type information. Changes
                  in the type system do not affect the structure of the parse tree.
                  This restriction does introduce an ambiguity an expression of the
                  form: (e1) e2 is assumed to be a cast if e2 does not start with
                  an operator. That means that (a) - b is interpreted as subtract
                  b from a and not cast negative b to type a. However, if a is a
                  simple type (byte, int, ...) then it is assumed to be a cast.&lt;p&gt;
                  WARNING: The contents of this source file are not part of any
                  supported API.  Code that depends on them does so at its own risk:
                  they are subject to change or removal without notice.                
                <author>
                    Arthur van Hoff                    
                </author>
            </javadoc>
            <javadoc line="69">
                Create a parser                
            </javadoc>
            <method name="Parser" type="constructor" line="72">
                <params>
                    <param name="env" type="Environment"/>
                    <param name="in" type="InputStream"/>
                </params>
            </method>
            <javadoc line="78">
                Create a parser, given a scanner.                
            </javadoc>
            <method name="Parser" type="constructor" line="81">
                <params>
                    <param name="scanner" type="Scanner"/>
                </params>
            </method>
            <javadoc line="90">
                Create a parser, given a scanner and the semantic callback.                
            </javadoc>
            <method name="Parser" type="constructor" line="93">
                <params>
                    <param name="scanner" type="Scanner"/>
                    <param name="actions" type="ParserActions"/>
                </params>
            </method>
            <declaration name="actions" type="ParserActions" line="98"/>
            <javadoc line="98">
                Usually &lt;code&gt;this.actions == (ParserActions)this&lt;/code&gt;.
                  However, a delegate scanner can produce tokens for this parser,
                  in which case &lt;code&gt;(Scanner)this&lt;/code&gt; is unused,
                  except for &lt;code&gt;this.token&lt;/code&gt; and &lt;code&gt;this.pos&lt;/code&gt;
                  instance variables which are filled from the real scanner
                  by &lt;code&gt;this.scan()&lt;/code&gt; and the constructor.                
            </javadoc>
            <javadoc line="119">
                package declaration                
                <deprecated>
                                        
                </deprecated>
            </javadoc>
            <method name="packageDeclaration" type="void" line="124">
                <params>
                    <param name="off" type="long"/>
                    <param name="nm" type="IdentifierToken"/>
                </params>
                <comment line="126">
                    By default, call the deprecated version.
                     Any application must override one of the packageDeclaration methods.                    
                </comment>
            </method>
            <javadoc line="129">
                @deprecated                
            </javadoc>
            <method name="packageDeclaration" type="void" line="133">
                <params>
                    <param name="off" type="long"/>
                    <param name="nm" type="Identifier"/>
                </params>
            </method>
            <javadoc line="137">
                import class                
                <deprecated>
                                        
                </deprecated>
            </javadoc>
            <method name="importClass" type="void" line="142">
                <params>
                    <param name="off" type="long"/>
                    <param name="nm" type="IdentifierToken"/>
                </params>
                <comment line="144">
                    By default, call the deprecated version.
                     Any application must override one of the packageDeclaration methods.                    
                </comment>
            </method>
            <javadoc line="147">
                @deprecated Use the version with the IdentifierToken arguments.                
            </javadoc>
            <method name="importClass" type="void" line="151">
                <params>
                    <param name="off" type="long"/>
                    <param name="nm" type="Identifier"/>
                </params>
            </method>
            <javadoc line="155">
                import package                
                <deprecated>
                                        
                </deprecated>
            </javadoc>
            <method name="importPackage" type="void" line="160">
                <params>
                    <param name="off" type="long"/>
                    <param name="nm" type="IdentifierToken"/>
                </params>
                <comment line="162">
                    By default, call the deprecated version.
                     Any application must override one of the importPackage methods.                    
                </comment>
            </method>
            <javadoc line="165">
                @deprecated Use the version with the IdentifierToken arguments.                
            </javadoc>
            <method name="importPackage" type="void" line="169">
                <params>
                    <param name="off" type="long"/>
                    <param name="nm" type="Identifier"/>
                </params>
            </method>
            <javadoc line="173">
                Define class                
                <deprecated>
                                        
                </deprecated>
            </javadoc>
            <method name="beginClass" type="ClassDefinition" line="181">
                <params>
                    <param name="off" type="long"/>
                    <param name="doc" type="String"/>
                    <param name="mod" type="int"/>
                    <param name="nm" type="IdentifierToken"/>
                    <param name="sup" type="IdentifierToken"/>
                    <param name="impl" type="IdentifierToken"/>
                </params>
                <comment line="183">
                    By default, call the deprecated version.
                     Any application must override one of the beginClass methods.                    
                </comment>
                <declaration name="supId" type="Identifier" line="184"/>
                <declaration name="implIds" type="Identifier" line="185"/>
                <scope line="186">
                    <scope line="188"/>
                </scope>
            </method>
            <javadoc line="195">
                @deprecated Use the version with the IdentifierToken arguments.                
            </javadoc>
            <method name="beginClass" type="void" line="200">
                <params>
                    <param name="off" type="long"/>
                    <param name="doc" type="String"/>
                    <param name="mod" type="int"/>
                    <param name="nm" type="Identifier"/>
                    <param name="sup" type="Identifier"/>
                    <param name="impl" type="Identifier"/>
                </params>
            </method>
            <javadoc line="204">
                Report the current class under construction.
                  By default, it&apos;s a no-op which returns null.
                  It may only be called before the corresponding endClass().                
            </javadoc>
            <method name="getCurrentClass" type="ClassDefinition" line="209"/>
            <javadoc line="213">
                End class                
                <deprecated>
                                        
                </deprecated>
            </javadoc>
            <method name="endClass" type="void" line="218">
                <params>
                    <param name="off" type="long"/>
                    <param name="c" type="ClassDefinition"/>
                </params>
                <comment line="220">
                    By default, call the deprecated version.
                     Any application must override one of the beginClass methods.                    
                </comment>
            </method>
            <javadoc line="223">
                @deprecated Use the version with the IdentifierToken arguments.                
            </javadoc>
            <method name="endClass" type="void" line="227">
                <params>
                    <param name="off" type="long"/>
                    <param name="nm" type="Identifier"/>
                </params>
            </method>
            <javadoc line="231">
                Define a field                
                <deprecated>
                                        
                </deprecated>
            </javadoc>
            <method name="defineField" type="void" line="239">
                <params>
                    <param name="where" type="long"/>
                    <param name="c" type="ClassDefinition"/>
                    <param name="doc" type="String"/>
                    <param name="mod" type="int"/>
                    <param name="t" type="Type"/>
                    <param name="nm" type="IdentifierToken"/>
                    <param name="args" type="IdentifierToken"/>
                    <param name="exp" type="IdentifierToken"/>
                    <param name="val" type="Node"/>
                </params>
                <comment line="241">
                    By default, call the deprecated version.
                     Any application must override one of the defineField methods.                    
                </comment>
                <declaration name="argIds" type="Identifier" line="242"/>
                <declaration name="expIds" type="Identifier" line="243"/>
                <scope line="244">
                    <scope line="246"/>
                </scope>
                <scope line="250">
                    <scope line="252"/>
                </scope>
            </method>
            <javadoc line="259">
                @deprecated Use the version with the IdentifierToken arguments.                
            </javadoc>
            <method name="defineField" type="void" line="265">
                <params>
                    <param name="where" type="long"/>
                    <param name="doc" type="String"/>
                    <param name="mod" type="int"/>
                    <param name="t" type="Type"/>
                    <param name="nm" type="Identifier"/>
                    <param name="args" type="Identifier"/>
                    <param name="exp" type="Identifier"/>
                    <param name="val" type="Node"/>
                </params>
            </method>
            <declaration name="args" type="Node" line="274"/>
            <declaration name="argIndex" type="int" line="275"/>
            <method name="addArgument" type="void" line="277">
                <params>
                    <param name="n" type="Node"/>
                </params>
                <scope line="278">
                    <declaration name="newArgs" type="Node" line="279"/>
                </scope>
            </method>
            <method name="exprArgs" type="Expression" line="285">
                <params>
                    <param name="index" type="int"/>
                </params>
                <declaration name="e" type="Expression" line="286"/>
            </method>
            <method name="statArgs" type="Statement" line="291">
                <params>
                    <param name="index" type="int"/>
                </params>
                <declaration name="s" type="Statement" line="292"/>
            </method>
            <javadoc line="298">
                Expect a token, return its value, scan the next token or
                  throw an exception.                
            </javadoc>
            <method name="expect" type="void" line="302">
                <params>
                    <param name="t" type="int"/>
                </params>
                <scope line="303"/>
            </method>
            <javadoc line="317">
                Parse a type expression. Does not parse the []&apos;s.                
            </javadoc>
            <method name="parseTypeExpression" type="Expression" line="320">
                <declaration name="e" type="Expression" line="341"/>
                <scope line="343"/>
            </method>
            <javadoc line="354">
                Parse a method invocation. Should be called when the current
                  then is the &apos;(&apos; of the argument list.                
            </javadoc>
            <method name="parseMethodExpression" type="Expression" line="358">
                <params>
                    <param name="e" type="Expression"/>
                    <param name="id" type="Identifier"/>
                </params>
                <declaration name="p" type="long" line="359"/>
                <declaration name="i" type="int" line="360"/>
                <scope line="361">
                    <scope line="363"/>
                </scope>
            </method>
            <javadoc line="372">
                Parse a new instance expression.  Should be called when the current
                  token is the &apos;(&apos; of the argument list.                
            </javadoc>
            <method name="parseNewInstanceExpression" type="Expression" line="376">
                <params>
                    <param name="p" type="long"/>
                    <param name="outerArg" type="Expression"/>
                    <param name="type" type="Expression"/>
                </params>
                <comment line="391">
                    x = new Type(arg) { subclass body ... }                    
                </comment>
                <comment line="401">
                    error recovery                    
                </comment>
                <declaration name="i" type="int" line="377"/>
                <scope line="379">
                    <scope line="381"/>
                </scope>
                <declaration name="body" type="ClassDefinition" line="387"/>
                <scope line="388">
                    <declaration name="tp" type="long" line="389"/>
                    <declaration name="superName" type="Identifier" line="391"/>
                    <scope line="392"/>
                    <declaration name="ext" type="Vector" line="395"/>
                    <declaration name="impl" type="Vector" line="396"/>
                    <scope line="398"/>
                </scope>
                <scope line="406"/>
            </method>
            <javadoc line="412">
                Parse a primary expression.                
            </javadoc>
            <method name="parseTerm" type="Expression" line="415">
                <comment line="538">
                    bracketed-expr: (expr)                    
                </comment>
                <comment line="544">
                    cast-expr: (simple-type) expr                    
                </comment>
                <comment line="550">
                    We handle INC and DEC specially.
                     See the discussion in JLS section 15.14.1.
                     (Part of fix for 4044502.)                    
                </comment>
                <comment line="555">
                    We know this must be a postfix increment.                    
                </comment>
                <comment line="559">
                    We know this must be a postfix decrement.                    
                </comment>
                <comment line="578">
                    cast-expr: (expr) expr                    
                </comment>
                <comment line="585">
                    array initializer: {expr1, expr2, ... exprn}                    
                </comment>
                <comment line="633">
                    System.err.println(&quot;NEAR: &quot; + opNames[token]);                    
                </comment>
                <scope line="417">
                    <declaration name="v" type="char" line="418"/>
                </scope>
                <scope line="421">
                    <declaration name="v" type="int" line="422"/>
                    <declaration name="q" type="long" line="423"/>
                </scope>
                <scope line="427">
                    <declaration name="v" type="long" line="428"/>
                    <declaration name="q" type="long" line="429"/>
                </scope>
                <scope line="433">
                    <declaration name="v" type="float" line="434"/>
                </scope>
                <scope line="437">
                    <declaration name="v" type="double" line="438"/>
                </scope>
                <scope line="441">
                    <declaration name="v" type="String" line="442"/>
                </scope>
                <scope line="445">
                    <declaration name="v" type="Identifier" line="446"/>
                    <declaration name="p" type="long" line="447"/>
                </scope>
                <scope line="459">
                    <declaration name="e" type="Expression" line="460"/>
                </scope>
                <scope line="463">
                    <declaration name="e" type="Expression" line="464"/>
                </scope>
                <scope line="479">
                    <declaration name="p" type="long" line="480"/>
                    <scope line="482">
                        <declaration name="v" type="int" line="483"/>
                        <declaration name="q" type="long" line="484"/>
                    </scope>
                    <scope line="488">
                        <declaration name="v" type="long" line="489"/>
                        <declaration name="q" type="long" line="490"/>
                    </scope>
                    <scope line="494">
                        <declaration name="v" type="float" line="495"/>
                    </scope>
                    <scope line="498">
                        <declaration name="v" type="double" line="499"/>
                    </scope>
                </scope>
                <scope line="505">
                    <declaration name="p" type="long" line="506"/>
                    <scope line="508">
                        <declaration name="v" type="int" line="509"/>
                    </scope>
                    <scope line="512">
                        <declaration name="v" type="long" line="513"/>
                    </scope>
                    <scope line="516">
                        <declaration name="v" type="float" line="517"/>
                    </scope>
                    <scope line="520">
                        <declaration name="v" type="double" line="521"/>
                    </scope>
                </scope>
                <scope line="536">
                    <declaration name="p" type="long" line="538"/>
                    <declaration name="e" type="Expression" line="539"/>
                    <scope line="542"/>
                </scope>
                <scope line="583">
                    <declaration name="p" type="long" line="585"/>
                    <declaration name="i" type="int" line="586"/>
                    <scope line="587">
                        <scope line="589">
                            <scope line="591"/>
                        </scope>
                    </scope>
                </scope>
                <scope line="601">
                    <declaration name="p" type="long" line="602"/>
                    <declaration name="i" type="int" line="603"/>
                    <scope line="605">
                        <declaration name="e" type="Expression" line="607"/>
                    </scope>
                    <declaration name="e" type="Expression" line="613"/>
                    <scope line="615">
                        <scope line="616"/>
                        <declaration name="dims" type="Expression[]" line="621"/>
                        <scope line="622"/>
                    </scope>
                    <scope line="626"/>
                </scope>
            </method>
            <javadoc line="637">
                Parse an expression.                
            </javadoc>
            <method name="parseExpression" type="Expression" line="640">
                <comment line="648">
                    this return is bogus                    
                </comment>
                <scope line="641">
                    <declaration name="more" type="Expression" line="642"/>
                </scope>
            </method>
            <javadoc line="651">
                Given a left-hand term, parse an operator and right-hand term.                
            </javadoc>
            <method name="parseBinaryExpression" type="Expression" line="654">
                <params>
                    <param name="e" type="Expression"/>
                </params>
                <comment line="659">
                    index: expr1[expr2]                    
                </comment>
                <comment line="676">
                    class C { class N { ... C.this ... } }
                     class C { class N { N(C c){ ... c.this() ... } } }                    
                </comment>
                <comment line="688">
                    class D extends C.N { D(C.N n) { n.super(); } }
                     Also, &apos;C.super&apos;, as in:
                     class C extends CS { class N { ... C.super.foo ... } }
                     class C extends CS { class N { ... C.super.foo() ... } }                    
                </comment>
                <comment line="697">
                    We must check elsewhere that this expression
                     does not stand alone, but qualifies a member name.                    
                </comment>
                <comment line="704">
                    new C().new N()                    
                </comment>
                <comment line="712">
                    just class literals, really
                     Class c = C.class;                    
                </comment>
                <comment line="829">
                    The grammar in the JLS does not allow assignment
                     expressions as the third part of a ?: expression.
                     Even though javac has no trouble parsing this,
                     check for this case and signal an error.
                     (fix for bug 4092958)                    
                </comment>
                <comment line="844">
                    mark end of binary expressions                    
                </comment>
                <comment line="847">
                    return more binary expression stuff                    
                </comment>
                <scope line="655">
                    <scope line="657">
                        <declaration name="p" type="long" line="659"/>
                        <declaration name="index" type="Expression" line="660"/>
                    </scope>
                    <scope line="672">
                        <declaration name="p" type="long" line="673"/>
                        <scope line="674">
                            <declaration name="q" type="long" line="677"/>
                            <scope line="678"/>
                            <scope line="681"/>
                        </scope>
                        <scope line="686">
                            <declaration name="q" type="long" line="691"/>
                            <scope line="692"/>
                            <scope line="695"/>
                        </scope>
                        <scope line="702"/>
                        <scope line="710"/>
                        <declaration name="id" type="Identifier" line="717"/>
                        <scope line="719"/>
                        <scope line="721"/>
                    </scope>
                    <scope line="822">
                        <declaration name="p" type="long" line="823"/>
                        <declaration name="second" type="Expression" line="824"/>
                        <declaration name="third" type="Expression" line="826"/>
                        <scope line="834"/>
                    </scope>
                </scope>
            </method>
            <javadoc line="849">
                Recover after a syntax error in a statement. This involves
                  discarding tokens until EOF or a possible continuation is
                  encountered.                
            </javadoc>
            <method name="recoverStatement" type="boolean" line="854">
                <comment line="871">
                    begin of a statement, return                    
                </comment>
                <comment line="882">
                    begin of something outside a statement, panic some more                    
                </comment>
                <comment line="897">
                    don&apos;t know what to do, skip                    
                </comment>
                <scope line="855"/>
            </method>
            <javadoc line="903">
                Parse declaration, called after the type expression
                  has been parsed and the current token is IDENT.                
            </javadoc>
            <method name="parseDeclaration" type="Statement" line="907">
                <params>
                    <param name="p" type="long"/>
                    <param name="mod" type="int"/>
                    <param name="type" type="Expression"/>
                </params>
                <declaration name="i" type="int" line="908"/>
                <scope line="909">
                    <scope line="911"/>
                </scope>
            </method>
            <javadoc line="919">
                Check if an expression is a legal toplevel expression.
                  Only method, inc, dec, and new expression are allowed.                
            </javadoc>
            <method name="topLevelExpression" type="void" line="923">
                <params>
                    <param name="e" type="Expression"/>
                </params>
            </method>
            <javadoc line="948">
                Parse a statement.                
            </javadoc>
            <method name="parseStatement" type="Statement" line="951">
                <comment line="961">
                    if-statement: if (expr) stat
                     if-statement: if (expr) stat else stat                    
                </comment>
                <comment line="978">
                    else-statement: else stat                    
                </comment>
                <comment line="984">
                    for-statement: for (decl-expr? ; expr? ; expr?) stat                    
                </comment>
                <comment line="999">
                    should have been a declaration                    
                </comment>
                <comment line="1031">
                    while-statement: while (expr) stat                    
                </comment>
                <comment line="1041">
                    do-statement: do stat while (expr)                    
                </comment>
                <comment line="1054">
                    break-statement: break ;                    
                </comment>
                <comment line="1067">
                    continue-statement: continue ;                    
                </comment>
                <comment line="1080">
                    return-statement: return ;
                     return-statement: return expr ;                    
                </comment>
                <comment line="1093">
                    switch statement: switch ( expr ) stat                    
                </comment>
                <comment line="1107">
                    case-statement: case expr:                    
                </comment>
                <comment line="1113">
                    default-statement: default:                    
                </comment>
                <comment line="1134">
                    case-statement: case expr : stat                    
                </comment>
                <comment line="1145">
                    default-statement: default : stat                    
                </comment>
                <comment line="1153">
                    try-statement: try stat catch (type-expr ident) stat finally stat                    
                </comment>
                <comment line="1155">
                    try-object specification                    
                </comment>
                <comment line="1167">
                    leave check for try (T x, y) for semantic phase                    
                </comment>
                <comment line="1170">
                    should have been a declaration                    
                </comment>
                <comment line="1180">
                    s = new FinallyStatement(p, init, s, 0);                    
                </comment>
                <comment line="1192">
                    We only catch Throwable&apos;s, so this is no longer required
                     while (token == LSQBRACKET) {
                        t = new ArrayAccessExpression(scan(), t, null);
                        expect(RSQBRACKET);
                     }                    
                </comment>
                <comment line="1217">
                    catch-statement: catch (expr ident) stat finally stat                    
                </comment>
                <comment line="1239">
                    finally-statement: finally stat                    
                </comment>
                <comment line="1246">
                    throw-statement: throw expr;                    
                </comment>
                <comment line="1262">
                    synchronized-statement: synchronized (expr) stat                    
                </comment>
                <comment line="1272">
                    Inner class.                    
                </comment>
                <comment line="1279">
                    a declaration of some sort                    
                </comment>
                <comment line="1282">
                    A class which is local to a block is not a member, and so
                     cannot be public, private, protected, or static. It is in
                     effect private to the block, since it cannot be used outside
                     its scope.
                    
                     However, any class (if it has a name) can be declared final,
                     abstract, or strictfp.                    
                </comment>
                <comment line="1314">
                    declaration: final expr expr                    
                </comment>
                <comment line="1331">
                    This is the start of something outside a statement                    
                </comment>
                <comment line="1340">
                    declaration: expr expr                    
                </comment>
                <comment line="1346">
                    label: id: stat                    
                </comment>
                <comment line="1353">
                    it was just an expression...                    
                </comment>
                <scope line="959">
                    <declaration name="p" type="long" line="962"/>
                    <declaration name="c" type="Expression" line="965"/>
                    <declaration name="t" type="Statement" line="967"/>
                    <scope line="968"/>
                    <scope line="971"/>
                </scope>
                <scope line="976"/>
                <scope line="982">
                    <declaration name="p" type="long" line="984"/>
                    <declaration name="init" type="Statement" line="985"/>
                    <declaration name="cond" type="Expression" line="986"/>
                    <scope line="989">
                        <declaration name="p2" type="long" line="990"/>
                        <declaration name="mod" type="int" line="991"/>
                        <declaration name="e" type="Expression" line="992"/>
                        <scope line="994"/>
                        <scope line="996">
                            <scope line="997"/>
                            <scope line="1001">
                                <declaration name="p3" type="long" line="1002"/>
                                <declaration name="e2" type="Expression" line="1003"/>
                            </scope>
                        </scope>
                    </scope>
                    <scope line="1011"/>
                    <scope line="1015">
                        <scope line="1018">
                            <declaration name="p2" type="long" line="1019"/>
                            <declaration name="e2" type="Expression" line="1020"/>
                        </scope>
                    </scope>
                </scope>
                <scope line="1029">
                    <declaration name="p" type="long" line="1031"/>
                    <declaration name="cond" type="Expression" line="1034"/>
                </scope>
                <scope line="1039">
                    <declaration name="p" type="long" line="1041"/>
                    <declaration name="body" type="Statement" line="1043"/>
                    <declaration name="cond" type="Expression" line="1046"/>
                </scope>
                <scope line="1052">
                    <declaration name="p" type="long" line="1054"/>
                    <declaration name="label" type="Identifier" line="1055"/>
                    <scope line="1057"/>
                </scope>
                <scope line="1065">
                    <declaration name="p" type="long" line="1067"/>
                    <declaration name="label" type="Identifier" line="1068"/>
                    <scope line="1070"/>
                </scope>
                <scope line="1078">
                    <declaration name="p" type="long" line="1081"/>
                    <declaration name="e" type="Expression" line="1082"/>
                    <scope line="1084"/>
                </scope>
                <scope line="1091">
                    <declaration name="p" type="long" line="1093"/>
                    <declaration name="i" type="int" line="1094"/>
                    <declaration name="e" type="Expression" line="1097"/>
                    <scope line="1101">
                        <declaration name="j" type="int" line="1102"/>
                        <scope line="1103"/>
                        <scope line="1121">
                            <scope line="1123"/>
                        </scope>
                    </scope>
                </scope>
                <scope line="1132">
                    <scope line="1135"/>
                </scope>
                <scope line="1143"/>
                <scope line="1151">
                    <declaration name="p" type="long" line="1153"/>
                    <declaration name="init" type="Statement" line="1154"/>
                    <declaration name="i" type="int" line="1155"/>
                    <declaration name="catches" type="boolean" line="1156"/>
                    <scope line="1158">
                        <declaration name="p2" type="long" line="1160"/>
                        <declaration name="mod" type="int" line="1161"/>
                        <declaration name="e" type="Expression" line="1162"/>
                        <scope line="1164"/>
                        <scope line="1167">
                            <scope line="1168"/>
                        </scope>
                    </scope>
                    <declaration name="s" type="Statement" line="1176"/>
                    <scope line="1178"/>
                    <scope line="1182">
                        <declaration name="pp" type="long" line="1183"/>
                        <declaration name="mod" type="int" line="1186"/>
                        <declaration name="t" type="Expression" line="1187"/>
                        <declaration name="id" type="IdentifierToken" line="1188"/>
                    </scope>
                    <scope line="1204"/>
                    <scope line="1207"/>
                    <scope line="1209"/>
                </scope>
                <scope line="1215">
                    <declaration name="s" type="Statement" line="1219"/>
                    <scope line="1220"/>
                    <scope line="1230"/>
                </scope>
                <scope line="1237"/>
                <scope line="1244">
                    <declaration name="p" type="long" line="1246"/>
                    <declaration name="e" type="Expression" line="1247"/>
                </scope>
                <scope line="1252">
                    <declaration name="p" type="long" line="1253"/>
                </scope>
                <scope line="1260">
                    <declaration name="p" type="long" line="1262"/>
                    <declaration name="e" type="Expression" line="1264"/>
                </scope>
                <scope line="1277">
                    <declaration name="p" type="long" line="1279"/>
                    <declaration name="mod" type="int" line="1288"/>
                    <scope line="1304">
                        <scope line="1305"/>
                        <declaration name="e" type="Expression" line="1309"/>
                        <scope line="1310"/>
                        <declaration name="s" type="Statement" line="1314"/>
                    </scope>
                </scope>
                <declaration name="p" type="long" line="1335"/>
                <declaration name="e" type="Expression" line="1336"/>
                <scope line="1338">
                    <declaration name="s" type="Statement" line="1340"/>
                </scope>
                <scope line="1344">
                    <declaration name="s" type="Statement" line="1347"/>
                </scope>
            </method>
            <method name="parseBlockStatement" type="Statement" line="1358">
                <comment line="1360">
                    compound statement: { stat1 stat2 ... statn }                    
                </comment>
                <comment line="1362">
                    We&apos;re expecting a block statement.  But we&apos;ll probably do the
                     least damage if we try to parse a normal statement instead.                    
                </comment>
                <scope line="1360"/>
                <declaration name="p" type="long" line="1366"/>
                <declaration name="i" type="int" line="1367"/>
                <scope line="1368">
                    <declaration name="j" type="int" line="1369"/>
                    <scope line="1370"/>
                    <scope line="1372">
                        <scope line="1374"/>
                    </scope>
                </scope>
            </method>
            <javadoc line="1385">
                Parse an identifier. ie: a.b.c returns &quot;a.b.c&quot;
                  If star is true then &quot;a.b.&quot; is allowed.
                  The return value encodes both the identifier and its location.                
            </javadoc>
            <method name="parseName" type="IdentifierToken" line="1390">
                <params>
                    <param name="star" type="boolean"/>
                </params>
                <declaration name="res" type="IdentifierToken" line="1391"/>
                <scope line="1394"/>
                <declaration name="buf" type="StringBuffer" line="1398"/>
                <scope line="1400">
                    <scope line="1402"/>
                    <scope line="1409"/>
                </scope>
            </method>
            <javadoc line="1418">
                @deprecated                
                <see>
                    #parseName                    
                </see>
            </javadoc>
            <method name="parseIdentifier" type="Identifier" line="1423">
                <params>
                    <param name="star" type="boolean"/>
                </params>
            </method>
            <javadoc line="1427">
                Parse a type expression, this results in a Type.
                  The parse includes trailing array brackets.                
            </javadoc>
            <method name="parseType" type="Type" line="1431">
                <declaration name="t" type="Type" line="1432"/>
            </method>
            <javadoc line="1481">
                Parse the tail of a type expression, which might be array brackets.
                  Return the given type, as possibly modified by the suffix.                
            </javadoc>
            <method name="parseArrayBrackets" type="Type" line="1485">
                <params>
                    <param name="t" type="Type"/>
                </params>
                <comment line="1488">
                    Parse []&apos;s                    
                </comment>
                <scope line="1488">
                    <scope line="1490"/>
                </scope>
            </method>
            <declaration name="aCount" type="int" line="1505"/>
            <declaration name="aTypes" type="Type" line="1506"/>
            <declaration name="aNames" type="IdentifierToken" line="1507"/>
            <method name="addArgument" type="void" line="1509">
                <params>
                    <param name="mod" type="int"/>
                    <param name="t" type="Type"/>
                    <param name="nm" type="IdentifierToken"/>
                </params>
                <scope line="1511">
                    <declaration name="newATypes" type="Type" line="1512"/>
                    <declaration name="newANames" type="IdentifierToken" line="1515"/>
                </scope>
            </method>
            <javadoc line="1523">
                Parse a possibly-empty sequence of modifier keywords.
                  Return the resulting bitmask.
                  Diagnose repeated modifiers, but make no other checks.
                  Only modifiers mentioned in the given bitmask are scanned;
                  an unmatched modifier must be handled by the caller.                
            </javadoc>
            <method name="parseModifiers" type="int" line="1530">
                <params>
                    <param name="mask" type="int"/>
                </params>
                <comment line="1535">
                    const isn&apos;t in java, but handle a common C++ usage gently                    
                </comment>
                <declaration name="mod" type="int" line="1531"/>
                <scope line="1532">
                    <scope line="1533"/>
                    <declaration name="nextmod" type="int" line="1538"/>
                    <scope line="1552"/>
                    <scope line="1555"/>
                </scope>
            </method>
            <declaration name="curClass" type="ClassDefinition" line="1564"/>
            <javadoc line="1566">
                Parse a field.                
            </javadoc>
            <method name="parseField" type="void" line="1569">
                <comment line="1572">
                    Empty fields are not allowed by the JLS but are accepted by
                     the compiler, and much code has come to rely on this.  It has
                     been decided that the language will be extended to legitimize them.                    
                </comment>
                <comment line="1576">
                    empty field                    
                </comment>
                <comment line="1581">
                    Optional doc comment                    
                </comment>
                <comment line="1584">
                    The start of the field                    
                </comment>
                <comment line="1587">
                    Parse the modifiers                    
                </comment>
                <comment line="1590">
                    Check for static initializer
                     ie: static { ... }
                     or an instance initializer (w/o the static).                    
                </comment>
                <comment line="1594">
                    static initializer                    
                </comment>
                <comment line="1602">
                    Check for inner class                    
                </comment>
                <comment line="1608">
                    Parse the type                    
                </comment>
                <comment line="1613">
                    Check that the type is followed by an Identifier
                     (the name of the method or the first variable),
                     otherwise it is a constructor.                    
                </comment>
                <comment line="1623">
                    It is a constructor                    
                </comment>
                <comment line="1633">
                    If the next token is a left-bracket then we
                     are dealing with a method or constructor, otherwise it is
                     a list of variables                    
                </comment>
                <comment line="1637">
                    It is a method or constructor declaration                    
                </comment>
                <comment line="1642">
                    Parse argument type and identifier
                     (arguments (like locals) are allowed to be final)                    
                </comment>
                <comment line="1649">
                    Parse optional array specifier, ie: a[][]                    
                </comment>
                <comment line="1653">
                    If the next token is a comma then there are
                     more arguments                    
                </comment>
                <comment line="1656">
                    Parse argument type and identifier                    
                </comment>
                <comment line="1663">
                    Parse optional array specifier, ie: a[][]                    
                </comment>
                <comment line="1670">
                    Parse optional array sepecifier, ie: foo()[][]                    
                </comment>
                <comment line="1673">
                    copy arguments                    
                </comment>
                <comment line="1680">
                    Construct the type signature                    
                </comment>
                <comment line="1683">
                    Parse and ignore throws clause                    
                </comment>
                <comment line="1698">
                    Check if it is a method definition or a method declaration
                     ie: foo() {...} or foo();                    
                </comment>
                <comment line="1701">
                    It&apos;s a method definition                    
                </comment>
                <comment line="1703">
                    Set the state of FP strictness for the body of the method                    
                </comment>
                <comment line="1725">
                    really expected a statement body here                    
                </comment>
                <comment line="1735">
                    It is a list of instance variables                    
                </comment>
                <comment line="1737">
                    get the current position                    
                </comment>
                <comment line="1738">
                    parse the array brackets (if any)
                     ie: var[][][]                    
                </comment>
                <comment line="1742">
                    Parse the optional initializer                    
                </comment>
                <comment line="1749">
                    Define the variable                    
                </comment>
                <comment line="1753">
                    If the next token is a comma, then there is more                    
                </comment>
                <comment line="1760">
                    The next token must be an identifier                    
                </comment>
                <scope line="1574"/>
                <declaration name="doc" type="String" line="1581"/>
                <declaration name="p" type="long" line="1584"/>
                <declaration name="mod" type="int" line="1587"/>
                <scope line="1592"/>
                <scope line="1602"/>
                <declaration name="t" type="Type" line="1609"/>
                <declaration name="id" type="IdentifierToken" line="1610"/>
                <scope line="1635">
                    <scope line="1640">
                        <declaration name="am" type="int" line="1643"/>
                        <declaration name="at" type="Type" line="1644"/>
                        <declaration name="an" type="IdentifierToken" line="1645"/>
                        <scope line="1654"/>
                    </scope>
                    <declaration name="atypes" type="Type" line="1673"/>
                    <declaration name="anames" type="IdentifierToken" line="1676"/>
                    <declaration name="exp" type="IdentifierToken" line="1683"/>
                    <scope line="1684">
                        <declaration name="v" type="Vector" line="1685"/>
                        <scope line="1688"/>
                    </scope>
                    <declaration name="oldFPstate" type="int" line="1703"/>
                    <scope line="1704"/>
                    <scope line="1706"/>
                    <scope line="1725"/>
                    <scope line="1727"/>
                </scope>
                <scope line="1735">
                    <declaration name="vt" type="Type" line="1739"/>
                    <declaration name="init" type="Node" line="1742"/>
                    <scope line="1743"/>
                    <scope line="1753"/>
                </scope>
            </method>
            <javadoc line="1765">
                Recover after a syntax error in a field. This involves
                  discarding tokens until an EOF or a possible legal
                  continuation is encountered.                
            </javadoc>
            <method name="recoverField" type="void" line="1770">
                <params>
                    <param name="newClass" type="ClassDefinition"/>
                </params>
                <comment line="1791">
                    possible begin of a field, continue                    
                </comment>
                <comment line="1814">
                    begin of something outside a class, panic more                    
                </comment>
                <comment line="1819">
                    don&apos;t know what to do, skip                    
                </comment>
                <scope line="1771"/>
            </method>
            <javadoc line="1825">
                Parse a top-level class or interface declaration.                
            </javadoc>
            <method name="parseClass" type="void" line="1828">
                <comment line="1832">
                    Parse the modifiers.                    
                </comment>
                <declaration name="doc" type="String" line="1829"/>
                <declaration name="mod" type="int" line="1832"/>
            </method>
            <declaration name="FPstate" type="int" line="1842"/>
            <javadoc line="1844">
                Parse a block-local class or interface declaration.                
            </javadoc>
            <method name="parseLocalClass" type="Statement" line="1847">
                <params>
                    <param name="mod" type="int"/>
                </params>
                <declaration name="p" type="long" line="1848"/>
                <declaration name="body" type="ClassDefinition" line="1849"/>
                <declaration name="ds" type="Statement" line="1850"/>
                <declaration name="type" type="Expression" line="1853"/>
            </method>
            <javadoc line="1857">
                Parse a named class or interface declaration,
                  starting at &quot;class&quot; or &quot;interface&quot;.                
                <arg>
                    ctx Syntactic context of the class, one of {PACKAGE CLASS STAT EXPR}.                    
                </arg>
            </javadoc>
            <method name="parseNamedClass" type="ClassDefinition" line="1862">
                <params>
                    <param name="mod" type="int"/>
                    <param name="ctx" type="int"/>
                    <param name="doc" type="String"/>
                </params>
                <comment line="1864">
                    Parse class/interface                    
                </comment>
                <comment line="1884">
                    The &amp; (...) isn&apos;t really necessary here because we do maintain
                     the invariant that FPstate has no extra bits set.                    
                </comment>
                <comment line="1889">
                    Parse the class name                    
                </comment>
                <declaration name="oldFPstate" type="int" line="1879"/>
                <scope line="1880"/>
                <scope line="1882"/>
                <declaration name="nm" type="IdentifierToken" line="1889"/>
                <declaration name="p" type="long" line="1890"/>
                <declaration name="ext" type="Vector" line="1893"/>
                <declaration name="impl" type="Vector" line="1894"/>
                <declaration name="tmp" type="ClassDefinition" line="1897"/>
            </method>
            <method name="parseInheritance" type="void" line="1904">
                <params>
                    <param name="ext" type="Vector"/>
                    <param name="impl" type="Vector"/>
                </params>
                <comment line="1906">
                    Parse extends clause                    
                </comment>
                <comment line="1916">
                    Parse implements clause                    
                </comment>
                <scope line="1906">
                    <scope line="1909"/>
                </scope>
                <scope line="1916">
                    <scope line="1919"/>
                </scope>
            </method>
            <javadoc line="1926">
                Parse the body of a class or interface declaration,
                  starting at the left brace.                
            </javadoc>
            <method name="parseClassBody" type="ClassDefinition" line="1933">
                <params>
                    <param name="nm" type="IdentifierToken"/>
                    <param name="mod" type="int"/>
                    <param name="ctx" type="int"/>
                    <param name="doc" type="String"/>
                    <param name="ext" type="Vector"/>
                    <param name="impl" type="Vector"/>
                    <param name="p" type="long"/>
                </params>
                <comment line="1935">
                    Decide which is the super class                    
                </comment>
                <comment line="1955">
                    Begin a new class                    
                </comment>
                <comment line="1961">
                    Parse fields                    
                </comment>
                <comment line="1975">
                    End the class                    
                </comment>
                <declaration name="sup" type="IdentifierToken" line="1935"/>
                <scope line="1936">
                    <scope line="1937"/>
                </scope>
                <scope line="1942">
                    <scope line="1943">
                        <scope line="1944"/>
                    </scope>
                </scope>
                <declaration name="oldClass" type="ClassDefinition" line="1952"/>
                <declaration name="implids" type="IdentifierToken" line="1955"/>
                <declaration name="newClass" type="ClassDefinition" line="1957"/>
                <scope line="1962">
                    <scope line="1963"/>
                    <scope line="1966"/>
                    <scope line="1968"/>
                </scope>
            </method>
            <javadoc line="1979">
                Recover after a syntax error in the file.
                  This involves discarding tokens until an EOF
                  or a possible legal continuation is encountered.                
            </javadoc>
            <method name="recoverFile" type="void" line="1984">
                <comment line="1990">
                    Start of a new source file statement, continue                    
                </comment>
                <comment line="2012">
                    Don&apos;t know what to do, skip                    
                </comment>
                <scope line="1985"/>
            </method>
            <javadoc line="2018">
                Parse an Java file.                
            </javadoc>
            <method name="parseFile" type="void" line="2021">
                <comment line="2026">
                    Package statement                    
                </comment>
                <comment line="2037">
                    Import statement                    
                </comment>
                <comment line="2062">
                    Start of a class                    
                </comment>
                <comment line="2067">
                    Bogus semicolon.
                     According to the JLS (7.6,19.6), a TypeDeclaration
                     may consist of a single semicolon, however, this
                     usage is discouraged (JLS 7.6).  In contrast,
                     a FieldDeclaration may not be empty, and is flagged
                     as an error.  See parseField above.                    
                </comment>
                <comment line="2077">
                    The end                    
                </comment>
                <comment line="2081">
                    Oops                    
                </comment>
                <scope line="2022">
                    <scope line="2023">
                        <scope line="2024">
                            <declaration name="p" type="long" line="2026"/>
                            <declaration name="id" type="IdentifierToken" line="2027"/>
                        </scope>
                    </scope>
                    <scope line="2031"/>
                    <scope line="2034">
                        <scope line="2035">
                            <declaration name="p" type="long" line="2037"/>
                            <declaration name="id" type="IdentifierToken" line="2038"/>
                            <scope line="2040"/>
                            <scope line="2043"/>
                        </scope>
                        <scope line="2046"/>
                    </scope>
                    <scope line="2051">
                        <scope line="2052"/>
                        <scope line="2084"/>
                    </scope>
                </scope>
                <scope line="2088"/>
            </method>
            <declaration name="scanner" type="Scanner" line="2094"/>
            <javadoc line="2094">
                Usually &lt;code&gt;this.scanner == (Scanner)this&lt;/code&gt;.
                  However, a delegate scanner can produce tokens for this parser,
                  in which case &lt;code&gt;(Scanner)this&lt;/code&gt; is unused,
                  except for &lt;code&gt;this.token&lt;/code&gt; and &lt;code&gt;this.pos&lt;/code&gt;
                  instance variables which are filled from the real scanner
                  by &lt;code&gt;this.scan()&lt;/code&gt; and the constructor.                
            </javadoc>
            <method name="scan" type="long" line="2111">
                <scope line="2112">
                    <declaration name="result" type="long" line="2113"/>
                </scope>
            </method>
            <method name="match" type="void" line="2121">
                <params>
                    <param name="open" type="int"/>
                    <param name="close" type="int"/>
                </params>
                <scope line="2122"/>
            </method>
        </class>
    </source>