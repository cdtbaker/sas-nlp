<?xml version="1.0" encoding="UTF-8"?>
    <source package="sun.tools.java">
        <import package="java.util"/>
        <import package="java.io.OutputStream"/>
        <import package="java.io.PrintStream"/>
        <import package="sun.tools.tree.Context"/>
        <import package="sun.tools.tree.Vset"/>
        <import package="sun.tools.tree.Expression"/>
        <import package="sun.tools.tree.LocalMember"/>
        <import package="sun.tools.tree.UplevelReference"/>
        <class name="ClassDefinition" line="37">
            <comment line="51">
                for local classes                
            </comment>
            <comment line="59">
                field for me in outerClass                
            </comment>
            <comment line="71">
                Table of local and anonymous classes whose internal names are constructed
                 using the current class as a prefix.  This is part of a fix for
                 bugid 4054523 and 4030421.  See also &apos;Environment.getClassDefinition&apos;
                 and &apos;BatchEnvironment.makeClassDefinition&apos;.  Allocated on demand.                
            </comment>
            <comment line="78">
                The immediately surrounding context in which the class appears.
                 Set at the beginning of checking, upon entry to &apos;SourceClass.checkInternal&apos;.
                 Null for classes that are not local or inside a local class.
                 At present, this field exists only for the benefit of &apos;resolveName&apos; as part
                 of the fix for 4095716.                
            </comment>
            <comment line="85">
                The saved class context is now also used in &apos;SourceClass.getAccessMember&apos;.
                 Provide read-only access via this method.  Part of fix for 4098093.                
            </comment>
            <comment line="185">
                *** DEBUG ***                
            </comment>
            <comment line="840">
                private fields are never inherited.  package-private fields are
                 not inherited across package boundaries.  To capture this, we
                 take two booleans as parameters: showPrivate indicates whether
                 we have passed a class boundary, and showPackage indicates whether
                 we have crossed a package boundary.                
            </comment>
            <comment line="1154">
                We create a stub for this.  Source classes do more work.                
            </comment>
            <comment line="1174">
                ---------------------------------------------------------------
                 The non-synthetic methods defined in this class or in any
                 of its parents (class or interface).  This member is used
                 to cache work done in collectInheritedMethods for use by
                 getMethods() and matchMethod().  It should be accessed by
                 no other method without forethought.                
            </comment>
            <comment line="1182">
                One of our superclasses may contain an abstract method which
                 we are unable to ever implement.  This happens when there is
                 a package-private abstract method in our parent and we are in
                 a different package than our parent.  In these cases, we
                 keep a list of the &quot;permanently abstract&quot; or &quot;unimplementable&quot;
                 methods so that we can correctly detect that this class is
                 indeed abstract and so that we can give somewhat comprehensible
                 error messages.                
            </comment>
            <comment line="1553">
                //////////////////////////////////////////////////////////
                 PCJ 2003-07-30 added this utility method to insulate
                 MethodSet additions from the covariant return type
                 feature of the 1.5 compiler.  When there are multiple
                 methods with the same signature and different return
                 types to be added, we try to ensure that the one with
                 the most specific return type winds up in the MethodSet.
                 This logic was not put into MethodSet itself because it
                 requires access to an Environment for type relationship
                 checking.  No error checking is performed here, but that
                 should be OK because this code is only still used by
                 rmic.  See 4892308.                
            </comment>
            <comment line="1585">
                //////////////////////////////////////////////////////////                
            </comment>
            <comment line="1610">
                In early VM&apos;s there was a bug -- the VM didn&apos;t walk the interfaces
                 of a class looking for a method, they only walked the superclass
                 chain.  This meant that abstract methods defined only in interfaces
                 were not being found.  To fix this bug, a counter-bug was introduced
                 in the compiler -- the so-called Miranda methods.  If a class
                 does not provide a definition for an abstract method in one of
                 its interfaces then the compiler inserts one in the class artificially.
                 That way the VM didn&apos;t have to bother looking at the interfaces.
                
                 This is a problem.  Miranda methods are not part of the specification.
                 But they continue to be inserted so that old VM&apos;s can run new code.
                 Someday, when the old VM&apos;s are gone, perhaps classes can be compiled
                 without Miranda methods.  Towards this end, the compiler has a
                 flag, -nomiranda, which can turn off the creation of these methods.
                 Eventually that behavior should become the default.
                
                 Why are they called Miranda methods?  Well the sentence &quot;If the
                 class is not able to provide a method, then one will be provided
                 by the compiler&quot; is very similar to the sentence &quot;If you cannot
                 afford an attorney, one will be provided by the court,&quot; -- one
                 of the so-called &quot;Miranda&quot; rights in the United States.                
            </comment>
            <comment line="1644">
                ---------------------------------------------------------------                
            </comment>
            <implements interface="Constants"/>
            <javadoc line="37">
                This class is a Java class definition
                  WARNING: The contents of this source file are not part of any
                  supported API.  Code that depends on them does so at its own risk:
                  they are subject to change or removal without notice.                
            </javadoc>
            <declaration name="source" type="Object" line="47"/>
            <declaration name="where" type="long" line="48"/>
            <declaration name="modifiers" type="int" line="49"/>
            <declaration name="localName" type="Identifier" line="50"/>
            <declaration name="declaration" type="ClassDeclaration" line="51"/>
            <declaration name="superClassId" type="IdentifierToken" line="52"/>
            <declaration name="interfaceIds" type="IdentifierToken" line="53"/>
            <declaration name="superClass" type="ClassDeclaration" line="54"/>
            <declaration name="interfaces" type="ClassDeclaration" line="55"/>
            <declaration name="outerClass" type="ClassDefinition" line="56"/>
            <declaration name="outerMember" type="MemberDefinition" line="57"/>
            <declaration name="innerClassMember" type="MemberDefinition" line="58"/>
            <declaration name="firstMember" type="MemberDefinition" line="59"/>
            <declaration name="lastMember" type="MemberDefinition" line="60"/>
            <declaration name="resolved" type="boolean" line="61"/>
            <declaration name="documentation" type="String" line="62"/>
            <declaration name="error" type="boolean" line="63"/>
            <declaration name="nestError" type="boolean" line="64"/>
            <declaration name="references" type="UplevelReference" line="65"/>
            <declaration name="referencesFrozen" type="boolean" line="66"/>
            <declaration name="fieldHash" type="Hashtable" line="67"/>
            <declaration name="abstr" type="int" line="68"/>
            <declaration name="localClasses" type="Hashtable" line="74"/>
            <declaration name="LOCAL_CLASSES_SIZE" type="int" line="75"/>
            <declaration name="classContext" type="Context" line="82"/>
            <method name="getClassContext" type="Context" line="86"/>
            <javadoc line="91">
                Constructor                
            </javadoc>
            <method name="ClassDefinition" type="constructor" line="95">
                <params>
                    <param name="source" type="Object"/>
                    <param name="where" type="long"/>
                    <param name="declaration" type="ClassDeclaration"/>
                    <param name="modifiers" type="int"/>
                    <param name="superClass" type="IdentifierToken"/>
                    <param name="interfaces" type="IdentifierToken"/>
                </params>
            </method>
            <javadoc line="104">
                Get the source of the class                
            </javadoc>
            <method name="getSource" type="Object" line="107"/>
            <javadoc line="111">
                Check if there were any errors in this class.                
            </javadoc>
            <method name="getError" type="boolean" line="114"/>
            <javadoc line="118">
                Mark this class to be erroneous.                
            </javadoc>
            <method name="setError" type="void" line="121"/>
            <javadoc line="126">
                Check if there were any errors in our class nest.                
            </javadoc>
            <method name="getNestError" type="boolean" line="129">
                <comment line="131">
                    Check to see if our error value is set, or if any of our
                     outer classes&apos; error values are set.  This will work in
                     conjunction with setError(), which sets the error value
                     of its outer class, to yield true is any of our nest
                     siblings has an error.  This addresses bug 4111488: either
                     code should be generated for all classes in a nest, or
                     none of them.                    
                </comment>
            </method>
            <javadoc line="140">
                Mark this class, and all siblings in its class nest, to be
                  erroneous.                
            </javadoc>
            <method name="setNestError" type="void" line="144">
                <comment line="148">
                    If we have an outer class, set it to be erroneous as well.
                     This will work in conjunction with getError(), which checks
                     the error value of its outer class, to set the whole class
                     nest to be erroneous.  This address bug 4111488: either
                     code should be generated for all classes in a nest, or
                     none of them.                    
                </comment>
                <scope line="146"/>
            </method>
            <javadoc line="157">
                Get the position in the input                
            </javadoc>
            <method name="getWhere" type="long" line="160"/>
            <javadoc line="164">
                Get the class declaration                
            </javadoc>
            <method name="getClassDeclaration" type="ClassDeclaration" line="167"/>
            <javadoc line="171">
                Get the class&apos; modifiers                
            </javadoc>
            <method name="getModifiers" type="int" line="174"/>
            <method name="subModifiers" type="void" line="177">
                <params>
                    <param name="mod" type="int"/>
                </params>
            </method>
            <method name="addModifiers" type="void" line="180">
                <params>
                    <param name="mod" type="int"/>
                </params>
            </method>
            <declaration name="supersCheckStarted" type="boolean" line="185"/>
            <javadoc line="187">
                Get the class&apos; super class                
            </javadoc>
            <method name="getSuperClass" type="ClassDeclaration" line="190">
                <comment line="192">
                    ---
                    if (superClass == null &amp;&amp; superClassId != null)
                    throw new CompilerError(&quot;getSuperClass &quot;+superClassId);
                     There are obscure cases where null is the right answer,
                     in order to enable some error reporting later on.
                     For example:  class T extends T.N { class N { } }                    
                </comment>
                <comment line="200">
                    *** DEBUG ***
                     This method should not be called if the superclass has not been resolved.                    
                </comment>
            </method>
            <javadoc line="206">
                Get the super class, and resolve names now if necessary.
                  It is only possible to resolve names at this point if we are
                  a source class.  The provision of this method at this level
                  in the class hierarchy is dubious, but see &apos;getInnerClass&apos; below.
                  All other calls to &apos;getSuperClass(env)&apos; appear in &apos;SourceClass&apos;.
                  NOTE: An older definition of this method has been moved to
                  &apos;SourceClass&apos;, where it overrides this one.                
                <see>
                    #resolveTypeStructure                    
                </see>
            </javadoc>
            <method name="getSuperClass" type="ClassDeclaration" line="219">
                <params>
                    <param name="env" type="Environment"/>
                </params>
            </method>
            <javadoc line="223">
                Get the class&apos; interfaces                
            </javadoc>
            <method name="getInterfaces" type="ClassDeclaration" line="226"/>
            <javadoc line="231">
                Get the class&apos; enclosing class (or null if not inner)                
            </javadoc>
            <method name="getOuterClass" type="ClassDefinition" line="234"/>
            <javadoc line="238">
                Set the class&apos; enclosing class.  Must be done at most once.                
            </javadoc>
            <method name="setOuterClass" type="void" line="241">
                <params>
                    <param name="outerClass" type="ClassDefinition"/>
                </params>
            </method>
            <javadoc line="246">
                Set the class&apos; enclosing current instance pointer.
                  Must be done at most once.                
            </javadoc>
            <method name="setOuterMember" type="void" line="250">
                <params>
                    <param name="outerMember" type="MemberDefinition"/>
                </params>
            </method>
            <javadoc line="257">
                Tell if the class is inner.
                  This predicate also returns true for top-level nested types.
                  To test for a true inner class as seen by the programmer,
                  use &lt;tt&gt;!isTopLevel()&lt;/tt&gt;.                
            </javadoc>
            <method name="isInnerClass" type="boolean" line="263"/>
            <javadoc line="267">
                Tell if the class is a member of another class.
                  This is false for package members and for block-local classes.                
            </javadoc>
            <method name="isMember" type="boolean" line="271"/>
            <javadoc line="275">
                Tell if the class is &quot;top-level&quot;, which is either a package member,
                  or a static member of another top-level class.                
            </javadoc>
            <method name="isTopLevel" type="boolean" line="279"/>
            <javadoc line="283">
                Tell if the class is local or inside a local class,
                  which means it cannot be mentioned outside of its file.                
            </javadoc>
            <method name="isInsideLocal" type="boolean" line="292">
                <comment line="289">
                    The comment above is true only because M_LOCAL is set
                     whenever M_ANONYMOUS is.  I think it is risky to assume that
                     isAnonymous(x) =&gt; isLocal(x).                    
                </comment>
            </method>
            <javadoc line="297">
                Tell if the class is local or or anonymous class, or inside
                  such a class, which means it cannot be mentioned outside of
                  its file.                
            </javadoc>
            <method name="isInsideLocalOrAnonymous" type="boolean" line="302"/>
            <javadoc line="307">
                Return a simple identifier for this class (idNull if anonymous).                
            </javadoc>
            <method name="getLocalName" type="Identifier" line="310">
                <comment line="315">
                    This is also the name of the innerClassMember, if any:                    
                </comment>
                <scope line="311"/>
            </method>
            <javadoc line="318">
                Set the local name of a class.  Must be a local class.                
            </javadoc>
            <method name="setLocalName" type="void" line="321">
                <params>
                    <param name="name" type="Identifier"/>
                </params>
                <scope line="322"/>
            </method>
            <javadoc line="327">
                If inner, get the field for this class in the enclosing class                
            </javadoc>
            <method name="getInnerClassMember" type="MemberDefinition" line="330">
                <comment line="335">
                    We must find the field in the outer class.                    
                </comment>
                <scope line="333">
                    <declaration name="nm" type="Identifier" line="335"/>
                    <scope line="337">
                        <scope line="338"/>
                    </scope>
                </scope>
            </method>
            <javadoc line="349">
                If inner, return an innermost uplevel self pointer, if any exists.
                  Otherwise, return null.                
            </javadoc>
            <method name="findOuterMember" type="MemberDefinition" line="353"/>
            <javadoc line="357">
                See if this is a (nested) static class.                
            </javadoc>
            <method name="isStatic" type="boolean" line="360"/>
            <javadoc line="364">
                Get the class&apos; top-level enclosing class                
            </javadoc>
            <method name="getTopClass" type="ClassDefinition" line="367">
                <declaration name="p" type="ClassDefinition" line="368"/>
            </method>
            <javadoc line="374">
                Get the class&apos; first field or first match                
            </javadoc>
            <method name="getFirstMember" type="MemberDefinition" line="377"/>
            <method name="getFirstMatch" type="MemberDefinition" line="380">
                <params>
                    <param name="name" type="Identifier"/>
                </params>
            </method>
            <javadoc line="384">
                Get the class&apos; name                
            </javadoc>
            <method name="getName" type="Identifier" line="387"/>
            <javadoc line="391">
                Get the class&apos; type                
            </javadoc>
            <method name="getType" type="Type" line="394"/>
            <javadoc line="398">
                Get the class&apos; documentation                
            </javadoc>
            <method name="getDocumentation" type="String" line="401"/>
            <javadoc line="405">
                Return true if the given documentation string contains a deprecation
                  paragraph.  This is true if the string contains the tag @deprecated
                  is the first word in a line.                
            </javadoc>
            <method name="containsDeprecated" type="boolean" line="410">
                <params>
                    <param name="documentation" type="String"/>
                </params>
                <comment line="419">
                    make sure there is only whitespace between this word
                     and the beginning of the line                    
                </comment>
                <comment line="424">
                    OK                    
                </comment>
                <comment line="430">
                    make sure the char after the word is space or end of line                    
                </comment>
                <scope line="411"/>
                <scope line="417">
                    <scope line="420">
                        <declaration name="ch" type="char" line="421"/>
                        <scope line="422"/>
                        <scope line="425"/>
                    </scope>
                    <declaration name="end" type="int" line="430"/>
                    <scope line="431">
                        <declaration name="ch" type="char" line="432"/>
                        <scope line="433"/>
                    </scope>
                </scope>
            </method>
            <method name="inSamePackage" type="boolean" line="442">
                <params>
                    <param name="c" type="ClassDeclaration"/>
                </params>
                <comment line="444">
                    find out if the class stored in c is defined in the same
                     package as the current class.                    
                </comment>
            </method>
            <method name="inSamePackage" type="boolean" line="448">
                <params>
                    <param name="c" type="ClassDefinition"/>
                </params>
                <comment line="450">
                    find out if the class stored in c is defined in the same
                     package as the current class.                    
                </comment>
            </method>
            <method name="inSamePackage" type="boolean" line="454">
                <params>
                    <param name="packageName" type="Identifier"/>
                </params>
            </method>
            <javadoc line="458">
                Checks                
            </javadoc>
            <method name="isInterface" type="boolean" line="461"/>
            <method name="isClass" type="boolean" line="464"/>
            <method name="isPublic" type="boolean" line="467"/>
            <method name="isPrivate" type="boolean" line="470"/>
            <method name="isProtected" type="boolean" line="473"/>
            <method name="isPackagePrivate" type="boolean" line="476"/>
            <method name="isFinal" type="boolean" line="479"/>
            <method name="isAbstract" type="boolean" line="482"/>
            <method name="isSynthetic" type="boolean" line="485"/>
            <method name="isDeprecated" type="boolean" line="488"/>
            <method name="isAnonymous" type="boolean" line="491"/>
            <method name="isLocal" type="boolean" line="494"/>
            <method name="hasConstructor" type="boolean" line="497"/>
            <javadoc line="502">
                Check to see if a class must be abstract.  This method replaces
                  isAbstract(env)                
            </javadoc>
            <method name="mustBeAbstract" type="boolean" line="506">
                <params>
                    <param name="env" type="Environment"/>
                </params>
                <comment line="508">
                    If it is declared abstract, return true.
                     (Fix for 4110534.)                    
                </comment>
                <comment line="514">
                    Check to see if the class should have been declared to be
                     abstract.                    
                </comment>
                <comment line="517">
                    We make sure that the inherited method collection has been
                     performed.                    
                </comment>
                <comment line="521">
                    We check for any abstract methods inherited or declared
                     by this class.                    
                </comment>
                <comment line="532">
                    We check for hidden &quot;permanently abstract&quot; methods in
                     our superclasses.                    
                </comment>
                <scope line="509"/>
                <declaration name="methods" type="Iterator" line="522"/>
                <scope line="523">
                    <declaration name="method" type="MemberDefinition" line="524"/>
                    <scope line="526"/>
                </scope>
            </method>
            <javadoc line="536">
                Check if this is a super class of another class                
            </javadoc>
            <method name="superClassOf" type="boolean" line="540">
                <params>
                    <param name="env" type="Environment"/>
                    <param name="otherClass" type="ClassDeclaration"/>
                </params>
                <scope line="541">
                    <scope line="542"/>
                </scope>
            </method>
            <javadoc line="550">
                Check if this is an enclosing class of another class                
            </javadoc>
            <method name="enclosingClassOf" type="boolean" line="553">
                <params>
                    <param name="otherClass" type="ClassDefinition"/>
                </params>
                <scope line="554">
                    <scope line="555"/>
                </scope>
            </method>
            <javadoc line="562">
                Check if this is a sub class of another class                
            </javadoc>
            <method name="subClassOf" type="boolean" line="565">
                <params>
                    <param name="env" type="Environment"/>
                    <param name="otherClass" type="ClassDeclaration"/>
                </params>
                <declaration name="c" type="ClassDeclaration" line="566"/>
                <scope line="567">
                    <scope line="568"/>
                </scope>
            </method>
            <javadoc line="576">
                Check if this class is implemented by another class                
            </javadoc>
            <method name="implementedBy" type="boolean" line="579">
                <params>
                    <param name="env" type="Environment"/>
                    <param name="c" type="ClassDeclaration"/>
                </params>
                <scope line="580">
                    <scope line="581"/>
                    <declaration name="intf" type="ClassDeclaration" line="584"/>
                    <scope line="585">
                        <scope line="586"/>
                    </scope>
                </scope>
            </method>
            <javadoc line="594">
                Check to see if a class which implements interface `this&apos; could
                  possibly implement the interface `intDef&apos;.  Note that the only
                  way that this can fail is if `this&apos; and `intDef&apos; have methods
                  which are of the same signature and different return types.  This
                  method is used by Environment.explicitCast() to determine if a
                  cast between two interfaces is legal.
                  This method should only be called on a class after it has been
                  basicCheck()&apos;ed.                
            </javadoc>
            <method name="couldImplement" type="boolean" line="605">
                <params>
                    <param name="intDef" type="ClassDefinition"/>
                </params>
                <comment line="607">
                    Check to see if we could have done the necessary checks.                    
                </comment>
                <comment line="612">
                    This method should only be called for interfaces.                    
                </comment>
                <comment line="617">
                    Make sure we are not called before we have collected our
                     inheritance information.                    
                </comment>
                <comment line="623">
                    Get the other classes&apos; methods.  getMethods() in
                     general can return methods which are not visible to the
                     current package.  We need to make sure that these do not
                     prevent this class from being implemented.                    
                </comment>
                <comment line="630">
                    Get one of the methods from intDef...                    
                </comment>
                <comment line="637">
                    See if we implement a method of the same signature...                    
                </comment>
                <comment line="640">
                    System.out.println(&quot;Comparing\n\t&quot; + myMethod +
                                       &quot;\nand\n\t&quot; + method);                    
                </comment>
                <comment line="644">
                    We do.  Make sure the methods have the same return type.                    
                </comment>
                <scope line="607"/>
                <scope line="612"/>
                <scope line="618"/>
                <declaration name="otherMethods" type="Iterator" line="626"/>
                <scope line="628">
                    <declaration name="method" type="MemberDefinition" line="630"/>
                    <declaration name="name" type="Identifier" line="633"/>
                    <declaration name="type" type="Type" line="634"/>
                    <declaration name="myMethod" type="MemberDefinition" line="637"/>
                    <scope line="642">
                        <scope line="644"/>
                    </scope>
                </scope>
            </method>
            <javadoc line="653">
                Check if another class can be accessed from the &apos;extends&apos; or &apos;implements&apos;
                  clause of this class.                
            </javadoc>
            <method name="extendsCanAccess" type="boolean" line="657">
                <params>
                    <param name="env" type="Environment"/>
                    <param name="c" type="ClassDeclaration"/>
                </params>
                <comment line="660">
                    Names in the &apos;extends&apos; or &apos;implements&apos; clause of an inner class
                     are checked as if they appeared in the body of the surrounding class.                    
                </comment>
                <comment line="666">
                    We are a package member.                    
                </comment>
                <comment line="671">
                    No locals should be in scope in the &apos;extends&apos; or
                     &apos;implements&apos; clause of a package member.                    
                </comment>
                <comment line="679">
                    Access to public member is always allowed.                    
                </comment>
                <comment line="684">
                    Private access is ok only from the same class nest.  This can
                     happen only if the class represented by &apos;this&apos; encloses the inner
                     class represented by &apos;f&apos;.                    
                </comment>
                <comment line="691">
                    Protected or default access -- allow access if in same package.                    
                </comment>
                <comment line="695">
                    Access to public member is always allowed.                    
                </comment>
                <comment line="700">
                    Default access -- allow access if in same package.                    
                </comment>
                <scope line="661"/>
                <declaration name="cdef" type="ClassDefinition" line="667"/>
                <scope line="669"/>
                <scope line="675">
                    <declaration name="f" type="MemberDefinition" line="676"/>
                    <scope line="679"/>
                    <scope line="686"/>
                </scope>
                <scope line="695"/>
            </method>
            <javadoc line="703">
                Check if another class can be accessed from within the body of this class.                
            </javadoc>
            <method name="canAccess" type="boolean" line="706">
                <params>
                    <param name="env" type="Environment"/>
                    <param name="c" type="ClassDeclaration"/>
                </params>
                <comment line="711">
                    if it&apos;s in scope, it&apos;s accessible                    
                </comment>
                <comment line="719">
                    Public access is always ok                    
                </comment>
                <comment line="724">
                    It must be in the same package                    
                </comment>
                <declaration name="cdef" type="ClassDefinition" line="707"/>
                <scope line="709"/>
                <scope line="714"/>
                <scope line="719"/>
            </method>
            <javadoc line="727">
                Check if a field can be accessed from a class                
            </javadoc>
            <method name="canAccess" type="boolean" line="732">
                <params>
                    <param name="env" type="Environment"/>
                    <param name="f" type="MemberDefinition"/>
                </params>
                <comment line="735">
                    Public access is always ok                    
                </comment>
                <comment line="739">
                    Protected access is ok from a subclass                    
                </comment>
                <comment line="743">
                    Private access is ok only from the same class nest                    
                </comment>
                <comment line="748">
                    It must be in the same package                    
                </comment>
                <scope line="735"/>
                <scope line="739"/>
                <scope line="743"/>
            </method>
            <javadoc line="751">
                Check if a class is entitled to inline access to a class from
                  another class.                
            </javadoc>
            <method name="permitInlinedAccess" type="boolean" line="756">
                <params>
                    <param name="env" type="Environment"/>
                    <param name="c" type="ClassDeclaration"/>
                </params>
            </method>
            <javadoc line="762">
                Check if a class is entitled to inline access to a method from
                  another class.                
            </javadoc>
            <method name="permitInlinedAccess" type="boolean" line="767">
                <params>
                    <param name="env" type="Environment"/>
                    <param name="f" type="MemberDefinition"/>
                </params>
            </method>
            <javadoc line="773">
                We know the the field is marked protected (and not public) and that
                  the field is visible (as per canAccess).  Can we access the field as
                  &lt;accessor&gt;.&lt;field&gt;, where &lt;accessor&gt; has the type &lt;accessorType&gt;?
                  Protected fields can only be accessed when the accessorType is a
                  subclass of the current class                
            </javadoc>
            <method name="protectedAccess" type="boolean" line="784">
                <params>
                    <param name="env" type="Environment"/>
                    <param name="f" type="MemberDefinition"/>
                    <param name="accessorType" type="Type"/>
                </params>
                <comment line="788">
                    static protected fields are accessible                    
                </comment>
                <comment line="790">
                    allow array.clone()                    
                </comment>
                <comment line="793">
                    &lt;accessorType&gt; is a subtype of the current class                    
                </comment>
                <comment line="797">
                    we are accessing the field from a friendly class (same package)                    
                </comment>
            </method>
            <javadoc line="802">
                Find or create an access method for a private member,
                  or return null if this is not possible.                
            </javadoc>
            <method name="getAccessMember" type="MemberDefinition" line="807">
                <params>
                    <param name="env" type="Environment"/>
                    <param name="ctx" type="Context"/>
                    <param name="field" type="MemberDefinition"/>
                    <param name="isSuper" type="boolean"/>
                </params>
            </method>
            <javadoc line="811">
                Find or create an update method for a private member,
                  or return null if this is not possible.                
            </javadoc>
            <method name="getUpdateMember" type="MemberDefinition" line="816">
                <params>
                    <param name="env" type="Environment"/>
                    <param name="ctx" type="Context"/>
                    <param name="field" type="MemberDefinition"/>
                    <param name="isSuper" type="boolean"/>
                </params>
            </method>
            <javadoc line="820">
                Get a field from this class.  Report ambiguous fields.
                  If no accessible field is found, this method may return an
                  inaccessible field to allow a useful error message.
                  getVariable now takes the source class `source&apos; as an argument.
                  This allows getVariable to check whether a field is inaccessible
                  before it signals that a field is ambiguous.  The compiler used to
                  signal an ambiguity even when one of the fields involved was not
                  accessible.  (bug 4053724)                
            </javadoc>
            <method name="getVariable" type="MemberDefinition" line="834">
                <params>
                    <param name="env" type="Environment"/>
                    <param name="nm" type="Identifier"/>
                    <param name="source" type="ClassDefinition"/>
                </params>
            </method>
            <method name="getVariable0" type="MemberDefinition" line="851">
                <params>
                    <param name="env" type="Environment"/>
                    <param name="nm" type="Identifier"/>
                    <param name="source" type="ClassDefinition"/>
                    <param name="showPrivate" type="boolean"/>
                    <param name="showPackage" type="boolean"/>
                </params>
                <comment line="854">
                    Check to see if this field is defined in the current class                    
                </comment>
                <comment line="861">
                    It is defined in this class.                    
                </comment>
                <comment line="864">
                    Even though this definition is not inherited,
                     it hides all definitions in supertypes.                    
                </comment>
                <comment line="871">
                    Find the field in our superclass.                    
                </comment>
                <comment line="882">
                    Find the field in our superinterfaces.                    
                </comment>
                <comment line="884">
                    Try to look up the field in an interface.  Since interfaces
                     only have public fields, the values of the two boolean
                     arguments are not important.                    
                </comment>
                <comment line="892">
                    If we have two different, accessible fields, then
                     we&apos;ve found an ambiguity.                    
                </comment>
                <scope line="856">
                    <scope line="857">
                        <scope line="859"/>
                        <scope line="862"/>
                    </scope>
                </scope>
                <declaration name="sup" type="ClassDeclaration" line="871"/>
                <declaration name="field" type="MemberDefinition" line="872"/>
                <scope line="873"/>
                <scope line="882">
                    <declaration name="field2" type="MemberDefinition" line="886"/>
                    <scope line="890">
                        <scope line="895"/>
                    </scope>
                </scope>
            </method>
            <javadoc line="905">
                Tells whether to report a deprecation error for this class.                
            </javadoc>
            <method name="reportDeprecated" type="boolean" line="908">
                <params>
                    <param name="env" type="Environment"/>
                </params>
            </method>
            <javadoc line="913">
                Note that this class is being used somehow by &lt;tt&gt;ref&lt;/tt&gt;.
                  Report deprecation errors, etc.                
            </javadoc>
            <method name="noteUsedBy" type="void" line="917">
                <params>
                    <param name="ref" type="ClassDefinition"/>
                    <param name="where" type="long"/>
                    <param name="env" type="Environment"/>
                </params>
                <comment line="919">
                    (Have this deal with canAccess() checks, too?)                    
                </comment>
                <scope line="919"/>
            </method>
            <javadoc line="924">
                Get an inner class.
                  Look in supers but not outers.
                  (This is used directly to resolve expressions like &quot;site.K&quot;, and
                  inside a loop to resolve lone names like &quot;K&quot; or the &quot;K&quot; in &quot;K.L&quot;.)
                  Called from &apos;Context&apos; and &apos;FieldExpression&apos; as well as this class.                
                <see>
                    FieldExpression.checkCommon                    
                </see>
                <see>
                    resolveName                    
                </see>
            </javadoc>
            <method name="getInnerClass" type="MemberDefinition" line="936">
                <params>
                    <param name="env" type="Environment"/>
                    <param name="nm" type="Identifier"/>
                </params>
                <comment line="938">
                    Note:  AmbiguousClass will not be thrown unless and until
                     inner classes can be defined inside interfaces.                    
                </comment>
                <comment line="941">
                    Check if it is defined in the current class                    
                </comment>
                <comment line="946">
                    ignore this name; it is internally generated                    
                </comment>
                <comment line="952">
                    Get it from the super class
                     It is likely that &apos;getSuperClass()&apos; could be made to work here
                     but we would have to assure somehow that &apos;resolveTypeStructure&apos;
                     has been called on the current class nest.  Since we can get
                     here from &apos;resolveName&apos;, which is called from &apos;resolveSupers&apos;,
                     it is possible that the first attempt to resolve the superclass
                     will originate here, instead of in the call to &apos;getSuperClass&apos;
                     in &apos;checkSupers&apos;.  See &apos;resolveTypeStructure&apos;, in which a call
                     to &apos;resolveSupers&apos; precedes the call to &apos;checkSupers&apos;.  Why is
                     name resolution done twice, first in &apos;resolveName&apos;?
                     NOTE: &apos;SourceMember.resolveTypeStructure&apos; may initiate type
                     structure resolution for an inner class.  Normally, this
                     occurs during the resolution of the outer class, but fields
                     added after the resolution of their containing class will
                     be resolved late -- see &apos;addMember(env,field)&apos; below.
                     This should only happen for synthetic members, which should
                     never be an inner class.                    
                </comment>
                <scope line="942">
                    <scope line="943">
                        <scope line="944"/>
                    </scope>
                </scope>
                <declaration name="sup" type="ClassDeclaration" line="968"/>
            </method>
            <javadoc line="975">
                Lookup a method.  This code implements the method lookup
                  mechanism specified in JLS 15.11.2.
                  This mechanism cannot be used to lookup synthetic methods.                
            </javadoc>
            <method name="matchMethod" type="MemberDefinition" line="987">
                <params>
                    <param name="env" type="Environment"/>
                    <param name="accessor" type="ClassDefinition"/>
                    <param name="methodName" type="Identifier"/>
                    <param name="argumentTypes" type="Type[]"/>
                    <param name="isAnonConstCall" type="boolean"/>
                    <param name="accessPackage" type="Identifier"/>
                </params>
                <comment line="991">
                    This may be too restrictive.                    
                </comment>
                <comment line="993">
                    collectInheritedMethods(env);                    
                </comment>
                <comment line="996">
                    A tentative maximally specific method.                    
                </comment>
                <comment line="999">
                    A list of other methods which may be maximally specific too.                    
                </comment>
                <comment line="1002">
                    Get all the methods inherited by this class which
                     have the name `methodName&apos;.                    
                </comment>
                <comment line="1009">
                    See if this method is applicable.                    
                </comment>
                <comment line="1014">
                    See if this method is accessible.                    
                </comment>
                <comment line="1024">
                    For anonymous constructor accesses, we
                     haven&apos;t yet built an accessing class.
                     We disallow anonymous classes from seeing
                     private/package-private inaccessible
                     constructors in their superclass.                    
                </comment>
                <comment line="1032">
                    If accessor is null, we assume that the access
                     is allowed.  Query: is this option used?                    
                </comment>
                <comment line="1037">
                    `method&apos; becomes our tentative maximally specific match.                    
                </comment>
                <comment line="1041">
                    We have found a method which is a strictly better
                     match than `tentative&apos;.  Replace it.                    
                </comment>
                <comment line="1045">
                    If this method could possibly be another
                     maximally specific method, add it to our
                     list of other candidates.                    
                </comment>
                <comment line="1059">
                    Find out if our `tentative&apos; match is a uniquely
                     maximally specific.                    
                </comment>
                <scope line="989"/>
                <declaration name="tentative" type="MemberDefinition" line="996"/>
                <declaration name="candidateList" type="List" line="999"/>
                <declaration name="methods" type="Iterator" line="1003"/>
                <scope line="1005">
                    <declaration name="method" type="MemberDefinition" line="1006"/>
                    <scope line="1009"/>
                    <scope line="1014">
                        <scope line="1015"/>
                    </scope>
                    <scope line="1018">
                        <scope line="1022"/>
                    </scope>
                    <scope line="1030"/>
                    <scope line="1035"/>
                    <scope line="1038">
                        <scope line="1039"/>
                        <scope line="1043">
                            <scope line="1047">
                                <scope line="1048"/>
                            </scope>
                        </scope>
                    </scope>
                </scope>
                <scope line="1057">
                    <declaration name="candidates" type="Iterator" line="1060"/>
                    <scope line="1061">
                        <declaration name="method" type="MemberDefinition" line="1062"/>
                        <scope line="1063"/>
                    </scope>
                </scope>
            </method>
            <javadoc line="1072">
                Lookup a method.  This code implements the method lookup
                  mechanism specified in JLS 15.11.2.
                  This mechanism cannot be used to lookup synthetic methods.                
            </javadoc>
            <method name="matchMethod" type="MemberDefinition" line="1082">
                <params>
                    <param name="env" type="Environment"/>
                    <param name="accessor" type="ClassDefinition"/>
                    <param name="methodName" type="Identifier"/>
                    <param name="argumentTypes" type="Type[]"/>
                </params>
            </method>
            <javadoc line="1088">
                Lookup a method.  This code implements the method lookup
                  mechanism specified in JLS 15.11.2.
                  This mechanism cannot be used to lookup synthetic methods.                
            </javadoc>
            <method name="matchMethod" type="MemberDefinition" line="1097">
                <params>
                    <param name="env" type="Environment"/>
                    <param name="accessor" type="ClassDefinition"/>
                    <param name="methodName" type="Identifier"/>
                </params>
            </method>
            <javadoc line="1103">
                A version of matchMethod to be used only for constructors
                  when we cannot pass in a sourceClass argument.  We just assert
                  our package name.
                  This is used only for anonymous classes, where we have to look up
                  a (potentially) protected constructor with no valid sourceClass
                  parameter available.                
            </javadoc>
            <method name="matchAnonConstructor" type="MemberDefinition" line="1115">
                <params>
                    <param name="env" type="Environment"/>
                    <param name="accessPackage" type="Identifier"/>
                    <param name="argumentTypes" type="Type"/>
                </params>
            </method>
            <javadoc line="1121">
                Find a method, ie: exact match in this class or any of the super
                  classes.
                  Only called by javadoc.  For now I am holding off rewriting this
                  code to rely on collectInheritedMethods(), as that code has
                  not gotten along with javadoc in the past.                
            </javadoc>
            <method name="findMethod" type="MemberDefinition" line="1130">
                <params>
                    <param name="env" type="Environment"/>
                    <param name="nm" type="Identifier"/>
                    <param name="t" type="Type"/>
                </params>
                <comment line="1132">
                    look in the current class                    
                </comment>
                <comment line="1135">
                    Note that non-method types return false for equalArguments().                    
                </comment>
                <comment line="1141">
                    constructors are not inherited                    
                </comment>
                <comment line="1146">
                    look in the super class                    
                </comment>
                <declaration name="f" type="MemberDefinition" line="1132"/>
                <scope line="1133">
                    <scope line="1135"/>
                </scope>
                <scope line="1141"/>
                <declaration name="sup" type="ClassDeclaration" line="1146"/>
            </method>
            <method name="basicCheck" type="void" line="1154">
                <params>
                    <param name="env" type="Environment"/>
                </params>
                <comment line="1156">
                    Do the outer class first.                    
                </comment>
            </method>
            <javadoc line="1160">
                Check this class.                
            </javadoc>
            <method name="check" type="void" line="1163">
                <params>
                    <param name="env" type="Environment"/>
                </params>
            </method>
            <method name="checkLocalClass" type="Vset" line="1169">
                <params>
                    <param name="env" type="Environment"/>
                    <param name="ctx" type="Context"/>
                    <param name="vset" type="Vset"/>
                    <param name="sup" type="ClassDefinition"/>
                    <param name="args" type="Expression"/>
                    <param name="argTypes" type="Type"/>
                </params>
            </method>
            <declaration name="allMethods" type="MethodSet" line="1179"/>
            <declaration name="permanentlyAbstractMethods" type="List" line="1189"/>
            <javadoc line="1191">
                This method returns an Iterator of all abstract methods
                  in our superclasses which we are unable to implement.                
            </javadoc>
            <method name="getPermanentlyAbstractMethods" type="Iterator" line="1195">
                <comment line="1197">
                    This method can only be called after collectInheritedMethods.                    
                </comment>
                <scope line="1197"/>
            </method>
            <declaration name="doInheritanceChecks" type="boolean" line="1204"/>
            <javadoc line="1204">
                A flag used by turnOffInheritanceChecks() to indicate if
                  inheritance checks are on or off.                
            </javadoc>
            <javadoc line="1210">
                This is a workaround to allow javadoc to turn off certain
                  inheritance/override checks which interfere with javadoc
                  badly.  In the future it might be good to eliminate the
                  shared sources of javadoc and javac to avoid the need for this
                  sort of workaround.                
            </javadoc>
            <method name="turnOffInheritanceChecks" type="void" line="1217"/>
            <javadoc line="1221">
                Add all of the methods declared in or above `parent&apos; to
                  `allMethods&apos;, the set of methods in the current class.
                  `myMethods&apos; is the set of all methods declared in this
                  class, and `mirandaMethods&apos; is a repository for Miranda methods.
                  If mirandaMethods is null, no mirandaMethods will be
                  generated.
                  For a definition of Miranda methods, see the comment above the
                  method addMirandaMethods() which occurs later in this file.                
            </javadoc>
            <method name="collectOneClass" type="void" line="1236">
                <params>
                    <param name="env" type="Environment"/>
                    <param name="parent" type="ClassDeclaration"/>
                    <param name="myMethods" type="MethodSet"/>
                    <param name="allMethods" type="MethodSet"/>
                    <param name="mirandaMethods" type="MethodSet"/>
                </params>
                <comment line="1239">
                    System.out.println(&quot;Inheriting methods from &quot; + parent);                    
                </comment>
                <comment line="1248">
                    Private methods are not inherited.
                    
                     Constructors are not inherited.
                    
                     Any non-abstract methods in an interface come
                     from java.lang.Object.  This means that they
                     should have already been added to allMethods
                     when we walked our superclass lineage.                    
                </comment>
                <comment line="1263">
                    Get the components of the methods&apos; signature.                    
                </comment>
                <comment line="1267">
                    Check for a method of the same signature which
                     was locally declared.                    
                </comment>
                <comment line="1272">
                    Is this method inaccessible due to package-private
                     visibility?                    
                </comment>
                <comment line="1279">
                    We give a warning when a class shadows an
                     inaccessible package-private method from
                     its superclass.  This warning is meant
                     to prevent people from relying on overriding
                     when it does not happen.  This warning should
                     probably be removed to be consistent with the
                     general &quot;no warnings&quot; policy of this
                     compiler.
                    
                     The `instanceof&apos; above is a hack so that only
                     SourceClass generates this warning, not a
                     BinaryClass, for example.                    
                </comment>
                <comment line="1298">
                    If our superclass has a package-private abstract
                     method that we have no access to, then we add
                     this method to our list of permanently abstract
                     methods.  The idea is, since we cannot override
                     the method, we can never make this class
                     non-abstract.                    
                </comment>
                <comment line="1308">
                    `method&apos; is inaccessible.  We do not inherit it.                    
                </comment>
                <comment line="1313">
                    `method&apos; and `override&apos; have the same signature.
                     We are required to check that `override&apos; is a
                     legal override of `method&apos;                    
                </comment>
                <comment line="1317">
                    System.out.println (&quot;About to check override of &quot; +
                                  method);                    
                </comment>
                <comment line="1322">
                    In the absence of a definition in the class
                     itself, we check to see if this definition
                     can be successfully merged with any other
                     inherited definitions.                    
                </comment>
                <comment line="1327">
                    Have we added a member of the same signature
                     to `allMethods&apos; already?                    
                </comment>
                <comment line="1332">
                    If the previous definition is nonexistent or
                     ignorable, replace it.                    
                </comment>
                <comment line="1335">
                    System.out.println(&quot;Added &quot; + method + &quot; to &quot; +
                                 this);                    
                </comment>
                <comment line="1340">
                    Whenever a class inherits a method
                     from an interface, that method is
                     one of our &quot;miranda&quot; methods.  Early
                     VMs require that these methods be
                     added as true members to the class
                     to enable method lookup to work in the
                     VM.                    
                </comment>
                <comment line="1352">
                    System.out.println(&quot;Added &quot; + method +
                     &quot; to &quot; + this + &quot; as a Miranda&quot;);                    
                </comment>
                <comment line="1356">
                    There is no previous inherited definition.
                     Add `method&apos; to `allMethods&apos;.                    
                </comment>
                <comment line="1362">
                    If we are in an interface and we have inherited
                     both an abstract method and a non-abstract method
                     then we know that the non-abstract method is
                     a placeholder from Object put in for type checking
                     and the abstract method was already checked to
                     be proper by our superinterface.                    
                </comment>
                <comment line="1371">
                    Okay, `formerMethod&apos; and `method&apos; both have the
                     same signature.  See if they are compatible.                    
                </comment>
                <comment line="1374">
                    System.out.println (&quot;About to check meet of &quot; +
                                  method);                    
                </comment>
                <comment line="1380">
                    The methods are incompatible.  Skip to
                     next method.                    
                </comment>
                <comment line="1386">
                    Do nothing.  The current definition
                     is specific enough.                    
                </comment>
                <comment line="1389">
                    System.out.println(&quot;trivial meet of &quot; +
                                     method);                    
                </comment>
                <comment line="1395">
                    `method&apos; is more specific than
                     `formerMethod&apos;.  replace `formerMethod&apos;.                    
                </comment>
                <comment line="1398">
                    System.out.println(&quot;new def of &quot; + method);                    
                </comment>
                <comment line="1401">
                    Whenever a class inherits a method
                     from an interface, that method is
                     one of our &quot;miranda&quot; methods.  Early
                     VMs require that these methods be
                     added as true members to the class
                     to enable method lookup to work in the
                     VM.                    
                </comment>
                <comment line="1414">
                    System.out.println(&quot;Added &quot; + method +
                     &quot; to &quot; + this + &quot; as a Miranda&quot;);                    
                </comment>
                <comment line="1423">
                    Neither method is more specific than the other.
                     Oh well.  We need to construct a nontrivial
                     meet of the two methods.
                    
                     This is not yet implemented, so we give
                     a message with a helpful workaround.                    
                </comment>
                <scope line="1240">
                    <declaration name="pClass" type="ClassDefinition" line="1241"/>
                    <declaration name="methods" type="Iterator" line="1242"/>
                    <scope line="1243">
                        <declaration name="method" type="MemberDefinition" line="1244"/>
                        <scope line="1257"/>
                        <declaration name="name" type="Identifier" line="1263"/>
                        <declaration name="type" type="Type" line="1264"/>
                        <declaration name="override" type="MemberDefinition" line="1268"/>
                        <scope line="1274">
                            <scope line="1277"/>
                            <scope line="1303"/>
                        </scope>
                        <scope line="1311"/>
                        <scope line="1320">
                            <declaration name="formerMethod" type="MemberDefinition" line="1328"/>
                            <scope line="1333">
                                <scope line="1338"/>
                            </scope>
                            <scope line="1360"/>
                            <scope line="1369">
                                <scope line="1378"/>
                                <scope line="1384"/>
                                <scope line="1393">
                                    <scope line="1399"/>
                                </scope>
                            </scope>
                        </scope>
                    </scope>
                </scope>
                <scope line="1436"/>
            </method>
            <javadoc line="1441">
                &lt;p&gt;Collect all methods defined in this class or inherited from
                  any of our superclasses or interfaces.  Look for any
                  incompatible definitions.
                  &lt;p&gt;This function is also responsible for collecting the
                  &lt;em&gt;Miranda&lt;/em&gt; methods for a class.  For a definition of
                  Miranda methods, see the comment in addMirandaMethods()
                  below.                
            </javadoc>
            <method name="collectInheritedMethods" type="void" line="1451">
                <params>
                    <param name="env" type="Environment"/>
                </params>
                <comment line="1453">
                    The methods defined in this class.                    
                </comment>
                <comment line="1457">
                    System.out.println(&quot;Called collectInheritedMethods() for &quot; +
                                     this);                    
                </comment>
                <comment line="1462">
                    We have already done the collection.  No need to
                     do it again.                    
                </comment>
                <comment line="1466">
                    We have run into a circular need to collect our methods.
                     This should not happen at this stage.                    
                </comment>
                <comment line="1475">
                    For testing, do not generate miranda methods.                    
                </comment>
                <comment line="1482">
                    Any methods defined in the current class get added
                     to both the myMethods and the allMethods MethodSets.                    
                </comment>
                <comment line="1489">
                    We only collect methods.  Initializers are not relevant.                    
                </comment>
                <comment line="1493">
                    System.out.println(&quot;Declared in &quot; + this + &quot;, &quot; + member);                    
                </comment>
                <comment line="1495">
                    //////////////////////////////////////////////////////////
                     PCJ 2003-07-30 modified the following code because with
                     the covariant return type feature of the 1.5 compiler,
                     there might be multiple methods with the same signature
                     but different return types, and MethodSet doesn&apos;t
                     support that.  We use a new utility method that attempts
                     to ensure that the appropriate method winds up in the
                     MethodSet.  See 4892308.
                    
                     myMethods.add(member);
                     allMethods.add(member);                    
                </comment>
                <comment line="1509">
                    //////////////////////////////////////////////////////////                    
                </comment>
                <comment line="1513">
                    We&apos;re ready to start adding inherited methods.  First add
                     the methods from our superclass.                    
                </comment>
                <comment line="1516">
                    System.out.println(&quot;About to start superclasses for &quot; + this);                    
                </comment>
                <comment line="1523">
                    Make sure that we add all unimplementable methods from our
                     superclass to our list of unimplementable methods.                    
                </comment>
                <comment line="1532">
                    Now we inherit all of the methods from our interfaces.                    
                </comment>
                <comment line="1534">
                    System.out.println(&quot;About to start interfaces for &quot; + this);                    
                </comment>
                <comment line="1542">
                    Now we have collected all of our methods from our superclasses
                     and interfaces into our `allMethods&apos; member.  Good.  As a last
                     task, we add our collected miranda methods to this class.
                    
                     If we do not add the mirandas to the class explicitly, there
                     will be no code generated for them.                    
                </comment>
                <declaration name="myMethods" type="MethodSet" line="1453"/>
                <declaration name="mirandaMethods" type="MethodSet" line="1454"/>
                <scope line="1459">
                    <scope line="1460"/>
                    <scope line="1464"/>
                </scope>
                <scope line="1475"/>
                <scope line="1477"/>
                <scope line="1486">
                    <scope line="1490"/>
                </scope>
                <declaration name="scDecl" type="ClassDeclaration" line="1517"/>
                <scope line="1518">
                    <declaration name="sc" type="ClassDefinition" line="1524"/>
                    <declaration name="supIter" type="Iterator" line="1525"/>
                    <scope line="1526"/>
                </scope>
                <scope line="1535"/>
                <scope line="1547"/>
            </method>
            <method name="methodSetAdd" type="void" line="1568">
                <params>
                    <param name="env" type="Environment"/>
                    <param name="methodSet" type="MethodSet"/>
                    <param name="newMethod" type="MemberDefinition"/>
                </params>
                <declaration name="oldMethod" type="MemberDefinition" line="1569"/>
                <scope line="1571">
                    <declaration name="oldReturnType" type="Type" line="1572"/>
                    <declaration name="newReturnType" type="Type" line="1573"/>
                    <scope line="1574">
                        <scope line="1575"/>
                    </scope>
                    <scope line="1578"/>
                </scope>
                <scope line="1580"/>
            </method>
            <javadoc line="1586">
                Get an Iterator of all methods which could be accessed in an
                  instance of this class.                
            </javadoc>
            <method name="getMethods" type="Iterator" line="1590">
                <params>
                    <param name="env" type="Environment"/>
                </params>
                <scope line="1591"/>
            </method>
            <javadoc line="1597">
                Get an Iterator of all methods which could be accessed in an
                  instance of this class.  Throw a compiler error if we haven&apos;t
                  generated this information yet.                
            </javadoc>
            <method name="getMethods" type="Iterator" line="1602">
                <scope line="1603"/>
            </method>
            <javadoc line="1631">
                Add a list of methods to this class as miranda methods.  This
                  gets overridden with a meaningful implementation in SourceClass.
                  BinaryClass should not need to do anything -- it should already
                  have its miranda methods and, if it doesn&apos;t, then that doesn&apos;t
                  affect our compilation.                
            </javadoc>
            <method name="addMirandaMethods" type="void" line="1639">
                <params>
                    <param name="env" type="Environment"/>
                    <param name="mirandas" type="Iterator"/>
                </params>
                <comment line="1641">
                    do nothing.                    
                </comment>
            </method>
            <method name="inlineLocalClass" type="void" line="1645">
                <params>
                    <param name="env" type="Environment"/>
                </params>
            </method>
            <javadoc line="1648">
                We create a stub for this.  Source classes do more work.
                  Some calls from &apos;SourceClass.checkSupers&apos; execute this method.                
                <see>
                    sun.tools.javac.SourceClass#resolveTypeStructure                    
                </see>
            </javadoc>
            <method name="resolveTypeStructure" type="void" line="1654">
                <params>
                    <param name="env" type="Environment"/>
                </params>
            </method>
            <javadoc line="1657">
                Look up an inner class name, from somewhere inside this class.
                  Since supers and outers are in scope, search them too.
                  &lt;p&gt;
                  If no inner class is found, env.resolveName() is then called,
                  to interpret the ambient package and import directives.
                  &lt;p&gt;
                  This routine operates on a &quot;best-efforts&quot; basis.  If
                  at some point a class is not found, the partially-resolved
                  identifier is returned.  Eventually, someone else has to
                  try to get the ClassDefinition and diagnose the ClassNotFound.
                  &lt;p&gt;
                  resolveName() looks at surrounding scopes, and hence
                  pulling in both inherited and uplevel types.  By contrast,
                  resolveInnerClass() is intended only for interpreting
                  explicitly qualified names, and so look only at inherited
                  types.  Also, resolveName() looks for package prefixes,
                  which appear similar to &quot;very uplevel&quot; outer classes.
                  &lt;p&gt;
                  A similar (but more complex) name-lookup process happens
                  when field and identifier expressions denoting qualified names
                  are type-checked.  The added complexity comes from the fact
                  that variables may occur in such names, and take precedence
                  over class and package names.
                  &lt;p&gt;
                  In the expression type-checker, resolveInnerClass() is paralleled
                  by code in FieldExpression.checkAmbigName(), which also calls
                  ClassDefinition.getInnerClass() to interpret names of the form
                  &quot;OuterClass.Inner&quot; (and also outerObject.Inner).  The checking
                  of an identifier expression that fails to be a variable is referred
                  directly to resolveName().                
            </javadoc>
            <method name="resolveName" type="Identifier" line="1689">
                <params>
                    <param name="env" type="Environment"/>
                    <param name="name" type="Identifier"/>
                </params>
                <comment line="1692">
                    This logic is pretty much exactly parallel to that of
                     Environment.resolveName().                    
                </comment>
                <comment line="1695">
                    Try to resolve the first identifier component,
                     because inner class names take precedence over
                     package prefixes.  (Cf. Environment.resolveName.)                    
                </comment>
                <comment line="1701">
                    The first identifier component refers to an
                     ambiguous class.  Limp on.  We throw away the
                     rest of the classname as it is irrelevant.
                     (part of solution for 4059855).                    
                </comment>
                <comment line="1715">
                    return partially-resolved name someone else can fail on                    
                </comment>
                <comment line="1720">
                    This method used to fail to look for local classes, thus a
                     reference to a local class within, e.g., the type of a member
                     declaration, would fail to resolve if the immediately enclosing
                     context was an inner class.  The code added below is ugly, but
                     it works, and is lifted from existing code in &apos;Context.resolveName&apos;
                     and &apos;Context.getClassCommon&apos;. See the comments there about the design.
                     Fixes 4095716.                    
                </comment>
                <comment line="1737">
                    Look for an unqualified name in enclosing scopes.                    
                </comment>
                <comment line="1743">
                    An uplevel member was found, and was nested more deeply than
                     any enclosing local of the same name.                    
                </comment>
                <comment line="1748">
                    a missing superclass, or something catastrophic                    
                </comment>
                <comment line="1752">
                    No uplevel member found, so use the enclosing local if one was found.                    
                </comment>
                <comment line="1757">
                    look in imports, etc.                    
                </comment>
                <scope line="1693">
                    <declaration name="rhead" type="Identifier" line="1697"/>
                    <scope line="1699"/>
                    <scope line="1707"/>
                    <scope line="1710"/>
                    <scope line="1713"/>
                </scope>
                <declaration name="ls" type="int" line="1727"/>
                <declaration name="lf" type="LocalMember" line="1728"/>
                <scope line="1729">
                    <scope line="1731"/>
                </scope>
                <scope line="1737">
                    <scope line="1738">
                        <declaration name="f" type="MemberDefinition" line="1739"/>
                        <scope line="1741"/>
                    </scope>
                    <scope line="1746"/>
                </scope>
                <scope line="1752"/>
            </method>
            <javadoc line="1760">
                Interpret a qualified class name, which may have further subcomponents..
                  Follow inheritance links, as in:
                  class C { class N { } }  class D extends C { }  ... new D.N() ...
                  Ignore outer scopes and packages.                
                <see>
                    resolveName                    
                </see>
            </javadoc>
            <method name="resolveInnerClass" type="Identifier" line="1767">
                <params>
                    <param name="env" type="Environment"/>
                    <param name="nm" type="Identifier"/>
                </params>
                <comment line="1776">
                    return partially-resolved name someone else can fail on                    
                </comment>
                <comment line="1786">
                    a missing superclass, or something catastrophic                    
                </comment>
                <comment line="1788">
                    Fake a good name for a diagnostic.                    
                </comment>
                <scope line="1769">
                    <declaration name="rhead" type="Identifier" line="1770"/>
                    <scope line="1771"/>
                    <scope line="1774"/>
                </scope>
                <scope line="1778">
                    <scope line="1779">
                        <declaration name="f" type="MemberDefinition" line="1780"/>
                        <scope line="1781"/>
                    </scope>
                    <scope line="1784"/>
                </scope>
            </method>
            <javadoc line="1792">
                While resolving import directives, the question has arisen:
                  does a given inner class exist?  If the top-level class exists,
                  we ask it about an inner class via this method.
                  This method looks only at the literal name of the class,
                  and does not attempt to follow inheritance links.
                  This is necessary, since at the time imports are being
                  processed, inheritance links have not been resolved yet.
                  (Thus, an import directive must always spell a class
                  name exactly.)                
            </javadoc>
            <method name="innerClassExists" type="boolean" line="1803">
                <params>
                    <param name="nm" type="Identifier"/>
                </params>
                <comment line="1808">
                    ignore this name; it is internally generated                    
                </comment>
                <scope line="1804">
                    <scope line="1805">
                        <scope line="1806"/>
                    </scope>
                </scope>
            </method>
            <javadoc line="1816">
                Find any method with a given name.                
            </javadoc>
            <method name="findAnyMethod" type="MemberDefinition" line="1819">
                <params>
                    <param name="env" type="Environment"/>
                    <param name="nm" type="Identifier"/>
                </params>
                <comment line="1828">
                    look in the super class                    
                </comment>
                <declaration name="f" type="MemberDefinition" line="1820"/>
                <scope line="1821">
                    <scope line="1822"/>
                </scope>
                <declaration name="sup" type="ClassDeclaration" line="1828"/>
            </method>
            <javadoc line="1834">
                Given the fact that this class has no method &quot;nm&quot; matching &quot;argTypes&quot;,
                  find out if the mismatch can be blamed on a particular actual argument
                  which disagrees with all of the overloadings.
                  If so, return the code (i&lt;&lt;2)+(castOK&lt;&lt;1)+ambig, where
                  &quot;i&quot; is the number of the offending argument, and
                  &quot;castOK&quot; is 1 if a cast could fix the problem.
                  The target type for the argument is returned in margTypeResult[0].
                  If not all methods agree on this type, &quot;ambig&quot; is 1.
                  If there is more than one method, the choice of target type is
                  arbitrary.&lt;p&gt;
                  Return -1 if every argument is acceptable to at least one method.
                  Return -2 if there are no methods of the required arity.
                  The value &quot;start&quot; gives the index of the first argument to begin
                  checking.                
            </javadoc>
            <method name="diagnoseMismatch" type="int" line="1851">
                <params>
                    <param name="env" type="Environment"/>
                    <param name="nm" type="Identifier"/>
                    <param name="argTypes" type="Type"/>
                    <param name="start" type="int"/>
                    <param name="margTypeResult" type="Type"/>
                </params>
                <declaration name="haveMatch" type="int" line="1852"/>
                <declaration name="margType" type="Type" line="1853"/>
                <scope line="1856">
                    <scope line="1857"/>
                </scope>
            </method>
            <method name="diagnoseMismatch" type="boolean" line="1866">
                <params>
                    <param name="env" type="Environment"/>
                    <param name="nm" type="Identifier"/>
                    <param name="argTypes" type="Type"/>
                    <param name="start" type="int"/>
                    <param name="haveMatch" type="int"/>
                    <param name="margType" type="Type"/>
                </params>
                <comment line="1868">
                    look in the current class                    
                </comment>
                <comment line="1898">
                    constructors are not inherited                    
                </comment>
                <comment line="1903">
                    look in the super class                    
                </comment>
                <declaration name="haveOne" type="boolean" line="1868"/>
                <declaration name="f" type="MemberDefinition" line="1869"/>
                <scope line="1870">
                    <scope line="1871"/>
                    <declaration name="fArgTypes" type="Type" line="1874"/>
                    <scope line="1875">
                        <scope line="1877">
                            <declaration name="at" type="Type" line="1878"/>
                            <declaration name="ft" type="Type" line="1879"/>
                            <scope line="1880"/>
                            <scope line="1883"/>
                            <scope line="1886"/>
                        </scope>
                    </scope>
                </scope>
                <scope line="1898"/>
                <declaration name="sup" type="ClassDeclaration" line="1903"/>
                <scope line="1904"/>
            </method>
            <javadoc line="1912">
                Add a field (no checks)                
            </javadoc>
            <method name="addMember" type="void" line="1915">
                <params>
                    <param name="field" type="MemberDefinition"/>
                </params>
                <comment line="1917">
                    System.out.println(&quot;ADD = &quot; + field);                    
                </comment>
                <comment line="1922">
                    insert this at the front, because of initialization order                    
                </comment>
                <scope line="1917"/>
                <scope line="1920"/>
                <scope line="1925"/>
            </method>
            <javadoc line="1933">
                Add a field (subclasses make checks)                
            </javadoc>
            <method name="addMember" type="void" line="1936">
                <params>
                    <param name="env" type="Environment"/>
                    <param name="field" type="MemberDefinition"/>
                </params>
                <comment line="1940">
                    a late addition                    
                </comment>
                <scope line="1938"/>
            </method>
            <javadoc line="1944">
                Find or create an uplevel reference for the given target.                
            </javadoc>
            <method name="getReference" type="UplevelReference" line="1947">
                <params>
                    <param name="target" type="LocalMember"/>
                </params>
                <scope line="1948">
                    <scope line="1949"/>
                </scope>
            </method>
            <method name="addReference" type="UplevelReference" line="1956">
                <params>
                    <param name="target" type="LocalMember"/>
                </params>
                <scope line="1957"/>
                <declaration name="r" type="UplevelReference" line="1961"/>
            </method>
            <javadoc line="1966">
                Return the list of all uplevel references.                
            </javadoc>
            <method name="getReferences" type="UplevelReference" line="1969"/>
            <javadoc line="1973">
                Return the same value as getReferences.
                  Also, mark the set of references frozen.
                  After that, it is an error to add new references.                
            </javadoc>
            <method name="getReferencesFrozen" type="UplevelReference" line="1978"/>
            <javadoc line="1983">
                assertion check                
            </javadoc>
            <method name="referencesMustNotBeFrozen" type="void" line="1986">
                <scope line="1987"/>
            </method>
            <javadoc line="1992">
                Get helper method for class literal lookup.                
            </javadoc>
            <method name="getClassLiteralLookup" type="MemberDefinition" line="1995">
                <params>
                    <param name="fwhere" type="long"/>
                </params>
            </method>
            <javadoc line="1999">
                Add a dependency                
            </javadoc>
            <method name="addDependency" type="void" line="2002">
                <params>
                    <param name="c" type="ClassDeclaration"/>
                </params>
            </method>
            <javadoc line="2006">
                Maintain a hash table of local and anonymous classes
                  whose internal names are prefixed by the current class.
                  The key is the simple internal name, less the prefix.                
            </javadoc>
            <method name="getLocalClass" type="ClassDefinition" line="2012">
                <params>
                    <param name="name" type="String"/>
                </params>
                <scope line="2013"/>
                <scope line="2015"/>
            </method>
            <method name="addLocalClass" type="void" line="2020">
                <params>
                    <param name="c" type="ClassDefinition"/>
                    <param name="name" type="String"/>
                </params>
                <scope line="2021"/>
            </method>
            <javadoc line="2028">
                Print for debugging                
            </javadoc>
            <method name="print" type="void" line="2031">
                <params>
                    <param name="out" type="PrintStream"/>
                </params>
                <scope line="2032"/>
                <scope line="2035"/>
                <scope line="2037"/>
                <scope line="2041"/>
                <scope line="2044">
                    <scope line="2046">
                        <scope line="2047"/>
                    </scope>
                </scope>
                <scope line="2056"/>
            </method>
            <javadoc line="2064">
                Convert to String                
            </javadoc>
            <method name="toString" type="String" line="2067"/>
            <javadoc line="2071">
                After the class has been written to disk, try to free up
                  some storage.                
            </javadoc>
            <method name="cleanup" type="void" line="2075">
                <params>
                    <param name="env" type="Environment"/>
                </params>
                <comment line="2083">
                    keep &quot;references&quot; around, for the sake of local subclasses                    
                </comment>
                <scope line="2076"/>
                <scope line="2079"/>
            </method>
        </class>
    </source>