<?xml version="1.0" encoding="UTF-8"?>
    <source package="sun.tools.java">
        <import package="java.util"/>
        <import package="java.io.OutputStream"/>
        <import package="java.io.PrintStream"/>
        <import package="sun.tools.tree.Context"/>
        <import package="sun.tools.tree.Vset"/>
        <import package="sun.tools.tree.Expression"/>
        <import package="sun.tools.tree.LocalMember"/>
        <import package="sun.tools.tree.UplevelReference"/>
        <class name="ClassDefinition" line="10">
            <implements interface="Constants"/>
            <javadoc line="10">
                This class is a Java class definition
                  WARNING: The contents of this source file are not part of any
                  supported API.  Code that depends on them does so at its own risk:
                  they are subject to change or removal without notice.                
            </javadoc>
            <declaration name="source" type="Object" line="17"/>
            <declaration name="where" type="long" line="18"/>
            <declaration name="modifiers" type="int" line="19"/>
            <declaration name="localName" type="Identifier" line="20"/>
            <declaration name="declaration" type="ClassDeclaration" line="21"/>
            <declaration name="superClassId" type="IdentifierToken" line="22"/>
            <declaration name="interfaceIds" type="IdentifierToken" line="23"/>
            <declaration name="superClass" type="ClassDeclaration" line="24"/>
            <declaration name="interfaces" type="ClassDeclaration" line="25"/>
            <declaration name="outerClass" type="ClassDefinition" line="26"/>
            <declaration name="outerMember" type="MemberDefinition" line="27"/>
            <declaration name="innerClassMember" type="MemberDefinition" line="28"/>
            <declaration name="firstMember" type="MemberDefinition" line="29"/>
            <declaration name="lastMember" type="MemberDefinition" line="30"/>
            <declaration name="resolved" type="boolean" line="31"/>
            <declaration name="documentation" type="String" line="32"/>
            <declaration name="error" type="boolean" line="33"/>
            <declaration name="nestError" type="boolean" line="34"/>
            <declaration name="references" type="UplevelReference" line="35"/>
            <declaration name="referencesFrozen" type="boolean" line="36"/>
            <declaration name="fieldHash" type="Hashtable" line="37"/>
            <declaration name="abstr" type="int" line="38"/>
            <declaration name="localClasses" type="Hashtable" line="39"/>
            <declaration name="LOCAL_CLASSES_SIZE" type="int" line="40"/>
            <declaration name="classContext" type="Context" line="41"/>
            <method name="getClassContext" type="Context" line="42"/>
            <javadoc line="45">
                Constructor                
            </javadoc>
            <method name="ClassDefinition" type="constructor" line="48">
                <params>
                    <param name="source" type="Object"/>
                    <param name="where" type="long"/>
                    <param name="declaration" type="ClassDeclaration"/>
                    <param name="modifiers" type="int"/>
                    <param name="superClass" type="IdentifierToken"/>
                    <param name="interfaces" type="IdentifierToken"/>
                </params>
            </method>
            <javadoc line="56">
                Get the source of the class                
            </javadoc>
            <method name="getSource" type="Object" line="59"/>
            <javadoc line="62">
                Check if there were any errors in this class.                
            </javadoc>
            <method name="getError" type="boolean" line="65"/>
            <javadoc line="68">
                Mark this class to be erroneous.                
            </javadoc>
            <method name="setError" type="void" line="71"/>
            <javadoc line="75">
                Check if there were any errors in our class nest.                
            </javadoc>
            <method name="getNestError" type="boolean" line="78"/>
            <javadoc line="81">
                Mark this class, and all siblings in its class nest, to be
                  erroneous.                
            </javadoc>
            <method name="setNestError" type="void" line="85">
                <scope line="87"/>
            </method>
            <javadoc line="91">
                Get the position in the input                
            </javadoc>
            <method name="getWhere" type="long" line="94"/>
            <javadoc line="97">
                Get the class declaration                
            </javadoc>
            <method name="getClassDeclaration" type="ClassDeclaration" line="100"/>
            <javadoc line="103">
                Get the class&apos; modifiers                
            </javadoc>
            <method name="getModifiers" type="int" line="106"/>
            <method name="subModifiers" type="void" line="109">
                <params>
                    <param name="mod" type="int"/>
                </params>
            </method>
            <method name="addModifiers" type="void" line="112">
                <params>
                    <param name="mod" type="int"/>
                </params>
            </method>
            <declaration name="supersCheckStarted" type="boolean" line="115"/>
            <javadoc line="116">
                Get the class&apos; super class                
            </javadoc>
            <method name="getSuperClass" type="ClassDeclaration" line="119"/>
            <javadoc line="123">
                Get the super class, and resolve names now if necessary.
                  It is only possible to resolve names at this point if we are
                  a source class.  The provision of this method at this level
                  in the class hierarchy is dubious, but see &apos;getInnerClass&apos; below.
                  All other calls to &apos;getSuperClass(env)&apos; appear in &apos;SourceClass&apos;.
                  NOTE: An older definition of this method has been moved to
                  &apos;SourceClass&apos;, where it overrides this one.                
                <see>
                    #resolveTypeStructure                    
                </see>
            </javadoc>
            <method name="getSuperClass" type="ClassDeclaration" line="133">
                <params>
                    <param name="env" type="Environment"/>
                </params>
            </method>
            <javadoc line="136">
                Get the class&apos; interfaces                
            </javadoc>
            <method name="getInterfaces" type="ClassDeclaration" line="139"/>
            <javadoc line="143">
                Get the class&apos; enclosing class (or null if not inner)                
            </javadoc>
            <method name="getOuterClass" type="ClassDefinition" line="146"/>
            <javadoc line="149">
                Set the class&apos; enclosing class.  Must be done at most once.                
            </javadoc>
            <method name="setOuterClass" type="void" line="152">
                <params>
                    <param name="outerClass" type="ClassDefinition"/>
                </params>
            </method>
            <javadoc line="156">
                Set the class&apos; enclosing current instance pointer.
                  Must be done at most once.                
            </javadoc>
            <method name="setOuterMember" type="void" line="160">
                <params>
                    <param name="outerMember" type="MemberDefinition"/>
                </params>
            </method>
            <javadoc line="165">
                Tell if the class is inner.
                  This predicate also returns true for top-level nested types.
                  To test for a true inner class as seen by the programmer,
                  use &lt;tt&gt;!isTopLevel()&lt;/tt&gt;.                
            </javadoc>
            <method name="isInnerClass" type="boolean" line="171"/>
            <javadoc line="174">
                Tell if the class is a member of another class.
                  This is false for package members and for block-local classes.                
            </javadoc>
            <method name="isMember" type="boolean" line="178"/>
            <javadoc line="181">
                Tell if the class is &quot;top-level&quot;, which is either a package member,
                  or a static member of another top-level class.                
            </javadoc>
            <method name="isTopLevel" type="boolean" line="185"/>
            <javadoc line="188">
                Tell if the class is local or inside a local class,
                  which means it cannot be mentioned outside of its file.                
            </javadoc>
            <method name="isInsideLocal" type="boolean" line="192"/>
            <javadoc line="195">
                Tell if the class is local or or anonymous class, or inside
                  such a class, which means it cannot be mentioned outside of
                  its file.                
            </javadoc>
            <method name="isInsideLocalOrAnonymous" type="boolean" line="200"/>
            <javadoc line="203">
                Return a simple identifier for this class (idNull if anonymous).                
            </javadoc>
            <method name="getLocalName" type="Identifier" line="206">
                <scope line="207"/>
            </method>
            <javadoc line="212">
                Set the local name of a class.  Must be a local class.                
            </javadoc>
            <method name="setLocalName" type="void" line="215">
                <params>
                    <param name="name" type="Identifier"/>
                </params>
                <scope line="216"/>
            </method>
            <javadoc line="220">
                If inner, get the field for this class in the enclosing class                
            </javadoc>
            <method name="getInnerClassMember" type="MemberDefinition" line="223">
                <scope line="225">
                    <declaration name="nm" type="Identifier" line="226"/>
                    <scope line="227">
                        <scope line="228"/>
                    </scope>
                </scope>
            </method>
            <javadoc line="237">
                If inner, return an innermost uplevel self pointer, if any exists.
                  Otherwise, return null.                
            </javadoc>
            <method name="findOuterMember" type="MemberDefinition" line="241"/>
            <javadoc line="244">
                See if this is a (nested) static class.                
            </javadoc>
            <method name="isStatic" type="boolean" line="247"/>
            <javadoc line="250">
                Get the class&apos; top-level enclosing class                
            </javadoc>
            <method name="getTopClass" type="ClassDefinition" line="253">
                <declaration name="p" type="ClassDefinition" line="254"/>
            </method>
            <javadoc line="258">
                Get the class&apos; first field or first match                
            </javadoc>
            <method name="getFirstMember" type="MemberDefinition" line="261"/>
            <method name="getFirstMatch" type="MemberDefinition" line="264">
                <params>
                    <param name="name" type="Identifier"/>
                </params>
            </method>
            <javadoc line="267">
                Get the class&apos; name                
            </javadoc>
            <method name="getName" type="Identifier" line="270"/>
            <javadoc line="273">
                Get the class&apos; type                
            </javadoc>
            <method name="getType" type="Type" line="276"/>
            <javadoc line="279">
                Get the class&apos; documentation                
            </javadoc>
            <method name="getDocumentation" type="String" line="282"/>
            <javadoc line="285">
                Return true if the given documentation string contains a deprecation
                  paragraph.  This is true if the string contains the tag @deprecated
                  is the first word in a line.                
            </javadoc>
            <method name="containsDeprecated" type="boolean" line="290">
                <params>
                    <param name="documentation" type="String"/>
                </params>
                <scope line="291"/>
                <scope line="294">
                    <scope line="295">
                        <declaration name="ch" type="char" line="296"/>
                        <scope line="297"/>
                        <scope line="300"/>
                    </scope>
                    <declaration name="end" type="int" line="304"/>
                    <scope line="305">
                        <declaration name="ch" type="char" line="306"/>
                        <scope line="307"/>
                    </scope>
                </scope>
            </method>
            <method name="inSamePackage" type="boolean" line="315">
                <params>
                    <param name="c" type="ClassDeclaration"/>
                </params>
            </method>
            <method name="inSamePackage" type="boolean" line="318">
                <params>
                    <param name="c" type="ClassDefinition"/>
                </params>
            </method>
            <method name="inSamePackage" type="boolean" line="321">
                <params>
                    <param name="packageName" type="Identifier"/>
                </params>
            </method>
            <javadoc line="324">
                Checks                
            </javadoc>
            <method name="isInterface" type="boolean" line="327"/>
            <method name="isClass" type="boolean" line="330"/>
            <method name="isPublic" type="boolean" line="333"/>
            <method name="isPrivate" type="boolean" line="336"/>
            <method name="isProtected" type="boolean" line="339"/>
            <method name="isPackagePrivate" type="boolean" line="342"/>
            <method name="isFinal" type="boolean" line="345"/>
            <method name="isAbstract" type="boolean" line="348"/>
            <method name="isSynthetic" type="boolean" line="351"/>
            <method name="isDeprecated" type="boolean" line="354"/>
            <method name="isAnonymous" type="boolean" line="357"/>
            <method name="isLocal" type="boolean" line="360"/>
            <method name="hasConstructor" type="boolean" line="363"/>
            <javadoc line="366">
                Check to see if a class must be abstract.  This method replaces
                  isAbstract(env)                
            </javadoc>
            <method name="mustBeAbstract" type="boolean" line="370">
                <params>
                    <param name="env" type="Environment"/>
                </params>
                <scope line="371"/>
                <declaration name="methods" type="Iterator" line="375"/>
                <scope line="376">
                    <declaration name="method" type="MemberDefinition" line="377"/>
                    <scope line="378"/>
                </scope>
            </method>
            <javadoc line="384">
                Check if this is a super class of another class                
            </javadoc>
            <method name="superClassOf" type="boolean" line="387">
                <params>
                    <param name="env" type="Environment"/>
                    <param name="otherClass" type="ClassDeclaration"/>
                </params>
                <scope line="388">
                    <scope line="389"/>
                </scope>
            </method>
            <javadoc line="396">
                Check if this is an enclosing class of another class                
            </javadoc>
            <method name="enclosingClassOf" type="boolean" line="399">
                <params>
                    <param name="otherClass" type="ClassDefinition"/>
                </params>
                <scope line="400">
                    <scope line="401"/>
                </scope>
            </method>
            <javadoc line="407">
                Check if this is a sub class of another class                
            </javadoc>
            <method name="subClassOf" type="boolean" line="410">
                <params>
                    <param name="env" type="Environment"/>
                    <param name="otherClass" type="ClassDeclaration"/>
                </params>
                <declaration name="c" type="ClassDeclaration" line="411"/>
                <scope line="412">
                    <scope line="413"/>
                </scope>
            </method>
            <javadoc line="420">
                Check if this class is implemented by another class                
            </javadoc>
            <method name="implementedBy" type="boolean" line="423">
                <params>
                    <param name="env" type="Environment"/>
                    <param name="c" type="ClassDeclaration"/>
                </params>
                <scope line="424">
                    <scope line="425"/>
                    <declaration name="intf" type="ClassDeclaration" line="428"/>
                    <scope line="429">
                        <scope line="430"/>
                    </scope>
                </scope>
            </method>
            <javadoc line="437">
                Check to see if a class which implements interface `this&apos; could
                  possibly implement the interface `intDef&apos;.  Note that the only
                  way that this can fail is if `this&apos; and `intDef&apos; have methods
                  which are of the same signature and different return types.  This
                  method is used by Environment.explicitCast() to determine if a
                  cast between two interfaces is legal.
                  This method should only be called on a class after it has been
                  basicCheck()&apos;ed.                
            </javadoc>
            <method name="couldImplement" type="boolean" line="447">
                <params>
                    <param name="intDef" type="ClassDefinition"/>
                </params>
                <scope line="448"/>
                <scope line="451"/>
                <scope line="454"/>
                <declaration name="otherMethods" type="Iterator" line="457"/>
                <scope line="458">
                    <declaration name="method" type="MemberDefinition" line="459"/>
                    <declaration name="name" type="Identifier" line="460"/>
                    <declaration name="type" type="Type" line="461"/>
                    <declaration name="myMethod" type="MemberDefinition" line="462"/>
                    <scope line="463">
                        <scope line="464"/>
                    </scope>
                </scope>
            </method>
            <javadoc line="471">
                Check if another class can be accessed from the &apos;extends&apos; or &apos;implements&apos;
                  clause of this class.                
            </javadoc>
            <method name="extendsCanAccess" type="boolean" line="475">
                <params>
                    <param name="env" type="Environment"/>
                    <param name="c" type="ClassDeclaration"/>
                </params>
                <scope line="476"/>
                <declaration name="cdef" type="ClassDefinition" line="479"/>
                <scope line="480"/>
                <scope line="483">
                    <declaration name="f" type="MemberDefinition" line="484"/>
                    <scope line="485"/>
                    <scope line="488"/>
                </scope>
                <scope line="493"/>
            </method>
            <javadoc line="498">
                Check if another class can be accessed from within the body of this class.                
            </javadoc>
            <method name="canAccess" type="boolean" line="501">
                <params>
                    <param name="env" type="Environment"/>
                    <param name="c" type="ClassDeclaration"/>
                </params>
                <declaration name="cdef" type="ClassDefinition" line="502"/>
                <scope line="503"/>
                <scope line="506"/>
                <scope line="509"/>
            </method>
            <javadoc line="514">
                Check if a field can be accessed from a class                
            </javadoc>
            <method name="canAccess" type="boolean" line="517">
                <params>
                    <param name="env" type="Environment"/>
                    <param name="f" type="MemberDefinition"/>
                </params>
                <scope line="518"/>
                <scope line="521"/>
                <scope line="524"/>
            </method>
            <javadoc line="529">
                Check if a class is entitled to inline access to a class from
                  another class.                
            </javadoc>
            <method name="permitInlinedAccess" type="boolean" line="533">
                <params>
                    <param name="env" type="Environment"/>
                    <param name="c" type="ClassDeclaration"/>
                </params>
            </method>
            <javadoc line="536">
                Check if a class is entitled to inline access to a method from
                  another class.                
            </javadoc>
            <method name="permitInlinedAccess" type="boolean" line="540">
                <params>
                    <param name="env" type="Environment"/>
                    <param name="f" type="MemberDefinition"/>
                </params>
            </method>
            <javadoc line="543">
                We know the the field is marked protected (and not public) and that
                  the field is visible (as per canAccess).  Can we access the field as
                  &lt;accessor&gt;.&lt;field&gt;, where &lt;accessor&gt; has the type &lt;accessorType&gt;?
                  Protected fields can only be accessed when the accessorType is a
                  subclass of the current class                
            </javadoc>
            <method name="protectedAccess" type="boolean" line="550">
                <params>
                    <param name="env" type="Environment"/>
                    <param name="f" type="MemberDefinition"/>
                    <param name="accessorType" type="Type"/>
                </params>
            </method>
            <javadoc line="553">
                Find or create an access method for a private member,
                  or return null if this is not possible.                
            </javadoc>
            <method name="getAccessMember" type="MemberDefinition" line="557">
                <params>
                    <param name="env" type="Environment"/>
                    <param name="ctx" type="Context"/>
                    <param name="field" type="MemberDefinition"/>
                    <param name="isSuper" type="boolean"/>
                </params>
            </method>
            <javadoc line="560">
                Find or create an update method for a private member,
                  or return null if this is not possible.                
            </javadoc>
            <method name="getUpdateMember" type="MemberDefinition" line="564">
                <params>
                    <param name="env" type="Environment"/>
                    <param name="ctx" type="Context"/>
                    <param name="field" type="MemberDefinition"/>
                    <param name="isSuper" type="boolean"/>
                </params>
            </method>
            <javadoc line="567">
                Get a field from this class.  Report ambiguous fields.
                  If no accessible field is found, this method may return an
                  inaccessible field to allow a useful error message.
                  getVariable now takes the source class `source&apos; as an argument.
                  This allows getVariable to check whether a field is inaccessible
                  before it signals that a field is ambiguous.  The compiler used to
                  signal an ambiguity even when one of the fields involved was not
                  accessible.  (bug 4053724)                
            </javadoc>
            <method name="getVariable" type="MemberDefinition" line="577">
                <params>
                    <param name="env" type="Environment"/>
                    <param name="nm" type="Identifier"/>
                    <param name="source" type="ClassDefinition"/>
                </params>
            </method>
            <method name="getVariable0" type="MemberDefinition" line="580">
                <params>
                    <param name="env" type="Environment"/>
                    <param name="nm" type="Identifier"/>
                    <param name="source" type="ClassDefinition"/>
                    <param name="showPrivate" type="boolean"/>
                    <param name="showPackage" type="boolean"/>
                </params>
                <scope line="581">
                    <scope line="582">
                        <scope line="583"/>
                        <scope line="586"/>
                    </scope>
                </scope>
                <declaration name="sup" type="ClassDeclaration" line="591"/>
                <declaration name="field" type="MemberDefinition" line="592"/>
                <scope line="593"/>
                <scope line="596">
                    <declaration name="field2" type="MemberDefinition" line="597"/>
                    <scope line="598">
                        <scope line="599"/>
                    </scope>
                </scope>
            </method>
            <javadoc line="607">
                Tells whether to report a deprecation error for this class.                
            </javadoc>
            <method name="reportDeprecated" type="boolean" line="610">
                <params>
                    <param name="env" type="Environment"/>
                </params>
            </method>
            <javadoc line="613">
                Note that this class is being used somehow by &lt;tt&gt;ref&lt;/tt&gt;.
                  Report deprecation errors, etc.                
            </javadoc>
            <method name="noteUsedBy" type="void" line="617">
                <params>
                    <param name="ref" type="ClassDefinition"/>
                    <param name="where" type="long"/>
                    <param name="env" type="Environment"/>
                </params>
                <scope line="618"/>
            </method>
            <javadoc line="622">
                Get an inner class.
                  Look in supers but not outers.
                  (This is used directly to resolve expressions like &quot;site.K&quot;, and
                  inside a loop to resolve lone names like &quot;K&quot; or the &quot;K&quot; in &quot;K.L&quot;.)
                  Called from &apos;Context&apos; and &apos;FieldExpression&apos; as well as this class.                
                <see>
                    FieldExpression.checkCommon                    
                </see>
                <see>
                    resolveName                    
                </see>
            </javadoc>
            <method name="getInnerClass" type="MemberDefinition" line="631">
                <params>
                    <param name="env" type="Environment"/>
                    <param name="nm" type="Identifier"/>
                </params>
                <scope line="632">
                    <scope line="633">
                        <scope line="634"/>
                    </scope>
                </scope>
                <declaration name="sup" type="ClassDeclaration" line="640"/>
            </method>
            <javadoc line="644">
                Lookup a method.  This code implements the method lookup
                  mechanism specified in JLS 15.11.2.
                  This mechanism cannot be used to lookup synthetic methods.                
            </javadoc>
            <method name="matchMethod" type="MemberDefinition" line="649">
                <params>
                    <param name="env" type="Environment"/>
                    <param name="accessor" type="ClassDefinition"/>
                    <param name="methodName" type="Identifier"/>
                    <param name="argumentTypes" type="Type[]"/>
                    <param name="isAnonConstCall" type="boolean"/>
                    <param name="accessPackage" type="Identifier"/>
                </params>
                <scope line="650"/>
                <declaration name="tentative" type="MemberDefinition" line="653"/>
                <declaration name="candidateList" type="List" line="654"/>
                <declaration name="methods" type="Iterator" line="655"/>
                <scope line="656">
                    <declaration name="method" type="MemberDefinition" line="657"/>
                    <scope line="658"/>
                    <scope line="661">
                        <scope line="662"/>
                    </scope>
                    <scope line="666">
                        <scope line="667"/>
                    </scope>
                    <scope line="671"/>
                    <scope line="673"/>
                    <scope line="676">
                        <scope line="677"/>
                        <scope line="680">
                            <scope line="681">
                                <scope line="682"/>
                            </scope>
                        </scope>
                    </scope>
                </scope>
                <scope line="690">
                    <declaration name="candidates" type="Iterator" line="691"/>
                    <scope line="692">
                        <declaration name="method" type="MemberDefinition" line="693"/>
                        <scope line="694"/>
                    </scope>
                </scope>
            </method>
            <javadoc line="701">
                Lookup a method.  This code implements the method lookup
                  mechanism specified in JLS 15.11.2.
                  This mechanism cannot be used to lookup synthetic methods.                
            </javadoc>
            <method name="matchMethod" type="MemberDefinition" line="706">
                <params>
                    <param name="env" type="Environment"/>
                    <param name="accessor" type="ClassDefinition"/>
                    <param name="methodName" type="Identifier"/>
                    <param name="argumentTypes" type="Type[]"/>
                </params>
            </method>
            <javadoc line="709">
                Lookup a method.  This code implements the method lookup
                  mechanism specified in JLS 15.11.2.
                  This mechanism cannot be used to lookup synthetic methods.                
            </javadoc>
            <method name="matchMethod" type="MemberDefinition" line="714">
                <params>
                    <param name="env" type="Environment"/>
                    <param name="accessor" type="ClassDefinition"/>
                    <param name="methodName" type="Identifier"/>
                </params>
            </method>
            <javadoc line="717">
                A version of matchMethod to be used only for constructors
                  when we cannot pass in a sourceClass argument.  We just assert
                  our package name.
                  This is used only for anonymous classes, where we have to look up
                  a (potentially) protected constructor with no valid sourceClass
                  parameter available.                
            </javadoc>
            <method name="matchAnonConstructor" type="MemberDefinition" line="725">
                <params>
                    <param name="env" type="Environment"/>
                    <param name="accessPackage" type="Identifier"/>
                    <param name="argumentTypes" type="Type"/>
                </params>
            </method>
            <javadoc line="728">
                Find a method, ie: exact match in this class or any of the super
                  classes.
                  Only called by javadoc.  For now I am holding off rewriting this
                  code to rely on collectInheritedMethods(), as that code has
                  not gotten along with javadoc in the past.                
            </javadoc>
            <method name="findMethod" type="MemberDefinition" line="735">
                <params>
                    <param name="env" type="Environment"/>
                    <param name="nm" type="Identifier"/>
                    <param name="t" type="Type"/>
                </params>
                <declaration name="f" type="MemberDefinition" line="736"/>
                <scope line="737">
                    <scope line="738"/>
                </scope>
                <scope line="742"/>
                <declaration name="sup" type="ClassDeclaration" line="745"/>
            </method>
            <method name="basicCheck" type="void" line="749">
                <params>
                    <param name="env" type="Environment"/>
                </params>
            </method>
            <javadoc line="752">
                Check this class.                
            </javadoc>
            <method name="check" type="void" line="755">
                <params>
                    <param name="env" type="Environment"/>
                </params>
            </method>
            <method name="checkLocalClass" type="Vset" line="757">
                <params>
                    <param name="env" type="Environment"/>
                    <param name="ctx" type="Context"/>
                    <param name="vset" type="Vset"/>
                    <param name="sup" type="ClassDefinition"/>
                    <param name="args" type="Expression"/>
                    <param name="argTypes" type="Type"/>
                </params>
            </method>
            <declaration name="allMethods" type="MethodSet" line="760"/>
            <declaration name="permanentlyAbstractMethods" type="List" line="761"/>
            <javadoc line="762">
                This method returns an Iterator of all abstract methods
                  in our superclasses which we are unable to implement.                
            </javadoc>
            <method name="getPermanentlyAbstractMethods" type="Iterator" line="766">
                <scope line="767"/>
            </method>
            <declaration name="doInheritanceChecks" type="boolean" line="772"/>
            <javadoc line="772">
                A flag used by turnOffInheritanceChecks() to indicate if
                  inheritance checks are on or off.                
            </javadoc>
            <javadoc line="777">
                This is a workaround to allow javadoc to turn off certain
                  inheritance/override checks which interfere with javadoc
                  badly.  In the future it might be good to eliminate the
                  shared sources of javadoc and javac to avoid the need for this
                  sort of workaround.                
            </javadoc>
            <method name="turnOffInheritanceChecks" type="void" line="784"/>
            <javadoc line="787">
                Add all of the methods declared in or above `parent&apos; to
                  `allMethods&apos;, the set of methods in the current class.
                  `myMethods&apos; is the set of all methods declared in this
                  class, and `mirandaMethods&apos; is a repository for Miranda methods.
                  If mirandaMethods is null, no mirandaMethods will be
                  generated.
                  For a definition of Miranda methods, see the comment above the
                  method addMirandaMethods() which occurs later in this file.                
            </javadoc>
            <method name="collectOneClass" type="void" line="797">
                <params>
                    <param name="env" type="Environment"/>
                    <param name="parent" type="ClassDeclaration"/>
                    <param name="myMethods" type="MethodSet"/>
                    <param name="allMethods" type="MethodSet"/>
                    <param name="mirandaMethods" type="MethodSet"/>
                </params>
                <scope line="798">
                    <declaration name="pClass" type="ClassDefinition" line="799"/>
                    <declaration name="methods" type="Iterator" line="800"/>
                    <scope line="801">
                        <declaration name="method" type="MemberDefinition" line="802"/>
                        <scope line="803"/>
                        <declaration name="name" type="Identifier" line="806"/>
                        <declaration name="type" type="Type" line="807"/>
                        <declaration name="override" type="MemberDefinition" line="808"/>
                        <scope line="809">
                            <scope line="810"/>
                            <scope line="813"/>
                        </scope>
                        <scope line="818"/>
                        <scope line="821">
                            <declaration name="formerMethod" type="MemberDefinition" line="822"/>
                            <scope line="823">
                                <scope line="824"/>
                            </scope>
                            <scope line="830"/>
                            <scope line="833">
                                <scope line="834"/>
                                <scope line="837"/>
                                <scope line="840">
                                    <scope line="841"/>
                                </scope>
                            </scope>
                        </scope>
                    </scope>
                </scope>
                <scope line="853"/>
            </method>
            <javadoc line="857">
                &lt;p&gt;Collect all methods defined in this class or inherited from
                  any of our superclasses or interfaces.  Look for any
                  incompatible definitions.
                  &lt;p&gt;This function is also responsible for collecting the
                  &lt;em&gt;Miranda&lt;/em&gt; methods for a class.  For a definition of
                  Miranda methods, see the comment in addMirandaMethods()
                  below.                
            </javadoc>
            <method name="collectInheritedMethods" type="void" line="866">
                <params>
                    <param name="env" type="Environment"/>
                </params>
                <declaration name="myMethods" type="MethodSet" line="867"/>
                <declaration name="mirandaMethods" type="MethodSet" line="868"/>
                <scope line="869">
                    <scope line="870"/>
                    <scope line="873"/>
                </scope>
                <scope line="879"/>
                <scope line="882"/>
                <scope line="885">
                    <scope line="886"/>
                </scope>
                <declaration name="scDecl" type="ClassDeclaration" line="891"/>
                <scope line="892">
                    <declaration name="sc" type="ClassDefinition" line="894"/>
                    <declaration name="supIter" type="Iterator" line="895"/>
                    <scope line="896"/>
                </scope>
                <scope line="900"/>
                <scope line="904"/>
            </method>
            <method name="methodSetAdd" type="void" line="908">
                <params>
                    <param name="env" type="Environment"/>
                    <param name="methodSet" type="MethodSet"/>
                    <param name="newMethod" type="MemberDefinition"/>
                </params>
                <declaration name="oldMethod" type="MemberDefinition" line="909"/>
                <scope line="910">
                    <declaration name="oldReturnType" type="Type" line="911"/>
                    <declaration name="newReturnType" type="Type" line="912"/>
                    <scope line="913">
                        <scope line="914"/>
                    </scope>
                    <scope line="918"/>
                </scope>
                <scope line="921"/>
            </method>
            <javadoc line="925">
                Get an Iterator of all methods which could be accessed in an
                  instance of this class.                
            </javadoc>
            <method name="getMethods" type="Iterator" line="929">
                <params>
                    <param name="env" type="Environment"/>
                </params>
                <scope line="930"/>
            </method>
            <javadoc line="935">
                Get an Iterator of all methods which could be accessed in an
                  instance of this class.  Throw a compiler error if we haven&apos;t
                  generated this information yet.                
            </javadoc>
            <method name="getMethods" type="Iterator" line="940">
                <scope line="941"/>
            </method>
            <javadoc line="946">
                Add a list of methods to this class as miranda methods.  This
                  gets overridden with a meaningful implementation in SourceClass.
                  BinaryClass should not need to do anything -- it should already
                  have its miranda methods and, if it doesn&apos;t, then that doesn&apos;t
                  affect our compilation.                
            </javadoc>
            <method name="addMirandaMethods" type="void" line="953">
                <params>
                    <param name="env" type="Environment"/>
                    <param name="mirandas" type="Iterator"/>
                </params>
            </method>
            <method name="inlineLocalClass" type="void" line="955">
                <params>
                    <param name="env" type="Environment"/>
                </params>
            </method>
            <javadoc line="957">
                We create a stub for this.  Source classes do more work.
                  Some calls from &apos;SourceClass.checkSupers&apos; execute this method.                
                <see>
                    sun.tools.javac.SourceClass#resolveTypeStructure                    
                </see>
            </javadoc>
            <method name="resolveTypeStructure" type="void" line="962">
                <params>
                    <param name="env" type="Environment"/>
                </params>
            </method>
            <javadoc line="964">
                Look up an inner class name, from somewhere inside this class.
                  Since supers and outers are in scope, search them too.
                  &lt;p&gt;
                  If no inner class is found, env.resolveName() is then called,
                  to interpret the ambient package and import directives.
                  &lt;p&gt;
                  This routine operates on a &quot;best-efforts&quot; basis.  If
                  at some point a class is not found, the partially-resolved
                  identifier is returned.  Eventually, someone else has to
                  try to get the ClassDefinition and diagnose the ClassNotFound.
                  &lt;p&gt;
                  resolveName() looks at surrounding scopes, and hence
                  pulling in both inherited and uplevel types.  By contrast,
                  resolveInnerClass() is intended only for interpreting
                  explicitly qualified names, and so look only at inherited
                  types.  Also, resolveName() looks for package prefixes,
                  which appear similar to &quot;very uplevel&quot; outer classes.
                  &lt;p&gt;
                  A similar (but more complex) name-lookup process happens
                  when field and identifier expressions denoting qualified names
                  are type-checked.  The added complexity comes from the fact
                  that variables may occur in such names, and take precedence
                  over class and package names.
                  &lt;p&gt;
                  In the expression type-checker, resolveInnerClass() is paralleled
                  by code in FieldExpression.checkAmbigName(), which also calls
                  ClassDefinition.getInnerClass() to interpret names of the form
                  &quot;OuterClass.Inner&quot; (and also outerObject.Inner).  The checking
                  of an identifier expression that fails to be a variable is referred
                  directly to resolveName().                
            </javadoc>
            <method name="resolveName" type="Identifier" line="996">
                <params>
                    <param name="env" type="Environment"/>
                    <param name="name" type="Identifier"/>
                </params>
                <scope line="998">
                    <declaration name="rhead" type="Identifier" line="999"/>
                    <scope line="1000"/>
                    <scope line="1003"/>
                    <scope line="1006"/>
                    <scope line="1009"/>
                </scope>
                <declaration name="ls" type="int" line="1013"/>
                <declaration name="lf" type="LocalMember" line="1014"/>
                <scope line="1015">
                    <scope line="1017"/>
                </scope>
                <scope line="1021">
                    <scope line="1022">
                        <declaration name="f" type="MemberDefinition" line="1023"/>
                        <scope line="1024"/>
                    </scope>
                    <scope line="1028"/>
                </scope>
                <scope line="1031"/>
            </method>
            <javadoc line="1036">
                Interpret a qualified class name, which may have further subcomponents..
                  Follow inheritance links, as in:
                  class C { class N { } }  class D extends C { }  ... new D.N() ...
                  Ignore outer scopes and packages.                
                <see>
                    resolveName                    
                </see>
            </javadoc>
            <method name="resolveInnerClass" type="Identifier" line="1043">
                <params>
                    <param name="env" type="Environment"/>
                    <param name="nm" type="Identifier"/>
                </params>
                <scope line="1045">
                    <declaration name="rhead" type="Identifier" line="1046"/>
                    <scope line="1047"/>
                    <scope line="1050"/>
                </scope>
                <scope line="1054">
                    <scope line="1055">
                        <declaration name="f" type="MemberDefinition" line="1056"/>
                        <scope line="1057"/>
                    </scope>
                    <scope line="1061"/>
                </scope>
            </method>
            <javadoc line="1066">
                While resolving import directives, the question has arisen:
                  does a given inner class exist?  If the top-level class exists,
                  we ask it about an inner class via this method.
                  This method looks only at the literal name of the class,
                  and does not attempt to follow inheritance links.
                  This is necessary, since at the time imports are being
                  processed, inheritance links have not been resolved yet.
                  (Thus, an import directive must always spell a class
                  name exactly.)                
            </javadoc>
            <method name="innerClassExists" type="boolean" line="1077">
                <params>
                    <param name="nm" type="Identifier"/>
                </params>
                <scope line="1078">
                    <scope line="1079">
                        <scope line="1080"/>
                    </scope>
                </scope>
            </method>
            <javadoc line="1088">
                Find any method with a given name.                
            </javadoc>
            <method name="findAnyMethod" type="MemberDefinition" line="1091">
                <params>
                    <param name="env" type="Environment"/>
                    <param name="nm" type="Identifier"/>
                </params>
                <declaration name="f" type="MemberDefinition" line="1092"/>
                <scope line="1093">
                    <scope line="1094"/>
                </scope>
                <declaration name="sup" type="ClassDeclaration" line="1098"/>
            </method>
            <javadoc line="1102">
                Given the fact that this class has no method &quot;nm&quot; matching &quot;argTypes&quot;,
                  find out if the mismatch can be blamed on a particular actual argument
                  which disagrees with all of the overloadings.
                  If so, return the code (i&lt;&lt;2)+(castOK&lt;&lt;1)+ambig, where
                  &quot;i&quot; is the number of the offending argument, and
                  &quot;castOK&quot; is 1 if a cast could fix the problem.
                  The target type for the argument is returned in margTypeResult[0].
                  If not all methods agree on this type, &quot;ambig&quot; is 1.
                  If there is more than one method, the choice of target type is
                  arbitrary.&lt;p&gt;
                  Return -1 if every argument is acceptable to at least one method.
                  Return -2 if there are no methods of the required arity.
                  The value &quot;start&quot; gives the index of the first argument to begin
                  checking.                
            </javadoc>
            <method name="diagnoseMismatch" type="int" line="1118">
                <params>
                    <param name="env" type="Environment"/>
                    <param name="nm" type="Identifier"/>
                    <param name="argTypes" type="Type"/>
                    <param name="start" type="int"/>
                    <param name="margTypeResult" type="Type"/>
                </params>
                <declaration name="haveMatch" type="int" line="1119"/>
                <declaration name="margType" type="Type" line="1120"/>
                <scope line="1122">
                    <scope line="1123"/>
                </scope>
            </method>
            <method name="diagnoseMismatch" type="boolean" line="1130">
                <params>
                    <param name="env" type="Environment"/>
                    <param name="nm" type="Identifier"/>
                    <param name="argTypes" type="Type"/>
                    <param name="start" type="int"/>
                    <param name="haveMatch" type="int"/>
                    <param name="margType" type="Type"/>
                </params>
                <declaration name="haveOne" type="boolean" line="1131"/>
                <declaration name="f" type="MemberDefinition" line="1132"/>
                <scope line="1133">
                    <scope line="1134"/>
                    <declaration name="fArgTypes" type="Type" line="1137"/>
                    <scope line="1138">
                        <scope line="1140">
                            <declaration name="at" type="Type" line="1141"/>
                            <declaration name="ft" type="Type" line="1142"/>
                            <scope line="1143"/>
                            <scope line="1147"/>
                            <scope line="1151"/>
                        </scope>
                    </scope>
                </scope>
                <scope line="1159"/>
                <declaration name="sup" type="ClassDeclaration" line="1162"/>
                <scope line="1163"/>
            </method>
            <javadoc line="1168">
                Add a field (no checks)                
            </javadoc>
            <method name="addMember" type="void" line="1171">
                <params>
                    <param name="field" type="MemberDefinition"/>
                </params>
                <scope line="1172"/>
                <scope line="1175"/>
                <scope line="1180"/>
            </method>
            <javadoc line="1187">
                Add a field (subclasses make checks)                
            </javadoc>
            <method name="addMember" type="void" line="1190">
                <params>
                    <param name="env" type="Environment"/>
                    <param name="field" type="MemberDefinition"/>
                </params>
                <scope line="1192"/>
            </method>
            <javadoc line="1196">
                Find or create an uplevel reference for the given target.                
            </javadoc>
            <method name="getReference" type="UplevelReference" line="1199">
                <params>
                    <param name="target" type="LocalMember"/>
                </params>
                <scope line="1200">
                    <scope line="1201"/>
                </scope>
            </method>
            <method name="addReference" type="UplevelReference" line="1207">
                <params>
                    <param name="target" type="LocalMember"/>
                </params>
                <scope line="1208"/>
                <declaration name="r" type="UplevelReference" line="1212"/>
            </method>
            <javadoc line="1216">
                Return the list of all uplevel references.                
            </javadoc>
            <method name="getReferences" type="UplevelReference" line="1219"/>
            <javadoc line="1222">
                Return the same value as getReferences.
                  Also, mark the set of references frozen.
                  After that, it is an error to add new references.                
            </javadoc>
            <method name="getReferencesFrozen" type="UplevelReference" line="1227"/>
            <javadoc line="1231">
                assertion check                
            </javadoc>
            <method name="referencesMustNotBeFrozen" type="void" line="1234">
                <scope line="1235"/>
            </method>
            <javadoc line="1239">
                Get helper method for class literal lookup.                
            </javadoc>
            <method name="getClassLiteralLookup" type="MemberDefinition" line="1242">
                <params>
                    <param name="fwhere" type="long"/>
                </params>
            </method>
            <javadoc line="1245">
                Add a dependency                
            </javadoc>
            <method name="addDependency" type="void" line="1248">
                <params>
                    <param name="c" type="ClassDeclaration"/>
                </params>
            </method>
            <javadoc line="1251">
                Maintain a hash table of local and anonymous classes
                  whose internal names are prefixed by the current class.
                  The key is the simple internal name, less the prefix.                
            </javadoc>
            <method name="getLocalClass" type="ClassDefinition" line="1256">
                <params>
                    <param name="name" type="String"/>
                </params>
                <scope line="1257"/>
                <scope line="1260"/>
            </method>
            <method name="addLocalClass" type="void" line="1264">
                <params>
                    <param name="c" type="ClassDefinition"/>
                    <param name="name" type="String"/>
                </params>
                <scope line="1265"/>
            </method>
            <javadoc line="1270">
                Print for debugging                
            </javadoc>
            <method name="print" type="void" line="1273">
                <params>
                    <param name="out" type="PrintStream"/>
                </params>
                <scope line="1274"/>
                <scope line="1277"/>
                <scope line="1280"/>
                <scope line="1284"/>
                <scope line="1287">
                    <scope line="1289">
                        <scope line="1290"/>
                    </scope>
                </scope>
                <scope line="1298"/>
            </method>
            <javadoc line="1304">
                Convert to String                
            </javadoc>
            <method name="toString" type="String" line="1307"/>
            <javadoc line="1310">
                After the class has been written to disk, try to free up
                  some storage.                
            </javadoc>
            <method name="cleanup" type="void" line="1314">
                <params>
                    <param name="env" type="Environment"/>
                </params>
                <scope line="1315"/>
                <scope line="1318"/>
            </method>
        </class>
    </source>