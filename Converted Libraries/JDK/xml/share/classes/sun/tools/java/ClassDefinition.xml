<?xml version="1.0" encoding="UTF-8"?>
    <source package="sun.tools.java">
        <import package="java.util"/>
        <import package="java.io.OutputStream"/>
        <import package="java.io.PrintStream"/>
        <import package="sun.tools.tree.Context"/>
        <import package="sun.tools.tree.Vset"/>
        <import package="sun.tools.tree.Expression"/>
        <import package="sun.tools.tree.LocalMember"/>
        <import package="sun.tools.tree.UplevelReference"/>
        <class name="ClassDefinition" line="37">
            <comment line="51">
                for local classes                
            </comment>
            <comment line="59">
                field for me in outerClass                
            </comment>
            <comment line="71">
                Table of local and anonymous classes whose internal names are constructed                
            </comment>
            <comment line="72">
                using the current class as a prefix.  This is part of a fix for                
            </comment>
            <comment line="73">
                bugid 4054523 and 4030421.  See also &apos;Environment.getClassDefinition&apos;                
            </comment>
            <comment line="74">
                and &apos;BatchEnvironment.makeClassDefinition&apos;.  Allocated on demand.                
            </comment>
            <comment line="78">
                The immediately surrounding context in which the class appears.                
            </comment>
            <comment line="79">
                Set at the beginning of checking, upon entry to &apos;SourceClass.checkInternal&apos;.                
            </comment>
            <comment line="80">
                Null for classes that are not local or inside a local class.                
            </comment>
            <comment line="81">
                At present, this field exists only for the benefit of &apos;resolveName&apos; as part                
            </comment>
            <comment line="82">
                of the fix for 4095716.                
            </comment>
            <comment line="85">
                The saved class context is now also used in &apos;SourceClass.getAccessMember&apos;.                
            </comment>
            <comment line="86">
                Provide read-only access via this method.  Part of fix for 4098093.                
            </comment>
            <comment line="185">
                *** DEBUG ***                
            </comment>
            <comment line="840">
                private fields are never inherited.  package-private fields are
                 not inherited across package boundaries.  To capture this, we
                 take two booleans as parameters: showPrivate indicates whether
                 we have passed a class boundary, and showPackage indicates whether
                 we have crossed a package boundary.                
            </comment>
            <comment line="1154">
                We create a stub for this.  Source classes do more work.                
            </comment>
            <comment line="1174">
                ---------------------------------------------------------------                
            </comment>
            <comment line="1175">
                The non-synthetic methods defined in this class or in any                
            </comment>
            <comment line="1176">
                of its parents (class or interface).  This member is used                
            </comment>
            <comment line="1177">
                to cache work done in collectInheritedMethods for use by                
            </comment>
            <comment line="1178">
                getMethods() and matchMethod().  It should be accessed by                
            </comment>
            <comment line="1179">
                no other method without forethought.                
            </comment>
            <comment line="1182">
                One of our superclasses may contain an abstract method which                
            </comment>
            <comment line="1183">
                we are unable to ever implement.  This happens when there is                
            </comment>
            <comment line="1184">
                a package-private abstract method in our parent and we are in                
            </comment>
            <comment line="1185">
                a different package than our parent.  In these cases, we                
            </comment>
            <comment line="1186">
                keep a list of the &quot;permanently abstract&quot; or &quot;unimplementable&quot;                
            </comment>
            <comment line="1187">
                methods so that we can correctly detect that this class is                
            </comment>
            <comment line="1188">
                indeed abstract and so that we can give somewhat comprehensible                
            </comment>
            <comment line="1189">
                error messages.                
            </comment>
            <comment line="1553">
                //////////////////////////////////////////////////////////                
            </comment>
            <comment line="1554">
                PCJ 2003-07-30 added this utility method to insulate                
            </comment>
            <comment line="1555">
                MethodSet additions from the covariant return type                
            </comment>
            <comment line="1556">
                feature of the 1.5 compiler.  When there are multiple                
            </comment>
            <comment line="1557">
                methods with the same signature and different return                
            </comment>
            <comment line="1558">
                types to be added, we try to ensure that the one with                
            </comment>
            <comment line="1559">
                the most specific return type winds up in the MethodSet.                
            </comment>
            <comment line="1560">
                This logic was not put into MethodSet itself because it                
            </comment>
            <comment line="1561">
                requires access to an Environment for type relationship                
            </comment>
            <comment line="1562">
                checking.  No error checking is performed here, but that                
            </comment>
            <comment line="1563">
                should be OK because this code is only still used by                
            </comment>
            <comment line="1564">
                rmic.  See 4892308.                
            </comment>
            <comment line="1565">
                //////////////////////////////////////////////////////////                
            </comment>
            <comment line="1585">
                //////////////////////////////////////////////////////////                
            </comment>
            <comment line="1610">
                In early VM&apos;s there was a bug -- the VM didn&apos;t walk the interfaces                
            </comment>
            <comment line="1611">
                of a class looking for a method, they only walked the superclass                
            </comment>
            <comment line="1612">
                chain.  This meant that abstract methods defined only in interfaces                
            </comment>
            <comment line="1613">
                were not being found.  To fix this bug, a counter-bug was introduced                
            </comment>
            <comment line="1614">
                in the compiler -- the so-called Miranda methods.  If a class                
            </comment>
            <comment line="1615">
                does not provide a definition for an abstract method in one of                
            </comment>
            <comment line="1616">
                its interfaces then the compiler inserts one in the class artificially.                
            </comment>
            <comment line="1617">
                That way the VM didn&apos;t have to bother looking at the interfaces.                
            </comment>
            <comment line="1618">
                                
            </comment>
            <comment line="1619">
                This is a problem.  Miranda methods are not part of the specification.                
            </comment>
            <comment line="1620">
                But they continue to be inserted so that old VM&apos;s can run new code.                
            </comment>
            <comment line="1621">
                Someday, when the old VM&apos;s are gone, perhaps classes can be compiled                
            </comment>
            <comment line="1622">
                without Miranda methods.  Towards this end, the compiler has a                
            </comment>
            <comment line="1623">
                flag, -nomiranda, which can turn off the creation of these methods.                
            </comment>
            <comment line="1624">
                Eventually that behavior should become the default.                
            </comment>
            <comment line="1625">
                                
            </comment>
            <comment line="1626">
                Why are they called Miranda methods?  Well the sentence &quot;If the                
            </comment>
            <comment line="1627">
                class is not able to provide a method, then one will be provided                
            </comment>
            <comment line="1628">
                by the compiler&quot; is very similar to the sentence &quot;If you cannot                
            </comment>
            <comment line="1629">
                afford an attorney, one will be provided by the court,&quot; -- one                
            </comment>
            <comment line="1630">
                of the so-called &quot;Miranda&quot; rights in the United States.                
            </comment>
            <comment line="1644">
                ---------------------------------------------------------------                
            </comment>
            <implements interface="Constants"/>
            <javadoc line="37">
                This class is a Java class definition
                  WARNING: The contents of this source file are not part of any
                  supported API.  Code that depends on them does so at its own risk:
                  they are subject to change or removal without notice.                
            </javadoc>
            <declaration name="source" type="Object" line="47"/>
            <declaration name="where" type="long" line="48"/>
            <declaration name="modifiers" type="int" line="49"/>
            <declaration name="localName" type="Identifier" line="50"/>
            <declaration name="declaration" type="ClassDeclaration" line="51"/>
            <declaration name="superClassId" type="IdentifierToken" line="52"/>
            <declaration name="interfaceIds" type="IdentifierToken" line="53"/>
            <declaration name="superClass" type="ClassDeclaration" line="54"/>
            <declaration name="interfaces" type="ClassDeclaration" line="55"/>
            <declaration name="outerClass" type="ClassDefinition" line="56"/>
            <declaration name="outerMember" type="MemberDefinition" line="57"/>
            <declaration name="innerClassMember" type="MemberDefinition" line="58"/>
            <declaration name="firstMember" type="MemberDefinition" line="59"/>
            <declaration name="lastMember" type="MemberDefinition" line="60"/>
            <declaration name="resolved" type="boolean" line="61"/>
            <declaration name="documentation" type="String" line="62"/>
            <declaration name="error" type="boolean" line="63"/>
            <declaration name="nestError" type="boolean" line="64"/>
            <declaration name="references" type="UplevelReference" line="65"/>
            <declaration name="referencesFrozen" type="boolean" line="66"/>
            <declaration name="fieldHash" type="Hashtable" line="67"/>
            <declaration name="abstr" type="int" line="68"/>
            <declaration name="localClasses" type="Hashtable" line="74"/>
            <declaration name="LOCAL_CLASSES_SIZE" type="int" line="75"/>
            <declaration name="classContext" type="Context" line="82"/>
            <method name="getClassContext" type="Context" line="86"/>
            <javadoc line="91">
                Constructor                
            </javadoc>
            <method name="ClassDefinition" type="constructor" line="95">
                <params>
                    <param name="source" type="Object"/>
                    <param name="where" type="long"/>
                    <param name="declaration" type="ClassDeclaration"/>
                    <param name="modifiers" type="int"/>
                    <param name="superClass" type="IdentifierToken"/>
                    <param name="interfaces" type="IdentifierToken"/>
                </params>
            </method>
            <javadoc line="104">
                Get the source of the class                
            </javadoc>
            <method name="getSource" type="Object" line="107"/>
            <javadoc line="111">
                Check if there were any errors in this class.                
            </javadoc>
            <method name="getError" type="boolean" line="114"/>
            <javadoc line="118">
                Mark this class to be erroneous.                
            </javadoc>
            <method name="setError" type="void" line="121"/>
            <javadoc line="126">
                Check if there were any errors in our class nest.                
            </javadoc>
            <method name="getNestError" type="boolean" line="129">
                <comment line="130">
                    Check to see if our error value is set, or if any of our                    
                </comment>
                <comment line="131">
                    outer classes&apos; error values are set.  This will work in                    
                </comment>
                <comment line="132">
                    conjunction with setError(), which sets the error value                    
                </comment>
                <comment line="133">
                    of its outer class, to yield true is any of our nest                    
                </comment>
                <comment line="134">
                    siblings has an error.  This addresses bug 4111488: either                    
                </comment>
                <comment line="135">
                    code should be generated for all classes in a nest, or                    
                </comment>
                <comment line="136">
                    none of them.                    
                </comment>
            </method>
            <javadoc line="140">
                Mark this class, and all siblings in its class nest, to be
                  erroneous.                
            </javadoc>
            <method name="setNestError" type="void" line="144">
                <comment line="147">
                    If we have an outer class, set it to be erroneous as well.                    
                </comment>
                <comment line="148">
                    This will work in conjunction with getError(), which checks                    
                </comment>
                <comment line="149">
                    the error value of its outer class, to set the whole class                    
                </comment>
                <comment line="150">
                    nest to be erroneous.  This address bug 4111488: either                    
                </comment>
                <comment line="151">
                    code should be generated for all classes in a nest, or                    
                </comment>
                <comment line="152">
                    none of them.                    
                </comment>
                <scope line="146"/>
            </method>
            <javadoc line="157">
                Get the position in the input                
            </javadoc>
            <method name="getWhere" type="long" line="160"/>
            <javadoc line="164">
                Get the class declaration                
            </javadoc>
            <method name="getClassDeclaration" type="ClassDeclaration" line="167"/>
            <javadoc line="171">
                Get the class&apos; modifiers                
            </javadoc>
            <method name="getModifiers" type="int" line="174"/>
            <method name="subModifiers" type="void" line="177">
                <params>
                    <param name="mod" type="int"/>
                </params>
            </method>
            <method name="addModifiers" type="void" line="180">
                <params>
                    <param name="mod" type="int"/>
                </params>
            </method>
            <declaration name="supersCheckStarted" type="boolean" line="185"/>
            <javadoc line="187">
                Get the class&apos; super class                
            </javadoc>
            <method name="getSuperClass" type="ClassDeclaration" line="190">
                <comment line="191">
                    ---
                    if (superClass == null &amp;&amp; superClassId != null)
                    throw new CompilerError(&quot;getSuperClass &quot;+superClassId);
                     There are obscure cases where null is the right answer,
                     in order to enable some error reporting later on.
                     For example:  class T extends T.N { class N { } }                    
                </comment>
                <comment line="199">
                    *** DEBUG ***                    
                </comment>
                <comment line="200">
                    This method should not be called if the superclass has not been resolved.                    
                </comment>
            </method>
            <javadoc line="206">
                Get the super class, and resolve names now if necessary.
                  It is only possible to resolve names at this point if we are
                  a source class.  The provision of this method at this level
                  in the class hierarchy is dubious, but see &apos;getInnerClass&apos; below.
                  All other calls to &apos;getSuperClass(env)&apos; appear in &apos;SourceClass&apos;.
                  NOTE: An older definition of this method has been moved to
                  &apos;SourceClass&apos;, where it overrides this one.                
                <see>
                    #resolveTypeStructure                    
                </see>
            </javadoc>
            <method name="getSuperClass" type="ClassDeclaration" line="219">
                <params>
                    <param name="env" type="Environment"/>
                </params>
            </method>
            <javadoc line="223">
                Get the class&apos; interfaces                
            </javadoc>
            <method name="getInterfaces" type="ClassDeclaration" line="226"/>
            <javadoc line="231">
                Get the class&apos; enclosing class (or null if not inner)                
            </javadoc>
            <method name="getOuterClass" type="ClassDefinition" line="234"/>
            <javadoc line="238">
                Set the class&apos; enclosing class.  Must be done at most once.                
            </javadoc>
            <method name="setOuterClass" type="void" line="241">
                <params>
                    <param name="outerClass" type="ClassDefinition"/>
                </params>
            </method>
            <javadoc line="246">
                Set the class&apos; enclosing current instance pointer.
                  Must be done at most once.                
            </javadoc>
            <method name="setOuterMember" type="void" line="250">
                <params>
                    <param name="outerMember" type="MemberDefinition"/>
                </params>
            </method>
            <javadoc line="257">
                Tell if the class is inner.
                  This predicate also returns true for top-level nested types.
                  To test for a true inner class as seen by the programmer,
                  use &lt;tt&gt;!isTopLevel()&lt;/tt&gt;.                
            </javadoc>
            <method name="isInnerClass" type="boolean" line="263"/>
            <javadoc line="267">
                Tell if the class is a member of another class.
                  This is false for package members and for block-local classes.                
            </javadoc>
            <method name="isMember" type="boolean" line="271"/>
            <javadoc line="275">
                Tell if the class is &quot;top-level&quot;, which is either a package member,
                  or a static member of another top-level class.                
            </javadoc>
            <method name="isTopLevel" type="boolean" line="279"/>
            <javadoc line="283">
                Tell if the class is local or inside a local class,
                  which means it cannot be mentioned outside of its file.                
            </javadoc>
            <method name="isInsideLocal" type="boolean" line="292">
                <comment line="288">
                    The comment above is true only because M_LOCAL is set                    
                </comment>
                <comment line="289">
                    whenever M_ANONYMOUS is.  I think it is risky to assume that                    
                </comment>
                <comment line="290">
                    isAnonymous(x) =&gt; isLocal(x).                    
                </comment>
            </method>
            <javadoc line="297">
                Tell if the class is local or or anonymous class, or inside
                  such a class, which means it cannot be mentioned outside of
                  its file.                
            </javadoc>
            <method name="isInsideLocalOrAnonymous" type="boolean" line="302"/>
            <javadoc line="307">
                Return a simple identifier for this class (idNull if anonymous).                
            </javadoc>
            <method name="getLocalName" type="Identifier" line="310">
                <comment line="314">
                    This is also the name of the innerClassMember, if any:                    
                </comment>
                <scope line="311"/>
            </method>
            <javadoc line="318">
                Set the local name of a class.  Must be a local class.                
            </javadoc>
            <method name="setLocalName" type="void" line="321">
                <params>
                    <param name="name" type="Identifier"/>
                </params>
                <scope line="322"/>
            </method>
            <javadoc line="327">
                If inner, get the field for this class in the enclosing class                
            </javadoc>
            <method name="getInnerClassMember" type="MemberDefinition" line="330">
                <comment line="334">
                    We must find the field in the outer class.                    
                </comment>
                <scope line="333">
                    <declaration name="nm" type="Identifier" line="335"/>
                    <scope line="337">
                        <scope line="338"/>
                    </scope>
                </scope>
            </method>
            <javadoc line="349">
                If inner, return an innermost uplevel self pointer, if any exists.
                  Otherwise, return null.                
            </javadoc>
            <method name="findOuterMember" type="MemberDefinition" line="353"/>
            <javadoc line="357">
                See if this is a (nested) static class.                
            </javadoc>
            <method name="isStatic" type="boolean" line="360"/>
            <javadoc line="364">
                Get the class&apos; top-level enclosing class                
            </javadoc>
            <method name="getTopClass" type="ClassDefinition" line="367">
                <declaration name="p" type="ClassDefinition" line="368"/>
            </method>
            <javadoc line="374">
                Get the class&apos; first field or first match                
            </javadoc>
            <method name="getFirstMember" type="MemberDefinition" line="377"/>
            <method name="getFirstMatch" type="MemberDefinition" line="380">
                <params>
                    <param name="name" type="Identifier"/>
                </params>
            </method>
            <javadoc line="384">
                Get the class&apos; name                
            </javadoc>
            <method name="getName" type="Identifier" line="387"/>
            <javadoc line="391">
                Get the class&apos; type                
            </javadoc>
            <method name="getType" type="Type" line="394"/>
            <javadoc line="398">
                Get the class&apos; documentation                
            </javadoc>
            <method name="getDocumentation" type="String" line="401"/>
            <javadoc line="405">
                Return true if the given documentation string contains a deprecation
                  paragraph.  This is true if the string contains the tag @deprecated
                  is the first word in a line.                
            </javadoc>
            <method name="containsDeprecated" type="boolean" line="410">
                <params>
                    <param name="documentation" type="String"/>
                </params>
                <comment line="418">
                    make sure there is only whitespace between this word                    
                </comment>
                <comment line="419">
                    and the beginning of the line                    
                </comment>
                <comment line="423">
                    OK                    
                </comment>
                <comment line="429">
                    make sure the char after the word is space or end of line                    
                </comment>
                <scope line="411"/>
                <scope line="417">
                    <scope line="420">
                        <declaration name="ch" type="char" line="421"/>
                        <scope line="422"/>
                        <scope line="425"/>
                    </scope>
                    <declaration name="end" type="int" line="430"/>
                    <scope line="431">
                        <declaration name="ch" type="char" line="432"/>
                        <scope line="433"/>
                    </scope>
                </scope>
            </method>
            <method name="inSamePackage" type="boolean" line="442">
                <params>
                    <param name="c" type="ClassDeclaration"/>
                </params>
                <comment line="443">
                    find out if the class stored in c is defined in the same                    
                </comment>
                <comment line="444">
                    package as the current class.                    
                </comment>
            </method>
            <method name="inSamePackage" type="boolean" line="448">
                <params>
                    <param name="c" type="ClassDefinition"/>
                </params>
                <comment line="449">
                    find out if the class stored in c is defined in the same                    
                </comment>
                <comment line="450">
                    package as the current class.                    
                </comment>
            </method>
            <method name="inSamePackage" type="boolean" line="454">
                <params>
                    <param name="packageName" type="Identifier"/>
                </params>
            </method>
            <javadoc line="458">
                Checks                
            </javadoc>
            <method name="isInterface" type="boolean" line="461"/>
            <method name="isClass" type="boolean" line="464"/>
            <method name="isPublic" type="boolean" line="467"/>
            <method name="isPrivate" type="boolean" line="470"/>
            <method name="isProtected" type="boolean" line="473"/>
            <method name="isPackagePrivate" type="boolean" line="476"/>
            <method name="isFinal" type="boolean" line="479"/>
            <method name="isAbstract" type="boolean" line="482"/>
            <method name="isSynthetic" type="boolean" line="485"/>
            <method name="isDeprecated" type="boolean" line="488"/>
            <method name="isAnonymous" type="boolean" line="491"/>
            <method name="isLocal" type="boolean" line="494"/>
            <method name="hasConstructor" type="boolean" line="497"/>
            <javadoc line="502">
                Check to see if a class must be abstract.  This method replaces
                  isAbstract(env)                
            </javadoc>
            <method name="mustBeAbstract" type="boolean" line="506">
                <params>
                    <param name="env" type="Environment"/>
                </params>
                <comment line="507">
                    If it is declared abstract, return true.                    
                </comment>
                <comment line="508">
                    (Fix for 4110534.)                    
                </comment>
                <comment line="513">
                    Check to see if the class should have been declared to be                    
                </comment>
                <comment line="514">
                    abstract.                    
                </comment>
                <comment line="516">
                    We make sure that the inherited method collection has been                    
                </comment>
                <comment line="517">
                    performed.                    
                </comment>
                <comment line="520">
                    We check for any abstract methods inherited or declared                    
                </comment>
                <comment line="521">
                    by this class.                    
                </comment>
                <comment line="531">
                    We check for hidden &quot;permanently abstract&quot; methods in                    
                </comment>
                <comment line="532">
                    our superclasses.                    
                </comment>
                <scope line="509"/>
                <declaration name="methods" type="Iterator" line="522"/>
                <scope line="523">
                    <declaration name="method" type="MemberDefinition" line="524"/>
                    <scope line="526"/>
                </scope>
            </method>
            <javadoc line="536">
                Check if this is a super class of another class                
            </javadoc>
            <method name="superClassOf" type="boolean" line="540">
                <params>
                    <param name="env" type="Environment"/>
                    <param name="otherClass" type="ClassDeclaration"/>
                </params>
                <scope line="541">
                    <scope line="542"/>
                </scope>
            </method>
            <javadoc line="550">
                Check if this is an enclosing class of another class                
            </javadoc>
            <method name="enclosingClassOf" type="boolean" line="553">
                <params>
                    <param name="otherClass" type="ClassDefinition"/>
                </params>
                <scope line="554">
                    <scope line="555"/>
                </scope>
            </method>
            <javadoc line="562">
                Check if this is a sub class of another class                
            </javadoc>
            <method name="subClassOf" type="boolean" line="565">
                <params>
                    <param name="env" type="Environment"/>
                    <param name="otherClass" type="ClassDeclaration"/>
                </params>
                <declaration name="c" type="ClassDeclaration" line="566"/>
                <scope line="567">
                    <scope line="568"/>
                </scope>
            </method>
            <javadoc line="576">
                Check if this class is implemented by another class                
            </javadoc>
            <method name="implementedBy" type="boolean" line="579">
                <params>
                    <param name="env" type="Environment"/>
                    <param name="c" type="ClassDeclaration"/>
                </params>
                <scope line="580">
                    <scope line="581"/>
                    <declaration name="intf" type="ClassDeclaration" line="584"/>
                    <scope line="585">
                        <scope line="586"/>
                    </scope>
                </scope>
            </method>
            <javadoc line="594">
                Check to see if a class which implements interface `this&apos; could
                  possibly implement the interface `intDef&apos;.  Note that the only
                  way that this can fail is if `this&apos; and `intDef&apos; have methods
                  which are of the same signature and different return types.  This
                  method is used by Environment.explicitCast() to determine if a
                  cast between two interfaces is legal.
                  This method should only be called on a class after it has been
                  basicCheck()&apos;ed.                
            </javadoc>
            <method name="couldImplement" type="boolean" line="605">
                <params>
                    <param name="intDef" type="ClassDefinition"/>
                </params>
                <comment line="606">
                    Check to see if we could have done the necessary checks.                    
                </comment>
                <comment line="611">
                    This method should only be called for interfaces.                    
                </comment>
                <comment line="616">
                    Make sure we are not called before we have collected our                    
                </comment>
                <comment line="617">
                    inheritance information.                    
                </comment>
                <comment line="622">
                    Get the other classes&apos; methods.  getMethods() in                    
                </comment>
                <comment line="623">
                    general can return methods which are not visible to the                    
                </comment>
                <comment line="624">
                    current package.  We need to make sure that these do not                    
                </comment>
                <comment line="625">
                    prevent this class from being implemented.                    
                </comment>
                <comment line="629">
                    Get one of the methods from intDef...                    
                </comment>
                <comment line="636">
                    See if we implement a method of the same signature...                    
                </comment>
                <comment line="639">
                    System.out.println(&quot;Comparing\n\t&quot; + myMethod +                    
                </comment>
                <comment line="640">
                    &quot;\nand\n\t&quot; + method);                    
                </comment>
                <comment line="643">
                    We do.  Make sure the methods have the same return type.                    
                </comment>
                <scope line="607"/>
                <scope line="612"/>
                <scope line="618"/>
                <declaration name="otherMethods" type="Iterator" line="626"/>
                <scope line="628">
                    <declaration name="method" type="MemberDefinition" line="630"/>
                    <declaration name="name" type="Identifier" line="633"/>
                    <declaration name="type" type="Type" line="634"/>
                    <declaration name="myMethod" type="MemberDefinition" line="637"/>
                    <scope line="642">
                        <scope line="644"/>
                    </scope>
                </scope>
            </method>
            <javadoc line="653">
                Check if another class can be accessed from the &apos;extends&apos; or &apos;implements&apos;
                  clause of this class.                
            </javadoc>
            <method name="extendsCanAccess" type="boolean" line="657">
                <params>
                    <param name="env" type="Environment"/>
                    <param name="c" type="ClassDeclaration"/>
                </params>
                <comment line="659">
                    Names in the &apos;extends&apos; or &apos;implements&apos; clause of an inner class                    
                </comment>
                <comment line="660">
                    are checked as if they appeared in the body of the surrounding class.                    
                </comment>
                <comment line="665">
                    We are a package member.                    
                </comment>
                <comment line="670">
                    No locals should be in scope in the &apos;extends&apos; or                    
                </comment>
                <comment line="671">
                    &apos;implements&apos; clause of a package member.                    
                </comment>
                <comment line="678">
                    Access to public member is always allowed.                    
                </comment>
                <comment line="683">
                    Private access is ok only from the same class nest.  This can                    
                </comment>
                <comment line="684">
                    happen only if the class represented by &apos;this&apos; encloses the inner                    
                </comment>
                <comment line="685">
                    class represented by &apos;f&apos;.                    
                </comment>
                <comment line="690">
                    Protected or default access -- allow access if in same package.                    
                </comment>
                <comment line="694">
                    Access to public member is always allowed.                    
                </comment>
                <comment line="699">
                    Default access -- allow access if in same package.                    
                </comment>
                <scope line="661"/>
                <declaration name="cdef" type="ClassDefinition" line="667"/>
                <scope line="669"/>
                <scope line="675">
                    <declaration name="f" type="MemberDefinition" line="676"/>
                    <scope line="679"/>
                    <scope line="686"/>
                </scope>
                <scope line="695"/>
            </method>
            <javadoc line="703">
                Check if another class can be accessed from within the body of this class.                
            </javadoc>
            <method name="canAccess" type="boolean" line="706">
                <params>
                    <param name="env" type="Environment"/>
                    <param name="c" type="ClassDeclaration"/>
                </params>
                <comment line="710">
                    if it&apos;s in scope, it&apos;s accessible                    
                </comment>
                <comment line="718">
                    Public access is always ok                    
                </comment>
                <comment line="723">
                    It must be in the same package                    
                </comment>
                <declaration name="cdef" type="ClassDefinition" line="707"/>
                <scope line="709"/>
                <scope line="714"/>
                <scope line="719"/>
            </method>
            <javadoc line="727">
                Check if a field can be accessed from a class                
            </javadoc>
            <method name="canAccess" type="boolean" line="732">
                <params>
                    <param name="env" type="Environment"/>
                    <param name="f" type="MemberDefinition"/>
                </params>
                <comment line="734">
                    Public access is always ok                    
                </comment>
                <comment line="738">
                    Protected access is ok from a subclass                    
                </comment>
                <comment line="742">
                    Private access is ok only from the same class nest                    
                </comment>
                <comment line="747">
                    It must be in the same package                    
                </comment>
                <scope line="735"/>
                <scope line="739"/>
                <scope line="743"/>
            </method>
            <javadoc line="751">
                Check if a class is entitled to inline access to a class from
                  another class.                
            </javadoc>
            <method name="permitInlinedAccess" type="boolean" line="756">
                <params>
                    <param name="env" type="Environment"/>
                    <param name="c" type="ClassDeclaration"/>
                </params>
            </method>
            <javadoc line="762">
                Check if a class is entitled to inline access to a method from
                  another class.                
            </javadoc>
            <method name="permitInlinedAccess" type="boolean" line="767">
                <params>
                    <param name="env" type="Environment"/>
                    <param name="f" type="MemberDefinition"/>
                </params>
            </method>
            <javadoc line="773">
                We know the the field is marked protected (and not public) and that
                  the field is visible (as per canAccess).  Can we access the field as
                  &lt;accessor&gt;.&lt;field&gt;, where &lt;accessor&gt; has the type &lt;accessorType&gt;?
                  Protected fields can only be accessed when the accessorType is a
                  subclass of the current class                
            </javadoc>
            <method name="protectedAccess" type="boolean" line="784">
                <params>
                    <param name="env" type="Environment"/>
                    <param name="f" type="MemberDefinition"/>
                    <param name="accessorType" type="Type"/>
                </params>
                <comment line="787">
                    static protected fields are accessible                    
                </comment>
                <comment line="789">
                    allow array.clone()                    
                </comment>
                <comment line="792">
                    &lt;accessorType&gt; is a subtype of the current class                    
                </comment>
                <comment line="796">
                    we are accessing the field from a friendly class (same package)                    
                </comment>
            </method>
            <javadoc line="802">
                Find or create an access method for a private member,
                  or return null if this is not possible.                
            </javadoc>
            <method name="getAccessMember" type="MemberDefinition" line="807">
                <params>
                    <param name="env" type="Environment"/>
                    <param name="ctx" type="Context"/>
                    <param name="field" type="MemberDefinition"/>
                    <param name="isSuper" type="boolean"/>
                </params>
            </method>
            <javadoc line="811">
                Find or create an update method for a private member,
                  or return null if this is not possible.                
            </javadoc>
            <method name="getUpdateMember" type="MemberDefinition" line="816">
                <params>
                    <param name="env" type="Environment"/>
                    <param name="ctx" type="Context"/>
                    <param name="field" type="MemberDefinition"/>
                    <param name="isSuper" type="boolean"/>
                </params>
            </method>
            <javadoc line="820">
                Get a field from this class.  Report ambiguous fields.
                  If no accessible field is found, this method may return an
                  inaccessible field to allow a useful error message.
                  getVariable now takes the source class `source&apos; as an argument.
                  This allows getVariable to check whether a field is inaccessible
                  before it signals that a field is ambiguous.  The compiler used to
                  signal an ambiguity even when one of the fields involved was not
                  accessible.  (bug 4053724)                
            </javadoc>
            <method name="getVariable" type="MemberDefinition" line="834">
                <params>
                    <param name="env" type="Environment"/>
                    <param name="nm" type="Identifier"/>
                    <param name="source" type="ClassDefinition"/>
                </params>
            </method>
            <method name="getVariable0" type="MemberDefinition" line="851">
                <params>
                    <param name="env" type="Environment"/>
                    <param name="nm" type="Identifier"/>
                    <param name="source" type="ClassDefinition"/>
                    <param name="showPrivate" type="boolean"/>
                    <param name="showPackage" type="boolean"/>
                </params>
                <comment line="853">
                    Check to see if this field is defined in the current class                    
                </comment>
                <comment line="860">
                    It is defined in this class.                    
                </comment>
                <comment line="863">
                    Even though this definition is not inherited,                    
                </comment>
                <comment line="864">
                    it hides all definitions in supertypes.                    
                </comment>
                <comment line="870">
                    Find the field in our superclass.                    
                </comment>
                <comment line="881">
                    Find the field in our superinterfaces.                    
                </comment>
                <comment line="883">
                    Try to look up the field in an interface.  Since interfaces                    
                </comment>
                <comment line="884">
                    only have public fields, the values of the two boolean                    
                </comment>
                <comment line="885">
                    arguments are not important.                    
                </comment>
                <comment line="891">
                    If we have two different, accessible fields, then                    
                </comment>
                <comment line="892">
                    we&apos;ve found an ambiguity.                    
                </comment>
                <scope line="856">
                    <scope line="857">
                        <scope line="859"/>
                        <scope line="862"/>
                    </scope>
                </scope>
                <declaration name="sup" type="ClassDeclaration" line="871"/>
                <declaration name="field" type="MemberDefinition" line="872"/>
                <scope line="873"/>
                <scope line="882">
                    <declaration name="field2" type="MemberDefinition" line="886"/>
                    <scope line="890">
                        <scope line="895"/>
                    </scope>
                </scope>
            </method>
            <javadoc line="905">
                Tells whether to report a deprecation error for this class.                
            </javadoc>
            <method name="reportDeprecated" type="boolean" line="908">
                <params>
                    <param name="env" type="Environment"/>
                </params>
            </method>
            <javadoc line="913">
                Note that this class is being used somehow by &lt;tt&gt;ref&lt;/tt&gt;.
                  Report deprecation errors, etc.                
            </javadoc>
            <method name="noteUsedBy" type="void" line="917">
                <params>
                    <param name="ref" type="ClassDefinition"/>
                    <param name="where" type="long"/>
                    <param name="env" type="Environment"/>
                </params>
                <comment line="918">
                    (Have this deal with canAccess() checks, too?)                    
                </comment>
                <scope line="919"/>
            </method>
            <javadoc line="924">
                Get an inner class.
                  Look in supers but not outers.
                  (This is used directly to resolve expressions like &quot;site.K&quot;, and
                  inside a loop to resolve lone names like &quot;K&quot; or the &quot;K&quot; in &quot;K.L&quot;.)
                  Called from &apos;Context&apos; and &apos;FieldExpression&apos; as well as this class.                
                <see>
                    FieldExpression.checkCommon                    
                </see>
                <see>
                    resolveName                    
                </see>
            </javadoc>
            <method name="getInnerClass" type="MemberDefinition" line="936">
                <params>
                    <param name="env" type="Environment"/>
                    <param name="nm" type="Identifier"/>
                </params>
                <comment line="937">
                    Note:  AmbiguousClass will not be thrown unless and until                    
                </comment>
                <comment line="938">
                    inner classes can be defined inside interfaces.                    
                </comment>
                <comment line="940">
                    Check if it is defined in the current class                    
                </comment>
                <comment line="945">
                    ignore this name; it is internally generated                    
                </comment>
                <comment line="951">
                    Get it from the super class                    
                </comment>
                <comment line="952">
                    It is likely that &apos;getSuperClass()&apos; could be made to work here                    
                </comment>
                <comment line="953">
                    but we would have to assure somehow that &apos;resolveTypeStructure&apos;                    
                </comment>
                <comment line="954">
                    has been called on the current class nest.  Since we can get                    
                </comment>
                <comment line="955">
                    here from &apos;resolveName&apos;, which is called from &apos;resolveSupers&apos;,                    
                </comment>
                <comment line="956">
                    it is possible that the first attempt to resolve the superclass                    
                </comment>
                <comment line="957">
                    will originate here, instead of in the call to &apos;getSuperClass&apos;                    
                </comment>
                <comment line="958">
                    in &apos;checkSupers&apos;.  See &apos;resolveTypeStructure&apos;, in which a call                    
                </comment>
                <comment line="959">
                    to &apos;resolveSupers&apos; precedes the call to &apos;checkSupers&apos;.  Why is                    
                </comment>
                <comment line="960">
                    name resolution done twice, first in &apos;resolveName&apos;?                    
                </comment>
                <comment line="961">
                    NOTE: &apos;SourceMember.resolveTypeStructure&apos; may initiate type                    
                </comment>
                <comment line="962">
                    structure resolution for an inner class.  Normally, this                    
                </comment>
                <comment line="963">
                    occurs during the resolution of the outer class, but fields                    
                </comment>
                <comment line="964">
                    added after the resolution of their containing class will                    
                </comment>
                <comment line="965">
                    be resolved late -- see &apos;addMember(env,field)&apos; below.                    
                </comment>
                <comment line="966">
                    This should only happen for synthetic members, which should                    
                </comment>
                <comment line="967">
                    never be an inner class.                    
                </comment>
                <scope line="942">
                    <scope line="943">
                        <scope line="944"/>
                    </scope>
                </scope>
                <declaration name="sup" type="ClassDeclaration" line="968"/>
            </method>
            <javadoc line="975">
                Lookup a method.  This code implements the method lookup
                  mechanism specified in JLS 15.11.2.
                  This mechanism cannot be used to lookup synthetic methods.                
            </javadoc>
            <method name="matchMethod" type="MemberDefinition" line="987">
                <params>
                    <param name="env" type="Environment"/>
                    <param name="accessor" type="ClassDefinition"/>
                    <param name="methodName" type="Identifier"/>
                    <param name="argumentTypes" type="Type[]"/>
                    <param name="isAnonConstCall" type="boolean"/>
                    <param name="accessPackage" type="Identifier"/>
                </params>
                <comment line="990">
                    This may be too restrictive.                    
                </comment>
                <comment line="992">
                    collectInheritedMethods(env);                    
                </comment>
                <comment line="995">
                    A tentative maximally specific method.                    
                </comment>
                <comment line="998">
                    A list of other methods which may be maximally specific too.                    
                </comment>
                <comment line="1001">
                    Get all the methods inherited by this class which                    
                </comment>
                <comment line="1002">
                    have the name `methodName&apos;.                    
                </comment>
                <comment line="1008">
                    See if this method is applicable.                    
                </comment>
                <comment line="1013">
                    See if this method is accessible.                    
                </comment>
                <comment line="1023">
                    For anonymous constructor accesses, we                    
                </comment>
                <comment line="1024">
                    haven&apos;t yet built an accessing class.                    
                </comment>
                <comment line="1025">
                    We disallow anonymous classes from seeing                    
                </comment>
                <comment line="1026">
                    private/package-private inaccessible                    
                </comment>
                <comment line="1027">
                    constructors in their superclass.                    
                </comment>
                <comment line="1031">
                    If accessor is null, we assume that the access                    
                </comment>
                <comment line="1032">
                    is allowed.  Query: is this option used?                    
                </comment>
                <comment line="1036">
                    `method&apos; becomes our tentative maximally specific match.                    
                </comment>
                <comment line="1040">
                    We have found a method which is a strictly better                    
                </comment>
                <comment line="1041">
                    match than `tentative&apos;.  Replace it.                    
                </comment>
                <comment line="1044">
                    If this method could possibly be another                    
                </comment>
                <comment line="1045">
                    maximally specific method, add it to our                    
                </comment>
                <comment line="1046">
                    list of other candidates.                    
                </comment>
                <comment line="1058">
                    Find out if our `tentative&apos; match is a uniquely                    
                </comment>
                <comment line="1059">
                    maximally specific.                    
                </comment>
                <scope line="989"/>
                <declaration name="tentative" type="MemberDefinition" line="996"/>
                <declaration name="candidateList" type="List" line="999"/>
                <declaration name="methods" type="Iterator" line="1003"/>
                <scope line="1005">
                    <declaration name="method" type="MemberDefinition" line="1006"/>
                    <scope line="1009"/>
                    <scope line="1014">
                        <scope line="1015"/>
                    </scope>
                    <scope line="1018">
                        <scope line="1022"/>
                    </scope>
                    <scope line="1030"/>
                    <scope line="1035"/>
                    <scope line="1038">
                        <scope line="1039"/>
                        <scope line="1043">
                            <scope line="1047">
                                <scope line="1048"/>
                            </scope>
                        </scope>
                    </scope>
                </scope>
                <scope line="1057">
                    <declaration name="candidates" type="Iterator" line="1060"/>
                    <scope line="1061">
                        <declaration name="method" type="MemberDefinition" line="1062"/>
                        <scope line="1063"/>
                    </scope>
                </scope>
            </method>
            <javadoc line="1072">
                Lookup a method.  This code implements the method lookup
                  mechanism specified in JLS 15.11.2.
                  This mechanism cannot be used to lookup synthetic methods.                
            </javadoc>
            <method name="matchMethod" type="MemberDefinition" line="1082">
                <params>
                    <param name="env" type="Environment"/>
                    <param name="accessor" type="ClassDefinition"/>
                    <param name="methodName" type="Identifier"/>
                    <param name="argumentTypes" type="Type[]"/>
                </params>
            </method>
            <javadoc line="1088">
                Lookup a method.  This code implements the method lookup
                  mechanism specified in JLS 15.11.2.
                  This mechanism cannot be used to lookup synthetic methods.                
            </javadoc>
            <method name="matchMethod" type="MemberDefinition" line="1097">
                <params>
                    <param name="env" type="Environment"/>
                    <param name="accessor" type="ClassDefinition"/>
                    <param name="methodName" type="Identifier"/>
                </params>
            </method>
            <javadoc line="1103">
                A version of matchMethod to be used only for constructors
                  when we cannot pass in a sourceClass argument.  We just assert
                  our package name.
                  This is used only for anonymous classes, where we have to look up
                  a (potentially) protected constructor with no valid sourceClass
                  parameter available.                
            </javadoc>
            <method name="matchAnonConstructor" type="MemberDefinition" line="1115">
                <params>
                    <param name="env" type="Environment"/>
                    <param name="accessPackage" type="Identifier"/>
                    <param name="argumentTypes" type="Type"/>
                </params>
            </method>
            <javadoc line="1121">
                Find a method, ie: exact match in this class or any of the super
                  classes.
                  Only called by javadoc.  For now I am holding off rewriting this
                  code to rely on collectInheritedMethods(), as that code has
                  not gotten along with javadoc in the past.                
            </javadoc>
            <method name="findMethod" type="MemberDefinition" line="1130">
                <params>
                    <param name="env" type="Environment"/>
                    <param name="nm" type="Identifier"/>
                    <param name="t" type="Type"/>
                </params>
                <comment line="1131">
                    look in the current class                    
                </comment>
                <comment line="1134">
                    Note that non-method types return false for equalArguments().                    
                </comment>
                <comment line="1140">
                    constructors are not inherited                    
                </comment>
                <comment line="1145">
                    look in the super class                    
                </comment>
                <declaration name="f" type="MemberDefinition" line="1132"/>
                <scope line="1133">
                    <scope line="1135"/>
                </scope>
                <scope line="1141"/>
                <declaration name="sup" type="ClassDeclaration" line="1146"/>
            </method>
            <method name="basicCheck" type="void" line="1154">
                <params>
                    <param name="env" type="Environment"/>
                </params>
                <comment line="1155">
                    Do the outer class first.                    
                </comment>
            </method>
            <javadoc line="1160">
                Check this class.                
            </javadoc>
            <method name="check" type="void" line="1163">
                <params>
                    <param name="env" type="Environment"/>
                </params>
            </method>
            <method name="checkLocalClass" type="Vset" line="1169">
                <params>
                    <param name="env" type="Environment"/>
                    <param name="ctx" type="Context"/>
                    <param name="vset" type="Vset"/>
                    <param name="sup" type="ClassDefinition"/>
                    <param name="args" type="Expression"/>
                    <param name="argTypes" type="Type"/>
                </params>
            </method>
            <declaration name="allMethods" type="MethodSet" line="1179"/>
            <declaration name="permanentlyAbstractMethods" type="List" line="1189"/>
            <javadoc line="1191">
                This method returns an Iterator of all abstract methods
                  in our superclasses which we are unable to implement.                
            </javadoc>
            <method name="getPermanentlyAbstractMethods" type="Iterator" line="1195">
                <comment line="1196">
                    This method can only be called after collectInheritedMethods.                    
                </comment>
                <scope line="1197"/>
            </method>
            <declaration name="doInheritanceChecks" type="boolean" line="1204"/>
            <javadoc line="1204">
                A flag used by turnOffInheritanceChecks() to indicate if
                  inheritance checks are on or off.                
            </javadoc>
            <javadoc line="1210">
                This is a workaround to allow javadoc to turn off certain
                  inheritance/override checks which interfere with javadoc
                  badly.  In the future it might be good to eliminate the
                  shared sources of javadoc and javac to avoid the need for this
                  sort of workaround.                
            </javadoc>
            <method name="turnOffInheritanceChecks" type="void" line="1217"/>
            <javadoc line="1221">
                Add all of the methods declared in or above `parent&apos; to
                  `allMethods&apos;, the set of methods in the current class.
                  `myMethods&apos; is the set of all methods declared in this
                  class, and `mirandaMethods&apos; is a repository for Miranda methods.
                  If mirandaMethods is null, no mirandaMethods will be
                  generated.
                  For a definition of Miranda methods, see the comment above the
                  method addMirandaMethods() which occurs later in this file.                
            </javadoc>
            <method name="collectOneClass" type="void" line="1236">
                <params>
                    <param name="env" type="Environment"/>
                    <param name="parent" type="ClassDeclaration"/>
                    <param name="myMethods" type="MethodSet"/>
                    <param name="allMethods" type="MethodSet"/>
                    <param name="mirandaMethods" type="MethodSet"/>
                </params>
                <comment line="1238">
                    System.out.println(&quot;Inheriting methods from &quot; + parent);                    
                </comment>
                <comment line="1247">
                    Private methods are not inherited.                    
                </comment>
                <comment line="1248">
                                        
                </comment>
                <comment line="1249">
                    Constructors are not inherited.                    
                </comment>
                <comment line="1250">
                                        
                </comment>
                <comment line="1251">
                    Any non-abstract methods in an interface come                    
                </comment>
                <comment line="1252">
                    from java.lang.Object.  This means that they                    
                </comment>
                <comment line="1253">
                    should have already been added to allMethods                    
                </comment>
                <comment line="1254">
                    when we walked our superclass lineage.                    
                </comment>
                <comment line="1262">
                    Get the components of the methods&apos; signature.                    
                </comment>
                <comment line="1266">
                    Check for a method of the same signature which                    
                </comment>
                <comment line="1267">
                    was locally declared.                    
                </comment>
                <comment line="1271">
                    Is this method inaccessible due to package-private                    
                </comment>
                <comment line="1272">
                    visibility?                    
                </comment>
                <comment line="1278">
                    We give a warning when a class shadows an                    
                </comment>
                <comment line="1279">
                    inaccessible package-private method from                    
                </comment>
                <comment line="1280">
                    its superclass.  This warning is meant                    
                </comment>
                <comment line="1281">
                    to prevent people from relying on overriding                    
                </comment>
                <comment line="1282">
                    when it does not happen.  This warning should                    
                </comment>
                <comment line="1283">
                    probably be removed to be consistent with the                    
                </comment>
                <comment line="1284">
                    general &quot;no warnings&quot; policy of this                    
                </comment>
                <comment line="1285">
                    compiler.                    
                </comment>
                <comment line="1286">
                                        
                </comment>
                <comment line="1287">
                    The `instanceof&apos; above is a hack so that only                    
                </comment>
                <comment line="1288">
                    SourceClass generates this warning, not a                    
                </comment>
                <comment line="1289">
                    BinaryClass, for example.                    
                </comment>
                <comment line="1297">
                    If our superclass has a package-private abstract                    
                </comment>
                <comment line="1298">
                    method that we have no access to, then we add                    
                </comment>
                <comment line="1299">
                    this method to our list of permanently abstract                    
                </comment>
                <comment line="1300">
                    methods.  The idea is, since we cannot override                    
                </comment>
                <comment line="1301">
                    the method, we can never make this class                    
                </comment>
                <comment line="1302">
                    non-abstract.                    
                </comment>
                <comment line="1307">
                    `method&apos; is inaccessible.  We do not inherit it.                    
                </comment>
                <comment line="1312">
                    `method&apos; and `override&apos; have the same signature.                    
                </comment>
                <comment line="1313">
                    We are required to check that `override&apos; is a                    
                </comment>
                <comment line="1314">
                    legal override of `method&apos;                    
                </comment>
                <comment line="1316">
                    System.out.println (&quot;About to check override of &quot; +                    
                </comment>
                <comment line="1317">
                    method);                    
                </comment>
                <comment line="1321">
                    In the absence of a definition in the class                    
                </comment>
                <comment line="1322">
                    itself, we check to see if this definition                    
                </comment>
                <comment line="1323">
                    can be successfully merged with any other                    
                </comment>
                <comment line="1324">
                    inherited definitions.                    
                </comment>
                <comment line="1326">
                    Have we added a member of the same signature                    
                </comment>
                <comment line="1327">
                    to `allMethods&apos; already?                    
                </comment>
                <comment line="1331">
                    If the previous definition is nonexistent or                    
                </comment>
                <comment line="1332">
                    ignorable, replace it.                    
                </comment>
                <comment line="1334">
                    System.out.println(&quot;Added &quot; + method + &quot; to &quot; +                    
                </comment>
                <comment line="1335">
                    this);                    
                </comment>
                <comment line="1339">
                    Whenever a class inherits a method                    
                </comment>
                <comment line="1340">
                    from an interface, that method is                    
                </comment>
                <comment line="1341">
                    one of our &quot;miranda&quot; methods.  Early                    
                </comment>
                <comment line="1342">
                    VMs require that these methods be                    
                </comment>
                <comment line="1343">
                    added as true members to the class                    
                </comment>
                <comment line="1344">
                    to enable method lookup to work in the                    
                </comment>
                <comment line="1345">
                    VM.                    
                </comment>
                <comment line="1351">
                    System.out.println(&quot;Added &quot; + method +                    
                </comment>
                <comment line="1352">
                    &quot; to &quot; + this + &quot; as a Miranda&quot;);                    
                </comment>
                <comment line="1355">
                    There is no previous inherited definition.                    
                </comment>
                <comment line="1356">
                    Add `method&apos; to `allMethods&apos;.                    
                </comment>
                <comment line="1361">
                    If we are in an interface and we have inherited                    
                </comment>
                <comment line="1362">
                    both an abstract method and a non-abstract method                    
                </comment>
                <comment line="1363">
                    then we know that the non-abstract method is                    
                </comment>
                <comment line="1364">
                    a placeholder from Object put in for type checking                    
                </comment>
                <comment line="1365">
                    and the abstract method was already checked to                    
                </comment>
                <comment line="1366">
                    be proper by our superinterface.                    
                </comment>
                <comment line="1370">
                    Okay, `formerMethod&apos; and `method&apos; both have the                    
                </comment>
                <comment line="1371">
                    same signature.  See if they are compatible.                    
                </comment>
                <comment line="1373">
                    System.out.println (&quot;About to check meet of &quot; +                    
                </comment>
                <comment line="1374">
                    method);                    
                </comment>
                <comment line="1379">
                    The methods are incompatible.  Skip to                    
                </comment>
                <comment line="1380">
                    next method.                    
                </comment>
                <comment line="1385">
                    Do nothing.  The current definition                    
                </comment>
                <comment line="1386">
                    is specific enough.                    
                </comment>
                <comment line="1388">
                    System.out.println(&quot;trivial meet of &quot; +                    
                </comment>
                <comment line="1389">
                    method);                    
                </comment>
                <comment line="1394">
                    `method&apos; is more specific than                    
                </comment>
                <comment line="1395">
                    `formerMethod&apos;.  replace `formerMethod&apos;.                    
                </comment>
                <comment line="1397">
                    System.out.println(&quot;new def of &quot; + method);                    
                </comment>
                <comment line="1400">
                    Whenever a class inherits a method                    
                </comment>
                <comment line="1401">
                    from an interface, that method is                    
                </comment>
                <comment line="1402">
                    one of our &quot;miranda&quot; methods.  Early                    
                </comment>
                <comment line="1403">
                    VMs require that these methods be                    
                </comment>
                <comment line="1404">
                    added as true members to the class                    
                </comment>
                <comment line="1405">
                    to enable method lookup to work in the                    
                </comment>
                <comment line="1406">
                    VM.                    
                </comment>
                <comment line="1413">
                    System.out.println(&quot;Added &quot; + method +                    
                </comment>
                <comment line="1414">
                    &quot; to &quot; + this + &quot; as a Miranda&quot;);                    
                </comment>
                <comment line="1422">
                    Neither method is more specific than the other.                    
                </comment>
                <comment line="1423">
                    Oh well.  We need to construct a nontrivial                    
                </comment>
                <comment line="1424">
                    meet of the two methods.                    
                </comment>
                <comment line="1425">
                                        
                </comment>
                <comment line="1426">
                    This is not yet implemented, so we give                    
                </comment>
                <comment line="1427">
                    a message with a helpful workaround.                    
                </comment>
                <scope line="1240">
                    <declaration name="pClass" type="ClassDefinition" line="1241"/>
                    <declaration name="methods" type="Iterator" line="1242"/>
                    <scope line="1243">
                        <declaration name="method" type="MemberDefinition" line="1244"/>
                        <scope line="1257"/>
                        <declaration name="name" type="Identifier" line="1263"/>
                        <declaration name="type" type="Type" line="1264"/>
                        <declaration name="override" type="MemberDefinition" line="1268"/>
                        <scope line="1274">
                            <scope line="1277"/>
                            <scope line="1303"/>
                        </scope>
                        <scope line="1311"/>
                        <scope line="1320">
                            <declaration name="formerMethod" type="MemberDefinition" line="1328"/>
                            <scope line="1333">
                                <scope line="1338"/>
                            </scope>
                            <scope line="1360"/>
                            <scope line="1369">
                                <scope line="1378"/>
                                <scope line="1384"/>
                                <scope line="1393">
                                    <scope line="1399"/>
                                </scope>
                            </scope>
                        </scope>
                    </scope>
                </scope>
                <scope line="1436"/>
            </method>
            <javadoc line="1441">
                &lt;p&gt;Collect all methods defined in this class or inherited from
                  any of our superclasses or interfaces.  Look for any
                  incompatible definitions.
                  &lt;p&gt;This function is also responsible for collecting the
                  &lt;em&gt;Miranda&lt;/em&gt; methods for a class.  For a definition of
                  Miranda methods, see the comment in addMirandaMethods()
                  below.                
            </javadoc>
            <method name="collectInheritedMethods" type="void" line="1451">
                <params>
                    <param name="env" type="Environment"/>
                </params>
                <comment line="1452">
                    The methods defined in this class.                    
                </comment>
                <comment line="1456">
                    System.out.println(&quot;Called collectInheritedMethods() for &quot; +                    
                </comment>
                <comment line="1457">
                    this);                    
                </comment>
                <comment line="1461">
                    We have already done the collection.  No need to                    
                </comment>
                <comment line="1462">
                    do it again.                    
                </comment>
                <comment line="1465">
                    We have run into a circular need to collect our methods.                    
                </comment>
                <comment line="1466">
                    This should not happen at this stage.                    
                </comment>
                <comment line="1474">
                    For testing, do not generate miranda methods.                    
                </comment>
                <comment line="1481">
                    Any methods defined in the current class get added                    
                </comment>
                <comment line="1482">
                    to both the myMethods and the allMethods MethodSets.                    
                </comment>
                <comment line="1488">
                    We only collect methods.  Initializers are not relevant.                    
                </comment>
                <comment line="1492">
                    System.out.println(&quot;Declared in &quot; + this + &quot;, &quot; + member);                    
                </comment>
                <comment line="1494">
                    //////////////////////////////////////////////////////////                    
                </comment>
                <comment line="1495">
                    PCJ 2003-07-30 modified the following code because with                    
                </comment>
                <comment line="1496">
                    the covariant return type feature of the 1.5 compiler,                    
                </comment>
                <comment line="1497">
                    there might be multiple methods with the same signature                    
                </comment>
                <comment line="1498">
                    but different return types, and MethodSet doesn&apos;t                    
                </comment>
                <comment line="1499">
                    support that.  We use a new utility method that attempts                    
                </comment>
                <comment line="1500">
                    to ensure that the appropriate method winds up in the                    
                </comment>
                <comment line="1501">
                    MethodSet.  See 4892308.                    
                </comment>
                <comment line="1502">
                    //////////////////////////////////////////////////////////                    
                </comment>
                <comment line="1503">
                    myMethods.add(member);                    
                </comment>
                <comment line="1504">
                    allMethods.add(member);                    
                </comment>
                <comment line="1505">
                    //////////////////////////////////////////////////////////                    
                </comment>
                <comment line="1508">
                    //////////////////////////////////////////////////////////                    
                </comment>
                <comment line="1512">
                    We&apos;re ready to start adding inherited methods.  First add                    
                </comment>
                <comment line="1513">
                    the methods from our superclass.                    
                </comment>
                <comment line="1515">
                    System.out.println(&quot;About to start superclasses for &quot; + this);                    
                </comment>
                <comment line="1522">
                    Make sure that we add all unimplementable methods from our                    
                </comment>
                <comment line="1523">
                    superclass to our list of unimplementable methods.                    
                </comment>
                <comment line="1531">
                    Now we inherit all of the methods from our interfaces.                    
                </comment>
                <comment line="1533">
                    System.out.println(&quot;About to start interfaces for &quot; + this);                    
                </comment>
                <comment line="1541">
                    Now we have collected all of our methods from our superclasses                    
                </comment>
                <comment line="1542">
                    and interfaces into our `allMethods&apos; member.  Good.  As a last                    
                </comment>
                <comment line="1543">
                    task, we add our collected miranda methods to this class.                    
                </comment>
                <comment line="1544">
                                        
                </comment>
                <comment line="1545">
                    If we do not add the mirandas to the class explicitly, there                    
                </comment>
                <comment line="1546">
                    will be no code generated for them.                    
                </comment>
                <declaration name="myMethods" type="MethodSet" line="1453"/>
                <declaration name="mirandaMethods" type="MethodSet" line="1454"/>
                <scope line="1459">
                    <scope line="1460"/>
                    <scope line="1464"/>
                </scope>
                <scope line="1475"/>
                <scope line="1477"/>
                <scope line="1486">
                    <scope line="1490"/>
                </scope>
                <declaration name="scDecl" type="ClassDeclaration" line="1517"/>
                <scope line="1518">
                    <declaration name="sc" type="ClassDefinition" line="1524"/>
                    <declaration name="supIter" type="Iterator" line="1525"/>
                    <scope line="1526"/>
                </scope>
                <scope line="1535"/>
                <scope line="1547"/>
            </method>
            <method name="methodSetAdd" type="void" line="1568">
                <params>
                    <param name="env" type="Environment"/>
                    <param name="methodSet" type="MethodSet"/>
                    <param name="newMethod" type="MemberDefinition"/>
                </params>
                <declaration name="oldMethod" type="MemberDefinition" line="1569"/>
                <scope line="1571">
                    <declaration name="oldReturnType" type="Type" line="1572"/>
                    <declaration name="newReturnType" type="Type" line="1573"/>
                    <scope line="1574">
                        <scope line="1575"/>
                    </scope>
                    <scope line="1578"/>
                </scope>
                <scope line="1580"/>
            </method>
            <javadoc line="1586">
                Get an Iterator of all methods which could be accessed in an
                  instance of this class.                
            </javadoc>
            <method name="getMethods" type="Iterator" line="1590">
                <params>
                    <param name="env" type="Environment"/>
                </params>
                <scope line="1591"/>
            </method>
            <javadoc line="1597">
                Get an Iterator of all methods which could be accessed in an
                  instance of this class.  Throw a compiler error if we haven&apos;t
                  generated this information yet.                
            </javadoc>
            <method name="getMethods" type="Iterator" line="1602">
                <scope line="1603"/>
            </method>
            <javadoc line="1631">
                Add a list of methods to this class as miranda methods.  This
                  gets overridden with a meaningful implementation in SourceClass.
                  BinaryClass should not need to do anything -- it should already
                  have its miranda methods and, if it doesn&apos;t, then that doesn&apos;t
                  affect our compilation.                
            </javadoc>
            <method name="addMirandaMethods" type="void" line="1639">
                <params>
                    <param name="env" type="Environment"/>
                    <param name="mirandas" type="Iterator"/>
                </params>
                <comment line="1640">
                    do nothing.                    
                </comment>
            </method>
            <method name="inlineLocalClass" type="void" line="1645">
                <params>
                    <param name="env" type="Environment"/>
                </params>
            </method>
            <javadoc line="1648">
                We create a stub for this.  Source classes do more work.
                  Some calls from &apos;SourceClass.checkSupers&apos; execute this method.                
                <see>
                    sun.tools.javac.SourceClass#resolveTypeStructure                    
                </see>
            </javadoc>
            <method name="resolveTypeStructure" type="void" line="1654">
                <params>
                    <param name="env" type="Environment"/>
                </params>
            </method>
            <javadoc line="1657">
                Look up an inner class name, from somewhere inside this class.
                  Since supers and outers are in scope, search them too.
                  &lt;p&gt;
                  If no inner class is found, env.resolveName() is then called,
                  to interpret the ambient package and import directives.
                  &lt;p&gt;
                  This routine operates on a &quot;best-efforts&quot; basis.  If
                  at some point a class is not found, the partially-resolved
                  identifier is returned.  Eventually, someone else has to
                  try to get the ClassDefinition and diagnose the ClassNotFound.
                  &lt;p&gt;
                  resolveName() looks at surrounding scopes, and hence
                  pulling in both inherited and uplevel types.  By contrast,
                  resolveInnerClass() is intended only for interpreting
                  explicitly qualified names, and so look only at inherited
                  types.  Also, resolveName() looks for package prefixes,
                  which appear similar to &quot;very uplevel&quot; outer classes.
                  &lt;p&gt;
                  A similar (but more complex) name-lookup process happens
                  when field and identifier expressions denoting qualified names
                  are type-checked.  The added complexity comes from the fact
                  that variables may occur in such names, and take precedence
                  over class and package names.
                  &lt;p&gt;
                  In the expression type-checker, resolveInnerClass() is paralleled
                  by code in FieldExpression.checkAmbigName(), which also calls
                  ClassDefinition.getInnerClass() to interpret names of the form
                  &quot;OuterClass.Inner&quot; (and also outerObject.Inner).  The checking
                  of an identifier expression that fails to be a variable is referred
                  directly to resolveName().                
            </javadoc>
            <method name="resolveName" type="Identifier" line="1689">
                <params>
                    <param name="env" type="Environment"/>
                    <param name="name" type="Identifier"/>
                </params>
                <comment line="1691">
                    This logic is pretty much exactly parallel to that of                    
                </comment>
                <comment line="1692">
                    Environment.resolveName().                    
                </comment>
                <comment line="1694">
                    Try to resolve the first identifier component,                    
                </comment>
                <comment line="1695">
                    because inner class names take precedence over                    
                </comment>
                <comment line="1696">
                    package prefixes.  (Cf. Environment.resolveName.)                    
                </comment>
                <comment line="1700">
                    The first identifier component refers to an                    
                </comment>
                <comment line="1701">
                    ambiguous class.  Limp on.  We throw away the                    
                </comment>
                <comment line="1702">
                    rest of the classname as it is irrelevant.                    
                </comment>
                <comment line="1703">
                    (part of solution for 4059855).                    
                </comment>
                <comment line="1714">
                    return partially-resolved name someone else can fail on                    
                </comment>
                <comment line="1719">
                    This method used to fail to look for local classes, thus a                    
                </comment>
                <comment line="1720">
                    reference to a local class within, e.g., the type of a member                    
                </comment>
                <comment line="1721">
                    declaration, would fail to resolve if the immediately enclosing                    
                </comment>
                <comment line="1722">
                    context was an inner class.  The code added below is ugly, but                    
                </comment>
                <comment line="1723">
                    it works, and is lifted from existing code in &apos;Context.resolveName&apos;                    
                </comment>
                <comment line="1724">
                    and &apos;Context.getClassCommon&apos;. See the comments there about the design.                    
                </comment>
                <comment line="1725">
                    Fixes 4095716.                    
                </comment>
                <comment line="1736">
                    Look for an unqualified name in enclosing scopes.                    
                </comment>
                <comment line="1742">
                    An uplevel member was found, and was nested more deeply than                    
                </comment>
                <comment line="1743">
                    any enclosing local of the same name.                    
                </comment>
                <comment line="1747">
                    a missing superclass, or something catastrophic                    
                </comment>
                <comment line="1751">
                    No uplevel member found, so use the enclosing local if one was found.                    
                </comment>
                <comment line="1756">
                    look in imports, etc.                    
                </comment>
                <scope line="1693">
                    <declaration name="rhead" type="Identifier" line="1697"/>
                    <scope line="1699"/>
                    <scope line="1707"/>
                    <scope line="1710"/>
                    <scope line="1713"/>
                </scope>
                <declaration name="ls" type="int" line="1727"/>
                <declaration name="lf" type="LocalMember" line="1728"/>
                <scope line="1729">
                    <scope line="1731"/>
                </scope>
                <scope line="1737">
                    <scope line="1738">
                        <declaration name="f" type="MemberDefinition" line="1739"/>
                        <scope line="1741"/>
                    </scope>
                    <scope line="1746"/>
                </scope>
                <scope line="1752"/>
            </method>
            <javadoc line="1760">
                Interpret a qualified class name, which may have further subcomponents..
                  Follow inheritance links, as in:
                  class C { class N { } }  class D extends C { }  ... new D.N() ...
                  Ignore outer scopes and packages.                
                <see>
                    resolveName                    
                </see>
            </javadoc>
            <method name="resolveInnerClass" type="Identifier" line="1767">
                <params>
                    <param name="env" type="Environment"/>
                    <param name="nm" type="Identifier"/>
                </params>
                <comment line="1775">
                    return partially-resolved name someone else can fail on                    
                </comment>
                <comment line="1785">
                    a missing superclass, or something catastrophic                    
                </comment>
                <comment line="1787">
                    Fake a good name for a diagnostic.                    
                </comment>
                <scope line="1769">
                    <declaration name="rhead" type="Identifier" line="1770"/>
                    <scope line="1771"/>
                    <scope line="1774"/>
                </scope>
                <scope line="1778">
                    <scope line="1779">
                        <declaration name="f" type="MemberDefinition" line="1780"/>
                        <scope line="1781"/>
                    </scope>
                    <scope line="1784"/>
                </scope>
            </method>
            <javadoc line="1792">
                While resolving import directives, the question has arisen:
                  does a given inner class exist?  If the top-level class exists,
                  we ask it about an inner class via this method.
                  This method looks only at the literal name of the class,
                  and does not attempt to follow inheritance links.
                  This is necessary, since at the time imports are being
                  processed, inheritance links have not been resolved yet.
                  (Thus, an import directive must always spell a class
                  name exactly.)                
            </javadoc>
            <method name="innerClassExists" type="boolean" line="1803">
                <params>
                    <param name="nm" type="Identifier"/>
                </params>
                <comment line="1807">
                    ignore this name; it is internally generated                    
                </comment>
                <scope line="1804">
                    <scope line="1805">
                        <scope line="1806"/>
                    </scope>
                </scope>
            </method>
            <javadoc line="1816">
                Find any method with a given name.                
            </javadoc>
            <method name="findAnyMethod" type="MemberDefinition" line="1819">
                <params>
                    <param name="env" type="Environment"/>
                    <param name="nm" type="Identifier"/>
                </params>
                <comment line="1827">
                    look in the super class                    
                </comment>
                <declaration name="f" type="MemberDefinition" line="1820"/>
                <scope line="1821">
                    <scope line="1822"/>
                </scope>
                <declaration name="sup" type="ClassDeclaration" line="1828"/>
            </method>
            <javadoc line="1834">
                Given the fact that this class has no method &quot;nm&quot; matching &quot;argTypes&quot;,
                  find out if the mismatch can be blamed on a particular actual argument
                  which disagrees with all of the overloadings.
                  If so, return the code (i&lt;&lt;2)+(castOK&lt;&lt;1)+ambig, where
                  &quot;i&quot; is the number of the offending argument, and
                  &quot;castOK&quot; is 1 if a cast could fix the problem.
                  The target type for the argument is returned in margTypeResult[0].
                  If not all methods agree on this type, &quot;ambig&quot; is 1.
                  If there is more than one method, the choice of target type is
                  arbitrary.&lt;p&gt;
                  Return -1 if every argument is acceptable to at least one method.
                  Return -2 if there are no methods of the required arity.
                  The value &quot;start&quot; gives the index of the first argument to begin
                  checking.                
            </javadoc>
            <method name="diagnoseMismatch" type="int" line="1851">
                <params>
                    <param name="env" type="Environment"/>
                    <param name="nm" type="Identifier"/>
                    <param name="argTypes" type="Type"/>
                    <param name="start" type="int"/>
                    <param name="margTypeResult" type="Type"/>
                </params>
                <declaration name="haveMatch" type="int" line="1852"/>
                <declaration name="margType" type="Type" line="1853"/>
                <scope line="1856">
                    <scope line="1857"/>
                </scope>
            </method>
            <method name="diagnoseMismatch" type="boolean" line="1866">
                <params>
                    <param name="env" type="Environment"/>
                    <param name="nm" type="Identifier"/>
                    <param name="argTypes" type="Type"/>
                    <param name="start" type="int"/>
                    <param name="haveMatch" type="int"/>
                    <param name="margType" type="Type"/>
                </params>
                <comment line="1867">
                    look in the current class                    
                </comment>
                <comment line="1897">
                    constructors are not inherited                    
                </comment>
                <comment line="1902">
                    look in the super class                    
                </comment>
                <declaration name="haveOne" type="boolean" line="1868"/>
                <declaration name="f" type="MemberDefinition" line="1869"/>
                <scope line="1870">
                    <scope line="1871"/>
                    <declaration name="fArgTypes" type="Type" line="1874"/>
                    <scope line="1875">
                        <scope line="1877">
                            <declaration name="at" type="Type" line="1878"/>
                            <declaration name="ft" type="Type" line="1879"/>
                            <scope line="1880"/>
                            <scope line="1883"/>
                            <scope line="1886"/>
                        </scope>
                    </scope>
                </scope>
                <scope line="1898"/>
                <declaration name="sup" type="ClassDeclaration" line="1903"/>
                <scope line="1904"/>
            </method>
            <javadoc line="1912">
                Add a field (no checks)                
            </javadoc>
            <method name="addMember" type="void" line="1915">
                <params>
                    <param name="field" type="MemberDefinition"/>
                </params>
                <comment line="1916">
                    System.out.println(&quot;ADD = &quot; + field);                    
                </comment>
                <comment line="1921">
                    insert this at the front, because of initialization order                    
                </comment>
                <scope line="1917"/>
                <scope line="1920"/>
                <scope line="1925"/>
            </method>
            <javadoc line="1933">
                Add a field (subclasses make checks)                
            </javadoc>
            <method name="addMember" type="void" line="1936">
                <params>
                    <param name="env" type="Environment"/>
                    <param name="field" type="MemberDefinition"/>
                </params>
                <comment line="1939">
                    a late addition                    
                </comment>
                <scope line="1938"/>
            </method>
            <javadoc line="1944">
                Find or create an uplevel reference for the given target.                
            </javadoc>
            <method name="getReference" type="UplevelReference" line="1947">
                <params>
                    <param name="target" type="LocalMember"/>
                </params>
                <scope line="1948">
                    <scope line="1949"/>
                </scope>
            </method>
            <method name="addReference" type="UplevelReference" line="1956">
                <params>
                    <param name="target" type="LocalMember"/>
                </params>
                <scope line="1957"/>
                <declaration name="r" type="UplevelReference" line="1961"/>
            </method>
            <javadoc line="1966">
                Return the list of all uplevel references.                
            </javadoc>
            <method name="getReferences" type="UplevelReference" line="1969"/>
            <javadoc line="1973">
                Return the same value as getReferences.
                  Also, mark the set of references frozen.
                  After that, it is an error to add new references.                
            </javadoc>
            <method name="getReferencesFrozen" type="UplevelReference" line="1978"/>
            <javadoc line="1983">
                assertion check                
            </javadoc>
            <method name="referencesMustNotBeFrozen" type="void" line="1986">
                <scope line="1987"/>
            </method>
            <javadoc line="1992">
                Get helper method for class literal lookup.                
            </javadoc>
            <method name="getClassLiteralLookup" type="MemberDefinition" line="1995">
                <params>
                    <param name="fwhere" type="long"/>
                </params>
            </method>
            <javadoc line="1999">
                Add a dependency                
            </javadoc>
            <method name="addDependency" type="void" line="2002">
                <params>
                    <param name="c" type="ClassDeclaration"/>
                </params>
            </method>
            <javadoc line="2006">
                Maintain a hash table of local and anonymous classes
                  whose internal names are prefixed by the current class.
                  The key is the simple internal name, less the prefix.                
            </javadoc>
            <method name="getLocalClass" type="ClassDefinition" line="2012">
                <params>
                    <param name="name" type="String"/>
                </params>
                <scope line="2013"/>
                <scope line="2015"/>
            </method>
            <method name="addLocalClass" type="void" line="2020">
                <params>
                    <param name="c" type="ClassDefinition"/>
                    <param name="name" type="String"/>
                </params>
                <scope line="2021"/>
            </method>
            <javadoc line="2028">
                Print for debugging                
            </javadoc>
            <method name="print" type="void" line="2031">
                <params>
                    <param name="out" type="PrintStream"/>
                </params>
                <scope line="2032"/>
                <scope line="2035"/>
                <scope line="2037"/>
                <scope line="2041"/>
                <scope line="2044">
                    <scope line="2046">
                        <scope line="2047"/>
                    </scope>
                </scope>
                <scope line="2056"/>
            </method>
            <javadoc line="2064">
                Convert to String                
            </javadoc>
            <method name="toString" type="String" line="2067"/>
            <javadoc line="2071">
                After the class has been written to disk, try to free up
                  some storage.                
            </javadoc>
            <method name="cleanup" type="void" line="2075">
                <params>
                    <param name="env" type="Environment"/>
                </params>
                <comment line="2082">
                    keep &quot;references&quot; around, for the sake of local subclasses                    
                </comment>
                <scope line="2076"/>
                <scope line="2079"/>
            </method>
        </class>
    </source>