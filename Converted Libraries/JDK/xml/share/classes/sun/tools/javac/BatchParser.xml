<?xml version="1.0" encoding="UTF-8"?>
    <source package="sun.tools.javac">
        <import package="sun.tools.java"/>
        <import package="sun.tools.tree"/>
        <import package="java.io.IOException"/>
        <import package="java.io.InputStream"/>
        <import package="java.util.Vector"/>
        <import package="java.util.Enumeration"/>
        <class name="BatchParser" line="36">
            <extends class="Parser"/>
            <javadoc line="36">
                Batch file parser, this needs more work.
                  WARNING: The contents of this source file are not part of any
                  supported API.  Code that depends on them does so at its own risk:
                  they are subject to change or removal without notice.                
            </javadoc>
            <declaration name="pkg" type="Identifier" line="46"/>
            <javadoc line="46">
                The current package                
            </javadoc>
            <declaration name="imports" type="Imports" line="51"/>
            <javadoc line="51">
                The current imports                
            </javadoc>
            <declaration name="classes" type="Vector" line="56"/>
            <javadoc line="56">
                The classes defined in this file                
            </javadoc>
            <declaration name="sourceClass" type="SourceClass" line="62"/>
            <javadoc line="62">
                The current class                
            </javadoc>
            <declaration name="toplevelEnv" type="Environment" line="67"/>
            <javadoc line="67">
                The toplevel environment                
            </javadoc>
            <javadoc line="72">
                Create a batch file parser                
            </javadoc>
            <method name="BatchParser" type="constructor" line="75">
                <params>
                    <param name="env" type="Environment"/>
                    <param name="in" type="InputStream"/>
                </params>
            </method>
            <javadoc line="83">
                Package declaration                
            </javadoc>
            <method name="packageDeclaration" type="void" line="86">
                <params>
                    <param name="where" type="long"/>
                    <param name="t" type="IdentifierToken"/>
                </params>
                <comment line="89">
                    System.out.println(&quot;package &quot; + nm);                    
                </comment>
                <comment line="91">
                    This code has been changed to pass an IdentifierToken,
                     rather than an Identifier, to setCurrentPackage().  Imports
                     now needs the location of the token.                    
                </comment>
                <declaration name="nm" type="Identifier" line="87"/>
                <scope line="89"/>
                <scope line="95"/>
            </method>
            <javadoc line="100">
                Import class                
            </javadoc>
            <method name="importClass" type="void" line="103">
                <params>
                    <param name="pos" type="long"/>
                    <param name="t" type="IdentifierToken"/>
                </params>
                <comment line="105">
                    System.out.println(&quot;import class &quot; + t);                    
                </comment>
            </method>
            <javadoc line="108">
                Import package                
            </javadoc>
            <method name="importPackage" type="void" line="111">
                <params>
                    <param name="pos" type="long"/>
                    <param name="t" type="IdentifierToken"/>
                </params>
                <comment line="113">
                    System.out.println(&quot;import package &quot; + t);                    
                </comment>
            </method>
            <javadoc line="116">
                Define class                
            </javadoc>
            <method name="beginClass" type="ClassDefinition" line="122">
                <params>
                    <param name="where" type="long"/>
                    <param name="doc" type="String"/>
                    <param name="mod" type="int"/>
                    <param name="t" type="IdentifierToken"/>
                    <param name="sup" type="IdentifierToken"/>
                    <param name="interfaces" type="IdentifierToken"/>
                </params>
                <comment line="125">
                    If this class is nested, the modifier bits set here will
                     be copied into the &apos;SourceMember&apos; object for the inner class
                     created during the call to &apos;makeClassDefinition&apos; below.
                     When writing the class file, we will look there for the
                     &apos;untransformed&apos; modifiers.  The modifiers in the ClassDefinition
                     object will end up as the &apos;transformed&apos; modifiers.  Note that
                     there are some bits set here that are not legal class modifiers
                     according to the JVMS, e.g., M_PRIVATE and M_STATIC.  These are
                     masked off while writing the class file, but are preserved in
                     the InnerClasses attributes.                    
                </comment>
                <comment line="145">
                    The defaults for anonymous and local classes should be documented!                    
                </comment>
                <comment line="154">
                    Certain modifiers are implied as follows:
                    
                     1.  Any interface (nested or not) is implicitly deemed to be abstract,
                         whether it is explicitly marked so or not.  (Java 1.0.)
                     2.  A interface which is a member of a type is implicitly deemed to
                         be static, whether it is explicitly marked so or not.  (InnerClasses)
                     3a. A type which is a member of an interface is implicitly deemed
                         to be public, whether it is explicitly marked so or not. (InnerClasses)
                     3b. A type which is a member of an interface is implicitly deemed
                         to be static, whether it is explicitly marked so or not. (InnerClasses)                    
                </comment>
                <comment line="166">
                    Rule 1.                    
                </comment>
                <comment line="169">
                    Rule 2.                    
                </comment>
                <comment line="175">
                    Rule 3a.
                     For interface members, neither &apos;private&apos; nor &apos;protected&apos;
                     are legal modifiers.  We avoid setting M_PUBLIC in some
                     cases in order to avoid interfering with error detection
                     and reporting.  This is patched up, after reporting an
                     error, by &apos;SourceClass.addMember&apos;.                    
                </comment>
                <comment line="183">
                    Rule 3b.                    
                </comment>
                <comment line="187">
                    For nested classes, we must transform &apos;protected&apos; to &apos;public&apos;
                     and &apos;private&apos; to package scope.  This must be done later,
                     because any modifiers set here will be copied into the
                     &apos;MemberDefinition&apos; for the nested class, which must represent
                     the original untransformed modifiers.  Also, compile-time
                     checks should be performed against the actual, untransformed
                     modifiers.  This is in contrast to transformations that implement
                     implicit modifiers, such as M_STATIC and M_FINAL for fields
                     of interfaces.                    
                </comment>
                <comment line="207">
                    The code which adds artificial dependencies between
                     classes in the same source file has been moved to
                     BatchEnvironment#parseFile().                    
                </comment>
                <declaration name="outerClass" type="SourceClass" line="137"/>
                <scope line="139"/>
                <scope line="146"/>
                <scope line="149"/>
                <scope line="164">
                    <scope line="167"/>
                </scope>
                <scope line="173"/>
            </method>
            <javadoc line="219">
                Report the current class under construction.                
            </javadoc>
            <method name="getCurrentClass" type="ClassDefinition" line="222"/>
            <javadoc line="226">
                End class                
            </javadoc>
            <method name="endClass" type="void" line="229">
                <params>
                    <param name="where" type="long"/>
                    <param name="c" type="ClassDefinition"/>
                </params>
                <comment line="234">
                    c == sourceClass; don&apos;t bother to check                    
                </comment>
                <declaration name="outerClass" type="SourceClass" line="235"/>
            </method>
            <javadoc line="244">
                Define a method                
            </javadoc>
            <method name="defineField" type="void" line="250">
                <params>
                    <param name="where" type="long"/>
                    <param name="c" type="ClassDefinition"/>
                    <param name="doc" type="String"/>
                    <param name="mod" type="int"/>
                    <param name="t" type="Type"/>
                    <param name="name" type="IdentifierToken"/>
                    <param name="args" type="IdentifierToken"/>
                    <param name="exp" type="IdentifierToken"/>
                    <param name="val" type="Node"/>
                </params>
                <comment line="252">
                    c == sourceClass; don&apos;t bother to check                    
                </comment>
                <comment line="254">
                    Members that are nested classes are not created with &apos;defineField&apos;,
                     so these transformations do not apply to them.  See &apos;beginClass&apos; above.                    
                </comment>
                <comment line="257">
                    Members of interfaces are implicitly public.                    
                </comment>
                <comment line="259">
                    For interface members, neither &apos;private&apos; nor &apos;protected&apos;
                     are legal modifiers.  Avoid setting M_PUBLIC in some cases
                     to avoid interfering with later error detection.  This will
                     be fixed up after the error is reported.                    
                </comment>
                <comment line="264">
                    Methods of interfaces are implicitly abstract.
                     Fields of interfaces are implicitly static and final.                    
                </comment>
                <comment line="273">
                    The parser reports &quot;idInit&quot; when in reality it has found
                     that there is no method name at all present.
                     So, decide if it&apos;s really a constructor, or a syntax error.                    
                </comment>
                <comment line="277">
                                        
                </comment>
                <comment line="283">
                    It appears to be a constructor with spurious qualification.                    
                </comment>
                <comment line="287">
                    It appears to be a type name with no method name.                    
                </comment>
                <comment line="291">
                    We assume the type name is missing, even though the
                     simple name that&apos;s present might have been intended
                     to be a type:  &quot;String (){}&quot; vs. &quot;toString(){}&quot;.                    
                </comment>
                <declaration name="nm" type="Identifier" line="252"/>
                <scope line="255">
                    <scope line="265"/>
                    <scope line="267"/>
                </scope>
                <scope line="271">
                    <declaration name="rt" type="Type" line="275"/>
                    <declaration name="retname" type="Identifier" line="276"/>
                    <declaration name="clsname" type="Identifier" line="278"/>
                    <scope line="279"/>
                    <scope line="281"/>
                    <scope line="285"/>
                    <scope line="289"/>
                </scope>
                <scope line="298"/>
                <scope line="302"/>
                <declaration name="f" type="MemberDefinition" line="306"/>
                <scope line="309"/>
            </method>
        </class>
    </source>