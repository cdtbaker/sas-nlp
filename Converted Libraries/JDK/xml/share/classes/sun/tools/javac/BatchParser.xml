<?xml version="1.0" encoding="UTF-8"?>
    <source package="sun.tools.javac">
        <import package="sun.tools.java"/>
        <import package="sun.tools.tree"/>
        <import package="java.io.IOException"/>
        <import package="java.io.InputStream"/>
        <import package="java.util.Vector"/>
        <import package="java.util.Enumeration"/>
        <class name="BatchParser" line="36">
            <extends class="Parser"/>
            <javadoc line="36">
                Batch file parser, this needs more work.
                  WARNING: The contents of this source file are not part of any
                  supported API.  Code that depends on them does so at its own risk:
                  they are subject to change or removal without notice.                
            </javadoc>
            <declaration name="pkg" type="Identifier" line="46"/>
            <javadoc line="46">
                The current package                
            </javadoc>
            <declaration name="imports" type="Imports" line="51"/>
            <javadoc line="51">
                The current imports                
            </javadoc>
            <declaration name="classes" type="Vector" line="56"/>
            <javadoc line="56">
                The classes defined in this file                
            </javadoc>
            <declaration name="sourceClass" type="SourceClass" line="62"/>
            <javadoc line="62">
                The current class                
            </javadoc>
            <declaration name="toplevelEnv" type="Environment" line="67"/>
            <javadoc line="67">
                The toplevel environment                
            </javadoc>
            <javadoc line="72">
                Create a batch file parser                
            </javadoc>
            <method name="BatchParser" type="constructor" line="75">
                <params>
                    <param name="env" type="Environment"/>
                    <param name="in" type="InputStream"/>
                </params>
            </method>
            <javadoc line="83">
                Package declaration                
            </javadoc>
            <method name="packageDeclaration" type="void" line="86">
                <params>
                    <param name="where" type="long"/>
                    <param name="t" type="IdentifierToken"/>
                </params>
                <comment line="88">
                    System.out.println(&quot;package &quot; + nm);                    
                </comment>
                <comment line="90">
                    This code has been changed to pass an IdentifierToken,                    
                </comment>
                <comment line="91">
                    rather than an Identifier, to setCurrentPackage().  Imports                    
                </comment>
                <comment line="92">
                    now needs the location of the token.                    
                </comment>
                <declaration name="nm" type="Identifier" line="87"/>
                <scope line="89"/>
                <scope line="95"/>
            </method>
            <javadoc line="100">
                Import class                
            </javadoc>
            <method name="importClass" type="void" line="103">
                <params>
                    <param name="pos" type="long"/>
                    <param name="t" type="IdentifierToken"/>
                </params>
                <comment line="104">
                    System.out.println(&quot;import class &quot; + t);                    
                </comment>
            </method>
            <javadoc line="108">
                Import package                
            </javadoc>
            <method name="importPackage" type="void" line="111">
                <params>
                    <param name="pos" type="long"/>
                    <param name="t" type="IdentifierToken"/>
                </params>
                <comment line="112">
                    System.out.println(&quot;import package &quot; + t);                    
                </comment>
            </method>
            <javadoc line="116">
                Define class                
            </javadoc>
            <method name="beginClass" type="ClassDefinition" line="122">
                <params>
                    <param name="where" type="long"/>
                    <param name="doc" type="String"/>
                    <param name="mod" type="int"/>
                    <param name="t" type="IdentifierToken"/>
                    <param name="sup" type="IdentifierToken"/>
                    <param name="interfaces" type="IdentifierToken"/>
                </params>
                <comment line="124">
                    If this class is nested, the modifier bits set here will                    
                </comment>
                <comment line="125">
                    be copied into the &apos;SourceMember&apos; object for the inner class                    
                </comment>
                <comment line="126">
                    created during the call to &apos;makeClassDefinition&apos; below.                    
                </comment>
                <comment line="127">
                    When writing the class file, we will look there for the                    
                </comment>
                <comment line="128">
                    &apos;untransformed&apos; modifiers.  The modifiers in the ClassDefinition                    
                </comment>
                <comment line="129">
                    object will end up as the &apos;transformed&apos; modifiers.  Note that                    
                </comment>
                <comment line="130">
                    there are some bits set here that are not legal class modifiers                    
                </comment>
                <comment line="131">
                    according to the JVMS, e.g., M_PRIVATE and M_STATIC.  These are                    
                </comment>
                <comment line="132">
                    masked off while writing the class file, but are preserved in                    
                </comment>
                <comment line="133">
                    the InnerClasses attributes.                    
                </comment>
                <comment line="144">
                    The defaults for anonymous and local classes should be documented!                    
                </comment>
                <comment line="153">
                    Certain modifiers are implied as follows:                    
                </comment>
                <comment line="154">
                                        
                </comment>
                <comment line="155">
                    1.  Any interface (nested or not) is implicitly deemed to be abstract,                    
                </comment>
                <comment line="156">
                    whether it is explicitly marked so or not.  (Java 1.0.)                    
                </comment>
                <comment line="157">
                    2.  A interface which is a member of a type is implicitly deemed to                    
                </comment>
                <comment line="158">
                    be static, whether it is explicitly marked so or not.  (InnerClasses)                    
                </comment>
                <comment line="159">
                    3a. A type which is a member of an interface is implicitly deemed                    
                </comment>
                <comment line="160">
                    to be public, whether it is explicitly marked so or not. (InnerClasses)                    
                </comment>
                <comment line="161">
                    3b. A type which is a member of an interface is implicitly deemed                    
                </comment>
                <comment line="162">
                    to be static, whether it is explicitly marked so or not. (InnerClasses)                    
                </comment>
                <comment line="165">
                    Rule 1.                    
                </comment>
                <comment line="168">
                    Rule 2.                    
                </comment>
                <comment line="174">
                    Rule 3a.                    
                </comment>
                <comment line="175">
                    For interface members, neither &apos;private&apos; nor &apos;protected&apos;                    
                </comment>
                <comment line="176">
                    are legal modifiers.  We avoid setting M_PUBLIC in some                    
                </comment>
                <comment line="177">
                    cases in order to avoid interfering with error detection                    
                </comment>
                <comment line="178">
                    and reporting.  This is patched up, after reporting an                    
                </comment>
                <comment line="179">
                    error, by &apos;SourceClass.addMember&apos;.                    
                </comment>
                <comment line="182">
                    Rule 3b.                    
                </comment>
                <comment line="186">
                    For nested classes, we must transform &apos;protected&apos; to &apos;public&apos;                    
                </comment>
                <comment line="187">
                    and &apos;private&apos; to package scope.  This must be done later,                    
                </comment>
                <comment line="188">
                    because any modifiers set here will be copied into the                    
                </comment>
                <comment line="189">
                    &apos;MemberDefinition&apos; for the nested class, which must represent                    
                </comment>
                <comment line="190">
                    the original untransformed modifiers.  Also, compile-time                    
                </comment>
                <comment line="191">
                    checks should be performed against the actual, untransformed                    
                </comment>
                <comment line="192">
                    modifiers.  This is in contrast to transformations that implement                    
                </comment>
                <comment line="193">
                    implicit modifiers, such as M_STATIC and M_FINAL for fields                    
                </comment>
                <comment line="194">
                    of interfaces.                    
                </comment>
                <comment line="206">
                    The code which adds artificial dependencies between                    
                </comment>
                <comment line="207">
                    classes in the same source file has been moved to                    
                </comment>
                <comment line="208">
                    BatchEnvironment#parseFile().                    
                </comment>
                <declaration name="outerClass" type="SourceClass" line="137"/>
                <scope line="139"/>
                <scope line="146"/>
                <scope line="149"/>
                <scope line="164">
                    <scope line="167"/>
                </scope>
                <scope line="173"/>
            </method>
            <javadoc line="219">
                Report the current class under construction.                
            </javadoc>
            <method name="getCurrentClass" type="ClassDefinition" line="222"/>
            <javadoc line="226">
                End class                
            </javadoc>
            <method name="endClass" type="void" line="229">
                <params>
                    <param name="where" type="long"/>
                    <param name="c" type="ClassDefinition"/>
                </params>
                <comment line="233">
                    c == sourceClass; don&apos;t bother to check                    
                </comment>
                <declaration name="outerClass" type="SourceClass" line="235"/>
            </method>
            <javadoc line="244">
                Define a method                
            </javadoc>
            <method name="defineField" type="void" line="250">
                <params>
                    <param name="where" type="long"/>
                    <param name="c" type="ClassDefinition"/>
                    <param name="doc" type="String"/>
                    <param name="mod" type="int"/>
                    <param name="t" type="Type"/>
                    <param name="name" type="IdentifierToken"/>
                    <param name="args" type="IdentifierToken"/>
                    <param name="exp" type="IdentifierToken"/>
                    <param name="val" type="Node"/>
                </params>
                <comment line="251">
                    c == sourceClass; don&apos;t bother to check                    
                </comment>
                <comment line="253">
                    Members that are nested classes are not created with &apos;defineField&apos;,                    
                </comment>
                <comment line="254">
                    so these transformations do not apply to them.  See &apos;beginClass&apos; above.                    
                </comment>
                <comment line="256">
                    Members of interfaces are implicitly public.                    
                </comment>
                <comment line="258">
                    For interface members, neither &apos;private&apos; nor &apos;protected&apos;                    
                </comment>
                <comment line="259">
                    are legal modifiers.  Avoid setting M_PUBLIC in some cases                    
                </comment>
                <comment line="260">
                    to avoid interfering with later error detection.  This will                    
                </comment>
                <comment line="261">
                    be fixed up after the error is reported.                    
                </comment>
                <comment line="263">
                    Methods of interfaces are implicitly abstract.                    
                </comment>
                <comment line="264">
                    Fields of interfaces are implicitly static and final.                    
                </comment>
                <comment line="272">
                    The parser reports &quot;idInit&quot; when in reality it has found                    
                </comment>
                <comment line="273">
                    that there is no method name at all present.                    
                </comment>
                <comment line="274">
                    So, decide if it&apos;s really a constructor, or a syntax error.                    
                </comment>
                <comment line="276">
                                        
                </comment>
                <comment line="282">
                    It appears to be a constructor with spurious qualification.                    
                </comment>
                <comment line="286">
                    It appears to be a type name with no method name.                    
                </comment>
                <comment line="290">
                    We assume the type name is missing, even though the                    
                </comment>
                <comment line="291">
                    simple name that&apos;s present might have been intended                    
                </comment>
                <comment line="292">
                    to be a type:  &quot;String (){}&quot; vs. &quot;toString(){}&quot;.                    
                </comment>
                <declaration name="nm" type="Identifier" line="252"/>
                <scope line="255">
                    <scope line="265"/>
                    <scope line="267"/>
                </scope>
                <scope line="271">
                    <declaration name="rt" type="Type" line="275"/>
                    <declaration name="retname" type="Identifier" line="276"/>
                    <declaration name="clsname" type="Identifier" line="278"/>
                    <scope line="279"/>
                    <scope line="281"/>
                    <scope line="285"/>
                    <scope line="289"/>
                </scope>
                <scope line="298"/>
                <scope line="302"/>
                <declaration name="f" type="MemberDefinition" line="306"/>
                <scope line="309"/>
            </method>
        </class>
    </source>