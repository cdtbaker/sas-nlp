<?xml version="1.0" encoding="UTF-8"?>
    <source package="sun.tools.javac">
        <import package="sun.tools.java"/>
        <import package="sun.tools.tree"/>
        <import package="sun.tools.tree.CompoundStatement"/>
        <import package="sun.tools.asm.Assembler"/>
        <import package="sun.tools.asm.ConstantPool"/>
        <import package="java.util.Vector"/>
        <import package="java.util.Enumeration"/>
        <import package="java.util.Hashtable"/>
        <import package="java.util.Iterator"/>
        <import package="java.io.IOException"/>
        <import package="java.io.OutputStream"/>
        <import package="java.io.DataOutputStream"/>
        <import package="java.io.ByteArrayOutputStream"/>
        <import package="java.io.File"/>
        <class name="SourceClass" line="43">
            <extends class="ClassDefinition"/>
            <comment line="200">
                JCOV                
            </comment>
            <comment line="209">
                end JCOV                
            </comment>
            <comment line="653">
                Set true if superclass (but not necessarily superinterfaces) have                
            </comment>
            <comment line="654">
                been checked.  If the superclass is still unresolved, then an error                
            </comment>
            <comment line="655">
                message should have been issued, and we assume that no further                
            </comment>
            <comment line="656">
                resolution is possible.                
            </comment>
            <javadoc line="43">
                This class represents an Java class as it is read from
                  an Java source file.
                  WARNING: The contents of this source file are not part of any
                  supported API.  Code that depends on them does so at its own risk:
                  they are subject to change or removal without notice.                
            </javadoc>
            <declaration name="toplevelEnv" type="Environment" line="55"/>
            <javadoc line="55">
                The toplevel environment, shared with the parser                
            </javadoc>
            <declaration name="defConstructor" type="SourceMember" line="60"/>
            <javadoc line="60">
                The default constructor                
            </javadoc>
            <declaration name="tab" type="ConstantPool" line="65"/>
            <javadoc line="65">
                The constant pool                
            </javadoc>
            <declaration name="deps" type="Hashtable" line="70"/>
            <javadoc line="70">
                The list of class dependencies                
            </javadoc>
            <declaration name="thisArg" type="LocalMember" line="75"/>
            <javadoc line="75">
                The field used to represent &quot;this&quot; in all of my code.                
            </javadoc>
            <declaration name="endPosition" type="long" line="80"/>
            <javadoc line="80">
                Last token of class, as reported by parser.                
            </javadoc>
            <declaration name="dummyArgumentType" type="Type" line="85"/>
            <javadoc line="85">
                Access methods for constructors are distinguished from
                  the constructors themselves by a dummy first argument.
                  A unique type used for this purpose and shared by all
                  constructor access methods within a package-member class is
                  maintained here.
                  &lt;p&gt;
                  This field is null except in an outermost class containing
                  one or more classes needing such an access method.                
            </javadoc>
            <javadoc line="97">
                Constructor                
            </javadoc>
            <method name="SourceClass" type="constructor" line="104">
                <params>
                    <param name="env" type="Environment"/>
                    <param name="where" type="long"/>
                    <param name="declaration" type="ClassDeclaration"/>
                    <param name="documentation" type="String"/>
                    <param name="modifiers" type="int"/>
                    <param name="superClass" type="IdentifierToken"/>
                    <param name="interfaces" type="IdentifierToken"/>
                    <param name="outerClass" type="SourceClass"/>
                    <param name="localName" type="Identifier"/>
                </params>
                <comment line="116">
                    Check for a package level class which is declared static.                    
                </comment>
                <comment line="122">
                    Inner classes cannot be static, nor can they be interfaces                    
                </comment>
                <comment line="123">
                    (which are implicitly static).  Static classes and interfaces                    
                </comment>
                <comment line="124">
                    can only occur as top-level entities.                    
                </comment>
                <comment line="125">
                                        
                </comment>
                <comment line="126">
                    Note that we do not have to check for local classes declared                    
                </comment>
                <comment line="127">
                    to be static (this is currently caught by the parser) but                    
                </comment>
                <comment line="128">
                    we check anyway in case the parser is modified to allow this.                    
                </comment>
                <comment line="149">
                    ----
                    if ((isPublic() || isProtected()) &amp;&amp; isInsideLocal()) {
                    env.error(where, &quot;warn.public.local.class&quot;, this);
                    }                    
                </comment>
                <comment line="155">
                    maybe define an uplevel &quot;A.this&quot; current instance field                    
                </comment>
                <comment line="162">
                    Set simple, unmangled local name for a local or anonymous class.                    
                </comment>
                <comment line="163">
                    NOTE: It would be OK to do this unconditionally, as null is the                    
                </comment>
                <comment line="164">
                    correct value for a member (non-local) class.                    
                </comment>
                <comment line="168">
                    Check for inner class with same simple name as one of                    
                </comment>
                <comment line="169">
                    its enclosing classes.  Note that &apos;getLocalName&apos; returns                    
                </comment>
                <comment line="170">
                    the simple, unmangled source-level name of any class.                    
                </comment>
                <comment line="171">
                    The previous version of this code was not careful to avoid                    
                </comment>
                <comment line="172">
                    mangled local class names.  This version fixes 4047746.                    
                </comment>
                <comment line="175">
                    Test above suppresses error for nested anonymous classes,                    
                </comment>
                <comment line="176">
                    which have an internal &quot;name&quot;, but are not named in source code.                    
                </comment>
                <scope line="112"/>
                <scope line="117"/>
                <scope line="129">
                    <scope line="130"/>
                    <scope line="132">
                        <scope line="135"/>
                    </scope>
                </scope>
                <scope line="141"/>
                <scope line="145"/>
                <scope line="156">
                    <declaration name="outerArg" type="LocalMember" line="157"/>
                    <declaration name="r" type="UplevelReference" line="158"/>
                </scope>
                <declaration name="thisName" type="Identifier" line="173"/>
                <scope line="174">
                    <scope line="178">
                        <declaration name="outerName" type="Identifier" line="179"/>
                    </scope>
                </scope>
            </method>
            <javadoc line="186">
                Return last position in this class.                
                <see>
                    #getWhere                    
                </see>
            </javadoc>
            <method name="getEndPosition" type="long" line="190"/>
            <method name="setEndPosition" type="void" line="194">
                <params>
                    <param name="endPosition" type="long"/>
                </params>
            </method>
            <javadoc line="200">
                Return absolute name of source file                
            </javadoc>
            <method name="getAbsoluteName" type="String" line="203">
                <declaration name="AbsName" type="String" line="204"/>
            </method>
            <javadoc line="210">
                Return imports                
            </javadoc>
            <method name="getImports" type="Imports" line="213"/>
            <javadoc line="217">
                Find or create my &quot;this&quot; argument, which is used for all methods.                
            </javadoc>
            <method name="getThisArgument" type="LocalMember" line="220">
                <scope line="221"/>
            </method>
            <javadoc line="227">
                Add a dependency                
            </javadoc>
            <method name="addDependency" type="void" line="230">
                <params>
                    <param name="c" type="ClassDeclaration"/>
                </params>
                <comment line="234">
                    If doing -xdepend option, save away list of class dependencies                    
                </comment>
                <comment line="235">
                    making sure to NOT include duplicates or the class we are in                    
                </comment>
                <comment line="236">
                    (Hashtable&apos;s put() makes sure we don&apos;t have duplicates)                    
                </comment>
                <scope line="231"/>
                <scope line="237"/>
            </method>
            <javadoc line="242">
                Add a field (check it first)                
            </javadoc>
            <method name="addMember" type="void" line="245">
                <params>
                    <param name="env" type="Environment"/>
                    <param name="f" type="MemberDefinition"/>
                </params>
                <comment line="246">
                    Make sure the access permissions are self-consistent:                    
                </comment>
                <comment line="255">
                    Cut out the more restrictive modifier(s):                    
                </comment>
                <comment line="264">
                    Note exemption for synthetic members below.                    
                </comment>
                <comment line="274">
                    Even if a static passes this test, there is still another                    
                </comment>
                <comment line="275">
                    check in &apos;SourceMember.check&apos;.  The check is delayed so                    
                </comment>
                <comment line="276">
                    that the initializer may be inspected more closely, using                    
                </comment>
                <comment line="277">
                    &apos;isConstant()&apos;.  Part of fix for 4095568.                    
                </comment>
                <comment line="279">
                    Static inner classes are diagnosed in &apos;SourceClass.&lt;init&gt;&apos;.                    
                </comment>
                <comment line="303">
                    f is not allowed to return an array of void                    
                </comment>
                <comment line="362">
                    arguments can be null if this is an implicit abstract method                    
                </comment>
                <comment line="372">
                    (arg should be an Identifier now)                    
                </comment>
                <comment line="386">
                    same check as for fields, below:                    
                </comment>
                <comment line="392">
                    Fix up the class itself to agree with                    
                </comment>
                <comment line="393">
                    the inner-class member.                    
                </comment>
                <comment line="401">
                    REMIND: set type to error                    
                </comment>
                <comment line="433">
                    Do not check for repeated methods here:  Types are not yet resolved.                    
                </comment>
                <comment line="443">
                    Found a duplicate inner-class member.                    
                </comment>
                <comment line="444">
                    Duplicate local classes are detected in                    
                </comment>
                <comment line="445">
                    &apos;VarDeclarationStatement.checkDeclaration&apos;.                    
                </comment>
                <scope line="256"/>
                <scope line="258"/>
                <scope line="265">
                    <scope line="266"/>
                    <scope line="269">
                        <scope line="270"/>
                    </scope>
                    <scope line="278"/>
                </scope>
                <scope line="284">
                    <scope line="285">
                        <scope line="286"/>
                        <scope line="291"/>
                    </scope>
                    <scope line="296">
                        <scope line="297"/>
                    </scope>
                    <scope line="304"/>
                    <scope line="310"/>
                    <scope line="315"/>
                    <scope line="319"/>
                    <scope line="323">
                        <scope line="324"/>
                        <scope line="328"/>
                        <scope line="332"/>
                        <scope line="336"/>
                        <scope line="340"/>
                    </scope>
                    <scope line="345">
                        <scope line="346"/>
                    </scope>
                    <scope line="350">
                        <scope line="351">
                            <scope line="352"/>
                            <scope line="354"/>
                        </scope>
                    </scope>
                    <declaration name="arguments" type="Vector" line="360"/>
                    <scope line="361">
                        <declaration name="argumentLength" type="int" line="363"/>
                        <declaration name="argTypes" type="Type" line="364"/>
                        <scope line="365">
                            <declaration name="arg" type="Object" line="366"/>
                            <declaration name="where" type="long" line="367"/>
                            <scope line="368"/>
                            <scope line="374"/>
                        </scope>
                    </scope>
                </scope>
                <scope line="379">
                    <scope line="381"/>
                    <scope line="388">
                        <declaration name="c" type="ClassDefinition" line="394"/>
                    </scope>
                </scope>
                <scope line="398">
                    <scope line="399"/>
                    <scope line="405"/>
                    <scope line="409"/>
                    <scope line="413"/>
                    <scope line="417"/>
                    <scope line="421"/>
                    <scope line="427"/>
                </scope>
                <scope line="434">
                    <scope line="436">
                        <scope line="437"/>
                        <scope line="442"/>
                    </scope>
                </scope>
            </method>
            <javadoc line="455">
                Create an environment suitable for checking this class.
                  Make sure the source and imports are set right.
                  Make sure the environment contains no context information.
                  (Actually, throw away env altogether and use toplevelEnv instead.)                
            </javadoc>
            <method name="setupEnv" type="Environment" line="461">
                <params>
                    <param name="env" type="Environment"/>
                </params>
                <comment line="462">
                    In some cases, we go to some trouble to create the &apos;env&apos; argument                    
                </comment>
                <comment line="463">
                    that is discarded.  We should remove the &apos;env&apos; argument entirely                    
                </comment>
                <comment line="464">
                    as well as the vestigial code that supports it.  See comments on                    
                </comment>
                <comment line="465">
                    &apos;newEnvironment&apos; in &apos;checkInternal&apos; below.                    
                </comment>
            </method>
            <javadoc line="469">
                A source class never reports deprecation, since the compiler
                  allows access to deprecated features that are being compiled
                  in the same job.                
            </javadoc>
            <method name="reportDeprecated" type="boolean" line="474">
                <params>
                    <param name="env" type="Environment"/>
                </params>
            </method>
            <javadoc line="478">
                See if the source file of this class is right.                
                <see>
                    ClassDefinition#noteUsedBy                    
                </see>
            </javadoc>
            <method name="noteUsedBy" type="void" line="482">
                <params>
                    <param name="ref" type="ClassDefinition"/>
                    <param name="where" type="long"/>
                    <param name="env" type="Environment"/>
                </params>
                <comment line="483">
                    If this class is not public, watch for cross-file references.                    
                </comment>
                <comment line="490">
                    already checked                    
                </comment>
                <comment line="496">
                    intra-file reference                    
                </comment>
                <declaration name="def" type="ClassDefinition" line="485"/>
                <scope line="486"/>
                <scope line="489"/>
                <scope line="492"/>
                <scope line="495"/>
            </method>
            <javadoc line="501">
                Check this class and all its fields.                
            </javadoc>
            <method name="check" type="void" line="504">
                <params>
                    <param name="env" type="Environment"/>
                </params>
                <comment line="507">
                    An inaccessible class gets checked when the surrounding                    
                </comment>
                <comment line="508">
                    block is checked.                    
                </comment>
                <comment line="509">
                    QUERY: Should this case ever occur?                    
                </comment>
                <comment line="510">
                    What would invoke checking of a local class aside from                    
                </comment>
                <comment line="511">
                    checking the surrounding method body?                    
                </comment>
                <comment line="519">
                    Make sure the outer is checked first.                    
                </comment>
                <comment line="527">
                    drop vset here                    
                </comment>
                <scope line="506"/>
                <scope line="515">
                    <scope line="516"/>
                    <declaration name="vset" type="Vset" line="522"/>
                    <declaration name="ctx" type="Context" line="523"/>
                </scope>
            </method>
            <method name="maybeCheck" type="void" line="532">
                <params>
                    <param name="env" type="Environment"/>
                </params>
                <comment line="534">
                    Check this class now, if it has not yet been checked.                    
                </comment>
                <comment line="535">
                    Cf. Main.compile().  Perhaps this code belongs there somehow.                    
                </comment>
                <comment line="538">
                    Set it first to avoid vicious circularity:                    
                </comment>
                <declaration name="c" type="ClassDeclaration" line="536"/>
                <scope line="537"/>
            </method>
            <method name="checkInternal" type="Vset" line="545">
                <params>
                    <param name="env" type="Environment"/>
                    <param name="ctx" type="Context"/>
                    <param name="vset" type="Vset"/>
                </params>
                <comment line="551">
                    Save context enclosing class for later access                    
                </comment>
                <comment line="552">
                    by &apos;ClassDefinition.resolveName.&apos;                    
                </comment>
                <comment line="555">
                    At present, the call to &apos;newEnvironment&apos; is not needed.                    
                </comment>
                <comment line="556">
                    The incoming environment to &apos;basicCheck&apos; is always passed to                    
                </comment>
                <comment line="557">
                    &apos;setupEnv&apos;, which discards it completely.  This is also the                    
                </comment>
                <comment line="558">
                    only call to &apos;newEnvironment&apos;, which is now apparently dead code.                    
                </comment>
                <comment line="561">
                    Validate access for all inner-class components                    
                </comment>
                <comment line="562">
                    of a qualified name, not just the last one, which                    
                </comment>
                <comment line="563">
                    is checked below.  Yes, this is a dirty hack...                    
                </comment>
                <comment line="564">
                    Much of this code was cribbed from &apos;checkSupers&apos;.                    
                </comment>
                <comment line="565">
                    Part of fix for 4094658.                    
                </comment>
                <comment line="575">
                    Error localization fails here if interfaces were                    
                </comment>
                <comment line="576">
                    elided during error recovery from an invalid one.                    
                </comment>
                <comment line="584">
                    Does the name already exist in an imported package?                    
                </comment>
                <comment line="585">
                    See JLS 8.1 for the precise rules.                    
                </comment>
                <comment line="587">
                    Discard package qualification for the import checks.                    
                </comment>
                <comment line="590">
                    We want this to throw a ClassNotFound exception                    
                </comment>
                <comment line="596">
                    At least one of e.name1 and e.name2 must be different                    
                </comment>
                <comment line="600">
                    we want this to happen                    
                </comment>
                <comment line="603">
                    Make sure that no package with the same fully qualified                    
                </comment>
                <comment line="604">
                    name exists.  This is required by JLS 7.1.  We only need                    
                </comment>
                <comment line="605">
                    to perform this check for top level classes -- it isn&apos;t                    
                </comment>
                <comment line="606">
                    necessary for inner classes.  (bug 4101529)                    
                </comment>
                <comment line="607">
                                        
                </comment>
                <comment line="608">
                    This change has been backed out because, on WIN32, it                    
                </comment>
                <comment line="609">
                    failed to distinguish between java.awt.event and                    
                </comment>
                <comment line="610">
                    java.awt.Event when looking for a directory.  We will                    
                </comment>
                <comment line="611">
                    add this back in later.                    
                </comment>
                <comment line="612">
                                        
                </comment>
                <comment line="613">
                    try {                    
                </comment>
                <comment line="614">
                    if (env.getPackage(nm).exists()) {                    
                </comment>
                <comment line="615">
                    env.error(where, &quot;class.package.conflict&quot;, nm);                    
                </comment>
                <comment line="616">
                    }                    
                </comment>
                <comment line="617">
                    } catch (java.io.IOException ee) {                    
                </comment>
                <comment line="618">
                    env.error(where, &quot;io.exception.package&quot;, nm);                    
                </comment>
                <comment line="619">
                    }                    
                </comment>
                <comment line="621">
                    Make sure it was defined in the right file                    
                </comment>
                <declaration name="nm" type="Identifier" line="546"/>
                <scope line="547"/>
                <declaration name="sup" type="ClassDeclaration" line="566"/>
                <scope line="567">
                    <declaration name="where" type="long" line="568"/>
                </scope>
                <scope line="572">
                    <declaration name="intf" type="ClassDeclaration" line="573"/>
                    <declaration name="where" type="long" line="574"/>
                    <scope line="578"/>
                </scope>
                <scope line="586">
                    <declaration name="simpleName" type="Identifier" line="588"/>
                    <scope line="589">
                        <declaration name="imports" type="Imports" line="591"/>
                        <declaration name="ID" type="Identifier" line="592"/>
                    </scope>
                    <scope line="595">
                        <declaration name="ID" type="Identifier" line="597"/>
                    </scope>
                    <scope line="599"/>
                    <scope line="622"/>
                </scope>
            </method>
            <declaration name="sourceFileChecked" type="boolean" line="631"/>
            <javadoc line="633">
                See if the source file of this class is of the right name.                
            </javadoc>
            <method name="checkSourceFile" type="void" line="636">
                <params>
                    <param name="env" type="Environment"/>
                    <param name="where" type="long"/>
                </params>
                <comment line="637">
                    one error per offending class is sufficient                    
                </comment>
                <declaration name="fname" type="String" line="641"/>
                <declaration name="src" type="String" line="642"/>
                <scope line="643">
                    <scope line="644"/>
                    <scope line="646"/>
                </scope>
            </method>
            <declaration name="supersChecked" type="boolean" line="656"/>
            <javadoc line="658">
                Overrides &apos;ClassDefinition.getSuperClass&apos;.                
            </javadoc>
            <method name="getSuperClass" type="ClassDeclaration" line="662">
                <params>
                    <param name="env" type="Environment"/>
                </params>
                <comment line="664">
                    Superclass may fail to be set because of error recovery,                    
                </comment>
                <comment line="665">
                    so resolve types here only if &apos;checkSupers&apos; has not yet                    
                </comment>
                <comment line="666">
                    completed its checks on the superclass.                    
                </comment>
                <comment line="667">
                    QUERY: Can we eliminate the need to resolve superclasses on demand?                    
                </comment>
                <comment line="668">
                    See comments in &apos;checkSupers&apos; and in &apos;ClassDefinition.getInnerClass&apos;.                    
                </comment>
                <comment line="671">
                    We used to report an error here if the superclass was not                    
                </comment>
                <comment line="672">
                    resolved.  Having moved the call to &apos;checkSupers&apos; from &apos;basicCheck&apos;                    
                </comment>
                <comment line="673">
                    into &apos;resolveTypeStructure&apos;, the errors reported here should have                    
                </comment>
                <comment line="674">
                    already been reported.  Furthermore, error recovery can null out                    
                </comment>
                <comment line="675">
                    the superclass, which would cause a spurious error from the test here.                    
                </comment>
                <scope line="669"/>
            </method>
            <javadoc line="681">
                Check that all superclasses and superinterfaces are defined and
                  well formed.  Among other checks, verify that the inheritance
                  graph is acyclic.  Called from &apos;resolveTypeStructure&apos;.                
            </javadoc>
            <method name="checkSupers" type="void" line="687">
                <params>
                    <param name="env" type="Environment"/>
                </params>
                <comment line="689">
                    *** DEBUG ***                    
                </comment>
                <comment line="698">
                    Interfaces have no superclass.  Superinterfaces                    
                </comment>
                <comment line="699">
                    are checked below, in code shared with the class case.                    
                </comment>
                <comment line="702">
                    Check superclass.                    
                </comment>
                <comment line="703">
                    Call to &apos;getSuperClass(env)&apos; (note argument) attempts                    
                </comment>
                <comment line="704">
                    &apos;resolveTypeStructure&apos; if superclass has not successfully                    
                </comment>
                <comment line="705">
                    been resolved.  Since we have just now called &apos;resolveSupers&apos;                    
                </comment>
                <comment line="706">
                    (see our call in &apos;resolveTypeStructure&apos;), it is not clear                    
                </comment>
                <comment line="707">
                    that this can do any good.  Why not &apos;getSuperClass()&apos; here?                    
                </comment>
                <comment line="714">
                    Resolve superclass and its ancestors.                    
                </comment>
                <comment line="716">
                    Access to the superclass should be checked relative                    
                </comment>
                <comment line="717">
                    to the surrounding context, not as if the reference                    
                </comment>
                <comment line="718">
                    appeared within the class body. Changed &apos;canAccess&apos;                    
                </comment>
                <comment line="719">
                    to &apos;extendsCanAccess&apos; to fix 4087314.                    
                </comment>
                <comment line="722">
                    Might it be a better recovery to let the access go through?                    
                </comment>
                <comment line="726">
                    Might it be a better recovery to let the access go through?                    
                </comment>
                <comment line="740">
                    If we have a valid superclass, check its                    
                </comment>
                <comment line="741">
                    supers as well, and so on up to root class.                    
                </comment>
                <comment line="742">
                    Call to &apos;enclosingClassOf&apos; will raise                    
                </comment>
                <comment line="743">
                    &apos;NullPointerException&apos; if &apos;def&apos; is null,                    
                </comment>
                <comment line="744">
                    so omit this check as error recovery.                    
                </comment>
                <comment line="748">
                    Do we need a similar test for                    
                </comment>
                <comment line="749">
                    interfaces?  See bugid 4038529.                    
                </comment>
                <comment line="754">
                    Since we resolved the superclass and its                    
                </comment>
                <comment line="755">
                    ancestors above, we should not discover                    
                </comment>
                <comment line="756">
                    any unresolved classes on the superclass                    
                </comment>
                <comment line="757">
                    chain.  It should thus be sufficient to                    
                </comment>
                <comment line="758">
                    call &apos;getSuperClass()&apos; (no argument) here.                    
                </comment>
                <comment line="761">
                    Superclass not resolved due to error.                    
                </comment>
                <comment line="768">
                    Error is detected in call to &apos;getClassDefinition&apos;.                    
                </comment>
                <comment line="769">
                    The class may actually exist but be ambiguous.                    
                </comment>
                <comment line="770">
                    Call env.resolve(e.name) to see if it is.                    
                </comment>
                <comment line="771">
                    env.resolve(name) will definitely tell us if the                    
                </comment>
                <comment line="772">
                    class is ambiguous, but may not necessarily tell                    
                </comment>
                <comment line="773">
                    us if the class is not found.                    
                </comment>
                <comment line="774">
                    (part of solution for 4059855)                    
                </comment>
                <comment line="784">
                    fall through                    
                </comment>
                <comment line="788">
                    The break exits this block                    
                </comment>
                <comment line="792">
                    Superclass was null on entry, after call to                    
                </comment>
                <comment line="793">
                    &apos;resolveSupers&apos;.  This should normally not happen,                    
                </comment>
                <comment line="794">
                    as &apos;resolveSupers&apos; sets &apos;superClass&apos; to a non-null                    
                </comment>
                <comment line="795">
                    value for all named classes, except for one special                    
                </comment>
                <comment line="796">
                    case: &apos;java.lang.Object&apos;, which has no superclass.                    
                </comment>
                <comment line="798">
                    checker should have filled it in first                    
                </comment>
                <comment line="806">
                    At this point, if &apos;superClass&apos; is null due to an error                    
                </comment>
                <comment line="807">
                    in the user program, a message should have been issued.                    
                </comment>
                <comment line="810">
                    Check interfaces                    
                </comment>
                <comment line="820">
                    Resolve superinterface and its ancestors.                    
                </comment>
                <comment line="822">
                    Check superinterface access in the correct context.                    
                </comment>
                <comment line="823">
                    Changed &apos;canAccess&apos; to &apos;extendsCanAccess&apos; to fix 4087314.                    
                </comment>
                <comment line="832">
                    Interface is OK, leave it in the interface list.                    
                </comment>
                <comment line="836">
                    The interface may actually exist but be ambiguous.                    
                </comment>
                <comment line="837">
                    Call env.resolve(e.name) to see if it is.                    
                </comment>
                <comment line="838">
                    env.resolve(name) will definitely tell us if the                    
                </comment>
                <comment line="839">
                    interface is ambiguous, but may not necessarily tell                    
                </comment>
                <comment line="840">
                    us if the interface is not found.                    
                </comment>
                <comment line="841">
                    (part of solution for 4059855)                    
                </comment>
                <comment line="851">
                    fall through                    
                </comment>
                <comment line="855">
                    The break exits this block                    
                </comment>
                <comment line="857">
                    Remove this interface from the list of interfaces                    
                </comment>
                <comment line="858">
                    as recovery from an error.                    
                </comment>
                <scope line="694">
                    <scope line="695">
                        <declaration name="nm" type="Identifier" line="696"/>
                    </scope>
                </scope>
                <scope line="701">
                    <scope line="708">
                        <declaration name="where" type="long" line="709"/>
                        <scope line="711">
                            <declaration name="def" type="ClassDefinition" line="712"/>
                            <scope line="720"/>
                            <scope line="724"/>
                            <scope line="728"/>
                            <scope line="731"/>
                            <scope line="734"/>
                            <scope line="737"/>
                            <scope line="739">
                                <declaration name="sup" type="ClassDefinition" line="745"/>
                                <scope line="746">
                                    <scope line="747"/>
                                    <declaration name="s" type="ClassDeclaration" line="759"/>
                                    <scope line="760"/>
                                </scope>
                            </scope>
                        </scope>
                        <scope line="767">
                            <scope line="775">
                                <scope line="776"/>
                                <scope line="778"/>
                                <scope line="783"/>
                            </scope>
                        </scope>
                    </scope>
                    <scope line="791">
                        <scope line="797"/>
                        <scope line="800"/>
                    </scope>
                </scope>
                <scope line="811">
                    <declaration name="intf" type="ClassDeclaration" line="812"/>
                    <declaration name="where" type="long" line="813"/>
                    <scope line="815"/>
                    <scope line="818">
                        <declaration name="def" type="ClassDefinition" line="819"/>
                        <scope line="824"/>
                        <scope line="826"/>
                        <scope line="828"/>
                        <scope line="830"/>
                    </scope>
                    <scope line="835">
                        <scope line="842">
                            <scope line="843"/>
                            <scope line="845"/>
                            <scope line="850"/>
                        </scope>
                    </scope>
                    <declaration name="newInterfaces" type="ClassDeclaration" line="859"/>
                </scope>
            </method>
            <javadoc line="870">
                Check all of the members of this class.
                  &lt;p&gt;
                  Inner classes are checked in the following way.  Any class which
                  is immediately contained in a block (anonymous and local classes)
                  is checked along with its containing method; see the
                  SourceMember.check() method for more information.  Member classes
                  of this class are checked immediately after this class, unless this
                  class is insideLocal(), in which case, they are checked with the
                  rest of the members.                
            </javadoc>
            <method name="checkMembers" type="Vset" line="882">
                <params>
                    <param name="env" type="Environment"/>
                    <param name="ctx" type="Context"/>
                    <param name="vset" type="Vset"/>
                </params>
                <comment line="884">
                    bail out if there were any errors                    
                </comment>
                <comment line="889">
                    Make sure that all of our member classes have been                    
                </comment>
                <comment line="890">
                    basicCheck&apos;ed before we check the rest of our members.                    
                </comment>
                <comment line="891">
                    If our member classes haven&apos;t been basicCheck&apos;ed, then they                    
                </comment>
                <comment line="892">
                    may not have &lt;init&gt; methods.  It is important that they                    
                </comment>
                <comment line="893">
                    have &lt;init&gt; methods so we can process NewInstanceExpressions                    
                </comment>
                <comment line="894">
                    correctly.  This problem didn&apos;t occur before 1.2beta1.                    
                </comment>
                <comment line="895">
                    This is a fix for bug 4082816.                    
                </comment>
                <comment line="899">
                    System.out.println(&quot;Considering &quot; + f + &quot; in &quot; + this);                    
                </comment>
                <comment line="911">
                    This class should be abstract if there are any abstract methods                    
                </comment>
                <comment line="912">
                    in our parent classes and interfaces which we do not override.                    
                </comment>
                <comment line="913">
                    There are odd cases when, even though we cannot access some                    
                </comment>
                <comment line="914">
                    abstract method from our superclass, that abstract method can                    
                </comment>
                <comment line="915">
                    still force this class to be abstract.  See the discussion in                    
                </comment>
                <comment line="916">
                    bug id 1240831.                    
                </comment>
                <comment line="918">
                    Set the class abstract.                    
                </comment>
                <comment line="921">
                    Tell the user which methods force this class to be abstract.                    
                </comment>
                <comment line="923">
                    First list all of the &quot;unimplementable&quot; abstract methods.                    
                </comment>
                <comment line="927">
                    We couldn&apos;t override this method even if we                    
                </comment>
                <comment line="928">
                    wanted to.  Try to make the error message                    
                </comment>
                <comment line="929">
                    as non-confusing as possible.                    
                </comment>
                <comment line="935">
                    Now list all of the traditional abstract methods.                    
                </comment>
                <comment line="938">
                    For each method, check if it is abstract.  If it is,                    
                </comment>
                <comment line="939">
                    output an appropriate error message.                    
                </comment>
                <comment line="949">
                    Check the instance variables in a pre-pass before any constructors.                    
                </comment>
                <comment line="950">
                    This lets constructors &quot;in-line&quot; any initializers directly.                    
                </comment>
                <comment line="951">
                    It also lets us do some definite assignment checks on variables.                    
                </comment>
                <comment line="956">
                    Do definite assignment checking on blank finals.                    
                </comment>
                <comment line="957">
                    Other variables do not need such checks.  The simple textual                    
                </comment>
                <comment line="958">
                    ordering constraints implemented by MemberDefinition.canReach()                    
                </comment>
                <comment line="959">
                    are necessary and sufficient for the other variables.                    
                </comment>
                <comment line="960">
                    Note that within non-static code, all statics are always                    
                </comment>
                <comment line="961">
                    definitely assigned, and vice-versa.                    
                </comment>
                <comment line="965">
                    The following allocates a LocalMember object as a proxy                    
                </comment>
                <comment line="966">
                    to represent the field.                    
                </comment>
                <comment line="978">
                    For instance variable checks, use a context with a &quot;this&quot; parameter.                    
                </comment>
                <comment line="984">
                    Do all the initializers in order, checking the definite                    
                </comment>
                <comment line="985">
                    assignment of blank finals.  Separate static from non-static.                    
                </comment>
                <comment line="1003">
                    Check the rest of the field definitions.                    
                </comment>
                <comment line="1004">
                    (Note:  Re-checking a field is a no-op.)                    
                </comment>
                <comment line="1009">
                    When checking a constructor, an explicit call to                    
                </comment>
                <comment line="1010">
                    &apos;this(...)&apos; makes all blank finals definitely assigned.                    
                </comment>
                <comment line="1011">
                    See &apos;MethodExpression.checkValue&apos;.                    
                </comment>
                <comment line="1013">
                    May issue multiple messages for the same variable!!                    
                </comment>
                <comment line="1015">
                    (drop vsCon here)                    
                </comment>
                <comment line="1018">
                    (drop vsFld here)                    
                </comment>
                <comment line="1025">
                    Must mark class as checked before visiting inner classes,                    
                </comment>
                <comment line="1026">
                    as they may in turn request checking of the current class                    
                </comment>
                <comment line="1027">
                    as an outer class.  Fix for bug id 4056774.                    
                </comment>
                <comment line="1030">
                    Also check other classes in the same nest.                    
                </comment>
                <comment line="1031">
                    All checking of this nest must be finished before any                    
                </comment>
                <comment line="1032">
                    of its classes emit bytecode.                    
                </comment>
                <comment line="1033">
                    Otherwise, the inner classes might not have a chance to                    
                </comment>
                <comment line="1034">
                    add access or class literal fields to the outer class.                    
                </comment>
                <comment line="1045">
                    Note:  Since inner classes cannot set up-level variables,                    
                </comment>
                <comment line="1046">
                    the returned vset is always equal to the passed-in vset.                    
                </comment>
                <comment line="1047">
                    Still, we&apos;ll return it for the sake of regularity.                    
                </comment>
                <scope line="885"/>
                <scope line="897">
                    <scope line="898">
                        <declaration name="cdef" type="SourceClass" line="900"/>
                        <scope line="901"/>
                    </scope>
                </scope>
                <scope line="907"/>
                <scope line="917">
                    <declaration name="iter" type="Iterator" line="924"/>
                    <scope line="925">
                        <declaration name="method" type="MemberDefinition" line="926"/>
                    </scope>
                    <scope line="937">
                        <declaration name="method" type="MemberDefinition" line="940"/>
                        <scope line="941"/>
                    </scope>
                </scope>
                <declaration name="ctxInit" type="Context" line="952"/>
                <declaration name="vsInst" type="Vset" line="953"/>
                <declaration name="vsClass" type="Vset" line="954"/>
                <scope line="963">
                    <scope line="964">
                        <declaration name="number" type="int" line="967"/>
                        <scope line="968"/>
                        <scope line="971"/>
                    </scope>
                </scope>
                <declaration name="ctxInst" type="Context" line="979"/>
                <declaration name="thisArg" type="LocalMember" line="980"/>
                <declaration name="thisNumber" type="int" line="981"/>
                <scope line="987">
                    <scope line="988">
                        <scope line="989">
                            <scope line="990"/>
                            <scope line="992"/>
                        </scope>
                    </scope>
                    <scope line="996"/>
                </scope>
                <scope line="1006">
                    <scope line="1007">
                        <scope line="1008">
                            <declaration name="vsCon" type="Vset" line="1012"/>
                        </scope>
                        <scope line="1016">
                            <declaration name="vsFld" type="Vset" line="1017"/>
                        </scope>
                    </scope>
                    <scope line="1020"/>
                </scope>
                <scope line="1036">
                    <scope line="1037">
                        <declaration name="cdef" type="SourceClass" line="1038"/>
                        <scope line="1039"/>
                    </scope>
                </scope>
            </method>
            <javadoc line="1051">
                Make sure all my blank finals exist now.                
            </javadoc>
            <method name="checkBlankFinals" type="void" line="1054">
                <params>
                    <param name="env" type="Environment"/>
                    <param name="ctxInit" type="Context"/>
                    <param name="vset" type="Vset"/>
                    <param name="isStatic" type="boolean"/>
                </params>
                <scope line="1055">
                    <scope line="1056">
                        <declaration name="ff" type="MemberDefinition" line="1057"/>
                        <scope line="1060"/>
                    </scope>
                </scope>
            </method>
            <declaration name="basicChecking" type="boolean" line="1068"/>
            <javadoc line="1068">
                Check this class has its superclass and its interfaces.  Also
                  force it to have an &lt;init&gt; method (if it doesn&apos;t already have one)
                  and to have all the abstract methods of its parents.                
            </javadoc>
            <declaration name="basicCheckDone" type="boolean" line="1074"/>
            <method name="basicCheck" type="void" line="1075">
                <params>
                    <param name="env" type="Environment"/>
                </params>
                <comment line="1099">
                    Check the existence of the superclass and all interfaces.                    
                </comment>
                <comment line="1100">
                    Also responsible for breaking inheritance cycles.  This call                    
                </comment>
                <comment line="1101">
                    has been moved to &apos;resolveTypeStructure&apos;, just after the call                    
                </comment>
                <comment line="1102">
                    to &apos;resolveSupers&apos;, as inheritance cycles must be broken before                    
                </comment>
                <comment line="1103">
                    resolving types within the members.  Fixes 4073739.                    
                </comment>
                <comment line="1104">
                    checkSupers(env);                    
                </comment>
                <comment line="1108">
                    Add implicit &lt;init&gt; method, if necessary.                    
                </comment>
                <comment line="1109">
                    QUERY:  What keeps us from adding an implicit constructor                    
                </comment>
                <comment line="1110">
                    when the user explicitly declares one?  Is it truly guaranteed                    
                </comment>
                <comment line="1111">
                    that the declaration for such an explicit constructor will have                    
                </comment>
                <comment line="1112">
                    been processed by the time we arrive here?  In general, &apos;basicCheck&apos;                    
                </comment>
                <comment line="1113">
                    is called very early, prior to the normal member checking phase.                    
                </comment>
                <comment line="1118">
                    Default constructors inherit the access modifiers of their                    
                </comment>
                <comment line="1119">
                    class.  For non-inner classes, this follows from JLS 8.6.7,                    
                </comment>
                <comment line="1120">
                    as the only possible modifier is &apos;public&apos;.  For the sake of                    
                </comment>
                <comment line="1121">
                    robustness in the presence of errors, we ignore any other                    
                </comment>
                <comment line="1122">
                    modifiers.  For inner classes, the rule needs to be extended                    
                </comment>
                <comment line="1123">
                    in some way to account for the possibility of private and                    
                </comment>
                <comment line="1124">
                    protected classes.  We make the &apos;obvious&apos; extension, however,                    
                </comment>
                <comment line="1125">
                    the inner classes spec is silent on this issue, and a definitive                    
                </comment>
                <comment line="1126">
                    resolution is needed.  See bugid 4087421.                    
                </comment>
                <comment line="1127">
                    WORKAROUND: A private constructor might need an access method,                    
                </comment>
                <comment line="1128">
                    but it is not possible to create one due to a restriction in                    
                </comment>
                <comment line="1129">
                    the verifier.  (This is a known problem -- see 4015397.)                    
                </comment>
                <comment line="1130">
                    We therefore do not inherit the &apos;private&apos; modifier from the class,                    
                </comment>
                <comment line="1131">
                    allowing the default constructor to be package private.  This                    
                </comment>
                <comment line="1132">
                    workaround can be observed via reflection, but is otherwise                    
                </comment>
                <comment line="1133">
                    undetectable, as the constructor is always accessible within                    
                </comment>
                <comment line="1134">
                    the class in which its containing (private) class appears.                    
                </comment>
                <comment line="1143">
                    Only do the inheritance/override checks if they are turned on.                    
                </comment>
                <comment line="1144">
                    The idea here is that they will be done in javac, but not                    
                </comment>
                <comment line="1145">
                    in javadoc.  See the comment for turnOffChecks(), above.                    
                </comment>
                <comment line="1148">
                    Verify the compatibility of all inherited method definitions                    
                </comment>
                <comment line="1149">
                    by collecting all of our inheritable methods.                    
                </comment>
                <scope line="1081"/>
                <declaration name="imports" type="Imports" line="1092"/>
                <scope line="1093"/>
                <scope line="1106">
                    <scope line="1114">
                        <declaration name="code" type="Node" line="1115"/>
                        <declaration name="t" type="Type" line="1116"/>
                        <declaration name="accessModifiers" type="int" line="1135"/>
                    </scope>
                </scope>
                <scope line="1146"/>
            </method>
            <javadoc line="1158">
                Add a group of methods to this class as miranda methods.
                  For a definition of Miranda methods, see the comment above the
                  method addMirandaMethods() in the file
                  sun/tools/java/ClassDeclaration.java                
            </javadoc>
            <method name="addMirandaMethods" type="void" line="1166">
                <params>
                    <param name="env" type="Environment"/>
                    <param name="mirandas" type="Iterator"/>
                </params>
                <comment line="1174">
                    System.out.println(&quot;adding miranda method &quot; + newMethod +                    
                </comment>
                <comment line="1175">
                    &quot; to &quot; + this);                    
                </comment>
                <scope line="1168">
                    <declaration name="method" type="MemberDefinition" line="1169"/>
                </scope>
            </method>
            <declaration name="resolving" type="boolean" line="1179"/>
            <javadoc line="1179">
                &lt;em&gt;After parsing is complete&lt;/em&gt;, resolve all names
                  except those inside method bodies or initializers.
                  In particular, this is the point at which we find out what
                  kinds of variables and methods there are in the classes,
                  and therefore what is each class&apos;s interface to the world.
                  &lt;p&gt;
                  Also perform certain other transformations, such as inserting
                  &quot;this$C&quot; arguments into constructors, and reorganizing structure
                  to flatten qualified member names.
                  &lt;p&gt;
                  Do not perform type-based or name-based consistency checks
                  or normalizations (such as default nullary constructors),
                  and do not attempt to compile code against this class,
                  until after this phase.                
            </javadoc>
            <method name="resolveTypeStructure" type="void" line="1198">
                <params>
                    <param name="env" type="Environment"/>
                </params>
                <comment line="1203">
                    Resolve immediately enclosing type, which in turn                    
                </comment>
                <comment line="1204">
                    forces resolution of all enclosing type declarations.                    
                </comment>
                <comment line="1208">
                    Do the outer class first, always.                    
                </comment>
                <comment line="1210">
                    (Note:  this.resolved is probably true at this point.)                    
                </comment>
                <comment line="1213">
                    Punt if we&apos;ve already resolved this class, or are currently                    
                </comment>
                <comment line="1214">
                    in the process of doing so.                    
                </comment>
                <comment line="1221">
                    Previously, &apos;resolved&apos; was set here, and served to prevent                    
                </comment>
                <comment line="1222">
                    duplicate resolutions here as well as its function in                    
                </comment>
                <comment line="1223">
                    &apos;ClassDefinition.addMember&apos;.  Now, &apos;resolving&apos; serves the                    
                </comment>
                <comment line="1224">
                    former purpose, distinct from that of &apos;resolved&apos;.                    
                </comment>
                <comment line="1232">
                    Resolve superclass names to class declarations                    
                </comment>
                <comment line="1233">
                    for the immediate superclass and superinterfaces.                    
                </comment>
                <comment line="1236">
                    Check all ancestor superclasses for various                    
                </comment>
                <comment line="1237">
                    errors, verifying definition of all superclasses                    
                </comment>
                <comment line="1238">
                    and superinterfaces.  Also breaks inheritance cycles.                    
                </comment>
                <comment line="1239">
                    Calls &apos;resolveTypeStructure&apos; recursively for ancestors                    
                </comment>
                <comment line="1240">
                    This call used to appear in &apos;basicCheck&apos;, but was not                    
                </comment>
                <comment line="1241">
                    performed early enough.  Most of the compiler will barf                    
                </comment>
                <comment line="1242">
                    on inheritance cycles!                    
                </comment>
                <comment line="1246">
                    Undefined classes should be reported by &apos;checkSupers&apos;.                    
                </comment>
                <comment line="1258">
                    Mark class as resolved.  If new members are subsequently                    
                </comment>
                <comment line="1259">
                    added to the class, they will be resolved at that time.                    
                </comment>
                <comment line="1260">
                    See &apos;ClassDefinition.addMember&apos;.  Previously, this variable was                    
                </comment>
                <comment line="1261">
                    set prior to the calls to &apos;checkSupers&apos; and &apos;resolveTypeStructure&apos;                    
                </comment>
                <comment line="1262">
                    (which may engender further calls to &apos;checkSupers&apos;).  This could                    
                </comment>
                <comment line="1263">
                    lead to duplicate resolution of implicit constructors, as the call to                    
                </comment>
                <comment line="1264">
                    &apos;basicCheck&apos; from &apos;checkSupers&apos; could add the constructor while                    
                </comment>
                <comment line="1265">
                    its class is marked resolved, and thus would resolve the constructor,                    
                </comment>
                <comment line="1266">
                    believing it to be a &quot;late addition&quot;.  It would then be resolved                    
                </comment>
                <comment line="1267">
                    redundantly during the normal traversal of the members, which                    
                </comment>
                <comment line="1268">
                    immediately follows in the code above.                    
                </comment>
                <comment line="1271">
                    Now we have enough information to detect method repeats.                    
                </comment>
                <declaration name="oc" type="ClassDefinition" line="1205"/>
                <scope line="1207"/>
                <scope line="1215"/>
                <scope line="1243"/>
                <scope line="1245"/>
                <scope line="1251"/>
                <scope line="1273">
                    <scope line="1276">
                        <scope line="1278"/>
                        <scope line="1282"/>
                    </scope>
                </scope>
            </method>
            <method name="resolveSupers" type="void" line="1292">
                <params>
                    <param name="env" type="Environment"/>
                </params>
                <comment line="1295">
                    Find the super class                    
                </comment>
                <comment line="1298">
                    Special-case java.lang.Object here (not in the parser).                    
                </comment>
                <comment line="1299">
                    In all other cases, if we have a valid &apos;superClassId&apos;,                    
                </comment>
                <comment line="1300">
                    we return with a valid and non-null &apos;superClass&apos; value.                    
                </comment>
                <comment line="1307">
                    Find interfaces                    
                </comment>
                <scope line="1296">
                    <scope line="1302"/>
                </scope>
                <scope line="1308">
                    <scope line="1310">
                        <scope line="1312">
                            <scope line="1313">
                                <declaration name="id" type="Identifier" line="1314"/>
                                <declaration name="where" type="long" line="1315"/>
                            </scope>
                        </scope>
                    </scope>
                </scope>
            </method>
            <method name="resolveSuper" type="ClassDeclaration" line="1325">
                <params>
                    <param name="env" type="Environment"/>
                    <param name="t" type="IdentifierToken"/>
                </params>
                <comment line="1334">
                    Result is never null, as a new &apos;ClassDeclaration&apos; is                    
                </comment>
                <comment line="1335">
                    created if one with the given name does not exist.                    
                </comment>
                <declaration name="name" type="Identifier" line="1326"/>
                <declaration name="result" type="ClassDeclaration" line="1333"/>
            </method>
            <javadoc line="1340">
                During the type-checking of an outer method body or initializer,
                  this routine is called to check a local class body
                  in the proper context.                
                <param>
                    sup     the named super class or interface (if anonymous)                    
                </param>
                <param>
                    args    the actual arguments (if anonymous)                    
                </param>
            </javadoc>
            <method name="checkLocalClass" type="Vset" line="1350">
                <params>
                    <param name="env" type="Environment"/>
                    <param name="ctx" type="Context"/>
                    <param name="vset" type="Vset"/>
                    <param name="sup" type="ClassDefinition"/>
                    <param name="args" type="Expression"/>
                    <param name="argTypes" type="Type"/>
                </params>
                <comment line="1360">
                    Run the checks in the lexical context from the outer class.                    
                </comment>
                <comment line="1363">
                    This is now done by &apos;checkInternal&apos; via its call to &apos;checkMembers&apos;.                    
                </comment>
                <comment line="1364">
                    getClassDeclaration().setDefinition(this, CS_CHECKED);                    
                </comment>
                <scope line="1353"/>
                <scope line="1356"/>
            </method>
            <javadoc line="1369">
                As with checkLocalClass, run the inline phase for a local class.                
            </javadoc>
            <method name="inlineLocalClass" type="void" line="1372">
                <params>
                    <param name="env" type="Environment"/>
                </params>
                <comment line="1376">
                    inlined inside of constructors only                    
                </comment>
                <comment line="1386">
                    add more constructor arguments for uplevel references                    
                </comment>
                <comment line="1390">
                    ((SourceMember)f).addUplevelArguments(false);                    
                </comment>
                <scope line="1374">
                    <scope line="1375"/>
                    <scope line="1378"/>
                    <scope line="1380"/>
                </scope>
                <scope line="1384">
                    <scope line="1388">
                        <scope line="1389"/>
                    </scope>
                </scope>
            </method>
            <declaration name="inlinedLocalClass" type="boolean" line="1396"/>
            <javadoc line="1398">
                Check a class which is inside a local class, but is not itself local.                
            </javadoc>
            <method name="checkInsideClass" type="Vset" line="1402">
                <params>
                    <param name="env" type="Environment"/>
                    <param name="ctx" type="Context"/>
                    <param name="vset" type="Vset"/>
                </params>
                <scope line="1403"/>
            </method>
            <javadoc line="1409">
                Just before checking an anonymous class, decide its true
                  inheritance, and build its (sole, implicit) constructor.                
            </javadoc>
            <method name="resolveAnonymousStructure" type="void" line="1416">
                <params>
                    <param name="env" type="Environment"/>
                    <param name="sup" type="ClassDefinition"/>
                    <param name="args" type="Expression"/>
                    <param name="argTypes" type="Type"/>
                </params>
                <comment line="1421">
                    Decide now on the superclass.                    
                </comment>
                <comment line="1423">
                    This check has been removed as part of the fix for 4055017.                    
                </comment>
                <comment line="1424">
                    In the anonymous class created to hold the &apos;class$&apos; method                    
                </comment>
                <comment line="1425">
                    of an interface, &apos;superClassId&apos; refers to &apos;java.lang.Object&apos;.                    
                </comment>
                <comment line="1426">
                    ---------------------
                    if (!(superClass == null &amp;&amp; superClassId.getName() == idNull)) {
                    throw new CompilerError(&quot;superclass &quot;+superClass);
                    }                    
                </comment>
                <comment line="1433">
                    allow an interface in the &quot;super class&quot; position                    
                </comment>
                <comment line="1455">
                    Synthesize an appropriate constructor.                    
                </comment>
                <comment line="1480">
                    ISSUE: make M_PRIVATE, with wrapper?                    
                </comment>
                <scope line="1432">
                    <declaration name="ni" type="int" line="1434"/>
                    <declaration name="i1" type="ClassDeclaration" line="1435"/>
                    <scope line="1436">
                        <scope line="1438">
                            <declaration name="id1" type="IdentifierToken" line="1439"/>
                        </scope>
                    </scope>
                </scope>
                <scope line="1451"/>
                <declaration name="t" type="Type" line="1456"/>
                <declaration name="names" type="IdentifierToken" line="1457"/>
                <scope line="1458"/>
                <declaration name="outerArg" type="int" line="1462"/>
                <declaration name="superArgs" type="Expression" line="1463"/>
                <scope line="1464"/>
                <declaration name="where" type="long" line="1467"/>
                <declaration name="superExp" type="Expression" line="1468"/>
                <scope line="1469"/>
                <scope line="1471"/>
                <declaration name="superCall" type="Expression" line="1475"/>
                <declaration name="body" type="Statement" line="1478"/>
                <declaration name="code" type="Node" line="1479"/>
                <declaration name="mod" type="int" line="1480"/>
            </method>
            <declaration name="classModifierBits" type="int" line="1485"/>
            <javadoc line="1485">
                Convert class modifiers to a string for diagnostic purposes.
                  Accepts modifiers applicable to inner classes and that appear
                  in the InnerClasses attribute only, as well as those that may
                  appear in the class modifier proper.                
            </javadoc>
            <declaration name="classModifierNames" type="String" line="1497"/>
            <method name="classModifierString" type="String" line="1502">
                <params>
                    <param name="mods" type="int"/>
                </params>
                <declaration name="s" type="String" line="1503"/>
                <scope line="1504">
                    <scope line="1505"/>
                </scope>
                <scope line="1510"/>
            </method>
            <javadoc line="1516">
                Find or create an access method for a private member,
                  or return null if this is not possible.                
            </javadoc>
            <method name="getAccessMember" type="MemberDefinition" line="1521">
                <params>
                    <param name="env" type="Environment"/>
                    <param name="ctx" type="Context"/>
                    <param name="field" type="MemberDefinition"/>
                    <param name="isSuper" type="boolean"/>
                </params>
            </method>
            <method name="getUpdateMember" type="MemberDefinition" line="1526">
                <params>
                    <param name="env" type="Environment"/>
                    <param name="ctx" type="Context"/>
                    <param name="field" type="MemberDefinition"/>
                    <param name="isSuper" type="boolean"/>
                </params>
                <scope line="1527"/>
            </method>
            <method name="getAccessMember" type="MemberDefinition" line="1536">
                <params>
                    <param name="env" type="Environment"/>
                    <param name="ctx" type="Context"/>
                    <param name="field" type="MemberDefinition"/>
                    <param name="isUpdate" type="boolean"/>
                    <param name="isSuper" type="boolean"/>
                </params>
                <comment line="1538">
                    The &apos;isSuper&apos; argument is really only meaningful when the                    
                </comment>
                <comment line="1539">
                    target member is a method, in which case an &apos;invokespecial&apos;                    
                </comment>
                <comment line="1540">
                    is needed.  For fields, &apos;getfield&apos; and &apos;putfield&apos; instructions                    
                </comment>
                <comment line="1541">
                    are generated in either case, and &apos;isSuper&apos; currently plays                    
                </comment>
                <comment line="1542">
                    no essential role.  Nonetheless, we maintain the distinction                    
                </comment>
                <comment line="1543">
                    consistently for the time being.                    
                </comment>
                <comment line="1548">
                    Find pre-existing access method.                    
                </comment>
                <comment line="1549">
                    In the case of a field access method, we only look for the getter.                    
                </comment>
                <comment line="1550">
                    A getter is always created whenever a setter is.                    
                </comment>
                <comment line="1551">
                    QUERY: Why doesn&apos;t the &apos;MemberDefinition&apos; object for the field                    
                </comment>
                <comment line="1552">
                    itself just have fields for its getter and setter?                    
                </comment>
                <comment line="1559">
                    Distinguish the getter and the setter by the number of                    
                </comment>
                <comment line="1560">
                    arguments.                    
                </comment>
                <comment line="1562">
                    This was (nargs == (isStatic ? 0 : 1) + (isUpdate ? 1 : 0))                    
                </comment>
                <comment line="1563">
                    in order to find a setter as well as a getter.  This caused                    
                </comment>
                <comment line="1564">
                    allocation of multiple getters.                    
                </comment>
                <comment line="1581">
                    must find or create the getter before creating the setter                    
                </comment>
                <comment line="1585">
                    If we arrive here, we are creating a new access member.                    
                </comment>
                <comment line="1591">
                    For a constructor, we use the same name as for all                    
                </comment>
                <comment line="1592">
                    constructors (&quot;&lt;init&gt;&quot;), but add a distinguishing                    
                </comment>
                <comment line="1593">
                    argument of an otherwise unused &quot;dummy&quot; type.                    
                </comment>
                <comment line="1595">
                    Get the dummy class, creating it if necessary.                    
                </comment>
                <comment line="1599">
                    Create dummy class.                    
                </comment>
                <comment line="1605">
                    If an interface has a public inner class, the dummy class for                    
                </comment>
                <comment line="1606">
                    the constructor must always be accessible. Fix for 4221648.                    
                </comment>
                <comment line="1615">
                    Check the class.                    
                </comment>
                <comment line="1616">
                    It is likely that a full check is not really necessary,                    
                </comment>
                <comment line="1617">
                    but it is essential that the class be marked as parsed.                    
                </comment>
                <comment line="1627">
                    Get class type.                    
                </comment>
                <comment line="1632">
                    Otherwise, we use the name &quot;access$N&quot;, for the                    
                </comment>
                <comment line="1633">
                    smallest value of N &gt;= 0 yielding an unused name.                    
                </comment>
                <comment line="1650">
                    nullary getter                    
                </comment>
                <comment line="1654">
                    unary setter                    
                </comment>
                <comment line="1657">
                    Since constructors are never static, we don&apos;t                    
                </comment>
                <comment line="1658">
                    have to worry about a dummy argument here.                    
                </comment>
                <comment line="1662">
                    All access methods for non-static members get an explicit                    
                </comment>
                <comment line="1663">
                    &apos;this&apos; pointer as an extra argument, as the access methods                    
                </comment>
                <comment line="1664">
                    themselves must be static. EXCEPTION: Access methods for                    
                </comment>
                <comment line="1665">
                    constructors are non-static.                    
                </comment>
                <comment line="1671">
                    nullary getter                    
                </comment>
                <comment line="1675">
                    unary setter                    
                </comment>
                <comment line="1678">
                    Target is a method, possibly a constructor.                    
                </comment>
                <comment line="1682">
                    Access method is a constructor.                    
                </comment>
                <comment line="1683">
                    Requires a dummy argument.                    
                </comment>
                <comment line="1687">
                    Outer instance link must be the first argument.                    
                </comment>
                <comment line="1688">
                    The following is a sanity check that will catch                    
                </comment>
                <comment line="1689">
                    most cases in which in this requirement is violated.                    
                </comment>
                <comment line="1693">
                    Strip outer &apos;this&apos; argument.                    
                </comment>
                <comment line="1694">
                    It will be added back when the access method is checked.                    
                </comment>
                <comment line="1701">
                    There is no outer instance.                    
                </comment>
                <comment line="1709">
                    Access method is static.                    
                </comment>
                <comment line="1710">
                    Requires an explicit &apos;this&apos; argument.                    
                </comment>
                <comment line="1739">
                    Constructor access method is non-static, so                    
                </comment>
                <comment line="1740">
                    &apos;this&apos; works normally.                    
                </comment>
                <comment line="1742">
                    Remove dummy argument, as it is not                    
                </comment>
                <comment line="1743">
                    passed to the target method.                    
                </comment>
                <comment line="1749">
                    Non-constructor access method is static, so                    
                </comment>
                <comment line="1750">
                    we use the first argument as &apos;this&apos;.                    
                </comment>
                <comment line="1752">
                    Remove first argument.                    
                </comment>
                <comment line="1767">
                    If true, &apos;isSuper&apos; forces a non-virtual call.                    
                </comment>
                <comment line="1780">
                    Access methods are now static (constructors excepted), and no longer final.                    
                </comment>
                <comment line="1781">
                    This change was mandated by the interaction of the access method                    
                </comment>
                <comment line="1782">
                    naming conventions and the restriction against overriding final                    
                </comment>
                <comment line="1783">
                    methods.                    
                </comment>
                <comment line="1789">
                    Create the synthetic method within the class in which the referenced                    
                </comment>
                <comment line="1790">
                    private member appears.  The &apos;env&apos; argument to &apos;makeMemberDefinition&apos;                    
                </comment>
                <comment line="1791">
                    is suspect because it represents the environment at the point at                    
                </comment>
                <comment line="1792">
                    which a reference takes place, while it should represent the                    
                </comment>
                <comment line="1793">
                    environment in which the definition of the synthetic method appears.                    
                </comment>
                <comment line="1794">
                    We get away with this because &apos;env&apos; is used only to access globals                    
                </comment>
                <comment line="1795">
                    such as &apos;Environment.error&apos;, and also as an argument to                    
                </comment>
                <comment line="1796">
                    &apos;resolveTypeStructure&apos;, which immediately discards it using                    
                </comment>
                <comment line="1797">
                    &apos;setupEnv&apos;. Apparently, the current definition of &apos;setupEnv&apos;                    
                </comment>
                <comment line="1798">
                    represents a design change that has not been thoroughly propagated.                    
                </comment>
                <comment line="1799">
                    An access method is declared with same list of exceptions as its                    
                </comment>
                <comment line="1800">
                    target. As the exceptions are simply listed by name, the correctness                    
                </comment>
                <comment line="1801">
                    of this approach requires that the access method be checked                    
                </comment>
                <comment line="1802">
                    (name-resolved) in the same context as its target method  This                    
                </comment>
                <comment line="1803">
                    should always be the case.                    
                </comment>
                <comment line="1808">
                    Just to be safe, copy over the name-resolved exceptions from the                    
                </comment>
                <comment line="1809">
                    target so that the context in which the access method is checked                    
                </comment>
                <comment line="1810">
                    doesn&apos;t matter.                    
                </comment>
                <comment line="1819">
                    The call to &apos;check&apos; is not needed, as the access method will be                    
                </comment>
                <comment line="1820">
                    checked by the containing class after it is added.  This is the                    
                </comment>
                <comment line="1821">
                    idiom followed in the implementation of class literals. (See                    
                </comment>
                <comment line="1822">
                    &apos;FieldExpression.java&apos;.) In any case, the context is wrong in the                    
                </comment>
                <comment line="1823">
                    call below.  The access method must be checked in the context in                    
                </comment>
                <comment line="1824">
                    which it is declared, i.e., the class containing the referenced                    
                </comment>
                <comment line="1825">
                    private member, not the (inner) class in which the original member                    
                </comment>
                <comment line="1826">
                    reference occurs.                    
                </comment>
                <comment line="1827">
                                        
                </comment>
                <comment line="1828">
                    try {                    
                </comment>
                <comment line="1829">
                    newf.check(env, ctx, new Vset());                    
                </comment>
                <comment line="1830">
                    } catch (ClassNotFound ee) {                    
                </comment>
                <comment line="1831">
                    env.error(where, &quot;class.not.found&quot;, ee.name, this);                    
                </comment>
                <comment line="1832">
                    }                    
                </comment>
                <comment line="1834">
                    The comment above is inaccurate.  While it is often the case                    
                </comment>
                <comment line="1835">
                    that the containing class will check the access method, this is                    
                </comment>
                <comment line="1836">
                    by no means guaranteed.  In fact, an access method may be added                    
                </comment>
                <comment line="1837">
                    after the checking of its class is complete.  In this case, however,                    
                </comment>
                <comment line="1838">
                    the context in which the class was checked will have been saved in                    
                </comment>
                <comment line="1839">
                    the class definition object (by the fix for 4095716), allowing us                    
                </comment>
                <comment line="1840">
                    to check the field now, and in the correct context.                    
                </comment>
                <comment line="1841">
                    This fixes bug 4098093.                    
                </comment>
                <comment line="1845">
                    System.out.println(&quot;checking late addition: &quot; + this);                    
                </comment>
                <comment line="1854">
                    System.out.println(&quot;[Access member &apos;&quot; +                    
                </comment>
                <comment line="1855">
                    newf + &quot;&apos; created for field &apos;&quot; +                    
                </comment>
                <comment line="1856">
                    field +&quot;&apos; in class &apos;&quot; + this + &quot;&apos;]&quot;);                    
                </comment>
                <declaration name="isStatic" type="boolean" line="1545"/>
                <declaration name="isMethod" type="boolean" line="1546"/>
                <declaration name="af" type="MemberDefinition" line="1553"/>
                <scope line="1554">
                    <scope line="1555">
                        <scope line="1556"/>
                        <declaration name="nargs" type="int" line="1561"/>
                        <scope line="1565"/>
                    </scope>
                </scope>
                <scope line="1571">
                    <scope line="1572"/>
                    <scope line="1574">
                        <declaration name="uf" type="MemberDefinition" line="1575"/>
                        <scope line="1576"/>
                    </scope>
                </scope>
                <scope line="1580"/>
                <declaration name="anm" type="Identifier" line="1587"/>
                <declaration name="dummyType" type="Type" line="1588"/>
                <scope line="1590">
                    <declaration name="outerMostClass" type="SourceClass" line="1596"/>
                    <scope line="1598">
                        <declaration name="sup" type="IdentifierToken" line="1600"/>
                        <declaration name="interfaces" type="IdentifierToken" line="1602"/>
                        <declaration name="t" type="IdentifierToken" line="1603"/>
                        <declaration name="mod" type="int" line="1604"/>
                        <scope line="1607"/>
                        <declaration name="dummyClass" type="ClassDefinition" line="1610"/>
                        <declaration name="argsX" type="Expression" line="1619"/>
                        <declaration name="argTypesX" type="Type" line="1620"/>
                        <scope line="1621">
                            <declaration name="supcls" type="ClassDefinition" line="1622"/>
                        </scope>
                        <scope line="1626"/>
                    </scope>
                </scope>
                <scope line="1631">
                    <scope line="1634">
                        <scope line="1636"/>
                    </scope>
                </scope>
                <declaration name="argTypes" type="Type" line="1642"/>
                <declaration name="t" type="Type" line="1643"/>
                <scope line="1645">
                    <scope line="1646">
                        <scope line="1647">
                            <declaration name="at" type="Type" line="1648"/>
                        </scope>
                        <scope line="1651">
                            <declaration name="at" type="Type" line="1652"/>
                        </scope>
                    </scope>
                    <scope line="1656"/>
                </scope>
                <scope line="1661">
                    <declaration name="classType" type="Type" line="1666"/>
                    <scope line="1667">
                        <scope line="1668">
                            <declaration name="at" type="Type" line="1669"/>
                        </scope>
                        <scope line="1672">
                            <declaration name="at" type="Type" line="1673"/>
                        </scope>
                    </scope>
                    <scope line="1677">
                        <declaration name="at" type="Type" line="1679"/>
                        <declaration name="nargs" type="int" line="1680"/>
                        <scope line="1681">
                            <declaration name="outerThisArg" type="MemberDefinition" line="1684"/>
                            <scope line="1686">
                                <scope line="1690"/>
                                <scope line="1697"/>
                            </scope>
                            <scope line="1700">
                                <scope line="1704"/>
                            </scope>
                        </scope>
                        <scope line="1708">
                            <scope line="1713"/>
                        </scope>
                    </scope>
                </scope>
                <declaration name="nlen" type="int" line="1721"/>
                <declaration name="where" type="long" line="1722"/>
                <declaration name="names" type="IdentifierToken" line="1723"/>
                <scope line="1724"/>
                <declaration name="access" type="Expression" line="1728"/>
                <declaration name="thisArg" type="Expression" line="1729"/>
                <declaration name="args" type="Expression" line="1730"/>
                <scope line="1732">
                    <scope line="1734"/>
                </scope>
                <scope line="1737">
                    <scope line="1738">
                        <scope line="1745"/>
                    </scope>
                    <scope line="1748">
                        <scope line="1754"/>
                    </scope>
                </scope>
                <scope line="1761">
                    <scope line="1763"/>
                </scope>
                <scope line="1766"/>
                <declaration name="code" type="Statement" line="1771"/>
                <scope line="1772"/>
                <scope line="1774"/>
                <declaration name="body" type="Statement" line="1777"/>
                <declaration name="mod" type="int" line="1784"/>
                <scope line="1785"/>
                <declaration name="newf" type="SourceMember" line="1804"/>
                <scope line="1814"/>
                <declaration name="checkContext" type="Context" line="1843"/>
                <scope line="1844">
                    <scope line="1846"/>
                    <scope line="1848"/>
                </scope>
            </method>
            <javadoc line="1861">
                Find an inner class of &apos;this&apos;, chosen arbitrarily.
                  Result is always an actual class, never an interface.
                  Returns null if none found.                
            </javadoc>
            <method name="findLookupContext" type="SourceClass" line="1866">
                <comment line="1867">
                    Look for an immediate inner class.                    
                </comment>
                <comment line="1878">
                    Look for a class nested within an immediate inner interface.                    
                </comment>
                <comment line="1879">
                    At this point, we have given up on finding a minimally-nested                    
                </comment>
                <comment line="1880">
                    class (which would require a breadth-first traversal).  It doesn&apos;t                    
                </comment>
                <comment line="1881">
                    really matter which inner class we find.                    
                </comment>
                <comment line="1893">
                    No inner classes.                    
                </comment>
                <scope line="1870">
                    <scope line="1871">
                        <declaration name="ic" type="SourceClass" line="1872"/>
                        <scope line="1873"/>
                    </scope>
                </scope>
                <scope line="1884">
                    <scope line="1885">
                        <declaration name="lc" type="SourceClass" line="1886"/>
                        <scope line="1888"/>
                    </scope>
                </scope>
            </method>
            <declaration name="lookup" type="MemberDefinition" line="1897"/>
            <javadoc line="1899">
                Get helper method for class literal lookup.                
            </javadoc>
            <method name="getClassLiteralLookup" type="MemberDefinition" line="1902">
                <params>
                    <param name="fwhere" type="long"/>
                </params>
                <comment line="1904">
                    If we have already created a lookup method, reuse it.                    
                </comment>
                <comment line="1909">
                    If the current class is a nested class, make sure we put the                    
                </comment>
                <comment line="1910">
                    lookup method in the outermost class.  Set &apos;lookup&apos; for the                    
                </comment>
                <comment line="1911">
                    intervening inner classes so we won&apos;t have to do the search                    
                </comment>
                <comment line="1912">
                    again.                    
                </comment>
                <comment line="1918">
                    If we arrive here, there was no existing &apos;class$&apos; method.                    
                </comment>
                <comment line="1924">
                    The top-level type is an interface.  Try to find an existing                    
                </comment>
                <comment line="1925">
                    inner class in which to create the helper method.  Any will do.                    
                </comment>
                <comment line="1928">
                    The interface has no inner classes.  Create an anonymous                    
                </comment>
                <comment line="1929">
                    inner class to hold the helper method, as an interface must                    
                </comment>
                <comment line="1930">
                    not have any methods.  The tests above for prior creation                    
                </comment>
                <comment line="1931">
                    of a &apos;class$&apos; method assure that only one such class is                    
                </comment>
                <comment line="1932">
                    allocated for each outermost class containing a class                    
                </comment>
                <comment line="1933">
                    literal embedded somewhere within.  Part of fix for 4055017.                    
                </comment>
                <comment line="1948">
                    The name of the class-getter stub is &quot;class$&quot;                    
                </comment>
                <comment line="1952">
                    Some sanity checks of questionable value.                    
                </comment>
                <comment line="1953">
                                        
                </comment>
                <comment line="1954">
                    This check became useless after matchMethod() was modified                    
                </comment>
                <comment line="1955">
                    to not return synthetic methods.                    
                </comment>
                <comment line="1956">
                                        
                </comment>
                <comment line="1957">
                    try {                    
                </comment>
                <comment line="1958">
                    lookup = c.matchMethod(toplevelEnv, c, idDClass, strarg);                    
                </comment>
                <comment line="1959">
                    } catch (ClassNotFound ee) {                    
                </comment>
                <comment line="1960">
                    throw new CompilerError(&quot;unexpected missing class&quot;);                    
                </comment>
                <comment line="1961">
                    } catch (AmbiguousMember ee) {                    
                </comment>
                <comment line="1962">
                    throw new CompilerError(&quot;synthetic name clash&quot;);                    
                </comment>
                <comment line="1963">
                    }                    
                </comment>
                <comment line="1964">
                    if (lookup != null &amp;&amp; lookup.getClassDefinition() == c) {                    
                </comment>
                <comment line="1965">
                    // Error if method found was not inherited.                    
                </comment>
                <comment line="1966">
                    throw new CompilerError(&quot;unexpected duplicate&quot;);                    
                </comment>
                <comment line="1967">
                    }                    
                </comment>
                <comment line="1968">
                    Some sanity checks of questionable value.                    
                </comment>
                <comment line="1970">
                    The helper function looks like this.
                       It simply maps a checked exception to an unchecked one.
                      static Class class$(String class$) {
                        try { return Class.forName(class$); }
                        catch (ClassNotFoundException forName) {
                          throw new NoClassDefFoundError(forName.getMessage());
                        }
                      }                    
                </comment>
                <comment line="1987">
                    map the exceptions                    
                </comment>
                <comment line="2008">
                    Use default (package) access.  If private, an access method would                    
                </comment>
                <comment line="2009">
                    be needed in the event that the class literal belonged to an interface.                    
                </comment>
                <comment line="2010">
                    Also, making it private tickles bug 4098316.                    
                </comment>
                <comment line="2017">
                    If a new class was created to contain the helper method,                    
                </comment>
                <comment line="2018">
                    check it now.                    
                </comment>
                <scope line="1905"/>
                <scope line="1913"/>
                <declaration name="c" type="ClassDefinition" line="1920"/>
                <declaration name="needNewClass" type="boolean" line="1921"/>
                <scope line="1923">
                    <scope line="1927">
                        <declaration name="sup" type="IdentifierToken" line="1935"/>
                        <declaration name="interfaces" type="IdentifierToken" line="1937"/>
                        <declaration name="t" type="IdentifierToken" line="1938"/>
                        <declaration name="mod" type="int" line="1939"/>
                    </scope>
                </scope>
                <declaration name="idDClass" type="Identifier" line="1949"/>
                <declaration name="strarg" type="Type" line="1950"/>
                <declaration name="w" type="long" line="1979"/>
                <declaration name="arg" type="IdentifierToken" line="1980"/>
                <declaration name="e" type="Expression" line="1981"/>
                <declaration name="a1" type="Expression" line="1982"/>
                <declaration name="idForName" type="Identifier" line="1983"/>
                <declaration name="body" type="Statement" line="1986"/>
                <declaration name="idClassNotFound" type="Identifier" line="1988"/>
                <declaration name="idNoClassDefFound" type="Identifier" line="1990"/>
                <declaration name="ctyp" type="Type" line="1992"/>
                <declaration name="exptyp" type="Type" line="1993"/>
                <declaration name="idGetMessage" type="Identifier" line="1994"/>
                <declaration name="a2" type="Expression" line="1997"/>
                <declaration name="handler" type="Statement" line="1999"/>
                <declaration name="handlers" type="Statement" line="2002"/>
                <declaration name="mtype" type="Type" line="2005"/>
                <declaration name="args" type="IdentifierToken" line="2006"/>
                <scope line="2019">
                    <scope line="2020"/>
                    <declaration name="argsX" type="Expression" line="2024"/>
                    <declaration name="argTypesX" type="Type" line="2025"/>
                    <scope line="2026">
                        <declaration name="sup" type="ClassDefinition" line="2027"/>
                    </scope>
                    <scope line="2031"/>
                </scope>
            </method>
            <declaration name="active" type="Vector" line="2038"/>
            <javadoc line="2038">
                A list of active ongoing compilations. This list
                  is used to stop two compilations from saving the
                  same class.                
            </javadoc>
            <javadoc line="2045">
                Compile this class                
            </javadoc>
            <method name="compile" type="void" line="2049">
                <params>
                    <param name="out" type="OutputStream"/>
                </params>
                <declaration name="env" type="Environment" line="2050"/>
                <scope line="2051">
                    <scope line="2052"/>
                </scope>
                <scope line="2058"/>
                <scope line="2060"/>
                <scope line="2062">
                    <scope line="2063"/>
                </scope>
            </method>
            <javadoc line="2070">
                Verify that the modifier bits included in &apos;required&apos; are
                  all present in &apos;mods&apos;, otherwise signal an internal error.
                  Note that errors in the source program may corrupt the modifiers,
                  thus we rely on the fact that &apos;CompilerError&apos; exceptions are
                  silently ignored after an error message has been issued.                
            </javadoc>
            <method name="assertModifiers" type="void" line="2077">
                <params>
                    <param name="mods" type="int"/>
                    <param name="required" type="int"/>
                </params>
                <scope line="2078"/>
            </method>
            <method name="compileClass" type="void" line="2084">
                <params>
                    <param name="env" type="Environment"/>
                    <param name="out" type="OutputStream"/>
                </params>
                <comment line="2094">
                    Reverse the order, so that outer levels come first:                    
                </comment>
                <comment line="2101">
                    System.out.println(&quot;compile class &quot; + getName());                    
                </comment>
                <comment line="2108">
                    Generate code for all fields                    
                </comment>
                <comment line="2113">
                    System.out.println(&quot;compile field &quot; + field.getName());                    
                </comment>
                <comment line="2158">
                    bail out if there were any errors                    
                </comment>
                <comment line="2165">
                    Insert constants                    
                </comment>
                <comment line="2200">
                    JCOV                    
                </comment>
                <comment line="2202">
                    AbsoluteSourcePath, TimeStamp                    
                </comment>
                <comment line="2207">
                    end JCOV                    
                </comment>
                <comment line="2213">
                    InnerClasses                    
                </comment>
                <comment line="2216">
                    JCOV                    
                </comment>
                <comment line="2225">
                    end JCOV                    
                </comment>
                <comment line="2234">
                    Sort the methods in order to make sure both constant pool                    
                </comment>
                <comment line="2235">
                    entries and methods are in a deterministic order from run                    
                </comment>
                <comment line="2236">
                    to run (this allows comparing class files for a fixed point                    
                </comment>
                <comment line="2237">
                    to validate the compiler)                    
                </comment>
                <comment line="2245">
                    Optimize Code and Collect method constants                    
                </comment>
                <comment line="2264">
                    Collect field constants                    
                </comment>
                <comment line="2276">
                    Collect inner class constants                    
                </comment>
                <comment line="2282">
                    If the inner class is local, we do not need to add its                    
                </comment>
                <comment line="2283">
                    outer class here -- the outer_class_info_index is zero.                    
                </comment>
                <comment line="2289">
                    If the local name of the class is idNull, don&apos;t bother to                    
                </comment>
                <comment line="2290">
                    add it to the constant pool.  We won&apos;t need it.                    
                </comment>
                <comment line="2297">
                    Write header                    
                </comment>
                <comment line="2304">
                    Write class information                    
                </comment>
                <comment line="2307">
                    Certain modifiers are implied:                    
                </comment>
                <comment line="2308">
                    1.  Any interface (nested or not) is implicitly deemed to be abstract,                    
                </comment>
                <comment line="2309">
                    whether it is explicitly marked so or not.  (Java 1.0.)                    
                </comment>
                <comment line="2310">
                    2.  A interface which is a member of a type is implicitly deemed to                    
                </comment>
                <comment line="2311">
                    be static, whether it is explicitly marked so or not.                    
                </comment>
                <comment line="2312">
                    3a. A type which is a member of an interface is implicitly deemed                    
                </comment>
                <comment line="2313">
                    to be public, whether it is explicitly marked so or not.                    
                </comment>
                <comment line="2314">
                    3b. A type which is a member of an interface is implicitly deemed                    
                </comment>
                <comment line="2315">
                    to be static, whether it is explicitly marked so or not.                    
                </comment>
                <comment line="2316">
                    All of these rules are implemented in &apos;BatchParser.beginClass&apos;,                    
                </comment>
                <comment line="2317">
                    but the results are verified here.                    
                </comment>
                <comment line="2320">
                    Rule 1.                    
                </comment>
                <comment line="2321">
                    The VM spec states that ACC_ABSTRACT must be set when                    
                </comment>
                <comment line="2322">
                    ACC_INTERFACE is; this was not done by javac prior to 1.2,                    
                </comment>
                <comment line="2323">
                    and the runtime compensates by setting it.  Making sure                    
                </comment>
                <comment line="2324">
                    it is set here will allow the runtime hack to eventually                    
                </comment>
                <comment line="2325">
                    be removed. Rule 2 doesn&apos;t apply to transformed modifiers.                    
                </comment>
                <comment line="2328">
                    Contrary to the JVM spec, we only set ACC_SUPER for classes,                    
                </comment>
                <comment line="2329">
                    not interfaces.  This is a workaround for a bug in IE3.0,                    
                </comment>
                <comment line="2330">
                    which refuses interfaces with ACC_SUPER on.                    
                </comment>
                <comment line="2334">
                    If this is a nested class, transform access modifiers.                    
                </comment>
                <comment line="2336">
                    If private, transform to default (package) access.                    
                </comment>
                <comment line="2337">
                    If protected, transform to public.                    
                </comment>
                <comment line="2338">
                    M_PRIVATE and M_PROTECTED are already masked off by MM_CLASS above.                    
                </comment>
                <comment line="2339">
                    cmods &amp;= ~(M_PRIVATE | M_PROTECTED);                    
                </comment>
                <comment line="2341">
                    Rule 3a.  Note that Rule 3b doesn&apos;t apply to transformed modifiers.                    
                </comment>
                <comment line="2365">
                    write variables                    
                </comment>
                <comment line="2400">
                    write methods                    
                </comment>
                <comment line="2407">
                    Transform floating point modifiers.  M_STRICTFP                    
                </comment>
                <comment line="2408">
                    of member + status of enclosing class turn into                    
                </comment>
                <comment line="2409">
                    ACC_STRICT bit.                    
                </comment>
                <comment line="2413">
                    Use the default                    
                </comment>
                <comment line="2435">
                    JCOV                    
                </comment>
                <comment line="2439">
                    end JCOV                    
                </comment>
                <comment line="2453">
                    JCOV                    
                </comment>
                <comment line="2461">
                    end JCOV                    
                </comment>
                <comment line="2475">
                    JCOV                    
                </comment>
                <comment line="2478">
                    end JCOV                    
                </comment>
                <comment line="2500">
                    class attributes                    
                </comment>
                <comment line="2518">
                    JCOV                    
                </comment>
                <comment line="2527">
                    end JCOV                    
                </comment>
                <comment line="2535">
                    For each inner class name transformation, we have a record                    
                </comment>
                <comment line="2536">
                    with the following fields:                    
                </comment>
                <comment line="2537">
                                        
                </comment>
                <comment line="2538">
                    u2 inner_class_info_index;   // CONSTANT_Class_info index                    
                </comment>
                <comment line="2539">
                    u2 outer_class_info_index;   // CONSTANT_Class_info index                    
                </comment>
                <comment line="2540">
                    u2 inner_name_index;         // CONSTANT_Utf8_info index                    
                </comment>
                <comment line="2541">
                    u2 inner_class_access_flags; // access_flags bitmask                    
                </comment>
                <comment line="2542">
                                        
                </comment>
                <comment line="2543">
                    The spec states that outer_class_info_index is 0 iff                    
                </comment>
                <comment line="2544">
                    the inner class is not a member of its enclosing class (i.e.                    
                </comment>
                <comment line="2545">
                    it is a local or anonymous class).  The spec also states                    
                </comment>
                <comment line="2546">
                    that if a class is anonymous then inner_name_index should                    
                </comment>
                <comment line="2547">
                    be 0.                    
                </comment>
                <comment line="2548">
                                        
                </comment>
                <comment line="2549">
                    See also the initInnerClasses() method in BinaryClass.java.                    
                </comment>
                <comment line="2551">
                    Generate inner_class_info_index.                    
                </comment>
                <comment line="2555">
                    Generate outer_class_info_index.                    
                </comment>
                <comment line="2556">
                                        
                </comment>
                <comment line="2557">
                    Checking isLocal() should probably be enough here,                    
                </comment>
                <comment line="2558">
                    but the check for isAnonymous is added for good                    
                </comment>
                <comment line="2559">
                    measure.                    
                </comment>
                <comment line="2563">
                    Query: what about if inner.isInsideLocal()?                    
                </comment>
                <comment line="2564">
                    For now we continue to generate a nonzero                    
                </comment>
                <comment line="2565">
                    outer_class_info_index.                    
                </comment>
                <comment line="2570">
                    Generate inner_name_index.                    
                </comment>
                <comment line="2581">
                    Generate inner_class_access_flags.                    
                </comment>
                <comment line="2585">
                    Certain modifiers are implied for nested types.                    
                </comment>
                <comment line="2586">
                    See rules 1, 2, 3a, and 3b enumerated above.                    
                </comment>
                <comment line="2587">
                    All of these rules are implemented in &apos;BatchParser.beginClass&apos;,                    
                </comment>
                <comment line="2588">
                    but are verified here.                    
                </comment>
                <comment line="2591">
                    Rules 1 and 2.                    
                </comment>
                <comment line="2595">
                    Rules 3a and 3b.                    
                </comment>
                <comment line="2596">
                    error recovery                    
                </comment>
                <comment line="2613">
                    Cleanup                    
                </comment>
                <comment line="2617">
                    JCOV                    
                </comment>
                <comment line="2618">
                    generate coverage data                    
                </comment>
                <comment line="2623">
                    end JCOV                    
                </comment>
                <declaration name="variables" type="Vector" line="2085"/>
                <declaration name="methods" type="Vector" line="2086"/>
                <declaration name="innerClasses" type="Vector" line="2087"/>
                <declaration name="init" type="CompilerMember" line="2088"/>
                <declaration name="ctx" type="Context" line="2089"/>
                <scope line="2091"/>
                <declaration name="ncsize" type="int" line="2095"/>
                <declaration name="haveDeprecated" type="boolean" line="2103"/>
                <declaration name="haveSynthetic" type="boolean" line="2104"/>
                <declaration name="haveConstantValue" type="boolean" line="2105"/>
                <declaration name="haveExceptions" type="boolean" line="2106"/>
                <scope line="2111">
                    <scope line="2118">
                        <scope line="2119">
                            <scope line="2123">
                                <scope line="2124"/>
                            </scope>
                            <scope line="2127">
                                <declaration name="f" type="CompilerMember" line="2128"/>
                            </scope>
                        </scope>
                        <scope line="2133"/>
                        <scope line="2135">
                            <declaration name="f" type="CompilerMember" line="2137"/>
                            <scope line="2139"/>
                        </scope>
                    </scope>
                    <scope line="2146"/>
                </scope>
                <scope line="2153"/>
                <scope line="2159"/>
                <declaration name="nClassAttrs" type="int" line="2163"/>
                <scope line="2166"/>
                <scope line="2169"/>
                <declaration name="sourceFile" type="String" line="2173"/>
                <scope line="2174"/>
                <scope line="2181"/>
                <scope line="2185"/>
                <scope line="2188">
                    <scope line="2190"/>
                </scope>
                <scope line="2194">
                    <scope line="2196"/>
                </scope>
                <scope line="2201"/>
                <scope line="2208"/>
                <scope line="2211"/>
                <declaration name="absoluteSourcePath" type="String" line="2217"/>
                <declaration name="timeStamp" type="long" line="2218"/>
                <scope line="2220"/>
                <scope line="2227"/>
                <scope line="2230"/>
                <declaration name="ordered_methods" type="CompilerMember[]" line="2238"/>
                <scope line="2246">
                    <declaration name="f" type="CompilerMember" line="2247"/>
                    <scope line="2248">
                        <declaration name="exp" type="ClassDeclaration" line="2253"/>
                        <scope line="2254"/>
                    </scope>
                    <scope line="2257"/>
                </scope>
                <scope line="2265">
                    <declaration name="f" type="CompilerMember" line="2266"/>
                    <declaration name="val" type="Object" line="2270"/>
                    <scope line="2271"/>
                </scope>
                <scope line="2278">
                    <declaration name="inner" type="ClassDefinition" line="2279"/>
                    <scope line="2284">
                        <declaration name="outer" type="ClassDefinition" line="2285"/>
                    </scope>
                    <declaration name="inner_local_name" type="Identifier" line="2291"/>
                    <scope line="2292"/>
                </scope>
                <declaration name="data" type="DataOutputStream" line="2298"/>
                <declaration name="cmods" type="int" line="2305"/>
                <scope line="2319"/>
                <scope line="2327"/>
                <scope line="2335">
                    <scope line="2342"/>
                </scope>
                <scope line="2349">
                    <declaration name="cn" type="Identifier" line="2350"/>
                    <declaration name="nm" type="Identifier" line="2351"/>
                </scope>
                <scope line="2361"/>
                <declaration name="buf" type="ByteArrayOutputStream" line="2366"/>
                <declaration name="attbuf" type="ByteArrayOutputStream" line="2367"/>
                <declaration name="databuf" type="DataOutputStream" line="2368"/>
                <scope line="2371">
                    <declaration name="f" type="CompilerMember" line="2372"/>
                    <declaration name="val" type="Object" line="2373"/>
                    <declaration name="fieldAtts" type="int" line="2379"/>
                    <declaration name="dep" type="boolean" line="2380"/>
                    <declaration name="syn" type="boolean" line="2381"/>
                    <scope line="2385"/>
                    <scope line="2390"/>
                    <scope line="2394"/>
                </scope>
                <scope line="2403">
                    <declaration name="f" type="CompilerMember" line="2404"/>
                    <declaration name="xmods" type="int" line="2406"/>
                    <scope line="2410"/>
                    <scope line="2412">
                        <scope line="2414"/>
                    </scope>
                    <declaration name="exp" type="ClassDeclaration" line="2422"/>
                    <declaration name="methodAtts" type="int" line="2423"/>
                    <declaration name="dep" type="boolean" line="2424"/>
                    <declaration name="syn" type="boolean" line="2425"/>
                    <scope line="2428">
                        <declaration name="natts" type="int" line="2431"/>
                        <scope line="2432"/>
                        <scope line="2436"/>
                        <scope line="2440"/>
                        <scope line="2445"/>
                        <scope line="2454"/>
                        <scope line="2462"/>
                    </scope>
                    <scope line="2474"/>
                    <scope line="2482">
                        <scope line="2486"/>
                    </scope>
                    <scope line="2490"/>
                    <scope line="2494"/>
                </scope>
                <scope line="2503"/>
                <scope line="2509"/>
                <scope line="2513"/>
                <scope line="2519"/>
                <scope line="2529">
                    <scope line="2534">
                        <declaration name="inner" type="ClassDefinition" line="2552"/>
                        <scope line="2560"/>
                        <scope line="2562">
                            <declaration name="outer" type="ClassDefinition" line="2566"/>
                        </scope>
                        <declaration name="inner_name" type="Identifier" line="2571"/>
                        <scope line="2572">
                            <scope line="2573"/>
                        </scope>
                        <scope line="2577"/>
                        <declaration name="imods" type="int" line="2582"/>
                        <scope line="2590"/>
                        <scope line="2594"/>
                        <scope line="2602">
                            <declaration name="fn" type="Identifier" line="2603"/>
                            <declaration name="nm" type="Identifier" line="2604"/>
                        </scope>
                    </scope>
                </scope>
                <scope line="2619">
                    <declaration name="CovAsm" type="Assembler" line="2620"/>
                </scope>
            </method>
            <javadoc line="2626">
                Print out the dependencies for this class (-xdepend) option                
            </javadoc>
            <method name="printClassDependencies" type="void" line="2630">
                <params>
                    <param name="env" type="Environment"/>
                </params>
                <comment line="2632">
                    Only do this if the -xdepend flag is on                    
                </comment>
                <comment line="2635">
                    Name of java source file this class was in (full path)                    
                </comment>
                <comment line="2636">
                    e.g. /home/ohair/Test.java                    
                </comment>
                <comment line="2639">
                    Class name, fully qualified                    
                </comment>
                <comment line="2640">
                    e.g. &quot;java.lang.Object&quot; or &quot;FooBar&quot; or &quot;sun.tools.javac.Main&quot;                    
                </comment>
                <comment line="2641">
                    Inner class names must be mangled, as ordinary &apos;.&apos; qualification                    
                </comment>
                <comment line="2642">
                    is used internally where the spec requires &apos;$&apos; separators.                    
                </comment>
                <comment line="2643">
                    String className = getName().toString();                    
                </comment>
                <comment line="2646">
                    Line number where class starts in the src file                    
                </comment>
                <comment line="2649">
                    Line number where class ends in the src file (not used yet)                    
                </comment>
                <comment line="2652">
                    First line looks like:                    
                </comment>
                <comment line="2653">
                    CLASS:src,startLine,endLine,className                    
                </comment>
                <comment line="2660">
                    For each class this class is dependent on:                    
                </comment>
                <comment line="2661">
                    CLDEP:className1,className2                    
                </comment>
                <comment line="2662">
                    where className1 is the name of the class we are in, and                    
                </comment>
                <comment line="2663">
                    classname2 is the name of the class className1                    
                </comment>
                <comment line="2664">
                    is dependent on.                    
                </comment>
                <comment line="2667">
                    Mangle name of class dependend on.                    
                </comment>
                <scope line="2633">
                    <declaration name="src" type="String" line="2637"/>
                    <declaration name="className" type="String" line="2644"/>
                    <declaration name="startLine" type="long" line="2647"/>
                    <declaration name="endLine" type="long" line="2650"/>
                    <scope line="2665">
                        <declaration name="data" type="ClassDeclaration" line="2666"/>
                        <declaration name="depName" type="String" line="2668"/>
                    </scope>
                </scope>
            </method>
        </class>
    </source>