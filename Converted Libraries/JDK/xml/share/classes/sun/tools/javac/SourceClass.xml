<?xml version="1.0" encoding="UTF-8"?>
    <source package="sun.tools.javac">
        <import package="sun.tools.java"/>
        <import package="sun.tools.tree"/>
        <import package="sun.tools.tree.CompoundStatement"/>
        <import package="sun.tools.asm.Assembler"/>
        <import package="sun.tools.asm.ConstantPool"/>
        <import package="java.util.Vector"/>
        <import package="java.util.Enumeration"/>
        <import package="java.util.Hashtable"/>
        <import package="java.util.Iterator"/>
        <import package="java.io.IOException"/>
        <import package="java.io.OutputStream"/>
        <import package="java.io.DataOutputStream"/>
        <import package="java.io.ByteArrayOutputStream"/>
        <import package="java.io.File"/>
        <class name="SourceClass" line="43">
            <extends class="ClassDefinition"/>
            <comment line="200">
                JCOV                
            </comment>
            <comment line="209">
                end JCOV                
            </comment>
            <comment line="653">
                Set true if superclass (but not necessarily superinterfaces) have
                 been checked.  If the superclass is still unresolved, then an error
                 message should have been issued, and we assume that no further
                 resolution is possible.                
            </comment>
            <javadoc line="43">
                This class represents an Java class as it is read from
                  an Java source file.
                  WARNING: The contents of this source file are not part of any
                  supported API.  Code that depends on them does so at its own risk:
                  they are subject to change or removal without notice.                
            </javadoc>
            <declaration name="toplevelEnv" type="Environment" line="55"/>
            <javadoc line="55">
                The toplevel environment, shared with the parser                
            </javadoc>
            <declaration name="defConstructor" type="SourceMember" line="60"/>
            <javadoc line="60">
                The default constructor                
            </javadoc>
            <declaration name="tab" type="ConstantPool" line="65"/>
            <javadoc line="65">
                The constant pool                
            </javadoc>
            <declaration name="deps" type="Hashtable" line="70"/>
            <javadoc line="70">
                The list of class dependencies                
            </javadoc>
            <declaration name="thisArg" type="LocalMember" line="75"/>
            <javadoc line="75">
                The field used to represent &quot;this&quot; in all of my code.                
            </javadoc>
            <declaration name="endPosition" type="long" line="80"/>
            <javadoc line="80">
                Last token of class, as reported by parser.                
            </javadoc>
            <declaration name="dummyArgumentType" type="Type" line="85"/>
            <javadoc line="85">
                Access methods for constructors are distinguished from
                  the constructors themselves by a dummy first argument.
                  A unique type used for this purpose and shared by all
                  constructor access methods within a package-member class is
                  maintained here.
                  &lt;p&gt;
                  This field is null except in an outermost class containing
                  one or more classes needing such an access method.                
            </javadoc>
            <javadoc line="97">
                Constructor                
            </javadoc>
            <method name="SourceClass" type="constructor" line="104">
                <params>
                    <param name="env" type="Environment"/>
                    <param name="where" type="long"/>
                    <param name="declaration" type="ClassDeclaration"/>
                    <param name="documentation" type="String"/>
                    <param name="modifiers" type="int"/>
                    <param name="superClass" type="IdentifierToken"/>
                    <param name="interfaces" type="IdentifierToken"/>
                    <param name="outerClass" type="SourceClass"/>
                    <param name="localName" type="Identifier"/>
                </params>
                <comment line="117">
                    Check for a package level class which is declared static.                    
                </comment>
                <comment line="123">
                    Inner classes cannot be static, nor can they be interfaces
                     (which are implicitly static).  Static classes and interfaces
                     can only occur as top-level entities.
                    
                     Note that we do not have to check for local classes declared
                     to be static (this is currently caught by the parser) but
                     we check anyway in case the parser is modified to allow this.                    
                </comment>
                <comment line="150">
                    ----
                    if ((isPublic() || isProtected()) &amp;&amp; isInsideLocal()) {
                    env.error(where, &quot;warn.public.local.class&quot;, this);
                    }                    
                </comment>
                <comment line="156">
                    maybe define an uplevel &quot;A.this&quot; current instance field                    
                </comment>
                <comment line="163">
                    Set simple, unmangled local name for a local or anonymous class.
                     NOTE: It would be OK to do this unconditionally, as null is the
                     correct value for a member (non-local) class.                    
                </comment>
                <comment line="169">
                    Check for inner class with same simple name as one of
                     its enclosing classes.  Note that &apos;getLocalName&apos; returns
                     the simple, unmangled source-level name of any class.
                     The previous version of this code was not careful to avoid
                     mangled local class names.  This version fixes 4047746.                    
                </comment>
                <comment line="176">
                    Test above suppresses error for nested anonymous classes,
                     which have an internal &quot;name&quot;, but are not named in source code.                    
                </comment>
                <scope line="112"/>
                <scope line="117"/>
                <scope line="129">
                    <scope line="130"/>
                    <scope line="132">
                        <scope line="135"/>
                    </scope>
                </scope>
                <scope line="141"/>
                <scope line="145"/>
                <scope line="156">
                    <declaration name="outerArg" type="LocalMember" line="157"/>
                    <declaration name="r" type="UplevelReference" line="158"/>
                </scope>
                <declaration name="thisName" type="Identifier" line="173"/>
                <scope line="174">
                    <scope line="178">
                        <declaration name="outerName" type="Identifier" line="179"/>
                    </scope>
                </scope>
            </method>
            <javadoc line="186">
                Return last position in this class.                
                <see>
                    #getWhere                    
                </see>
            </javadoc>
            <method name="getEndPosition" type="long" line="190"/>
            <method name="setEndPosition" type="void" line="194">
                <params>
                    <param name="endPosition" type="long"/>
                </params>
            </method>
            <javadoc line="200">
                Return absolute name of source file                
            </javadoc>
            <method name="getAbsoluteName" type="String" line="203">
                <declaration name="AbsName" type="String" line="204"/>
            </method>
            <javadoc line="210">
                Return imports                
            </javadoc>
            <method name="getImports" type="Imports" line="213"/>
            <javadoc line="217">
                Find or create my &quot;this&quot; argument, which is used for all methods.                
            </javadoc>
            <method name="getThisArgument" type="LocalMember" line="220">
                <scope line="221"/>
            </method>
            <javadoc line="227">
                Add a dependency                
            </javadoc>
            <method name="addDependency" type="void" line="230">
                <params>
                    <param name="c" type="ClassDeclaration"/>
                </params>
                <comment line="235">
                    If doing -xdepend option, save away list of class dependencies
                       making sure to NOT include duplicates or the class we are in
                       (Hashtable&apos;s put() makes sure we don&apos;t have duplicates)                    
                </comment>
                <scope line="231"/>
                <scope line="237"/>
            </method>
            <javadoc line="242">
                Add a field (check it first)                
            </javadoc>
            <method name="addMember" type="void" line="245">
                <params>
                    <param name="env" type="Environment"/>
                    <param name="f" type="MemberDefinition"/>
                </params>
                <comment line="247">
                    Make sure the access permissions are self-consistent:                    
                </comment>
                <comment line="256">
                    Cut out the more restrictive modifier(s):                    
                </comment>
                <comment line="265">
                    Note exemption for synthetic members below.                    
                </comment>
                <comment line="275">
                    Even if a static passes this test, there is still another
                     check in &apos;SourceMember.check&apos;.  The check is delayed so
                     that the initializer may be inspected more closely, using
                     &apos;isConstant()&apos;.  Part of fix for 4095568.                    
                </comment>
                <comment line="280">
                    Static inner classes are diagnosed in &apos;SourceClass.&lt;init&gt;&apos;.                    
                </comment>
                <comment line="304">
                    f is not allowed to return an array of void                    
                </comment>
                <comment line="363">
                    arguments can be null if this is an implicit abstract method                    
                </comment>
                <comment line="373">
                    (arg should be an Identifier now)                    
                </comment>
                <comment line="387">
                    same check as for fields, below:                    
                </comment>
                <comment line="393">
                    Fix up the class itself to agree with
                     the inner-class member.                    
                </comment>
                <comment line="402">
                    REMIND: set type to error                    
                </comment>
                <comment line="434">
                    Do not check for repeated methods here:  Types are not yet resolved.                    
                </comment>
                <comment line="444">
                    Found a duplicate inner-class member.
                     Duplicate local classes are detected in
                     &apos;VarDeclarationStatement.checkDeclaration&apos;.                    
                </comment>
                <scope line="256"/>
                <scope line="258"/>
                <scope line="265">
                    <scope line="266"/>
                    <scope line="269">
                        <scope line="270"/>
                    </scope>
                    <scope line="278"/>
                </scope>
                <scope line="284">
                    <scope line="285">
                        <scope line="286"/>
                        <scope line="291"/>
                    </scope>
                    <scope line="296">
                        <scope line="297"/>
                    </scope>
                    <scope line="304"/>
                    <scope line="310"/>
                    <scope line="315"/>
                    <scope line="319"/>
                    <scope line="323">
                        <scope line="324"/>
                        <scope line="328"/>
                        <scope line="332"/>
                        <scope line="336"/>
                        <scope line="340"/>
                    </scope>
                    <scope line="345">
                        <scope line="346"/>
                    </scope>
                    <scope line="350">
                        <scope line="351">
                            <scope line="352"/>
                            <scope line="354"/>
                        </scope>
                    </scope>
                    <declaration name="arguments" type="Vector" line="360"/>
                    <scope line="361">
                        <declaration name="argumentLength" type="int" line="363"/>
                        <declaration name="argTypes" type="Type" line="364"/>
                        <scope line="365">
                            <declaration name="arg" type="Object" line="366"/>
                            <declaration name="where" type="long" line="367"/>
                            <scope line="368"/>
                            <scope line="374"/>
                        </scope>
                    </scope>
                </scope>
                <scope line="379">
                    <scope line="381"/>
                    <scope line="388">
                        <declaration name="c" type="ClassDefinition" line="394"/>
                    </scope>
                </scope>
                <scope line="398">
                    <scope line="399"/>
                    <scope line="405"/>
                    <scope line="409"/>
                    <scope line="413"/>
                    <scope line="417"/>
                    <scope line="421"/>
                    <scope line="427"/>
                </scope>
                <scope line="434">
                    <scope line="436">
                        <scope line="437"/>
                        <scope line="442"/>
                    </scope>
                </scope>
            </method>
            <javadoc line="455">
                Create an environment suitable for checking this class.
                  Make sure the source and imports are set right.
                  Make sure the environment contains no context information.
                  (Actually, throw away env altogether and use toplevelEnv instead.)                
            </javadoc>
            <method name="setupEnv" type="Environment" line="461">
                <params>
                    <param name="env" type="Environment"/>
                </params>
                <comment line="463">
                    In some cases, we go to some trouble to create the &apos;env&apos; argument
                     that is discarded.  We should remove the &apos;env&apos; argument entirely
                     as well as the vestigial code that supports it.  See comments on
                     &apos;newEnvironment&apos; in &apos;checkInternal&apos; below.                    
                </comment>
            </method>
            <javadoc line="469">
                A source class never reports deprecation, since the compiler
                  allows access to deprecated features that are being compiled
                  in the same job.                
            </javadoc>
            <method name="reportDeprecated" type="boolean" line="474">
                <params>
                    <param name="env" type="Environment"/>
                </params>
            </method>
            <javadoc line="478">
                See if the source file of this class is right.                
                <see>
                    ClassDefinition#noteUsedBy                    
                </see>
            </javadoc>
            <method name="noteUsedBy" type="void" line="482">
                <params>
                    <param name="ref" type="ClassDefinition"/>
                    <param name="where" type="long"/>
                    <param name="env" type="Environment"/>
                </params>
                <comment line="484">
                    If this class is not public, watch for cross-file references.                    
                </comment>
                <comment line="491">
                    already checked                    
                </comment>
                <comment line="497">
                    intra-file reference                    
                </comment>
                <declaration name="def" type="ClassDefinition" line="485"/>
                <scope line="486"/>
                <scope line="489"/>
                <scope line="492"/>
                <scope line="495"/>
            </method>
            <javadoc line="501">
                Check this class and all its fields.                
            </javadoc>
            <method name="check" type="void" line="504">
                <params>
                    <param name="env" type="Environment"/>
                </params>
                <comment line="508">
                    An inaccessible class gets checked when the surrounding
                     block is checked.
                     QUERY: Should this case ever occur?
                     What would invoke checking of a local class aside from
                     checking the surrounding method body?                    
                </comment>
                <comment line="520">
                    Make sure the outer is checked first.                    
                </comment>
                <comment line="528">
                    drop vset here                    
                </comment>
                <scope line="506"/>
                <scope line="515">
                    <scope line="516"/>
                    <declaration name="vset" type="Vset" line="522"/>
                    <declaration name="ctx" type="Context" line="523"/>
                </scope>
            </method>
            <method name="maybeCheck" type="void" line="532">
                <params>
                    <param name="env" type="Environment"/>
                </params>
                <comment line="535">
                    Check this class now, if it has not yet been checked.
                     Cf. Main.compile().  Perhaps this code belongs there somehow.                    
                </comment>
                <comment line="539">
                    Set it first to avoid vicious circularity:                    
                </comment>
                <declaration name="c" type="ClassDeclaration" line="536"/>
                <scope line="537"/>
            </method>
            <method name="checkInternal" type="Vset" line="545">
                <params>
                    <param name="env" type="Environment"/>
                    <param name="ctx" type="Context"/>
                    <param name="vset" type="Vset"/>
                </params>
                <comment line="552">
                    Save context enclosing class for later access
                     by &apos;ClassDefinition.resolveName.&apos;                    
                </comment>
                <comment line="556">
                    At present, the call to &apos;newEnvironment&apos; is not needed.
                     The incoming environment to &apos;basicCheck&apos; is always passed to
                     &apos;setupEnv&apos;, which discards it completely.  This is also the
                     only call to &apos;newEnvironment&apos;, which is now apparently dead code.                    
                </comment>
                <comment line="562">
                    Validate access for all inner-class components
                     of a qualified name, not just the last one, which
                     is checked below.  Yes, this is a dirty hack...
                     Much of this code was cribbed from &apos;checkSupers&apos;.
                     Part of fix for 4094658.                    
                </comment>
                <comment line="576">
                    Error localization fails here if interfaces were
                     elided during error recovery from an invalid one.                    
                </comment>
                <comment line="585">
                    Does the name already exist in an imported package?
                     See JLS 8.1 for the precise rules.                    
                </comment>
                <comment line="588">
                    Discard package qualification for the import checks.                    
                </comment>
                <comment line="591">
                    We want this to throw a ClassNotFound exception                    
                </comment>
                <comment line="597">
                    At least one of e.name1 and e.name2 must be different                    
                </comment>
                <comment line="601">
                    we want this to happen                    
                </comment>
                <comment line="604">
                    Make sure that no package with the same fully qualified
                     name exists.  This is required by JLS 7.1.  We only need
                     to perform this check for top level classes -- it isn&apos;t
                     necessary for inner classes.  (bug 4101529)
                    
                     This change has been backed out because, on WIN32, it
                     failed to distinguish between java.awt.event and
                     java.awt.Event when looking for a directory.  We will
                     add this back in later.
                    
                     try {
                      if (env.getPackage(nm).exists()) {
                          env.error(where, &quot;class.package.conflict&quot;, nm);
                      }
                     } catch (java.io.IOException ee) {
                      env.error(where, &quot;io.exception.package&quot;, nm);
                     }                    
                </comment>
                <comment line="622">
                    Make sure it was defined in the right file                    
                </comment>
                <declaration name="nm" type="Identifier" line="546"/>
                <scope line="547"/>
                <declaration name="sup" type="ClassDeclaration" line="566"/>
                <scope line="567">
                    <declaration name="where" type="long" line="568"/>
                </scope>
                <scope line="572">
                    <declaration name="intf" type="ClassDeclaration" line="573"/>
                    <declaration name="where" type="long" line="574"/>
                    <scope line="578"/>
                </scope>
                <scope line="586">
                    <declaration name="simpleName" type="Identifier" line="588"/>
                    <scope line="589">
                        <declaration name="imports" type="Imports" line="591"/>
                        <declaration name="ID" type="Identifier" line="592"/>
                    </scope>
                    <scope line="595">
                        <declaration name="ID" type="Identifier" line="597"/>
                    </scope>
                    <scope line="599"/>
                    <scope line="622"/>
                </scope>
            </method>
            <declaration name="sourceFileChecked" type="boolean" line="631"/>
            <javadoc line="633">
                See if the source file of this class is of the right name.                
            </javadoc>
            <method name="checkSourceFile" type="void" line="636">
                <params>
                    <param name="env" type="Environment"/>
                    <param name="where" type="long"/>
                </params>
                <comment line="638">
                    one error per offending class is sufficient                    
                </comment>
                <declaration name="fname" type="String" line="641"/>
                <declaration name="src" type="String" line="642"/>
                <scope line="643">
                    <scope line="644"/>
                    <scope line="646"/>
                </scope>
            </method>
            <declaration name="supersChecked" type="boolean" line="656"/>
            <javadoc line="658">
                Overrides &apos;ClassDefinition.getSuperClass&apos;.                
            </javadoc>
            <method name="getSuperClass" type="ClassDeclaration" line="662">
                <params>
                    <param name="env" type="Environment"/>
                </params>
                <comment line="665">
                    Superclass may fail to be set because of error recovery,
                     so resolve types here only if &apos;checkSupers&apos; has not yet
                     completed its checks on the superclass.
                     QUERY: Can we eliminate the need to resolve superclasses on demand?
                     See comments in &apos;checkSupers&apos; and in &apos;ClassDefinition.getInnerClass&apos;.                    
                </comment>
                <comment line="672">
                    We used to report an error here if the superclass was not
                     resolved.  Having moved the call to &apos;checkSupers&apos; from &apos;basicCheck&apos;
                     into &apos;resolveTypeStructure&apos;, the errors reported here should have
                     already been reported.  Furthermore, error recovery can null out
                     the superclass, which would cause a spurious error from the test here.                    
                </comment>
                <scope line="669"/>
            </method>
            <javadoc line="681">
                Check that all superclasses and superinterfaces are defined and
                  well formed.  Among other checks, verify that the inheritance
                  graph is acyclic.  Called from &apos;resolveTypeStructure&apos;.                
            </javadoc>
            <method name="checkSupers" type="void" line="687">
                <params>
                    <param name="env" type="Environment"/>
                </params>
                <comment line="690">
                    *** DEBUG ***                    
                </comment>
                <comment line="699">
                    Interfaces have no superclass.  Superinterfaces
                     are checked below, in code shared with the class case.                    
                </comment>
                <comment line="703">
                    Check superclass.
                     Call to &apos;getSuperClass(env)&apos; (note argument) attempts
                     &apos;resolveTypeStructure&apos; if superclass has not successfully
                     been resolved.  Since we have just now called &apos;resolveSupers&apos;
                     (see our call in &apos;resolveTypeStructure&apos;), it is not clear
                     that this can do any good.  Why not &apos;getSuperClass()&apos; here?                    
                </comment>
                <comment line="715">
                    Resolve superclass and its ancestors.                    
                </comment>
                <comment line="717">
                    Access to the superclass should be checked relative
                     to the surrounding context, not as if the reference
                     appeared within the class body. Changed &apos;canAccess&apos;
                     to &apos;extendsCanAccess&apos; to fix 4087314.                    
                </comment>
                <comment line="723">
                    Might it be a better recovery to let the access go through?                    
                </comment>
                <comment line="727">
                    Might it be a better recovery to let the access go through?                    
                </comment>
                <comment line="741">
                    If we have a valid superclass, check its
                     supers as well, and so on up to root class.
                     Call to &apos;enclosingClassOf&apos; will raise
                     &apos;NullPointerException&apos; if &apos;def&apos; is null,
                     so omit this check as error recovery.                    
                </comment>
                <comment line="749">
                    Do we need a similar test for
                     interfaces?  See bugid 4038529.                    
                </comment>
                <comment line="755">
                    Since we resolved the superclass and its
                     ancestors above, we should not discover
                     any unresolved classes on the superclass
                     chain.  It should thus be sufficient to
                     call &apos;getSuperClass()&apos; (no argument) here.                    
                </comment>
                <comment line="762">
                    Superclass not resolved due to error.                    
                </comment>
                <comment line="769">
                    Error is detected in call to &apos;getClassDefinition&apos;.
                     The class may actually exist but be ambiguous.
                     Call env.resolve(e.name) to see if it is.
                     env.resolve(name) will definitely tell us if the
                     class is ambiguous, but may not necessarily tell
                     us if the class is not found.
                     (part of solution for 4059855)                    
                </comment>
                <comment line="785">
                    fall through                    
                </comment>
                <comment line="789">
                    The break exits this block                    
                </comment>
                <comment line="793">
                    Superclass was null on entry, after call to
                     &apos;resolveSupers&apos;.  This should normally not happen,
                     as &apos;resolveSupers&apos; sets &apos;superClass&apos; to a non-null
                     value for all named classes, except for one special
                     case: &apos;java.lang.Object&apos;, which has no superclass.                    
                </comment>
                <comment line="799">
                    checker should have filled it in first                    
                </comment>
                <comment line="807">
                    At this point, if &apos;superClass&apos; is null due to an error
                     in the user program, a message should have been issued.                    
                </comment>
                <comment line="811">
                    Check interfaces                    
                </comment>
                <comment line="821">
                    Resolve superinterface and its ancestors.                    
                </comment>
                <comment line="823">
                    Check superinterface access in the correct context.
                     Changed &apos;canAccess&apos; to &apos;extendsCanAccess&apos; to fix 4087314.                    
                </comment>
                <comment line="833">
                    Interface is OK, leave it in the interface list.                    
                </comment>
                <comment line="837">
                    The interface may actually exist but be ambiguous.
                     Call env.resolve(e.name) to see if it is.
                     env.resolve(name) will definitely tell us if the
                     interface is ambiguous, but may not necessarily tell
                     us if the interface is not found.
                     (part of solution for 4059855)                    
                </comment>
                <comment line="852">
                    fall through                    
                </comment>
                <comment line="856">
                    The break exits this block                    
                </comment>
                <comment line="858">
                    Remove this interface from the list of interfaces
                     as recovery from an error.                    
                </comment>
                <scope line="694">
                    <scope line="695">
                        <declaration name="nm" type="Identifier" line="696"/>
                    </scope>
                </scope>
                <scope line="701">
                    <scope line="708">
                        <declaration name="where" type="long" line="709"/>
                        <scope line="711">
                            <declaration name="def" type="ClassDefinition" line="712"/>
                            <scope line="720"/>
                            <scope line="724"/>
                            <scope line="728"/>
                            <scope line="731"/>
                            <scope line="734"/>
                            <scope line="737"/>
                            <scope line="739">
                                <declaration name="sup" type="ClassDefinition" line="745"/>
                                <scope line="746">
                                    <scope line="747"/>
                                    <declaration name="s" type="ClassDeclaration" line="759"/>
                                    <scope line="760"/>
                                </scope>
                            </scope>
                        </scope>
                        <scope line="767">
                            <scope line="775">
                                <scope line="776"/>
                                <scope line="778"/>
                                <scope line="783"/>
                            </scope>
                        </scope>
                    </scope>
                    <scope line="791">
                        <scope line="797"/>
                        <scope line="800"/>
                    </scope>
                </scope>
                <scope line="811">
                    <declaration name="intf" type="ClassDeclaration" line="812"/>
                    <declaration name="where" type="long" line="813"/>
                    <scope line="815"/>
                    <scope line="818">
                        <declaration name="def" type="ClassDefinition" line="819"/>
                        <scope line="824"/>
                        <scope line="826"/>
                        <scope line="828"/>
                        <scope line="830"/>
                    </scope>
                    <scope line="835">
                        <scope line="842">
                            <scope line="843"/>
                            <scope line="845"/>
                            <scope line="850"/>
                        </scope>
                    </scope>
                    <declaration name="newInterfaces" type="ClassDeclaration" line="859"/>
                </scope>
            </method>
            <javadoc line="870">
                Check all of the members of this class.
                  &lt;p&gt;
                  Inner classes are checked in the following way.  Any class which
                  is immediately contained in a block (anonymous and local classes)
                  is checked along with its containing method; see the
                  SourceMember.check() method for more information.  Member classes
                  of this class are checked immediately after this class, unless this
                  class is insideLocal(), in which case, they are checked with the
                  rest of the members.                
            </javadoc>
            <method name="checkMembers" type="Vset" line="882">
                <params>
                    <param name="env" type="Environment"/>
                    <param name="ctx" type="Context"/>
                    <param name="vset" type="Vset"/>
                </params>
                <comment line="885">
                    bail out if there were any errors                    
                </comment>
                <comment line="890">
                    Make sure that all of our member classes have been
                     basicCheck&apos;ed before we check the rest of our members.
                     If our member classes haven&apos;t been basicCheck&apos;ed, then they
                     may not have &lt;init&gt; methods.  It is important that they
                     have &lt;init&gt; methods so we can process NewInstanceExpressions
                     correctly.  This problem didn&apos;t occur before 1.2beta1.
                     This is a fix for bug 4082816.                    
                </comment>
                <comment line="900">
                    System.out.println(&quot;Considering &quot; + f + &quot; in &quot; + this);                    
                </comment>
                <comment line="912">
                    This class should be abstract if there are any abstract methods
                     in our parent classes and interfaces which we do not override.
                     There are odd cases when, even though we cannot access some
                     abstract method from our superclass, that abstract method can
                     still force this class to be abstract.  See the discussion in
                     bug id 1240831.                    
                </comment>
                <comment line="919">
                    Set the class abstract.                    
                </comment>
                <comment line="922">
                    Tell the user which methods force this class to be abstract.                    
                </comment>
                <comment line="924">
                    First list all of the &quot;unimplementable&quot; abstract methods.                    
                </comment>
                <comment line="928">
                    We couldn&apos;t override this method even if we
                     wanted to.  Try to make the error message
                     as non-confusing as possible.                    
                </comment>
                <comment line="936">
                    Now list all of the traditional abstract methods.                    
                </comment>
                <comment line="939">
                    For each method, check if it is abstract.  If it is,
                     output an appropriate error message.                    
                </comment>
                <comment line="950">
                    Check the instance variables in a pre-pass before any constructors.
                     This lets constructors &quot;in-line&quot; any initializers directly.
                     It also lets us do some definite assignment checks on variables.                    
                </comment>
                <comment line="957">
                    Do definite assignment checking on blank finals.
                     Other variables do not need such checks.  The simple textual
                     ordering constraints implemented by MemberDefinition.canReach()
                     are necessary and sufficient for the other variables.
                     Note that within non-static code, all statics are always
                     definitely assigned, and vice-versa.                    
                </comment>
                <comment line="966">
                    The following allocates a LocalMember object as a proxy
                     to represent the field.                    
                </comment>
                <comment line="979">
                    For instance variable checks, use a context with a &quot;this&quot; parameter.                    
                </comment>
                <comment line="985">
                    Do all the initializers in order, checking the definite
                     assignment of blank finals.  Separate static from non-static.                    
                </comment>
                <comment line="1004">
                    Check the rest of the field definitions.
                     (Note:  Re-checking a field is a no-op.)                    
                </comment>
                <comment line="1010">
                    When checking a constructor, an explicit call to
                     &apos;this(...)&apos; makes all blank finals definitely assigned.
                     See &apos;MethodExpression.checkValue&apos;.                    
                </comment>
                <comment line="1014">
                    May issue multiple messages for the same variable!!                    
                </comment>
                <comment line="1016">
                    (drop vsCon here)                    
                </comment>
                <comment line="1019">
                    (drop vsFld here)                    
                </comment>
                <comment line="1026">
                    Must mark class as checked before visiting inner classes,
                     as they may in turn request checking of the current class
                     as an outer class.  Fix for bug id 4056774.                    
                </comment>
                <comment line="1031">
                    Also check other classes in the same nest.
                     All checking of this nest must be finished before any
                     of its classes emit bytecode.
                     Otherwise, the inner classes might not have a chance to
                     add access or class literal fields to the outer class.                    
                </comment>
                <comment line="1046">
                    Note:  Since inner classes cannot set up-level variables,
                     the returned vset is always equal to the passed-in vset.
                     Still, we&apos;ll return it for the sake of regularity.                    
                </comment>
                <scope line="885"/>
                <scope line="897">
                    <scope line="898">
                        <declaration name="cdef" type="SourceClass" line="900"/>
                        <scope line="901"/>
                    </scope>
                </scope>
                <scope line="907"/>
                <scope line="917">
                    <declaration name="iter" type="Iterator" line="924"/>
                    <scope line="925">
                        <declaration name="method" type="MemberDefinition" line="926"/>
                    </scope>
                    <scope line="937">
                        <declaration name="method" type="MemberDefinition" line="940"/>
                        <scope line="941"/>
                    </scope>
                </scope>
                <declaration name="ctxInit" type="Context" line="952"/>
                <declaration name="vsInst" type="Vset" line="953"/>
                <declaration name="vsClass" type="Vset" line="954"/>
                <scope line="963">
                    <scope line="964">
                        <declaration name="number" type="int" line="967"/>
                        <scope line="968"/>
                        <scope line="971"/>
                    </scope>
                </scope>
                <declaration name="ctxInst" type="Context" line="979"/>
                <declaration name="thisArg" type="LocalMember" line="980"/>
                <declaration name="thisNumber" type="int" line="981"/>
                <scope line="987">
                    <scope line="988">
                        <scope line="989">
                            <scope line="990"/>
                            <scope line="992"/>
                        </scope>
                    </scope>
                    <scope line="996"/>
                </scope>
                <scope line="1006">
                    <scope line="1007">
                        <scope line="1008">
                            <declaration name="vsCon" type="Vset" line="1012"/>
                        </scope>
                        <scope line="1016">
                            <declaration name="vsFld" type="Vset" line="1017"/>
                        </scope>
                    </scope>
                    <scope line="1020"/>
                </scope>
                <scope line="1036">
                    <scope line="1037">
                        <declaration name="cdef" type="SourceClass" line="1038"/>
                        <scope line="1039"/>
                    </scope>
                </scope>
            </method>
            <javadoc line="1051">
                Make sure all my blank finals exist now.                
            </javadoc>
            <method name="checkBlankFinals" type="void" line="1054">
                <params>
                    <param name="env" type="Environment"/>
                    <param name="ctxInit" type="Context"/>
                    <param name="vset" type="Vset"/>
                    <param name="isStatic" type="boolean"/>
                </params>
                <scope line="1055">
                    <scope line="1056">
                        <declaration name="ff" type="MemberDefinition" line="1057"/>
                        <scope line="1060"/>
                    </scope>
                </scope>
            </method>
            <declaration name="basicChecking" type="boolean" line="1068"/>
            <javadoc line="1068">
                Check this class has its superclass and its interfaces.  Also
                  force it to have an &lt;init&gt; method (if it doesn&apos;t already have one)
                  and to have all the abstract methods of its parents.                
            </javadoc>
            <declaration name="basicCheckDone" type="boolean" line="1074"/>
            <method name="basicCheck" type="void" line="1075">
                <params>
                    <param name="env" type="Environment"/>
                </params>
                <comment line="1100">
                    Check the existence of the superclass and all interfaces.
                     Also responsible for breaking inheritance cycles.  This call
                     has been moved to &apos;resolveTypeStructure&apos;, just after the call
                     to &apos;resolveSupers&apos;, as inheritance cycles must be broken before
                     resolving types within the members.  Fixes 4073739.
                       checkSupers(env);                    
                </comment>
                <comment line="1109">
                    Add implicit &lt;init&gt; method, if necessary.
                     QUERY:  What keeps us from adding an implicit constructor
                     when the user explicitly declares one?  Is it truly guaranteed
                     that the declaration for such an explicit constructor will have
                     been processed by the time we arrive here?  In general, &apos;basicCheck&apos;
                     is called very early, prior to the normal member checking phase.                    
                </comment>
                <comment line="1119">
                    Default constructors inherit the access modifiers of their
                     class.  For non-inner classes, this follows from JLS 8.6.7,
                     as the only possible modifier is &apos;public&apos;.  For the sake of
                     robustness in the presence of errors, we ignore any other
                     modifiers.  For inner classes, the rule needs to be extended
                     in some way to account for the possibility of private and
                     protected classes.  We make the &apos;obvious&apos; extension, however,
                     the inner classes spec is silent on this issue, and a definitive
                     resolution is needed.  See bugid 4087421.
                     WORKAROUND: A private constructor might need an access method,
                     but it is not possible to create one due to a restriction in
                     the verifier.  (This is a known problem -- see 4015397.)
                     We therefore do not inherit the &apos;private&apos; modifier from the class,
                     allowing the default constructor to be package private.  This
                     workaround can be observed via reflection, but is otherwise
                     undetectable, as the constructor is always accessible within
                     the class in which its containing (private) class appears.                    
                </comment>
                <comment line="1144">
                    Only do the inheritance/override checks if they are turned on.
                     The idea here is that they will be done in javac, but not
                     in javadoc.  See the comment for turnOffChecks(), above.                    
                </comment>
                <comment line="1149">
                    Verify the compatibility of all inherited method definitions
                     by collecting all of our inheritable methods.                    
                </comment>
                <scope line="1081"/>
                <declaration name="imports" type="Imports" line="1092"/>
                <scope line="1093"/>
                <scope line="1106">
                    <scope line="1114">
                        <declaration name="code" type="Node" line="1115"/>
                        <declaration name="t" type="Type" line="1116"/>
                        <declaration name="accessModifiers" type="int" line="1135"/>
                    </scope>
                </scope>
                <scope line="1146"/>
            </method>
            <javadoc line="1158">
                Add a group of methods to this class as miranda methods.
                  For a definition of Miranda methods, see the comment above the
                  method addMirandaMethods() in the file
                  sun/tools/java/ClassDeclaration.java                
            </javadoc>
            <method name="addMirandaMethods" type="void" line="1166">
                <params>
                    <param name="env" type="Environment"/>
                    <param name="mirandas" type="Iterator"/>
                </params>
                <comment line="1175">
                    System.out.println(&quot;adding miranda method &quot; + newMethod +
                                       &quot; to &quot; + this);                    
                </comment>
                <scope line="1168">
                    <declaration name="method" type="MemberDefinition" line="1169"/>
                </scope>
            </method>
            <declaration name="resolving" type="boolean" line="1179"/>
            <javadoc line="1179">
                &lt;em&gt;After parsing is complete&lt;/em&gt;, resolve all names
                  except those inside method bodies or initializers.
                  In particular, this is the point at which we find out what
                  kinds of variables and methods there are in the classes,
                  and therefore what is each class&apos;s interface to the world.
                  &lt;p&gt;
                  Also perform certain other transformations, such as inserting
                  &quot;this$C&quot; arguments into constructors, and reorganizing structure
                  to flatten qualified member names.
                  &lt;p&gt;
                  Do not perform type-based or name-based consistency checks
                  or normalizations (such as default nullary constructors),
                  and do not attempt to compile code against this class,
                  until after this phase.                
            </javadoc>
            <method name="resolveTypeStructure" type="void" line="1198">
                <params>
                    <param name="env" type="Environment"/>
                </params>
                <comment line="1204">
                    Resolve immediately enclosing type, which in turn
                     forces resolution of all enclosing type declarations.                    
                </comment>
                <comment line="1209">
                    Do the outer class first, always.                    
                </comment>
                <comment line="1211">
                    (Note:  this.resolved is probably true at this point.)                    
                </comment>
                <comment line="1214">
                    Punt if we&apos;ve already resolved this class, or are currently
                     in the process of doing so.                    
                </comment>
                <comment line="1222">
                    Previously, &apos;resolved&apos; was set here, and served to prevent
                     duplicate resolutions here as well as its function in
                     &apos;ClassDefinition.addMember&apos;.  Now, &apos;resolving&apos; serves the
                     former purpose, distinct from that of &apos;resolved&apos;.                    
                </comment>
                <comment line="1233">
                    Resolve superclass names to class declarations
                     for the immediate superclass and superinterfaces.                    
                </comment>
                <comment line="1237">
                    Check all ancestor superclasses for various
                     errors, verifying definition of all superclasses
                     and superinterfaces.  Also breaks inheritance cycles.
                     Calls &apos;resolveTypeStructure&apos; recursively for ancestors
                     This call used to appear in &apos;basicCheck&apos;, but was not
                     performed early enough.  Most of the compiler will barf
                     on inheritance cycles!                    
                </comment>
                <comment line="1247">
                    Undefined classes should be reported by &apos;checkSupers&apos;.                    
                </comment>
                <comment line="1259">
                    Mark class as resolved.  If new members are subsequently
                     added to the class, they will be resolved at that time.
                     See &apos;ClassDefinition.addMember&apos;.  Previously, this variable was
                     set prior to the calls to &apos;checkSupers&apos; and &apos;resolveTypeStructure&apos;
                     (which may engender further calls to &apos;checkSupers&apos;).  This could
                     lead to duplicate resolution of implicit constructors, as the call to
                     &apos;basicCheck&apos; from &apos;checkSupers&apos; could add the constructor while
                     its class is marked resolved, and thus would resolve the constructor,
                     believing it to be a &quot;late addition&quot;.  It would then be resolved
                     redundantly during the normal traversal of the members, which
                     immediately follows in the code above.                    
                </comment>
                <comment line="1272">
                    Now we have enough information to detect method repeats.                    
                </comment>
                <declaration name="oc" type="ClassDefinition" line="1205"/>
                <scope line="1207"/>
                <scope line="1215"/>
                <scope line="1243"/>
                <scope line="1245"/>
                <scope line="1251"/>
                <scope line="1273">
                    <scope line="1276">
                        <scope line="1278"/>
                        <scope line="1282"/>
                    </scope>
                </scope>
            </method>
            <method name="resolveSupers" type="void" line="1292">
                <params>
                    <param name="env" type="Environment"/>
                </params>
                <comment line="1296">
                    Find the super class                    
                </comment>
                <comment line="1299">
                    Special-case java.lang.Object here (not in the parser).
                     In all other cases, if we have a valid &apos;superClassId&apos;,
                     we return with a valid and non-null &apos;superClass&apos; value.                    
                </comment>
                <comment line="1308">
                    Find interfaces                    
                </comment>
                <scope line="1296">
                    <scope line="1302"/>
                </scope>
                <scope line="1308">
                    <scope line="1310">
                        <scope line="1312">
                            <scope line="1313">
                                <declaration name="id" type="Identifier" line="1314"/>
                                <declaration name="where" type="long" line="1315"/>
                            </scope>
                        </scope>
                    </scope>
                </scope>
            </method>
            <method name="resolveSuper" type="ClassDeclaration" line="1325">
                <params>
                    <param name="env" type="Environment"/>
                    <param name="t" type="IdentifierToken"/>
                </params>
                <comment line="1335">
                    Result is never null, as a new &apos;ClassDeclaration&apos; is
                     created if one with the given name does not exist.                    
                </comment>
                <declaration name="name" type="Identifier" line="1326"/>
                <declaration name="result" type="ClassDeclaration" line="1333"/>
            </method>
            <javadoc line="1340">
                During the type-checking of an outer method body or initializer,
                  this routine is called to check a local class body
                  in the proper context.                
                <param>
                    sup     the named super class or interface (if anonymous)                    
                </param>
                <param>
                    args    the actual arguments (if anonymous)                    
                </param>
            </javadoc>
            <method name="checkLocalClass" type="Vset" line="1350">
                <params>
                    <param name="env" type="Environment"/>
                    <param name="ctx" type="Context"/>
                    <param name="vset" type="Vset"/>
                    <param name="sup" type="ClassDefinition"/>
                    <param name="args" type="Expression"/>
                    <param name="argTypes" type="Type"/>
                </params>
                <comment line="1361">
                    Run the checks in the lexical context from the outer class.                    
                </comment>
                <comment line="1364">
                    This is now done by &apos;checkInternal&apos; via its call to &apos;checkMembers&apos;.
                     getClassDeclaration().setDefinition(this, CS_CHECKED);                    
                </comment>
                <scope line="1353"/>
                <scope line="1356"/>
            </method>
            <javadoc line="1369">
                As with checkLocalClass, run the inline phase for a local class.                
            </javadoc>
            <method name="inlineLocalClass" type="void" line="1372">
                <params>
                    <param name="env" type="Environment"/>
                </params>
                <comment line="1377">
                    inlined inside of constructors only                    
                </comment>
                <comment line="1387">
                    add more constructor arguments for uplevel references                    
                </comment>
                <comment line="1391">
                    ((SourceMember)f).addUplevelArguments(false);                    
                </comment>
                <scope line="1374">
                    <scope line="1375"/>
                    <scope line="1378"/>
                    <scope line="1380"/>
                </scope>
                <scope line="1384">
                    <scope line="1388">
                        <scope line="1389"/>
                    </scope>
                </scope>
            </method>
            <declaration name="inlinedLocalClass" type="boolean" line="1396"/>
            <javadoc line="1398">
                Check a class which is inside a local class, but is not itself local.                
            </javadoc>
            <method name="checkInsideClass" type="Vset" line="1402">
                <params>
                    <param name="env" type="Environment"/>
                    <param name="ctx" type="Context"/>
                    <param name="vset" type="Vset"/>
                </params>
                <scope line="1403"/>
            </method>
            <javadoc line="1409">
                Just before checking an anonymous class, decide its true
                  inheritance, and build its (sole, implicit) constructor.                
            </javadoc>
            <method name="resolveAnonymousStructure" type="void" line="1416">
                <params>
                    <param name="env" type="Environment"/>
                    <param name="sup" type="ClassDefinition"/>
                    <param name="args" type="Expression"/>
                    <param name="argTypes" type="Type"/>
                </params>
                <comment line="1422">
                    Decide now on the superclass.                    
                </comment>
                <comment line="1424">
                    This check has been removed as part of the fix for 4055017.
                     In the anonymous class created to hold the &apos;class$&apos; method
                     of an interface, &apos;superClassId&apos; refers to &apos;java.lang.Object&apos;.                    
                </comment>
                <comment line="1427">
                    ---------------------
                    if (!(superClass == null &amp;&amp; superClassId.getName() == idNull)) {
                    throw new CompilerError(&quot;superclass &quot;+superClass);
                    }                    
                </comment>
                <comment line="1434">
                    allow an interface in the &quot;super class&quot; position                    
                </comment>
                <comment line="1456">
                    Synthesize an appropriate constructor.                    
                </comment>
                <comment line="1481">
                    ISSUE: make M_PRIVATE, with wrapper?                    
                </comment>
                <scope line="1432">
                    <declaration name="ni" type="int" line="1434"/>
                    <declaration name="i1" type="ClassDeclaration" line="1435"/>
                    <scope line="1436">
                        <scope line="1438">
                            <declaration name="id1" type="IdentifierToken" line="1439"/>
                        </scope>
                    </scope>
                </scope>
                <scope line="1451"/>
                <declaration name="t" type="Type" line="1456"/>
                <declaration name="names" type="IdentifierToken" line="1457"/>
                <scope line="1458"/>
                <declaration name="outerArg" type="int" line="1462"/>
                <declaration name="superArgs" type="Expression" line="1463"/>
                <scope line="1464"/>
                <declaration name="where" type="long" line="1467"/>
                <declaration name="superExp" type="Expression" line="1468"/>
                <scope line="1469"/>
                <scope line="1471"/>
                <declaration name="superCall" type="Expression" line="1475"/>
                <declaration name="body" type="Statement" line="1478"/>
                <declaration name="code" type="Node" line="1479"/>
                <declaration name="mod" type="int" line="1480"/>
            </method>
            <declaration name="classModifierBits" type="int" line="1485"/>
            <javadoc line="1485">
                Convert class modifiers to a string for diagnostic purposes.
                  Accepts modifiers applicable to inner classes and that appear
                  in the InnerClasses attribute only, as well as those that may
                  appear in the class modifier proper.                
            </javadoc>
            <declaration name="classModifierNames" type="String" line="1497"/>
            <method name="classModifierString" type="String" line="1502">
                <params>
                    <param name="mods" type="int"/>
                </params>
                <declaration name="s" type="String" line="1503"/>
                <scope line="1504">
                    <scope line="1505"/>
                </scope>
                <scope line="1510"/>
            </method>
            <javadoc line="1516">
                Find or create an access method for a private member,
                  or return null if this is not possible.                
            </javadoc>
            <method name="getAccessMember" type="MemberDefinition" line="1521">
                <params>
                    <param name="env" type="Environment"/>
                    <param name="ctx" type="Context"/>
                    <param name="field" type="MemberDefinition"/>
                    <param name="isSuper" type="boolean"/>
                </params>
            </method>
            <method name="getUpdateMember" type="MemberDefinition" line="1526">
                <params>
                    <param name="env" type="Environment"/>
                    <param name="ctx" type="Context"/>
                    <param name="field" type="MemberDefinition"/>
                    <param name="isSuper" type="boolean"/>
                </params>
                <scope line="1527"/>
            </method>
            <method name="getAccessMember" type="MemberDefinition" line="1536">
                <params>
                    <param name="env" type="Environment"/>
                    <param name="ctx" type="Context"/>
                    <param name="field" type="MemberDefinition"/>
                    <param name="isUpdate" type="boolean"/>
                    <param name="isSuper" type="boolean"/>
                </params>
                <comment line="1539">
                    The &apos;isSuper&apos; argument is really only meaningful when the
                     target member is a method, in which case an &apos;invokespecial&apos;
                     is needed.  For fields, &apos;getfield&apos; and &apos;putfield&apos; instructions
                     are generated in either case, and &apos;isSuper&apos; currently plays
                     no essential role.  Nonetheless, we maintain the distinction
                     consistently for the time being.                    
                </comment>
                <comment line="1549">
                    Find pre-existing access method.
                     In the case of a field access method, we only look for the getter.
                     A getter is always created whenever a setter is.
                     QUERY: Why doesn&apos;t the &apos;MemberDefinition&apos; object for the field
                     itself just have fields for its getter and setter?                    
                </comment>
                <comment line="1560">
                    Distinguish the getter and the setter by the number of
                     arguments.                    
                </comment>
                <comment line="1563">
                    This was (nargs == (isStatic ? 0 : 1) + (isUpdate ? 1 : 0))
                     in order to find a setter as well as a getter.  This caused
                     allocation of multiple getters.                    
                </comment>
                <comment line="1582">
                    must find or create the getter before creating the setter                    
                </comment>
                <comment line="1586">
                    If we arrive here, we are creating a new access member.                    
                </comment>
                <comment line="1592">
                    For a constructor, we use the same name as for all
                     constructors (&quot;&lt;init&gt;&quot;), but add a distinguishing
                     argument of an otherwise unused &quot;dummy&quot; type.                    
                </comment>
                <comment line="1596">
                    Get the dummy class, creating it if necessary.                    
                </comment>
                <comment line="1600">
                    Create dummy class.                    
                </comment>
                <comment line="1606">
                    If an interface has a public inner class, the dummy class for
                     the constructor must always be accessible. Fix for 4221648.                    
                </comment>
                <comment line="1616">
                    Check the class.
                     It is likely that a full check is not really necessary,
                     but it is essential that the class be marked as parsed.                    
                </comment>
                <comment line="1628">
                    Get class type.                    
                </comment>
                <comment line="1633">
                    Otherwise, we use the name &quot;access$N&quot;, for the
                     smallest value of N &gt;= 0 yielding an unused name.                    
                </comment>
                <comment line="1651">
                    nullary getter                    
                </comment>
                <comment line="1655">
                    unary setter                    
                </comment>
                <comment line="1658">
                    Since constructors are never static, we don&apos;t
                     have to worry about a dummy argument here.                    
                </comment>
                <comment line="1663">
                    All access methods for non-static members get an explicit
                     &apos;this&apos; pointer as an extra argument, as the access methods
                     themselves must be static. EXCEPTION: Access methods for
                     constructors are non-static.                    
                </comment>
                <comment line="1672">
                    nullary getter                    
                </comment>
                <comment line="1676">
                    unary setter                    
                </comment>
                <comment line="1679">
                    Target is a method, possibly a constructor.                    
                </comment>
                <comment line="1683">
                    Access method is a constructor.
                     Requires a dummy argument.                    
                </comment>
                <comment line="1688">
                    Outer instance link must be the first argument.
                     The following is a sanity check that will catch
                     most cases in which in this requirement is violated.                    
                </comment>
                <comment line="1694">
                    Strip outer &apos;this&apos; argument.
                     It will be added back when the access method is checked.                    
                </comment>
                <comment line="1702">
                    There is no outer instance.                    
                </comment>
                <comment line="1710">
                    Access method is static.
                     Requires an explicit &apos;this&apos; argument.                    
                </comment>
                <comment line="1740">
                    Constructor access method is non-static, so
                     &apos;this&apos; works normally.                    
                </comment>
                <comment line="1743">
                    Remove dummy argument, as it is not
                     passed to the target method.                    
                </comment>
                <comment line="1750">
                    Non-constructor access method is static, so
                     we use the first argument as &apos;this&apos;.                    
                </comment>
                <comment line="1753">
                    Remove first argument.                    
                </comment>
                <comment line="1768">
                    If true, &apos;isSuper&apos; forces a non-virtual call.                    
                </comment>
                <comment line="1781">
                    Access methods are now static (constructors excepted), and no longer final.
                     This change was mandated by the interaction of the access method
                     naming conventions and the restriction against overriding final
                     methods.                    
                </comment>
                <comment line="1790">
                    Create the synthetic method within the class in which the referenced
                     private member appears.  The &apos;env&apos; argument to &apos;makeMemberDefinition&apos;
                     is suspect because it represents the environment at the point at
                     which a reference takes place, while it should represent the
                     environment in which the definition of the synthetic method appears.
                     We get away with this because &apos;env&apos; is used only to access globals
                     such as &apos;Environment.error&apos;, and also as an argument to
                     &apos;resolveTypeStructure&apos;, which immediately discards it using
                     &apos;setupEnv&apos;. Apparently, the current definition of &apos;setupEnv&apos;
                     represents a design change that has not been thoroughly propagated.
                     An access method is declared with same list of exceptions as its
                     target. As the exceptions are simply listed by name, the correctness
                     of this approach requires that the access method be checked
                     (name-resolved) in the same context as its target method  This
                     should always be the case.                    
                </comment>
                <comment line="1809">
                    Just to be safe, copy over the name-resolved exceptions from the
                     target so that the context in which the access method is checked
                     doesn&apos;t matter.                    
                </comment>
                <comment line="1820">
                    The call to &apos;check&apos; is not needed, as the access method will be
                     checked by the containing class after it is added.  This is the
                     idiom followed in the implementation of class literals. (See
                     &apos;FieldExpression.java&apos;.) In any case, the context is wrong in the
                     call below.  The access method must be checked in the context in
                     which it is declared, i.e., the class containing the referenced
                     private member, not the (inner) class in which the original member
                     reference occurs.
                    
                     try {
                         newf.check(env, ctx, new Vset());
                     } catch (ClassNotFound ee) {
                         env.error(where, &quot;class.not.found&quot;, ee.name, this);
                     }                    
                </comment>
                <comment line="1835">
                    The comment above is inaccurate.  While it is often the case
                     that the containing class will check the access method, this is
                     by no means guaranteed.  In fact, an access method may be added
                     after the checking of its class is complete.  In this case, however,
                     the context in which the class was checked will have been saved in
                     the class definition object (by the fix for 4095716), allowing us
                     to check the field now, and in the correct context.
                     This fixes bug 4098093.                    
                </comment>
                <comment line="1846">
                    System.out.println(&quot;checking late addition: &quot; + this);                    
                </comment>
                <comment line="1855">
                    System.out.println(&quot;[Access member &apos;&quot; +
                                          newf + &quot;&apos; created for field &apos;&quot; +
                                          field +&quot;&apos; in class &apos;&quot; + this + &quot;&apos;]&quot;);                    
                </comment>
                <declaration name="isStatic" type="boolean" line="1545"/>
                <declaration name="isMethod" type="boolean" line="1546"/>
                <declaration name="af" type="MemberDefinition" line="1553"/>
                <scope line="1554">
                    <scope line="1555">
                        <scope line="1556"/>
                        <declaration name="nargs" type="int" line="1561"/>
                        <scope line="1565"/>
                    </scope>
                </scope>
                <scope line="1571">
                    <scope line="1572"/>
                    <scope line="1574">
                        <declaration name="uf" type="MemberDefinition" line="1575"/>
                        <scope line="1576"/>
                    </scope>
                </scope>
                <scope line="1580"/>
                <declaration name="anm" type="Identifier" line="1587"/>
                <declaration name="dummyType" type="Type" line="1588"/>
                <scope line="1590">
                    <declaration name="outerMostClass" type="SourceClass" line="1596"/>
                    <scope line="1598">
                        <declaration name="sup" type="IdentifierToken" line="1600"/>
                        <declaration name="interfaces" type="IdentifierToken" line="1602"/>
                        <declaration name="t" type="IdentifierToken" line="1603"/>
                        <declaration name="mod" type="int" line="1604"/>
                        <scope line="1607"/>
                        <declaration name="dummyClass" type="ClassDefinition" line="1610"/>
                        <declaration name="argsX" type="Expression" line="1619"/>
                        <declaration name="argTypesX" type="Type" line="1620"/>
                        <scope line="1621">
                            <declaration name="supcls" type="ClassDefinition" line="1622"/>
                        </scope>
                        <scope line="1626"/>
                    </scope>
                </scope>
                <scope line="1631">
                    <scope line="1634">
                        <scope line="1636"/>
                    </scope>
                </scope>
                <declaration name="argTypes" type="Type" line="1642"/>
                <declaration name="t" type="Type" line="1643"/>
                <scope line="1645">
                    <scope line="1646">
                        <scope line="1647">
                            <declaration name="at" type="Type" line="1648"/>
                        </scope>
                        <scope line="1651">
                            <declaration name="at" type="Type" line="1652"/>
                        </scope>
                    </scope>
                    <scope line="1656"/>
                </scope>
                <scope line="1661">
                    <declaration name="classType" type="Type" line="1666"/>
                    <scope line="1667">
                        <scope line="1668">
                            <declaration name="at" type="Type" line="1669"/>
                        </scope>
                        <scope line="1672">
                            <declaration name="at" type="Type" line="1673"/>
                        </scope>
                    </scope>
                    <scope line="1677">
                        <declaration name="at" type="Type" line="1679"/>
                        <declaration name="nargs" type="int" line="1680"/>
                        <scope line="1681">
                            <declaration name="outerThisArg" type="MemberDefinition" line="1684"/>
                            <scope line="1686">
                                <scope line="1690"/>
                                <scope line="1697"/>
                            </scope>
                            <scope line="1700">
                                <scope line="1704"/>
                            </scope>
                        </scope>
                        <scope line="1708">
                            <scope line="1713"/>
                        </scope>
                    </scope>
                </scope>
                <declaration name="nlen" type="int" line="1721"/>
                <declaration name="where" type="long" line="1722"/>
                <declaration name="names" type="IdentifierToken" line="1723"/>
                <scope line="1724"/>
                <declaration name="access" type="Expression" line="1728"/>
                <declaration name="thisArg" type="Expression" line="1729"/>
                <declaration name="args" type="Expression" line="1730"/>
                <scope line="1732">
                    <scope line="1734"/>
                </scope>
                <scope line="1737">
                    <scope line="1738">
                        <scope line="1745"/>
                    </scope>
                    <scope line="1748">
                        <scope line="1754"/>
                    </scope>
                </scope>
                <scope line="1761">
                    <scope line="1763"/>
                </scope>
                <scope line="1766"/>
                <declaration name="code" type="Statement" line="1771"/>
                <scope line="1772"/>
                <scope line="1774"/>
                <declaration name="body" type="Statement" line="1777"/>
                <declaration name="mod" type="int" line="1784"/>
                <scope line="1785"/>
                <declaration name="newf" type="SourceMember" line="1804"/>
                <scope line="1814"/>
                <declaration name="checkContext" type="Context" line="1843"/>
                <scope line="1844">
                    <scope line="1846"/>
                    <scope line="1848"/>
                </scope>
            </method>
            <javadoc line="1861">
                Find an inner class of &apos;this&apos;, chosen arbitrarily.
                  Result is always an actual class, never an interface.
                  Returns null if none found.                
            </javadoc>
            <method name="findLookupContext" type="SourceClass" line="1866">
                <comment line="1868">
                    Look for an immediate inner class.                    
                </comment>
                <comment line="1879">
                    Look for a class nested within an immediate inner interface.
                     At this point, we have given up on finding a minimally-nested
                     class (which would require a breadth-first traversal).  It doesn&apos;t
                     really matter which inner class we find.                    
                </comment>
                <comment line="1894">
                    No inner classes.                    
                </comment>
                <scope line="1870">
                    <scope line="1871">
                        <declaration name="ic" type="SourceClass" line="1872"/>
                        <scope line="1873"/>
                    </scope>
                </scope>
                <scope line="1884">
                    <scope line="1885">
                        <declaration name="lc" type="SourceClass" line="1886"/>
                        <scope line="1888"/>
                    </scope>
                </scope>
            </method>
            <declaration name="lookup" type="MemberDefinition" line="1897"/>
            <javadoc line="1899">
                Get helper method for class literal lookup.                
            </javadoc>
            <method name="getClassLiteralLookup" type="MemberDefinition" line="1902">
                <params>
                    <param name="fwhere" type="long"/>
                </params>
                <comment line="1905">
                    If we have already created a lookup method, reuse it.                    
                </comment>
                <comment line="1910">
                    If the current class is a nested class, make sure we put the
                     lookup method in the outermost class.  Set &apos;lookup&apos; for the
                     intervening inner classes so we won&apos;t have to do the search
                     again.                    
                </comment>
                <comment line="1919">
                    If we arrive here, there was no existing &apos;class$&apos; method.                    
                </comment>
                <comment line="1925">
                    The top-level type is an interface.  Try to find an existing
                     inner class in which to create the helper method.  Any will do.                    
                </comment>
                <comment line="1929">
                    The interface has no inner classes.  Create an anonymous
                     inner class to hold the helper method, as an interface must
                     not have any methods.  The tests above for prior creation
                     of a &apos;class$&apos; method assure that only one such class is
                     allocated for each outermost class containing a class
                     literal embedded somewhere within.  Part of fix for 4055017.                    
                </comment>
                <comment line="1949">
                    The name of the class-getter stub is &quot;class$&quot;                    
                </comment>
                <comment line="1953">
                    Some sanity checks of questionable value.
                    
                     This check became useless after matchMethod() was modified
                     to not return synthetic methods.
                    
                    try {
                        lookup = c.matchMethod(toplevelEnv, c, idDClass, strarg);
                    } catch (ClassNotFound ee) {
                        throw new CompilerError(&quot;unexpected missing class&quot;);
                    } catch (AmbiguousMember ee) {
                        throw new CompilerError(&quot;synthetic name clash&quot;);
                    }
                    if (lookup != null &amp;&amp; lookup.getClassDefinition() == c) {
                         Error if method found was not inherited.
                        throw new CompilerError(&quot;unexpected duplicate&quot;);
                    }
                     Some sanity checks of questionable value.                    
                </comment>
                <comment line="1971">
                    The helper function looks like this.
                       It simply maps a checked exception to an unchecked one.
                      static Class class$(String class$) {
                        try { return Class.forName(class$); }
                        catch (ClassNotFoundException forName) {
                          throw new NoClassDefFoundError(forName.getMessage());
                        }
                      }                    
                </comment>
                <comment line="1988">
                    map the exceptions                    
                </comment>
                <comment line="2009">
                    Use default (package) access.  If private, an access method would
                     be needed in the event that the class literal belonged to an interface.
                     Also, making it private tickles bug 4098316.                    
                </comment>
                <comment line="2018">
                    If a new class was created to contain the helper method,
                     check it now.                    
                </comment>
                <scope line="1905"/>
                <scope line="1913"/>
                <declaration name="c" type="ClassDefinition" line="1920"/>
                <declaration name="needNewClass" type="boolean" line="1921"/>
                <scope line="1923">
                    <scope line="1927">
                        <declaration name="sup" type="IdentifierToken" line="1935"/>
                        <declaration name="interfaces" type="IdentifierToken" line="1937"/>
                        <declaration name="t" type="IdentifierToken" line="1938"/>
                        <declaration name="mod" type="int" line="1939"/>
                    </scope>
                </scope>
                <declaration name="idDClass" type="Identifier" line="1949"/>
                <declaration name="strarg" type="Type" line="1950"/>
                <declaration name="w" type="long" line="1979"/>
                <declaration name="arg" type="IdentifierToken" line="1980"/>
                <declaration name="e" type="Expression" line="1981"/>
                <declaration name="a1" type="Expression" line="1982"/>
                <declaration name="idForName" type="Identifier" line="1983"/>
                <declaration name="body" type="Statement" line="1986"/>
                <declaration name="idClassNotFound" type="Identifier" line="1988"/>
                <declaration name="idNoClassDefFound" type="Identifier" line="1990"/>
                <declaration name="ctyp" type="Type" line="1992"/>
                <declaration name="exptyp" type="Type" line="1993"/>
                <declaration name="idGetMessage" type="Identifier" line="1994"/>
                <declaration name="a2" type="Expression" line="1997"/>
                <declaration name="handler" type="Statement" line="1999"/>
                <declaration name="handlers" type="Statement" line="2002"/>
                <declaration name="mtype" type="Type" line="2005"/>
                <declaration name="args" type="IdentifierToken" line="2006"/>
                <scope line="2019">
                    <scope line="2020"/>
                    <declaration name="argsX" type="Expression" line="2024"/>
                    <declaration name="argTypesX" type="Type" line="2025"/>
                    <scope line="2026">
                        <declaration name="sup" type="ClassDefinition" line="2027"/>
                    </scope>
                    <scope line="2031"/>
                </scope>
            </method>
            <declaration name="active" type="Vector" line="2038"/>
            <javadoc line="2038">
                A list of active ongoing compilations. This list
                  is used to stop two compilations from saving the
                  same class.                
            </javadoc>
            <javadoc line="2045">
                Compile this class                
            </javadoc>
            <method name="compile" type="void" line="2049">
                <params>
                    <param name="out" type="OutputStream"/>
                </params>
                <declaration name="env" type="Environment" line="2050"/>
                <scope line="2051">
                    <scope line="2052"/>
                </scope>
                <scope line="2058"/>
                <scope line="2060"/>
                <scope line="2062">
                    <scope line="2063"/>
                </scope>
            </method>
            <javadoc line="2070">
                Verify that the modifier bits included in &apos;required&apos; are
                  all present in &apos;mods&apos;, otherwise signal an internal error.
                  Note that errors in the source program may corrupt the modifiers,
                  thus we rely on the fact that &apos;CompilerError&apos; exceptions are
                  silently ignored after an error message has been issued.                
            </javadoc>
            <method name="assertModifiers" type="void" line="2077">
                <params>
                    <param name="mods" type="int"/>
                    <param name="required" type="int"/>
                </params>
                <scope line="2078"/>
            </method>
            <method name="compileClass" type="void" line="2084">
                <params>
                    <param name="env" type="Environment"/>
                    <param name="out" type="OutputStream"/>
                </params>
                <comment line="2095">
                    Reverse the order, so that outer levels come first:                    
                </comment>
                <comment line="2102">
                    System.out.println(&quot;compile class &quot; + getName());                    
                </comment>
                <comment line="2109">
                    Generate code for all fields                    
                </comment>
                <comment line="2114">
                    System.out.println(&quot;compile field &quot; + field.getName());                    
                </comment>
                <comment line="2159">
                    bail out if there were any errors                    
                </comment>
                <comment line="2166">
                    Insert constants                    
                </comment>
                <comment line="2201">
                    JCOV                    
                </comment>
                <comment line="2203">
                    AbsoluteSourcePath, TimeStamp                    
                </comment>
                <comment line="2208">
                    end JCOV                    
                </comment>
                <comment line="2214">
                    InnerClasses                    
                </comment>
                <comment line="2217">
                    JCOV                    
                </comment>
                <comment line="2226">
                    end JCOV                    
                </comment>
                <comment line="2235">
                    Sort the methods in order to make sure both constant pool
                     entries and methods are in a deterministic order from run
                     to run (this allows comparing class files for a fixed point
                     to validate the compiler)                    
                </comment>
                <comment line="2246">
                    Optimize Code and Collect method constants                    
                </comment>
                <comment line="2265">
                    Collect field constants                    
                </comment>
                <comment line="2277">
                    Collect inner class constants                    
                </comment>
                <comment line="2283">
                    If the inner class is local, we do not need to add its
                     outer class here -- the outer_class_info_index is zero.                    
                </comment>
                <comment line="2290">
                    If the local name of the class is idNull, don&apos;t bother to
                     add it to the constant pool.  We won&apos;t need it.                    
                </comment>
                <comment line="2298">
                    Write header                    
                </comment>
                <comment line="2305">
                    Write class information                    
                </comment>
                <comment line="2308">
                    Certain modifiers are implied:
                     1.  Any interface (nested or not) is implicitly deemed to be abstract,
                         whether it is explicitly marked so or not.  (Java 1.0.)
                     2.  A interface which is a member of a type is implicitly deemed to
                         be static, whether it is explicitly marked so or not.
                     3a. A type which is a member of an interface is implicitly deemed
                         to be public, whether it is explicitly marked so or not.
                     3b. A type which is a member of an interface is implicitly deemed
                         to be static, whether it is explicitly marked so or not.
                     All of these rules are implemented in &apos;BatchParser.beginClass&apos;,
                     but the results are verified here.                    
                </comment>
                <comment line="2321">
                    Rule 1.
                     The VM spec states that ACC_ABSTRACT must be set when
                     ACC_INTERFACE is; this was not done by javac prior to 1.2,
                     and the runtime compensates by setting it.  Making sure
                     it is set here will allow the runtime hack to eventually
                     be removed. Rule 2 doesn&apos;t apply to transformed modifiers.                    
                </comment>
                <comment line="2329">
                    Contrary to the JVM spec, we only set ACC_SUPER for classes,
                     not interfaces.  This is a workaround for a bug in IE3.0,
                     which refuses interfaces with ACC_SUPER on.                    
                </comment>
                <comment line="2335">
                    If this is a nested class, transform access modifiers.                    
                </comment>
                <comment line="2337">
                    If private, transform to default (package) access.
                     If protected, transform to public.
                     M_PRIVATE and M_PROTECTED are already masked off by MM_CLASS above.
                     cmods &amp;= ~(M_PRIVATE | M_PROTECTED);                    
                </comment>
                <comment line="2342">
                    Rule 3a.  Note that Rule 3b doesn&apos;t apply to transformed modifiers.                    
                </comment>
                <comment line="2366">
                    write variables                    
                </comment>
                <comment line="2401">
                    write methods                    
                </comment>
                <comment line="2408">
                    Transform floating point modifiers.  M_STRICTFP
                     of member + status of enclosing class turn into
                     ACC_STRICT bit.                    
                </comment>
                <comment line="2414">
                    Use the default                    
                </comment>
                <comment line="2436">
                    JCOV                    
                </comment>
                <comment line="2440">
                    end JCOV                    
                </comment>
                <comment line="2454">
                    JCOV                    
                </comment>
                <comment line="2462">
                    end JCOV                    
                </comment>
                <comment line="2476">
                    JCOV                    
                </comment>
                <comment line="2479">
                    end JCOV                    
                </comment>
                <comment line="2501">
                    class attributes                    
                </comment>
                <comment line="2519">
                    JCOV                    
                </comment>
                <comment line="2528">
                    end JCOV                    
                </comment>
                <comment line="2536">
                    For each inner class name transformation, we have a record
                     with the following fields:
                    
                        u2 inner_class_info_index;    CONSTANT_Class_info index
                        u2 outer_class_info_index;    CONSTANT_Class_info index
                        u2 inner_name_index;          CONSTANT_Utf8_info index
                        u2 inner_class_access_flags;  access_flags bitmask
                    
                     The spec states that outer_class_info_index is 0 iff
                     the inner class is not a member of its enclosing class (i.e.
                     it is a local or anonymous class).  The spec also states
                     that if a class is anonymous then inner_name_index should
                     be 0.
                    
                     See also the initInnerClasses() method in BinaryClass.java.                    
                </comment>
                <comment line="2552">
                    Generate inner_class_info_index.                    
                </comment>
                <comment line="2556">
                    Generate outer_class_info_index.
                    
                     Checking isLocal() should probably be enough here,
                     but the check for isAnonymous is added for good
                     measure.                    
                </comment>
                <comment line="2564">
                    Query: what about if inner.isInsideLocal()?
                     For now we continue to generate a nonzero
                     outer_class_info_index.                    
                </comment>
                <comment line="2571">
                    Generate inner_name_index.                    
                </comment>
                <comment line="2582">
                    Generate inner_class_access_flags.                    
                </comment>
                <comment line="2586">
                    Certain modifiers are implied for nested types.
                     See rules 1, 2, 3a, and 3b enumerated above.
                     All of these rules are implemented in &apos;BatchParser.beginClass&apos;,
                     but are verified here.                    
                </comment>
                <comment line="2592">
                    Rules 1 and 2.                    
                </comment>
                <comment line="2596">
                    Rules 3a and 3b.                    
                </comment>
                <comment line="2597">
                    error recovery                    
                </comment>
                <comment line="2614">
                    Cleanup                    
                </comment>
                <comment line="2618">
                    JCOV                    
                </comment>
                <comment line="2619">
                    generate coverage data                    
                </comment>
                <comment line="2624">
                    end JCOV                    
                </comment>
                <declaration name="variables" type="Vector" line="2085"/>
                <declaration name="methods" type="Vector" line="2086"/>
                <declaration name="innerClasses" type="Vector" line="2087"/>
                <declaration name="init" type="CompilerMember" line="2088"/>
                <declaration name="ctx" type="Context" line="2089"/>
                <scope line="2091"/>
                <declaration name="ncsize" type="int" line="2095"/>
                <declaration name="haveDeprecated" type="boolean" line="2103"/>
                <declaration name="haveSynthetic" type="boolean" line="2104"/>
                <declaration name="haveConstantValue" type="boolean" line="2105"/>
                <declaration name="haveExceptions" type="boolean" line="2106"/>
                <scope line="2111">
                    <scope line="2118">
                        <scope line="2119">
                            <scope line="2123">
                                <scope line="2124"/>
                            </scope>
                            <scope line="2127">
                                <declaration name="f" type="CompilerMember" line="2128"/>
                            </scope>
                        </scope>
                        <scope line="2133"/>
                        <scope line="2135">
                            <declaration name="f" type="CompilerMember" line="2137"/>
                            <scope line="2139"/>
                        </scope>
                    </scope>
                    <scope line="2146"/>
                </scope>
                <scope line="2153"/>
                <scope line="2159"/>
                <declaration name="nClassAttrs" type="int" line="2163"/>
                <scope line="2166"/>
                <scope line="2169"/>
                <declaration name="sourceFile" type="String" line="2173"/>
                <scope line="2174"/>
                <scope line="2181"/>
                <scope line="2185"/>
                <scope line="2188">
                    <scope line="2190"/>
                </scope>
                <scope line="2194">
                    <scope line="2196"/>
                </scope>
                <scope line="2201"/>
                <scope line="2208"/>
                <scope line="2211"/>
                <declaration name="absoluteSourcePath" type="String" line="2217"/>
                <declaration name="timeStamp" type="long" line="2218"/>
                <scope line="2220"/>
                <scope line="2227"/>
                <scope line="2230"/>
                <declaration name="ordered_methods" type="CompilerMember[]" line="2238"/>
                <scope line="2246">
                    <declaration name="f" type="CompilerMember" line="2247"/>
                    <scope line="2248">
                        <declaration name="exp" type="ClassDeclaration" line="2253"/>
                        <scope line="2254"/>
                    </scope>
                    <scope line="2257"/>
                </scope>
                <scope line="2265">
                    <declaration name="f" type="CompilerMember" line="2266"/>
                    <declaration name="val" type="Object" line="2270"/>
                    <scope line="2271"/>
                </scope>
                <scope line="2278">
                    <declaration name="inner" type="ClassDefinition" line="2279"/>
                    <scope line="2284">
                        <declaration name="outer" type="ClassDefinition" line="2285"/>
                    </scope>
                    <declaration name="inner_local_name" type="Identifier" line="2291"/>
                    <scope line="2292"/>
                </scope>
                <declaration name="data" type="DataOutputStream" line="2298"/>
                <declaration name="cmods" type="int" line="2305"/>
                <scope line="2319"/>
                <scope line="2327"/>
                <scope line="2335">
                    <scope line="2342"/>
                </scope>
                <scope line="2349">
                    <declaration name="cn" type="Identifier" line="2350"/>
                    <declaration name="nm" type="Identifier" line="2351"/>
                </scope>
                <scope line="2361"/>
                <declaration name="buf" type="ByteArrayOutputStream" line="2366"/>
                <declaration name="attbuf" type="ByteArrayOutputStream" line="2367"/>
                <declaration name="databuf" type="DataOutputStream" line="2368"/>
                <scope line="2371">
                    <declaration name="f" type="CompilerMember" line="2372"/>
                    <declaration name="val" type="Object" line="2373"/>
                    <declaration name="fieldAtts" type="int" line="2379"/>
                    <declaration name="dep" type="boolean" line="2380"/>
                    <declaration name="syn" type="boolean" line="2381"/>
                    <scope line="2385"/>
                    <scope line="2390"/>
                    <scope line="2394"/>
                </scope>
                <scope line="2403">
                    <declaration name="f" type="CompilerMember" line="2404"/>
                    <declaration name="xmods" type="int" line="2406"/>
                    <scope line="2410"/>
                    <scope line="2412">
                        <scope line="2414"/>
                    </scope>
                    <declaration name="exp" type="ClassDeclaration" line="2422"/>
                    <declaration name="methodAtts" type="int" line="2423"/>
                    <declaration name="dep" type="boolean" line="2424"/>
                    <declaration name="syn" type="boolean" line="2425"/>
                    <scope line="2428">
                        <declaration name="natts" type="int" line="2431"/>
                        <scope line="2432"/>
                        <scope line="2436"/>
                        <scope line="2440"/>
                        <scope line="2445"/>
                        <scope line="2454"/>
                        <scope line="2462"/>
                    </scope>
                    <scope line="2474"/>
                    <scope line="2482">
                        <scope line="2486"/>
                    </scope>
                    <scope line="2490"/>
                    <scope line="2494"/>
                </scope>
                <scope line="2503"/>
                <scope line="2509"/>
                <scope line="2513"/>
                <scope line="2519"/>
                <scope line="2529">
                    <scope line="2534">
                        <declaration name="inner" type="ClassDefinition" line="2552"/>
                        <scope line="2560"/>
                        <scope line="2562">
                            <declaration name="outer" type="ClassDefinition" line="2566"/>
                        </scope>
                        <declaration name="inner_name" type="Identifier" line="2571"/>
                        <scope line="2572">
                            <scope line="2573"/>
                        </scope>
                        <scope line="2577"/>
                        <declaration name="imods" type="int" line="2582"/>
                        <scope line="2590"/>
                        <scope line="2594"/>
                        <scope line="2602">
                            <declaration name="fn" type="Identifier" line="2603"/>
                            <declaration name="nm" type="Identifier" line="2604"/>
                        </scope>
                    </scope>
                </scope>
                <scope line="2619">
                    <declaration name="CovAsm" type="Assembler" line="2620"/>
                </scope>
            </method>
            <javadoc line="2626">
                Print out the dependencies for this class (-xdepend) option                
            </javadoc>
            <method name="printClassDependencies" type="void" line="2630">
                <params>
                    <param name="env" type="Environment"/>
                </params>
                <comment line="2633">
                    Only do this if the -xdepend flag is on                    
                </comment>
                <comment line="2636">
                    Name of java source file this class was in (full path)
                        e.g. /home/ohair/Test.java                    
                </comment>
                <comment line="2640">
                    Class name, fully qualified
                       e.g. &quot;java.lang.Object&quot; or &quot;FooBar&quot; or &quot;sun.tools.javac.Main&quot;
                     Inner class names must be mangled, as ordinary &apos;.&apos; qualification
                     is used internally where the spec requires &apos;$&apos; separators.
                       String className = getName().toString();                    
                </comment>
                <comment line="2647">
                    Line number where class starts in the src file                    
                </comment>
                <comment line="2650">
                    Line number where class ends in the src file (not used yet)                    
                </comment>
                <comment line="2653">
                    First line looks like:
                        CLASS:src,startLine,endLine,className                    
                </comment>
                <comment line="2661">
                    For each class this class is dependent on:
                        CLDEP:className1,className2
                      where className1 is the name of the class we are in, and
                            classname2 is the name of the class className1
                              is dependent on.                    
                </comment>
                <comment line="2668">
                    Mangle name of class dependend on.                    
                </comment>
                <scope line="2633">
                    <declaration name="src" type="String" line="2637"/>
                    <declaration name="className" type="String" line="2644"/>
                    <declaration name="startLine" type="long" line="2647"/>
                    <declaration name="endLine" type="long" line="2650"/>
                    <scope line="2665">
                        <declaration name="data" type="ClassDeclaration" line="2666"/>
                        <declaration name="depName" type="String" line="2668"/>
                    </scope>
                </scope>
            </method>
        </class>
    </source>