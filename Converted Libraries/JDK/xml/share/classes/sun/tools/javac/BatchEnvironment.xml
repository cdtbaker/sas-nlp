<?xml version="1.0" encoding="UTF-8"?>
    <source package="sun.tools.javac">
        <import package="sun.tools.java"/>
        <import package="sun.tools.tree.Node"/>
        <import package="sun.tools.java.Package"/>
        <import package="java.util"/>
        <import package="java.io"/>
        <class name="BatchEnvironment" line="35">
            <extends class="Environment"/>
            <comment line="93">
                JCOV                
            </comment>
            <comment line="98">
                end JCOV                
            </comment>
            <comment line="262">
                JCOV                
            </comment>
            <comment line="269">
                end JCOV                
            </comment>
            <comment line="419">
                Generate a new name similar to the given one.
                 Do it in such a way that repeated compilations of
                 the same source generate the same series of names.                
            </comment>
            <comment line="425">
                This code does not perform as stated above.
                 Correction below is part of fix for bug id 4056065.
                
                 NOTE: The method &apos;generateName&apos; has now been folded into its
                 single caller, &apos;makeClassDefinition&apos;, which appears later in
                 this file.                
            </comment>
            <comment line="432">
                --------------------------
                public Identifier generateName(ClassDefinition outerClass, Identifier nm) {
                Identifier outerNm = outerClass.getName();
                Identifier flat = outerNm.getFlatName();
                Identifier stem = Identifier.lookup(outerNm.getQualifier(),
                flat.getHead());
                for (int i = 1; ; i++) {
                String name = i + (nm.equals(idNull) ? &quot;&quot; : SIG_INNERCLASS + nm);
                Identifier nm1 = Identifier.lookupInner(stem,
                Identifier.lookup(name));
                if (classes.get(Type.tClass(nm1)) == null)
                return nm1;
                }
                }                
            </comment>
            <implements interface="ErrorConsumer"/>
            <javadoc line="35">
                Main environment of the batch version of the Java compiler,
                  this needs more work.
                  WARNING: The contents of this source file are not part of any
                  supported API.  Code that depends on them does so at its own risk:
                  they are subject to change or removal without notice.                
            </javadoc>
            <declaration name="out" type="OutputStream" line="46"/>
            <javadoc line="46">
                The stream where error message are printed.                
            </javadoc>
            <declaration name="sourcePath" type="ClassPath" line="51"/>
            <javadoc line="51">
                The path we use for finding source files.                
            </javadoc>
            <declaration name="binaryPath" type="ClassPath" line="56"/>
            <javadoc line="56">
                The path we use for finding class (binary) files.                
            </javadoc>
            <declaration name="packages" type="Hashtable" line="61"/>
            <javadoc line="61">
                A hashtable of resource contexts.                
            </javadoc>
            <declaration name="classesOrdered" type="Vector" line="66"/>
            <javadoc line="66">
                The classes, in order of appearance.                
            </javadoc>
            <declaration name="classes" type="Hashtable" line="71"/>
            <javadoc line="71">
                The classes, keyed by ClassDeclaration.                
            </javadoc>
            <declaration name="flags" type="int" line="76"/>
            <javadoc line="76">
                flags                
            </javadoc>
            <declaration name="majorVersion" type="short" line="81"/>
            <javadoc line="81">
                Major and minor versions to use for generated class files.
                  Environments that extend BatchEnvironment (such as javadoc&apos;s
                  Env class) get the default values below.
                  javac itself may override these versions with values determined
                  from the command line &quot;-target&quot; option.                
            </javadoc>
            <declaration name="minorVersion" type="short" line="90"/>
            <declaration name="covFile" type="File" line="93"/>
            <javadoc line="93">
                coverage data file                
            </javadoc>
            <declaration name="nerrors" type="int" line="99"/>
            <javadoc line="99">
                The number of errors and warnings                
            </javadoc>
            <declaration name="nwarnings" type="int" line="103"/>
            <declaration name="ndeprecations" type="int" line="104"/>
            <declaration name="deprecationFiles" type="Vector" line="106"/>
            <javadoc line="106">
                A list of files containing deprecation warnings.                
            </javadoc>
            <declaration name="errorConsumer" type="ErrorConsumer" line="111"/>
            <javadoc line="111">
                writes out error messages                
            </javadoc>
            <javadoc line="117">
                Old constructors -- these constructors build a BatchEnvironment
                  with an old-style class path.                
            </javadoc>
            <method name="BatchEnvironment" type="constructor" line="121">
                <params>
                    <param name="path" type="ClassPath"/>
                </params>
            </method>
            <method name="BatchEnvironment" type="constructor" line="125">
                <params>
                    <param name="out" type="OutputStream"/>
                    <param name="path" type="ClassPath"/>
                </params>
            </method>
            <method name="BatchEnvironment" type="constructor" line="130">
                <params>
                    <param name="out" type="OutputStream"/>
                    <param name="path" type="ClassPath"/>
                    <param name="errorConsumer" type="ErrorConsumer"/>
                </params>
            </method>
            <javadoc line="134">
                New constructors -- these constructors build a BatchEnvironment
                  with a source path and a binary path.                
            </javadoc>
            <method name="BatchEnvironment" type="constructor" line="139">
                <params>
                    <param name="sourcePath" type="ClassPath"/>
                    <param name="binaryPath" type="ClassPath"/>
                </params>
            </method>
            <method name="BatchEnvironment" type="constructor" line="144">
                <params>
                    <param name="out" type="OutputStream"/>
                    <param name="sourcePath" type="ClassPath"/>
                    <param name="binaryPath" type="ClassPath"/>
                </params>
            </method>
            <method name="BatchEnvironment" type="constructor" line="150">
                <params>
                    <param name="out" type="OutputStream"/>
                    <param name="sourcePath" type="ClassPath"/>
                    <param name="binaryPath" type="ClassPath"/>
                    <param name="errorConsumer" type="ErrorConsumer"/>
                </params>
            </method>
            <javadoc line="157">
                Factory                
            </javadoc>
            <method name="create" type="BatchEnvironment" line="164">
                <params>
                    <param name="out" type="OutputStream"/>
                    <param name="srcPathString" type="String"/>
                    <param name="classPathString" type="String"/>
                    <param name="sysClassPathString" type="String"/>
                    <param name="extDirsString" type="String"/>
                </params>
                <declaration name="classPaths" type="ClassPath[]" line="165"/>
            </method>
            <method name="classPaths" type="ClassPath[]" line="173">
                <params>
                    <param name="srcPathString" type="String"/>
                    <param name="classPathString" type="String"/>
                    <param name="sysClassPathString" type="String"/>
                    <param name="extDirsString" type="String"/>
                </params>
                <comment line="175">
                    Create our source classpath and our binary classpath                    
                </comment>
                <comment line="181">
                    The env.class.path property is the user&apos;s CLASSPATH
                     environment variable, and it set by the wrapper (ie,
                     javac.exe).                    
                </comment>
                <comment line="194">
                    shouldn&apos;t happen; recover gracefully                    
                </comment>
                <declaration name="sourcePath" type="ClassPath" line="175"/>
                <declaration name="binaryPath" type="ClassPath" line="176"/>
                <declaration name="binaryPathBuffer" type="StringBuffer" line="177"/>
                <scope line="179">
                    <scope line="184"/>
                </scope>
                <scope line="188"/>
                <scope line="191">
                    <scope line="193"/>
                </scope>
                <scope line="199"/>
                <scope line="202">
                    <declaration name="st" type="StringTokenizer" line="203"/>
                    <scope line="205">
                        <declaration name="dirName" type="String" line="206"/>
                        <declaration name="dir" type="File" line="207"/>
                        <scope line="208"/>
                        <scope line="211">
                            <declaration name="files" type="String[]" line="212"/>
                            <scope line="213">
                                <declaration name="name" type="String" line="214"/>
                                <scope line="215"/>
                            </scope>
                        </scope>
                    </scope>
                </scope>
            </method>
            <method name="appendPath" type="void" line="231">
                <params>
                    <param name="buf" type="StringBuffer"/>
                    <param name="str" type="String"/>
                </params>
                <scope line="232">
                    <scope line="233"/>
                </scope>
            </method>
            <javadoc line="240">
                Return flags                
            </javadoc>
            <method name="getFlags" type="int" line="243"/>
            <javadoc line="247">
                Return major version to use for generated class files                
            </javadoc>
            <method name="getMajorVersion" type="short" line="250"/>
            <javadoc line="254">
                Return minor version to use for generated class files                
            </javadoc>
            <method name="getMinorVersion" type="short" line="257"/>
            <javadoc line="262">
                Return coverage data file                
            </javadoc>
            <method name="getcovFile" type="File" line="265"/>
            <javadoc line="270">
                Return an enumeration of all the currently defined classes
                  in order of appearance to getClassDeclaration().                
            </javadoc>
            <method name="getClasses" type="Enumeration" line="274"/>
            <declaration name="exemptPackages" type="Set" line="278"/>
            <javadoc line="278">
                A set of Identifiers for all packages exempt from the &quot;exists&quot;
                  check in Imports#resolve().  These are the current packages for
                  all classes being compiled as of the first call to isExemptPackage.                
            </javadoc>
            <javadoc line="285">
                Tells whether an Identifier refers to a package which should be
                  exempt from the &quot;exists&quot; check in Imports#resolve().                
            </javadoc>
            <method name="isExemptPackage" type="boolean" line="289">
                <params>
                    <param name="id" type="Identifier"/>
                </params>
                <comment line="292">
                    Collect a list of the packages of all classes currently
                     being compiled.                    
                </comment>
                <scope line="290"/>
            </method>
            <javadoc line="299">
                Set the set of packages which are exempt from the exists check
                  in Imports#resolve().                
            </javadoc>
            <method name="setExemptPackages" type="void" line="303">
                <comment line="305">
                    The JLS gives us the freedom to define &quot;accessibility&quot; of
                     a package in whatever manner we wish.  After the evaluation
                     of bug 4093217, we have decided to consider a package P
                     accessible if either:
                    
                     1. The directory corresponding to P exists on the classpath.
                     2. For any class C currently being compiled, C belongs to
                        package P.
                     3. For any class C currently being compiled, C belongs to
                        package Q and Q is a subpackage of P.
                    
                     In order to implement this, we collect the current packages
                     (and prefixes) of all packages we have found so far.  These
                     will be exempt from the &quot;exists&quot; check in
                     sun.tools.java.Imports#resolve().                    
                </comment>
                <comment line="323">
                    Add all of the current packages and their prefixes to our set.                    
                </comment>
                <comment line="333">
                    Add the name of this package and all of its prefixes
                     to our set.                    
                </comment>
                <comment line="341">
                    Before we go any further, we make sure java.lang is
                     accessible and that it is not ambiguous.  These checks
                     are performed for &quot;ordinary&quot; packages in
                     sun.tools.java.Imports#resolve().  The reason we perform
                     them specially for java.lang is that we want to report
                     the error once, and outside of any particular file.                    
                </comment>
                <comment line="348">
                    Check to see if java.lang is accessible.                    
                </comment>
                <comment line="350">
                    Add java.lang to the set of exempt packages.                    
                </comment>
                <comment line="355">
                    java.lang doesn&apos;t exist.                    
                </comment>
                <comment line="360">
                    We got an IO exception checking to see if the package
                     java.lang exists.                    
                </comment>
                <comment line="366">
                    Next we ensure that java.lang is not both a class and
                     a package.  (Fix for 4101529)
                    
                     This change has been backed out because, on WIN32, it
                     failed to take character case into account.  It will
                     be put back in later.
                    
                     Identifier resolvedName =
                       resolvePackageQualifiedName(idJavaLang);
                     Identifier topClassName = resolvedName.getTopName();
                         if (Imports.importable(topClassName, env)) {
                     if (Imports.importable(topClassName, this)) {
                         It is a package and a class.  Emit the error.
                        error(0, &quot;package.class.conflict.strong&quot;,
                                idJavaLang, topClassName);
                        return;
                     }                    
                </comment>
                <scope line="323">
                    <declaration name="c" type="ClassDeclaration" line="324"/>
                    <scope line="325">
                        <declaration name="def" type="SourceClass" line="326"/>
                        <declaration name="pkg" type="Identifier" line="330"/>
                        <scope line="334"/>
                    </scope>
                </scope>
                <scope line="348">
                    <scope line="352">
                        <scope line="353"/>
                    </scope>
                    <scope line="358"/>
                </scope>
            </method>
            <javadoc line="384">
                Get a class, given the fully qualified class name                
            </javadoc>
            <method name="getClassDeclaration" type="ClassDeclaration" line="387">
                <params>
                    <param name="nm" type="Identifier"/>
                </params>
            </method>
            <method name="getClassDeclaration" type="ClassDeclaration" line="391">
                <params>
                    <param name="t" type="Type"/>
                </params>
                <declaration name="c" type="ClassDeclaration" line="392"/>
                <scope line="393"/>
            </method>
            <javadoc line="400">
                Check if a class exists
                  Applies only to package members (non-nested classes).                
            </javadoc>
            <method name="classExists" type="boolean" line="404">
                <params>
                    <param name="nm" type="Identifier"/>
                </params>
                <comment line="407">
                    just in case                    
                </comment>
                <scope line="405"/>
                <declaration name="t" type="Type" line="408"/>
                <scope line="409">
                    <declaration name="c" type="ClassDeclaration" line="410"/>
                </scope>
                <scope line="413"/>
            </method>
            <javadoc line="447">
                Get the package path for a package                
            </javadoc>
            <method name="getPackage" type="Package" line="450">
                <params>
                    <param name="pkg" type="Identifier"/>
                </params>
                <declaration name="p" type="Package" line="451"/>
                <scope line="452"/>
            </method>
            <javadoc line="458">
                Parse a source file                
            </javadoc>
            <method name="parseFile" type="void" line="461">
                <params>
                    <param name="file" type="ClassFile"/>
                </params>
                <comment line="474">
                    p = new BatchParser(e, new BufferedInputStream(input));                    
                </comment>
                <comment line="490">
                    We&apos;re turn with the input, so ignore this.                    
                </comment>
                <comment line="500">
                    The JLS allows a file to contain no compilation units --
                     that is, it allows a file to contain no classes or interfaces.
                     In this case, we are still responsible for checking that the
                     imports resolve properly.  The way the compiler is organized,
                     this is the last point at which we still have enough information
                     to do so. (Fix for 4041851).                    
                </comment>
                <comment line="508">
                    In an attempt to see that classes which come from the
                     same source file are all recompiled when any one of them
                     would be recompiled (when using the -depend option) we
                     introduce artificial dependencies between these classes.
                     We do this by calling the addDependency() method, which
                     adds a (potentially unused) class reference to the constant
                     pool of the class.
                    
                     Previously, we added a dependency from every class in the
                     file, to every class in the file.  This introduced, in
                     total, a quadratic number of potentially bogus constant
                     pool entries.  This was bad.  Now we add our artificial
                     dependencies in such a way that the classes are connected
                     in a circle.  While single links is probably sufficient, the
                     code below adds double links just to be diligent.
                     (Fix for 4108286).
                    
                     Note that we don&apos;t chain in inner classes.  The links
                     between them and their outerclass should be sufficient
                     here.
                     (Fix for 4107960).
                    
                     The dependency code was previously in BatchParser.java.                    
                </comment>
                <comment line="533">
                    first will not be an inner class.                    
                </comment>
                <comment line="543">
                    Don&apos;t chain in inner classes.                    
                </comment>
                <comment line="551">
                    Make a circle.  Don&apos;t bother to add a dependency if there
                     is only one class in the file.                    
                </comment>
                <declaration name="tm" type="long" line="462"/>
                <declaration name="input" type="InputStream" line="463"/>
                <declaration name="p" type="BatchParser" line="464"/>
                <declaration name="env" type="Environment" line="468"/>
                <scope line="470"/>
                <scope line="475"/>
                <scope line="480"/>
                <scope line="482"/>
                <scope line="486"/>
                <scope line="488"/>
                <scope line="492"/>
                <scope line="498"/>
                <scope line="506">
                    <declaration name="e" type="Enumeration" line="530"/>
                    <declaration name="first" type="ClassDefinition" line="533"/>
                    <scope line="534"/>
                    <declaration name="current" type="ClassDefinition" line="538"/>
                    <declaration name="next" type="ClassDefinition" line="539"/>
                    <scope line="540">
                        <scope line="543"/>
                    </scope>
                    <scope line="552"/>
                </scope>
            </method>
            <javadoc line="561">
                Load a binary file                
            </javadoc>
            <method name="loadFile" type="BinaryClass" line="564">
                <params>
                    <param name="file" type="ClassFile"/>
                </params>
                <comment line="582">
                    If we get an EOF while processing a class file, then
                     it has been truncated.  We let other I/O errors pass
                     through.  Fix for 4088443.                    
                </comment>
                <declaration name="tm" type="long" line="565"/>
                <declaration name="input" type="InputStream" line="566"/>
                <declaration name="c" type="BinaryClass" line="567"/>
                <scope line="571">
                    <declaration name="is" type="DataInputStream" line="572"/>
                </scope>
                <scope line="576"/>
                <scope line="580"/>
                <scope line="589"/>
            </method>
            <javadoc line="600">
                Default flags for loadFile.  Subclasses may override this.                
            </javadoc>
            <method name="loadFileFlags" type="int" line="603"/>
            <javadoc line="607">
                Load a binary class                
            </javadoc>
            <method name="needsCompilation" type="boolean" line="610">
                <params>
                    <param name="check" type="Hashtable"/>
                    <param name="c" type="ClassDeclaration"/>
                </params>
                <comment line="628">
                    It must be source, dependencies need compilation                    
                </comment>
                <scope line="620">
                    <declaration name="bin" type="BinaryClass" line="623"/>
                    <scope line="624">
                        <declaration name="dep" type="ClassDeclaration" line="625"/>
                        <scope line="626"/>
                    </scope>
                </scope>
                <scope line="638"/>
            </method>
            <javadoc line="650">
                Load the definition of a class
                  or at least determine how to load it.
                  The caller must repeat calls to this method
                  until it the state converges to CS_BINARY, CS_PARSED, or the like..                
                <see>
                    ClassDeclaration#getClassDefinition                    
                </see>
            </javadoc>
            <method name="loadDefinition" type="void" line="657">
                <params>
                    <param name="c" type="ClassDeclaration"/>
                </params>
                <comment line="670">
                    If we can&apos;t get at the package, then we&apos;ll just
                     have to set the class to be not found.                    
                </comment>
                <comment line="681">
                    must be source, there is no binary                    
                </comment>
                <comment line="697">
                    If we can&apos;t access the binary, set the class to
                     be not found.  (bug id 4030497)                    
                </comment>
                <comment line="713">
                    no source nor binary found                    
                </comment>
                <comment line="720">
                    Couldn&apos;t find the source, try the one mentioned in the binary                    
                </comment>
                <comment line="723">
                    Look for the source file                    
                </comment>
                <comment line="730">
                    must be source, it is newer than the binary                    
                </comment>
                <comment line="760">
                    It must be binary, there is no source                    
                </comment>
                <comment line="774">
                    must be source, it is newer than the binary                    
                </comment>
                <comment line="835">
                    All undecided classes that this class depends on must be binary                    
                </comment>
                <comment line="839">
                    must be binary, dependencies need compilation                    
                </comment>
                <comment line="856">
                    Use the source file name from the binary class file                    
                </comment>
                <comment line="870">
                    Get a source file name from the package                    
                </comment>
                <comment line="881">
                    not found, there is no source                    
                </comment>
                <comment line="896">
                    not found after parsing the file                    
                </comment>
                <scope line="661">
                    <declaration name="nm" type="Identifier" line="664"/>
                    <declaration name="pkg" type="Package" line="665"/>
                    <scope line="666"/>
                    <scope line="668"/>
                    <declaration name="binfile" type="ClassFile" line="678"/>
                    <scope line="679"/>
                    <declaration name="srcfile" type="ClassFile" line="688"/>
                    <scope line="689">
                        <declaration name="bc" type="BinaryClass" line="692"/>
                        <scope line="693"/>
                        <scope line="695"/>
                        <scope line="705"/>
                        <scope line="711"/>
                        <scope line="720">
                            <scope line="724">
                                <scope line="728"/>
                                <scope line="740"/>
                                <scope line="745"/>
                            </scope>
                        </scope>
                    </scope>
                    <declaration name="bc" type="BinaryClass" line="770"/>
                    <scope line="771">
                        <scope line="772"/>
                    </scope>
                    <scope line="781"/>
                    <scope line="786"/>
                    <scope line="792">
                        <declaration name="name" type="Identifier" line="793"/>
                        <scope line="794">
                            <scope line="795"/>
                            <scope line="799"/>
                        </scope>
                        <scope line="804">
                            <scope line="808"/>
                            <scope line="812"/>
                        </scope>
                    </scope>
                    <scope line="818"/>
                </scope>
                <scope line="830">
                    <declaration name="tab" type="Hashtable" line="832"/>
                    <scope line="833">
                        <scope line="835">
                            <declaration name="dep" type="ClassDeclaration" line="836"/>
                            <scope line="837"/>
                        </scope>
                    </scope>
                </scope>
                <scope line="850">
                    <declaration name="srcfile" type="ClassFile" line="852"/>
                    <declaration name="pkg" type="Package" line="853"/>
                    <scope line="854">
                        <scope line="856"/>
                        <scope line="859"/>
                        <scope line="864">
                            <declaration name="fn" type="String" line="865"/>
                        </scope>
                    </scope>
                    <scope line="868">
                        <declaration name="nm" type="Identifier" line="870"/>
                        <scope line="871"/>
                        <scope line="874"/>
                        <scope line="879"/>
                    </scope>
                    <scope line="888"/>
                    <scope line="890"/>
                    <scope line="894"/>
                </scope>
            </method>
            <javadoc line="911">
                Create a new class.                
            </javadoc>
            <method name="makeClassDefinition" type="ClassDefinition" line="920">
                <params>
                    <param name="toplevelEnv" type="Environment"/>
                    <param name="where" type="long"/>
                    <param name="name" type="IdentifierToken"/>
                    <param name="doc" type="String"/>
                    <param name="modifiers" type="int"/>
                    <param name="superClass" type="IdentifierToken"/>
                    <param name="interfaces" type="IdentifierToken"/>
                    <param name="outerClass" type="ClassDefinition"/>
                </params>
                <comment line="930">
                    Provide name for a local class.  This used to be set after
                     the class was created, but it is needed for checking within
                     the class constructor.
                     NOTE: It seems that we could always provide the simple name,
                     and thereby avoid the test in &apos;ClassDefinition.getLocalName()&apos;
                     for the definedness of the local name.  There, if the local
                     name is not set, a simple name is extracted from the result of
                     &apos;getName()&apos;.  That name can potentially change, however, as
                     it is ultimately derived from &apos;ClassType.className&apos;, which is
                     set by &apos;Type.changeClassName&apos;.  Better leave this alone...                    
                </comment>
                <comment line="945">
                    Inaccessible class.  Create a name of the form
                     &apos;PackageMember.N$localName&apos; or &apos;PackageMember.N&apos;.
                     Note that the &apos;.&apos; will be converted later to a &apos;$&apos;.
                       pkgNm = generateName(outerClass, nm);                    
                </comment>
                <comment line="950">
                    Always use the smallest number in generating the name that
                     renders the complete name unique within the top-level class.
                     This is required to make the names more predictable, as part
                     of a serialization-related workaround, and satisfies an obscure
                     requirement that the name of a local class be of the form
                     &apos;PackageMember$1$localName&apos; when this name is unique.                    
                </comment>
                <comment line="964">
                    System.out.println(&quot;LOCAL CLASS: &quot; + pkgNm + &quot; IN &quot; + localContextClass);                    
                </comment>
                <comment line="968">
                    Local class has a locally-scoped name which is independent of pkgNm.                    
                </comment>
                <comment line="972">
                    Accessible inner class.  Qualify name with surrounding class name.                    
                </comment>
                <comment line="978">
                    Find the class                    
                </comment>
                <comment line="981">
                    Make sure this is the first definition                    
                </comment>
                <comment line="985">
                    Don&apos;t mess with the existing class declarations with same name                    
                </comment>
                <comment line="999">
                    It is a member of its enclosing class.                    
                </comment>
                <comment line="1001">
                    Record local (or anonymous) class in the class whose name will
                     serve as the prefix of the local class name.  This is necessary
                     so that the class may be retrieved from its name, which does not
                     fully represent the class nesting structure.
                     See &apos;ClassDefinition.getClassDefinition&apos;.
                     This is part of a fix for bugid 4054523 and 4030421.                    
                </comment>
                <comment line="1012">
                    The local name of an anonymous or local class used to be set here
                     with a call to &apos;setLocalName&apos;.  This has been moved to the constructor
                     for &apos;SourceClass&apos;, which now takes a &apos;localName&apos; argument.                    
                </comment>
                <declaration name="nm" type="Identifier" line="922"/>
                <declaration name="nmpos" type="long" line="923"/>
                <declaration name="pkgNm" type="Identifier" line="925"/>
                <declaration name="mangledName" type="String" line="926"/>
                <declaration name="localContextClass" type="ClassDefinition" line="927"/>
                <declaration name="localName" type="Identifier" line="939"/>
                <scope line="941"/>
                <scope line="943">
                    <scope line="955">
                        <scope line="957"/>
                    </scope>
                    <declaration name="outerNm" type="Identifier" line="961"/>
                    <scope line="964"/>
                    <scope line="966"/>
                </scope>
                <scope line="970"/>
                <scope line="973"/>
                <declaration name="c" type="ClassDeclaration" line="978"/>
                <scope line="981"/>
                <scope line="988"/>
                <declaration name="sourceClass" type="ClassDefinition" line="992"/>
                <scope line="997">
                    <scope line="1006"/>
                </scope>
            </method>
            <javadoc line="1018">
                Create a new field.                
            </javadoc>
            <method name="makeMemberDefinition" type="MemberDefinition" line="1027">
                <params>
                    <param name="origEnv" type="Environment"/>
                    <param name="where" type="long"/>
                    <param name="clazz" type="ClassDefinition"/>
                    <param name="doc" type="String"/>
                    <param name="modifiers" type="int"/>
                    <param name="type" type="Type"/>
                    <param name="name" type="Identifier"/>
                    <param name="argNames" type="IdentifierToken"/>
                    <param name="expIds" type="IdentifierToken"/>
                    <param name="value" type="Object"/>
                </params>
                <declaration name="v" type="Vector" line="1029"/>
                <scope line="1030">
                    <scope line="1032"/>
                </scope>
                <declaration name="f" type="SourceMember" line="1036"/>
            </method>
            <javadoc line="1042">
                Release resources in classpath.                
            </javadoc>
            <method name="shutdown" type="void" line="1045">
                <scope line="1046">
                    <scope line="1047"/>
                    <scope line="1050"/>
                </scope>
                <scope line="1053"/>
            </method>
            <javadoc line="1063">
                Error String                
            </javadoc>
            <method name="errorString" type="String" line="1067">
                <params>
                    <param name="err" type="String"/>
                    <param name="arg1" type="Object"/>
                    <param name="arg2" type="Object"/>
                    <param name="arg3" type="Object"/>
                </params>
                <declaration name="key" type="String" line="1068"/>
            </method>
            <declaration name="errorFileName" type="String" line="1081"/>
            <javadoc line="1081">
                The filename where the last errors have occurred                
            </javadoc>
            <declaration name="errors" type="ErrorMessage" line="1086"/>
            <javadoc line="1086">
                List of outstanding error messages                
            </javadoc>
            <javadoc line="1091">
                Insert an error message in the list of outstanding error messages.
                  The list is sorted on input position and contains no duplicates.
                  The return value indicates whether or not the message was
                  actually inserted.
                  The method flushErrors() used to check for duplicate error messages.
                  It would only detect duplicates if they were contiguous.  Removing
                  non-contiguous duplicate error messages is slightly less complicated
                  at insertion time, so the functionality was moved here.  This also
                  saves a miniscule number of allocations.                
            </javadoc>
            <method name="insertError" type="boolean" line="1104">
                <params>
                    <param name="where" type="long"/>
                    <param name="message" type="String"/>
                </params>
                <comment line="1106">
                    output(&quot;ERR = &quot; + message);                    
                </comment>
                <comment line="1110">
                    If the list is empty, or the error comes before any other
                     errors, insert it at the beginning of the list.                    
                </comment>
                <comment line="1118">
                    The new message is an exact duplicate of the first message
                     in the list.  Don&apos;t insert it.                    
                </comment>
                <comment line="1123">
                    Okay, we know that the error doesn&apos;t come first.  Walk
                     the list until we find the right position for insertion.                    
                </comment>
                <comment line="1133">
                    Now walk over any errors with the same location, looking
                     for duplicates.  If we find a duplicate, don&apos;t insert the
                     error.                    
                </comment>
                <comment line="1139">
                    We have found an exact duplicate.  Don&apos;t bother to
                     insert the error.                    
                </comment>
                <comment line="1146">
                    Now insert after current.                    
                </comment>
                <comment line="1152">
                    Indicate that the insertion occurred.                    
                </comment>
                <scope line="1108">
                    <declaration name="newMsg" type="ErrorMessage" line="1111"/>
                </scope>
                <scope line="1116"/>
                <scope line="1121">
                    <declaration name="current" type="ErrorMessage" line="1124"/>
                    <declaration name="next" type="ErrorMessage" line="1125"/>
                    <scope line="1128"/>
                    <scope line="1136">
                        <scope line="1137"/>
                    </scope>
                    <declaration name="newMsg" type="ErrorMessage" line="1146"/>
                </scope>
            </method>
            <declaration name="errorsPushed" type="int" line="1155"/>
            <declaration name="errorLimit" type="int" line="1157"/>
            <javadoc line="1157">
                Maximum number of errors to print.                
            </javadoc>
            <declaration name="hitErrorLimit" type="boolean" line="1162"/>
            <javadoc line="1164">
                Flush outstanding errors                
            </javadoc>
            <method name="pushError" type="void" line="1169">
                <params>
                    <param name="errorFileName" type="String"/>
                    <param name="line" type="int"/>
                    <param name="message" type="String"/>
                    <param name="referenceText" type="String"/>
                    <param name="referenceTextPointer" type="String"/>
                </params>
                <comment line="1185">
                    It wasn&apos;t really a source file (probably an error or
                     warning because of a malformed or badly versioned
                     class file.                    
                </comment>
                <declaration name="limit" type="int" line="1170"/>
                <scope line="1171">
                    <scope line="1172"/>
                </scope>
                <scope line="1179"/>
                <scope line="1183"/>
            </method>
            <method name="flushErrors" type="void" line="1191">
                <comment line="1198">
                    Read the file                    
                </comment>
                <comment line="1201">
                    A malformed file encoding could cause a CharConversionException.
                     If something bad happens while trying to find the source file,
                     don&apos;t bother trying to show lines.                    
                </comment>
                <comment line="1215">
                    inputAvail will not be set                    
                </comment>
                <comment line="1218">
                    Report the errors                    
                </comment>
                <comment line="1220">
                    There used to be code here which checked
                     for duplicate error messages.  This functionality
                     has been moved to the method insertError().  See
                     the comments on that method for more information.                    
                </comment>
                <scope line="1192"/>
                <declaration name="inputAvail" type="boolean" line="1196"/>
                <declaration name="data" type="char" line="1198"/>
                <declaration name="dataLength" type="int" line="1199"/>
                <scope line="1203">
                    <declaration name="in" type="FileInputStream" line="1204"/>
                    <declaration name="reader" type="InputStreamReader" line="1206"/>
                </scope>
                <scope line="1213"/>
                <scope line="1218">
                    <declaration name="ln" type="int" line="1224"/>
                    <declaration name="off" type="int" line="1225"/>
                    <declaration name="referenceString" type="String" line="1228"/>
                    <declaration name="markerString" type="String" line="1229"/>
                    <scope line="1230">
                        <declaration name="i" type="int" line="1231"/>
                        <declaration name="strdata" type="char" line="1236"/>
                        <scope line="1237"/>
                    </scope>
                </scope>
            </method>
            <javadoc line="1250">
                Report error                
            </javadoc>
            <method name="reportError" type="void" line="1254">
                <params>
                    <param name="src" type="Object"/>
                    <param name="where" type="long"/>
                    <param name="err" type="String"/>
                    <param name="msg" type="String"/>
                </params>
                <comment line="1275">
                    Flush errors if we&apos;ve moved on to a new file.                    
                </comment>
                <comment line="1281">
                    Classify `err&apos; as a warning, deprecation warning, or
                     error message.  Proceed accordingly.                    
                </comment>
                <comment line="1285">
                    This is a deprecation warning.  Add `src&apos; to the
                     list of files with deprecation warnings.                    
                </comment>
                <comment line="1291">
                    If we are reporting deprecations, try to add it
                     to our list.  Otherwise, just increment the
                     deprecation count.                    
                </comment>
                <comment line="1302">
                    This is a regular warning.  If we are reporting
                     warnings, try to add it to the list.  Otherwise, just
                     increment the warning count.                    
                </comment>
                <comment line="1314">
                    This is an error.  Try to add it to the list of errors.
                     If it isn&apos;t a duplicate, increment our error count.                    
                </comment>
                <scope line="1255">
                    <scope line="1256"/>
                    <scope line="1260">
                        <scope line="1261"/>
                    </scope>
                </scope>
                <scope line="1271">
                    <declaration name="fileName" type="String" line="1272"/>
                    <scope line="1275"/>
                    <scope line="1282">
                        <scope line="1283">
                            <scope line="1286"/>
                            <scope line="1293">
                                <scope line="1294"/>
                            </scope>
                            <scope line="1297"/>
                        </scope>
                        <scope line="1300">
                            <scope line="1304">
                                <scope line="1305"/>
                            </scope>
                            <scope line="1308"/>
                        </scope>
                    </scope>
                    <scope line="1312">
                        <scope line="1315"/>
                    </scope>
                </scope>
                <scope line="1320"/>
                <scope line="1323"/>
                <scope line="1326">
                    <scope line="1327"/>
                    <scope line="1329"/>
                </scope>
                <scope line="1332">
                    <declaration name="c" type="ClassDefinition" line="1333"/>
                    <scope line="1334"/>
                </scope>
                <scope line="1339"/>
                <scope line="1342"/>
            </method>
            <javadoc line="1347">
                Issue an error                
            </javadoc>
            <method name="error" type="void" line="1350">
                <params>
                    <param name="source" type="Object"/>
                    <param name="where" type="long"/>
                    <param name="err" type="String"/>
                    <param name="arg1" type="Object"/>
                    <param name="arg2" type="Object"/>
                    <param name="arg3" type="Object"/>
                </params>
                <comment line="1353">
                    Don&apos;t bother to queue any more errors if they won&apos;t get printed.                    
                </comment>
                <scope line="1351"/>
                <scope line="1355"/>
            </method>
            <javadoc line="1362">
                Output a string. This can either be an error message or something
                  for debugging.                
            </javadoc>
            <method name="output" type="void" line="1366">
                <params>
                    <param name="msg" type="String"/>
                </params>
                <declaration name="out" type="PrintStream" line="1367"/>
            </method>
        </class>
    </source>