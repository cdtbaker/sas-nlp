<?xml version="1.0" encoding="UTF-8"?>
    <source package="sun.tools.javac">
        <import package="sun.tools.java"/>
        <import package="sun.tools.tree"/>
        <import package="sun.tools.asm"/>
        <import package="java.util.Vector"/>
        <import package="java.util.Enumeration"/>
        <import package="java.util.Hashtable"/>
        <import package="java.io.PrintStream"/>
        <class name="SourceMember" line="36">
            <extends class="MemberDefinition"/>
            <comment line="52">
                set to the MemberDefinition in the interface if we have this field because                
            </comment>
            <comment line="53">
                it has been forced on us                
            </comment>
            <comment line="131">
                The methods addOuterThis() and addUplevelArguments() were                
            </comment>
            <comment line="132">
                both originally part of a single method called addUplevelArguments()                
            </comment>
            <comment line="133">
                which took a single boolean parameter describing which of the                
            </comment>
            <comment line="134">
                two behaviors it wanted.                
            </comment>
            <comment line="135">
                                
            </comment>
            <comment line="136">
                The original addUplevelArguments() claimed to keep the arguments in                
            </comment>
            <comment line="137">
                the following order:                
            </comment>
            <comment line="138">
                                
            </comment>
            <comment line="139">
                (1) &lt;this&gt; &lt;early outer this&gt; &lt;uplevel arguments...&gt; &lt;true arguments...&gt;                
            </comment>
            <comment line="140">
                                
            </comment>
            <comment line="141">
                (By &lt;early outer this&gt; I am referring to the clientOuterField added                
            </comment>
            <comment line="142">
                to some constructors when they are created.  If an outer this is                
            </comment>
            <comment line="143">
                added later, on demand, then this is mixed in with the rest of the                
            </comment>
            <comment line="144">
                uplevel arguments and is added by addUplevelArguments.)                
            </comment>
            <comment line="145">
                                
            </comment>
            <comment line="146">
                In reality, the `args&apos; Vector was generated in this order, but the                
            </comment>
            <comment line="147">
                Type array `argTypes&apos; was generated as:                
            </comment>
            <comment line="148">
                                
            </comment>
            <comment line="149">
                (2) &lt;this&gt; &lt;uplevel arguments...&gt; &lt;early outer this&gt; &lt;true arguments...&gt;                
            </comment>
            <comment line="150">
                                
            </comment>
            <comment line="151">
                This didn&apos;t make a difference in the common case -- that is, when                
            </comment>
            <comment line="152">
                a class had an &lt;outer.this&gt; or &lt;uplevel arguments...&gt; but not both.                
            </comment>
            <comment line="153">
                Both can happen in the case that a member class is declared inside                
            </comment>
            <comment line="154">
                of a local class.  It seems that the calling sequences, generated                
            </comment>
            <comment line="155">
                in places like NewInstanceExpression.codeCommon(), use order (2),                
            </comment>
            <comment line="156">
                so I have changed the code below to stick with that order.  Since                
            </comment>
            <comment line="157">
                the only time this happens is in classes which are insideLocal, no                
            </comment>
            <comment line="158">
                one should be able to tell the difference between these orders.                
            </comment>
            <comment line="159">
                (bug number 4085633)                
            </comment>
            <comment line="671">
                helper to check(): synthesize a missing super() call                
            </comment>
            <implements interface="Constants"/>
            <javadoc line="36">
                A Source Member
                  WARNING: The contents of this source file are not part of any
                  supported API.  Code that depends on them does so at its own risk:
                  they are subject to change or removal without notice.                
            </javadoc>
            <declaration name="args" type="Vector" line="46"/>
            <javadoc line="46">
                The argument names (if it is a method)                
            </javadoc>
            <declaration name="abstractSource" type="MemberDefinition" line="53"/>
            <declaration name="status" type="int" line="55"/>
            <javadoc line="55">
                The status of the field                
            </javadoc>
            <declaration name="PARSED" type="int" line="60"/>
            <declaration name="CHECKING" type="int" line="61"/>
            <declaration name="CHECKED" type="int" line="62"/>
            <declaration name="INLINING" type="int" line="63"/>
            <declaration name="INLINED" type="int" line="64"/>
            <declaration name="ERROR" type="int" line="65"/>
            <method name="getArguments" type="Vector" line="67"/>
            <javadoc line="71">
                Constructor                
                <param>
                    argNames a vector of IdentifierToken                    
                </param>
            </javadoc>
            <method name="SourceMember" type="constructor" line="78">
                <params>
                    <param name="where" type="long"/>
                    <param name="clazz" type="ClassDefinition"/>
                    <param name="doc" type="String"/>
                    <param name="modifiers" type="int"/>
                    <param name="type" type="Type"/>
                    <param name="name" type="Identifier"/>
                    <param name="argNames" type="Vector"/>
                    <param name="exp" type="IdentifierToken"/>
                    <param name="value" type="Node"/>
                </params>
                <comment line="81">
                    for the moment                    
                </comment>
                <comment line="82">
                    not until type names are resolved: createArgumentFields(argNames);                    
                </comment>
                <scope line="84"/>
            </method>
            <method name="createArgumentFields" type="void" line="89">
                <params>
                    <param name="argNames" type="Vector"/>
                </params>
                <comment line="90">
                    Create a list of arguments                    
                </comment>
                <comment line="104">
                    This should not happen, but it does                    
                </comment>
                <comment line="105">
                    in cases of vicious cyclic inheritance.                    
                </comment>
                <comment line="113">
                    allow argNames to be simple Identifiers (deprecated!)                    
                </comment>
                <scope line="91">
                    <scope line="94"/>
                    <scope line="98">
                        <declaration name="e" type="Enumeration" line="99"/>
                        <declaration name="argTypes" type="Type" line="100"/>
                        <scope line="101">
                            <declaration name="x" type="Object" line="102"/>
                            <scope line="103"/>
                            <declaration name="id" type="Identifier" line="109"/>
                            <declaration name="mod" type="int" line="110"/>
                            <declaration name="where" type="long" line="111"/>
                            <scope line="112"/>
                            <scope line="117">
                                <declaration name="token" type="IdentifierToken" line="118"/>
                            </scope>
                        </scope>
                    </scope>
                </scope>
            </method>
            <declaration name="outerThisArg" type="LocalMember" line="160"/>
            <javadoc line="162">
                Get outer instance link, or null if none.                
            </javadoc>
            <method name="getOuterThisArg" type="LocalMember" line="166"/>
            <javadoc line="170">
                Add the outer.this argument to the list of arguments for this
                  constructor.  This is called from resolveTypeStructure.  Any
                  additional uplevel arguments get added later by addUplevelArguments().                
            </javadoc>
            <method name="addOuterThis" type="void" line="176">
                <comment line="179">
                    See if we have a client outer field.                    
                </comment>
                <comment line="185">
                    There is no outer this argument.  Quit.                    
                </comment>
                <comment line="190">
                    Get the old arg types.                    
                </comment>
                <comment line="193">
                    And make an array for the new ones with space for one more.                    
                </comment>
                <comment line="199">
                    args is our list of arguments.  It contains a `this&apos;, so                    
                </comment>
                <comment line="200">
                    we insert at position 1.  The list of types does not have a                    
                </comment>
                <comment line="201">
                    this, so we insert at position 0.                    
                </comment>
                <comment line="205">
                    Add on the rest of the constructor arguments.                    
                </comment>
                <declaration name="refs" type="UplevelReference" line="177"/>
                <scope line="181"/>
                <scope line="186"/>
                <declaration name="oldArgTypes" type="Type" line="191"/>
                <declaration name="argTypes" type="Type" line="194"/>
                <declaration name="arg" type="LocalMember" line="196"/>
                <scope line="206"/>
            </method>
            <javadoc line="213">
                Prepend argument names and argument types for local variable references.
                  This information is never seen by the type-check phase,
                  but it affects code generation, which is the earliest moment
                  we have comprehensive information on uplevel references.
                  The code() methods tweaks the constructor calls, prepending
                  the proper values to the argument list.                
            </javadoc>
            <method name="addUplevelArguments" type="void" line="221">
                <comment line="225">
                    Count how many uplevels we have to add.                    
                </comment>
                <comment line="234">
                    None to add, quit.                    
                </comment>
                <comment line="238">
                    Get the old argument types.                    
                </comment>
                <comment line="241">
                    Make an array with enough room for the new.                    
                </comment>
                <comment line="244">
                    Add all of the late uplevel references to args and argTypes.                    
                </comment>
                <comment line="245">
                    Note that they are `off-by-one&apos; because of the `this&apos;.                    
                </comment>
                <comment line="258">
                    Add the rest of the old arguments.                    
                </comment>
                <declaration name="refs" type="UplevelReference" line="222"/>
                <declaration name="count" type="int" line="226"/>
                <scope line="227">
                    <scope line="228"/>
                </scope>
                <scope line="233"/>
                <declaration name="oldArgTypes" type="Type" line="239"/>
                <declaration name="argTypes" type="Type" line="242"/>
                <declaration name="ins" type="int" line="246"/>
                <scope line="247">
                    <scope line="248">
                        <declaration name="arg" type="LocalMember" line="249"/>
                    </scope>
                </scope>
                <scope line="259"/>
            </method>
            <javadoc line="266">
                Constructor for an inner class.                
            </javadoc>
            <method name="SourceMember" type="constructor" line="269">
                <params>
                    <param name="innerClass" type="ClassDefinition"/>
                </params>
            </method>
            <javadoc line="273">
                Constructor.
                  Used only to generate an abstract copy of a method that a class
                  inherits from an interface                
            </javadoc>
            <method name="SourceMember" type="constructor" line="278">
                <params>
                    <param name="f" type="MemberDefinition"/>
                    <param name="c" type="ClassDefinition"/>
                    <param name="env" type="Environment"/>
                </params>
            </method>
            <javadoc line="287">
                Get exceptions                
            </javadoc>
            <method name="getExceptions" type="ClassDeclaration[]" line="290">
                <params>
                    <param name="env" type="Environment"/>
                </params>
                <comment line="295">
                    (should not happen)                    
                </comment>
                <comment line="299">
                    be sure to get the imports right:                    
                </comment>
                <scope line="291"/>
                <scope line="294"/>
                <scope line="302">
                    <declaration name="e" type="Identifier" line="303"/>
                    <declaration name="rexp" type="Identifier" line="304"/>
                </scope>
            </method>
            <javadoc line="310">
                Set array of name-resolved exceptions directly, e.g., for access methods.                
            </javadoc>
            <method name="setExceptions" type="void" line="313">
                <params>
                    <param name="exp" type="ClassDeclaration[]"/>
                </params>
            </method>
            <declaration name="resolved" type="boolean" line="317"/>
            <javadoc line="317">
                Resolve types in a field, after parsing.                
                <see>
                    ClassDefinition.resolveTypeStructure                    
                </see>
            </javadoc>
            <method name="resolveTypeStructure" type="void" line="324">
                <params>
                    <param name="env" type="Environment"/>
                </params>
                <comment line="327">
                    A member should only be resolved once.  For a constructor, it is imperative                    
                </comment>
                <comment line="328">
                    that &apos;addOuterThis&apos; be called only once, else the outer instance argument may                    
                </comment>
                <comment line="329">
                    be inserted into the argument list multiple times.                    
                </comment>
                <comment line="333">
                    This case shouldn&apos;t be happening.  It is the responsibility                    
                </comment>
                <comment line="334">
                    of our callers to avoid attempting multiple resolutions of a member.                    
                </comment>
                <comment line="335">
                    *** REMOVE FOR SHIPMENT? ***                    
                </comment>
                <comment line="337">
                    return;                    
                </comment>
                <comment line="351">
                    Expand all class names in &apos;type&apos;, including those that are not                    
                </comment>
                <comment line="352">
                    fully-qualified or refer to inner classes, into fully-qualified                    
                </comment>
                <comment line="353">
                    names.  Local and anonymous classes get synthesized names here,                    
                </comment>
                <comment line="354">
                    corresponding to the class files that will be generated.  This is                    
                </comment>
                <comment line="355">
                    currently the only place where &apos;resolveNames&apos; is used.                    
                </comment>
                <comment line="358">
                    do the throws also:                    
                </comment>
                <comment line="364">
                    Add outer instance argument for constructors.                    
                </comment>
                <scope line="331"/>
                <scope line="338"/>
                <scope line="344">
                    <declaration name="nc" type="ClassDefinition" line="345"/>
                    <scope line="346"/>
                </scope>
                <scope line="350">
                    <scope line="361">
                        <declaration name="argNames" type="Vector" line="362"/>
                        <scope line="365"/>
                    </scope>
                </scope>
            </method>
            <javadoc line="373">
                Get the class declaration in which the field is actually defined                
            </javadoc>
            <method name="getDefiningClassDeclaration" type="ClassDeclaration" line="376"/>
            <javadoc line="383">
                A source field never reports deprecation, since the compiler
                  allows access to deprecated features that are being compiled
                  in the same job.                
            </javadoc>
            <method name="reportDeprecated" type="boolean" line="388">
                <params>
                    <param name="env" type="Environment"/>
                </params>
            </method>
            <javadoc line="392">
                Check this field.
                  &lt;p&gt;
                  This is the method which requests checking.
                  The real work is done by
                  &lt;tt&gt;Vset check(Environment, Context, Vset)&lt;/tt&gt;.                
            </javadoc>
            <method name="check" type="void" line="399">
                <params>
                    <param name="env" type="Environment"/>
                </params>
                <comment line="402">
                    rely on the class to check all fields in the proper order                    
                </comment>
                <comment line="405">
                    break a big cycle for small synthetic variables                    
                </comment>
                <scope line="403">
                    <scope line="404"/>
                    <scope line="413">
                        <scope line="414"/>
                        <scope line="416"/>
                    </scope>
                </scope>
            </method>
            <javadoc line="427">
                Check a field.                
                <param>
                    vset tells which uplevel variables are definitely assigned
                      The vset is also used to track the initialization of blank finals
                      by whichever fields which are relevant to them.                    
                </param>
            </javadoc>
            <method name="check" type="Vset" line="433">
                <params>
                    <param name="env" type="Environment"/>
                    <param name="ctx" type="Context"/>
                    <param name="vset" type="Vset"/>
                </params>
                <comment line="438">
                    some classes are checked separately                    
                </comment>
                <comment line="457">
                    This is where all checking of names appearing within the type                    
                </comment>
                <comment line="458">
                    of the member is done.  Includes return type and argument types.                    
                </comment>
                <comment line="459">
                    Since only one location (&apos;where&apos;) for error messages is provided,                    
                </comment>
                <comment line="460">
                    localization of errors is poor.  Throws clauses are handled below.                    
                </comment>
                <comment line="463">
                    Make sure that all the classes that we claim to throw really                    
                </comment>
                <comment line="464">
                    are subclasses of Throwable, and are classes that we can reach                    
                </comment>
                <comment line="478">
                    Validate access for all inner-class components                    
                </comment>
                <comment line="479">
                    of a qualified name, not just the last one, which                    
                </comment>
                <comment line="480">
                    is checked below.  Yes, this is a dirty hack...                    
                </comment>
                <comment line="481">
                    Part of fix for 4094658.                    
                </comment>
                <comment line="523">
                    initialize vset, indication that each of the arguments                    
                </comment>
                <comment line="524">
                    to the function has a value                    
                </comment>
                <comment line="532">
                    Undefine &quot;this&quot; in some constructors, until after                    
                </comment>
                <comment line="533">
                    the super constructor has been called.                    
                </comment>
                <comment line="536">
                    If the first thing in the definition isn&apos;t a call                    
                </comment>
                <comment line="537">
                    to either super() or this(), then insert one.                    
                </comment>
                <comment line="549">
                    System.out.println(&quot;VSET = &quot; + vset);                    
                </comment>
                <comment line="586">
                    If this message is being generated for                    
                </comment>
                <comment line="587">
                    a default constructor, we should give                    
                </comment>
                <comment line="588">
                    a different error message.  Currently                    
                </comment>
                <comment line="589">
                    we check for this by seeing if the                    
                </comment>
                <comment line="590">
                    constructor has the same &quot;where&quot; as                    
                </comment>
                <comment line="591">
                    its class.  This is a bit kludgy, but                    
                </comment>
                <comment line="592">
                    works. (bug id 4034836)                    
                </comment>
                <comment line="595">
                    Constructor with uncaught exception.                    
                </comment>
                <comment line="599">
                    Initializer with uncaught exception.                    
                </comment>
                <comment line="602">
                    Method with uncaught exception.                    
                </comment>
                <comment line="609">
                    small &amp; throw-away                    
                </comment>
                <comment line="616">
                    Complain about static final members of inner classes that                    
                </comment>
                <comment line="617">
                    do not have an initializer that is a constant expression.                    
                </comment>
                <comment line="618">
                    In general, static members are not permitted for inner                    
                </comment>
                <comment line="619">
                    classes, but an exception is made for named constants.                    
                </comment>
                <comment line="620">
                    Other cases of static members, including non-final ones,                    
                </comment>
                <comment line="621">
                    are handled in &apos;SourceClass&apos;.  Part of fix for 4095568.                    
                </comment>
                <comment line="630">
                    Both RuntimeExceptions and Errors should be                    
                </comment>
                <comment line="631">
                    allowed in initializers.  Fix for bug 4102541.                    
                </comment>
                <comment line="661">
                    Initializers (static and instance) must be able to complete normally.                    
                </comment>
                <scope line="436">
                    <scope line="437">
                        <declaration name="nc" type="ClassDefinition" line="439"/>
                        <scope line="441"/>
                    </scope>
                    <scope line="448">
                        <scope line="450"/>
                    </scope>
                    <scope line="465">
                        <declaration name="throwable" type="ClassDeclaration" line="466"/>
                        <declaration name="exp" type="ClassDeclaration" line="468"/>
                        <scope line="469">
                            <declaration name="def" type="ClassDefinition" line="470"/>
                            <declaration name="where" type="long" line="471"/>
                            <scope line="472"/>
                            <scope line="475"/>
                            <scope line="484"/>
                            <scope line="490"/>
                            <scope line="492"/>
                        </scope>
                    </scope>
                    <scope line="500">
                        <declaration name="length" type="int" line="501"/>
                        <scope line="503">
                            <declaration name="lf" type="LocalMember" line="504"/>
                            <declaration name="name_i" type="Identifier" line="505"/>
                            <scope line="506">
                                <declaration name="lf2" type="LocalMember" line="507"/>
                                <declaration name="name_j" type="Identifier" line="508"/>
                                <scope line="509"/>
                            </scope>
                        </scope>
                    </scope>
                    <scope line="518">
                        <scope line="521">
                            <declaration name="s" type="Statement" line="522"/>
                            <scope line="526">
                                <declaration name="f" type="LocalMember" line="527"/>
                            </scope>
                            <scope line="531">
                                <declaration name="supCall" type="Expression" line="538"/>
                                <scope line="540">
                                    <declaration name="scs" type="Statement" line="542"/>
                                </scope>
                            </scope>
                            <declaration name="exp" type="ClassDeclaration" line="550"/>
                            <declaration name="htsize" type="int" line="551"/>
                            <declaration name="thrown" type="Hashtable" line="552"/>
                            <declaration name="ignore1" type="ClassDeclaration" line="556"/>
                            <declaration name="ignore2" type="ClassDeclaration" line="558"/>
                            <scope line="561">
                                <declaration name="c" type="ClassDeclaration" line="562"/>
                                <declaration name="def" type="ClassDefinition" line="563"/>
                                <scope line="565"/>
                                <declaration name="ok" type="boolean" line="569"/>
                                <scope line="570">
                                    <scope line="571">
                                        <scope line="572"/>
                                    </scope>
                                </scope>
                                <scope line="577">
                                    <declaration name="n" type="Node" line="578"/>
                                    <declaration name="where" type="long" line="579"/>
                                    <declaration name="errorMsg" type="String" line="580"/>
                                    <scope line="582">
                                        <scope line="584"/>
                                        <scope line="594"/>
                                    </scope>
                                    <scope line="598"/>
                                    <scope line="601"/>
                                </scope>
                            </scope>
                        </scope>
                        <scope line="608">
                            <declaration name="thrown" type="Hashtable" line="609"/>
                            <declaration name="val" type="Expression" line="610"/>
                            <scope line="622">
                                <scope line="623"/>
                            </scope>
                            <declaration name="except" type="ClassDeclaration" line="632"/>
                            <declaration name="ignore1" type="ClassDeclaration" line="634"/>
                            <declaration name="ignore2" type="ClassDeclaration" line="636"/>
                            <scope line="639">
                                <declaration name="c" type="ClassDeclaration" line="640"/>
                                <declaration name="def" type="ClassDefinition" line="641"/>
                                <scope line="645">
                                    <declaration name="n" type="Node" line="646"/>
                                </scope>
                            </scope>
                        </scope>
                        <scope line="652"/>
                    </scope>
                </scope>
                <scope line="662"/>
            </method>
            <method name="getDefaultSuperCall" type="Expression" line="671">
                <params>
                    <param name="env" type="Environment"/>
                </params>
                <comment line="674">
                    does the superclass constructor require an enclosing instance?                    
                </comment>
                <declaration name="se" type="Expression" line="672"/>
                <declaration name="sclass" type="ClassDefinition" line="673"/>
                <declaration name="reqc" type="ClassDefinition" line="675"/>
                <declaration name="thisc" type="ClassDefinition" line="678"/>
                <scope line="679"/>
                <scope line="683"/>
            </method>
            <javadoc line="689">
                Inline the field                
            </javadoc>
            <method name="inline" type="void" line="692">
                <params>
                    <param name="env" type="Environment"/>
                </params>
                <comment line="717">
                    some classes are checked and inlined separately                    
                </comment>
                <comment line="730">
                    Cf. &quot;thisArg&quot; in SourceClass.checkMembers().                    
                </comment>
                <scope line="700"/>
                <scope line="706">
                    <scope line="707">
                        <declaration name="s" type="Statement" line="708"/>
                        <declaration name="ctx" type="Context" line="709"/>
                        <scope line="710">
                            <declaration name="local" type="LocalMember" line="711"/>
                        </scope>
                    </scope>
                </scope>
                <scope line="716">
                    <declaration name="nc" type="ClassDefinition" line="718"/>
                    <scope line="720"/>
                </scope>
                <scope line="726">
                    <scope line="727">
                        <declaration name="ctx" type="Context" line="728"/>
                        <scope line="729">
                            <declaration name="ctxInst" type="Context" line="731"/>
                            <declaration name="thisArg" type="LocalMember" line="732"/>
                        </scope>
                        <scope line="737"/>
                    </scope>
                </scope>
                <scope line="743">
                    <scope line="745"/>
                    <scope line="748"/>
                </scope>
            </method>
            <javadoc line="757">
                Get the value of the field (or null if the value can&apos;t be determined)                
            </javadoc>
            <method name="getValue" type="Node" line="760">
                <params>
                    <param name="env" type="Environment"/>
                </params>
                <comment line="763">
                    be sure to get the imports right:                    
                </comment>
                <declaration name="value" type="Node" line="761"/>
                <scope line="762"/>
            </method>
            <method name="isInlineable" type="boolean" line="771">
                <params>
                    <param name="env" type="Environment"/>
                    <param name="fromFinal" type="boolean"/>
                </params>
                <scope line="772"/>
            </method>
            <javadoc line="780">
                Get the initial value of the field                
            </javadoc>
            <method name="getInitialValue" type="Object" line="783">
                <scope line="784"/>
            </method>
            <javadoc line="790">
                Generate code                
            </javadoc>
            <method name="code" type="void" line="793">
                <params>
                    <param name="env" type="Environment"/>
                    <param name="asm" type="Assembler"/>
                </params>
                <comment line="806">
                    Actually generate code                    
                </comment>
                <comment line="818">
                    ctx.declare(env, (LocalMember)e.nextElement());                    
                </comment>
                <comment line="821">
                    if (isConstructor() &amp;&amp; ((s == null) || (s.firstConstructor() == null))) {
                    ClassDeclaration c = getClassDefinition().getSuperClass();
                    if (c != null) {
                    MemberDefinition field = c.getClassDefinition(env).matchMethod(env, getClassDefinition(), idInit);
                    asm.add(getWhere(), opc_aload, new Integer(0));
                    asm.add(getWhere(), opc_invokespecial, field);
                    asm.add(getWhere(), opc_pop);
                    }
                    
                     Output initialization code
                    for (MemberDefinition f = getClassDefinition().getFirstMember() ; f != null ; f = f.getNextMember()) {
                    if (!f.isStatic()) {
                    f.codeInit(env, ctx, asm);
                    }
                    }
                    }                    
                </comment>
                <scope line="807"/>
                <scope line="810">
                    <declaration name="ctx" type="Context" line="812"/>
                    <declaration name="s" type="Statement" line="813"/>
                    <scope line="815">
                        <declaration name="f" type="LocalMember" line="816"/>
                    </scope>
                    <scope line="839"/>
                    <scope line="842"/>
                </scope>
            </method>
            <method name="codeInit" type="void" line="850">
                <params>
                    <param name="env" type="Environment"/>
                    <param name="ctx" type="Context"/>
                    <param name="asm" type="Assembler"/>
                </params>
                <comment line="866">
                    Actually generate code                    
                </comment>
                <comment line="872">
                    The JLS Section 8.5 specifies that static (non-final)                    
                </comment>
                <comment line="873">
                    initializers should be executed in textual order.  Eliding                    
                </comment>
                <comment line="874">
                    initializations to default values can interfere with this,                    
                </comment>
                <comment line="875">
                    so the tests for !e.equalsDefault() have been eliminated,                    
                </comment>
                <comment line="876">
                    below.                    
                </comment>
                <comment line="879">
                    removed: &amp;&amp; !e.equalsDefault()) {                    
                </comment>
                <comment line="883">
                    removed: if (!e.equalsDefault()) {                    
                </comment>
                <comment line="884">
                    This code doesn&apos;t appear to be reached for                    
                </comment>
                <comment line="885">
                    instance initializers.  Code for these is generated                    
                </comment>
                <comment line="886">
                    in the makeVarInits() method of the class                    
                </comment>
                <comment line="887">
                    MethodExpression.                    
                </comment>
                <scope line="851"/>
                <scope line="867"/>
                <scope line="870">
                    <declaration name="e" type="Expression" line="871"/>
                    <scope line="877">
                        <scope line="878"/>
                    </scope>
                    <scope line="883"/>
                </scope>
            </method>
            <javadoc line="897">
                Print for debugging                
            </javadoc>
            <method name="print" type="void" line="900">
                <params>
                    <param name="out" type="PrintStream"/>
                </params>
                <scope line="902"/>
            </method>
        </class>
    </source>