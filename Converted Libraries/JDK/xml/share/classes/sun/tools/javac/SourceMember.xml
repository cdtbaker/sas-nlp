<?xml version="1.0" encoding="UTF-8"?>
    <source package="sun.tools.javac">
        <import package="sun.tools.java"/>
        <import package="sun.tools.tree"/>
        <import package="sun.tools.asm"/>
        <import package="java.util.Vector"/>
        <import package="java.util.Enumeration"/>
        <import package="java.util.Hashtable"/>
        <import package="java.io.PrintStream"/>
        <class name="SourceMember" line="36">
            <extends class="MemberDefinition"/>
            <comment line="52">
                set to the MemberDefinition in the interface if we have this field because
                 it has been forced on us                
            </comment>
            <comment line="131">
                The methods addOuterThis() and addUplevelArguments() were
                 both originally part of a single method called addUplevelArguments()
                 which took a single boolean parameter describing which of the
                 two behaviors it wanted.
                
                 The original addUplevelArguments() claimed to keep the arguments in
                 the following order:
                
                 (1) &lt;this&gt; &lt;early outer this&gt; &lt;uplevel arguments...&gt; &lt;true arguments...&gt;
                
                 (By &lt;early outer this&gt; I am referring to the clientOuterField added
                 to some constructors when they are created.  If an outer this is
                 added later, on demand, then this is mixed in with the rest of the
                 uplevel arguments and is added by addUplevelArguments.)
                
                 In reality, the `args&apos; Vector was generated in this order, but the
                 Type array `argTypes&apos; was generated as:
                
                 (2) &lt;this&gt; &lt;uplevel arguments...&gt; &lt;early outer this&gt; &lt;true arguments...&gt;
                
                 This didn&apos;t make a difference in the common case -- that is, when
                 a class had an &lt;outer.this&gt; or &lt;uplevel arguments...&gt; but not both.
                 Both can happen in the case that a member class is declared inside
                 of a local class.  It seems that the calling sequences, generated
                 in places like NewInstanceExpression.codeCommon(), use order (2),
                 so I have changed the code below to stick with that order.  Since
                 the only time this happens is in classes which are insideLocal, no
                 one should be able to tell the difference between these orders.
                 (bug number 4085633)                
            </comment>
            <comment line="671">
                helper to check(): synthesize a missing super() call                
            </comment>
            <implements interface="Constants"/>
            <javadoc line="36">
                A Source Member
                  WARNING: The contents of this source file are not part of any
                  supported API.  Code that depends on them does so at its own risk:
                  they are subject to change or removal without notice.                
            </javadoc>
            <declaration name="args" type="Vector" line="46"/>
            <javadoc line="46">
                The argument names (if it is a method)                
            </javadoc>
            <declaration name="abstractSource" type="MemberDefinition" line="53"/>
            <declaration name="status" type="int" line="55"/>
            <javadoc line="55">
                The status of the field                
            </javadoc>
            <declaration name="PARSED" type="int" line="60"/>
            <declaration name="CHECKING" type="int" line="61"/>
            <declaration name="CHECKED" type="int" line="62"/>
            <declaration name="INLINING" type="int" line="63"/>
            <declaration name="INLINED" type="int" line="64"/>
            <declaration name="ERROR" type="int" line="65"/>
            <method name="getArguments" type="Vector" line="67"/>
            <javadoc line="71">
                Constructor                
                <param>
                    argNames a vector of IdentifierToken                    
                </param>
            </javadoc>
            <method name="SourceMember" type="constructor" line="78">
                <params>
                    <param name="where" type="long"/>
                    <param name="clazz" type="ClassDefinition"/>
                    <param name="doc" type="String"/>
                    <param name="modifiers" type="int"/>
                    <param name="type" type="Type"/>
                    <param name="name" type="Identifier"/>
                    <param name="argNames" type="Vector"/>
                    <param name="exp" type="IdentifierToken"/>
                    <param name="value" type="Node"/>
                </params>
                <comment line="82">
                    for the moment                    
                </comment>
                <comment line="83">
                    not until type names are resolved: createArgumentFields(argNames);                    
                </comment>
                <scope line="84"/>
            </method>
            <method name="createArgumentFields" type="void" line="89">
                <params>
                    <param name="argNames" type="Vector"/>
                </params>
                <comment line="91">
                    Create a list of arguments                    
                </comment>
                <comment line="105">
                    This should not happen, but it does
                     in cases of vicious cyclic inheritance.                    
                </comment>
                <comment line="114">
                    allow argNames to be simple Identifiers (deprecated!)                    
                </comment>
                <scope line="91">
                    <scope line="94"/>
                    <scope line="98">
                        <declaration name="e" type="Enumeration" line="99"/>
                        <declaration name="argTypes" type="Type" line="100"/>
                        <scope line="101">
                            <declaration name="x" type="Object" line="102"/>
                            <scope line="103"/>
                            <declaration name="id" type="Identifier" line="109"/>
                            <declaration name="mod" type="int" line="110"/>
                            <declaration name="where" type="long" line="111"/>
                            <scope line="112"/>
                            <scope line="117">
                                <declaration name="token" type="IdentifierToken" line="118"/>
                            </scope>
                        </scope>
                    </scope>
                </scope>
            </method>
            <declaration name="outerThisArg" type="LocalMember" line="160"/>
            <javadoc line="162">
                Get outer instance link, or null if none.                
            </javadoc>
            <method name="getOuterThisArg" type="LocalMember" line="166"/>
            <javadoc line="170">
                Add the outer.this argument to the list of arguments for this
                  constructor.  This is called from resolveTypeStructure.  Any
                  additional uplevel arguments get added later by addUplevelArguments().                
            </javadoc>
            <method name="addOuterThis" type="void" line="176">
                <comment line="180">
                    See if we have a client outer field.                    
                </comment>
                <comment line="186">
                    There is no outer this argument.  Quit.                    
                </comment>
                <comment line="191">
                    Get the old arg types.                    
                </comment>
                <comment line="194">
                    And make an array for the new ones with space for one more.                    
                </comment>
                <comment line="200">
                    args is our list of arguments.  It contains a `this&apos;, so
                     we insert at position 1.  The list of types does not have a
                     this, so we insert at position 0.                    
                </comment>
                <comment line="206">
                    Add on the rest of the constructor arguments.                    
                </comment>
                <declaration name="refs" type="UplevelReference" line="177"/>
                <scope line="181"/>
                <scope line="186"/>
                <declaration name="oldArgTypes" type="Type" line="191"/>
                <declaration name="argTypes" type="Type" line="194"/>
                <declaration name="arg" type="LocalMember" line="196"/>
                <scope line="206"/>
            </method>
            <javadoc line="213">
                Prepend argument names and argument types for local variable references.
                  This information is never seen by the type-check phase,
                  but it affects code generation, which is the earliest moment
                  we have comprehensive information on uplevel references.
                  The code() methods tweaks the constructor calls, prepending
                  the proper values to the argument list.                
            </javadoc>
            <method name="addUplevelArguments" type="void" line="221">
                <comment line="226">
                    Count how many uplevels we have to add.                    
                </comment>
                <comment line="235">
                    None to add, quit.                    
                </comment>
                <comment line="239">
                    Get the old argument types.                    
                </comment>
                <comment line="242">
                    Make an array with enough room for the new.                    
                </comment>
                <comment line="245">
                    Add all of the late uplevel references to args and argTypes.
                     Note that they are `off-by-one&apos; because of the `this&apos;.                    
                </comment>
                <comment line="259">
                    Add the rest of the old arguments.                    
                </comment>
                <declaration name="refs" type="UplevelReference" line="222"/>
                <declaration name="count" type="int" line="226"/>
                <scope line="227">
                    <scope line="228"/>
                </scope>
                <scope line="233"/>
                <declaration name="oldArgTypes" type="Type" line="239"/>
                <declaration name="argTypes" type="Type" line="242"/>
                <declaration name="ins" type="int" line="246"/>
                <scope line="247">
                    <scope line="248">
                        <declaration name="arg" type="LocalMember" line="249"/>
                    </scope>
                </scope>
                <scope line="259"/>
            </method>
            <javadoc line="266">
                Constructor for an inner class.                
            </javadoc>
            <method name="SourceMember" type="constructor" line="269">
                <params>
                    <param name="innerClass" type="ClassDefinition"/>
                </params>
            </method>
            <javadoc line="273">
                Constructor.
                  Used only to generate an abstract copy of a method that a class
                  inherits from an interface                
            </javadoc>
            <method name="SourceMember" type="constructor" line="278">
                <params>
                    <param name="f" type="MemberDefinition"/>
                    <param name="c" type="ClassDefinition"/>
                    <param name="env" type="Environment"/>
                </params>
            </method>
            <javadoc line="287">
                Get exceptions                
            </javadoc>
            <method name="getExceptions" type="ClassDeclaration[]" line="290">
                <params>
                    <param name="env" type="Environment"/>
                </params>
                <comment line="296">
                    (should not happen)                    
                </comment>
                <comment line="300">
                    be sure to get the imports right:                    
                </comment>
                <scope line="291"/>
                <scope line="294"/>
                <scope line="302">
                    <declaration name="e" type="Identifier" line="303"/>
                    <declaration name="rexp" type="Identifier" line="304"/>
                </scope>
            </method>
            <javadoc line="310">
                Set array of name-resolved exceptions directly, e.g., for access methods.                
            </javadoc>
            <method name="setExceptions" type="void" line="313">
                <params>
                    <param name="exp" type="ClassDeclaration[]"/>
                </params>
            </method>
            <declaration name="resolved" type="boolean" line="317"/>
            <javadoc line="317">
                Resolve types in a field, after parsing.                
                <see>
                    ClassDefinition.resolveTypeStructure                    
                </see>
            </javadoc>
            <method name="resolveTypeStructure" type="void" line="324">
                <params>
                    <param name="env" type="Environment"/>
                </params>
                <comment line="328">
                    A member should only be resolved once.  For a constructor, it is imperative
                     that &apos;addOuterThis&apos; be called only once, else the outer instance argument may
                     be inserted into the argument list multiple times.                    
                </comment>
                <comment line="334">
                    This case shouldn&apos;t be happening.  It is the responsibility
                     of our callers to avoid attempting multiple resolutions of a member.
                     *** REMOVE FOR SHIPMENT? ***                    
                </comment>
                <comment line="338">
                    return;                    
                </comment>
                <comment line="352">
                    Expand all class names in &apos;type&apos;, including those that are not
                     fully-qualified or refer to inner classes, into fully-qualified
                     names.  Local and anonymous classes get synthesized names here,
                     corresponding to the class files that will be generated.  This is
                     currently the only place where &apos;resolveNames&apos; is used.                    
                </comment>
                <comment line="359">
                    do the throws also:                    
                </comment>
                <comment line="365">
                    Add outer instance argument for constructors.                    
                </comment>
                <scope line="331"/>
                <scope line="338"/>
                <scope line="344">
                    <declaration name="nc" type="ClassDefinition" line="345"/>
                    <scope line="346"/>
                </scope>
                <scope line="350">
                    <scope line="361">
                        <declaration name="argNames" type="Vector" line="362"/>
                        <scope line="365"/>
                    </scope>
                </scope>
            </method>
            <javadoc line="373">
                Get the class declaration in which the field is actually defined                
            </javadoc>
            <method name="getDefiningClassDeclaration" type="ClassDeclaration" line="376"/>
            <javadoc line="383">
                A source field never reports deprecation, since the compiler
                  allows access to deprecated features that are being compiled
                  in the same job.                
            </javadoc>
            <method name="reportDeprecated" type="boolean" line="388">
                <params>
                    <param name="env" type="Environment"/>
                </params>
            </method>
            <javadoc line="392">
                Check this field.
                  &lt;p&gt;
                  This is the method which requests checking.
                  The real work is done by
                  &lt;tt&gt;Vset check(Environment, Context, Vset)&lt;/tt&gt;.                
            </javadoc>
            <method name="check" type="void" line="399">
                <params>
                    <param name="env" type="Environment"/>
                </params>
                <comment line="403">
                    rely on the class to check all fields in the proper order                    
                </comment>
                <comment line="406">
                    break a big cycle for small synthetic variables                    
                </comment>
                <scope line="403">
                    <scope line="404"/>
                    <scope line="413">
                        <scope line="414"/>
                        <scope line="416"/>
                    </scope>
                </scope>
            </method>
            <javadoc line="427">
                Check a field.                
                <param>
                    vset tells which uplevel variables are definitely assigned
                      The vset is also used to track the initialization of blank finals
                      by whichever fields which are relevant to them.                    
                </param>
            </javadoc>
            <method name="check" type="Vset" line="433">
                <params>
                    <param name="env" type="Environment"/>
                    <param name="ctx" type="Context"/>
                    <param name="vset" type="Vset"/>
                </params>
                <comment line="439">
                    some classes are checked separately                    
                </comment>
                <comment line="458">
                    This is where all checking of names appearing within the type
                     of the member is done.  Includes return type and argument types.
                     Since only one location (&apos;where&apos;) for error messages is provided,
                     localization of errors is poor.  Throws clauses are handled below.                    
                </comment>
                <comment line="464">
                    Make sure that all the classes that we claim to throw really
                     are subclasses of Throwable, and are classes that we can reach                    
                </comment>
                <comment line="479">
                    Validate access for all inner-class components
                     of a qualified name, not just the last one, which
                     is checked below.  Yes, this is a dirty hack...
                     Part of fix for 4094658.                    
                </comment>
                <comment line="524">
                    initialize vset, indication that each of the arguments
                     to the function has a value                    
                </comment>
                <comment line="533">
                    Undefine &quot;this&quot; in some constructors, until after
                     the super constructor has been called.                    
                </comment>
                <comment line="537">
                    If the first thing in the definition isn&apos;t a call
                     to either super() or this(), then insert one.                    
                </comment>
                <comment line="550">
                    System.out.println(&quot;VSET = &quot; + vset);                    
                </comment>
                <comment line="587">
                    If this message is being generated for
                     a default constructor, we should give
                     a different error message.  Currently
                     we check for this by seeing if the
                     constructor has the same &quot;where&quot; as
                     its class.  This is a bit kludgy, but
                     works. (bug id 4034836)                    
                </comment>
                <comment line="596">
                    Constructor with uncaught exception.                    
                </comment>
                <comment line="600">
                    Initializer with uncaught exception.                    
                </comment>
                <comment line="603">
                    Method with uncaught exception.                    
                </comment>
                <comment line="610">
                    small &amp; throw-away                    
                </comment>
                <comment line="617">
                    Complain about static final members of inner classes that
                     do not have an initializer that is a constant expression.
                     In general, static members are not permitted for inner
                     classes, but an exception is made for named constants.
                     Other cases of static members, including non-final ones,
                     are handled in &apos;SourceClass&apos;.  Part of fix for 4095568.                    
                </comment>
                <comment line="631">
                    Both RuntimeExceptions and Errors should be
                     allowed in initializers.  Fix for bug 4102541.                    
                </comment>
                <comment line="662">
                    Initializers (static and instance) must be able to complete normally.                    
                </comment>
                <scope line="436">
                    <scope line="437">
                        <declaration name="nc" type="ClassDefinition" line="439"/>
                        <scope line="441"/>
                    </scope>
                    <scope line="448">
                        <scope line="450"/>
                    </scope>
                    <scope line="465">
                        <declaration name="throwable" type="ClassDeclaration" line="466"/>
                        <declaration name="exp" type="ClassDeclaration" line="468"/>
                        <scope line="469">
                            <declaration name="def" type="ClassDefinition" line="470"/>
                            <declaration name="where" type="long" line="471"/>
                            <scope line="472"/>
                            <scope line="475"/>
                            <scope line="484"/>
                            <scope line="490"/>
                            <scope line="492"/>
                        </scope>
                    </scope>
                    <scope line="500">
                        <declaration name="length" type="int" line="501"/>
                        <scope line="503">
                            <declaration name="lf" type="LocalMember" line="504"/>
                            <declaration name="name_i" type="Identifier" line="505"/>
                            <scope line="506">
                                <declaration name="lf2" type="LocalMember" line="507"/>
                                <declaration name="name_j" type="Identifier" line="508"/>
                                <scope line="509"/>
                            </scope>
                        </scope>
                    </scope>
                    <scope line="518">
                        <scope line="521">
                            <declaration name="s" type="Statement" line="522"/>
                            <scope line="526">
                                <declaration name="f" type="LocalMember" line="527"/>
                            </scope>
                            <scope line="531">
                                <declaration name="supCall" type="Expression" line="538"/>
                                <scope line="540">
                                    <declaration name="scs" type="Statement" line="542"/>
                                </scope>
                            </scope>
                            <declaration name="exp" type="ClassDeclaration" line="550"/>
                            <declaration name="htsize" type="int" line="551"/>
                            <declaration name="thrown" type="Hashtable" line="552"/>
                            <declaration name="ignore1" type="ClassDeclaration" line="556"/>
                            <declaration name="ignore2" type="ClassDeclaration" line="558"/>
                            <scope line="561">
                                <declaration name="c" type="ClassDeclaration" line="562"/>
                                <declaration name="def" type="ClassDefinition" line="563"/>
                                <scope line="565"/>
                                <declaration name="ok" type="boolean" line="569"/>
                                <scope line="570">
                                    <scope line="571">
                                        <scope line="572"/>
                                    </scope>
                                </scope>
                                <scope line="577">
                                    <declaration name="n" type="Node" line="578"/>
                                    <declaration name="where" type="long" line="579"/>
                                    <declaration name="errorMsg" type="String" line="580"/>
                                    <scope line="582">
                                        <scope line="584"/>
                                        <scope line="594"/>
                                    </scope>
                                    <scope line="598"/>
                                    <scope line="601"/>
                                </scope>
                            </scope>
                        </scope>
                        <scope line="608">
                            <declaration name="thrown" type="Hashtable" line="609"/>
                            <declaration name="val" type="Expression" line="610"/>
                            <scope line="622">
                                <scope line="623"/>
                            </scope>
                            <declaration name="except" type="ClassDeclaration" line="632"/>
                            <declaration name="ignore1" type="ClassDeclaration" line="634"/>
                            <declaration name="ignore2" type="ClassDeclaration" line="636"/>
                            <scope line="639">
                                <declaration name="c" type="ClassDeclaration" line="640"/>
                                <declaration name="def" type="ClassDefinition" line="641"/>
                                <scope line="645">
                                    <declaration name="n" type="Node" line="646"/>
                                </scope>
                            </scope>
                        </scope>
                        <scope line="652"/>
                    </scope>
                </scope>
                <scope line="662"/>
            </method>
            <method name="getDefaultSuperCall" type="Expression" line="671">
                <params>
                    <param name="env" type="Environment"/>
                </params>
                <comment line="675">
                    does the superclass constructor require an enclosing instance?                    
                </comment>
                <declaration name="se" type="Expression" line="672"/>
                <declaration name="sclass" type="ClassDefinition" line="673"/>
                <declaration name="reqc" type="ClassDefinition" line="675"/>
                <declaration name="thisc" type="ClassDefinition" line="678"/>
                <scope line="679"/>
                <scope line="683"/>
            </method>
            <javadoc line="689">
                Inline the field                
            </javadoc>
            <method name="inline" type="void" line="692">
                <params>
                    <param name="env" type="Environment"/>
                </params>
                <comment line="718">
                    some classes are checked and inlined separately                    
                </comment>
                <comment line="731">
                    Cf. &quot;thisArg&quot; in SourceClass.checkMembers().                    
                </comment>
                <scope line="700"/>
                <scope line="706">
                    <scope line="707">
                        <declaration name="s" type="Statement" line="708"/>
                        <declaration name="ctx" type="Context" line="709"/>
                        <scope line="710">
                            <declaration name="local" type="LocalMember" line="711"/>
                        </scope>
                    </scope>
                </scope>
                <scope line="716">
                    <declaration name="nc" type="ClassDefinition" line="718"/>
                    <scope line="720"/>
                </scope>
                <scope line="726">
                    <scope line="727">
                        <declaration name="ctx" type="Context" line="728"/>
                        <scope line="729">
                            <declaration name="ctxInst" type="Context" line="731"/>
                            <declaration name="thisArg" type="LocalMember" line="732"/>
                        </scope>
                        <scope line="737"/>
                    </scope>
                </scope>
                <scope line="743">
                    <scope line="745"/>
                    <scope line="748"/>
                </scope>
            </method>
            <javadoc line="757">
                Get the value of the field (or null if the value can&apos;t be determined)                
            </javadoc>
            <method name="getValue" type="Node" line="760">
                <params>
                    <param name="env" type="Environment"/>
                </params>
                <comment line="764">
                    be sure to get the imports right:                    
                </comment>
                <declaration name="value" type="Node" line="761"/>
                <scope line="762"/>
            </method>
            <method name="isInlineable" type="boolean" line="771">
                <params>
                    <param name="env" type="Environment"/>
                    <param name="fromFinal" type="boolean"/>
                </params>
                <scope line="772"/>
            </method>
            <javadoc line="780">
                Get the initial value of the field                
            </javadoc>
            <method name="getInitialValue" type="Object" line="783">
                <scope line="784"/>
            </method>
            <javadoc line="790">
                Generate code                
            </javadoc>
            <method name="code" type="void" line="793">
                <params>
                    <param name="env" type="Environment"/>
                    <param name="asm" type="Assembler"/>
                </params>
                <comment line="807">
                    Actually generate code                    
                </comment>
                <comment line="819">
                    ctx.declare(env, (LocalMember)e.nextElement());                    
                </comment>
                <comment line="822">
                    if (isConstructor() &amp;&amp; ((s == null) || (s.firstConstructor() == null))) {
                    ClassDeclaration c = getClassDefinition().getSuperClass();
                    if (c != null) {
                    MemberDefinition field = c.getClassDefinition(env).matchMethod(env, getClassDefinition(), idInit);
                    asm.add(getWhere(), opc_aload, new Integer(0));
                    asm.add(getWhere(), opc_invokespecial, field);
                    asm.add(getWhere(), opc_pop);
                    }
                    
                     Output initialization code
                    for (MemberDefinition f = getClassDefinition().getFirstMember() ; f != null ; f = f.getNextMember()) {
                    if (!f.isStatic()) {
                    f.codeInit(env, ctx, asm);
                    }
                    }
                    }                    
                </comment>
                <scope line="807"/>
                <scope line="810">
                    <declaration name="ctx" type="Context" line="812"/>
                    <declaration name="s" type="Statement" line="813"/>
                    <scope line="815">
                        <declaration name="f" type="LocalMember" line="816"/>
                    </scope>
                    <scope line="839"/>
                    <scope line="842"/>
                </scope>
            </method>
            <method name="codeInit" type="void" line="850">
                <params>
                    <param name="env" type="Environment"/>
                    <param name="ctx" type="Context"/>
                    <param name="asm" type="Assembler"/>
                </params>
                <comment line="867">
                    Actually generate code                    
                </comment>
                <comment line="873">
                    The JLS Section 8.5 specifies that static (non-final)
                     initializers should be executed in textual order.  Eliding
                     initializations to default values can interfere with this,
                     so the tests for !e.equalsDefault() have been eliminated,
                     below.                    
                </comment>
                <comment line="880">
                    removed: &amp;&amp; !e.equalsDefault()) {                    
                </comment>
                <comment line="884">
                    removed: if (!e.equalsDefault()) {                    
                </comment>
                <comment line="885">
                    This code doesn&apos;t appear to be reached for
                     instance initializers.  Code for these is generated
                     in the makeVarInits() method of the class
                     MethodExpression.                    
                </comment>
                <scope line="851"/>
                <scope line="867"/>
                <scope line="870">
                    <declaration name="e" type="Expression" line="871"/>
                    <scope line="877">
                        <scope line="878"/>
                    </scope>
                    <scope line="883"/>
                </scope>
            </method>
            <javadoc line="897">
                Print for debugging                
            </javadoc>
            <method name="print" type="void" line="900">
                <params>
                    <param name="out" type="PrintStream"/>
                </params>
                <scope line="902"/>
            </method>
        </class>
    </source>