<?xml version="1.0" encoding="UTF-8"?>
    <source package="sun.tools.asm">
        <import package="sun.tools.java"/>
        <import package="java.io.IOException"/>
        <import package="java.io.DataOutputStream"/>
        <class name="LocalVariableTable" line="32">
            <javadoc line="32">
                This class is used to assemble the local variable table.
                  WARNING: The contents of this source file are not part of any
                  supported API.  Code that depends on them does so at its own risk:
                  they are subject to change or removal without notice.                
                <author>
                    Arthur van Hoff                    
                </author>
            </javadoc>
            <declaration name="locals" type="LocalVariable" line="43"/>
            <declaration name="len" type="int" line="44"/>
            <javadoc line="46">
                Define a new local variable. Merge entries where possible.                
            </javadoc>
            <method name="define" type="void" line="49">
                <params>
                    <param name="field" type="MemberDefinition"/>
                    <param name="slot" type="int"/>
                    <param name="from" type="int"/>
                    <param name="to" type="int"/>
                </params>
                <scope line="50"/>
                <scope line="53">
                    <scope line="55"/>
                </scope>
                <scope line="61">
                    <declaration name="newlocals" type="LocalVariable" line="62"/>
                </scope>
            </method>
            <javadoc line="69">
                Trim overlapping local ranges.  Java forbids shadowing of
                  locals in nested scopes, but non-nested scopes may still declare
                  locals with the same name.  Because local variable ranges are
                  computed using flow analysis as part of assembly, it isn&apos;t
                  possible to simply make sure variable ranges end where the
                  enclosing lexical scope ends.  This method makes sure that
                  variables with the same name don&apos;t overlap, giving priority to
                  fields with higher slot numbers that should have appeared later
                  in the source.                
            </javadoc>
            <method name="trim_ranges" type="void" line="80">
                <comment line="86">
                    At this point we know that both ranges are                    
                </comment>
                <comment line="87">
                    the same name and there is also overlap or they abut                    
                </comment>
                <comment line="92">
                    We&apos;ve detected two local variables with the                    
                </comment>
                <comment line="93">
                    same name, and the one with the greater slot                    
                </comment>
                <comment line="94">
                    number starts before the other.  This order                    
                </comment>
                <comment line="95">
                    reversal may happen with locals with the same                    
                </comment>
                <comment line="96">
                    name declared in both a try body and an                    
                </comment>
                <comment line="97">
                    associated catch clause.  This is rare, and                    
                </comment>
                <comment line="98">
                    we give up.                    
                </comment>
                <comment line="104">
                    Same situation as above; just give up.                    
                </comment>
                <comment line="107">
                    This case can happen if there are two variables                    
                </comment>
                <comment line="108">
                    with the same name and slot numbers, and ranges                    
                </comment>
                <comment line="109">
                    that abut.  AFAIK the only way this can occur                    
                </comment>
                <comment line="110">
                    is with multiple static initializers.  Punt.                    
                </comment>
                <scope line="81">
                    <scope line="82">
                        <scope line="85">
                            <scope line="88">
                                <scope line="89"/>
                                <scope line="91"/>
                            </scope>
                            <scope line="100">
                                <scope line="101"/>
                                <scope line="103"/>
                            </scope>
                            <scope line="106"/>
                        </scope>
                    </scope>
                </scope>
            </method>
            <javadoc line="117">
                Write out the data.                
            </javadoc>
            <method name="write" type="void" line="120">
                <params>
                    <param name="env" type="Environment"/>
                    <param name="out" type="DataOutputStream"/>
                    <param name="tab" type="ConstantPool"/>
                </params>
                <comment line="124">
                    System.out.println(&quot;pc=&quot; + locals[i].from + &quot;, len=&quot; + (locals[i].to - locals[i].from) + &quot;, nm=&quot; + locals[i].field.getName() + &quot;, slot=&quot; + locals[i].slot);                    
                </comment>
                <scope line="123"/>
            </method>
        </class>
    </source>