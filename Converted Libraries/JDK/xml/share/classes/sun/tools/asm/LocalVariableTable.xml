<?xml version="1.0" encoding="UTF-8"?>
    <source package="sun.tools.asm">
        <import package="sun.tools.java"/>
        <import package="java.io.IOException"/>
        <import package="java.io.DataOutputStream"/>
        <class name="LocalVariableTable" line="32">
            <javadoc line="32">
                This class is used to assemble the local variable table.
                  WARNING: The contents of this source file are not part of any
                  supported API.  Code that depends on them does so at its own risk:
                  they are subject to change or removal without notice.                
                <author>
                    Arthur van Hoff                    
                </author>
            </javadoc>
            <declaration name="locals" type="LocalVariable" line="43"/>
            <declaration name="len" type="int" line="44"/>
            <javadoc line="46">
                Define a new local variable. Merge entries where possible.                
            </javadoc>
            <method name="define" type="void" line="49">
                <params>
                    <param name="field" type="MemberDefinition"/>
                    <param name="slot" type="int"/>
                    <param name="from" type="int"/>
                    <param name="to" type="int"/>
                </params>
                <scope line="50"/>
                <scope line="53">
                    <scope line="55"/>
                </scope>
                <scope line="61">
                    <declaration name="newlocals" type="LocalVariable" line="62"/>
                </scope>
            </method>
            <javadoc line="69">
                Trim overlapping local ranges.  Java forbids shadowing of
                  locals in nested scopes, but non-nested scopes may still declare
                  locals with the same name.  Because local variable ranges are
                  computed using flow analysis as part of assembly, it isn&apos;t
                  possible to simply make sure variable ranges end where the
                  enclosing lexical scope ends.  This method makes sure that
                  variables with the same name don&apos;t overlap, giving priority to
                  fields with higher slot numbers that should have appeared later
                  in the source.                
            </javadoc>
            <method name="trim_ranges" type="void" line="80">
                <comment line="87">
                    At this point we know that both ranges are
                     the same name and there is also overlap or they abut                    
                </comment>
                <comment line="93">
                    We&apos;ve detected two local variables with the
                     same name, and the one with the greater slot
                     number starts before the other.  This order
                     reversal may happen with locals with the same
                     name declared in both a try body and an
                     associated catch clause.  This is rare, and
                     we give up.                    
                </comment>
                <comment line="105">
                    Same situation as above; just give up.                    
                </comment>
                <comment line="108">
                    This case can happen if there are two variables
                     with the same name and slot numbers, and ranges
                     that abut.  AFAIK the only way this can occur
                     is with multiple static initializers.  Punt.                    
                </comment>
                <scope line="81">
                    <scope line="82">
                        <scope line="85">
                            <scope line="88">
                                <scope line="89"/>
                                <scope line="91"/>
                            </scope>
                            <scope line="100">
                                <scope line="101"/>
                                <scope line="103"/>
                            </scope>
                            <scope line="106"/>
                        </scope>
                    </scope>
                </scope>
            </method>
            <javadoc line="117">
                Write out the data.                
            </javadoc>
            <method name="write" type="void" line="120">
                <params>
                    <param name="env" type="Environment"/>
                    <param name="out" type="DataOutputStream"/>
                    <param name="tab" type="ConstantPool"/>
                </params>
                <comment line="125">
                    System.out.println(&quot;pc=&quot; + locals[i].from + &quot;, len=&quot; + (locals[i].to - locals[i].from) + &quot;, nm=&quot; + locals[i].field.getName() + &quot;, slot=&quot; + locals[i].slot);                    
                </comment>
                <scope line="123"/>
            </method>
        </class>
    </source>