<?xml version="1.0" encoding="UTF-8"?>
    <source package="sun.tools.tree">
        <import package="sun.tools.java"/>
        <import package="sun.tools.asm"/>
        <import package="java.io.PrintStream"/>
        <import package="java.util.Hashtable"/>
        <class name="FieldExpression" line="33">
            <extends class="UnaryExpression"/>
            <comment line="45">
                The class from which the field is select ed.                
            </comment>
            <comment line="48">
                For an expression of the form &apos;&lt;class&gt;.super&apos;, then                
            </comment>
            <comment line="49">
                this is &lt;class&gt;, else null.                
            </comment>
            <comment line="100">
                Convert a qualified name into a type.
                 Performs a careful check of each inner-class component,
                 including the JLS 6.6.1 access checks that were omitted
                 in &apos;FieldExpression.toType&apos;.
                 &lt;p&gt;
                 This code is similar to &apos;checkCommon&apos;, which could be cleaned
                 up a bit long the lines we have done here.                
            </comment>
            <comment line="109">
                -------------------------------------------------------
                Type toQualifiedType(Environment env, Context ctx) {
                ClassDefinition ctxClass = ctx.field.getClassDefinition();
                Type rty = right.toQualifiedType(env, ctx);
                if (rty == Type.tPackage) {
                 Is this field expression a non-inner type?
                Identifier nm = toIdentifier(this);
                if ((nm != null) &amp;&amp; env.classExists(nm)) {
                Type t = Type.tClass(nm);
                if (env.resolve(where, ctxClass, t)) {
                return t;
                } else {
                return null;
                }
                }
                 Not a type.  Must be a package prefix.
                return Type.tPackage;
                }
                if (rty == null) {
                 An error was already reported, so quit.
                return null;
                }
                
                 Check inner-class qualification while unwinding from recursion.
                try {
                ClassDefinition rightClass = env.getClassDefinition(rty);
                
                 Local variables, which cannot be inner classes,
                 are ignored here, and thus will not hide inner
                 classes.  Is this correct?
                MemberDefinition field = rightClass.getInnerClass(env, id);
                if (field == null) {
                env.error(where, &quot;inner.class.expected&quot;, id, rightClass);
                return Type.tError;
                }
                
                ClassDefinition innerClass = field.getInnerClass();
                Type t = innerClass.getType();
                
                if (!ctxClass.canAccess(env, field)) {
                env.error(where, &quot;no.type.access&quot;, id, rightClass, ctxClass);
                return t;
                }
                if (field.isProtected()
                &amp;&amp; !ctxClass.protectedAccess(env, field, rty)) {
                env.error(where, &quot;invalid.protected.type.use&quot;, id, ctxClass, rty);
                return t;
                }
                
                 These were ommitted earlier in calls to &apos;toType&apos;, but I can&apos;t
                 see any reason for that.  I think it was an oversight.  See
                 &apos;checkCommon&apos; and &apos;checkInnerClass&apos;.
                innerClass.noteUsedBy(ctxClass, where, env);
                ctxClass.addDependency(field.getClassDeclaration());
                
                return t;
                
                } catch (ClassNotFound e) {
                env.error(where, &quot;class.not.found&quot;, e.name, ctx.field);
                }
                
                 Class not found.
                return null;
                }                
            </comment>
            <javadoc line="33">
                WARNING: The contents of this source file are not part of any
                  supported API.  Code that depends on them does so at its own risk:
                  they are subject to change or removal without notice.                
            </javadoc>
            <declaration name="id" type="Identifier" line="40"/>
            <declaration name="field" type="MemberDefinition" line="41"/>
            <declaration name="implementation" type="Expression" line="42"/>
            <declaration name="clazz" type="ClassDefinition" line="45"/>
            <declaration name="superBase" type="ClassDefinition" line="49"/>
            <javadoc line="51">
                constructor                
            </javadoc>
            <method name="FieldExpression" type="constructor" line="54">
                <params>
                    <param name="where" type="long"/>
                    <param name="right" type="Expression"/>
                    <param name="id" type="Identifier"/>
                </params>
            </method>
            <method name="FieldExpression" type="constructor" line="58">
                <params>
                    <param name="where" type="long"/>
                    <param name="right" type="Expression"/>
                    <param name="field" type="MemberDefinition"/>
                </params>
            </method>
            <method name="getImplementation" type="Expression" line="64"/>
            <javadoc line="70">
                Return true if the field is being selected from
                  a qualified &apos;super&apos;.                
            </javadoc>
            <method name="isQualSuper" type="boolean" line="74"/>
            <javadoc line="78">
                Convert an &apos;.&apos; expression to a qualified identifier                
            </javadoc>
            <method name="toIdentifier" type="Identifier" line="81">
                <params>
                    <param name="e" type="Expression"/>
                </params>
                <declaration name="buf" type="StringBuffer" line="82"/>
                <scope line="83">
                    <declaration name="fe" type="FieldExpression" line="84"/>
                    <scope line="85"/>
                </scope>
                <scope line="92"/>
            </method>
            <javadoc line="174">
                Convert an &apos;.&apos; expression to a type                
            </javadoc>
            <method name="toType" type="Type" line="204">
                <params>
                    <param name="env" type="Environment"/>
                    <param name="ctx" type="Context"/>
                </params>
                <comment line="178">
                    This is a rewrite to treat qualified names in a                    
                </comment>
                <comment line="179">
                    context in which a type name is expected in the                    
                </comment>
                <comment line="180">
                    same way that they are handled for an ambiguous                    
                </comment>
                <comment line="181">
                    or expression-expected context in &apos;checkCommon&apos;                    
                </comment>
                <comment line="182">
                    below.  The new code is cleaner and allows better                    
                </comment>
                <comment line="183">
                    localization of errors.  Unfortunately, most                    
                </comment>
                <comment line="184">
                    qualified names appearing in types are actually                    
                </comment>
                <comment line="185">
                    handled by &apos;Environment.resolve&apos;.  There isn&apos;t                    
                </comment>
                <comment line="186">
                    much point, then, in breaking out &apos;toType&apos; as a                    
                </comment>
                <comment line="187">
                    special case until the other cases can be cleaned                    
                </comment>
                <comment line="188">
                    up as well.  For the time being, we will leave this                    
                </comment>
                <comment line="189">
                    code disabled, thus reducing the testing requirements.                    
                </comment>
                <comment line="190">
                    -------------------------------------------------------
                    Type toType(Environment env, Context ctx) {
                    Type t = toQualifiedType(env, ctx);
                    if (t == null) {
                    return Type.tError;
                    }
                    if (t == Type.tPackage) {
                    FieldExpression.reportFailedPackagePrefix(env, right, true);
                    return Type.tError;
                    }
                    return t;
                    }                    
                </comment>
                <declaration name="id" type="Identifier" line="205"/>
                <scope line="206"/>
                <declaration name="t" type="Type" line="210"/>
                <scope line="211"/>
            </method>
            <javadoc line="217">
                Check if the present name is part of a scoping prefix.                
            </javadoc>
            <method name="checkAmbigName" type="Vset" line="223">
                <params>
                    <param name="env" type="Environment"/>
                    <param name="ctx" type="Context"/>
                    <param name="vset" type="Vset"/>
                    <param name="exp" type="Hashtable"/>
                    <param name="loc" type="UnaryExpression"/>
                </params>
                <comment line="225">
                    this cannot be a type or package                    
                </comment>
                <scope line="224"/>
            </method>
            <javadoc line="230">
                Check the expression                
            </javadoc>
            <method name="checkValue" type="Vset" line="235">
                <params>
                    <param name="env" type="Environment"/>
                    <param name="ctx" type="Context"/>
                    <param name="vset" type="Vset"/>
                    <param name="exp" type="Hashtable"/>
                </params>
                <comment line="238">
                    &quot;super&quot; is not allowed in this context.                    
                </comment>
                <comment line="239">
                    It must always qualify another name.                    
                </comment>
                <scope line="237"/>
            </method>
            <javadoc line="245">
                If &apos;checkAmbiguousName&apos; returns &apos;Package.tPackage&apos;, then it was
                  unable to resolve any prefix of the qualified name.  This method
                  attempts to diagnose the problem.                
            </javadoc>
            <method name="reportFailedPackagePrefix" type="void" line="251">
                <params>
                    <param name="env" type="Environment"/>
                    <param name="right" type="Expression"/>
                </params>
            </method>
            <method name="reportFailedPackagePrefix" type="void" line="257">
                <params>
                    <param name="env" type="Environment"/>
                    <param name="right" type="Expression"/>
                    <param name="mustBeType" type="boolean"/>
                </params>
                <comment line="258">
                    Find the leftmost component, and put the blame on it.                    
                </comment>
                <comment line="264">
                    It may be that &apos;ie&apos; refers to an ambiguous class.  Check this                    
                </comment>
                <comment line="265">
                    with a call to env.resolve(). Part of solution for 4059855.                    
                </comment>
                <declaration name="idp" type="Expression" line="259"/>
                <declaration name="ie" type="IdentifierExpression" line="262"/>
                <scope line="266"/>
                <scope line="268"/>
                <scope line="271"/>
                <scope line="274">
                    <scope line="275"/>
                    <scope line="277"/>
                </scope>
                <scope line="280">
                    <scope line="281"/>
                    <scope line="283"/>
                </scope>
            </method>
            <javadoc line="289">
                Rewrite accesses to private fields of another class.                
            </javadoc>
            <method name="implementFieldAccess" type="Expression" line="294">
                <params>
                    <param name="env" type="Environment"/>
                    <param name="ctx" type="Context"/>
                    <param name="base" type="Expression"/>
                    <param name="isLHS" type="boolean"/>
                </params>
                <comment line="298">
                    If the field is final and its initializer is a constant expression,                    
                </comment>
                <comment line="299">
                    then just rewrite to the constant expression. This is not just an                    
                </comment>
                <comment line="300">
                    optimization, but is required for correctness.  If an expression is                    
                </comment>
                <comment line="301">
                    rewritten to use an access method, then its status as a constant                    
                </comment>
                <comment line="302">
                    expression is lost.  This was the cause of bug 4098737.  Note that                    
                </comment>
                <comment line="303">
                    a call to &apos;getValue(env)&apos; below would not be correct, as it attempts                    
                </comment>
                <comment line="304">
                    to simplify the initial value expression, which must not occur until                    
                </comment>
                <comment line="305">
                    after the checking phase, for example, after definite assignment checks.                    
                </comment>
                <comment line="308">
                    Must not be LHS here.  Test as a precaution,                    
                </comment>
                <comment line="309">
                    as we may not be careful to avoid this when                    
                </comment>
                <comment line="310">
                    compiling an erroneous program.                    
                </comment>
                <comment line="316">
                    System.out.println(&quot;Finding access method for &quot; + field);                    
                </comment>
                <comment line="318">
                    System.out.println(&quot;Using access method &quot; + af);                    
                </comment>
                <comment line="321">
                    System.out.println(&quot;Reading &quot; + field +                    
                </comment>
                <comment line="322">
                    &quot; via access method &quot; + af);                    
                </comment>
                <comment line="323">
                    If referencing the value of the field, then replace                    
                </comment>
                <comment line="324">
                    with a call to the access method.  If assigning to                    
                </comment>
                <comment line="325">
                    the field, a call to the update method will be                    
                </comment>
                <comment line="326">
                    generated later. It is important that                    
                </comment>
                <comment line="327">
                    &apos;implementation&apos; not be set to non-null if the                    
                </comment>
                <comment line="328">
                    expression is a valid assignment target.                    
                </comment>
                <comment line="329">
                    (See &apos;checkLHS&apos;.)                    
                </comment>
                <declaration name="abase" type="ClassDefinition" line="295"/>
                <scope line="296">
                    <scope line="306">
                        <declaration name="e" type="Expression" line="307"/>
                        <scope line="311"/>
                    </scope>
                    <declaration name="af" type="MemberDefinition" line="317"/>
                    <scope line="320">
                        <scope line="330">
                            <declaration name="args" type="Expression" line="331"/>
                            <declaration name="call" type="Expression" line="332"/>
                        </scope>
                        <scope line="335">
                            <declaration name="args" type="Expression" line="336"/>
                        </scope>
                    </scope>
                </scope>
            </method>
            <javadoc line="345">
                Determine if an access method is required, and, if so, return
                  the class in which it should appear, else return null.                
            </javadoc>
            <method name="accessBase" type="ClassDefinition" line="349">
                <params>
                    <param name="env" type="Environment"/>
                    <param name="ctx" type="Context"/>
                </params>
                <comment line="354">
                    If access from same class as field, then no access                    
                </comment>
                <comment line="355">
                    method is needed.                    
                </comment>
                <comment line="358">
                    An access method is needed in the class containing the field.                    
                </comment>
                <comment line="362">
                    If access is not via qualified super, then it is either                    
                </comment>
                <comment line="363">
                    OK without an access method, or it is an illegal access                    
                </comment>
                <comment line="364">
                    for which an error message should have been issued.                    
                </comment>
                <comment line="365">
                    Legal accesses include unqualified &apos;super.foo&apos;.                    
                </comment>
                <comment line="371">
                    Access to protected member in same package always allowed.                    
                </comment>
                <comment line="374">
                    Access via qualified super.                    
                </comment>
                <comment line="375">
                    An access method is needed in the qualifying class, an                    
                </comment>
                <comment line="376">
                    immediate subclass of the class containing the selected                    
                </comment>
                <comment line="377">
                    field.  NOTE: The fact that the returned class is &apos;superBase&apos;                    
                </comment>
                <comment line="378">
                    carries the additional bit of information (that a special                    
                </comment>
                <comment line="379">
                    superclass access method is being created) which is provided                    
                </comment>
                <comment line="380">
                    to &apos;getAccessMember&apos; via its &apos;isSuper&apos; argument.                    
                </comment>
                <comment line="383">
                    No access method needed.                    
                </comment>
                <scope line="350">
                    <declaration name="cdef" type="ClassDefinition" line="351"/>
                    <declaration name="ctxClass" type="ClassDefinition" line="352"/>
                    <scope line="353"/>
                </scope>
                <scope line="360">
                    <scope line="361"/>
                    <declaration name="cdef" type="ClassDefinition" line="368"/>
                    <declaration name="ctxClass" type="ClassDefinition" line="369"/>
                    <scope line="370"/>
                </scope>
                <scope line="382"/>
            </method>
            <javadoc line="388">
                Determine if a type is accessible from a given class.                
            </javadoc>
            <method name="isTypeAccessible" type="boolean" line="394">
                <params>
                    <param name="where" type="long"/>
                    <param name="env" type="Environment"/>
                    <param name="t" type="Type"/>
                    <param name="c" type="ClassDefinition"/>
                </params>
                <comment line="399">
                    Why not just use &apos;Environment.getClassDeclaration&apos; here?                    
                </comment>
                <comment line="400">
                    But &apos;Environment.getClassDeclation&apos; has special treatment                    
                </comment>
                <comment line="401">
                    for local classes that is probably necessary.  This code                    
                </comment>
                <comment line="402">
                    was adapted from &apos;Environment.resolve&apos;.                    
                </comment>
                <comment line="405">
                    Ignore -- reported elsewhere.                    
                </comment>
                <scope line="397">
                    <declaration name="nm" type="Identifier" line="398"/>
                    <declaration name="def" type="ClassDefinition" line="403"/>
                </scope>
                <scope line="405"/>
            </method>
            <javadoc line="414">
                Common code for checkValue and checkAmbigName                
            </javadoc>
            <method name="checkCommon" type="Vset" line="420">
                <params>
                    <param name="env" type="Environment"/>
                    <param name="ctx" type="Context"/>
                    <param name="vset" type="Vset"/>
                    <param name="exp" type="Hashtable"/>
                    <param name="loc" type="UnaryExpression"/>
                    <param name="isLHS" type="boolean"/>
                </params>
                <comment line="422">
                    Handle class literal, e.g., &apos;x.class&apos;.                    
                </comment>
                <comment line="425">
                    In &apos;x.class&apos;, &apos;x&apos; must be a type name, possibly qualified.                    
                </comment>
                <comment line="452">
                    java.lang.Class                    
                </comment>
                <comment line="456">
                    Check for the bogus type `array of void&apos;                    
                </comment>
                <comment line="463">
                    it is a class or array                    
                </comment>
                <comment line="471">
                    sig is like &quot;Lfoo/bar;&quot;, name is like &quot;foo.bar&quot;.                    
                </comment>
                <comment line="472">
                    We assume SIG_CLASS and SIG_ENDCLASS are 1 char each.                    
                </comment>
                <comment line="476">
                    sig is like &quot;[Lfoo/bar;&quot; or &quot;[I&quot;;                    
                </comment>
                <comment line="477">
                    name is like &quot;[Lfoo.bar&quot; or (again) &quot;[I&quot;.                    
                </comment>
                <comment line="482">
                    The immediately-enclosing type is an interface.                    
                </comment>
                <comment line="483">
                    The class literal can only appear in an initialization                    
                </comment>
                <comment line="484">
                    expression, so don&apos;t bother caching it.  (This could                    
                </comment>
                <comment line="485">
                    lose if many initializations use the same class literal,                    
                </comment>
                <comment line="486">
                    but saves time and code space otherwise.)                    
                </comment>
                <comment line="490">
                    Cache the call to the helper, as it may be executed                    
                </comment>
                <comment line="491">
                    many times (e.g., if the class literal is inside a loop).                    
                </comment>
                <comment line="500">
                    java.lang.Class                    
                </comment>
                <comment line="504">
                    Arrive here if not a class literal.                    
                </comment>
                <comment line="508">
                    The field as been pre-set, e.g., as the result of transforming                    
                </comment>
                <comment line="509">
                    an &apos;IdentifierExpression&apos;. Most error-checking has already been                    
                </comment>
                <comment line="510">
                    performed at this point.                    
                </comment>
                <comment line="511">
                    QUERY: Why don&apos;t we further unify checking of identifier                    
                </comment>
                <comment line="512">
                    expressions and field expressions that denote instance and                    
                </comment>
                <comment line="513">
                    class variables?                    
                </comment>
                <comment line="520">
                    Does the qualifier have a meaning of its own?                    
                </comment>
                <comment line="523">
                    Are we out of options?                    
                </comment>
                <comment line="529">
                    ASSERT(loc.right == this)                    
                </comment>
                <comment line="531">
                    Nope.  Is this field expression a type?                    
                </comment>
                <comment line="535">
                    Check access. (Cf. IdentifierExpression.toResolvedType.)                    
                </comment>
                <comment line="541">
                    Let the caller make sense of it, then.                    
                </comment>
                <comment line="546">
                    Good; we have a well-defined qualifier type.                    
                </comment>
                <comment line="553">
                    Handle array &apos;length&apos; field, e.g., &apos;x.length&apos;.                    
                </comment>
                <comment line="557">
                    Verify that the type of the base expression is accessible.                    
                </comment>
                <comment line="558">
                    Required by JLS 6.6.1.  Fixes 4094658.                    
                </comment>
                <comment line="579">
                    At this point, we know that &apos;right.type&apos; is a class type.                    
                </comment>
                <comment line="581">
                    Note that &apos;&lt;expr&gt;.super(...)&apos; and &apos;&lt;expr&gt;.this(...)&apos; cases never                    
                </comment>
                <comment line="582">
                    reach here.  Instead, &apos;&lt;expr&gt;&apos; is stored as the &apos;outerArg&apos; field                    
                </comment>
                <comment line="583">
                    of a &apos;SuperExpression&apos; or &apos;ThisExpression&apos; node.                    
                </comment>
                <comment line="585">
                    If our prefix is of the form &apos;&lt;class&gt;.super&apos;, then we are                    
                </comment>
                <comment line="586">
                    about to do a field selection &apos;&lt;class&gt;.super.&lt;field&gt;&apos;.                    
                </comment>
                <comment line="587">
                    Save the qualifying class in &apos;superBase&apos;, which is non-null                    
                </comment>
                <comment line="588">
                    only if the current FieldExpression is a qualified &apos;super&apos; form.                    
                </comment>
                <comment line="589">
                    Also, set &apos;sourceClass&apos; to the &quot;effective accessing class&quot; relative                    
                </comment>
                <comment line="590">
                    to which access checks will be performed.  Normally, this is the                    
                </comment>
                <comment line="591">
                    immediately enclosing class.  For &apos;&lt;class&gt;.this&apos; and &apos;&lt;class&gt;.super&apos;,                    
                </comment>
                <comment line="592">
                    however, we use &lt;class&gt;.                    
                </comment>
                <comment line="605">
                    Handle &apos;class.this&apos; and &apos;class.super&apos;.                    
                </comment>
                <comment line="606">
                                        
                </comment>
                <comment line="607">
                    Suppose &apos;super.name&apos; appears within a class C with immediate                    
                </comment>
                <comment line="608">
                    superclass S. According to JLS 15.10.2, &apos;super.name&apos; in this                    
                </comment>
                <comment line="609">
                    case is equivalent to &apos;((S)this).name&apos;.  Analogously, we interpret                    
                </comment>
                <comment line="610">
                    &apos;class.super.name&apos; as &apos;((S)(class.this)).name&apos;, where S is the                    
                </comment>
                <comment line="611">
                    immediate superclass of (enclosing) class &apos;class&apos;.                    
                </comment>
                <comment line="612">
                    Note that &apos;super&apos; may not stand alone as an expression, but must                    
                </comment>
                <comment line="613">
                    occur as the qualifying expression of a field access or a method                    
                </comment>
                <comment line="614">
                    invocation.  This is enforced in &apos;SuperExpression.checkValue&apos; and                    
                </comment>
                <comment line="615">
                    &apos;FieldExpression.checkValue&apos;, and need not concern us here.                    
                </comment>
                <comment line="617">
                    ClassDefinition clazz = env.getClassDefinition(right.type);                    
                </comment>
                <comment line="624">
                    We used to check that &apos;right.type&apos; is accessible here,                    
                </comment>
                <comment line="625">
                    per JLS 6.6.1.  As a result of the fix for 4102393, however,                    
                </comment>
                <comment line="626">
                    the qualifying class name must exactly match an enclosing                    
                </comment>
                <comment line="627">
                    outer class, which is necessarily accessible.                    
                </comment>
                <comment line="629">
                                        
                </comment>
                <comment line="632">
                                        
                </comment>
                <comment line="634">
                    A.this means we&apos;re inside an A and we want its self ptr.                    
                </comment>
                <comment line="635">
                    C.this is always the same as this when C is innermost.                    
                </comment>
                <comment line="636">
                    Another A.this means we skip out to get a &quot;hidden&quot; this,                    
                </comment>
                <comment line="637">
                    just as ASuper.foo skips out to get a hidden variable.                    
                </comment>
                <comment line="638">
                    Last argument &apos;true&apos; means we want an exact class match,                    
                </comment>
                <comment line="639">
                    not a subclass of the specified class (&apos;clazz&apos;).                    
                </comment>
                <comment line="650">
                    Field should be an instance variable or class variable.                    
                </comment>
                <comment line="654">
                    Is this field expression an inner type?                    
                </comment>
                <comment line="655">
                    Search the class and its supers (but not its outers).                    
                </comment>
                <comment line="656">
                    QUERY: We may need to get the inner class from a                    
                </comment>
                <comment line="657">
                    superclass of &apos;clazz&apos;.  This call is prepared to                    
                </comment>
                <comment line="658">
                    resolve the superclass if necessary.  Can we arrange                    
                </comment>
                <comment line="659">
                    to assure that it is always previously resolved?                    
                </comment>
                <comment line="660">
                    This is one of a small number of problematic calls that                    
                </comment>
                <comment line="661">
                    requires &apos;getSuperClass&apos; to resolve superclasses on demand.                    
                </comment>
                <comment line="662">
                    See &apos;ClassDefinition.getInnerClass(env, nm)&apos;.                    
                </comment>
                <comment line="669">
                    If not a variable reference, diagnose error if name is                    
                </comment>
                <comment line="670">
                    that of a method.                    
                </comment>
                <comment line="682">
                    At this point, we have identified a valid field.                    
                </comment>
                <comment line="684">
                    Required by JLS 6.6.1.  Fixes 4094658.                    
                </comment>
                <comment line="705">
                    &apos;Class.field&apos; is not legal when field is not static;                    
                </comment>
                <comment line="706">
                    see JLS 15.13.1.  This case was permitted by javac                    
                </comment>
                <comment line="707">
                    prior to 1.2; static refs were silently changed to                    
                </comment>
                <comment line="708">
                    be dynamic access of the form &apos;this.field&apos;.                    
                </comment>
                <comment line="712">
                    Rewrite access to use an access method if necessary.                    
                </comment>
                <comment line="716">
                    Check for invalid access to protected field.                    
                </comment>
                <comment line="719">
                    Extension of JLS 6.6.2 for qualified &apos;super&apos;.                    
                </comment>
                <comment line="739">
                    When a package-private class defines public or protected                    
                </comment>
                <comment line="740">
                    members, those members may sometimes be accessed from                    
                </comment>
                <comment line="741">
                    outside of the package in public subclasses.  In these                    
                </comment>
                <comment line="742">
                    cases, we need to massage the getField to refer to                    
                </comment>
                <comment line="743">
                    to an accessible subclass rather than the package-private                    
                </comment>
                <comment line="744">
                    parent class.  Part of fix for 4135692.                    
                </comment>
                <comment line="746">
                    Find out if the class which contains this field                    
                </comment>
                <comment line="747">
                    reference has access to the class which declares the                    
                </comment>
                <comment line="748">
                    public or protected field.                    
                </comment>
                <comment line="755">
                    System.out.println(&quot;The access of member &quot; +                    
                </comment>
                <comment line="756">
                    field + &quot; declared in class &quot; +                    
                </comment>
                <comment line="757">
                    declarer +                    
                </comment>
                <comment line="758">
                    &quot; is not allowed by the VM from class  &quot; +                    
                </comment>
                <comment line="759">
                    ctxClass +                    
                </comment>
                <comment line="760">
                    &quot;.  Replacing with an access of class &quot; +                    
                </comment>
                <comment line="761">
                    clazz);                    
                </comment>
                <comment line="763">
                    We cannot make this access at the VM level.                    
                </comment>
                <comment line="764">
                    Construct a member which will stand for this                    
                </comment>
                <comment line="765">
                    field in ctxClass and set `field&apos; to refer to it.                    
                </comment>
                <scope line="423">
                    <declaration name="t" type="Type" line="426"/>
                    <scope line="428">
                        <scope line="429"/>
                        <declaration name="wrc" type="String" line="433"/>
                        <declaration name="wid" type="Identifier" line="448"/>
                        <declaration name="wcls" type="Expression" line="449"/>
                    </scope>
                    <scope line="457"/>
                    <declaration name="fwhere" type="long" line="464"/>
                    <declaration name="fcls" type="ClassDefinition" line="465"/>
                    <declaration name="lookup" type="MemberDefinition" line="466"/>
                    <declaration name="sig" type="String" line="468"/>
                    <declaration name="className" type="String" line="469"/>
                    <scope line="470"/>
                    <scope line="475"/>
                    <scope line="481"/>
                    <scope line="489">
                        <declaration name="inClass" type="ClassDefinition" line="492"/>
                        <declaration name="cfld" type="MemberDefinition" line="493"/>
                    </scope>
                </scope>
                <scope line="506"/>
                <scope line="522">
                    <scope line="524"/>
                    <declaration name="nm" type="Identifier" line="532"/>
                    <scope line="533">
                        <declaration name="ctxClass" type="ClassDefinition" line="536"/>
                    </scope>
                </scope>
                <declaration name="ctxClass" type="ClassDefinition" line="548"/>
                <declaration name="staticRef" type="boolean" line="549"/>
                <scope line="551">
                    <scope line="555">
                        <scope line="556">
                            <scope line="559">
                                <declaration name="cdecl" type="ClassDeclaration" line="560"/>
                                <scope line="561"/>
                                <scope line="564"/>
                            </scope>
                        </scope>
                        <scope line="573"/>
                    </scope>
                    <declaration name="sourceClass" type="ClassDefinition" line="594"/>
                    <scope line="595">
                        <declaration name="id" type="Identifier" line="596"/>
                        <scope line="597"/>
                        <scope line="599"/>
                    </scope>
                    <scope line="619">
                        <scope line="620"/>
                        <scope line="642"/>
                        <scope line="644"/>
                    </scope>
                    <scope line="653">
                        <scope line="664"/>
                    </scope>
                    <scope line="672">
                        <scope line="673"/>
                        <scope line="676"/>
                    </scope>
                    <scope line="685">
                        <declaration name="cdecl" type="ClassDeclaration" line="686"/>
                        <scope line="687"/>
                        <scope line="690"/>
                    </scope>
                    <scope line="698"/>
                    <scope line="704"/>
                    <scope line="711"/>
                    <scope line="722"/>
                    <scope line="730"/>
                    <scope line="734"/>
                    <scope line="749">
                        <declaration name="declarer" type="ClassDefinition" line="750"/>
                        <scope line="753"/>
                    </scope>
                </scope>
                <scope line="773"/>
                <scope line="776"/>
            </method>
            <javadoc line="783">
                Return a &lt;code&gt;FieldUpdater&lt;/code&gt; object to be used in updating the
                  value of the location denoted by &lt;code&gt;this&lt;/code&gt;, which must be an
                  expression suitable for the left-hand side of an assignment.
                  This is used for implementing assignments to private fields for which
                  an access method is required.  Returns null if no access method is
                  needed, in which case the assignment is handled in the usual way, by
                  direct access.  Only simple assignment expressions are handled here
                  Assignment operators and pre/post increment/decrement operators are
                  are handled by &apos;getUpdater&apos; below.
                  &lt;p&gt;
                  Must be called after &apos;checkValue&apos;, else &apos;right&apos; will be invalid.                
            </javadoc>
            <method name="getAssigner" type="FieldUpdater" line="798">
                <params>
                    <param name="env" type="Environment"/>
                    <param name="ctx" type="Context"/>
                </params>
                <comment line="800">
                    Field can legitimately be null if the field name was                    
                </comment>
                <comment line="801">
                    undefined, in which case an error was reported, but                    
                </comment>
                <comment line="802">
                    no value for &apos;field&apos; is available.                    
                </comment>
                <comment line="803">
                    throw new CompilerError(&quot;getAssigner&quot;);                    
                </comment>
                <comment line="809">
                    It may not be necessary to copy &apos;right&apos; here.                    
                </comment>
                <comment line="811">
                    Created &apos;FieldUpdater&apos; has no getter method.                    
                </comment>
                <scope line="799"/>
                <declaration name="abase" type="ClassDefinition" line="806"/>
                <scope line="807">
                    <declaration name="setter" type="MemberDefinition" line="808"/>
                    <declaration name="base" type="Expression" line="810"/>
                </scope>
            </method>
            <javadoc line="817">
                Return a &lt;code&gt;FieldUpdater&lt;/code&gt; object to be used in updating the
                  value of the location denoted by &lt;code&gt;this&lt;/code&gt;, which must be an
                  expression suitable for the left-hand side of an assignment.  This is
                  used for implementing the assignment operators and the increment and
                  decrement operators on private fields that are accessed from another
                  class, e.g, uplevel from an inner class. Returns null if no access
                  method is needed.
                  &lt;p&gt;
                  Must be called after &apos;checkValue&apos;, else &apos;right&apos; will be invalid.                
            </javadoc>
            <method name="getUpdater" type="FieldUpdater" line="829">
                <params>
                    <param name="env" type="Environment"/>
                    <param name="ctx" type="Context"/>
                </params>
                <comment line="831">
                    Field can legitimately be null if the field name was                    
                </comment>
                <comment line="832">
                    undefined, in which case an error was reported, but                    
                </comment>
                <comment line="833">
                    no value for &apos;field&apos; is available.                    
                </comment>
                <comment line="834">
                    throw new CompilerError(&quot;getUpdater&quot;);                    
                </comment>
                <comment line="841">
                    It may not be necessary to copy &apos;right&apos; here.                    
                </comment>
                <scope line="830"/>
                <declaration name="abase" type="ClassDefinition" line="837"/>
                <scope line="838">
                    <declaration name="getter" type="MemberDefinition" line="839"/>
                    <declaration name="setter" type="MemberDefinition" line="840"/>
                    <declaration name="base" type="Expression" line="842"/>
                </scope>
            </method>
            <javadoc line="848">
                This field expression is an inner class reference.
                  Finish checking it.                
            </javadoc>
            <method name="checkInnerClass" type="Vset" line="854">
                <params>
                    <param name="env" type="Environment"/>
                    <param name="ctx" type="Context"/>
                    <param name="vset" type="Vset"/>
                    <param name="exp" type="Hashtable"/>
                    <param name="loc" type="UnaryExpression"/>
                </params>
                <comment line="864">
                    check access                    
                </comment>
                <comment line="869">
                    env.error(where, &quot;no.type.access&quot;,                    
                </comment>
                <comment line="870">
                    id, clazz, ctx.field.getClassDeclaration());                    
                </comment>
                <comment line="878">
                    Extension of JLS 6.6.2 for qualified &apos;super&apos;.                    
                </comment>
                <comment line="896">
                    Complain about a free-floating type name.                    
                </comment>
                <declaration name="inner" type="ClassDefinition" line="855"/>
                <scope line="858"/>
                <declaration name="te" type="Expression" line="862"/>
                <declaration name="ctxClass" type="ClassDefinition" line="865"/>
                <scope line="866">
                    <scope line="867">
                        <declaration name="clazz" type="ClassDefinition" line="868"/>
                    </scope>
                    <scope line="881"/>
                </scope>
                <scope line="890"/>
            </method>
            <javadoc line="902">
                Check the expression if it appears on the LHS of an assignment                
            </javadoc>
            <method name="checkLHS" type="Vset" line="906">
                <params>
                    <param name="env" type="Environment"/>
                    <param name="ctx" type="Context"/>
                    <param name="vset" type="Vset"/>
                    <param name="exp" type="Hashtable"/>
                </params>
                <comment line="909">
                    checkValue(env, ctx, vset, exp);                    
                </comment>
                <comment line="912">
                    If &apos;implementation&apos; is set to a non-null value, then the                    
                </comment>
                <comment line="913">
                    field expression does not denote an assignable location,                    
                </comment>
                <comment line="914">
                    e.g., the &apos;length&apos; field of an array.                    
                </comment>
                <comment line="916">
                    This just reports an error and recovers.                    
                </comment>
                <comment line="926">
                    Continue with checking anyhow.                    
                </comment>
                <comment line="927">
                    In fact, it would be easy to allow this case.                    
                </comment>
                <comment line="931">
                    The actual instance could be anywhere, so don&apos;t                    
                </comment>
                <comment line="932">
                    continue with checking the definite assignment status.                    
                </comment>
                <declaration name="hadField" type="boolean" line="907"/>
                <scope line="915"/>
                <scope line="920">
                    <scope line="921">
                        <scope line="922">
                            <scope line="923"/>
                        </scope>
                        <scope line="928">
                            <scope line="929"/>
                        </scope>
                    </scope>
                    <scope line="937"/>
                </scope>
            </method>
            <javadoc line="944">
                Check the expression if it appears on the LHS of an op= expression                
            </javadoc>
            <method name="checkAssignOp" type="Vset" line="948">
                <params>
                    <param name="env" type="Environment"/>
                    <param name="ctx" type="Context"/>
                    <param name="vset" type="Vset"/>
                    <param name="exp" type="Hashtable"/>
                    <param name="outside" type="Expression"/>
                </params>
                <comment line="950">
                    checkValue(env, ctx, vset, exp);                    
                </comment>
                <comment line="953">
                    If &apos;implementation&apos; is set to a non-null value, then the                    
                </comment>
                <comment line="954">
                    field expression does not denote an assignable location,                    
                </comment>
                <comment line="955">
                    e.g., the &apos;length&apos; field of an array.                    
                </comment>
                <scope line="956"/>
                <scope line="959"/>
            </method>
            <javadoc line="965">
                There is a simple assignment being made to the given final field.
                  The field was named either by a simple name or by an almost-simple
                  expression of the form &quot;this.v&quot;.
                  Check if this is a legal assignment.
                  &lt;p&gt;
                  Blank final variables can be set in initializers or constructor
                  bodies.  In all cases there must be definite single assignment.
                  (All instance and instance variable initializers and each
                  constructor body are treated as if concatenated for the purposes
                  of this check.  Assignment to &quot;this.x&quot; is treated as a definite
                  assignment to the simple name &quot;x&quot; which names the instance variable.)                
            </javadoc>
            <method name="checkFinalAssign" type="Vset" line="981">
                <params>
                    <param name="env" type="Environment"/>
                    <param name="ctx" type="Context"/>
                    <param name="vset" type="Vset"/>
                    <param name="where" type="long"/>
                    <param name="field" type="MemberDefinition"/>
                </params>
                <comment line="986">
                    definite single assignment                    
                </comment>
                <comment line="989">
                    it is a blank final in this class, but not assignable                    
                </comment>
                <comment line="994">
                    give the generic error message                    
                </comment>
                <scope line="983">
                    <declaration name="number" type="int" line="984"/>
                    <scope line="985"/>
                    <scope line="988">
                        <declaration name="id" type="Identifier" line="990"/>
                    </scope>
                </scope>
                <scope line="993">
                    <declaration name="id" type="Identifier" line="995"/>
                </scope>
            </method>
            <method name="getClassLiteralCache" type="MemberDefinition" line="1004">
                <params>
                    <param name="env" type="Environment"/>
                    <param name="ctx" type="Context"/>
                    <param name="className" type="String"/>
                    <param name="c" type="ClassDefinition"/>
                </params>
                <comment line="1005">
                    Given a class name, look for a static field to cache it.                    
                </comment>
                <comment line="1006">
                    className       lname                    
                </comment>
                <comment line="1007">
                    pkg.Foo         class$pkg$Foo                    
                </comment>
                <comment line="1008">
                    [Lpkg.Foo;      array$Lpkg$Foo                    
                </comment>
                <comment line="1009">
                    [[Lpkg.Foo;     array$$Lpkg$Foo                    
                </comment>
                <comment line="1010">
                    [I              array$I                    
                </comment>
                <comment line="1011">
                    [[I             array$$I                    
                </comment>
                <comment line="1017">
                    [[[I =&gt; array$$$I                    
                </comment>
                <comment line="1019">
                    [Lpkg.Foo; =&gt; array$Lpkg$Foo                    
                </comment>
                <comment line="1023">
                    else [I =&gt; array$I or some such; lname is already OK                    
                </comment>
                <comment line="1027">
                    The class to put the cache in is now given as an argument.                    
                </comment>
                <comment line="1028">
                                        
                </comment>
                <comment line="1029">
                    ClassDefinition c = ctx.field.getClassDefinition();                    
                </comment>
                <comment line="1030">
                    while (c.isInnerClass()) {                    
                </comment>
                <comment line="1031">
                    c = c.getOuterClass();                    
                </comment>
                <comment line="1042">
                    Ignore inherited field.  Each top-level class                    
                </comment>
                <comment line="1043">
                    containing a given class literal must have its own copy,                    
                </comment>
                <comment line="1044">
                    both for reasons of binary compatibility and to prevent                    
                </comment>
                <comment line="1045">
                    access violations should the superclass be in another                    
                </comment>
                <comment line="1046">
                    package.  Part of fix 4106051.                    
                </comment>
                <comment line="1051">
                    Since each class now has its own copy, we might as well                    
                </comment>
                <comment line="1052">
                    tighten up the access to private (previously default).                    
                </comment>
                <comment line="1053">
                    Part of fix for 4106051.                    
                </comment>
                <comment line="1054">
                    ** Temporarily retract this, as it tickles 4098316.                    
                </comment>
                <comment line="1057">
                    M_PRIVATE,                    
                </comment>
                <declaration name="lname" type="String" line="1012"/>
                <scope line="1013"/>
                <scope line="1015">
                    <scope line="1018"/>
                </scope>
                <declaration name="fname" type="Identifier" line="1025"/>
                <declaration name="cfld" type="MemberDefinition" line="1033"/>
                <scope line="1034"/>
                <scope line="1036"/>
                <scope line="1038"/>
                <scope line="1047"/>
            </method>
            <method name="makeClassLiteralCacheRef" type="Expression" line="1065">
                <params>
                    <param name="env" type="Environment"/>
                    <param name="ctx" type="Context"/>
                    <param name="lookup" type="MemberDefinition"/>
                    <param name="cfld" type="MemberDefinition"/>
                    <param name="className" type="String"/>
                </params>
                <declaration name="ccls" type="Expression" line="1066"/>
                <declaration name="cache" type="Expression" line="1069"/>
                <declaration name="cacheOK" type="Expression" line="1070"/>
                <declaration name="lcls" type="Expression" line="1073"/>
                <declaration name="name" type="Expression" line="1075"/>
                <declaration name="namearg" type="Expression" line="1076"/>
                <declaration name="setCache" type="Expression" line="1077"/>
            </method>
            <method name="makeClassLiteralInlineRef" type="Expression" line="1086">
                <params>
                    <param name="env" type="Environment"/>
                    <param name="ctx" type="Context"/>
                    <param name="lookup" type="MemberDefinition"/>
                    <param name="className" type="String"/>
                </params>
                <declaration name="lcls" type="Expression" line="1087"/>
                <declaration name="name" type="Expression" line="1089"/>
                <declaration name="namearg" type="Expression" line="1090"/>
                <declaration name="getClass" type="Expression" line="1091"/>
            </method>
            <javadoc line="1097">
                Check if constant:  Will it inline away?                
            </javadoc>
            <method name="isConstant" type="boolean" line="1100">
                <scope line="1105"/>
            </method>
            <javadoc line="1111">
                Inline                
            </javadoc>
            <method name="inline" type="Expression" line="1114">
                <params>
                    <param name="env" type="Environment"/>
                    <param name="ctx" type="Context"/>
                </params>
                <comment line="1117">
                    A field expression may have the side effect of causing                    
                </comment>
                <comment line="1118">
                    a NullPointerException, so evaluate it even though                    
                </comment>
                <comment line="1119">
                    the value is not needed.  Similarly, static field dereferences                    
                </comment>
                <comment line="1120">
                    may cause class initialization, so they mustn&apos;t be omitted                    
                </comment>
                <comment line="1121">
                    either.                    
                </comment>
                <comment line="1122">
                                        
                </comment>
                <comment line="1123">
                    However, NullPointerException can&apos;t happen and initialization must                    
                </comment>
                <comment line="1124">
                    already have occured if you are dotting into &apos;this&apos;.  So                    
                </comment>
                <comment line="1125">
                    allow fields of &apos;this&apos; to be eliminated as a special case.                    
                </comment>
                <comment line="1131">
                    It should be possible to split this into two checks: one using                    
                </comment>
                <comment line="1132">
                    isNonNull() for non-statics and a different check for statics.                    
                </comment>
                <comment line="1133">
                    That would make the inlining slightly less conservative by                    
                </comment>
                <comment line="1134">
                    allowing, for example, dotting into String constants.                    
                </comment>
                <declaration name="e" type="Expression" line="1126"/>
                <scope line="1127">
                    <declaration name="fe" type="FieldExpression" line="1128"/>
                </scope>
            </method>
            <method name="inlineValue" type="Expression" line="1138">
                <params>
                    <param name="env" type="Environment"/>
                    <param name="ctx" type="Context"/>
                </params>
                <comment line="1149">
                    remove bogus line-number info                    
                </comment>
                <scope line="1141">
                    <scope line="1142"/>
                    <scope line="1146">
                        <declaration name="e" type="Expression" line="1147"/>
                        <scope line="1148"/>
                    </scope>
                    <scope line="1156">
                        <scope line="1157">
                            <declaration name="e" type="Expression" line="1158"/>
                            <scope line="1160"/>
                        </scope>
                        <scope line="1163"/>
                    </scope>
                </scope>
                <scope line="1169"/>
            </method>
            <method name="inlineLHS" type="Expression" line="1173">
                <params>
                    <param name="env" type="Environment"/>
                    <param name="ctx" type="Context"/>
                </params>
                <scope line="1176">
                    <scope line="1177">
                        <declaration name="e" type="Expression" line="1178"/>
                        <scope line="1180"/>
                    </scope>
                    <scope line="1183"/>
                </scope>
            </method>
            <method name="copyInline" type="Expression" line="1190">
                <params>
                    <param name="ctx" type="Context"/>
                </params>
            </method>
            <javadoc line="1196">
                The cost of inlining this expression                
            </javadoc>
            <method name="costInline" type="int" line="1199">
                <params>
                    <param name="thresh" type="int"/>
                    <param name="env" type="Environment"/>
                    <param name="ctx" type="Context"/>
                </params>
                <comment line="1206">
                    ctxClass is the current class trying to inline this method                    
                </comment>
                <comment line="1209">
                    We only allow the inlining if the current class can access                    
                </comment>
                <comment line="1210">
                    the field, the field&apos;s class, and right&apos;s declared type.                    
                </comment>
                <scope line="1202"/>
                <declaration name="ctxClass" type="ClassDefinition" line="1207"/>
                <scope line="1208">
                    <scope line="1212">
                        <scope line="1213"/>
                        <scope line="1215">
                            <declaration name="rt" type="ClassDeclaration" line="1216"/>
                            <scope line="1217"/>
                        </scope>
                    </scope>
                </scope>
                <scope line="1222"/>
            </method>
            <javadoc line="1227">
                Code                
            </javadoc>
            <method name="codeLValue" type="int" line="1230">
                <params>
                    <param name="env" type="Environment"/>
                    <param name="ctx" type="Context"/>
                    <param name="asm" type="Assembler"/>
                </params>
                <scope line="1233">
                    <scope line="1234"/>
                </scope>
            </method>
            <method name="codeLoad" type="void" line="1243">
                <params>
                    <param name="env" type="Environment"/>
                    <param name="ctx" type="Context"/>
                    <param name="asm" type="Assembler"/>
                </params>
                <scope line="1244"/>
                <scope line="1247"/>
                <scope line="1249"/>
            </method>
            <method name="codeStore" type="void" line="1253">
                <params>
                    <param name="env" type="Environment"/>
                    <param name="ctx" type="Context"/>
                    <param name="asm" type="Assembler"/>
                </params>
                <scope line="1254"/>
                <scope line="1256"/>
            </method>
            <method name="codeValue" type="void" line="1261">
                <params>
                    <param name="env" type="Environment"/>
                    <param name="ctx" type="Context"/>
                    <param name="asm" type="Assembler"/>
                </params>
            </method>
            <javadoc line="1266">
                Print                
            </javadoc>
            <method name="print" type="void" line="1269">
                <params>
                    <param name="out" type="PrintStream"/>
                </params>
                <scope line="1271"/>
                <scope line="1273"/>
                <scope line="1277"/>
            </method>
        </class>
    </source>