<?xml version="1.0" encoding="UTF-8"?>
    <source package="sun.tools.tree">
        <import package="sun.tools.java"/>
        <import package="sun.tools.asm.Assembler"/>
        <import package="java.io.PrintStream"/>
        <import package="java.util.Hashtable"/>
        <class name="AssignOpExpression" line="33">
            <extends class="BinaryAssignExpression"/>
            <comment line="41">
                Type of intermediate result, before assigning                
            </comment>
            <comment line="44">
                Used also in &apos;AssignAddExpression&apos;.                
            </comment>
            <javadoc line="33">
                WARNING: The contents of this source file are not part of any
                  supported API.  Code that depends on them does so at its own risk:
                  they are subject to change or removal without notice.                
            </javadoc>
            <declaration name="itype" type="Type" line="40"/>
            <declaration name="NOINC" type="int" line="41"/>
            <declaration name="updater" type="FieldUpdater" line="43"/>
            <javadoc line="45">
                Constructor                
            </javadoc>
            <method name="AssignOpExpression" type="constructor" line="48">
                <params>
                    <param name="op" type="int"/>
                    <param name="where" type="long"/>
                    <param name="left" type="Expression"/>
                    <param name="right" type="Expression"/>
                </params>
            </method>
            <javadoc line="52">
                Select the type                
            </javadoc>
            <method name="selectType" type="void" line="57">
                <params>
                    <param name="env" type="Environment"/>
                    <param name="ctx" type="Context"/>
                    <param name="tm" type="int"/>
                </params>
                <comment line="58">
                    special conversion type for RHS                    
                </comment>
                <comment line="63">
                    The type of the right hand side can be                    
                </comment>
                <comment line="64">
                    anything except void.  Fix for 4119864.                    
                </comment>
                <comment line="73">
                                        
                </comment>
                <comment line="99">
                    Fix for bug 4134459.                    
                </comment>
                <comment line="100">
                    We allow any integral type (even long) to                    
                </comment>
                <comment line="101">
                    be the right hand side of a shift operation.                    
                </comment>
                <comment line="105">
                    The intermediate type of the expression is the                    
                </comment>
                <comment line="106">
                    type of the left hand side after undergoing                    
                </comment>
                <comment line="107">
                    unary (not binary) type promotion.  We ignore                    
                </comment>
                <comment line="108">
                    tm -- it contains information about both left                    
                </comment>
                <comment line="109">
                    and right hand sides -- and we compute the                    
                </comment>
                <comment line="110">
                    type only from the type of the lhs.                    
                </comment>
                <comment line="126">
                    The result is always the type of the left operand.                    
                </comment>
                <declaration name="rtype" type="Type" line="58"/>
                <scope line="61">
                    <scope line="62"/>
                    <scope line="68"/>
                </scope>
                <scope line="75"/>
                <scope line="77"/>
                <scope line="79"/>
                <scope line="81"/>
                <scope line="87"/>
                <scope line="89"/>
                <scope line="91"/>
                <scope line="102"/>
                <scope line="111"/>
                <scope line="113"/>
                <scope line="122"/>
            </method>
            <javadoc line="132">
                Get the increment, return NOINC if an increment is not possible                
            </javadoc>
            <method name="getIncrement" type="int" line="135">
                <scope line="138">
                    <declaration name="val" type="int" line="139"/>
                </scope>
            </method>
            <javadoc line="149">
                Check an assignment expression                
            </javadoc>
            <method name="checkValue" type="Vset" line="152">
                <params>
                    <param name="env" type="Environment"/>
                    <param name="ctx" type="Context"/>
                    <param name="vset" type="Vset"/>
                    <param name="exp" type="Hashtable"/>
                </params>
                <comment line="163">
                    Must be called after &apos;checkAssignOp&apos;.                    
                </comment>
                <declaration name="tm" type="int" line="155"/>
                <scope line="156"/>
                <scope line="160"/>
            </method>
            <javadoc line="167">
                Inline                
            </javadoc>
            <method name="inlineValue" type="Expression" line="170">
                <params>
                    <param name="env" type="Environment"/>
                    <param name="ctx" type="Context"/>
                </params>
                <comment line="171">
                    Why not inlineLHS?  But that does not work.                    
                </comment>
                <scope line="174"/>
            </method>
            <javadoc line="180">
                Create a copy of the expression for method inlining                
            </javadoc>
            <method name="copyInline" type="Expression" line="183">
                <params>
                    <param name="ctx" type="Context"/>
                </params>
                <declaration name="e" type="AssignOpExpression" line="184"/>
                <scope line="187"/>
            </method>
            <javadoc line="193">
                The cost of inlining this statement                
            </javadoc>
            <method name="costInline" type="int" line="196">
                <params>
                    <param name="thresh" type="int"/>
                    <param name="env" type="Environment"/>
                    <param name="ctx" type="Context"/>
                </params>
                <comment line="197">
                    ----------
                    return (getIncrement() != NOINC)
                    ? 2
                    : (3 + super.costInline(thresh, env, ctx));                    
                </comment>
                <comment line="204">
                    Increment variable in place.  Count 3 bytes for &apos;iinc&apos;.                    
                </comment>
                <comment line="206">
                    Cost of rhs expression + cost of lhs expression + cost                    
                </comment>
                <comment line="207">
                    of load/op/store instructions.  E.g.: iload = 1 or 2,                    
                </comment>
                <comment line="208">
                    istore = 1 or 2, iadd = 1.  Cost could be higher if                    
                </comment>
                <comment line="209">
                    getfield/putfield or conversions needed, lower if rhs is                    
                </comment>
                <comment line="210">
                    a small constant.  Costs are highly approximate.                    
                </comment>
                <comment line="214">
                    Cost of rhs expression + (2 * cost of access method call) +                    
                </comment>
                <comment line="215">
                    cost of operator.  Does not account for cost of conversions,                    
                </comment>
                <comment line="216">
                    or duplications in value-needed context.                    
                </comment>
                <scope line="202"/>
                <scope line="213"/>
            </method>
            <javadoc line="222">
                Code                
            </javadoc>
            <method name="code" type="void" line="225">
                <params>
                    <param name="env" type="Environment"/>
                    <param name="ctx" type="Context"/>
                    <param name="asm" type="Assembler"/>
                    <param name="valNeeded" type="boolean"/>
                </params>
                <comment line="227">
                    Handle cases in which a &apos;+=&apos; or &apos;-=&apos; operator can be optimized using                    
                </comment>
                <comment line="228">
                    the &apos;iinc&apos; instruction.  See also &apos;IncDecExpression.codeIncDec&apos;.                    
                </comment>
                <comment line="229">
                    The &apos;iinc&apos; instruction cannot be used if an access method call is required.                    
                </comment>
                <comment line="242">
                    Field is directly accessible.                    
                </comment>
                <comment line="255">
                    Must use access methods.                    
                </comment>
                <declaration name="val" type="int" line="230"/>
                <scope line="231">
                    <declaration name="v" type="int" line="232"/>
                    <declaration name="operands" type="int[]" line="233"/>
                    <scope line="235"/>
                </scope>
                <scope line="241">
                    <declaration name="depth" type="int" line="243"/>
                    <scope line="250"/>
                </scope>
                <scope line="254"/>
            </method>
            <method name="codeValue" type="void" line="265">
                <params>
                    <param name="env" type="Environment"/>
                    <param name="ctx" type="Context"/>
                    <param name="asm" type="Assembler"/>
                </params>
            </method>
            <method name="code" type="void" line="268">
                <params>
                    <param name="env" type="Environment"/>
                    <param name="ctx" type="Context"/>
                    <param name="asm" type="Assembler"/>
                </params>
            </method>
            <javadoc line="272">
                Print                
            </javadoc>
            <method name="print" type="void" line="275">
                <params>
                    <param name="out" type="PrintStream"/>
                </params>
            </method>
        </class>
    </source>