<?xml version="1.0" encoding="UTF-8"?>
    <source package="sun.tools.tree">
        <import package="sun.tools.java"/>
        <import package="sun.tools.asm.Assembler"/>
        <import package="sun.tools.asm.Label"/>
        <import package="sun.tools.asm.TryData"/>
        <import package="sun.tools.asm.CatchData"/>
        <import package="java.io.PrintStream"/>
        <import package="java.util.Hashtable"/>
        <import package="java.util.Enumeration"/>
        <class name="FinallyStatement" line="37">
            <extends class="Statement"/>
            <comment line="47">
                does finalBody never return?                
            </comment>
            <comment line="48">
                set by inner return statement                
            </comment>
            <comment line="49">
                try object expression  or declaration from parser                
            </comment>
            <comment line="50">
                temp holding the try object, if any                
            </comment>
            <comment line="61">
                /**                
            </comment>
            <comment line="62">
                * Constructor for  try (init) {body}                
            </comment>
            <comment line="63">
                */                
            </comment>
            <comment line="64">
                public FinallyStatement(long where, Statement init, Statement body, int junk) {                
            </comment>
            <comment line="65">
                this(where, body, null);                
            </comment>
            <comment line="66">
                this.init = init;                
            </comment>
            <comment line="67">
                }                
            </comment>
            <javadoc line="37">
                WARNING: The contents of this source file are not part of any
                  supported API.  Code that depends on them does so at its own risk:
                  they are subject to change or removal without notice.                
            </javadoc>
            <declaration name="body" type="Statement" line="44"/>
            <declaration name="finalbody" type="Statement" line="45"/>
            <declaration name="finallyCanFinish" type="boolean" line="46"/>
            <declaration name="needReturnSlot" type="boolean" line="47"/>
            <declaration name="init" type="Statement" line="48"/>
            <declaration name="tryTemp" type="LocalMember" line="49"/>
            <javadoc line="51">
                Constructor                
            </javadoc>
            <method name="FinallyStatement" type="constructor" line="54">
                <params>
                    <param name="where" type="long"/>
                    <param name="body" type="Statement"/>
                    <param name="finalbody" type="Statement"/>
                </params>
            </method>
            <javadoc line="68">
                Check statement                
            </javadoc>
            <method name="check" type="Vset" line="71">
                <params>
                    <param name="env" type="Environment"/>
                    <param name="ctx" type="Context"/>
                    <param name="vset" type="Vset"/>
                    <param name="exp" type="Hashtable"/>
                </params>
                <comment line="75">
                    Handle the proposed &apos;try (init) { stmts } finally { stmts }&apos; syntax.                    
                </comment>
                <comment line="76">
                    This feature has not been adopted, and support is presently disabled.                    
                </comment>
                <comment line="77">
                    -----------------------------------------------------------
                    if (init != null) {
                    ClassDefinition sourceClass = ctx.field.getClassDefinition();
                    Expression tryExpr = null;
                    DeclarationStatement tryDecl = null;
                    long where = init.getWhere();
                     find out whether init is a simple expression or a declaration
                    if (init.getOp() == EXPRESSION) {
                    tryExpr = ((ExpressionStatement)init).expr;
                    init = null;     restore it below
                    vset = tryExpr.checkValue(env, ctx, vset, exp);
                    } else if (init.getOp() == DECLARATION) {
                    tryDecl = (DeclarationStatement) init;
                    init = null;     restore it below
                    vset = tryDecl.checkBlockStatement(env, ctx, vset, exp);
                    if (tryDecl.args.length != 1) {
                    env.error(where, &quot;invalid.decl&quot;);
                    } else {
                    LocalMember field =
                    ((VarDeclarationStatement) tryDecl.args[0]).field;
                    tryExpr = new IdentifierExpression(where, field);
                    tryExpr.type = field.getType();
                    }
                    } else {
                    env.error(where, &quot;invalid.expr&quot;);
                    vset = init.check(env, ctx, vset, exp);
                    }
                    Type type = (tryExpr == null) ? Type.tError : tryExpr.getType();
                    
                    MemberDefinition tryEnter = null;
                    MemberDefinition tryExit = null;
                    if (!type.isType(TC_CLASS)) {
                    if (!type.isType(TC_ERROR)) {
                    env.error(where, &quot;invalid.method.invoke&quot;, type);
                    }
                    } else {
                    Identifier idTryEnter = Identifier.lookup(&quot;tryEnter&quot;);
                    Identifier idTryExit = Identifier.lookup(&quot;tryExit&quot;);
                    Type tTryMethod = Type.tMethod(Type.tVoid);
                    try {
                    ClassDefinition tryClass = env.getClassDefinition(type);
                    tryEnter = tryClass.matchMethod(env, sourceClass, idTryEnter);
                    tryExit = tryClass.matchMethod(env, sourceClass, idTryExit);
                    if (tryEnter != null &amp;&amp; !tryEnter.getType().equals(tTryMethod)) {
                    tryEnter = null;
                    }
                    if (tryExit != null &amp;&amp; !tryExit.getType().equals(tTryMethod)) {
                    tryExit = null;
                    }
                    } catch (ClassNotFound ee) {
                    env.error(where, &quot;class.not.found&quot;, ee.name, ctx.field);
                    } catch (AmbiguousMember ee) {
                    Identifier id = ee.field1.getName();
                    env.error(where, &quot;ambig.field&quot;, id, ee.field1, ee.field2);
                    }
                    }
                    if (tryEnter == null || tryExit == null) {
                     Make a better (more didactic) error here!
                    env.error(where, &quot;invalid.method.invoke&quot;, type);
                    } else {
                    tryTemp = new LocalMember(where, sourceClass, 0,
                    type, Identifier.lookup(&quot;&lt;try_object&gt;&quot;));
                    ctx = new Context(ctx, this);
                    ctx.declare(env, tryTemp);
                    
                    Expression e;
                    e = new IdentifierExpression(where, tryTemp);
                    e = new AssignExpression(where, e, tryExpr);
                    e = new MethodExpression(where, e, tryEnter, new Expression[0]);
                    e.type = Type.tVoid;
                    Statement enterCall = new ExpressionStatement(where, e);
                     store it on the init, for code generation
                    if (tryDecl != null) {
                    Statement args2[] = { tryDecl.args[0], enterCall };
                    tryDecl.args = args2;
                    init = tryDecl;
                    } else {
                    init = enterCall;
                    }
                    e = new IdentifierExpression(where, tryTemp);
                    e = new MethodExpression(where, e, tryExit, new Expression[0]);
                    e.type = Type.tVoid;
                    Statement exitCall = new ExpressionStatement(where, e);
                    finalbody = exitCall;
                    }
                    }                    
                </comment>
                <comment line="165">
                    Check the try part. We reach the end of the try part either by                    
                </comment>
                <comment line="166">
                    finishing normally, or doing a break to the label of the try/finally.                    
                </comment>
                <comment line="167">
                    NOTE: I don&apos;t think newctx1.vsBreak is ever used -- see TryStatement.                    
                </comment>
                <comment line="171">
                    Check the finally part.                    
                </comment>
                <comment line="173">
                    Should never access this field.  The null indicates the finally part.                    
                </comment>
                <comment line="178">
                    If !finallyCanFinish, then the only possible exceptions that can                    
                </comment>
                <comment line="179">
                    occur at this point are the ones preceding the try/finally, or                    
                </comment>
                <comment line="180">
                    the ones generated by the finally.  Anything in the try is                    
                </comment>
                <comment line="181">
                    irrelevant. Otherwise, we have to merge in all the exceptions                    
                </comment>
                <comment line="182">
                    generated by the body into exp.                    
                </comment>
                <comment line="184">
                    Add newexp&apos;s back into exp; cf. ThrowStatement.check().                    
                </comment>
                <declaration name="newexp" type="Hashtable" line="73"/>
                <declaration name="newctx1" type="CheckContext" line="168"/>
                <declaration name="vset1" type="Vset" line="169"/>
                <declaration name="newctx2" type="CheckContext" line="172"/>
                <declaration name="vset2" type="Vset" line="175"/>
                <scope line="183">
                    <scope line="185">
                        <declaration name="def" type="Object" line="186"/>
                    </scope>
                </scope>
            </method>
            <javadoc line="193">
                Inline                
            </javadoc>
            <method name="inline" type="Statement" line="196">
                <params>
                    <param name="env" type="Environment"/>
                    <param name="ctx" type="Context"/>
                </params>
                <scope line="197"/>
                <scope line="201"/>
                <scope line="204"/>
                <scope line="207"/>
                <scope line="210"/>
                <scope line="213"/>
            </method>
            <javadoc line="219">
                Create a copy of the statement for method inlining                
            </javadoc>
            <method name="copyInline" type="Statement" line="222">
                <params>
                    <param name="ctx" type="Context"/>
                    <param name="valNeeded" type="boolean"/>
                </params>
                <declaration name="s" type="FinallyStatement" line="223"/>
                <scope line="224"/>
                <scope line="227"/>
                <scope line="230"/>
                <scope line="233"/>
            </method>
            <javadoc line="239">
                Compute cost of inlining this statement                
            </javadoc>
            <method name="costInline" type="int" line="242">
                <params>
                    <param name="thresh" type="int"/>
                    <param name="env" type="Environment"/>
                    <param name="ctx" type="Context"/>
                </params>
                <declaration name="cost" type="int" line="243"/>
                <scope line="244"/>
                <scope line="248"/>
                <scope line="252"/>
            </method>
            <javadoc line="258">
                Code                
            </javadoc>
            <method name="code" type="void" line="261">
                <params>
                    <param name="env" type="Environment"/>
                    <param name="ctx" type="Context"/>
                    <param name="asm" type="Assembler"/>
                </params>
                <comment line="287">
                    allocate space for the exception and return address                    
                </comment>
                <comment line="297">
                    Main body                    
                </comment>
                <comment line="299">
                    start of protected code                    
                </comment>
                <comment line="302">
                    end of protected code                    
                </comment>
                <comment line="304">
                    Cleanup afer body                    
                </comment>
                <comment line="309">
                    just goto the cleanup code.  It will never return.                    
                </comment>
                <comment line="313">
                    Catch code                    
                </comment>
                <comment line="317">
                    store exception                    
                </comment>
                <comment line="319">
                    rethrow exception                    
                </comment>
                <comment line="322">
                    pop exception off stack.  Fall through to finally code                    
                </comment>
                <comment line="326">
                    The finally part, which is marked by the contLabel.  Update                    
                </comment>
                <comment line="327">
                    breakLabel: since break&apos;s in the finally are different                    
                </comment>
                <comment line="328">
                    contLabel:  to null to indicate no longer in the protected code.                    
                </comment>
                <comment line="333">
                    save the return address                    
                </comment>
                <comment line="334">
                    execute the cleanup code                    
                </comment>
                <comment line="335">
                    return                    
                </comment>
                <comment line="337">
                    execute the cleanup code                    
                </comment>
                <comment line="339">
                    breaks come here                    
                </comment>
                <declaration name="num1" type="Integer" line="263"/>
                <declaration name="endLabel" type="Label" line="264"/>
                <scope line="266"/>
                <scope line="269">
                    <declaration name="exprctx" type="CodeContext" line="270"/>
                </scope>
                <scope line="274">
                    <declaration name="f1" type="LocalMember" line="275"/>
                    <declaration name="thisClass" type="ClassDefinition" line="276"/>
                    <scope line="278">
                        <declaration name="returnType" type="Type" line="279"/>
                        <declaration name="localfield" type="LocalMember" line="280"/>
                    </scope>
                </scope>
                <declaration name="td" type="TryData" line="294"/>
                <declaration name="bodyctx" type="CodeContext" line="298"/>
                <scope line="305"/>
                <scope line="308"/>
                <declaration name="cd" type="CatchData" line="314"/>
                <scope line="316"/>
                <scope line="321"/>
                <scope line="332"/>
                <scope line="336"/>
            </method>
            <javadoc line="342">
                Print                
            </javadoc>
            <method name="print" type="void" line="345">
                <params>
                    <param name="out" type="PrintStream"/>
                    <param name="indent" type="int"/>
                </params>
                <scope line="348"/>
                <scope line="350"/>
                <scope line="354"/>
                <scope line="356"/>
            </method>
        </class>
    </source>