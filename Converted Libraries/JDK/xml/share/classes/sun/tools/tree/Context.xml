<?xml version="1.0" encoding="UTF-8"?>
    <source package="sun.tools.tree">
        <import package="sun.tools.java"/>
        <import package="sun.tools.asm.Assembler"/>
        <class name="Context" line="31">
            <implements interface="Constants"/>
            <javadoc line="31">
                WARNING: The contents of this source file are not part of any
                  supported API.  Code that depends on them does so at its own risk:
                  they are subject to change or removal without notice.                
            </javadoc>
            <declaration name="prev" type="Context" line="38"/>
            <declaration name="node" type="Node" line="39"/>
            <declaration name="varNumber" type="int" line="40"/>
            <declaration name="locals" type="LocalMember" line="41"/>
            <declaration name="classes" type="LocalMember" line="42"/>
            <declaration name="field" type="MemberDefinition" line="43"/>
            <declaration name="scopeNumber" type="int" line="44"/>
            <declaration name="frameNumber" type="int" line="45"/>
            <javadoc line="47">
                Create the initial context for a method
                  The incoming context is inherited from                
            </javadoc>
            <method name="Context" type="constructor" line="51">
                <params>
                    <param name="ctx" type="Context"/>
                    <param name="field" type="MemberDefinition"/>
                </params>
                <comment line="63">
                    Variables and initializers are inlined into a constructor.                    
                </comment>
                <comment line="64">
                    Model this by inheriting the frame number of the parent,                    
                </comment>
                <comment line="65">
                    which will contain a &quot;this&quot; parameter.                    
                </comment>
                <scope line="53"/>
                <scope line="57">
                    <scope line="62"/>
                    <scope line="68"/>
                </scope>
            </method>
            <javadoc line="76">
                Create a new context, for initializing a class.                
            </javadoc>
            <method name="Context" type="constructor" line="79">
                <params>
                    <param name="ctx" type="Context"/>
                    <param name="c" type="ClassDefinition"/>
                </params>
            </method>
            <javadoc line="83">
                Create a new nested context, for a block statement                
            </javadoc>
            <method name="Context" type="constructor" line="86">
                <params>
                    <param name="ctx" type="Context"/>
                    <param name="node" type="Node"/>
                </params>
                <comment line="94">
                    Inherit local classes from surrounding block,                    
                </comment>
                <comment line="95">
                    just as for local variables.  Fixes 4074421.                    
                </comment>
                <scope line="87"/>
                <scope line="91"/>
            </method>
            <method name="Context" type="constructor" line="105">
                <params>
                    <param name="ctx" type="Context"/>
                </params>
            </method>
            <javadoc line="109">
                Declare local                
            </javadoc>
            <method name="declare" type="int" line="112">
                <params>
                    <param name="env" type="Environment"/>
                    <param name="local" type="LocalMember"/>
                </params>
                <comment line="113">
                    System.out.println(   &quot;DECLARE= &quot; + local.getName() + &quot;=&quot; + varNumber + &quot;, read=&quot; + local.readcount + &quot;, write=&quot; + local.writecount + &quot;, hash=&quot; + local.hashCode());                    
                </comment>
                <comment line="116">
                    Anticipate variable or initializer.                    
                </comment>
                <comment line="124">
                    Originally the statement:                    
                </comment>
                <comment line="125">
                                        
                </comment>
                <comment line="126">
                    local.subModifiers(M_INLINEABLE);                    
                </comment>
                <comment line="127">
                                        
                </comment>
                <comment line="128">
                    was here with the comment:                    
                </comment>
                <comment line="129">
                                        
                </comment>
                <comment line="130">
                    // prevent inlining across call sites                    
                </comment>
                <comment line="131">
                                        
                </comment>
                <comment line="132">
                    This statement prevented constant local variables from                    
                </comment>
                <comment line="133">
                    inlining. It didn&apos;t seem to do anything useful.                    
                </comment>
                <comment line="134">
                                        
                </comment>
                <comment line="135">
                    The statement has been removed and an assertion has been                    
                </comment>
                <comment line="136">
                    added which mandates that the only members which are marked                    
                </comment>
                <comment line="137">
                    with M_INLINEABLE are the ones for which isConstant() is true.                    
                </comment>
                <comment line="138">
                    (Fix for 4106244.)                    
                </comment>
                <comment line="139">
                                        
                </comment>
                <comment line="140">
                    Addition to the above comment: they might also be                    
                </comment>
                <comment line="141">
                    final variables initialized with &apos;this&apos;, &apos;super&apos;, or other                    
                </comment>
                <comment line="142">
                    final identifiers.  See VarDeclarationStatement.inline().                    
                </comment>
                <comment line="143">
                    So I&apos;ve removed the assertion.  The original subModifiers                    
                </comment>
                <comment line="144">
                    call appears to have been there to fix nested class translation                    
                </comment>
                <comment line="145">
                    breakage, which has been fixed in VarDeclarationStatement                    
                </comment>
                <comment line="146">
                    now instead.  (Fix for 4073244.)                    
                </comment>
                <scope line="115"/>
                <scope line="118"/>
            </method>
            <javadoc line="155">
                Get a local variable by name                
            </javadoc>
            <method name="getLocalField" type="LocalMember" line="159">
                <params>
                    <param name="name" type="Identifier"/>
                </params>
                <scope line="160">
                    <scope line="161"/>
                </scope>
            </method>
            <javadoc line="168">
                Get the scope number for a reference to a member of this class
                  (Larger scope numbers are more deeply nested.)                
                <see>
                    LocalMember#scopeNumber                    
                </see>
            </javadoc>
            <method name="getScopeNumber" type="int" line="174">
                <params>
                    <param name="c" type="ClassDefinition"/>
                </params>
                <scope line="175">
                    <scope line="177"/>
                </scope>
            </method>
            <method name="getFieldCommon" type="MemberDefinition" line="186">
                <params>
                    <param name="env" type="Environment"/>
                    <param name="name" type="Identifier"/>
                    <param name="apparentOnly" type="boolean"/>
                </params>
                <comment line="187">
                    Note:  This is structured as a pair of parallel lookups.                    
                </comment>
                <comment line="188">
                    If we were to redesign Context, we might prefer to walk                    
                </comment>
                <comment line="189">
                    along a single chain of scopes.                    
                </comment>
                <comment line="196">
                    Also look for a class member in a shallower scope.                    
                </comment>
                <declaration name="lf" type="LocalMember" line="191"/>
                <declaration name="ls" type="int" line="192"/>
                <declaration name="thisClass" type="ClassDefinition" line="194"/>
                <scope line="199">
                    <declaration name="f" type="MemberDefinition" line="200"/>
                    <scope line="201">
                        <scope line="202"/>
                    </scope>
                </scope>
            </method>
            <javadoc line="212">
                Assign a number to a class field.
                  (This is used to track definite assignment of some blank finals.)                
            </javadoc>
            <method name="declareFieldNumber" type="int" line="216">
                <params>
                    <param name="field" type="MemberDefinition"/>
                </params>
            </method>
            <javadoc line="220">
                Retrieve a number previously assigned by declareMember().
                  Return -1 if there was no such assignment in this context.                
            </javadoc>
            <method name="getFieldNumber" type="int" line="224">
                <params>
                    <param name="field" type="MemberDefinition"/>
                </params>
                <scope line="225">
                    <scope line="226"/>
                </scope>
            </method>
            <javadoc line="233">
                Return the local field or member field corresponding to a number.
                  Return null if there is no such field.                
            </javadoc>
            <method name="getElement" type="MemberDefinition" line="237">
                <params>
                    <param name="number" type="int"/>
                </params>
                <scope line="238">
                    <scope line="239">
                        <declaration name="field" type="MemberDefinition" line="240"/>
                    </scope>
                </scope>
            </method>
            <javadoc line="247">
                Get a local class by name                
            </javadoc>
            <method name="getLocalClass" type="LocalMember" line="251">
                <params>
                    <param name="name" type="Identifier"/>
                </params>
                <scope line="252">
                    <scope line="253"/>
                </scope>
            </method>
            <method name="getClassCommon" type="MemberDefinition" line="262">
                <params>
                    <param name="env" type="Environment"/>
                    <param name="name" type="Identifier"/>
                    <param name="apparentOnly" type="boolean"/>
                </params>
                <comment line="266">
                    Also look for a class member in a shallower scope.                    
                </comment>
                <comment line="270">
                    QUERY: We may need to get the inner class from a                    
                </comment>
                <comment line="271">
                    superclass of &apos;c&apos;.  This call is prepared to                    
                </comment>
                <comment line="272">
                    resolve the superclass if necessary.  Can we arrange                    
                </comment>
                <comment line="273">
                    to assure that it is always previously resolved?                    
                </comment>
                <comment line="274">
                    This is one of a small number of problematic calls that                    
                </comment>
                <comment line="275">
                    requires &apos;getSuperClass&apos; to resolve superclasses on demand.                    
                </comment>
                <comment line="276">
                    See &apos;ClassDefinition.getInnerClass(env, nm)&apos;.                    
                </comment>
                <declaration name="lf" type="LocalMember" line="263"/>
                <declaration name="ls" type="int" line="264"/>
                <scope line="269">
                    <declaration name="f" type="MemberDefinition" line="277"/>
                    <scope line="278">
                        <scope line="279"/>
                    </scope>
                </scope>
            </method>
            <javadoc line="289">
                Get either a local variable, or a field in a current class                
            </javadoc>
            <method name="getField" type="MemberDefinition" line="293">
                <params>
                    <param name="env" type="Environment"/>
                    <param name="name" type="Identifier"/>
                </params>
            </method>
            <javadoc line="297">
                Like getField, except that it skips over inherited fields.
                  Used for error checking.                
            </javadoc>
            <method name="getApparentField" type="MemberDefinition" line="302">
                <params>
                    <param name="env" type="Environment"/>
                    <param name="name" type="Identifier"/>
                </params>
            </method>
            <javadoc line="306">
                Check if the given field is active in this context.                
            </javadoc>
            <method name="isInScope" type="boolean" line="309">
                <params>
                    <param name="field" type="LocalMember"/>
                </params>
                <scope line="310">
                    <scope line="311"/>
                </scope>
            </method>
            <javadoc line="318">
                Notice a reference (usually an uplevel one).
                  Update the references list of every enclosing class
                  which is enclosed by the scope of the target.
                  Update decisions about which uplevels to make into fields.
                  Return the uplevel reference descriptor, or null if it&apos;s local.
                  &lt;p&gt;
                  The target must be in scope in this context.
                  So, call this method only from the check phase.
                  (In other phases, the context may be less complete.)
                  &lt;p&gt;
                  This can and should be called both before and after classes are frozen.
                  It should be a no-op, and will raise a compiler error if not.                
            </javadoc>
            <method name="noteReference" type="UplevelReference" line="332">
                <params>
                    <param name="env" type="Environment"/>
                    <param name="target" type="LocalMember"/>
                </params>
                <comment line="335">
                    Walk outward visiting each scope.                    
                </comment>
                <comment line="336">
                    Note each distinct frame (i.e., enclosing method).                    
                </comment>
                <comment line="337">
                    For each frame in which the variable is uplevel,                    
                </comment>
                <comment line="338">
                    record the event in the references list of the enclosing class.                    
                </comment>
                <comment line="343">
                    we&apos;re processing frames, not contexts                    
                </comment>
                <comment line="347">
                    the target is native to this frame                    
                </comment>
                <comment line="350">
                    process a frame which is using this variable as an uplevel                    
                </comment>
                <comment line="355">
                    remember the reference pertaining to the innermost frame                    
                </comment>
                <declaration name="targetScopeNumber" type="int" line="333"/>
                <declaration name="res" type="UplevelReference" line="339"/>
                <declaration name="currentFrameNumber" type="int" line="340"/>
                <scope line="341">
                    <scope line="342"/>
                    <scope line="346"/>
                    <declaration name="refc" type="ClassDefinition" line="351"/>
                    <declaration name="r" type="UplevelReference" line="352"/>
                    <scope line="356"/>
                </scope>
            </method>
            <javadoc line="363">
                Implement a reference (usually an uplevel one).
                  Call noteReference() first, to make sure the reference
                  lists are up to date.
                  &lt;p&gt;
                  The resulting expression tree does not need checking;
                  it can be code-generated right away.
                  If the reference is not uplevel, the result is an IDENT or THIS.                
            </javadoc>
            <method name="makeReference" type="Expression" line="372">
                <params>
                    <param name="env" type="Environment"/>
                    <param name="target" type="LocalMember"/>
                </params>
                <comment line="375">
                    Now create a referencing expression.                    
                </comment>
                <declaration name="r" type="UplevelReference" line="373"/>
                <scope line="376"/>
                <scope line="378"/>
                <scope line="380"/>
            </method>
            <javadoc line="385">
                Return a local expression which can serve as the base reference
                  for the given field.  If the field is a constructor, return an
                  expression for the implicit enclosing instance argument.
                  &lt;p&gt;
                  Return null if there is no need for such an argument,
                  or if there was an error.                
            </javadoc>
            <method name="findOuterLink" type="Expression" line="394">
                <params>
                    <param name="env" type="Environment"/>
                    <param name="where" type="long"/>
                    <param name="f" type="MemberDefinition"/>
                </params>
                <comment line="395">
                    reqc is the base pointer type required to use f                    
                </comment>
                <declaration name="fc" type="ClassDefinition" line="396"/>
                <declaration name="reqc" type="ClassDefinition" line="397"/>
                <scope line="401"/>
            </method>
            <method name="match" type="boolean" line="408">
                <params>
                    <param name="env" type="Environment"/>
                    <param name="thisc" type="ClassDefinition"/>
                    <param name="reqc" type="ClassDefinition"/>
                </params>
                <scope line="409"/>
                <scope line="412"/>
            </method>
            <method name="findOuterLink" type="Expression" line="420">
                <params>
                    <param name="env" type="Environment"/>
                    <param name="where" type="long"/>
                    <param name="reqc" type="ClassDefinition"/>
                    <param name="f" type="MemberDefinition"/>
                    <param name="needExactMatch" type="boolean"/>
                </params>
                <comment line="423">
                    say something like: undefined variable A.this                    
                </comment>
                <comment line="435">
                    This is an attempt at error recovery.                    
                </comment>
                <comment line="436">
                    Unfortunately, the constructor may throw                    
                </comment>
                <comment line="437">
                    a null pointer exception after failing to resolve                    
                </comment>
                <comment line="438">
                    &apos;idThis&apos;.  Since an error message has already been                    
                </comment>
                <comment line="439">
                    issued previously, this exception is caught and                    
                </comment>
                <comment line="440">
                    silently ignored.  Ideally, we should avoid throwing                    
                </comment>
                <comment line="441">
                    the exception.                    
                </comment>
                <comment line="447">
                    use lp to scan for current instances (locals named &quot;this&quot;)                    
                </comment>
                <comment line="450">
                    thise is a link expression being built up                    
                </comment>
                <comment line="453">
                    root is the local variable (idThis) at the far left of thise                    
                </comment>
                <comment line="456">
                    thisc is the class of the link expression thise                    
                </comment>
                <comment line="459">
                    conCls is the class of the &quot;this&quot;, in a constructor                    
                </comment>
                <comment line="472">
                    start fresh from lp                    
                </comment>
                <comment line="485">
                    Require exact class identity when called with                    
                </comment>
                <comment line="486">
                    &apos;needExactMatch&apos; true.  This is done when checking                    
                </comment>
                <comment line="487">
                    the &apos;&lt;class&gt;.this&apos; syntax.  Fixes 4102393 and 4133457.                    
                </comment>
                <comment line="493">
                    move out one step, if the current instance has an outer link                    
                </comment>
                <comment line="498">
                    try to find more help in lp                    
                </comment>
                <comment line="504">
                    Must pick up &quot;this$C&quot; from the constructor argument,                    
                </comment>
                <comment line="505">
                    not from &quot;this.this$C&quot;, since the latter may not be                    
                </comment>
                <comment line="506">
                    initialized properly.  (This way is cheaper too.)                    
                </comment>
                <comment line="516">
                    mark crossed scopes                    
                </comment>
                <comment line="517">
                    ?????                    
                </comment>
                <comment line="518">
                    ensureAvailable(root);                    
                </comment>
                <comment line="523">
                    say something like: undefined variable A.this                    
                </comment>
                <comment line="532">
                    avoid floodgating:                    
                </comment>
                <scope line="421">
                    <scope line="422">
                        <declaration name="nm" type="Identifier" line="424"/>
                    </scope>
                    <scope line="426"/>
                    <scope line="428"/>
                    <scope line="431"/>
                    <declaration name="e" type="Expression" line="442"/>
                </scope>
                <declaration name="lp" type="LocalMember" line="448"/>
                <declaration name="thise" type="Expression" line="451"/>
                <declaration name="root" type="LocalMember" line="454"/>
                <declaration name="thisc" type="ClassDefinition" line="457"/>
                <declaration name="conCls" type="ClassDefinition" line="460"/>
                <scope line="461"/>
                <scope line="465"/>
                <scope line="470">
                    <scope line="471">
                        <scope line="473"/>
                        <scope line="476"/>
                    </scope>
                    <scope line="489"/>
                    <declaration name="outerMember" type="MemberDefinition" line="495"/>
                    <scope line="496"/>
                    <declaration name="prevc" type="ClassDefinition" line="500"/>
                    <scope line="503">
                        <declaration name="nm" type="Identifier" line="507"/>
                        <declaration name="arg" type="IdentifierExpression" line="508"/>
                    </scope>
                    <scope line="511"/>
                </scope>
                <scope line="515"/>
                <scope line="522">
                    <declaration name="nm" type="Identifier" line="524"/>
                </scope>
                <scope line="526"/>
                <scope line="528"/>
                <declaration name="e" type="Expression" line="533"/>
            </method>
            <javadoc line="538">
                Is there a &quot;this&quot; of type reqc in scope?                
            </javadoc>
            <method name="outerLinkExists" type="boolean" line="543">
                <params>
                    <param name="env" type="Environment"/>
                    <param name="reqc" type="ClassDefinition"/>
                    <param name="thisc" type="ClassDefinition"/>
                </params>
                <scope line="544">
                    <scope line="545"/>
                </scope>
            </method>
            <javadoc line="553">
                From which enclosing class do members of this type come?                
            </javadoc>
            <method name="findScope" type="ClassDefinition" line="556">
                <params>
                    <param name="env" type="Environment"/>
                    <param name="reqc" type="ClassDefinition"/>
                </params>
                <declaration name="thisc" type="ClassDefinition" line="557"/>
                <scope line="558"/>
            </method>
            <javadoc line="564">
                Resolve a type name from within a local scope.                
                <see>
                    Environment#resolveName                    
                </see>
            </javadoc>
            <method name="resolveName" type="Identifier" line="568">
                <params>
                    <param name="env" type="Environment"/>
                    <param name="name" type="Identifier"/>
                </params>
                <comment line="569">
                    This logic is pretty much exactly parallel to that of                    
                </comment>
                <comment line="570">
                    Environment.resolveName().                    
                </comment>
                <comment line="572">
                    Try to resolve the first identifier component,                    
                </comment>
                <comment line="573">
                    because inner class names take precedence over                    
                </comment>
                <comment line="574">
                    package prefixes.  (Cf. Environment.resolveName.)                    
                </comment>
                <comment line="578">
                    The first identifier component refers to an                    
                </comment>
                <comment line="579">
                    ambiguous class.  Limp on.  We throw away the                    
                </comment>
                <comment line="580">
                    rest of the classname as it is irrelevant.                    
                </comment>
                <comment line="581">
                    (part of solution for 4059855).                    
                </comment>
                <comment line="592">
                    return partially-resolved name someone else can fail on                    
                </comment>
                <comment line="597">
                    Look for an unqualified name in enclosing scopes.                    
                </comment>
                <comment line="604">
                    a missing superclass, or something catastrophic                    
                </comment>
                <comment line="607">
                    look in imports, etc.                    
                </comment>
                <scope line="571">
                    <declaration name="rhead" type="Identifier" line="575"/>
                    <scope line="577"/>
                    <scope line="585"/>
                    <scope line="588"/>
                    <scope line="591"/>
                </scope>
                <scope line="598">
                    <declaration name="f" type="MemberDefinition" line="599"/>
                    <scope line="600"/>
                </scope>
                <scope line="603"/>
            </method>
            <javadoc line="611">
                Return the name of a lexically apparent type,
                  skipping inherited members, and ignoring
                  the current pacakge and imports.
                  This is used for error checking.                
            </javadoc>
            <method name="getApparentClassName" type="Identifier" line="618">
                <params>
                    <param name="env" type="Environment"/>
                    <param name="name" type="Identifier"/>
                </params>
                <comment line="620">
                    Try to resolve the first identifier component,                    
                </comment>
                <comment line="621">
                    because inner class names take precedence over                    
                </comment>
                <comment line="622">
                    package prefixes.  (Cf. Environment.resolveName.)                    
                </comment>
                <comment line="629">
                    Look for an unqualified name in enclosing scopes.                    
                </comment>
                <comment line="636">
                    a missing superclass, or something catastrophic                    
                </comment>
                <comment line="639">
                    the enclosing class name is the only apparent package member:                    
                </comment>
                <scope line="619">
                    <declaration name="rhead" type="Identifier" line="623"/>
                </scope>
                <scope line="630">
                    <declaration name="f" type="MemberDefinition" line="631"/>
                    <scope line="632"/>
                </scope>
                <scope line="635"/>
                <declaration name="topnm" type="Identifier" line="640"/>
                <scope line="641"/>
            </method>
            <javadoc line="647">
                Raise an error if a blank final was definitely unassigned
                  on entry to a loop, but has possibly been assigned on the
                  back-branch.  If this is the case, the loop may be assigning
                  it multiple times.                
            </javadoc>
            <method name="checkBackBranch" type="void" line="654">
                <params>
                    <param name="env" type="Environment"/>
                    <param name="loop" type="Statement"/>
                    <param name="vsEntry" type="Vset"/>
                    <param name="vsBack" type="Vset"/>
                </params>
                <scope line="655">
                    <scope line="658"/>
                </scope>
            </method>
            <javadoc line="665">
                Check if a field can reach another field (only considers
                  forward references, not the access modifiers).                
            </javadoc>
            <method name="canReach" type="boolean" line="669">
                <params>
                    <param name="env" type="Environment"/>
                    <param name="f" type="MemberDefinition"/>
                </params>
            </method>
            <javadoc line="673">
                Get the context that corresponds to a label, return null if
                  not found.                
            </javadoc>
            <method name="getLabelContext" type="Context" line="678">
                <params>
                    <param name="lbl" type="Identifier"/>
                </params>
                <scope line="679">
                    <scope line="680"/>
                </scope>
            </method>
            <javadoc line="688">
                Get the destination context of a break                
            </javadoc>
            <method name="getBreakContext" type="Context" line="692">
                <params>
                    <param name="lbl" type="Identifier"/>
                </params>
                <scope line="693"/>
                <scope line="696">
                    <scope line="697"/>
                </scope>
            </method>
            <javadoc line="710">
                Get the destination context of a continue                
            </javadoc>
            <method name="getContinueContext" type="Context" line="714">
                <params>
                    <param name="lbl" type="Identifier"/>
                </params>
                <scope line="715"/>
                <scope line="718">
                    <scope line="719"/>
                </scope>
            </method>
            <javadoc line="731">
                Get the destination context of a return (the method body)                
            </javadoc>
            <method name="getReturnContext" type="CheckContext" line="735">
                <comment line="737">
                    The METHOD node is set up by Statement.checkMethod().                    
                </comment>
                <scope line="736">
                    <scope line="738"/>
                </scope>
            </method>
            <javadoc line="745">
                Get the context of the innermost surrounding try-block.
                  Consider only try-blocks contained within the same method.
                  (There could be others when searching from within a method
                  of a local class, but they are irrelevant to our purpose.)
                  This is used for recording DA/DU information preceding
                  all abnormal transfers of control: break, continue, return,
                  and throw.                
            </javadoc>
            <method name="getTryExitContext" type="CheckContext" line="755">
                <scope line="758">
                    <scope line="759"/>
                </scope>
            </method>
            <javadoc line="766">
                Get the nearest inlined context                
            </javadoc>
            <method name="getInlineContext" type="Context" line="769">
                <scope line="770">
                    <scope line="771"/>
                </scope>
            </method>
            <javadoc line="782">
                Get the context of a field that is being inlined                
            </javadoc>
            <method name="getInlineMemberContext" type="Context" line="785">
                <params>
                    <param name="field" type="MemberDefinition"/>
                </params>
                <scope line="786">
                    <scope line="787">
                        <scope line="790"/>
                        <scope line="795"/>
                    </scope>
                </scope>
            </method>
            <javadoc line="804">
                Remove variables from the vset set  that are no longer part of
                  this context.                
            </javadoc>
            <method name="removeAdditionalVars" type="Vset" line="808">
                <params>
                    <param name="vset" type="Vset"/>
                </params>
            </method>
            <method name="getVarNumber" type="int" line="812"/>
            <javadoc line="816">
                Return the number of the innermost current instance reference.                
            </javadoc>
            <method name="getThisNumber" type="int" line="819">
                <comment line="825">
                    this is a variable; there is no &quot;this&quot; (should not happen)                    
                </comment>
                <declaration name="thisf" type="LocalMember" line="820"/>
                <scope line="822"/>
            </method>
            <javadoc line="829">
                Return the field containing the present context.                
            </javadoc>
            <method name="getField" type="MemberDefinition" line="832"/>
            <javadoc line="836">
                Extend an environment with the given context.
                  The resulting environment behaves the same as
                  the given one, except that resolveName() takes
                  into account local class names in this context.                
            </javadoc>
            <method name="newEnvironment" type="Environment" line="842">
                <params>
                    <param name="env" type="Environment"/>
                    <param name="ctx" type="Context"/>
                </params>
            </method>
        </class>
        <class name="ContextEnvironment" line="847">
            <extends class="Environment"/>
            <declaration name="ctx" type="Context" line="849"/>
            <declaration name="innerEnv" type="Environment" line="850"/>
            <method name="ContextEnvironment" type="constructor" line="852">
                <params>
                    <param name="env" type="Environment"/>
                    <param name="ctx" type="Context"/>
                </params>
            </method>
            <method name="resolveName" type="Identifier" line="858">
                <params>
                    <param name="name" type="Identifier"/>
                </params>
            </method>
        </class>
    </source>