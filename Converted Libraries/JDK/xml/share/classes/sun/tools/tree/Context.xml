<?xml version="1.0" encoding="UTF-8"?>
    <source package="sun.tools.tree">
        <import package="sun.tools.java"/>
        <import package="sun.tools.asm.Assembler"/>
        <class name="Context" line="31">
            <implements interface="Constants"/>
            <javadoc line="31">
                WARNING: The contents of this source file are not part of any
                  supported API.  Code that depends on them does so at its own risk:
                  they are subject to change or removal without notice.                
            </javadoc>
            <declaration name="prev" type="Context" line="38"/>
            <declaration name="node" type="Node" line="39"/>
            <declaration name="varNumber" type="int" line="40"/>
            <declaration name="locals" type="LocalMember" line="41"/>
            <declaration name="classes" type="LocalMember" line="42"/>
            <declaration name="field" type="MemberDefinition" line="43"/>
            <declaration name="scopeNumber" type="int" line="44"/>
            <declaration name="frameNumber" type="int" line="45"/>
            <javadoc line="47">
                Create the initial context for a method
                  The incoming context is inherited from                
            </javadoc>
            <method name="Context" type="constructor" line="51">
                <params>
                    <param name="ctx" type="Context"/>
                    <param name="field" type="MemberDefinition"/>
                </params>
                <comment line="64">
                    Variables and initializers are inlined into a constructor.
                     Model this by inheriting the frame number of the parent,
                     which will contain a &quot;this&quot; parameter.                    
                </comment>
                <scope line="53"/>
                <scope line="57">
                    <scope line="62"/>
                    <scope line="68"/>
                </scope>
            </method>
            <javadoc line="76">
                Create a new context, for initializing a class.                
            </javadoc>
            <method name="Context" type="constructor" line="79">
                <params>
                    <param name="ctx" type="Context"/>
                    <param name="c" type="ClassDefinition"/>
                </params>
            </method>
            <javadoc line="83">
                Create a new nested context, for a block statement                
            </javadoc>
            <method name="Context" type="constructor" line="86">
                <params>
                    <param name="ctx" type="Context"/>
                    <param name="node" type="Node"/>
                </params>
                <comment line="95">
                    Inherit local classes from surrounding block,
                     just as for local variables.  Fixes 4074421.                    
                </comment>
                <scope line="87"/>
                <scope line="91"/>
            </method>
            <method name="Context" type="constructor" line="105">
                <params>
                    <param name="ctx" type="Context"/>
                </params>
            </method>
            <javadoc line="109">
                Declare local                
            </javadoc>
            <method name="declare" type="int" line="112">
                <params>
                    <param name="env" type="Environment"/>
                    <param name="local" type="LocalMember"/>
                </params>
                <comment line="114">
                    System.out.println(   &quot;DECLARE= &quot; + local.getName() + &quot;=&quot; + varNumber + &quot;, read=&quot; + local.readcount + &quot;, write=&quot; + local.writecount + &quot;, hash=&quot; + local.hashCode());                    
                </comment>
                <comment line="117">
                    Anticipate variable or initializer.                    
                </comment>
                <comment line="125">
                    Originally the statement:
                    
                         local.subModifiers(M_INLINEABLE);
                    
                     was here with the comment:
                    
                          prevent inlining across call sites
                    
                     This statement prevented constant local variables from
                     inlining. It didn&apos;t seem to do anything useful.
                    
                     The statement has been removed and an assertion has been
                     added which mandates that the only members which are marked
                     with M_INLINEABLE are the ones for which isConstant() is true.
                     (Fix for 4106244.)
                    
                     Addition to the above comment: they might also be
                     final variables initialized with &apos;this&apos;, &apos;super&apos;, or other
                     final identifiers.  See VarDeclarationStatement.inline().
                     So I&apos;ve removed the assertion.  The original subModifiers
                     call appears to have been there to fix nested class translation
                     breakage, which has been fixed in VarDeclarationStatement
                     now instead.  (Fix for 4073244.)                    
                </comment>
                <scope line="115"/>
                <scope line="118"/>
            </method>
            <javadoc line="155">
                Get a local variable by name                
            </javadoc>
            <method name="getLocalField" type="LocalMember" line="159">
                <params>
                    <param name="name" type="Identifier"/>
                </params>
                <scope line="160">
                    <scope line="161"/>
                </scope>
            </method>
            <javadoc line="168">
                Get the scope number for a reference to a member of this class
                  (Larger scope numbers are more deeply nested.)                
                <see>
                    LocalMember#scopeNumber                    
                </see>
            </javadoc>
            <method name="getScopeNumber" type="int" line="174">
                <params>
                    <param name="c" type="ClassDefinition"/>
                </params>
                <scope line="175">
                    <scope line="177"/>
                </scope>
            </method>
            <method name="getFieldCommon" type="MemberDefinition" line="186">
                <params>
                    <param name="env" type="Environment"/>
                    <param name="name" type="Identifier"/>
                    <param name="apparentOnly" type="boolean"/>
                </params>
                <comment line="188">
                    Note:  This is structured as a pair of parallel lookups.
                     If we were to redesign Context, we might prefer to walk
                     along a single chain of scopes.                    
                </comment>
                <comment line="197">
                    Also look for a class member in a shallower scope.                    
                </comment>
                <declaration name="lf" type="LocalMember" line="191"/>
                <declaration name="ls" type="int" line="192"/>
                <declaration name="thisClass" type="ClassDefinition" line="194"/>
                <scope line="199">
                    <declaration name="f" type="MemberDefinition" line="200"/>
                    <scope line="201">
                        <scope line="202"/>
                    </scope>
                </scope>
            </method>
            <javadoc line="212">
                Assign a number to a class field.
                  (This is used to track definite assignment of some blank finals.)                
            </javadoc>
            <method name="declareFieldNumber" type="int" line="216">
                <params>
                    <param name="field" type="MemberDefinition"/>
                </params>
            </method>
            <javadoc line="220">
                Retrieve a number previously assigned by declareMember().
                  Return -1 if there was no such assignment in this context.                
            </javadoc>
            <method name="getFieldNumber" type="int" line="224">
                <params>
                    <param name="field" type="MemberDefinition"/>
                </params>
                <scope line="225">
                    <scope line="226"/>
                </scope>
            </method>
            <javadoc line="233">
                Return the local field or member field corresponding to a number.
                  Return null if there is no such field.                
            </javadoc>
            <method name="getElement" type="MemberDefinition" line="237">
                <params>
                    <param name="number" type="int"/>
                </params>
                <scope line="238">
                    <scope line="239">
                        <declaration name="field" type="MemberDefinition" line="240"/>
                    </scope>
                </scope>
            </method>
            <javadoc line="247">
                Get a local class by name                
            </javadoc>
            <method name="getLocalClass" type="LocalMember" line="251">
                <params>
                    <param name="name" type="Identifier"/>
                </params>
                <scope line="252">
                    <scope line="253"/>
                </scope>
            </method>
            <method name="getClassCommon" type="MemberDefinition" line="262">
                <params>
                    <param name="env" type="Environment"/>
                    <param name="name" type="Identifier"/>
                    <param name="apparentOnly" type="boolean"/>
                </params>
                <comment line="267">
                    Also look for a class member in a shallower scope.                    
                </comment>
                <comment line="271">
                    QUERY: We may need to get the inner class from a
                     superclass of &apos;c&apos;.  This call is prepared to
                     resolve the superclass if necessary.  Can we arrange
                     to assure that it is always previously resolved?
                     This is one of a small number of problematic calls that
                     requires &apos;getSuperClass&apos; to resolve superclasses on demand.
                     See &apos;ClassDefinition.getInnerClass(env, nm)&apos;.                    
                </comment>
                <declaration name="lf" type="LocalMember" line="263"/>
                <declaration name="ls" type="int" line="264"/>
                <scope line="269">
                    <declaration name="f" type="MemberDefinition" line="277"/>
                    <scope line="278">
                        <scope line="279"/>
                    </scope>
                </scope>
            </method>
            <javadoc line="289">
                Get either a local variable, or a field in a current class                
            </javadoc>
            <method name="getField" type="MemberDefinition" line="293">
                <params>
                    <param name="env" type="Environment"/>
                    <param name="name" type="Identifier"/>
                </params>
            </method>
            <javadoc line="297">
                Like getField, except that it skips over inherited fields.
                  Used for error checking.                
            </javadoc>
            <method name="getApparentField" type="MemberDefinition" line="302">
                <params>
                    <param name="env" type="Environment"/>
                    <param name="name" type="Identifier"/>
                </params>
            </method>
            <javadoc line="306">
                Check if the given field is active in this context.                
            </javadoc>
            <method name="isInScope" type="boolean" line="309">
                <params>
                    <param name="field" type="LocalMember"/>
                </params>
                <scope line="310">
                    <scope line="311"/>
                </scope>
            </method>
            <javadoc line="318">
                Notice a reference (usually an uplevel one).
                  Update the references list of every enclosing class
                  which is enclosed by the scope of the target.
                  Update decisions about which uplevels to make into fields.
                  Return the uplevel reference descriptor, or null if it&apos;s local.
                  &lt;p&gt;
                  The target must be in scope in this context.
                  So, call this method only from the check phase.
                  (In other phases, the context may be less complete.)
                  &lt;p&gt;
                  This can and should be called both before and after classes are frozen.
                  It should be a no-op, and will raise a compiler error if not.                
            </javadoc>
            <method name="noteReference" type="UplevelReference" line="332">
                <params>
                    <param name="env" type="Environment"/>
                    <param name="target" type="LocalMember"/>
                </params>
                <comment line="336">
                    Walk outward visiting each scope.
                     Note each distinct frame (i.e., enclosing method).
                     For each frame in which the variable is uplevel,
                     record the event in the references list of the enclosing class.                    
                </comment>
                <comment line="344">
                    we&apos;re processing frames, not contexts                    
                </comment>
                <comment line="348">
                    the target is native to this frame                    
                </comment>
                <comment line="351">
                    process a frame which is using this variable as an uplevel                    
                </comment>
                <comment line="356">
                    remember the reference pertaining to the innermost frame                    
                </comment>
                <declaration name="targetScopeNumber" type="int" line="333"/>
                <declaration name="res" type="UplevelReference" line="339"/>
                <declaration name="currentFrameNumber" type="int" line="340"/>
                <scope line="341">
                    <scope line="342"/>
                    <scope line="346"/>
                    <declaration name="refc" type="ClassDefinition" line="351"/>
                    <declaration name="r" type="UplevelReference" line="352"/>
                    <scope line="356"/>
                </scope>
            </method>
            <javadoc line="363">
                Implement a reference (usually an uplevel one).
                  Call noteReference() first, to make sure the reference
                  lists are up to date.
                  &lt;p&gt;
                  The resulting expression tree does not need checking;
                  it can be code-generated right away.
                  If the reference is not uplevel, the result is an IDENT or THIS.                
            </javadoc>
            <method name="makeReference" type="Expression" line="372">
                <params>
                    <param name="env" type="Environment"/>
                    <param name="target" type="LocalMember"/>
                </params>
                <comment line="376">
                    Now create a referencing expression.                    
                </comment>
                <declaration name="r" type="UplevelReference" line="373"/>
                <scope line="376"/>
                <scope line="378"/>
                <scope line="380"/>
            </method>
            <javadoc line="385">
                Return a local expression which can serve as the base reference
                  for the given field.  If the field is a constructor, return an
                  expression for the implicit enclosing instance argument.
                  &lt;p&gt;
                  Return null if there is no need for such an argument,
                  or if there was an error.                
            </javadoc>
            <method name="findOuterLink" type="Expression" line="394">
                <params>
                    <param name="env" type="Environment"/>
                    <param name="where" type="long"/>
                    <param name="f" type="MemberDefinition"/>
                </params>
                <comment line="396">
                    reqc is the base pointer type required to use f                    
                </comment>
                <declaration name="fc" type="ClassDefinition" line="396"/>
                <declaration name="reqc" type="ClassDefinition" line="397"/>
                <scope line="401"/>
            </method>
            <method name="match" type="boolean" line="408">
                <params>
                    <param name="env" type="Environment"/>
                    <param name="thisc" type="ClassDefinition"/>
                    <param name="reqc" type="ClassDefinition"/>
                </params>
                <scope line="409"/>
                <scope line="412"/>
            </method>
            <method name="findOuterLink" type="Expression" line="420">
                <params>
                    <param name="env" type="Environment"/>
                    <param name="where" type="long"/>
                    <param name="reqc" type="ClassDefinition"/>
                    <param name="f" type="MemberDefinition"/>
                    <param name="needExactMatch" type="boolean"/>
                </params>
                <comment line="424">
                    say something like: undefined variable A.this                    
                </comment>
                <comment line="436">
                    This is an attempt at error recovery.
                     Unfortunately, the constructor may throw
                     a null pointer exception after failing to resolve
                     &apos;idThis&apos;.  Since an error message has already been
                     issued previously, this exception is caught and
                     silently ignored.  Ideally, we should avoid throwing
                     the exception.                    
                </comment>
                <comment line="448">
                    use lp to scan for current instances (locals named &quot;this&quot;)                    
                </comment>
                <comment line="451">
                    thise is a link expression being built up                    
                </comment>
                <comment line="454">
                    root is the local variable (idThis) at the far left of thise                    
                </comment>
                <comment line="457">
                    thisc is the class of the link expression thise                    
                </comment>
                <comment line="460">
                    conCls is the class of the &quot;this&quot;, in a constructor                    
                </comment>
                <comment line="473">
                    start fresh from lp                    
                </comment>
                <comment line="486">
                    Require exact class identity when called with
                     &apos;needExactMatch&apos; true.  This is done when checking
                     the &apos;&lt;class&gt;.this&apos; syntax.  Fixes 4102393 and 4133457.                    
                </comment>
                <comment line="494">
                    move out one step, if the current instance has an outer link                    
                </comment>
                <comment line="499">
                    try to find more help in lp                    
                </comment>
                <comment line="505">
                    Must pick up &quot;this$C&quot; from the constructor argument,
                     not from &quot;this.this$C&quot;, since the latter may not be
                     initialized properly.  (This way is cheaper too.)                    
                </comment>
                <comment line="517">
                    mark crossed scopes
                     ?????
                    ensureAvailable(root);                    
                </comment>
                <comment line="524">
                    say something like: undefined variable A.this                    
                </comment>
                <comment line="533">
                    avoid floodgating:                    
                </comment>
                <scope line="421">
                    <scope line="422">
                        <declaration name="nm" type="Identifier" line="424"/>
                    </scope>
                    <scope line="426"/>
                    <scope line="428"/>
                    <scope line="431"/>
                    <declaration name="e" type="Expression" line="442"/>
                </scope>
                <declaration name="lp" type="LocalMember" line="448"/>
                <declaration name="thise" type="Expression" line="451"/>
                <declaration name="root" type="LocalMember" line="454"/>
                <declaration name="thisc" type="ClassDefinition" line="457"/>
                <declaration name="conCls" type="ClassDefinition" line="460"/>
                <scope line="461"/>
                <scope line="465"/>
                <scope line="470">
                    <scope line="471">
                        <scope line="473"/>
                        <scope line="476"/>
                    </scope>
                    <scope line="489"/>
                    <declaration name="outerMember" type="MemberDefinition" line="495"/>
                    <scope line="496"/>
                    <declaration name="prevc" type="ClassDefinition" line="500"/>
                    <scope line="503">
                        <declaration name="nm" type="Identifier" line="507"/>
                        <declaration name="arg" type="IdentifierExpression" line="508"/>
                    </scope>
                    <scope line="511"/>
                </scope>
                <scope line="515"/>
                <scope line="522">
                    <declaration name="nm" type="Identifier" line="524"/>
                </scope>
                <scope line="526"/>
                <scope line="528"/>
                <declaration name="e" type="Expression" line="533"/>
            </method>
            <javadoc line="538">
                Is there a &quot;this&quot; of type reqc in scope?                
            </javadoc>
            <method name="outerLinkExists" type="boolean" line="543">
                <params>
                    <param name="env" type="Environment"/>
                    <param name="reqc" type="ClassDefinition"/>
                    <param name="thisc" type="ClassDefinition"/>
                </params>
                <scope line="544">
                    <scope line="545"/>
                </scope>
            </method>
            <javadoc line="553">
                From which enclosing class do members of this type come?                
            </javadoc>
            <method name="findScope" type="ClassDefinition" line="556">
                <params>
                    <param name="env" type="Environment"/>
                    <param name="reqc" type="ClassDefinition"/>
                </params>
                <declaration name="thisc" type="ClassDefinition" line="557"/>
                <scope line="558"/>
            </method>
            <javadoc line="564">
                Resolve a type name from within a local scope.                
                <see>
                    Environment#resolveName                    
                </see>
            </javadoc>
            <method name="resolveName" type="Identifier" line="568">
                <params>
                    <param name="env" type="Environment"/>
                    <param name="name" type="Identifier"/>
                </params>
                <comment line="570">
                    This logic is pretty much exactly parallel to that of
                     Environment.resolveName().                    
                </comment>
                <comment line="573">
                    Try to resolve the first identifier component,
                     because inner class names take precedence over
                     package prefixes.  (Cf. Environment.resolveName.)                    
                </comment>
                <comment line="579">
                    The first identifier component refers to an
                     ambiguous class.  Limp on.  We throw away the
                     rest of the classname as it is irrelevant.
                     (part of solution for 4059855).                    
                </comment>
                <comment line="593">
                    return partially-resolved name someone else can fail on                    
                </comment>
                <comment line="598">
                    Look for an unqualified name in enclosing scopes.                    
                </comment>
                <comment line="605">
                    a missing superclass, or something catastrophic                    
                </comment>
                <comment line="608">
                    look in imports, etc.                    
                </comment>
                <scope line="571">
                    <declaration name="rhead" type="Identifier" line="575"/>
                    <scope line="577"/>
                    <scope line="585"/>
                    <scope line="588"/>
                    <scope line="591"/>
                </scope>
                <scope line="598">
                    <declaration name="f" type="MemberDefinition" line="599"/>
                    <scope line="600"/>
                </scope>
                <scope line="603"/>
            </method>
            <javadoc line="611">
                Return the name of a lexically apparent type,
                  skipping inherited members, and ignoring
                  the current pacakge and imports.
                  This is used for error checking.                
            </javadoc>
            <method name="getApparentClassName" type="Identifier" line="618">
                <params>
                    <param name="env" type="Environment"/>
                    <param name="name" type="Identifier"/>
                </params>
                <comment line="621">
                    Try to resolve the first identifier component,
                     because inner class names take precedence over
                     package prefixes.  (Cf. Environment.resolveName.)                    
                </comment>
                <comment line="630">
                    Look for an unqualified name in enclosing scopes.                    
                </comment>
                <comment line="637">
                    a missing superclass, or something catastrophic                    
                </comment>
                <comment line="640">
                    the enclosing class name is the only apparent package member:                    
                </comment>
                <scope line="619">
                    <declaration name="rhead" type="Identifier" line="623"/>
                </scope>
                <scope line="630">
                    <declaration name="f" type="MemberDefinition" line="631"/>
                    <scope line="632"/>
                </scope>
                <scope line="635"/>
                <declaration name="topnm" type="Identifier" line="640"/>
                <scope line="641"/>
            </method>
            <javadoc line="647">
                Raise an error if a blank final was definitely unassigned
                  on entry to a loop, but has possibly been assigned on the
                  back-branch.  If this is the case, the loop may be assigning
                  it multiple times.                
            </javadoc>
            <method name="checkBackBranch" type="void" line="654">
                <params>
                    <param name="env" type="Environment"/>
                    <param name="loop" type="Statement"/>
                    <param name="vsEntry" type="Vset"/>
                    <param name="vsBack" type="Vset"/>
                </params>
                <scope line="655">
                    <scope line="658"/>
                </scope>
            </method>
            <javadoc line="665">
                Check if a field can reach another field (only considers
                  forward references, not the access modifiers).                
            </javadoc>
            <method name="canReach" type="boolean" line="669">
                <params>
                    <param name="env" type="Environment"/>
                    <param name="f" type="MemberDefinition"/>
                </params>
            </method>
            <javadoc line="673">
                Get the context that corresponds to a label, return null if
                  not found.                
            </javadoc>
            <method name="getLabelContext" type="Context" line="678">
                <params>
                    <param name="lbl" type="Identifier"/>
                </params>
                <scope line="679">
                    <scope line="680"/>
                </scope>
            </method>
            <javadoc line="688">
                Get the destination context of a break                
            </javadoc>
            <method name="getBreakContext" type="Context" line="692">
                <params>
                    <param name="lbl" type="Identifier"/>
                </params>
                <scope line="693"/>
                <scope line="696">
                    <scope line="697"/>
                </scope>
            </method>
            <javadoc line="710">
                Get the destination context of a continue                
            </javadoc>
            <method name="getContinueContext" type="Context" line="714">
                <params>
                    <param name="lbl" type="Identifier"/>
                </params>
                <scope line="715"/>
                <scope line="718">
                    <scope line="719"/>
                </scope>
            </method>
            <javadoc line="731">
                Get the destination context of a return (the method body)                
            </javadoc>
            <method name="getReturnContext" type="CheckContext" line="735">
                <comment line="738">
                    The METHOD node is set up by Statement.checkMethod().                    
                </comment>
                <scope line="736">
                    <scope line="738"/>
                </scope>
            </method>
            <javadoc line="745">
                Get the context of the innermost surrounding try-block.
                  Consider only try-blocks contained within the same method.
                  (There could be others when searching from within a method
                  of a local class, but they are irrelevant to our purpose.)
                  This is used for recording DA/DU information preceding
                  all abnormal transfers of control: break, continue, return,
                  and throw.                
            </javadoc>
            <method name="getTryExitContext" type="CheckContext" line="755">
                <scope line="758">
                    <scope line="759"/>
                </scope>
            </method>
            <javadoc line="766">
                Get the nearest inlined context                
            </javadoc>
            <method name="getInlineContext" type="Context" line="769">
                <scope line="770">
                    <scope line="771"/>
                </scope>
            </method>
            <javadoc line="782">
                Get the context of a field that is being inlined                
            </javadoc>
            <method name="getInlineMemberContext" type="Context" line="785">
                <params>
                    <param name="field" type="MemberDefinition"/>
                </params>
                <scope line="786">
                    <scope line="787">
                        <scope line="790"/>
                        <scope line="795"/>
                    </scope>
                </scope>
            </method>
            <javadoc line="804">
                Remove variables from the vset set  that are no longer part of
                  this context.                
            </javadoc>
            <method name="removeAdditionalVars" type="Vset" line="808">
                <params>
                    <param name="vset" type="Vset"/>
                </params>
            </method>
            <method name="getVarNumber" type="int" line="812"/>
            <javadoc line="816">
                Return the number of the innermost current instance reference.                
            </javadoc>
            <method name="getThisNumber" type="int" line="819">
                <comment line="826">
                    this is a variable; there is no &quot;this&quot; (should not happen)                    
                </comment>
                <declaration name="thisf" type="LocalMember" line="820"/>
                <scope line="822"/>
            </method>
            <javadoc line="829">
                Return the field containing the present context.                
            </javadoc>
            <method name="getField" type="MemberDefinition" line="832"/>
            <javadoc line="836">
                Extend an environment with the given context.
                  The resulting environment behaves the same as
                  the given one, except that resolveName() takes
                  into account local class names in this context.                
            </javadoc>
            <method name="newEnvironment" type="Environment" line="842">
                <params>
                    <param name="env" type="Environment"/>
                    <param name="ctx" type="Context"/>
                </params>
            </method>
        </class>
        <class name="ContextEnvironment" line="847">
            <extends class="Environment"/>
            <declaration name="ctx" type="Context" line="849"/>
            <declaration name="innerEnv" type="Environment" line="850"/>
            <method name="ContextEnvironment" type="constructor" line="852">
                <params>
                    <param name="env" type="Environment"/>
                    <param name="ctx" type="Context"/>
                </params>
            </method>
            <method name="resolveName" type="Identifier" line="858">
                <params>
                    <param name="name" type="Identifier"/>
                </params>
            </method>
        </class>
    </source>