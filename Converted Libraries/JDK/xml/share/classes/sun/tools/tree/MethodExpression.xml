<?xml version="1.0" encoding="UTF-8"?>
    <source package="sun.tools.tree">
        <import package="sun.tools.java"/>
        <import package="sun.tools.asm.Assembler"/>
        <import package="java.io.PrintStream"/>
        <import package="java.util.Hashtable"/>
        <class name="MethodExpression" line="33">
            <extends class="NaryExpression"/>
            <comment line="42">
                The class in which the called method is defined                
            </comment>
            <comment line="46">
                Set if qualified by &apos;super&apos; or &apos;&lt;class&gt;.super&apos;.                
            </comment>
            <comment line="62">
                This is a hack used only within certain access methods generated by                
            </comment>
            <comment line="63">
                &apos;SourceClass.getAccessMember&apos;.  It allows an &apos;invokespecial&apos; instruction                
            </comment>
            <comment line="64">
                to be forced even though &apos;super&apos; does not appear within the call.                
            </comment>
            <comment line="65">
                Such access methods are needed for access to protected methods when using                
            </comment>
            <comment line="66">
                the qualified &apos;&lt;class&gt;.super.&lt;method&gt;(...)&apos; notation.                
            </comment>
            <comment line="791">
                Grab all instance initializer code from the class definition,
                 and return as one bolus.  Note that we are assuming the
                 the relevant fields have already been checked.
                 (See the pre-pass in SourceClass.checkMembers which ensures this.)                
            </comment>
            <javadoc line="33">
                WARNING: The contents of this source file are not part of any
                  supported API.  Code that depends on them does so at its own risk:
                  they are subject to change or removal without notice.                
            </javadoc>
            <declaration name="id" type="Identifier" line="40"/>
            <declaration name="clazz" type="ClassDefinition" line="41"/>
            <declaration name="field" type="MemberDefinition" line="42"/>
            <declaration name="implementation" type="Expression" line="43"/>
            <declaration name="isSuper" type="boolean" line="45"/>
            <javadoc line="47">
                constructor                
            </javadoc>
            <method name="MethodExpression" type="constructor" line="50">
                <params>
                    <param name="where" type="long"/>
                    <param name="right" type="Expression"/>
                    <param name="id" type="Identifier"/>
                    <param name="args" type="Expression"/>
                </params>
            </method>
            <method name="MethodExpression" type="constructor" line="54">
                <params>
                    <param name="where" type="long"/>
                    <param name="right" type="Expression"/>
                    <param name="field" type="MemberDefinition"/>
                    <param name="args" type="Expression"/>
                </params>
            </method>
            <method name="MethodExpression" type="constructor" line="67">
                <params>
                    <param name="where" type="long"/>
                    <param name="right" type="Expression"/>
                    <param name="field" type="MemberDefinition"/>
                    <param name="args" type="Expression"/>
                    <param name="forceSuper" type="boolean"/>
                </params>
            </method>
            <method name="getImplementation" type="Expression" line="72"/>
            <javadoc line="78">
                Check expression type                
            </javadoc>
            <method name="checkValue" type="Vset" line="81">
                <params>
                    <param name="env" type="Environment"/>
                    <param name="ctx" type="Context"/>
                    <param name="vset" type="Vset"/>
                    <param name="exp" type="Hashtable"/>
                </params>
                <comment line="86">
                    Access method to use if required.                    
                </comment>
                <comment line="91">
                    When calling a constructor, we may need to add an                    
                </comment>
                <comment line="92">
                    additional argument to transmit the outer instance link.                    
                </comment>
                <comment line="99">
                    outer.super(...)                    
                </comment>
                <comment line="103">
                    outer.this(...)                    
                </comment>
                <comment line="109">
                    the same error is handled elsewhere                    
                </comment>
                <comment line="115">
                    The effective accessing class, for access checking.                    
                </comment>
                <comment line="116">
                    This is normally the immediately enclosing class.                    
                </comment>
                <comment line="122">
                    Find the first outer scope that mentions the method.                    
                </comment>
                <comment line="132">
                    this is the scope for error diagnosis                    
                </comment>
                <comment line="135">
                    found the innermost scope in which m occurs                    
                </comment>
                <comment line="138">
                    Maybe an inherited method hides an apparent method.                    
                </comment>
                <comment line="139">
                    Keep looking at enclosing scopes to find out.                    
                </comment>
                <comment line="160">
                    As a consequence of the DA/DU rules in the JLS (draft of                    
                </comment>
                <comment line="161">
                    forthcoming 2e), all variables are both definitely assigned                    
                </comment>
                <comment line="162">
                    and definitely unassigned in unreachable code.  Normally, this                    
                </comment>
                <comment line="163">
                    correctly suppresses DA/DU-related errors in such code.                    
                </comment>
                <comment line="164">
                    The use of the DA status of the &apos;this&apos; variable for the extra                    
                </comment>
                <comment line="165">
                    check below on correct constructor usage, however, does not quite                    
                </comment>
                <comment line="166">
                    fit into this DA/DU scheme.  The current representation of                    
                </comment>
                <comment line="167">
                    Vsets for unreachable dead-ends, does not allow &apos;clearVar&apos;                    
                </comment>
                <comment line="168">
                    to work, as the DA/DU bits (all on) are implicitly represented                    
                </comment>
                <comment line="169">
                    by the fact that the Vset is a dead-end.  The DA/DU status                    
                </comment>
                <comment line="170">
                    of the &apos;this&apos; variable is supposed to be temporarily                    
                </comment>
                <comment line="171">
                    cleared at the beginning of a constructor and during the                    
                </comment>
                <comment line="172">
                    checking of constructor arguments (see below in this method).                    
                </comment>
                <comment line="173">
                    Since &apos;clearVar&apos; has no effect on dead-ends, we may                    
                </comment>
                <comment line="174">
                    find the &apos;this&apos; variable in an erroneously definitely-assigned state.                    
                </comment>
                <comment line="175">
                    As a workaround, we suppress the following error message when                    
                </comment>
                <comment line="176">
                    the Vset is a dead-end, i.e., when we are in unreachable code.                    
                </comment>
                <comment line="177">
                    Unfortunately, the special-case treatment of reachability for                    
                </comment>
                <comment line="178">
                    if-then and if-then-else allows unreachable code in some circumstances,                    
                </comment>
                <comment line="179">
                    thus it is possible that no error message will be emitted at all.                    
                </comment>
                <comment line="180">
                    While this behavior is strictly incorrect (thus we call this a                    
                </comment>
                <comment line="181">
                    workaround), the problematic code is indeed unreachable and will                    
                </comment>
                <comment line="182">
                    not be executed.  In fact, it will be entirely omitted from the                    
                </comment>
                <comment line="183">
                    translated program, and can cause no harm at runtime.  A correct                    
                </comment>
                <comment line="184">
                    solution would require modifying the representation of the DA/DU                    
                </comment>
                <comment line="185">
                    analysis to use finite Vsets only, restricting the universe                    
                </comment>
                <comment line="186">
                    of variables about which assertions are made (even in unreachable                    
                </comment>
                <comment line="187">
                    code) to variables that are actually in scope. Alternatively, the                    
                </comment>
                <comment line="188">
                    Vset extension and the dead-end marker (currently a reserved value                    
                </comment>
                <comment line="189">
                    of the extension) could be represented orthogonally.  In either case,                    
                </comment>
                <comment line="190">
                    &apos;clearVar&apos; could then be made to work on (non-canonical) dead ends.                    
                </comment>
                <comment line="191">
                    See file &apos;Vset.java&apos;.                    
                </comment>
                <comment line="198">
                    supers require this specific kind of checking                    
                </comment>
                <comment line="225">
                    Normally, the effective accessing class is the innermost                    
                </comment>
                <comment line="226">
                    class surrounding the current method call, but, for calls                    
                </comment>
                <comment line="227">
                    of the form &apos;&lt;class&gt;.super.&lt;method&gt;(...)&apos;, it is &lt;class&gt;.                    
                </comment>
                <comment line="228">
                    This allows access to protected members of a superclass                    
                </comment>
                <comment line="229">
                    from within a class nested within one of its subclasses.                    
                </comment>
                <comment line="230">
                    Otherwise, for example, the call below to &apos;matchMethod&apos;                    
                </comment>
                <comment line="231">
                    may fail due to the rules for visibility of inaccessible                    
                </comment>
                <comment line="232">
                    members.  For consistency, we treat qualified &apos;this&apos; in                    
                </comment>
                <comment line="233">
                    the same manner, as error diagnostics will be affected.                    
                </comment>
                <comment line="234">
                    QUERY: Are there subtle unexplored language issues here?                    
                </comment>
                <comment line="247">
                    Fix for 4158650.  When we extend a protected inner                    
                </comment>
                <comment line="248">
                    class in a different package, we may not have access                    
                </comment>
                <comment line="249">
                    to the type of our superclass.  Allow the call to                    
                </comment>
                <comment line="250">
                    the superclass constructor from within our constructor                    
                </comment>
                <comment line="251">
                    Note that this check does not apply to constructor                    
                </comment>
                <comment line="252">
                    calls in new instance expressions -- those are part                    
                </comment>
                <comment line="253">
                    of NewInstanceExpression#check().                    
                </comment>
                <comment line="255">
                    Required by JLS 6.6.1.  Fixes 4143715.                    
                </comment>
                <comment line="256">
                    (See also 4094658.)                    
                </comment>
                <comment line="273">
                    Compose a list of argument types                    
                </comment>
                <comment line="276">
                    &quot;this&quot; is not defined during argument checking                    
                </comment>
                <comment line="287">
                    &quot;this&quot; is defined after the constructor invocation                    
                </comment>
                <comment line="292">
                    Check if there are any type errors in the arguments                    
                </comment>
                <comment line="297">
                    Get the method field, given the argument types                    
                </comment>
                <comment line="332">
                    Make sure that static references are allowed                    
                </comment>
                <comment line="342">
                    Extension of JLS 6.6.2 for qualified &apos;super&apos;.                    
                </comment>
                <comment line="352">
                    In &lt;class&gt;.super.&lt;method&gt;(), we cannot simply evaluate                    
                </comment>
                <comment line="353">
                    &lt;class&gt;.super to an object reference (as we would for                    
                </comment>
                <comment line="354">
                    &lt;class&gt;.super.&lt;field&gt;) and then perform an &apos;invokespecial&apos;.                    
                </comment>
                <comment line="355">
                    An &apos;invokespecial&apos; must be performed from within (a subclass of)                    
                </comment>
                <comment line="356">
                    the class in which the target method is located.                    
                </comment>
                <comment line="360">
                    The private case is handled below.                    
                </comment>
                <comment line="361">
                    Use an access method unless the effective accessing class                    
                </comment>
                <comment line="362">
                    (the class qualifying the &apos;super&apos;) is the same as the                    
                </comment>
                <comment line="363">
                    immediately enclosing class, i.e., the qualification was                    
                </comment>
                <comment line="364">
                    unnecessary.                    
                </comment>
                <comment line="371">
                    Access method for private field if not in the same class.                    
                </comment>
                <comment line="379">
                    Make sure that we are not invoking an abstract method                    
                </comment>
                <comment line="394">
                    Check for recursive constructor                    
                </comment>
                <comment line="399">
                    When a package-private class defines public or protected                    
                </comment>
                <comment line="400">
                    members, those members may sometimes be accessed from                    
                </comment>
                <comment line="401">
                    outside of the package in public subclasses.  In these                    
                </comment>
                <comment line="402">
                    cases, we need to massage the method call to refer to                    
                </comment>
                <comment line="403">
                    to an accessible subclass rather than the package-private                    
                </comment>
                <comment line="404">
                    parent class.  Part of fix for 4135692.                    
                </comment>
                <comment line="406">
                    Find out if the class which contains this method                    
                </comment>
                <comment line="407">
                    call has access to the class which declares the                    
                </comment>
                <comment line="408">
                    public or protected method referent.                    
                </comment>
                <comment line="409">
                    We don&apos;t perform this translation on constructor calls.                    
                </comment>
                <comment line="417">
                    System.out.println(&quot;The access of member &quot; +                    
                </comment>
                <comment line="418">
                    field + &quot; declared in class &quot; +                    
                </comment>
                <comment line="419">
                    declarer +                    
                </comment>
                <comment line="420">
                    &quot; is not allowed by the VM from class  &quot; +                    
                </comment>
                <comment line="421">
                    accessor +                    
                </comment>
                <comment line="422">
                    &quot;.  Replacing with an access of class &quot; +                    
                </comment>
                <comment line="423">
                    clazz);                    
                </comment>
                <comment line="425">
                    We cannot make this access at the VM level.                    
                </comment>
                <comment line="426">
                    Construct a member which will stand for this                    
                </comment>
                <comment line="427">
                    method in clazz and set `field&apos; to refer to it.                    
                </comment>
                <comment line="447">
                    Make sure it is qualified                    
                </comment>
                <comment line="453">
                    Cast arguments                    
                </comment>
                <comment line="467">
                    Argument was added above.                    
                </comment>
                <comment line="468">
                    Maintain the model for hidden outer args in outer.super(...):                    
                </comment>
                <comment line="479">
                    Need dummy argument for access method.                    
                </comment>
                <comment line="480">
                    Dummy argument follows outer instance link.                    
                </comment>
                <comment line="481">
                    Leave &apos;this.args&apos; equal to &apos;newargs&apos; but                    
                </comment>
                <comment line="482">
                    without the outer instance link.                    
                </comment>
                <comment line="485">
                    outer instance                    
                </comment>
                <comment line="486">
                    dummy argument                    
                </comment>
                <comment line="491">
                    Strip outer instance link from &apos;this.args&apos;.                    
                </comment>
                <comment line="492">
                    ASSERT(this.arg.length == nargs-1);                    
                </comment>
                <comment line="498">
                    Is this needed?                    
                </comment>
                <comment line="500">
                    No argument was added.                    
                </comment>
                <comment line="502">
                    Need dummy argument for access method.                    
                </comment>
                <comment line="503">
                    Dummy argument is first, as there is no outer instance link.                    
                </comment>
                <comment line="513">
                    Have ordinary method.                    
                </comment>
                <comment line="514">
                    Argument should have been added only for a constructor.                    
                </comment>
                <comment line="519">
                    System.out.println(&quot;Calling &quot; + field + &quot; via &quot; + implMethod);                    
                </comment>
                <comment line="525">
                    Access method needs an explicit &apos;this&apos; pointer.                    
                </comment>
                <comment line="537">
                    Follow super() by variable initializations                    
                </comment>
                <comment line="548">
                    Throw the declared exceptions.                    
                </comment>
                <comment line="552">
                    Arrays pretend that they have &quot;public Object clone()&quot; that doesn&apos;t
                     throw anything, according to the language spec.                    
                </comment>
                <comment line="556">
                                        
                </comment>
                <comment line="569">
                    Mark all blank finals as definitely assigned following &apos;this(...)&apos;.                    
                </comment>
                <comment line="570">
                    Correctness follows inductively from the requirement that all blank finals                    
                </comment>
                <comment line="571">
                    be definitely assigned at the completion of every constructor.                    
                </comment>
                <comment line="577">
                    Static variables should also be considered defined as well, but this                    
                </comment>
                <comment line="578">
                    is handled in &apos;SourceClass.checkMembers&apos;, and we should not interfere.                    
                </comment>
                <declaration name="c" type="ClassDeclaration" line="82"/>
                <declaration name="isArray" type="boolean" line="83"/>
                <declaration name="staticRef" type="boolean" line="84"/>
                <declaration name="implMethod" type="MemberDefinition" line="87"/>
                <declaration name="ctxClass" type="ClassDefinition" line="89"/>
                <declaration name="args" type="Expression" line="93"/>
                <scope line="94">
                    <declaration name="conCls" type="ClassDefinition" line="95"/>
                    <scope line="96">
                        <declaration name="conOuter" type="Expression" line="97"/>
                        <scope line="98"/>
                        <scope line="102"/>
                    </scope>
                    <scope line="108"/>
                </scope>
                <declaration name="argTypes" type="Type" line="113"/>
                <declaration name="sourceClass" type="ClassDefinition" line="117"/>
                <scope line="119">
                    <scope line="120">
                        <declaration name="cdef" type="ClassDefinition" line="123"/>
                        <declaration name="m" type="MemberDefinition" line="124"/>
                        <scope line="125">
                            <scope line="127"/>
                        </scope>
                        <scope line="131"/>
                        <scope line="134">
                            <scope line="140">
                                <declaration name="cdef2" type="ClassDefinition" line="141"/>
                                <scope line="142">
                                    <declaration name="m2" type="MemberDefinition" line="143"/>
                                    <scope line="144"/>
                                </scope>
                            </scope>
                        </scope>
                    </scope>
                    <scope line="153">
                        <scope line="154">
                            <declaration name="thisN" type="int" line="155"/>
                            <scope line="156"/>
                            <scope line="192"/>
                            <scope line="197"/>
                            <scope line="200"/>
                        </scope>
                        <scope line="203">
                            <scope line="205"/>
                            <scope line="209"/>
                        </scope>
                        <scope line="213"/>
                        <scope line="215"/>
                        <scope line="218">
                            <scope line="219"/>
                        </scope>
                        <scope line="235">
                            <declaration name="id" type="Identifier" line="236"/>
                            <scope line="237"/>
                            <scope line="239"/>
                        </scope>
                        <scope line="243"/>
                        <scope line="254">
                            <scope line="259">
                                <declaration name="cdecl" type="ClassDeclaration" line="260"/>
                                <scope line="262"/>
                                <scope line="265"/>
                            </scope>
                        </scope>
                    </scope>
                    <declaration name="hasErrors" type="boolean" line="274"/>
                    <scope line="277"/>
                    <scope line="281"/>
                    <scope line="288"/>
                    <scope line="293"/>
                    <scope line="300">
                        <scope line="304">
                            <scope line="305">
                                <declaration name="sig" type="String" line="308"/>
                            </scope>
                            <declaration name="sig" type="String" line="313"/>
                            <scope line="315">
                                <scope line="316"/>
                                <scope line="318"/>
                            </scope>
                            <scope line="321"/>
                            <scope line="322"/>
                        </scope>
                    </scope>
                    <scope line="333"/>
                    <scope line="345"/>
                    <scope line="358">
                        <scope line="359">
                            <scope line="365"/>
                        </scope>
                    </scope>
                    <scope line="372">
                        <declaration name="cdef" type="ClassDefinition" line="373"/>
                        <scope line="374"/>
                    </scope>
                    <scope line="380"/>
                    <scope line="385">
                        <scope line="386"/>
                        <scope line="388"/>
                    </scope>
                    <scope line="395"/>
                    <scope line="410">
                        <declaration name="declarer" type="ClassDefinition" line="411"/>
                        <scope line="415"/>
                    </scope>
                    <scope line="434"/>
                </scope>
                <scope line="438"/>
                <scope line="442"/>
                <scope line="448"/>
                <scope line="455"/>
                <scope line="459">
                    <declaration name="m" type="MemberDefinition" line="460"/>
                    <scope line="461"/>
                    <declaration name="nargs" type="int" line="464"/>
                    <declaration name="newargs" type="Expression[]" line="465"/>
                    <scope line="466">
                        <declaration name="rightI" type="Expression" line="469"/>
                        <scope line="470"/>
                        <scope line="473"/>
                        <scope line="475"/>
                        <scope line="478">
                            <scope line="487"/>
                        </scope>
                        <scope line="490">
                            <scope line="493"/>
                        </scope>
                    </scope>
                    <scope line="499">
                        <scope line="501">
                            <scope line="506"/>
                        </scope>
                    </scope>
                </scope>
                <scope line="512">
                    <scope line="515"/>
                    <scope line="518">
                        <declaration name="oldargs" type="Expression" line="520"/>
                        <scope line="521">
                            <declaration name="call" type="Expression" line="522"/>
                        </scope>
                        <scope line="524">
                            <declaration name="nargs" type="int" line="526"/>
                            <declaration name="newargs" type="Expression" line="527"/>
                            <scope line="529"/>
                        </scope>
                    </scope>
                </scope>
                <scope line="539">
                    <declaration name="e" type="Expression" line="540"/>
                    <scope line="541"/>
                </scope>
                <declaration name="exceptions" type="ClassDeclaration" line="549"/>
                <scope line="551">
                    <scope line="557">
                        <scope line="558"/>
                    </scope>
                </scope>
                <scope line="563">
                    <scope line="564"/>
                </scope>
                <scope line="573">
                    <declaration name="cls" type="ClassDefinition" line="574"/>
                    <scope line="575">
                        <scope line="576"/>
                    </scope>
                </scope>
            </method>
            <javadoc line="587">
                Check void expression                
            </javadoc>
            <method name="check" type="Vset" line="590">
                <params>
                    <param name="env" type="Environment"/>
                    <param name="ctx" type="Context"/>
                    <param name="vset" type="Vset"/>
                    <param name="exp" type="Hashtable"/>
                </params>
            </method>
            <javadoc line="594">
                We&apos;re about to report a &quot;unmatched method&quot; error.
                  Try to issue a better diagnostic by comparing the actual argument types
                  with the method (or methods) available.
                  In particular, if there is an argument which fails to match &lt;em&gt;any&lt;/em&gt;
                  method, we report a type mismatch error against that particular argument.
                  The diagnostic will report a target type taken from one of the methods.
                  &lt;p&gt;
                  Return false if we couldn&apos;t think of anything smart to say.                
            </javadoc>
            <method name="diagnoseMismatch" type="boolean" line="605">
                <params>
                    <param name="env" type="Environment"/>
                    <param name="args" type="Expression"/>
                    <param name="argTypes" type="Type"/>
                </params>
                <comment line="622">
                    At least one argument is offensive to all overloadings.                    
                </comment>
                <comment line="623">
                    targetType is one of the argument types it does not match.                    
                </comment>
                <comment line="626">
                    The message might be slightly misleading, if there are other                    
                </comment>
                <comment line="627">
                    argument types that also would match.  Hint at this:                    
                </comment>
                <comment line="628">
                    if (ambig)  ttype = &quot;{&quot;+ttype+&quot;;...}&quot;;                    
                </comment>
                <comment line="635">
                    look for other bad arguments, too                    
                </comment>
                <declaration name="margType" type="Type" line="606"/>
                <declaration name="saidSomething" type="boolean" line="607"/>
                <declaration name="start" type="int" line="608"/>
                <scope line="609">
                    <declaration name="code" type="int" line="610"/>
                    <declaration name="opName" type="String" line="611"/>
                    <scope line="612"/>
                    <declaration name="i" type="int" line="617"/>
                    <declaration name="castOK" type="boolean" line="618"/>
                    <declaration name="ambig" type="boolean" line="619"/>
                    <declaration name="targetType" type="Type" line="620"/>
                    <declaration name="ttype" type="String" line="624"/>
                </scope>
            </method>
            <declaration name="MAXINLINECOST" type="int" line="640"/>
            <javadoc line="640">
                Inline                
            </javadoc>
            <method name="inlineMethod" type="Expression" line="646">
                <params>
                    <param name="env" type="Environment"/>
                    <param name="ctx" type="Context"/>
                    <param name="s" type="Statement"/>
                    <param name="valNeeded" type="boolean"/>
                </params>
                <comment line="665">
                    System.out.print(&quot;BEFORE:&quot;); s.print(System.out); System.out.println();                    
                </comment>
                <comment line="666">
                    Note: If !valNeeded, then all returns in the body of the method                    
                </comment>
                <comment line="667">
                    change to void returns.                    
                </comment>
                <comment line="669">
                    System.out.print(&quot;COPY:&quot;); body[body.length - 1].print(System.out); System.out.println();                    
                </comment>
                <comment line="672">
                    Make sure the type matches what the return statements are returning.                    
                </comment>
                <scope line="647"/>
                <declaration name="v" type="LocalMember" line="650"/>
                <declaration name="body" type="Statement" line="651"/>
                <declaration name="n" type="int" line="653"/>
                <scope line="654"/>
                <scope line="656">
                    <scope line="657"/>
                </scope>
                <scope line="662"/>
                <declaration name="type" type="Type" line="673"/>
                <declaration name="e" type="Expression" line="674"/>
            </method>
            <method name="inline" type="Expression" line="678">
                <params>
                    <param name="env" type="Environment"/>
                    <param name="ctx" type="Context"/>
                </params>
                <comment line="689">
                    ctxClass is the current class trying to inline this method                    
                </comment>
                <comment line="695">
                    Don&apos;t inline if a qualified non-static method: the call                    
                </comment>
                <comment line="696">
                    itself might throw NullPointerException as a side effect                    
                </comment>
                <comment line="699">
                    We only allow the inlining if the current class can access                    
                </comment>
                <comment line="700">
                    the field, the field&apos;s class, and right&apos;s declared type.                    
                </comment>
                <scope line="681">
                    <scope line="682"/>
                    <scope line="685"/>
                    <declaration name="ctxClass" type="ClassDefinition" line="690"/>
                    <declaration name="e" type="Expression" line="692"/>
                    <scope line="709">
                        <declaration name="s" type="Statement" line="710"/>
                        <scope line="712"/>
                    </scope>
                </scope>
                <scope line="718"/>
            </method>
            <method name="inlineValue" type="Expression" line="723">
                <params>
                    <param name="env" type="Environment"/>
                    <param name="ctx" type="Context"/>
                </params>
                <comment line="741">
                    ctxClass is the current class trying to inline this method                    
                </comment>
                <comment line="746">
                    Don&apos;t inline if a qualified non-static method: the call                    
                </comment>
                <comment line="747">
                    itself might throw NullPointerException as a side effect                    
                </comment>
                <comment line="750">
                    We only allow the inlining if the current class can access                    
                </comment>
                <comment line="751">
                    the field, the field&apos;s class, and right&apos;s declared type.                    
                </comment>
                <scope line="726">
                    <scope line="727"/>
                    <scope line="730">
                        <declaration name="refc" type="ClassDefinition" line="731"/>
                        <declaration name="r" type="UplevelReference" line="732"/>
                        <scope line="733"/>
                    </scope>
                    <scope line="737"/>
                    <declaration name="ctxClass" type="ClassDefinition" line="742"/>
                    <scope line="759">
                        <declaration name="s" type="Statement" line="760"/>
                        <scope line="762"/>
                    </scope>
                </scope>
                <scope line="767"/>
            </method>
            <method name="copyInline" type="Expression" line="772">
                <params>
                    <param name="ctx" type="Context"/>
                </params>
            </method>
            <method name="costInline" type="int" line="778">
                <params>
                    <param name="thresh" type="int"/>
                    <param name="env" type="Environment"/>
                    <param name="ctx" type="Context"/>
                </params>
                <comment line="782">
                    for now, don&apos;t allow calls to super() to be inlined.  We may fix                    
                </comment>
                <comment line="783">
                    this later                    
                </comment>
                <scope line="784"/>
            </method>
            <method name="makeVarInits" type="Expression" line="796">
                <params>
                    <param name="env" type="Environment"/>
                    <param name="ctx" type="Context"/>
                </params>
                <comment line="797">
                    insert instance initializers                    
                </comment>
                <comment line="811">
                    it&apos;s too early to accumulate these                    
                </comment>
                <comment line="826">
                    append all initializers to &quot;e&quot;:                    
                </comment>
                <comment line="827">
                    This section used to check for variables which were                    
                </comment>
                <comment line="828">
                    initialized to their default values and elide such                    
                </comment>
                <comment line="829">
                    initialization.  This is specifically disallowed by                    
                </comment>
                <comment line="830">
                    JLS 12.5 numeral 4, which requires a textual ordering                    
                </comment>
                <comment line="831">
                    on the execution of initializers.                    
                </comment>
                <comment line="832">
                    &amp;&amp; !val.equals(0)) {                    
                </comment>
                <declaration name="clazz" type="ClassDefinition" line="798"/>
                <declaration name="e" type="Expression" line="799"/>
                <scope line="800">
                    <scope line="801">
                        <scope line="802"/>
                        <scope line="804"/>
                        <declaration name="val" type="Expression" line="808"/>
                        <scope line="809">
                            <scope line="810"/>
                            <declaration name="arg" type="IdentifierExpression" line="814"/>
                            <scope line="816"/>
                        </scope>
                        <scope line="820">
                            <declaration name="s" type="Statement" line="821"/>
                        </scope>
                        <scope line="823"/>
                        <scope line="832">
                            <declaration name="p" type="long" line="833"/>
                            <declaration name="init" type="Expression" line="835"/>
                            <scope line="836">
                                <declaration name="v" type="Expression" line="837"/>
                            </scope>
                        </scope>
                    </scope>
                </scope>
            </method>
            <javadoc line="848">
                Code                
            </javadoc>
            <method name="codeValue" type="void" line="851">
                <params>
                    <param name="env" type="Environment"/>
                    <param name="ctx" type="Context"/>
                    <param name="asm" type="Assembler"/>
                </params>
                <comment line="854">
                    argument index                    
                </comment>
                <comment line="862">
                    &apos;super.&lt;method&gt;(...)&apos;, &apos;super(...)&apos;, or &apos;&lt;expr&gt;.super(...)&apos;                    
                </comment>
                <comment line="863">
                    isSuper = true;                    
                </comment>
                <comment line="868">
                    &apos;super(...)&apos; or &apos;&lt;expr&gt;.super(...)&apos; only                    
                </comment>
                <comment line="872">
                    When calling a constructor for a class with                    
                </comment>
                <comment line="873">
                    embedded uplevel references, add extra arguments.                    
                </comment>
                <comment line="875">
                    the extra arguments are inserted after this one                    
                </comment>
                <comment line="883">
                    if (right.op == FIELD &amp;&amp;
                    ((FieldExpression)right).id == idSuper) {
                     &apos;&lt;class&gt;.super.&lt;method&gt;(...)&apos;
                    isSuper = true;
                    }                    
                </comment>
                <comment line="907">
                    &apos;super(...)&apos; or &apos;&lt;expr&gt;.super(...)&apos;                    
                </comment>
                <comment line="911">
                    After calling a superclass constructor in a class with                    
                </comment>
                <comment line="912">
                    embedded uplevel references, initialize uplevel fields.                    
                </comment>
                <declaration name="i" type="int" line="854"/>
                <scope line="855">
                    <scope line="856"/>
                </scope>
                <scope line="859"/>
                <scope line="861">
                    <scope line="867">
                        <declaration name="refc" type="ClassDefinition" line="869"/>
                        <declaration name="r" type="UplevelReference" line="870"/>
                        <scope line="871">
                            <scope line="874"/>
                        </scope>
                    </scope>
                </scope>
                <scope line="881"/>
                <scope line="892"/>
                <scope line="896"/>
                <scope line="898"/>
                <scope line="900"/>
                <scope line="902"/>
                <scope line="906">
                    <declaration name="refc" type="ClassDefinition" line="908"/>
                    <declaration name="r" type="UplevelReference" line="909"/>
                    <scope line="910"/>
                </scope>
            </method>
            <javadoc line="918">
                Check if the first thing is a constructor invocation                
            </javadoc>
            <method name="firstConstructor" type="Expression" line="921"/>
            <javadoc line="925">
                Print                
            </javadoc>
            <method name="print" type="void" line="928">
                <params>
                    <param name="out" type="PrintStream"/>
                </params>
                <scope line="930"/>
                <scope line="935">
                    <scope line="937"/>
                    <scope line="939"/>
                </scope>
                <scope line="944"/>
            </method>
        </class>
    </source>