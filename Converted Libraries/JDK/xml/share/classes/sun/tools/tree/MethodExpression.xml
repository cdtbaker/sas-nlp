<?xml version="1.0" encoding="UTF-8"?>
    <source package="sun.tools.tree">
        <import package="sun.tools.java"/>
        <import package="sun.tools.asm.Assembler"/>
        <import package="java.io.PrintStream"/>
        <import package="java.util.Hashtable"/>
        <class name="MethodExpression" line="33">
            <extends class="NaryExpression"/>
            <comment line="42">
                The class in which the called method is defined                
            </comment>
            <comment line="46">
                Set if qualified by &apos;super&apos; or &apos;&lt;class&gt;.super&apos;.                
            </comment>
            <comment line="62">
                This is a hack used only within certain access methods generated by
                 &apos;SourceClass.getAccessMember&apos;.  It allows an &apos;invokespecial&apos; instruction
                 to be forced even though &apos;super&apos; does not appear within the call.
                 Such access methods are needed for access to protected methods when using
                 the qualified &apos;&lt;class&gt;.super.&lt;method&gt;(...)&apos; notation.                
            </comment>
            <comment line="791">
                Grab all instance initializer code from the class definition,
                 and return as one bolus.  Note that we are assuming the
                 the relevant fields have already been checked.
                 (See the pre-pass in SourceClass.checkMembers which ensures this.)                
            </comment>
            <javadoc line="33">
                WARNING: The contents of this source file are not part of any
                  supported API.  Code that depends on them does so at its own risk:
                  they are subject to change or removal without notice.                
            </javadoc>
            <declaration name="id" type="Identifier" line="40"/>
            <declaration name="clazz" type="ClassDefinition" line="41"/>
            <declaration name="field" type="MemberDefinition" line="42"/>
            <declaration name="implementation" type="Expression" line="43"/>
            <declaration name="isSuper" type="boolean" line="45"/>
            <javadoc line="47">
                constructor                
            </javadoc>
            <method name="MethodExpression" type="constructor" line="50">
                <params>
                    <param name="where" type="long"/>
                    <param name="right" type="Expression"/>
                    <param name="id" type="Identifier"/>
                    <param name="args" type="Expression"/>
                </params>
            </method>
            <method name="MethodExpression" type="constructor" line="54">
                <params>
                    <param name="where" type="long"/>
                    <param name="right" type="Expression"/>
                    <param name="field" type="MemberDefinition"/>
                    <param name="args" type="Expression"/>
                </params>
            </method>
            <method name="MethodExpression" type="constructor" line="67">
                <params>
                    <param name="where" type="long"/>
                    <param name="right" type="Expression"/>
                    <param name="field" type="MemberDefinition"/>
                    <param name="args" type="Expression"/>
                    <param name="forceSuper" type="boolean"/>
                </params>
            </method>
            <method name="getImplementation" type="Expression" line="72"/>
            <javadoc line="78">
                Check expression type                
            </javadoc>
            <method name="checkValue" type="Vset" line="81">
                <params>
                    <param name="env" type="Environment"/>
                    <param name="ctx" type="Context"/>
                    <param name="vset" type="Vset"/>
                    <param name="exp" type="Hashtable"/>
                </params>
                <comment line="87">
                    Access method to use if required.                    
                </comment>
                <comment line="92">
                    When calling a constructor, we may need to add an
                     additional argument to transmit the outer instance link.                    
                </comment>
                <comment line="100">
                    outer.super(...)                    
                </comment>
                <comment line="104">
                    outer.this(...)                    
                </comment>
                <comment line="110">
                    the same error is handled elsewhere                    
                </comment>
                <comment line="116">
                    The effective accessing class, for access checking.
                     This is normally the immediately enclosing class.                    
                </comment>
                <comment line="123">
                    Find the first outer scope that mentions the method.                    
                </comment>
                <comment line="133">
                    this is the scope for error diagnosis                    
                </comment>
                <comment line="136">
                    found the innermost scope in which m occurs                    
                </comment>
                <comment line="139">
                    Maybe an inherited method hides an apparent method.
                     Keep looking at enclosing scopes to find out.                    
                </comment>
                <comment line="161">
                    As a consequence of the DA/DU rules in the JLS (draft of
                     forthcoming 2e), all variables are both definitely assigned
                     and definitely unassigned in unreachable code.  Normally, this
                     correctly suppresses DA/DU-related errors in such code.
                     The use of the DA status of the &apos;this&apos; variable for the extra
                     check below on correct constructor usage, however, does not quite
                     fit into this DA/DU scheme.  The current representation of
                     Vsets for unreachable dead-ends, does not allow &apos;clearVar&apos;
                     to work, as the DA/DU bits (all on) are implicitly represented
                     by the fact that the Vset is a dead-end.  The DA/DU status
                     of the &apos;this&apos; variable is supposed to be temporarily
                     cleared at the beginning of a constructor and during the
                     checking of constructor arguments (see below in this method).
                     Since &apos;clearVar&apos; has no effect on dead-ends, we may
                     find the &apos;this&apos; variable in an erroneously definitely-assigned state.
                     As a workaround, we suppress the following error message when
                     the Vset is a dead-end, i.e., when we are in unreachable code.
                     Unfortunately, the special-case treatment of reachability for
                     if-then and if-then-else allows unreachable code in some circumstances,
                     thus it is possible that no error message will be emitted at all.
                     While this behavior is strictly incorrect (thus we call this a
                     workaround), the problematic code is indeed unreachable and will
                     not be executed.  In fact, it will be entirely omitted from the
                     translated program, and can cause no harm at runtime.  A correct
                     solution would require modifying the representation of the DA/DU
                     analysis to use finite Vsets only, restricting the universe
                     of variables about which assertions are made (even in unreachable
                     code) to variables that are actually in scope. Alternatively, the
                     Vset extension and the dead-end marker (currently a reserved value
                     of the extension) could be represented orthogonally.  In either case,
                     &apos;clearVar&apos; could then be made to work on (non-canonical) dead ends.
                     See file &apos;Vset.java&apos;.                    
                </comment>
                <comment line="199">
                    supers require this specific kind of checking                    
                </comment>
                <comment line="226">
                    Normally, the effective accessing class is the innermost
                     class surrounding the current method call, but, for calls
                     of the form &apos;&lt;class&gt;.super.&lt;method&gt;(...)&apos;, it is &lt;class&gt;.
                     This allows access to protected members of a superclass
                     from within a class nested within one of its subclasses.
                     Otherwise, for example, the call below to &apos;matchMethod&apos;
                     may fail due to the rules for visibility of inaccessible
                     members.  For consistency, we treat qualified &apos;this&apos; in
                     the same manner, as error diagnostics will be affected.
                     QUERY: Are there subtle unexplored language issues here?                    
                </comment>
                <comment line="248">
                    Fix for 4158650.  When we extend a protected inner
                     class in a different package, we may not have access
                     to the type of our superclass.  Allow the call to
                     the superclass constructor from within our constructor
                     Note that this check does not apply to constructor
                     calls in new instance expressions -- those are part
                     of NewInstanceExpression#check().                    
                </comment>
                <comment line="256">
                    Required by JLS 6.6.1.  Fixes 4143715.
                     (See also 4094658.)                    
                </comment>
                <comment line="274">
                    Compose a list of argument types                    
                </comment>
                <comment line="277">
                    &quot;this&quot; is not defined during argument checking                    
                </comment>
                <comment line="288">
                    &quot;this&quot; is defined after the constructor invocation                    
                </comment>
                <comment line="293">
                    Check if there are any type errors in the arguments                    
                </comment>
                <comment line="298">
                    Get the method field, given the argument types                    
                </comment>
                <comment line="333">
                    Make sure that static references are allowed                    
                </comment>
                <comment line="343">
                    Extension of JLS 6.6.2 for qualified &apos;super&apos;.                    
                </comment>
                <comment line="353">
                    In &lt;class&gt;.super.&lt;method&gt;(), we cannot simply evaluate
                     &lt;class&gt;.super to an object reference (as we would for
                     &lt;class&gt;.super.&lt;field&gt;) and then perform an &apos;invokespecial&apos;.
                     An &apos;invokespecial&apos; must be performed from within (a subclass of)
                     the class in which the target method is located.                    
                </comment>
                <comment line="361">
                    The private case is handled below.
                     Use an access method unless the effective accessing class
                     (the class qualifying the &apos;super&apos;) is the same as the
                     immediately enclosing class, i.e., the qualification was
                     unnecessary.                    
                </comment>
                <comment line="372">
                    Access method for private field if not in the same class.                    
                </comment>
                <comment line="380">
                    Make sure that we are not invoking an abstract method                    
                </comment>
                <comment line="395">
                    Check for recursive constructor                    
                </comment>
                <comment line="400">
                    When a package-private class defines public or protected
                     members, those members may sometimes be accessed from
                     outside of the package in public subclasses.  In these
                     cases, we need to massage the method call to refer to
                     to an accessible subclass rather than the package-private
                     parent class.  Part of fix for 4135692.                    
                </comment>
                <comment line="407">
                    Find out if the class which contains this method
                     call has access to the class which declares the
                     public or protected method referent.
                     We don&apos;t perform this translation on constructor calls.                    
                </comment>
                <comment line="418">
                    System.out.println(&quot;The access of member &quot; +
                                 field + &quot; declared in class &quot; +
                                 declarer +
                                 &quot; is not allowed by the VM from class  &quot; +
                                 accessor +
                                 &quot;.  Replacing with an access of class &quot; +
                                 clazz);                    
                </comment>
                <comment line="426">
                    We cannot make this access at the VM level.
                     Construct a member which will stand for this
                     method in clazz and set `field&apos; to refer to it.                    
                </comment>
                <comment line="448">
                    Make sure it is qualified                    
                </comment>
                <comment line="454">
                    Cast arguments                    
                </comment>
                <comment line="468">
                    Argument was added above.
                     Maintain the model for hidden outer args in outer.super(...):                    
                </comment>
                <comment line="480">
                    Need dummy argument for access method.
                     Dummy argument follows outer instance link.
                     Leave &apos;this.args&apos; equal to &apos;newargs&apos; but
                     without the outer instance link.                    
                </comment>
                <comment line="486">
                    outer instance                    
                </comment>
                <comment line="487">
                    dummy argument                    
                </comment>
                <comment line="492">
                    Strip outer instance link from &apos;this.args&apos;.
                     ASSERT(this.arg.length == nargs-1);                    
                </comment>
                <comment line="499">
                    Is this needed?                    
                </comment>
                <comment line="501">
                    No argument was added.                    
                </comment>
                <comment line="503">
                    Need dummy argument for access method.
                     Dummy argument is first, as there is no outer instance link.                    
                </comment>
                <comment line="514">
                    Have ordinary method.
                     Argument should have been added only for a constructor.                    
                </comment>
                <comment line="520">
                    System.out.println(&quot;Calling &quot; + field + &quot; via &quot; + implMethod);                    
                </comment>
                <comment line="526">
                    Access method needs an explicit &apos;this&apos; pointer.                    
                </comment>
                <comment line="538">
                    Follow super() by variable initializations                    
                </comment>
                <comment line="549">
                    Throw the declared exceptions.                    
                </comment>
                <comment line="553">
                    Arrays pretend that they have &quot;public Object clone()&quot; that doesn&apos;t
                     throw anything, according to the language spec.                    
                </comment>
                <comment line="557">
                                        
                </comment>
                <comment line="570">
                    Mark all blank finals as definitely assigned following &apos;this(...)&apos;.
                     Correctness follows inductively from the requirement that all blank finals
                     be definitely assigned at the completion of every constructor.                    
                </comment>
                <comment line="578">
                    Static variables should also be considered defined as well, but this
                     is handled in &apos;SourceClass.checkMembers&apos;, and we should not interfere.                    
                </comment>
                <declaration name="c" type="ClassDeclaration" line="82"/>
                <declaration name="isArray" type="boolean" line="83"/>
                <declaration name="staticRef" type="boolean" line="84"/>
                <declaration name="implMethod" type="MemberDefinition" line="87"/>
                <declaration name="ctxClass" type="ClassDefinition" line="89"/>
                <declaration name="args" type="Expression" line="93"/>
                <scope line="94">
                    <declaration name="conCls" type="ClassDefinition" line="95"/>
                    <scope line="96">
                        <declaration name="conOuter" type="Expression" line="97"/>
                        <scope line="98"/>
                        <scope line="102"/>
                    </scope>
                    <scope line="108"/>
                </scope>
                <declaration name="argTypes" type="Type" line="113"/>
                <declaration name="sourceClass" type="ClassDefinition" line="117"/>
                <scope line="119">
                    <scope line="120">
                        <declaration name="cdef" type="ClassDefinition" line="123"/>
                        <declaration name="m" type="MemberDefinition" line="124"/>
                        <scope line="125">
                            <scope line="127"/>
                        </scope>
                        <scope line="131"/>
                        <scope line="134">
                            <scope line="140">
                                <declaration name="cdef2" type="ClassDefinition" line="141"/>
                                <scope line="142">
                                    <declaration name="m2" type="MemberDefinition" line="143"/>
                                    <scope line="144"/>
                                </scope>
                            </scope>
                        </scope>
                    </scope>
                    <scope line="153">
                        <scope line="154">
                            <declaration name="thisN" type="int" line="155"/>
                            <scope line="156"/>
                            <scope line="192"/>
                            <scope line="197"/>
                            <scope line="200"/>
                        </scope>
                        <scope line="203">
                            <scope line="205"/>
                            <scope line="209"/>
                        </scope>
                        <scope line="213"/>
                        <scope line="215"/>
                        <scope line="218">
                            <scope line="219"/>
                        </scope>
                        <scope line="235">
                            <declaration name="id" type="Identifier" line="236"/>
                            <scope line="237"/>
                            <scope line="239"/>
                        </scope>
                        <scope line="243"/>
                        <scope line="254">
                            <scope line="259">
                                <declaration name="cdecl" type="ClassDeclaration" line="260"/>
                                <scope line="262"/>
                                <scope line="265"/>
                            </scope>
                        </scope>
                    </scope>
                    <declaration name="hasErrors" type="boolean" line="274"/>
                    <scope line="277"/>
                    <scope line="281"/>
                    <scope line="288"/>
                    <scope line="293"/>
                    <scope line="300">
                        <scope line="304">
                            <scope line="305">
                                <declaration name="sig" type="String" line="308"/>
                            </scope>
                            <declaration name="sig" type="String" line="313"/>
                            <scope line="315">
                                <scope line="316"/>
                                <scope line="318"/>
                            </scope>
                            <scope line="321"/>
                            <scope line="322"/>
                        </scope>
                    </scope>
                    <scope line="333"/>
                    <scope line="345"/>
                    <scope line="358">
                        <scope line="359">
                            <scope line="365"/>
                        </scope>
                    </scope>
                    <scope line="372">
                        <declaration name="cdef" type="ClassDefinition" line="373"/>
                        <scope line="374"/>
                    </scope>
                    <scope line="380"/>
                    <scope line="385">
                        <scope line="386"/>
                        <scope line="388"/>
                    </scope>
                    <scope line="395"/>
                    <scope line="410">
                        <declaration name="declarer" type="ClassDefinition" line="411"/>
                        <scope line="415"/>
                    </scope>
                    <scope line="434"/>
                </scope>
                <scope line="438"/>
                <scope line="442"/>
                <scope line="448"/>
                <scope line="455"/>
                <scope line="459">
                    <declaration name="m" type="MemberDefinition" line="460"/>
                    <scope line="461"/>
                    <declaration name="nargs" type="int" line="464"/>
                    <declaration name="newargs" type="Expression[]" line="465"/>
                    <scope line="466">
                        <declaration name="rightI" type="Expression" line="469"/>
                        <scope line="470"/>
                        <scope line="473"/>
                        <scope line="475"/>
                        <scope line="478">
                            <scope line="487"/>
                        </scope>
                        <scope line="490">
                            <scope line="493"/>
                        </scope>
                    </scope>
                    <scope line="499">
                        <scope line="501">
                            <scope line="506"/>
                        </scope>
                    </scope>
                </scope>
                <scope line="512">
                    <scope line="515"/>
                    <scope line="518">
                        <declaration name="oldargs" type="Expression" line="520"/>
                        <scope line="521">
                            <declaration name="call" type="Expression" line="522"/>
                        </scope>
                        <scope line="524">
                            <declaration name="nargs" type="int" line="526"/>
                            <declaration name="newargs" type="Expression" line="527"/>
                            <scope line="529"/>
                        </scope>
                    </scope>
                </scope>
                <scope line="539">
                    <declaration name="e" type="Expression" line="540"/>
                    <scope line="541"/>
                </scope>
                <declaration name="exceptions" type="ClassDeclaration" line="549"/>
                <scope line="551">
                    <scope line="557">
                        <scope line="558"/>
                    </scope>
                </scope>
                <scope line="563">
                    <scope line="564"/>
                </scope>
                <scope line="573">
                    <declaration name="cls" type="ClassDefinition" line="574"/>
                    <scope line="575">
                        <scope line="576"/>
                    </scope>
                </scope>
            </method>
            <javadoc line="587">
                Check void expression                
            </javadoc>
            <method name="check" type="Vset" line="590">
                <params>
                    <param name="env" type="Environment"/>
                    <param name="ctx" type="Context"/>
                    <param name="vset" type="Vset"/>
                    <param name="exp" type="Hashtable"/>
                </params>
            </method>
            <javadoc line="594">
                We&apos;re about to report a &quot;unmatched method&quot; error.
                  Try to issue a better diagnostic by comparing the actual argument types
                  with the method (or methods) available.
                  In particular, if there is an argument which fails to match &lt;em&gt;any&lt;/em&gt;
                  method, we report a type mismatch error against that particular argument.
                  The diagnostic will report a target type taken from one of the methods.
                  &lt;p&gt;
                  Return false if we couldn&apos;t think of anything smart to say.                
            </javadoc>
            <method name="diagnoseMismatch" type="boolean" line="605">
                <params>
                    <param name="env" type="Environment"/>
                    <param name="args" type="Expression"/>
                    <param name="argTypes" type="Type"/>
                </params>
                <comment line="623">
                    At least one argument is offensive to all overloadings.
                     targetType is one of the argument types it does not match.                    
                </comment>
                <comment line="627">
                    The message might be slightly misleading, if there are other
                     argument types that also would match.  Hint at this:
                    if (ambig)  ttype = &quot;{&quot;+ttype+&quot;;...}&quot;;                    
                </comment>
                <comment line="636">
                    look for other bad arguments, too                    
                </comment>
                <declaration name="margType" type="Type" line="606"/>
                <declaration name="saidSomething" type="boolean" line="607"/>
                <declaration name="start" type="int" line="608"/>
                <scope line="609">
                    <declaration name="code" type="int" line="610"/>
                    <declaration name="opName" type="String" line="611"/>
                    <scope line="612"/>
                    <declaration name="i" type="int" line="617"/>
                    <declaration name="castOK" type="boolean" line="618"/>
                    <declaration name="ambig" type="boolean" line="619"/>
                    <declaration name="targetType" type="Type" line="620"/>
                    <declaration name="ttype" type="String" line="624"/>
                </scope>
            </method>
            <declaration name="MAXINLINECOST" type="int" line="640"/>
            <javadoc line="640">
                Inline                
            </javadoc>
            <method name="inlineMethod" type="Expression" line="646">
                <params>
                    <param name="env" type="Environment"/>
                    <param name="ctx" type="Context"/>
                    <param name="s" type="Statement"/>
                    <param name="valNeeded" type="boolean"/>
                </params>
                <comment line="666">
                    System.out.print(&quot;BEFORE:&quot;); s.print(System.out); System.out.println();
                     Note: If !valNeeded, then all returns in the body of the method
                     change to void returns.                    
                </comment>
                <comment line="670">
                    System.out.print(&quot;COPY:&quot;); body[body.length - 1].print(System.out); System.out.println();                    
                </comment>
                <comment line="673">
                    Make sure the type matches what the return statements are returning.                    
                </comment>
                <scope line="647"/>
                <declaration name="v" type="LocalMember" line="650"/>
                <declaration name="body" type="Statement" line="651"/>
                <declaration name="n" type="int" line="653"/>
                <scope line="654"/>
                <scope line="656">
                    <scope line="657"/>
                </scope>
                <scope line="662"/>
                <declaration name="type" type="Type" line="673"/>
                <declaration name="e" type="Expression" line="674"/>
            </method>
            <method name="inline" type="Expression" line="678">
                <params>
                    <param name="env" type="Environment"/>
                    <param name="ctx" type="Context"/>
                </params>
                <comment line="690">
                    ctxClass is the current class trying to inline this method                    
                </comment>
                <comment line="696">
                    Don&apos;t inline if a qualified non-static method: the call
                     itself might throw NullPointerException as a side effect                    
                </comment>
                <comment line="700">
                    We only allow the inlining if the current class can access
                     the field, the field&apos;s class, and right&apos;s declared type.                    
                </comment>
                <scope line="681">
                    <scope line="682"/>
                    <scope line="685"/>
                    <declaration name="ctxClass" type="ClassDefinition" line="690"/>
                    <declaration name="e" type="Expression" line="692"/>
                    <scope line="709">
                        <declaration name="s" type="Statement" line="710"/>
                        <scope line="712"/>
                    </scope>
                </scope>
                <scope line="718"/>
            </method>
            <method name="inlineValue" type="Expression" line="723">
                <params>
                    <param name="env" type="Environment"/>
                    <param name="ctx" type="Context"/>
                </params>
                <comment line="742">
                    ctxClass is the current class trying to inline this method                    
                </comment>
                <comment line="747">
                    Don&apos;t inline if a qualified non-static method: the call
                     itself might throw NullPointerException as a side effect                    
                </comment>
                <comment line="751">
                    We only allow the inlining if the current class can access
                     the field, the field&apos;s class, and right&apos;s declared type.                    
                </comment>
                <scope line="726">
                    <scope line="727"/>
                    <scope line="730">
                        <declaration name="refc" type="ClassDefinition" line="731"/>
                        <declaration name="r" type="UplevelReference" line="732"/>
                        <scope line="733"/>
                    </scope>
                    <scope line="737"/>
                    <declaration name="ctxClass" type="ClassDefinition" line="742"/>
                    <scope line="759">
                        <declaration name="s" type="Statement" line="760"/>
                        <scope line="762"/>
                    </scope>
                </scope>
                <scope line="767"/>
            </method>
            <method name="copyInline" type="Expression" line="772">
                <params>
                    <param name="ctx" type="Context"/>
                </params>
            </method>
            <method name="costInline" type="int" line="778">
                <params>
                    <param name="thresh" type="int"/>
                    <param name="env" type="Environment"/>
                    <param name="ctx" type="Context"/>
                </params>
                <comment line="783">
                    for now, don&apos;t allow calls to super() to be inlined.  We may fix
                     this later                    
                </comment>
                <scope line="784"/>
            </method>
            <method name="makeVarInits" type="Expression" line="796">
                <params>
                    <param name="env" type="Environment"/>
                    <param name="ctx" type="Context"/>
                </params>
                <comment line="798">
                    insert instance initializers                    
                </comment>
                <comment line="812">
                    it&apos;s too early to accumulate these                    
                </comment>
                <comment line="827">
                    append all initializers to &quot;e&quot;:
                     This section used to check for variables which were
                     initialized to their default values and elide such
                     initialization.  This is specifically disallowed by
                     JLS 12.5 numeral 4, which requires a textual ordering
                     on the execution of initializers.                    
                </comment>
                <comment line="833">
                    &amp;&amp; !val.equals(0)) {                    
                </comment>
                <declaration name="clazz" type="ClassDefinition" line="798"/>
                <declaration name="e" type="Expression" line="799"/>
                <scope line="800">
                    <scope line="801">
                        <scope line="802"/>
                        <scope line="804"/>
                        <declaration name="val" type="Expression" line="808"/>
                        <scope line="809">
                            <scope line="810"/>
                            <declaration name="arg" type="IdentifierExpression" line="814"/>
                            <scope line="816"/>
                        </scope>
                        <scope line="820">
                            <declaration name="s" type="Statement" line="821"/>
                        </scope>
                        <scope line="823"/>
                        <scope line="832">
                            <declaration name="p" type="long" line="833"/>
                            <declaration name="init" type="Expression" line="835"/>
                            <scope line="836">
                                <declaration name="v" type="Expression" line="837"/>
                            </scope>
                        </scope>
                    </scope>
                </scope>
            </method>
            <javadoc line="848">
                Code                
            </javadoc>
            <method name="codeValue" type="void" line="851">
                <params>
                    <param name="env" type="Environment"/>
                    <param name="ctx" type="Context"/>
                    <param name="asm" type="Assembler"/>
                </params>
                <comment line="855">
                    argument index                    
                </comment>
                <comment line="863">
                    &apos;super.&lt;method&gt;(...)&apos;, &apos;super(...)&apos;, or &apos;&lt;expr&gt;.super(...)&apos;                    
                </comment>
                <comment line="864">
                    isSuper = true;                    
                </comment>
                <comment line="869">
                    &apos;super(...)&apos; or &apos;&lt;expr&gt;.super(...)&apos; only                    
                </comment>
                <comment line="873">
                    When calling a constructor for a class with
                     embedded uplevel references, add extra arguments.                    
                </comment>
                <comment line="876">
                    the extra arguments are inserted after this one                    
                </comment>
                <comment line="884">
                    if (right.op == FIELD &amp;&amp;
                    ((FieldExpression)right).id == idSuper) {
                     &apos;&lt;class&gt;.super.&lt;method&gt;(...)&apos;
                    isSuper = true;
                    }                    
                </comment>
                <comment line="908">
                    &apos;super(...)&apos; or &apos;&lt;expr&gt;.super(...)&apos;                    
                </comment>
                <comment line="912">
                    After calling a superclass constructor in a class with
                     embedded uplevel references, initialize uplevel fields.                    
                </comment>
                <declaration name="i" type="int" line="854"/>
                <scope line="855">
                    <scope line="856"/>
                </scope>
                <scope line="859"/>
                <scope line="861">
                    <scope line="867">
                        <declaration name="refc" type="ClassDefinition" line="869"/>
                        <declaration name="r" type="UplevelReference" line="870"/>
                        <scope line="871">
                            <scope line="874"/>
                        </scope>
                    </scope>
                </scope>
                <scope line="881"/>
                <scope line="892"/>
                <scope line="896"/>
                <scope line="898"/>
                <scope line="900"/>
                <scope line="902"/>
                <scope line="906">
                    <declaration name="refc" type="ClassDefinition" line="908"/>
                    <declaration name="r" type="UplevelReference" line="909"/>
                    <scope line="910"/>
                </scope>
            </method>
            <javadoc line="918">
                Check if the first thing is a constructor invocation                
            </javadoc>
            <method name="firstConstructor" type="Expression" line="921"/>
            <javadoc line="925">
                Print                
            </javadoc>
            <method name="print" type="void" line="928">
                <params>
                    <param name="out" type="PrintStream"/>
                </params>
                <scope line="930"/>
                <scope line="935">
                    <scope line="937"/>
                    <scope line="939"/>
                </scope>
                <scope line="944"/>
            </method>
        </class>
    </source>