<?xml version="1.0" encoding="UTF-8"?>
    <source package="sun.tools.tree">
        <import package="sun.tools.java"/>
        <import package="sun.tools.asm.Assembler"/>
        <import package="java.util.Hashtable"/>
        <class name="NewInstanceExpression" line="32">
            <extends class="NaryExpression"/>
            <comment line="44">
                Access method for constructor, if needed.                
            </comment>
            <javadoc line="32">
                WARNING: The contents of this source file are not part of any
                  supported API.  Code that depends on them does so at its own risk:
                  they are subject to change or removal without notice.                
            </javadoc>
            <declaration name="field" type="MemberDefinition" line="39"/>
            <declaration name="outerArg" type="Expression" line="40"/>
            <declaration name="body" type="ClassDefinition" line="41"/>
            <declaration name="implMethod" type="MemberDefinition" line="44"/>
            <javadoc line="46">
                Constructor                
            </javadoc>
            <method name="NewInstanceExpression" type="constructor" line="49">
                <params>
                    <param name="where" type="long"/>
                    <param name="right" type="Expression"/>
                    <param name="args" type="Expression"/>
                </params>
            </method>
            <method name="NewInstanceExpression" type="constructor" line="54">
                <params>
                    <param name="where" type="long"/>
                    <param name="right" type="Expression"/>
                    <param name="args" type="Expression"/>
                    <param name="outerArg" type="Expression"/>
                    <param name="body" type="ClassDefinition"/>
                </params>
            </method>
            <javadoc line="60">
                From the &quot;new&quot; in an expression of the form outer.new InnerCls(...),
                  return the &quot;outer&quot; expression, or null if there is none.                
            </javadoc>
            <method name="getOuterArg" type="Expression" line="64"/>
            <method name="precedence" type="int" line="68"/>
            <method name="order" type="Expression" line="72">
                <comment line="74">
                    act like a method or field reference expression:                    
                </comment>
                <scope line="74">
                    <declaration name="e" type="UnaryExpression" line="75"/>
                </scope>
            </method>
            <javadoc line="83">
                Check expression type                
            </javadoc>
            <method name="checkValue" type="Vset" line="86">
                <params>
                    <param name="env" type="Environment"/>
                    <param name="ctx" type="Context"/>
                    <param name="vset" type="Vset"/>
                    <param name="exp" type="Hashtable"/>
                </params>
                <comment line="88">
                    What type?                    
                </comment>
                <comment line="97">
                    Remember the expression that we already checked
                     so that we don&apos;t attempt to check it again when
                     it appears as an argument to the constructor.
                     Fix for 4030426.                    
                </comment>
                <comment line="103">
                    Check outerArg and the type name together.                    
                </comment>
                <comment line="106">
                    According to the inner classes spec, the type name in a
                     qualified &apos;new&apos; expression must be a single identifier.                    
                </comment>
                <comment line="119">
                    Don&apos;t perform checks on components of qualified name
                     (&apos;getQualifiedClassDefinition&apos;), because a qualified
                     name is illegal in this context, and will have previously
                     been reported as an error.                    
                </comment>
                <comment line="126">
                    Check access directly, since we&apos;re not calling toType().                    
                </comment>
                <comment line="129">
                    and fall through to env.getClassDefinition() below                    
                </comment>
                <comment line="134">
                    The call to &apos;toType&apos; should perform component access checks.                    
                </comment>
                <comment line="156">
                    If we failed to find a class or a class was ambiguous, def
                     may be null.  Bail out.  This allows us to report multiple
                     unfound or ambiguous classes rather than tripping over an
                     internal compiler error.                    
                </comment>
                <comment line="165">
                    Add an extra argument, maybe.                    
                </comment>
                <comment line="170">
                    recopy the checked arg                    
                </comment>
                <comment line="172">
                    else set it to void (maybe it has a side-effect)                    
                </comment>
                <comment line="175">
                    Compose a list of argument types                    
                </comment>
                <comment line="179">
                    Don&apos;t check &apos;outerArg&apos; again. Fix for 4030426.                    
                </comment>
                <comment line="188">
                    Check if there are any type errors in the arguments                    
                </comment>
                <comment line="195">
                    Get the source class that this declaration appears in.                    
                </comment>
                <comment line="200">
                    If this is an anonymous class, handle it specially now.                    
                </comment>
                <comment line="202">
                    The current package.                    
                </comment>
                <comment line="205">
                    This is an anonymous class.                    
                </comment>
                <comment line="208">
                    For interfaces, our superclass is java.lang.Object.
                     We could just assume that java.lang.Object has
                     one constructor with no arguments in the code
                     that follows, but we don&apos;t.  This way, if Object
                     grows a new constructor (unlikely) then the
                     compiler should handle it.                    
                </comment>
                <comment line="216">
                    Otherwise, def is actually our superclass.                    
                </comment>
                <comment line="219">
                    Try to find a matching constructor in our superclass.                    
                </comment>
                <comment line="223">
                    We&apos;ve found one.  Process the body.
                    
                     Note that we are passing in the constructors&apos; argument
                     types, rather than the argument types of the actual
                     expressions, to checkLocalClass().  Previously,
                     the expression types were passed in.  This could
                     lead to trouble when one of the argument types was
                     the special internal type tNull.  (bug 4054689).                    
                </comment>
                <comment line="240">
                    Set t to be the true type of this expression.
                     (bug 4102056).                    
                </comment>
                <comment line="247">
                    Check if it is an interface                    
                </comment>
                <comment line="253">
                    Check for abstract class                    
                </comment>
                <comment line="260">
                    Get the constructor that the &quot;new&quot; expression should call.                    
                </comment>
                <comment line="263">
                    Report an error if there is no matching constructor.                    
                </comment>
                <comment line="279">
                    Use access method.                    
                </comment>
                <comment line="284">
                    Check for abstract anonymous class                    
                </comment>
                <comment line="295">
                    According to JLS 6.6.2, a protected constructor may be accessed
                     by a class instance creation expression only from within the
                     package in which it is defined.                    
                </comment>
                <comment line="314">
                    Cast arguments                    
                </comment>
                <comment line="320">
                    recopy the checked arg                    
                </comment>
                <comment line="321">
                    maintain an accurate tree                    
                </comment>
                <comment line="327">
                    Throw the declared exceptions.                    
                </comment>
                <declaration name="def" type="ClassDefinition" line="88"/>
                <declaration name="alreadyChecked" type="Expression" line="90"/>
                <scope line="92">
                    <scope line="93">
                        <declaration name="typeName" type="Identifier" line="103"/>
                        <scope line="107"/>
                        <scope line="111">
                            <scope line="112"/>
                        </scope>
                        <scope line="117">
                            <declaration name="oc" type="ClassDefinition" line="122"/>
                            <declaration name="nm" type="Identifier" line="123"/>
                        </scope>
                    </scope>
                    <scope line="132"/>
                </scope>
                <scope line="139"/>
                <scope line="141"/>
                <declaration name="t" type="Type" line="145"/>
                <declaration name="hasErrors" type="boolean" line="146"/>
                <scope line="148">
                    <scope line="149"/>
                </scope>
                <scope line="159"/>
                <declaration name="args" type="Expression" line="165"/>
                <declaration name="argTypes" type="Type" line="175"/>
                <scope line="177">
                    <scope line="179"/>
                </scope>
                <scope line="186">
                    <scope line="188"/>
                    <declaration name="sourceClass" type="ClassDefinition" line="195"/>
                    <declaration name="c" type="ClassDeclaration" line="197"/>
                    <scope line="200">
                        <declaration name="packageName" type="Identifier" line="202"/>
                        <declaration name="superDef" type="ClassDefinition" line="205"/>
                        <scope line="206"/>
                        <scope line="214"/>
                        <declaration name="constructor" type="MemberDefinition" line="219"/>
                        <scope line="221"/>
                    </scope>
                    <scope line="245">
                        <scope line="247"/>
                        <scope line="253"/>
                    </scope>
                    <scope line="263">
                        <declaration name="anyInit" type="MemberDefinition" line="264"/>
                        <declaration name="sig" type="String" line="269"/>
                    </scope>
                    <scope line="275">
                        <declaration name="cdef" type="ClassDefinition" line="276"/>
                        <scope line="277"/>
                    </scope>
                    <scope line="284"/>
                    <scope line="289"/>
                    <scope line="299"/>
                </scope>
                <scope line="304"/>
                <scope line="308"/>
                <scope line="315"/>
                <scope line="318">
                    <scope line="321"/>
                </scope>
                <declaration name="exceptions" type="ClassDeclaration" line="327"/>
                <scope line="328">
                    <scope line="329"/>
                </scope>
            </method>
            <javadoc line="339">
                Given a list of arguments for a constructor,
                  return a possibly modified list which includes the hidden
                  argument which initializes the uplevel self pointer.                
                <arg>
                    def the class which perhaps contains an outer link.                    
                </arg>
                <arg>
                    outerArg if non-null, an explicit location in which to construct.                    
                </arg>
            </javadoc>
            <method name="insertOuterLink" type="Expression[]" line="349">
                <params>
                    <param name="env" type="Environment"/>
                    <param name="ctx" type="Context"/>
                    <param name="where" type="long"/>
                    <param name="def" type="ClassDefinition"/>
                    <param name="outerArg" type="Expression"/>
                    <param name="args" type="Expression"/>
                </params>
                <comment line="359">
                    die somewhere else                    
                </comment>
                <scope line="350">
                    <declaration name="args2" type="Expression" line="351"/>
                    <scope line="353"/>
                    <scope line="357"/>
                </scope>
            </method>
            <javadoc line="366">
                Check void expression                
            </javadoc>
            <method name="check" type="Vset" line="369">
                <params>
                    <param name="env" type="Environment"/>
                    <param name="ctx" type="Context"/>
                    <param name="vset" type="Vset"/>
                    <param name="exp" type="Hashtable"/>
                </params>
            </method>
            <declaration name="MAXINLINECOST" type="int" line="373"/>
            <javadoc line="373">
                Inline                
            </javadoc>
            <method name="copyInline" type="Expression" line="378">
                <params>
                    <param name="ctx" type="Context"/>
                </params>
                <declaration name="e" type="NewInstanceExpression" line="379"/>
                <scope line="380"/>
            </method>
            <method name="inlineNewInstance" type="Expression" line="386">
                <params>
                    <param name="env" type="Environment"/>
                    <param name="ctx" type="Context"/>
                    <param name="s" type="Statement"/>
                </params>
                <comment line="404">
                    System.out.print(&quot;BEFORE:&quot;); s.print(System.out); System.out.println();                    
                </comment>
                <comment line="406">
                    System.out.print(&quot;COPY:&quot;); body[body.length - 1].print(System.out); System.out.println();
                    System.out.print(&quot;AFTER:&quot;); s.print(System.out); System.out.println();                    
                </comment>
                <scope line="387"/>
                <declaration name="v" type="LocalMember" line="390"/>
                <declaration name="body" type="Statement" line="391"/>
                <declaration name="o" type="int" line="393"/>
                <scope line="394"/>
                <scope line="397"/>
                <scope line="400"/>
            </method>
            <method name="inline" type="Expression" line="412">
                <params>
                    <param name="env" type="Environment"/>
                    <param name="ctx" type="Context"/>
                </params>
            </method>
            <method name="inlineValue" type="Expression" line="415">
                <params>
                    <param name="env" type="Environment"/>
                    <param name="ctx" type="Context"/>
                </params>
                <comment line="425">
                    right = right.inlineValue(env, ctx);                    
                </comment>
                <comment line="437">
                    This &apos;false&apos; that fy put in is inexplicable to me
                     the decision to not inline new instance expressions
                     should be revisited.  - dps                    
                </comment>
                <scope line="416"/>
                <declaration name="refc" type="ClassDefinition" line="419"/>
                <declaration name="r" type="UplevelReference" line="420"/>
                <scope line="421"/>
                <scope line="426">
                    <scope line="427"/>
                    <scope line="433"/>
                    <scope line="441">
                        <declaration name="s" type="Statement" line="442"/>
                        <scope line="444"/>
                    </scope>
                </scope>
                <scope line="448"/>
                <scope line="451">
                    <declaration name="e" type="Expression" line="452"/>
                </scope>
            </method>
            <method name="costInline" type="int" line="459">
                <params>
                    <param name="thresh" type="int"/>
                    <param name="env" type="Environment"/>
                    <param name="ctx" type="Context"/>
                </params>
                <comment line="462">
                    don&apos;t copy classes...                    
                </comment>
                <comment line="467">
                    sourceClass is the current class trying to inline this method                    
                </comment>
                <comment line="470">
                    We only allow the inlining if the current class can access
                     the field and the field&apos;s class;                    
                </comment>
                <scope line="460"/>
                <scope line="463"/>
                <declaration name="sourceClass" type="ClassDefinition" line="467"/>
                <scope line="468">
                    <scope line="472"/>
                </scope>
                <scope line="475"/>
            </method>
            <javadoc line="481">
                Code                
            </javadoc>
            <method name="code" type="void" line="484">
                <params>
                    <param name="env" type="Environment"/>
                    <param name="ctx" type="Context"/>
                    <param name="asm" type="Assembler"/>
                </params>
            </method>
            <method name="codeValue" type="void" line="487">
                <params>
                    <param name="env" type="Environment"/>
                    <param name="ctx" type="Context"/>
                    <param name="asm" type="Assembler"/>
                </params>
            </method>
            <method name="codeCommon" type="void" line="491">
                <params>
                    <param name="env" type="Environment"/>
                    <param name="ctx" type="Context"/>
                    <param name="asm" type="Assembler"/>
                    <param name="forValue" type="boolean"/>
                </params>
                <comment line="511">
                    guaranteed non-null                    
                </comment>
                <comment line="518">
                    else fall through:                    
                </comment>
                <comment line="521">
                    Test for nullity by invoking some trivial operation
                     that can throw a NullPointerException.                    
                </comment>
                <comment line="535">
                    Constructor call will be via an access method.
                     Pass &apos;null&apos; as the value of the dummy argument.                    
                </comment>
                <scope line="493"/>
                <declaration name="refc" type="ClassDefinition" line="497"/>
                <declaration name="r" type="UplevelReference" line="498"/>
                <scope line="500"/>
                <scope line="504">
                    <scope line="512">
                        <declaration name="f" type="MemberDefinition" line="513"/>
                        <scope line="514"/>
                    </scope>
                    <scope line="522">
                        <declaration name="c" type="ClassDefinition" line="523"/>
                        <declaration name="getc" type="MemberDefinition" line="524"/>
                    </scope>
                    <scope line="528"/>
                </scope>
                <scope line="533"/>
                <scope line="539"/>
            </method>
        </class>
    </source>