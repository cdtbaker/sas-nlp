<?xml version="1.0" encoding="UTF-8"?>
    <source package="sun.tools.tree">
        <import package="sun.tools.java"/>
        <import package="sun.tools.asm.Assembler"/>
        <class name="AddExpression" line="31">
            <extends class="BinaryArithmeticExpression"/>
            <javadoc line="31">
                WARNING: The contents of this source file are not part of any
                  supported API.  Code that depends on them does so at its own risk:
                  they are subject to change or removal without notice.                
            </javadoc>
            <javadoc line="38">
                constructor                
            </javadoc>
            <method name="AddExpression" type="constructor" line="41">
                <params>
                    <param name="where" type="long"/>
                    <param name="left" type="Expression"/>
                    <param name="right" type="Expression"/>
                </params>
            </method>
            <javadoc line="45">
                Select the type                
            </javadoc>
            <method name="selectType" type="void" line="48">
                <params>
                    <param name="env" type="Environment"/>
                    <param name="ctx" type="Context"/>
                    <param name="tm" type="int"/>
                </params>
                <scope line="49"/>
                <scope line="52"/>
            </method>
            <method name="isNonNull" type="boolean" line="59">
                <comment line="60">
                    an addition expression cannot yield a null reference as a result                    
                </comment>
            </method>
            <javadoc line="64">
                Evaluate                
            </javadoc>
            <method name="eval" type="Expression" line="67">
                <params>
                    <param name="a" type="int"/>
                    <param name="b" type="int"/>
                </params>
            </method>
            <method name="eval" type="Expression" line="70">
                <params>
                    <param name="a" type="long"/>
                    <param name="b" type="long"/>
                </params>
            </method>
            <method name="eval" type="Expression" line="73">
                <params>
                    <param name="a" type="float"/>
                    <param name="b" type="float"/>
                </params>
            </method>
            <method name="eval" type="Expression" line="76">
                <params>
                    <param name="a" type="double"/>
                    <param name="b" type="double"/>
                </params>
            </method>
            <method name="eval" type="Expression" line="79">
                <params>
                    <param name="a" type="String"/>
                    <param name="b" type="String"/>
                </params>
            </method>
            <javadoc line="83">
                Inline the value of an AddExpression.  If this AddExpression
                  represents a concatenation of compile-time constant strings,
                  dispatch to the special method inlineValueSB, which handles
                  the inlining more efficiently.                
            </javadoc>
            <method name="inlineValue" type="Expression" line="89">
                <params>
                    <param name="env" type="Environment"/>
                    <param name="ctx" type="Context"/>
                </params>
                <comment line="93">
                    We were able to evaluate the String concatenation.                    
                </comment>
                <comment line="97">
                    For some reason inlinValueSB() failed to produce a value.                    
                </comment>
                <comment line="98">
                    Use the older, less efficient, inlining mechanism.                    
                </comment>
                <scope line="90">
                    <declaration name="buffer" type="StringBuffer" line="91"/>
                    <scope line="92"/>
                </scope>
            </method>
            <javadoc line="102">
                Attempt to evaluate this expression.  If this expression
                  yields a value, append it to the StringBuffer `buffer&apos;.
                  If this expression cannot be evaluated at this time (for
                  example if it contains a division by zero, a non-constant
                  subexpression, or a subexpression which &quot;refuses&quot; to evaluate)
                  then return `null&apos; to indicate failure.
                  It is anticipated that this method will be called to evaluate
                  concatenations of compile-time constant strings.  The call
                  originates from AddExpression#inlineValue().
                  This method does not use associativity to good effect in
                  folding string concatenations.  This is room for improvement.
                  -------------
                  A bit of history: this method was added because an
                  expression like...
                  &quot;a&quot; + &quot;b&quot; + &quot;c&quot; + &quot;d&quot;
                  ...was evaluated at compile-time as...
                  (new StringBuffer((new StringBuffer(&quot;a&quot;)).append(&quot;b&quot;).toString())).
                  append((new StringBuffer(&quot;c&quot;)).append(&quot;d&quot;).toString()).toString()
                  Alex Garthwaite, in profiling the memory allocation of the
                  compiler, noticed this and suggested that the method inlineValueSB()
                  be added to evaluate constant string concatenations in a more
                  efficient manner.  The compiler now builds the string in a
                  top-down fashion, by accumulating the result in a StringBuffer
                  which is allocated once and passed in as a parameter.  The new
                  evaluation scheme is equivalent to...
                  (new StringBuffer(&quot;a&quot;)).append(&quot;b&quot;).append(&quot;c&quot;).append(&quot;d&quot;)
                  .toString()
                  ...which is more efficient.  Since then, the code has been modified
                  to fix certain problems.  Now, for example, it can return `null&apos;
                  when it encounters a concatenation which it is not able to
                  evaluate.
                  See also Expression#inlineValueSB() and ExprExpression#inlineValueSB().                
            </javadoc>
            <method name="inlineValueSB" type="StringBuffer" line="149">
                <params>
                    <param name="env" type="Environment"/>
                    <param name="ctx" type="Context"/>
                    <param name="buffer" type="StringBuffer"/>
                </params>
                <comment line="151">
                    This isn&apos;t a concatenation.  It is actually an addition                    
                </comment>
                <comment line="152">
                    of some sort.  Call the generic inlineValueSB()                    
                </comment>
                <scope line="150"/>
                <scope line="157"/>
            </method>
            <javadoc line="163">
                Simplify                
            </javadoc>
            <method name="simplify" type="Expression" line="166">
                <comment line="168">
                    Can&apos;t simplify floating point add because of -0.0 strangeness                    
                </comment>
                <scope line="167">
                    <scope line="169">
                        <scope line="170"/>
                        <scope line="173"/>
                    </scope>
                </scope>
                <scope line="177"/>
                <scope line="179"/>
            </method>
            <javadoc line="185">
                The cost of inlining this expression                
            </javadoc>
            <method name="costInline" type="int" line="188">
                <params>
                    <param name="thresh" type="int"/>
                    <param name="env" type="Environment"/>
                    <param name="ctx" type="Context"/>
                </params>
            </method>
            <javadoc line="194">
                Code                
            </javadoc>
            <method name="codeOperation" type="void" line="197">
                <params>
                    <param name="env" type="Environment"/>
                    <param name="ctx" type="Context"/>
                    <param name="asm" type="Assembler"/>
                </params>
            </method>
            <javadoc line="201">
                Convert this expression to a string and append it to the string
                  buffer on the top of the stack.
                  If the needBuffer argument is true, the string buffer needs to be
                  created, initialized, and pushed on the stack, first.                
            </javadoc>
            <method name="codeAppend" type="void" line="209">
                <params>
                    <param name="env" type="Environment"/>
                    <param name="ctx" type="Context"/>
                    <param name="asm" type="Assembler"/>
                    <param name="sbClass" type="ClassDeclaration"/>
                    <param name="needBuffer" type="boolean"/>
                </params>
                <scope line="210"/>
                <scope line="213"/>
            </method>
            <method name="codeValue" type="void" line="218">
                <params>
                    <param name="env" type="Environment"/>
                    <param name="ctx" type="Context"/>
                    <param name="asm" type="Assembler"/>
                </params>
                <comment line="221">
                    optimize (&quot;&quot;+foo) or (foo+&quot;&quot;) to String.valueOf(foo)                    
                </comment>
                <comment line="236">
                    Create the string buffer and append to it.                    
                </comment>
                <comment line="238">
                    Convert the string buffer to a string                    
                </comment>
                <scope line="219">
                    <scope line="220">
                        <scope line="222"/>
                        <scope line="227"/>
                        <declaration name="sbClass" type="ClassDeclaration" line="233"/>
                        <declaration name="sourceClass" type="ClassDefinition" line="235"/>
                        <declaration name="f" type="MemberDefinition" line="239"/>
                    </scope>
                    <scope line="244"/>
                    <scope line="246"/>
                </scope>
                <scope line="249"/>
            </method>
        </class>
    </source>