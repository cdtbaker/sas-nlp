<?xml version="1.0" encoding="UTF-8"?>
    <source package="sun.tools.tree">
        <import package="sun.tools.java"/>
        <import package="sun.tools.asm.Assembler"/>
        <import package="sun.tools.asm.Label"/>
        <import package="java.io.PrintStream"/>
        <import package="java.util.Hashtable"/>
        <class name="IfStatement" line="34">
            <extends class="Statement"/>
            <javadoc line="34">
                WARNING: The contents of this source file are not part of any
                  supported API.  Code that depends on them does so at its own risk:
                  they are subject to change or removal without notice.                
            </javadoc>
            <declaration name="cond" type="Expression" line="41"/>
            <declaration name="ifTrue" type="Statement" line="42"/>
            <declaration name="ifFalse" type="Statement" line="43"/>
            <javadoc line="45">
                Constructor                
            </javadoc>
            <method name="IfStatement" type="constructor" line="48">
                <params>
                    <param name="where" type="long"/>
                    <param name="cond" type="Expression"/>
                    <param name="ifTrue" type="Statement"/>
                    <param name="ifFalse" type="Statement"/>
                </params>
            </method>
            <javadoc line="55">
                Check statement                
            </javadoc>
            <method name="check" type="Vset" line="58">
                <params>
                    <param name="env" type="Environment"/>
                    <param name="ctx" type="Context"/>
                    <param name="vset" type="Vset"/>
                    <param name="exp" type="Hashtable"/>
                </params>
                <comment line="61">
                    Vset vsExtra = vset.copy();  // See comment below.                    
                </comment>
                <comment line="65">
                    The following code, now deleted, was apparently an erroneous attempt                    
                </comment>
                <comment line="66">
                    at providing better error diagnostics.  The comment read: &apos;If either                    
                </comment>
                <comment line="67">
                    the true clause or the false clause is unreachable, do a reasonable                    
                </comment>
                <comment line="68">
                    check on the child anyway.&apos;                    
                </comment>
                <comment line="69">
                    Vset vsTrue  = cvars.vsTrue.isDeadEnd() ? vsExtra : cvars.vsTrue;                    
                </comment>
                <comment line="70">
                    Vset vsFalse = cvars.vsFalse.isDeadEnd() ? vsExtra : cvars.vsFalse;                    
                </comment>
                <comment line="71">
                    Unfortunately, this violates the rules laid out in the JLS, and leads to                    
                </comment>
                <comment line="72">
                    blatantly incorrect results.  For example, &apos;i&apos; will not be recognized                    
                </comment>
                <comment line="73">
                    as definitely assigned following the statement &apos;if (true) i = 1;&apos;.                    
                </comment>
                <comment line="74">
                    It is best to slavishly follow the JLS here.  A cleverer approach could                    
                </comment>
                <comment line="75">
                    only correctly issue warnings, as JLS 16.2.6 is quite explicit, and it                    
                </comment>
                <comment line="76">
                    is OK for a dead branch of an if-statement to omit an assignment that                    
                </comment>
                <comment line="77">
                    would be required in the other branch.  A complication: This code also                    
                </comment>
                <comment line="78">
                    had the effect of implementing the special-case rules for &apos;if-then&apos; and                    
                </comment>
                <comment line="79">
                    &apos;if-then-else&apos; in JLS 14.19, &quot;Unreachable Statements&quot;.  We now use                    
                </comment>
                <comment line="80">
                    &apos;Vset.clearDeadEnd&apos; to remove the dead-end status of unreachable branches                    
                </comment>
                <comment line="81">
                    without affecting the definite-assignment status of the variables, thus                    
                </comment>
                <comment line="82">
                    maintaining a correct implementation of JLS 16.2.6.  Fixes 4094353.                    
                </comment>
                <comment line="83">
                    Note that the code below will not consider the branches unreachable if                    
                </comment>
                <comment line="84">
                    the entire statement is unreachable.  This is consistent with the error                    
                </comment>
                <comment line="85">
                    recovery policy that reports the only the first unreachable statement                    
                </comment>
                <comment line="86">
                    along an acyclic execution path.                    
                </comment>
                <declaration name="newctx" type="CheckContext" line="60"/>
                <declaration name="cvars" type="ConditionVars" line="62"/>
                <declaration name="vsTrue" type="Vset" line="87"/>
                <declaration name="vsFalse" type="Vset" line="88"/>
            </method>
            <javadoc line="96">
                Inline                
            </javadoc>
            <method name="inline" type="Statement" line="99">
                <params>
                    <param name="env" type="Environment"/>
                    <param name="ctx" type="Context"/>
                </params>
                <comment line="103">
                    The compiler currently needs to perform inlining on both                    
                </comment>
                <comment line="104">
                    branches of the if statement -- even if `cond&apos; is a constant                    
                </comment>
                <comment line="105">
                    true or false.  Why?  The compiler will later try to compile                    
                </comment>
                <comment line="106">
                    all classes that it has seen; this includes classes that                    
                </comment>
                <comment line="107">
                    appear in dead code.  If we don&apos;t inline the dead branch here                    
                </comment>
                <comment line="108">
                    then the compiler will never perform inlining on any local                    
                </comment>
                <comment line="109">
                    classes appearing on the dead code.  When the compiler tries                    
                </comment>
                <comment line="110">
                    to compile an un-inlined local class with uplevel references,                    
                </comment>
                <comment line="111">
                    it dies.  (bug 4059492)                    
                </comment>
                <comment line="112">
                                        
                </comment>
                <comment line="113">
                    A better solution to this would be to walk the dead branch and                    
                </comment>
                <comment line="114">
                    mark any local classes appearing therein as unneeded.  Then the                    
                </comment>
                <comment line="115">
                    compilation phase could skip these classes.                    
                </comment>
                <scope line="116"/>
                <scope line="119"/>
                <scope line="122"/>
                <scope line="125"/>
                <scope line="128"/>
                <scope line="131"/>
            </method>
            <javadoc line="138">
                Create a copy of the statement for method inlining                
            </javadoc>
            <method name="copyInline" type="Statement" line="141">
                <params>
                    <param name="ctx" type="Context"/>
                    <param name="valNeeded" type="boolean"/>
                </params>
                <declaration name="s" type="IfStatement" line="142"/>
                <scope line="144"/>
                <scope line="147"/>
            </method>
            <javadoc line="153">
                The cost of inlining this statement                
            </javadoc>
            <method name="costInline" type="int" line="156">
                <params>
                    <param name="thresh" type="int"/>
                    <param name="env" type="Environment"/>
                    <param name="ctx" type="Context"/>
                </params>
                <declaration name="cost" type="int" line="157"/>
                <scope line="158"/>
                <scope line="161"/>
            </method>
            <javadoc line="167">
                Code                
            </javadoc>
            <method name="code" type="void" line="170">
                <params>
                    <param name="env" type="Environment"/>
                    <param name="ctx" type="Context"/>
                    <param name="asm" type="Assembler"/>
                </params>
                <declaration name="newctx" type="CodeContext" line="171"/>
                <declaration name="l1" type="Label" line="173"/>
                <scope line="176">
                    <declaration name="l2" type="Label" line="177"/>
                </scope>
                <scope line="182"/>
            </method>
            <javadoc line="189">
                Print                
            </javadoc>
            <method name="print" type="void" line="192">
                <params>
                    <param name="out" type="PrintStream"/>
                    <param name="indent" type="int"/>
                </params>
                <scope line="198"/>
            </method>
        </class>
    </source>