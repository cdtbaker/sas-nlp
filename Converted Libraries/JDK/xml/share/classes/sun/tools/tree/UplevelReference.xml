<?xml version="1.0" encoding="UTF-8"?>
    <source package="sun.tools.tree">
        <import package="sun.tools.java"/>
        <import package="sun.tools.tree"/>
        <import package="sun.tools.asm.Assembler"/>
        <class name="UplevelReference" line="32">
            <implements interface="Constants"/>
            <javadoc line="32">
                A reference from one scope to another.
                  WARNING: The contents of this source file are not part of any
                  supported API.  Code that depends on them does so at its own risk:
                  they are subject to change or removal without notice.                
            </javadoc>
            <declaration name="client" type="ClassDefinition" line="43"/>
            <javadoc line="43">
                The class in which the reference occurs.                
            </javadoc>
            <declaration name="target" type="LocalMember" line="48"/>
            <javadoc line="48">
                The field being referenced.
                  It is always a final argument or a final local variable.
                  (An uplevel reference to a field of a class C is fetched
                  through an implicit uplevel reference to C.this, which is
                  an argument.)                
            </javadoc>
            <declaration name="localArgument" type="LocalMember" line="57"/>
            <javadoc line="57">
                The local variable which bears a copy of the target&apos;s value,
                  for all methods of the client class.
                  Its name is &quot;this$C&quot; for &lt;code&gt;this.C&lt;/code&gt; or
                  &quot;val$x&quot; for other target variables &lt;code&gt;x&lt;/code&gt;.
                  &lt;p&gt;
                  This local variable is always a constructor argument,
                  and is therefore usable only in the constructor and in initializers.
                  All other methods use the local field.                
                <see>
                    #localField                    
                </see>
            </javadoc>
            <declaration name="localField" type="MemberDefinition" line="70"/>
            <javadoc line="70">
                A private synthetic field of the client class which
                  bears a copy of the target&apos;s value.
                  The compiler tries to avoid creating it if possible.
                  The field has the same name and type as the localArgument.                
                <see>
                    #localArgument                    
                </see>
            </javadoc>
            <declaration name="next" type="UplevelReference" line="79"/>
            <javadoc line="79">
                The next item on the references list of the client.                
            </javadoc>
            <javadoc line="84">
                constructor                
            </javadoc>
            <method name="UplevelReference" type="constructor" line="87">
                <params>
                    <param name="client" type="ClassDefinition"/>
                    <param name="target" type="LocalMember"/>
                </params>
                <comment line="92">
                    Choose a name and build a variable declaration node.                    
                </comment>
                <comment line="96">
                    It should always be true that tc.enclosingClassOf(client).
                     If it were false, the numbering scheme would fail
                     to produce unique names, since we&apos;d be trying
                     to number classes which were not in the sequence
                     of enclosing scopes.  The next paragraph of this
                     code robustly deals with that possibility, however,
                     by detecting name collisions and perturbing the names.                    
                </comment>
                <comment line="105">
                    The inner classes specification states that the name of
                     a private field containing a reference to the outermost
                     enclosing instance is named &quot;this$0&quot;.  That outermost
                     enclosing instance is always the innermost toplevel class.                    
                </comment>
                <comment line="111">
                    In this example, T1,T2,T3 are all top-level (static),
                     while I4,I5,I6,I7 are all inner.  Each of the inner classes
                     will have a single up-level &quot;this$N&quot; reference to the next
                     class out.  Only the outermost &quot;this$0&quot; will refer to a
                     top-level class, T3.
                    
                     class T1 {
                      static class T2 {
                       static class T3 {
                        class I4 {
                         class I5 {
                          class I6 {
                            at this point we have these fields in various places:
                            I4 this$0; I5 this$1; I6 this$2;
                          }
                         }
                         class I7 {
                            I4 this$0; I7 this$1;
                         }
                        }
                       }
                      }
                     }                    
                </comment>
                <comment line="139">
                    Make reasonably certain that valName is unique to this client.
                     (This check can be fooled by malicious naming of explicit
                     constructor arguments, or of inherited fields.)                    
                </comment>
                <comment line="155">
                    try another name                    
                </comment>
                <comment line="159">
                    Build the constructor argument.
                     Like &quot;this&quot;, it wil be shared equally by all constructors of client.                    
                </comment>
                <declaration name="valName" type="Identifier" line="92"/>
                <scope line="93">
                    <declaration name="tc" type="ClassDefinition" line="94"/>
                    <declaration name="depth" type="int" line="102"/>
                    <scope line="103"/>
                </scope>
                <scope line="134"/>
                <declaration name="base" type="Identifier" line="141"/>
                <declaration name="tick" type="int" line="142"/>
                <scope line="143">
                    <declaration name="failed" type="boolean" line="144"/>
                    <scope line="146">
                        <scope line="147"/>
                    </scope>
                    <scope line="151"/>
                </scope>
            </method>
            <javadoc line="167">
                Insert self into a list of references.
                  Maintain &quot;isEarlierThan&quot; as an invariant of the list.
                  This is important (a) to maximize stability of signatures,
                  and (b) to allow uplevel &quot;this&quot; parameters to come at the
                  front of every argument list they appear in.                
            </javadoc>
            <method name="insertInto" type="UplevelReference" line="174">
                <params>
                    <param name="references" type="UplevelReference"/>
                </params>
                <scope line="175"/>
                <scope line="178">
                    <declaration name="prev" type="UplevelReference" line="179"/>
                    <scope line="180"/>
                </scope>
            </method>
            <javadoc line="189">
                Tells if self precedes the other in the canonical ordering.                
            </javadoc>
            <method name="isEarlierThan" type="boolean" line="192">
                <params>
                    <param name="other" type="UplevelReference"/>
                </params>
                <comment line="194">
                    Outer fields always come first.                    
                </comment>
                <comment line="201">
                    Now it doesn&apos;t matter what the order is; use string comparison.                    
                </comment>
                <scope line="194"/>
                <scope line="196"/>
                <declaration name="target2" type="LocalMember" line="201"/>
                <declaration name="name" type="Identifier" line="202"/>
                <declaration name="name2" type="Identifier" line="203"/>
                <declaration name="cmp" type="int" line="204"/>
                <scope line="205"/>
                <declaration name="cname" type="Identifier" line="208"/>
                <declaration name="cname2" type="Identifier" line="209"/>
                <declaration name="ccmp" type="int" line="210"/>
            </method>
            <javadoc line="214">
                the target of this reference                
            </javadoc>
            <method name="getTarget" type="LocalMember" line="217"/>
            <javadoc line="221">
                the local argument for this reference                
            </javadoc>
            <method name="getLocalArgument" type="LocalMember" line="224"/>
            <javadoc line="228">
                the field allocated in the client for this reference                
            </javadoc>
            <method name="getLocalField" type="MemberDefinition" line="231"/>
            <javadoc line="235">
                Get the local field, creating one if necessary.
                  The client class must not be frozen.                
            </javadoc>
            <method name="getLocalField" type="MemberDefinition" line="239">
                <params>
                    <param name="env" type="Environment"/>
                </params>
                <scope line="240"/>
            </method>
            <javadoc line="246">
                the client class                
            </javadoc>
            <method name="getClient" type="ClassDefinition" line="249"/>
            <javadoc line="253">
                the next reference in the client&apos;s list                
            </javadoc>
            <method name="getNext" type="UplevelReference" line="256"/>
            <javadoc line="260">
                Tell if this uplevel reference is the up-level &quot;this&quot; pointer
                  of an inner class.  Such references are treated differently
                  than others, because they affect constructor calls across
                  compilation units.                
            </javadoc>
            <method name="isClientOuterField" type="boolean" line="266">
                <declaration name="outerf" type="MemberDefinition" line="267"/>
            </method>
            <javadoc line="271">
                Tell if my local argument is directly available in this context.
                  If not, the uplevel reference will have to be via a class field.
                  &lt;p&gt;
                  This must be called in a context which is local
                  to the client of the uplevel reference.                
            </javadoc>
            <method name="localArgumentAvailable" type="boolean" line="278">
                <params>
                    <param name="env" type="Environment"/>
                    <param name="ctx" type="Context"/>
                </params>
                <declaration name="reff" type="MemberDefinition" line="279"/>
                <scope line="280"/>
            </method>
            <javadoc line="288">
                Process an uplevel reference.
                  The only decision to make at this point is whether
                  to build a &quot;localField&quot; instance variable, which
                  is done (lazily) when localArgumentAvailable() proves false.                
            </javadoc>
            <method name="noteReference" type="void" line="294">
                <params>
                    <param name="env" type="Environment"/>
                    <param name="ctx" type="Context"/>
                </params>
                <comment line="297">
                    We need an instance variable unless client is a constructor.                    
                </comment>
                <scope line="295"/>
            </method>
            <method name="makeLocalField" type="void" line="301">
                <params>
                    <param name="env" type="Environment"/>
                </params>
                <comment line="303">
                    Cannot alter decisions like this one at a late date.                    
                </comment>
                <declaration name="mod" type="int" line="304"/>
            </method>
            <javadoc line="314">
                Assuming noteReference() is all taken care of,
                  build an uplevel reference.
                  &lt;p&gt;
                  This must be called in a context which is local
                  to the client of the uplevel reference.                
            </javadoc>
            <method name="makeLocalReference" type="Expression" line="321">
                <params>
                    <param name="env" type="Environment"/>
                    <param name="ctx" type="Context"/>
                </params>
                <scope line="322"/>
                <scope line="325"/>
                <scope line="327"/>
            </method>
            <javadoc line="332">
                As with makeLocalReference(), build a locally-usable reference.
                  Ignore the availability of local arguments; always use a class field.                
            </javadoc>
            <method name="makeFieldReference" type="Expression" line="336">
                <params>
                    <param name="env" type="Environment"/>
                    <param name="ctx" type="Context"/>
                </params>
                <declaration name="e" type="Expression" line="337"/>
            </method>
            <javadoc line="341">
                During the inline phase, call this on a list of references
                  for which the code phase will later emit arguments.
                  It will make sure that any &quot;double-uplevel&quot; values
                  needed by the callee are also present at the call site.
                  &lt;p&gt;
                  If any reference is a &quot;ClientOuterField&quot;, it is skipped
                  by this method (and by willCodeArguments).  This is because                
            </javadoc>
            <method name="willCodeArguments" type="void" line="350">
                <params>
                    <param name="env" type="Environment"/>
                    <param name="ctx" type="Context"/>
                </params>
                <scope line="351"/>
                <scope line="355"/>
            </method>
            <javadoc line="360">
                Code is being generated for a call to a constructor of
                  the client class.  Push an argument for the constructor.                
            </javadoc>
            <method name="codeArguments" type="void" line="365">
                <params>
                    <param name="env" type="Environment"/>
                    <param name="ctx" type="Context"/>
                    <param name="asm" type="Assembler"/>
                    <param name="where" type="long"/>
                    <param name="conField" type="MemberDefinition"/>
                </params>
                <scope line="366">
                    <declaration name="e" type="Expression" line="367"/>
                </scope>
                <scope line="371"/>
            </method>
            <javadoc line="376">
                Code is being generated for a constructor of the client class.
                  Emit code which initializes the instance.                
            </javadoc>
            <method name="codeInitialization" type="void" line="381">
                <params>
                    <param name="env" type="Environment"/>
                    <param name="ctx" type="Context"/>
                    <param name="asm" type="Assembler"/>
                    <param name="where" type="long"/>
                    <param name="conField" type="MemberDefinition"/>
                </params>
                <comment line="383">
                    If the reference is a clientOuterField, then the initialization
                     code is generated in MethodExpression.makeVarInits().
                     (Fix for bug 4075063.)                    
                </comment>
                <scope line="385">
                    <declaration name="e" type="Expression" line="386"/>
                    <declaration name="f" type="Expression" line="387"/>
                </scope>
                <scope line="393"/>
            </method>
            <method name="toString" type="String" line="398"/>
        </class>
    </source>