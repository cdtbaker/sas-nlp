<?xml version="1.0" encoding="UTF-8"?>
    <source package="sun.tools.tree">
        <import package="sun.tools.java"/>
        <import package="sun.tools.tree"/>
        <import package="sun.tools.asm.Assembler"/>
        <class name="UplevelReference" line="32">
            <implements interface="Constants"/>
            <javadoc line="32">
                A reference from one scope to another.
                  WARNING: The contents of this source file are not part of any
                  supported API.  Code that depends on them does so at its own risk:
                  they are subject to change or removal without notice.                
            </javadoc>
            <declaration name="client" type="ClassDefinition" line="43"/>
            <javadoc line="43">
                The class in which the reference occurs.                
            </javadoc>
            <declaration name="target" type="LocalMember" line="48"/>
            <javadoc line="48">
                The field being referenced.
                  It is always a final argument or a final local variable.
                  (An uplevel reference to a field of a class C is fetched
                  through an implicit uplevel reference to C.this, which is
                  an argument.)                
            </javadoc>
            <declaration name="localArgument" type="LocalMember" line="57"/>
            <javadoc line="57">
                The local variable which bears a copy of the target&apos;s value,
                  for all methods of the client class.
                  Its name is &quot;this$C&quot; for &lt;code&gt;this.C&lt;/code&gt; or
                  &quot;val$x&quot; for other target variables &lt;code&gt;x&lt;/code&gt;.
                  &lt;p&gt;
                  This local variable is always a constructor argument,
                  and is therefore usable only in the constructor and in initializers.
                  All other methods use the local field.                
                <see>
                    #localField                    
                </see>
            </javadoc>
            <declaration name="localField" type="MemberDefinition" line="70"/>
            <javadoc line="70">
                A private synthetic field of the client class which
                  bears a copy of the target&apos;s value.
                  The compiler tries to avoid creating it if possible.
                  The field has the same name and type as the localArgument.                
                <see>
                    #localArgument                    
                </see>
            </javadoc>
            <declaration name="next" type="UplevelReference" line="79"/>
            <javadoc line="79">
                The next item on the references list of the client.                
            </javadoc>
            <javadoc line="84">
                constructor                
            </javadoc>
            <method name="UplevelReference" type="constructor" line="87">
                <params>
                    <param name="client" type="ClassDefinition"/>
                    <param name="target" type="LocalMember"/>
                </params>
                <comment line="91">
                    Choose a name and build a variable declaration node.                    
                </comment>
                <comment line="95">
                    It should always be true that tc.enclosingClassOf(client).                    
                </comment>
                <comment line="96">
                    If it were false, the numbering scheme would fail                    
                </comment>
                <comment line="97">
                    to produce unique names, since we&apos;d be trying                    
                </comment>
                <comment line="98">
                    to number classes which were not in the sequence                    
                </comment>
                <comment line="99">
                    of enclosing scopes.  The next paragraph of this                    
                </comment>
                <comment line="100">
                    code robustly deals with that possibility, however,                    
                </comment>
                <comment line="101">
                    by detecting name collisions and perturbing the names.                    
                </comment>
                <comment line="104">
                    The inner classes specification states that the name of                    
                </comment>
                <comment line="105">
                    a private field containing a reference to the outermost                    
                </comment>
                <comment line="106">
                    enclosing instance is named &quot;this$0&quot;.  That outermost                    
                </comment>
                <comment line="107">
                    enclosing instance is always the innermost toplevel class.                    
                </comment>
                <comment line="110">
                    In this example, T1,T2,T3 are all top-level (static),                    
                </comment>
                <comment line="111">
                    while I4,I5,I6,I7 are all inner.  Each of the inner classes                    
                </comment>
                <comment line="112">
                    will have a single up-level &quot;this$N&quot; reference to the next                    
                </comment>
                <comment line="113">
                    class out.  Only the outermost &quot;this$0&quot; will refer to a                    
                </comment>
                <comment line="114">
                    top-level class, T3.                    
                </comment>
                <comment line="115">
                                        
                </comment>
                <comment line="116">
                    class T1 {                    
                </comment>
                <comment line="117">
                    static class T2 {                    
                </comment>
                <comment line="118">
                    static class T3 {                    
                </comment>
                <comment line="119">
                    class I4 {                    
                </comment>
                <comment line="120">
                    class I5 {                    
                </comment>
                <comment line="121">
                    class I6 {                    
                </comment>
                <comment line="122">
                    // at this point we have these fields in various places:                    
                </comment>
                <comment line="123">
                    // I4 this$0; I5 this$1; I6 this$2;                    
                </comment>
                <comment line="124">
                    }                    
                </comment>
                <comment line="125">
                    }                    
                </comment>
                <comment line="126">
                    class I7 {                    
                </comment>
                <comment line="127">
                    // I4 this$0; I7 this$1;                    
                </comment>
                <comment line="128">
                    }                    
                </comment>
                <comment line="129">
                    }                    
                </comment>
                <comment line="130">
                    }                    
                </comment>
                <comment line="131">
                    }                    
                </comment>
                <comment line="132">
                    }                    
                </comment>
                <comment line="138">
                    Make reasonably certain that valName is unique to this client.                    
                </comment>
                <comment line="139">
                    (This check can be fooled by malicious naming of explicit                    
                </comment>
                <comment line="140">
                    constructor arguments, or of inherited fields.)                    
                </comment>
                <comment line="154">
                    try another name                    
                </comment>
                <comment line="158">
                    Build the constructor argument.                    
                </comment>
                <comment line="159">
                    Like &quot;this&quot;, it wil be shared equally by all constructors of client.                    
                </comment>
                <declaration name="valName" type="Identifier" line="92"/>
                <scope line="93">
                    <declaration name="tc" type="ClassDefinition" line="94"/>
                    <declaration name="depth" type="int" line="102"/>
                    <scope line="103"/>
                </scope>
                <scope line="134"/>
                <declaration name="base" type="Identifier" line="141"/>
                <declaration name="tick" type="int" line="142"/>
                <scope line="143">
                    <declaration name="failed" type="boolean" line="144"/>
                    <scope line="146">
                        <scope line="147"/>
                    </scope>
                    <scope line="151"/>
                </scope>
            </method>
            <javadoc line="167">
                Insert self into a list of references.
                  Maintain &quot;isEarlierThan&quot; as an invariant of the list.
                  This is important (a) to maximize stability of signatures,
                  and (b) to allow uplevel &quot;this&quot; parameters to come at the
                  front of every argument list they appear in.                
            </javadoc>
            <method name="insertInto" type="UplevelReference" line="174">
                <params>
                    <param name="references" type="UplevelReference"/>
                </params>
                <scope line="175"/>
                <scope line="178">
                    <declaration name="prev" type="UplevelReference" line="179"/>
                    <scope line="180"/>
                </scope>
            </method>
            <javadoc line="189">
                Tells if self precedes the other in the canonical ordering.                
            </javadoc>
            <method name="isEarlierThan" type="boolean" line="192">
                <params>
                    <param name="other" type="UplevelReference"/>
                </params>
                <comment line="193">
                    Outer fields always come first.                    
                </comment>
                <comment line="200">
                    Now it doesn&apos;t matter what the order is; use string comparison.                    
                </comment>
                <scope line="194"/>
                <scope line="196"/>
                <declaration name="target2" type="LocalMember" line="201"/>
                <declaration name="name" type="Identifier" line="202"/>
                <declaration name="name2" type="Identifier" line="203"/>
                <declaration name="cmp" type="int" line="204"/>
                <scope line="205"/>
                <declaration name="cname" type="Identifier" line="208"/>
                <declaration name="cname2" type="Identifier" line="209"/>
                <declaration name="ccmp" type="int" line="210"/>
            </method>
            <javadoc line="214">
                the target of this reference                
            </javadoc>
            <method name="getTarget" type="LocalMember" line="217"/>
            <javadoc line="221">
                the local argument for this reference                
            </javadoc>
            <method name="getLocalArgument" type="LocalMember" line="224"/>
            <javadoc line="228">
                the field allocated in the client for this reference                
            </javadoc>
            <method name="getLocalField" type="MemberDefinition" line="231"/>
            <javadoc line="235">
                Get the local field, creating one if necessary.
                  The client class must not be frozen.                
            </javadoc>
            <method name="getLocalField" type="MemberDefinition" line="239">
                <params>
                    <param name="env" type="Environment"/>
                </params>
                <scope line="240"/>
            </method>
            <javadoc line="246">
                the client class                
            </javadoc>
            <method name="getClient" type="ClassDefinition" line="249"/>
            <javadoc line="253">
                the next reference in the client&apos;s list                
            </javadoc>
            <method name="getNext" type="UplevelReference" line="256"/>
            <javadoc line="260">
                Tell if this uplevel reference is the up-level &quot;this&quot; pointer
                  of an inner class.  Such references are treated differently
                  than others, because they affect constructor calls across
                  compilation units.                
            </javadoc>
            <method name="isClientOuterField" type="boolean" line="266">
                <declaration name="outerf" type="MemberDefinition" line="267"/>
            </method>
            <javadoc line="271">
                Tell if my local argument is directly available in this context.
                  If not, the uplevel reference will have to be via a class field.
                  &lt;p&gt;
                  This must be called in a context which is local
                  to the client of the uplevel reference.                
            </javadoc>
            <method name="localArgumentAvailable" type="boolean" line="278">
                <params>
                    <param name="env" type="Environment"/>
                    <param name="ctx" type="Context"/>
                </params>
                <declaration name="reff" type="MemberDefinition" line="279"/>
                <scope line="280"/>
            </method>
            <javadoc line="288">
                Process an uplevel reference.
                  The only decision to make at this point is whether
                  to build a &quot;localField&quot; instance variable, which
                  is done (lazily) when localArgumentAvailable() proves false.                
            </javadoc>
            <method name="noteReference" type="void" line="294">
                <params>
                    <param name="env" type="Environment"/>
                    <param name="ctx" type="Context"/>
                </params>
                <comment line="296">
                    We need an instance variable unless client is a constructor.                    
                </comment>
                <scope line="295"/>
            </method>
            <method name="makeLocalField" type="void" line="301">
                <params>
                    <param name="env" type="Environment"/>
                </params>
                <comment line="302">
                    Cannot alter decisions like this one at a late date.                    
                </comment>
                <declaration name="mod" type="int" line="304"/>
            </method>
            <javadoc line="314">
                Assuming noteReference() is all taken care of,
                  build an uplevel reference.
                  &lt;p&gt;
                  This must be called in a context which is local
                  to the client of the uplevel reference.                
            </javadoc>
            <method name="makeLocalReference" type="Expression" line="321">
                <params>
                    <param name="env" type="Environment"/>
                    <param name="ctx" type="Context"/>
                </params>
                <scope line="322"/>
                <scope line="325"/>
                <scope line="327"/>
            </method>
            <javadoc line="332">
                As with makeLocalReference(), build a locally-usable reference.
                  Ignore the availability of local arguments; always use a class field.                
            </javadoc>
            <method name="makeFieldReference" type="Expression" line="336">
                <params>
                    <param name="env" type="Environment"/>
                    <param name="ctx" type="Context"/>
                </params>
                <declaration name="e" type="Expression" line="337"/>
            </method>
            <javadoc line="341">
                During the inline phase, call this on a list of references
                  for which the code phase will later emit arguments.
                  It will make sure that any &quot;double-uplevel&quot; values
                  needed by the callee are also present at the call site.
                  &lt;p&gt;
                  If any reference is a &quot;ClientOuterField&quot;, it is skipped
                  by this method (and by willCodeArguments).  This is because                
            </javadoc>
            <method name="willCodeArguments" type="void" line="350">
                <params>
                    <param name="env" type="Environment"/>
                    <param name="ctx" type="Context"/>
                </params>
                <scope line="351"/>
                <scope line="355"/>
            </method>
            <javadoc line="360">
                Code is being generated for a call to a constructor of
                  the client class.  Push an argument for the constructor.                
            </javadoc>
            <method name="codeArguments" type="void" line="365">
                <params>
                    <param name="env" type="Environment"/>
                    <param name="ctx" type="Context"/>
                    <param name="asm" type="Assembler"/>
                    <param name="where" type="long"/>
                    <param name="conField" type="MemberDefinition"/>
                </params>
                <scope line="366">
                    <declaration name="e" type="Expression" line="367"/>
                </scope>
                <scope line="371"/>
            </method>
            <javadoc line="376">
                Code is being generated for a constructor of the client class.
                  Emit code which initializes the instance.                
            </javadoc>
            <method name="codeInitialization" type="void" line="381">
                <params>
                    <param name="env" type="Environment"/>
                    <param name="ctx" type="Context"/>
                    <param name="asm" type="Assembler"/>
                    <param name="where" type="long"/>
                    <param name="conField" type="MemberDefinition"/>
                </params>
                <comment line="382">
                    If the reference is a clientOuterField, then the initialization                    
                </comment>
                <comment line="383">
                    code is generated in MethodExpression.makeVarInits().                    
                </comment>
                <comment line="384">
                    (Fix for bug 4075063.)                    
                </comment>
                <scope line="385">
                    <declaration name="e" type="Expression" line="386"/>
                    <declaration name="f" type="Expression" line="387"/>
                </scope>
                <scope line="393"/>
            </method>
            <method name="toString" type="String" line="398"/>
        </class>
    </source>