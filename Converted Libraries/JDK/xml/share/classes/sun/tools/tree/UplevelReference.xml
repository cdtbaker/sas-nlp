<?xml version="1.0" encoding="UTF-8"?>
    <source package="sun.tools.tree">
        <import package="sun.tools.java"/>
        <import package="sun.tools.tree"/>
        <import package="sun.tools.asm.Assembler"/>
        <class name="UplevelReference" line="5">
            <implements interface="Constants"/>
            <javadoc line="5">
                A reference from one scope to another.
                  WARNING: The contents of this source file are not part of any
                  supported API.  Code that depends on them does so at its own risk:
                  they are subject to change or removal without notice.                
            </javadoc>
            <declaration name="client" type="ClassDefinition" line="12"/>
            <javadoc line="12">
                The class in which the reference occurs.                
            </javadoc>
            <declaration name="target" type="LocalMember" line="16"/>
            <javadoc line="16">
                The field being referenced.
                  It is always a final argument or a final local variable.
                  (An uplevel reference to a field of a class C is fetched
                  through an implicit uplevel reference to C.this, which is
                  an argument.)                
            </javadoc>
            <declaration name="localArgument" type="LocalMember" line="24"/>
            <javadoc line="24">
                The local variable which bears a copy of the target&apos;s value,
                  for all methods of the client class.
                  Its name is &quot;this$C&quot; for &lt;code&gt;this.C&lt;/code&gt; or
                  &quot;val$x&quot; for other target variables &lt;code&gt;x&lt;/code&gt;.
                  &lt;p&gt;
                  This local variable is always a constructor argument,
                  and is therefore usable only in the constructor and in initializers.
                  All other methods use the local field.                
                <see>
                    #localField                    
                </see>
            </javadoc>
            <declaration name="localField" type="MemberDefinition" line="36"/>
            <javadoc line="36">
                A private synthetic field of the client class which
                  bears a copy of the target&apos;s value.
                  The compiler tries to avoid creating it if possible.
                  The field has the same name and type as the localArgument.                
                <see>
                    #localArgument                    
                </see>
            </javadoc>
            <declaration name="next" type="UplevelReference" line="44"/>
            <javadoc line="44">
                The next item on the references list of the client.                
            </javadoc>
            <javadoc line="48">
                constructor                
            </javadoc>
            <method name="UplevelReference" type="constructor" line="51">
                <params>
                    <param name="client" type="ClassDefinition"/>
                    <param name="target" type="LocalMember"/>
                </params>
                <declaration name="valName" type="Identifier" line="54"/>
                <scope line="55">
                    <declaration name="tc" type="ClassDefinition" line="56"/>
                    <declaration name="depth" type="int" line="57"/>
                    <scope line="58"/>
                </scope>
                <scope line="63"/>
                <declaration name="base" type="Identifier" line="66"/>
                <declaration name="tick" type="int" line="67"/>
                <scope line="68">
                    <declaration name="failed" type="boolean" line="69"/>
                    <scope line="70">
                        <scope line="71"/>
                    </scope>
                    <scope line="75"/>
                </scope>
            </method>
            <javadoc line="82">
                Insert self into a list of references.
                  Maintain &quot;isEarlierThan&quot; as an invariant of the list.
                  This is important (a) to maximize stability of signatures,
                  and (b) to allow uplevel &quot;this&quot; parameters to come at the
                  front of every argument list they appear in.                
            </javadoc>
            <method name="insertInto" type="UplevelReference" line="89">
                <params>
                    <param name="references" type="UplevelReference"/>
                </params>
                <scope line="90"/>
                <scope line="94">
                    <declaration name="prev" type="UplevelReference" line="95"/>
                    <scope line="96"/>
                </scope>
            </method>
            <javadoc line="104">
                Tells if self precedes the other in the canonical ordering.                
            </javadoc>
            <method name="isEarlierThan" type="boolean" line="107">
                <params>
                    <param name="other" type="UplevelReference"/>
                </params>
                <scope line="108"/>
                <scope line="111"/>
                <declaration name="target2" type="LocalMember" line="114"/>
                <declaration name="name" type="Identifier" line="115"/>
                <declaration name="name2" type="Identifier" line="116"/>
                <declaration name="cmp" type="int" line="117"/>
                <scope line="118"/>
                <declaration name="cname" type="Identifier" line="121"/>
                <declaration name="cname2" type="Identifier" line="122"/>
                <declaration name="ccmp" type="int" line="123"/>
            </method>
            <javadoc line="126">
                the target of this reference                
            </javadoc>
            <method name="getTarget" type="LocalMember" line="129"/>
            <javadoc line="132">
                the local argument for this reference                
            </javadoc>
            <method name="getLocalArgument" type="LocalMember" line="135"/>
            <javadoc line="138">
                the field allocated in the client for this reference                
            </javadoc>
            <method name="getLocalField" type="MemberDefinition" line="141"/>
            <javadoc line="144">
                Get the local field, creating one if necessary.
                  The client class must not be frozen.                
            </javadoc>
            <method name="getLocalField" type="MemberDefinition" line="148">
                <params>
                    <param name="env" type="Environment"/>
                </params>
                <scope line="149"/>
            </method>
            <javadoc line="154">
                the client class                
            </javadoc>
            <method name="getClient" type="ClassDefinition" line="157"/>
            <javadoc line="160">
                the next reference in the client&apos;s list                
            </javadoc>
            <method name="getNext" type="UplevelReference" line="163"/>
            <javadoc line="166">
                Tell if this uplevel reference is the up-level &quot;this&quot; pointer
                  of an inner class.  Such references are treated differently
                  than others, because they affect constructor calls across
                  compilation units.                
            </javadoc>
            <method name="isClientOuterField" type="boolean" line="172">
                <declaration name="outerf" type="MemberDefinition" line="173"/>
            </method>
            <javadoc line="176">
                Tell if my local argument is directly available in this context.
                  If not, the uplevel reference will have to be via a class field.
                  &lt;p&gt;
                  This must be called in a context which is local
                  to the client of the uplevel reference.                
            </javadoc>
            <method name="localArgumentAvailable" type="boolean" line="183">
                <params>
                    <param name="env" type="Environment"/>
                    <param name="ctx" type="Context"/>
                </params>
                <declaration name="reff" type="MemberDefinition" line="184"/>
                <scope line="185"/>
            </method>
            <javadoc line="190">
                Process an uplevel reference.
                  The only decision to make at this point is whether
                  to build a &quot;localField&quot; instance variable, which
                  is done (lazily) when localArgumentAvailable() proves false.                
            </javadoc>
            <method name="noteReference" type="void" line="196">
                <params>
                    <param name="env" type="Environment"/>
                    <param name="ctx" type="Context"/>
                </params>
                <scope line="197"/>
            </method>
            <method name="makeLocalField" type="void" line="201">
                <params>
                    <param name="env" type="Environment"/>
                </params>
                <declaration name="mod" type="int" line="203"/>
            </method>
            <javadoc line="206">
                Assuming noteReference() is all taken care of,
                  build an uplevel reference.
                  &lt;p&gt;
                  This must be called in a context which is local
                  to the client of the uplevel reference.                
            </javadoc>
            <method name="makeLocalReference" type="Expression" line="213">
                <params>
                    <param name="env" type="Environment"/>
                    <param name="ctx" type="Context"/>
                </params>
                <scope line="214"/>
                <scope line="217"/>
                <scope line="220"/>
            </method>
            <javadoc line="224">
                As with makeLocalReference(), build a locally-usable reference.
                  Ignore the availability of local arguments; always use a class field.                
            </javadoc>
            <method name="makeFieldReference" type="Expression" line="228">
                <params>
                    <param name="env" type="Environment"/>
                    <param name="ctx" type="Context"/>
                </params>
                <declaration name="e" type="Expression" line="229"/>
            </method>
            <javadoc line="232">
                During the inline phase, call this on a list of references
                  for which the code phase will later emit arguments.
                  It will make sure that any &quot;double-uplevel&quot; values
                  needed by the callee are also present at the call site.
                  &lt;p&gt;
                  If any reference is a &quot;ClientOuterField&quot;, it is skipped
                  by this method (and by willCodeArguments).  This is because                
            </javadoc>
            <method name="willCodeArguments" type="void" line="241">
                <params>
                    <param name="env" type="Environment"/>
                    <param name="ctx" type="Context"/>
                </params>
                <scope line="242"/>
                <scope line="245"/>
            </method>
            <javadoc line="249">
                Code is being generated for a call to a constructor of
                  the client class.  Push an argument for the constructor.                
            </javadoc>
            <method name="codeArguments" type="void" line="253">
                <params>
                    <param name="env" type="Environment"/>
                    <param name="ctx" type="Context"/>
                    <param name="asm" type="Assembler"/>
                    <param name="where" type="long"/>
                    <param name="conField" type="MemberDefinition"/>
                </params>
                <scope line="254">
                    <declaration name="e" type="Expression" line="255"/>
                </scope>
                <scope line="258"/>
            </method>
            <javadoc line="262">
                Code is being generated for a constructor of the client class.
                  Emit code which initializes the instance.                
            </javadoc>
            <method name="codeInitialization" type="void" line="266">
                <params>
                    <param name="env" type="Environment"/>
                    <param name="ctx" type="Context"/>
                    <param name="asm" type="Assembler"/>
                    <param name="where" type="long"/>
                    <param name="conField" type="MemberDefinition"/>
                </params>
                <scope line="267">
                    <declaration name="e" type="Expression" line="268"/>
                    <declaration name="f" type="Expression" line="269"/>
                </scope>
                <scope line="274"/>
            </method>
            <method name="toString" type="String" line="278"/>
        </class>
    </source>