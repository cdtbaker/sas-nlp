<?xml version="1.0" encoding="UTF-8"?>
    <source package="sun.tools.tree">
        <import package="sun.tools.java"/>
        <class name="Vset" line="30">
            <comment line="38">
                DA bits for first 64 variables                
            </comment>
            <comment line="39">
                DU bits for first 64 variables                
            </comment>
            <comment line="41">
                The extension array is interleaved, consisting of alternating
                 blocks of 64 DA bits followed by 64 DU bits followed by 64 DA
                 bits, and so on.                
            </comment>
            <comment line="45">
                extension array for more bits                
            </comment>
            <comment line="47">
                An infinite vector of zeroes or an infinite vector of ones is
                 represented by a special value of the extension array.
                
                 IMPORTANT: The condition &apos;this.x == fullX&apos; is used as a marker for
                 unreachable code, i.e., for a dead-end.  We maintain the invariant
                 that (this.x != fullX || (this.vset == -1 &amp;&amp; this.uset == -1)).
                 A dead-end has the peculiar property that all variables are both
                 definitely assigned and definitely unassigned.  We always force this
                 condition to hold, even when the normal bitvector operations performed
                 during DA/DU analysis would produce a different result.  This supresses
                 reporting of DA/DU errors in unreachable code.                
            </comment>
            <comment line="59">
                all zeroes                
            </comment>
            <comment line="60">
                all ones                
            </comment>
            <comment line="62">
                For more thorough testing of long vset support, it is helpful to
                 temporarily redefine this value to a smaller number, such as 1 or 2.                
            </comment>
            <comment line="65">
                number of bits in vset (uset)                
            </comment>
            <implements interface="Constants"/>
            <javadoc line="30">
                WARNING: The contents of this source file are not part of any
                  supported API.  Code that depends on them does so at its own risk:
                  they are subject to change or removal without notice.                
            </javadoc>
            <declaration name="vset" type="long" line="37"/>
            <declaration name="uset" type="long" line="38"/>
            <declaration name="x" type="long" line="44"/>
            <declaration name="emptyX" type="long" line="58"/>
            <declaration name="fullX" type="long" line="59"/>
            <declaration name="VBITS" type="int" line="64"/>
            <declaration name="DEAD_END" type="Vset" line="66"/>
            <javadoc line="66">
                This is the Vset which reports all vars assigned and unassigned.
                  This impossibility is degenerately true exactly when
                  control flow cannot reach this point.                
            </javadoc>
            <javadoc line="80">
                Create an empty Vset.                
            </javadoc>
            <method name="Vset" type="constructor" line="83"/>
            <method name="Vset" type="constructor" line="87">
                <params>
                    <param name="vset" type="long"/>
                    <param name="uset" type="long"/>
                    <param name="x" type="long"/>
                </params>
            </method>
            <javadoc line="93">
                Create an copy of the given Vset.
                  (However, DEAD_END simply returns itself.)                
            </javadoc>
            <method name="copy" type="Vset" line="97">
                <comment line="104">
                    recopy the extension vector                    
                </comment>
                <scope line="98"/>
                <declaration name="vs" type="Vset" line="101"/>
                <scope line="102"/>
            </method>
            <method name="growX" type="void" line="108">
                <params>
                    <param name="length" type="int"/>
                </params>
                <declaration name="newX" type="long" line="109"/>
                <declaration name="oldX" type="long" line="110"/>
                <scope line="111"/>
            </method>
            <javadoc line="117">
                Ask if this is a vset for a dead end.
                  Answer true only for the canonical dead-end, DEAD_END.
                  A canonical dead-end is produced only as a result of
                  a statement that cannot complete normally, as specified
                  by the JLS.  Due to the special-case rules for if-then
                  and if-then-else, this may fail to detect actual unreachable
                  code that could easily be identified.                
            </javadoc>
            <method name="isDeadEnd" type="boolean" line="127"/>
            <javadoc line="131">
                Ask if this is a vset for a dead end.
                  Answer true for any dead-end.
                  Since &apos;clearDeadEnd&apos; has no effect on this predicate,
                  if-then and if-then-else are handled in the more &apos;obvious&apos;
                  and precise way.  This predicate is to be preferred for
                  dead code elimination purposes.
                  (Presently used in workaround for bug 4173473 in MethodExpression.java)                
            </javadoc>
            <method name="isReallyDeadEnd" type="boolean" line="140"/>
            <javadoc line="144">
                Replace canonical DEAD_END with a distinct but
                  equivalent Vset.  The bits are unaltered, but
                  the result does not answer true to &apos;isDeadEnd&apos;.
                  &lt;p&gt;
                  Used mostly for error recovery, but see
                  &apos;IfStatement.check&apos;, where it is used to
                  implement the special-case treatment of
                  statement reachability for such statements.                
            </javadoc>
            <method name="clearDeadEnd" type="Vset" line="154">
                <scope line="155"/>
            </method>
            <javadoc line="161">
                Ask if a var is definitely assigned.                
            </javadoc>
            <method name="testVar" type="boolean" line="164">
                <params>
                    <param name="varNumber" type="int"/>
                </params>
                <declaration name="bit" type="long" line="165"/>
                <scope line="166">
                    <declaration name="i" type="int" line="167"/>
                    <scope line="168"/>
                </scope>
                <scope line="172"/>
            </method>
            <javadoc line="177">
                Ask if a var is definitely un-assigned.
                  (This is not just the negation of testVar:
                  It&apos;s possible for neither to be true.)                
            </javadoc>
            <method name="testVarUnassigned" type="boolean" line="182">
                <params>
                    <param name="varNumber" type="int"/>
                </params>
                <comment line="186">
                    index &quot;uset&quot; extension                    
                </comment>
                <declaration name="bit" type="long" line="183"/>
                <scope line="184">
                    <declaration name="i" type="int" line="186"/>
                    <scope line="187"/>
                </scope>
                <scope line="191"/>
            </method>
            <javadoc line="196">
                Note that a var is definitely assigned.
                  (Side-effecting.)                
            </javadoc>
            <method name="addVar" type="Vset" line="200">
                <params>
                    <param name="varNumber" type="int"/>
                </params>
                <comment line="206">
                    gen DA, kill DU                    
                </comment>
                <scope line="201"/>
                <declaration name="bit" type="long" line="207"/>
                <scope line="208">
                    <declaration name="i" type="int" line="209"/>
                    <scope line="210"/>
                    <scope line="214"/>
                </scope>
                <scope line="217"/>
            </method>
            <javadoc line="224">
                Note that a var is definitely un-assigned.
                  (Side-effecting.)                
            </javadoc>
            <method name="addVarUnassigned" type="Vset" line="228">
                <params>
                    <param name="varNumber" type="int"/>
                </params>
                <comment line="234">
                    gen DU, kill DA                    
                </comment>
                <comment line="238">
                    index &quot;uset&quot; extension                    
                </comment>
                <scope line="229"/>
                <declaration name="bit" type="long" line="235"/>
                <scope line="236">
                    <declaration name="i" type="int" line="238"/>
                    <scope line="239"/>
                </scope>
                <scope line="244"/>
            </method>
            <javadoc line="251">
                Retract any assertion about the var.
                  This operation is ineffective on a dead-end.
                  (Side-effecting.)                
            </javadoc>
            <method name="clearVar" type="Vset" line="256">
                <params>
                    <param name="varNumber" type="int"/>
                </params>
                <scope line="257"/>
                <declaration name="bit" type="long" line="260"/>
                <scope line="261">
                    <declaration name="i" type="int" line="262"/>
                    <scope line="263"/>
                    <scope line="267"/>
                </scope>
                <scope line="270"/>
            </method>
            <javadoc line="277">
                Join with another vset.  This is set intersection.
                  (Side-effecting.)                
            </javadoc>
            <method name="join" type="Vset" line="281">
                <params>
                    <param name="other" type="Vset"/>
                </params>
                <comment line="284">
                    Return a dead-end if both vsets are dead-ends.
                     Return the canonical DEAD_END only if both vsets
                     are the canonical DEAD_END.  Otherwise, an incoming
                     dead-end vset has already produced an error message,
                     and is now assumed to be reachable.                    
                </comment>
                <comment line="302">
                    DA = DA intersection DA
                     DU = DU intersection DU                    
                </comment>
                <comment line="311">
                    ASSERT(otherX.length &gt; 0);                    
                </comment>
                <comment line="318">
                    If self is longer than other, all remaining
                     bits are implicitly 0.  In the result, then,
                     the remaining DA and DU bits are cleared.                    
                </comment>
                <scope line="288"/>
                <scope line="291"/>
                <scope line="294"/>
                <scope line="297"/>
                <scope line="307"/>
                <scope line="309">
                    <declaration name="otherX" type="long" line="311"/>
                    <declaration name="selfLength" type="int" line="312"/>
                    <declaration name="limit" type="int" line="313"/>
                    <scope line="314"/>
                    <scope line="320"/>
                </scope>
            </method>
            <javadoc line="327">
                Add in the definite assignment bits of another vset,
                  but join the definite unassignment bits.  This unusual
                  operation is used only for &apos;finally&apos; blocks.  The
                  original vset &apos;this&apos; is destroyed by this operation.
                  (Part of fix for 4068688.)                
            </javadoc>
            <method name="addDAandJoinDU" type="Vset" line="335">
                <params>
                    <param name="other" type="Vset"/>
                </params>
                <comment line="338">
                    Return a dead-end if either vset is a dead end.
                     If either vset is the canonical DEAD_END, the
                     result is also the canonical DEAD_END.                    
                </comment>
                <comment line="354">
                    DA = DA union DA&apos;
                     DU = (DU intersection DU&apos;) - DA&apos;                    
                </comment>
                <comment line="365">
                    ASSERT(otherX.length &gt; 0);                    
                </comment>
                <comment line="378">
                    If self is longer than other, all remaining
                     bits are implicitly 0. In the result, then,
                     the remaining DA bits are left unchanged, and
                     the DU bits are all cleared. First, align
                     index to the next block of DU bits (odd index).                    
                </comment>
                <scope line="340"/>
                <scope line="343"/>
                <scope line="346"/>
                <scope line="349"/>
                <declaration name="selfLength" type="int" line="359"/>
                <declaration name="otherX" type="long" line="360"/>
                <declaration name="otherLength" type="int" line="361"/>
                <scope line="363">
                    <scope line="365"/>
                    <declaration name="i" type="int" line="368"/>
                    <scope line="369"/>
                </scope>
                <scope line="382"/>
            </method>
            <javadoc line="389">
                Construct a vset consisting of the DA bits of the first argument
                  and the DU bits of the second argument.  This is a higly unusual
                  operation, as it implies a case where the flowgraph for DA analysis
                  differs from that for DU analysis.  It is only needed for analysing
                  &apos;try&apos; blocks.  The result is a dead-end iff the first argument is
                  dead-end. (Part of fix for 4068688.)                
            </javadoc>
            <method name="firstDAandSecondDU" type="Vset" line="398">
                <params>
                    <param name="sourceDA" type="Vset"/>
                    <param name="sourceDU" type="Vset"/>
                </params>
                <comment line="401">
                    Note that reachability status is received via &apos;sourceDA&apos; only!
                     This is a consequence of the fact that reachability and DA
                     analysis are performed on an identical flow graph, whereas the
                     flowgraph for DU analysis differs in the case of a &apos;try&apos; statement.                    
                </comment>
                <scope line="404"/>
                <declaration name="sourceDAx" type="long" line="408"/>
                <declaration name="lenDA" type="int" line="409"/>
                <declaration name="sourceDUx" type="long" line="410"/>
                <declaration name="lenDU" type="int" line="411"/>
                <declaration name="limit" type="int" line="412"/>
                <declaration name="x" type="long" line="413"/>
                <scope line="415">
                    <scope line="417"/>
                    <scope line="420"/>
                </scope>
            </method>
            <javadoc line="428">
                Remove variables from the vset that are no longer part of
                  a context.  Zeroes are stored past varNumber.
                  (Side-effecting.)&lt;p&gt;
                  However, if this is a dead end, keep it so.
                  That is, leave an infinite tail of bits set.                
            </javadoc>
            <method name="removeAdditionalVars" type="Vset" line="435">
                <params>
                    <param name="varNumber" type="int"/>
                </params>
                <comment line="446">
                    do the &quot;uset&quot; extension also                    
                </comment>
                <scope line="436"/>
                <declaration name="bit" type="long" line="439"/>
                <scope line="440">
                    <declaration name="i" type="int" line="441"/>
                    <scope line="442">
                        <scope line="444"/>
                        <scope line="447"/>
                    </scope>
                </scope>
                <scope line="451">
                    <scope line="452"/>
                </scope>
            </method>
            <javadoc line="461">
                Return one larger than the highest bit set.                
            </javadoc>
            <method name="varLimit" type="int" line="464">
                <comment line="470">
                    oops                    
                </comment>
                <comment line="473">
                    check the &quot;uset&quot; also                    
                </comment>
                <comment line="481">
                    check the &quot;uset&quot; also                    
                </comment>
                <declaration name="vset" type="long" line="465"/>
                <declaration name="result" type="int" line="466"/>
                <scope line="467">
                    <scope line="468">
                        <scope line="471"/>
                        <scope line="474"/>
                    </scope>
                    <scope line="481"/>
                    <scope line="484"/>
                </scope>
                <scope line="488"/>
            </method>
            <method name="toString" type="String" line="495">
                <comment line="508">
                    not definitely unassigned                    
                </comment>
                <declaration name="sb" type="StringBuffer" line="498"/>
                <declaration name="maxVar" type="int" line="499"/>
                <scope line="500">
                    <scope line="501">
                        <scope line="502"/>
                        <scope line="506"/>
                    </scope>
                </scope>
                <scope line="511"/>
            </method>
        </class>
    </source>