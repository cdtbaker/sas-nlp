<?xml version="1.0" encoding="UTF-8"?>
    <source package="sun.tools.tree">
        <import package="sun.tools.java"/>
        <class name="Vset" line="3">
            <implements interface="Constants"/>
            <javadoc line="3">
                WARNING: The contents of this source file are not part of any
                  supported API.  Code that depends on them does so at its own risk:
                  they are subject to change or removal without notice.                
            </javadoc>
            <declaration name="vset" type="long" line="9"/>
            <declaration name="uset" type="long" line="10"/>
            <declaration name="x" type="long" line="11"/>
            <declaration name="emptyX" type="long" line="12"/>
            <declaration name="fullX" type="long" line="13"/>
            <declaration name="VBITS" type="int" line="14"/>
            <declaration name="DEAD_END" type="Vset" line="15"/>
            <javadoc line="15">
                This is the Vset which reports all vars assigned and unassigned.
                  This impossibility is degenerately true exactly when
                  control flow cannot reach this point.                
            </javadoc>
            <javadoc line="21">
                Create an empty Vset.                
            </javadoc>
            <method name="Vset" type="constructor" line="24"/>
            <method name="Vset" type="constructor" line="27">
                <params>
                    <param name="vset" type="long"/>
                    <param name="uset" type="long"/>
                    <param name="x" type="long"/>
                </params>
            </method>
            <javadoc line="32">
                Create an copy of the given Vset.
                  (However, DEAD_END simply returns itself.)                
            </javadoc>
            <method name="copy" type="Vset" line="36">
                <scope line="37"/>
                <declaration name="vs" type="Vset" line="40"/>
                <scope line="41"/>
            </method>
            <method name="growX" type="void" line="46">
                <params>
                    <param name="length" type="int"/>
                </params>
                <declaration name="newX" type="long" line="47"/>
                <declaration name="oldX" type="long" line="48"/>
                <scope line="49"/>
            </method>
            <javadoc line="54">
                Ask if this is a vset for a dead end.
                  Answer true only for the canonical dead-end, DEAD_END.
                  A canonical dead-end is produced only as a result of
                  a statement that cannot complete normally, as specified
                  by the JLS.  Due to the special-case rules for if-then
                  and if-then-else, this may fail to detect actual unreachable
                  code that could easily be identified.                
            </javadoc>
            <method name="isDeadEnd" type="boolean" line="63"/>
            <javadoc line="66">
                Ask if this is a vset for a dead end.
                  Answer true for any dead-end.
                  Since &apos;clearDeadEnd&apos; has no effect on this predicate,
                  if-then and if-then-else are handled in the more &apos;obvious&apos;
                  and precise way.  This predicate is to be preferred for
                  dead code elimination purposes.
                  (Presently used in workaround for bug 4173473 in MethodExpression.java)                
            </javadoc>
            <method name="isReallyDeadEnd" type="boolean" line="75"/>
            <javadoc line="78">
                Replace canonical DEAD_END with a distinct but
                  equivalent Vset.  The bits are unaltered, but
                  the result does not answer true to &apos;isDeadEnd&apos;.
                  &lt;p&gt;
                  Used mostly for error recovery, but see
                  &apos;IfStatement.check&apos;, where it is used to
                  implement the special-case treatment of
                  statement reachability for such statements.                
            </javadoc>
            <method name="clearDeadEnd" type="Vset" line="88">
                <scope line="89"/>
            </method>
            <javadoc line="94">
                Ask if a var is definitely assigned.                
            </javadoc>
            <method name="testVar" type="boolean" line="97">
                <params>
                    <param name="varNumber" type="int"/>
                </params>
                <declaration name="bit" type="long" line="98"/>
                <scope line="99">
                    <declaration name="i" type="int" line="100"/>
                    <scope line="101"/>
                </scope>
                <scope line="106"/>
            </method>
            <javadoc line="110">
                Ask if a var is definitely un-assigned.
                  (This is not just the negation of testVar:
                  It&apos;s possible for neither to be true.)                
            </javadoc>
            <method name="testVarUnassigned" type="boolean" line="115">
                <params>
                    <param name="varNumber" type="int"/>
                </params>
                <declaration name="bit" type="long" line="116"/>
                <scope line="117">
                    <declaration name="i" type="int" line="118"/>
                    <scope line="119"/>
                </scope>
                <scope line="124"/>
            </method>
            <javadoc line="128">
                Note that a var is definitely assigned.
                  (Side-effecting.)                
            </javadoc>
            <method name="addVar" type="Vset" line="132">
                <params>
                    <param name="varNumber" type="int"/>
                </params>
                <scope line="133"/>
                <declaration name="bit" type="long" line="136"/>
                <scope line="137">
                    <declaration name="i" type="int" line="138"/>
                    <scope line="139"/>
                    <scope line="143"/>
                </scope>
                <scope line="147"/>
            </method>
            <javadoc line="153">
                Note that a var is definitely un-assigned.
                  (Side-effecting.)                
            </javadoc>
            <method name="addVarUnassigned" type="Vset" line="157">
                <params>
                    <param name="varNumber" type="int"/>
                </params>
                <scope line="158"/>
                <declaration name="bit" type="long" line="161"/>
                <scope line="162">
                    <declaration name="i" type="int" line="163"/>
                    <scope line="164"/>
                </scope>
                <scope line="170"/>
            </method>
            <javadoc line="176">
                Retract any assertion about the var.
                  This operation is ineffective on a dead-end.
                  (Side-effecting.)                
            </javadoc>
            <method name="clearVar" type="Vset" line="181">
                <params>
                    <param name="varNumber" type="int"/>
                </params>
                <scope line="182"/>
                <declaration name="bit" type="long" line="185"/>
                <scope line="186">
                    <declaration name="i" type="int" line="187"/>
                    <scope line="188"/>
                    <scope line="192"/>
                </scope>
                <scope line="196"/>
            </method>
            <javadoc line="202">
                Join with another vset.  This is set intersection.
                  (Side-effecting.)                
            </javadoc>
            <method name="join" type="Vset" line="206">
                <params>
                    <param name="other" type="Vset"/>
                </params>
                <scope line="207"/>
                <scope line="210"/>
                <scope line="213"/>
                <scope line="216"/>
                <scope line="221"/>
                <scope line="224">
                    <declaration name="otherX" type="long" line="225"/>
                    <declaration name="selfLength" type="int" line="226"/>
                    <declaration name="limit" type="int" line="227"/>
                    <scope line="228"/>
                    <scope line="231"/>
                </scope>
            </method>
            <javadoc line="237">
                Add in the definite assignment bits of another vset,
                  but join the definite unassignment bits.  This unusual
                  operation is used only for &apos;finally&apos; blocks.  The
                  original vset &apos;this&apos; is destroyed by this operation.
                  (Part of fix for 4068688.)                
            </javadoc>
            <method name="addDAandJoinDU" type="Vset" line="244">
                <params>
                    <param name="other" type="Vset"/>
                </params>
                <scope line="245"/>
                <scope line="248"/>
                <scope line="251"/>
                <scope line="254"/>
                <declaration name="selfLength" type="int" line="259"/>
                <declaration name="otherX" type="long" line="260"/>
                <declaration name="otherLength" type="int" line="261"/>
                <scope line="262">
                    <scope line="263"/>
                    <declaration name="i" type="int" line="266"/>
                    <scope line="267"/>
                </scope>
                <scope line="275"/>
            </method>
            <javadoc line="280">
                Construct a vset consisting of the DA bits of the first argument
                  and the DU bits of the second argument.  This is a higly unusual
                  operation, as it implies a case where the flowgraph for DA analysis
                  differs from that for DU analysis.  It is only needed for analysing
                  &apos;try&apos; blocks.  The result is a dead-end iff the first argument is
                  dead-end. (Part of fix for 4068688.)                
            </javadoc>
            <method name="firstDAandSecondDU" type="Vset" line="288">
                <params>
                    <param name="sourceDA" type="Vset"/>
                    <param name="sourceDU" type="Vset"/>
                </params>
                <scope line="289"/>
                <declaration name="sourceDAx" type="long" line="292"/>
                <declaration name="lenDA" type="int" line="293"/>
                <declaration name="sourceDUx" type="long" line="294"/>
                <declaration name="lenDU" type="int" line="295"/>
                <declaration name="limit" type="int" line="296"/>
                <declaration name="x" type="long" line="297"/>
                <scope line="298">
                    <scope line="300"/>
                    <scope line="303"/>
                </scope>
            </method>
            <javadoc line="309">
                Remove variables from the vset that are no longer part of
                  a context.  Zeroes are stored past varNumber.
                  (Side-effecting.)&lt;p&gt;
                  However, if this is a dead end, keep it so.
                  That is, leave an infinite tail of bits set.                
            </javadoc>
            <method name="removeAdditionalVars" type="Vset" line="316">
                <params>
                    <param name="varNumber" type="int"/>
                </params>
                <scope line="317"/>
                <declaration name="bit" type="long" line="320"/>
                <scope line="321">
                    <declaration name="i" type="int" line="322"/>
                    <scope line="323">
                        <scope line="325"/>
                        <scope line="328"/>
                    </scope>
                </scope>
                <scope line="333">
                    <scope line="334"/>
                </scope>
            </method>
            <javadoc line="342">
                Return one larger than the highest bit set.                
            </javadoc>
            <method name="varLimit" type="int" line="345">
                <declaration name="vset" type="long" line="346"/>
                <declaration name="result" type="int" line="347"/>
                <scope line="348">
                    <scope line="349">
                        <scope line="352"/>
                        <scope line="355"/>
                    </scope>
                    <scope line="362"/>
                    <scope line="366"/>
                </scope>
                <scope line="370"/>
            </method>
            <method name="toString" type="String" line="376">
                <declaration name="sb" type="StringBuffer" line="378"/>
                <declaration name="maxVar" type="int" line="379"/>
                <scope line="380">
                    <scope line="381">
                        <scope line="382"/>
                        <scope line="386"/>
                    </scope>
                </scope>
                <scope line="391"/>
            </method>
        </class>
    </source>