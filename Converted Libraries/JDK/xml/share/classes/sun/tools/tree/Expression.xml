<?xml version="1.0" encoding="UTF-8"?>
    <source package="sun.tools.tree">
        <import package="sun.tools.java"/>
        <import package="sun.tools.asm.Label"/>
        <import package="sun.tools.asm.Assembler"/>
        <import package="java.io.PrintStream"/>
        <import package="java.util.Hashtable"/>
        <class name="Expression" line="34">
            <extends class="Node"/>
            <comment line="149">
                Convert an expresion to a type in a context where a qualified
                 type name is expected, e.g., in the prefix of a qualified type
                 name.                
            </comment>
            <comment line="154">
                -----------------------------------------------------
                Type toQualifiedType(Environment env, Context ctx) {
                env.error(where, &quot;invalid.type.expr&quot;);
                return Type.tError;
                }                
            </comment>
            <comment line="287">
                Check a condition.
                
                 cvars is modified so that
                    cvar.vsTrue indicates variables with a known value if result = true
                    cvars.vsFalse indicates variables with a known value if !result
                
                 The default action is to simply call checkValue on the expression, and
                 to see both vsTrue and vsFalse to the result.                
            </comment>
            <javadoc line="34">
                WARNING: The contents of this source file are not part of any
                  supported API.  Code that depends on them does so at its own risk:
                  they are subject to change or removal without notice.                
            </javadoc>
            <declaration name="type" type="Type" line="41"/>
            <javadoc line="43">
                Constructor                
            </javadoc>
            <method name="Expression" type="constructor" line="46">
                <params>
                    <param name="op" type="int"/>
                    <param name="where" type="long"/>
                    <param name="type" type="Type"/>
                </params>
            </method>
            <javadoc line="51">
                Type checking may assign a more complex implementation
                  to an innocuous-looking expression (like an identifier).
                  Return that implementation, or the original expression itself
                  if there is no special implementation.
                  &lt;p&gt;
                  This appears at present to be dead code, and is not called
                  from within javac.  Access to the implementation generally
                  occurs within the same class, and thus uses the underlying
                  field directly.                
            </javadoc>
            <method name="getImplementation" type="Expression" line="62"/>
            <method name="getType" type="Type" line="66"/>
            <javadoc line="70">
                Return the precedence of the operator                
            </javadoc>
            <method name="precedence" type="int" line="73"/>
            <javadoc line="77">
                Order the expression based on precedence                
            </javadoc>
            <method name="order" type="Expression" line="80"/>
            <javadoc line="84">
                Return true if constant, according to JLS 15.27.
                  A constant expression must inline away to a literal constant.                
            </javadoc>
            <method name="isConstant" type="boolean" line="88"/>
            <javadoc line="92">
                Return the constant value.                
            </javadoc>
            <method name="getValue" type="Object" line="95"/>
            <javadoc line="99">
                Check if the expression is known to be equal to a given value.
                  Returns false for any expression other than a literal constant,
                  thus should be called only after simplification (inlining) has
                  been performed.                
            </javadoc>
            <method name="equals" type="boolean" line="105">
                <params>
                    <param name="i" type="int"/>
                </params>
            </method>
            <method name="equals" type="boolean" line="108">
                <params>
                    <param name="b" type="boolean"/>
                </params>
            </method>
            <method name="equals" type="boolean" line="111">
                <params>
                    <param name="id" type="Identifier"/>
                </params>
            </method>
            <method name="equals" type="boolean" line="114">
                <params>
                    <param name="s" type="String"/>
                </params>
            </method>
            <javadoc line="118">
                Check if the expression must be a null reference.                
            </javadoc>
            <method name="isNull" type="boolean" line="121"/>
            <javadoc line="125">
                Check if the expression cannot be a null reference.                
            </javadoc>
            <method name="isNonNull" type="boolean" line="128"/>
            <javadoc line="132">
                Check if the expression is equal to its default static value                
            </javadoc>
            <method name="equalsDefault" type="boolean" line="135"/>
            <javadoc line="140">
                Convert an expresion to a type                
            </javadoc>
            <method name="toType" type="Type" line="143">
                <params>
                    <param name="env" type="Environment"/>
                    <param name="ctx" type="Context"/>
                </params>
            </method>
            <javadoc line="160">
                See if this expression fits in the given type.
                  This is useful because some larger numbers fit into
                  smaller types.
                  &lt;p&gt;
                  If it is an &quot;int&quot; constant expression, inline it, if necessary,
                  to examine its numerical value.  See JLS 5.2 and 15.24.                
            </javadoc>
            <method name="fitsType" type="boolean" line="168">
                <params>
                    <param name="env" type="Environment"/>
                    <param name="ctx" type="Context"/>
                    <param name="t" type="Type"/>
                </params>
                <comment line="174">
                    Tentative inlining is harmless for constant expressions.                    
                </comment>
                <scope line="169">
                    <scope line="170"/>
                    <scope line="173">
                        <declaration name="n" type="Expression" line="175"/>
                        <scope line="176"/>
                    </scope>
                </scope>
                <scope line="181"/>
            </method>
            <javadoc line="186">
                @deprecated (for backward compatibility)                
            </javadoc>
            <method name="fitsType" type="boolean" line="188">
                <params>
                    <param name="env" type="Environment"/>
                    <param name="t" type="Type"/>
                </params>
            </method>
            <javadoc line="192">
                Check an expression                
            </javadoc>
            <method name="checkValue" type="Vset" line="195">
                <params>
                    <param name="env" type="Environment"/>
                    <param name="ctx" type="Context"/>
                    <param name="vset" type="Vset"/>
                    <param name="exp" type="Hashtable"/>
                </params>
            </method>
            <method name="checkInitializer" type="Vset" line="198">
                <params>
                    <param name="env" type="Environment"/>
                    <param name="ctx" type="Context"/>
                    <param name="vset" type="Vset"/>
                    <param name="t" type="Type"/>
                    <param name="exp" type="Hashtable"/>
                </params>
            </method>
            <method name="check" type="Vset" line="201">
                <params>
                    <param name="env" type="Environment"/>
                    <param name="ctx" type="Context"/>
                    <param name="vset" type="Vset"/>
                    <param name="exp" type="Hashtable"/>
                </params>
            </method>
            <method name="checkLHS" type="Vset" line="206">
                <params>
                    <param name="env" type="Environment"/>
                    <param name="ctx" type="Context"/>
                    <param name="vset" type="Vset"/>
                    <param name="exp" type="Hashtable"/>
                </params>
            </method>
            <javadoc line="212">
                Return a &lt;code&gt;FieldUpdater&lt;/code&gt; object to be used in updating the
                  value of the location denoted by &lt;code&gt;this&lt;/code&gt;, which must be an
                  expression suitable for the left-hand side of an assignment.
                  This is used for implementing assignments to private fields for which
                  an access method is required.  Returns null if no access method is
                  needed, in which case the assignment is handled in the usual way, by
                  direct access.  Only simple assignment expressions are handled here
                  Assignment operators and pre/post increment/decrement operators are
                  are handled by &apos;getUpdater&apos; below.
                  &lt;p&gt;
                  Called during the checking phase.                
            </javadoc>
            <method name="getAssigner" type="FieldUpdater" line="226">
                <params>
                    <param name="env" type="Environment"/>
                    <param name="ctx" type="Context"/>
                </params>
            </method>
            <javadoc line="230">
                Return a &lt;code&gt;FieldUpdater&lt;/code&gt; object to be used in updating the value of the
                  location denoted by &lt;code&gt;this&lt;/code&gt;, which must be an expression suitable for the
                  left-hand side of an assignment.  This is used for implementing the assignment
                  operators and the increment/decrement operators on private fields that require an
                  access method, e.g., uplevel from an inner class.  Returns null if no access method
                  is needed.
                  &lt;p&gt;
                  Called during the checking phase.                
            </javadoc>
            <method name="getUpdater" type="FieldUpdater" line="241">
                <params>
                    <param name="env" type="Environment"/>
                    <param name="ctx" type="Context"/>
                </params>
            </method>
            <method name="checkAssignOp" type="Vset" line="246">
                <params>
                    <param name="env" type="Environment"/>
                    <param name="ctx" type="Context"/>
                    <param name="vset" type="Vset"/>
                    <param name="exp" type="Hashtable"/>
                    <param name="outside" type="Expression"/>
                </params>
            </method>
            <javadoc line="255">
                Check something that might be an AmbiguousName (refman 6.5.2).
                  A string of dot-separated identifiers might be, in order of preference:
                  &lt;nl&gt;
                  &lt;li&gt; a variable name followed by fields or types
                  &lt;li&gt; a type name followed by fields or types
                  &lt;li&gt; a package name followed a type and then fields or types
                  &lt;/nl&gt;
                  If a type name is found, it rewrites itself as a &lt;tt&gt;TypeExpression&lt;/tt&gt;.
                  If a node decides it can only be a package prefix, it sets its
                  type to &lt;tt&gt;Type.tPackage&lt;/tt&gt;.  The caller must detect this
                  and act appropriately to verify the full package name.                
                <arg>
                    loc the expression containing the ambiguous expression                    
                </arg>
            </javadoc>
            <method name="checkAmbigName" type="Vset" line="270">
                <params>
                    <param name="env" type="Environment"/>
                    <param name="ctx" type="Context"/>
                    <param name="vset" type="Vset"/>
                    <param name="exp" type="Hashtable"/>
                    <param name="loc" type="UnaryExpression"/>
                </params>
            </method>
            <javadoc line="274">
                Check a condition.  Return a ConditionVars(), which indicates when
                  which variables are set if the condition is true, and which are set if
                  the condition is false.                
            </javadoc>
            <method name="checkCondition" type="ConditionVars" line="280">
                <params>
                    <param name="env" type="Environment"/>
                    <param name="ctx" type="Context"/>
                    <param name="vset" type="Vset"/>
                    <param name="exp" type="Hashtable"/>
                </params>
                <declaration name="cvars" type="ConditionVars" line="281"/>
            </method>
            <method name="checkCondition" type="void" line="298">
                <params>
                    <param name="env" type="Environment"/>
                    <param name="ctx" type="Context"/>
                    <param name="vset" type="Vset"/>
                    <param name="exp" type="Hashtable"/>
                    <param name="cvars" type="ConditionVars"/>
                </params>
                <comment line="300">
                    unshare side effects:                    
                </comment>
            </method>
            <javadoc line="304">
                Evaluate.
                  Attempt to compute the value of an expression node.  If all operands are
                  literal constants of the same kind (e.g., IntegerExpression nodes), a
                  new constant node of the proper type is returned representing the value
                  as computed at compile-time.  Otherwise, the original node &apos;this&apos; is
                  returned.                
            </javadoc>
            <method name="eval" type="Expression" line="313"/>
            <javadoc line="317">
                Simplify.
                  Attempt to simplify an expression node by returning a semantically-
                  equivalent expression that is presumably less costly to execute.  There
                  is some overlap with the intent of &apos;eval&apos;, as compile-time evaluation of
                  conditional expressions and the short-circuit boolean operators is
                  performed here.  Other simplifications include logical identities
                  involving logical negation and comparisons.  If no simplification is
                  possible, the original node &apos;this&apos; is returned.  It is assumed that the
                  children of the node have previously been recursively simplified and
                  evaluated.  A result of &apos;null&apos; indicates that the expression may be
                  elided entirely.                
            </javadoc>
            <method name="simplify" type="Expression" line="331"/>
            <javadoc line="335">
                Inline.
                  Recursively simplify each child of an expression node, destructively
                  replacing the child with the simplified result.  Also attempts to
                  simplify the current node &apos;this&apos;, and returns the simplified result.
                  The name &apos;inline&apos; is somthing of a misnomer, as these methods are
                  responsible for compile-time expression simplification in general.
                  The &apos;eval&apos; and &apos;simplify&apos; methods apply to a single expression node
                  only -- it is &apos;inline&apos; and &apos;inlineValue&apos; that drive the simplification
                  of entire expressions.                
            </javadoc>
            <method name="inline" type="Expression" line="348">
                <params>
                    <param name="env" type="Environment"/>
                    <param name="ctx" type="Context"/>
                </params>
            </method>
            <method name="inlineValue" type="Expression" line="351">
                <params>
                    <param name="env" type="Environment"/>
                    <param name="ctx" type="Context"/>
                </params>
            </method>
            <javadoc line="355">
                Attempt to evaluate this expression.  If this expression
                  yields a value, append it to the StringBuffer `buffer&apos;.
                  If this expression cannot be evaluated at this time (for
                  example if it contains a division by zero, a non-constant
                  subexpression, or a subexpression which &quot;refuses&quot; to evaluate)
                  then return `null&apos; to indicate failure.
                  It is anticipated that this method will be called to evaluate
                  concatenations of compile-time constant strings.  The call
                  originates from AddExpression#inlineValue().
                  See AddExpression#inlineValueSB() for detailed comments.                
            </javadoc>
            <method name="inlineValueSB" type="StringBuffer" line="371">
                <params>
                    <param name="env" type="Environment"/>
                    <param name="ctx" type="Context"/>
                    <param name="buffer" type="StringBuffer"/>
                </params>
                <comment line="376">
                    This (supposedly constant) expression refuses to yield                    
                </comment>
                <comment line="377">
                    a value.  This can happen, in particular, when we are                    
                </comment>
                <comment line="378">
                    trying to evaluate a division by zero.  It can also                    
                </comment>
                <comment line="379">
                    happen in cases where isConstant() is able to classify                    
                </comment>
                <comment line="380">
                    expressions as constant that the compiler&apos;s inlining                    
                </comment>
                <comment line="381">
                    mechanisms aren&apos;t able to evaluate; this is rare,                    
                </comment>
                <comment line="382">
                    and all such cases that we have found so far                    
                </comment>
                <comment line="383">
                    (e.g. 4082814, 4106244) have been plugged up.                    
                </comment>
                <comment line="384">
                                        
                </comment>
                <comment line="385">
                    We return a null to indicate that we have failed to                    
                </comment>
                <comment line="386">
                    evaluate the concatenation.                    
                </comment>
                <comment line="390">
                    For boolean and character expressions, getValue() returns                    
                </comment>
                <comment line="391">
                    an Integer.  We need to take care, when appending the result                    
                </comment>
                <comment line="392">
                    of getValue(), that we preserve the type.                    
                </comment>
                <comment line="393">
                    Fix for 4103959, 4102672.                    
                </comment>
                <declaration name="inlined" type="Expression" line="372"/>
                <declaration name="val" type="Object" line="373"/>
                <scope line="375"/>
                <scope line="394"/>
                <scope line="396"/>
                <scope line="398"/>
            </method>
            <method name="inlineLHS" type="Expression" line="405">
                <params>
                    <param name="env" type="Environment"/>
                    <param name="ctx" type="Context"/>
                </params>
            </method>
            <javadoc line="409">
                The cost of inlining this expression.
                  This cost controls the inlining of methods, and does not determine
                  the compile-time simplifications performed by &apos;inline&apos; and friends.                
            </javadoc>
            <method name="costInline" type="int" line="414">
                <params>
                    <param name="thresh" type="int"/>
                    <param name="env" type="Environment"/>
                    <param name="ctx" type="Context"/>
                </params>
            </method>
            <javadoc line="418">
                Code                
            </javadoc>
            <method name="codeBranch" type="void" line="421">
                <params>
                    <param name="env" type="Environment"/>
                    <param name="ctx" type="Context"/>
                    <param name="asm" type="Assembler"/>
                    <param name="lbl" type="Label"/>
                    <param name="whenTrue" type="boolean"/>
                </params>
                <scope line="422"/>
                <scope line="425"/>
            </method>
            <method name="codeValue" type="void" line="429">
                <params>
                    <param name="env" type="Environment"/>
                    <param name="ctx" type="Context"/>
                    <param name="asm" type="Assembler"/>
                </params>
                <scope line="430">
                    <declaration name="l1" type="Label" line="431"/>
                    <declaration name="l2" type="Label" line="432"/>
                </scope>
                <scope line="440"/>
            </method>
            <method name="code" type="void" line="444">
                <params>
                    <param name="env" type="Environment"/>
                    <param name="ctx" type="Context"/>
                    <param name="asm" type="Assembler"/>
                </params>
            </method>
            <method name="codeLValue" type="int" line="461">
                <params>
                    <param name="env" type="Environment"/>
                    <param name="ctx" type="Context"/>
                    <param name="asm" type="Assembler"/>
                </params>
            </method>
            <method name="codeLoad" type="void" line="465">
                <params>
                    <param name="env" type="Environment"/>
                    <param name="ctx" type="Context"/>
                    <param name="asm" type="Assembler"/>
                </params>
            </method>
            <method name="codeStore" type="void" line="469">
                <params>
                    <param name="env" type="Environment"/>
                    <param name="ctx" type="Context"/>
                    <param name="asm" type="Assembler"/>
                </params>
            </method>
            <javadoc line="474">
                Convert this expression to a string.                
            </javadoc>
            <method name="ensureString" type="void" line="479">
                <params>
                    <param name="env" type="Environment"/>
                    <param name="ctx" type="Context"/>
                    <param name="asm" type="Assembler"/>
                </params>
                <comment line="483">
                    Make sure it&apos;s a non-null string.                    
                </comment>
                <comment line="487">
                    FIX FOR 4071548                    
                </comment>
                <comment line="488">
                    We use &apos;String.valueOf&apos; to do the conversion, in order to                    
                </comment>
                <comment line="489">
                    correctly handle null references and efficiently handle                    
                </comment>
                <comment line="490">
                    primitive types.  For reference types, we force the argument                    
                </comment>
                <comment line="491">
                    to be interpreted as of &apos;Object&apos; type, thus avoiding the                    
                </comment>
                <comment line="492">
                    the special-case overloading of &apos;valueOf&apos; for character arrays.                    
                </comment>
                <comment line="493">
                    This special treatment would conflict with JLS 15.17.1.1.                    
                </comment>
                <comment line="495">
                    Reference type                    
                </comment>
                <comment line="497">
                    Convert non-string object to string.  If object is                    
                </comment>
                <comment line="498">
                    a string, we don&apos;t need to convert it, except in the                    
                </comment>
                <comment line="499">
                    case that it is null, which is handled below.                    
                </comment>
                <comment line="505">
                    FIX FOR 4030173                    
                </comment>
                <comment line="506">
                    If the argument was null, then value is &quot;null&quot;, but if the                    
                </comment>
                <comment line="507">
                    argument was not null, &apos;toString&apos; was called and could have                    
                </comment>
                <comment line="508">
                    returned null.  We call &apos;valueOf&apos; again to make sure that                    
                </comment>
                <comment line="509">
                    the result is a non-null string.  See JLS 15.17.1.1.  The                    
                </comment>
                <comment line="510">
                    approach taken here minimizes code size -- open code would                    
                </comment>
                <comment line="511">
                    be faster.  The &apos;toString&apos; method for an array class cannot                    
                </comment>
                <comment line="512">
                    be overridden, thus we know that it will never return null.                    
                </comment>
                <comment line="520">
                    Primitive type                    
                </comment>
                <scope line="480"/>
                <declaration name="sourceClass" type="ClassDefinition" line="484"/>
                <declaration name="stClass" type="ClassDeclaration" line="485"/>
                <declaration name="stClsDef" type="ClassDefinition" line="486"/>
                <scope line="494">
                    <scope line="496">
                        <declaration name="argType1" type="Type" line="500"/>
                        <declaration name="f1" type="MemberDefinition" line="501"/>
                    </scope>
                    <scope line="513">
                        <declaration name="argType2" type="Type" line="514"/>
                        <declaration name="f2" type="MemberDefinition" line="515"/>
                    </scope>
                </scope>
                <scope line="519">
                    <declaration name="argType" type="Type" line="521"/>
                    <declaration name="f" type="MemberDefinition" line="522"/>
                </scope>
            </method>
            <javadoc line="528">
                Convert this expression to a string and append it to the string
                  buffer on the top of the stack.
                  If the needBuffer argument is true, the string buffer needs to be
                  created, initialized, and pushed on the stack, first.                
            </javadoc>
            <method name="codeAppend" type="void" line="537">
                <params>
                    <param name="env" type="Environment"/>
                    <param name="ctx" type="Context"/>
                    <param name="asm" type="Assembler"/>
                    <param name="sbClass" type="ClassDeclaration"/>
                    <param name="needBuffer" type="boolean"/>
                </params>
                <comment line="542">
                    need to create the string buffer                    
                </comment>
                <comment line="543">
                    create the class                    
                </comment>
                <comment line="546">
                    make an empty string buffer                    
                </comment>
                <comment line="549">
                    optimize by initializing the buffer with the string                    
                </comment>
                <comment line="557">
                    append this item to the string buffer                    
                </comment>
                <comment line="559">
                    FIX FOR 4071548                    
                </comment>
                <comment line="560">
                    &apos;StringBuffer.append&apos; converts its argument as if by                    
                </comment>
                <comment line="561">
                    &apos;valueOf&apos;, treating character arrays specially.  This                    
                </comment>
                <comment line="562">
                    violates JLS 15.17.1.1, which requires that concatenation                    
                </comment>
                <comment line="563">
                    convert non-primitive arguments using &apos;toString&apos;.  We force                    
                </comment>
                <comment line="564">
                    the treatment of all reference types as type &apos;Object&apos;, thus                    
                </comment>
                <comment line="565">
                    invoking an overloading of &apos;append&apos; that has the required                    
                </comment>
                <comment line="566">
                    semantics.                    
                </comment>
                <declaration name="sourceClass" type="ClassDefinition" line="538"/>
                <declaration name="sbClsDef" type="ClassDefinition" line="539"/>
                <declaration name="f" type="MemberDefinition" line="540"/>
                <scope line="541">
                    <scope line="545"/>
                    <scope line="548">
                        <declaration name="argType" type="Type" line="552"/>
                    </scope>
                </scope>
                <scope line="556">
                    <declaration name="argType" type="Type" line="567"/>
                </scope>
            </method>
            <javadoc line="576">
                Code                
            </javadoc>
            <method name="codeDup" type="void" line="579">
                <params>
                    <param name="env" type="Environment"/>
                    <param name="ctx" type="Context"/>
                    <param name="asm" type="Assembler"/>
                    <param name="items" type="int"/>
                    <param name="depth" type="int"/>
                </params>
            </method>
            <method name="codeConversion" type="void" line="616">
                <params>
                    <param name="env" type="Environment"/>
                    <param name="ctx" type="Context"/>
                    <param name="asm" type="Assembler"/>
                    <param name="f" type="Type"/>
                    <param name="t" type="Type"/>
                </params>
                <declaration name="from" type="int" line="617"/>
                <declaration name="to" type="int" line="618"/>
                <scope line="622"/>
                <scope line="627"/>
                <scope line="633"/>
                <scope line="639"/>
                <scope line="723">
                    <scope line="724"/>
                </scope>
                <scope line="727"/>
                <scope line="741">
                    <scope line="742"/>
                </scope>
                <scope line="746"/>
            </method>
            <javadoc line="755">
                Check if the first thing is a constructor invocation                
            </javadoc>
            <method name="firstConstructor" type="Expression" line="758"/>
            <javadoc line="762">
                Create a copy of the expression for method inlining                
            </javadoc>
            <method name="copyInline" type="Expression" line="765">
                <params>
                    <param name="ctx" type="Context"/>
                </params>
            </method>
            <javadoc line="769">
                Print                
            </javadoc>
            <method name="print" type="void" line="772">
                <params>
                    <param name="out" type="PrintStream"/>
                </params>
            </method>
        </class>
    </source>