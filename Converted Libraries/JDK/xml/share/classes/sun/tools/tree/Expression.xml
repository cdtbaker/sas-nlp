<?xml version="1.0" encoding="UTF-8"?>
    <source package="sun.tools.tree">
        <import package="sun.tools.java"/>
        <import package="sun.tools.asm.Label"/>
        <import package="sun.tools.asm.Assembler"/>
        <import package="java.io.PrintStream"/>
        <import package="java.util.Hashtable"/>
        <class name="Expression" line="7">
            <extends class="Node"/>
            <javadoc line="7">
                WARNING: The contents of this source file are not part of any
                  supported API.  Code that depends on them does so at its own risk:
                  they are subject to change or removal without notice.                
            </javadoc>
            <declaration name="type" type="Type" line="13"/>
            <javadoc line="14">
                Constructor                
            </javadoc>
            <method name="Expression" type="constructor" line="17">
                <params>
                    <param name="op" type="int"/>
                    <param name="where" type="long"/>
                    <param name="type" type="Type"/>
                </params>
            </method>
            <javadoc line="21">
                Type checking may assign a more complex implementation
                  to an innocuous-looking expression (like an identifier).
                  Return that implementation, or the original expression itself
                  if there is no special implementation.
                  &lt;p&gt;
                  This appears at present to be dead code, and is not called
                  from within javac.  Access to the implementation generally
                  occurs within the same class, and thus uses the underlying
                  field directly.                
            </javadoc>
            <method name="getImplementation" type="Expression" line="32"/>
            <method name="getType" type="Type" line="35"/>
            <javadoc line="38">
                Return the precedence of the operator                
            </javadoc>
            <method name="precedence" type="int" line="41"/>
            <javadoc line="44">
                Order the expression based on precedence                
            </javadoc>
            <method name="order" type="Expression" line="47"/>
            <javadoc line="50">
                Return true if constant, according to JLS 15.27.
                  A constant expression must inline away to a literal constant.                
            </javadoc>
            <method name="isConstant" type="boolean" line="54"/>
            <javadoc line="57">
                Return the constant value.                
            </javadoc>
            <method name="getValue" type="Object" line="60"/>
            <javadoc line="63">
                Check if the expression is known to be equal to a given value.
                  Returns false for any expression other than a literal constant,
                  thus should be called only after simplification (inlining) has
                  been performed.                
            </javadoc>
            <method name="equals" type="boolean" line="69">
                <params>
                    <param name="i" type="int"/>
                </params>
            </method>
            <method name="equals" type="boolean" line="72">
                <params>
                    <param name="b" type="boolean"/>
                </params>
            </method>
            <method name="equals" type="boolean" line="75">
                <params>
                    <param name="id" type="Identifier"/>
                </params>
            </method>
            <method name="equals" type="boolean" line="78">
                <params>
                    <param name="s" type="String"/>
                </params>
            </method>
            <javadoc line="81">
                Check if the expression must be a null reference.                
            </javadoc>
            <method name="isNull" type="boolean" line="84"/>
            <javadoc line="87">
                Check if the expression cannot be a null reference.                
            </javadoc>
            <method name="isNonNull" type="boolean" line="90"/>
            <javadoc line="93">
                Check if the expression is equal to its default static value                
            </javadoc>
            <method name="equalsDefault" type="boolean" line="96"/>
            <javadoc line="99">
                Convert an expresion to a type                
            </javadoc>
            <method name="toType" type="Type" line="102">
                <params>
                    <param name="env" type="Environment"/>
                    <param name="ctx" type="Context"/>
                </params>
            </method>
            <javadoc line="106">
                See if this expression fits in the given type.
                  This is useful because some larger numbers fit into
                  smaller types.
                  &lt;p&gt;
                  If it is an &quot;int&quot; constant expression, inline it, if necessary,
                  to examine its numerical value.  See JLS 5.2 and 15.24.                
            </javadoc>
            <method name="fitsType" type="boolean" line="114">
                <params>
                    <param name="env" type="Environment"/>
                    <param name="ctx" type="Context"/>
                    <param name="t" type="Type"/>
                </params>
                <scope line="115">
                    <scope line="116"/>
                    <scope line="119">
                        <declaration name="n" type="Expression" line="120"/>
                        <scope line="121"/>
                    </scope>
                </scope>
                <scope line="127"/>
            </method>
            <javadoc line="131">
                @deprecated (for backward compatibility)                
            </javadoc>
            <method name="fitsType" type="boolean" line="134">
                <params>
                    <param name="env" type="Environment"/>
                    <param name="t" type="Type"/>
                </params>
            </method>
            <javadoc line="137">
                Check an expression                
            </javadoc>
            <method name="checkValue" type="Vset" line="140">
                <params>
                    <param name="env" type="Environment"/>
                    <param name="ctx" type="Context"/>
                    <param name="vset" type="Vset"/>
                    <param name="exp" type="Hashtable"/>
                </params>
            </method>
            <method name="checkInitializer" type="Vset" line="143">
                <params>
                    <param name="env" type="Environment"/>
                    <param name="ctx" type="Context"/>
                    <param name="vset" type="Vset"/>
                    <param name="t" type="Type"/>
                    <param name="exp" type="Hashtable"/>
                </params>
            </method>
            <method name="check" type="Vset" line="146">
                <params>
                    <param name="env" type="Environment"/>
                    <param name="ctx" type="Context"/>
                    <param name="vset" type="Vset"/>
                    <param name="exp" type="Hashtable"/>
                </params>
            </method>
            <method name="checkLHS" type="Vset" line="149">
                <params>
                    <param name="env" type="Environment"/>
                    <param name="ctx" type="Context"/>
                    <param name="vset" type="Vset"/>
                    <param name="exp" type="Hashtable"/>
                </params>
            </method>
            <javadoc line="154">
                Return a &lt;code&gt;FieldUpdater&lt;/code&gt; object to be used in updating the
                  value of the location denoted by &lt;code&gt;this&lt;/code&gt;, which must be an
                  expression suitable for the left-hand side of an assignment.
                  This is used for implementing assignments to private fields for which
                  an access method is required.  Returns null if no access method is
                  needed, in which case the assignment is handled in the usual way, by
                  direct access.  Only simple assignment expressions are handled here
                  Assignment operators and pre/post increment/decrement operators are
                  are handled by &apos;getUpdater&apos; below.
                  &lt;p&gt;
                  Called during the checking phase.                
            </javadoc>
            <method name="getAssigner" type="FieldUpdater" line="167">
                <params>
                    <param name="env" type="Environment"/>
                    <param name="ctx" type="Context"/>
                </params>
            </method>
            <javadoc line="170">
                Return a &lt;code&gt;FieldUpdater&lt;/code&gt; object to be used in updating the value of the
                  location denoted by &lt;code&gt;this&lt;/code&gt;, which must be an expression suitable for the
                  left-hand side of an assignment.  This is used for implementing the assignment
                  operators and the increment/decrement operators on private fields that require an
                  access method, e.g., uplevel from an inner class.  Returns null if no access method
                  is needed.
                  &lt;p&gt;
                  Called during the checking phase.                
            </javadoc>
            <method name="getUpdater" type="FieldUpdater" line="180">
                <params>
                    <param name="env" type="Environment"/>
                    <param name="ctx" type="Context"/>
                </params>
            </method>
            <method name="checkAssignOp" type="Vset" line="183">
                <params>
                    <param name="env" type="Environment"/>
                    <param name="ctx" type="Context"/>
                    <param name="vset" type="Vset"/>
                    <param name="exp" type="Hashtable"/>
                    <param name="outside" type="Expression"/>
                </params>
            </method>
            <javadoc line="189">
                Check something that might be an AmbiguousName (refman 6.5.2).
                  A string of dot-separated identifiers might be, in order of preference:
                  &lt;nl&gt;
                  &lt;li&gt; a variable name followed by fields or types
                  &lt;li&gt; a type name followed by fields or types
                  &lt;li&gt; a package name followed a type and then fields or types
                  &lt;/nl&gt;
                  If a type name is found, it rewrites itself as a &lt;tt&gt;TypeExpression&lt;/tt&gt;.
                  If a node decides it can only be a package prefix, it sets its
                  type to &lt;tt&gt;Type.tPackage&lt;/tt&gt;.  The caller must detect this
                  and act appropriately to verify the full package name.                
                <arg>
                    loc the expression containing the ambiguous expression                    
                </arg>
            </javadoc>
            <method name="checkAmbigName" type="Vset" line="203">
                <params>
                    <param name="env" type="Environment"/>
                    <param name="ctx" type="Context"/>
                    <param name="vset" type="Vset"/>
                    <param name="exp" type="Hashtable"/>
                    <param name="loc" type="UnaryExpression"/>
                </params>
            </method>
            <javadoc line="206">
                Check a condition.  Return a ConditionVars(), which indicates when
                  which variables are set if the condition is true, and which are set if
                  the condition is false.                
            </javadoc>
            <method name="checkCondition" type="ConditionVars" line="211">
                <params>
                    <param name="env" type="Environment"/>
                    <param name="ctx" type="Context"/>
                    <param name="vset" type="Vset"/>
                    <param name="exp" type="Hashtable"/>
                </params>
                <declaration name="cvars" type="ConditionVars" line="212"/>
            </method>
            <method name="checkCondition" type="void" line="216">
                <params>
                    <param name="env" type="Environment"/>
                    <param name="ctx" type="Context"/>
                    <param name="vset" type="Vset"/>
                    <param name="exp" type="Hashtable"/>
                    <param name="cvars" type="ConditionVars"/>
                </params>
            </method>
            <javadoc line="220">
                Evaluate.
                  Attempt to compute the value of an expression node.  If all operands are
                  literal constants of the same kind (e.g., IntegerExpression nodes), a
                  new constant node of the proper type is returned representing the value
                  as computed at compile-time.  Otherwise, the original node &apos;this&apos; is
                  returned.                
            </javadoc>
            <method name="eval" type="Expression" line="228"/>
            <javadoc line="231">
                Simplify.
                  Attempt to simplify an expression node by returning a semantically-
                  equivalent expression that is presumably less costly to execute.  There
                  is some overlap with the intent of &apos;eval&apos;, as compile-time evaluation of
                  conditional expressions and the short-circuit boolean operators is
                  performed here.  Other simplifications include logical identities
                  involving logical negation and comparisons.  If no simplification is
                  possible, the original node &apos;this&apos; is returned.  It is assumed that the
                  children of the node have previously been recursively simplified and
                  evaluated.  A result of &apos;null&apos; indicates that the expression may be
                  elided entirely.                
            </javadoc>
            <method name="simplify" type="Expression" line="244"/>
            <javadoc line="247">
                Inline.
                  Recursively simplify each child of an expression node, destructively
                  replacing the child with the simplified result.  Also attempts to
                  simplify the current node &apos;this&apos;, and returns the simplified result.
                  The name &apos;inline&apos; is somthing of a misnomer, as these methods are
                  responsible for compile-time expression simplification in general.
                  The &apos;eval&apos; and &apos;simplify&apos; methods apply to a single expression node
                  only -- it is &apos;inline&apos; and &apos;inlineValue&apos; that drive the simplification
                  of entire expressions.                
            </javadoc>
            <method name="inline" type="Expression" line="258">
                <params>
                    <param name="env" type="Environment"/>
                    <param name="ctx" type="Context"/>
                </params>
            </method>
            <method name="inlineValue" type="Expression" line="261">
                <params>
                    <param name="env" type="Environment"/>
                    <param name="ctx" type="Context"/>
                </params>
            </method>
            <javadoc line="264">
                Attempt to evaluate this expression.  If this expression
                  yields a value, append it to the StringBuffer `buffer&apos;.
                  If this expression cannot be evaluated at this time (for
                  example if it contains a division by zero, a non-constant
                  subexpression, or a subexpression which &quot;refuses&quot; to evaluate)
                  then return `null&apos; to indicate failure.
                  It is anticipated that this method will be called to evaluate
                  concatenations of compile-time constant strings.  The call
                  originates from AddExpression#inlineValue().
                  See AddExpression#inlineValueSB() for detailed comments.                
            </javadoc>
            <method name="inlineValueSB" type="StringBuffer" line="276">
                <params>
                    <param name="env" type="Environment"/>
                    <param name="ctx" type="Context"/>
                    <param name="buffer" type="StringBuffer"/>
                </params>
                <declaration name="inlined" type="Expression" line="277"/>
                <declaration name="val" type="Object" line="278"/>
                <scope line="279"/>
                <scope line="282"/>
                <scope line="285"/>
                <scope line="288"/>
            </method>
            <method name="inlineLHS" type="Expression" line="293">
                <params>
                    <param name="env" type="Environment"/>
                    <param name="ctx" type="Context"/>
                </params>
            </method>
            <javadoc line="296">
                The cost of inlining this expression.
                  This cost controls the inlining of methods, and does not determine
                  the compile-time simplifications performed by &apos;inline&apos; and friends.                
            </javadoc>
            <method name="costInline" type="int" line="301">
                <params>
                    <param name="thresh" type="int"/>
                    <param name="env" type="Environment"/>
                    <param name="ctx" type="Context"/>
                </params>
            </method>
            <javadoc line="304">
                Code                
            </javadoc>
            <method name="codeBranch" type="void" line="307">
                <params>
                    <param name="env" type="Environment"/>
                    <param name="ctx" type="Context"/>
                    <param name="asm" type="Assembler"/>
                    <param name="lbl" type="Label"/>
                    <param name="whenTrue" type="boolean"/>
                </params>
                <scope line="308"/>
                <scope line="312"/>
            </method>
            <method name="codeValue" type="void" line="316">
                <params>
                    <param name="env" type="Environment"/>
                    <param name="ctx" type="Context"/>
                    <param name="asm" type="Assembler"/>
                </params>
                <scope line="317">
                    <declaration name="l1" type="Label" line="318"/>
                    <declaration name="l2" type="Label" line="319"/>
                </scope>
                <scope line="327"/>
            </method>
            <method name="code" type="void" line="331">
                <params>
                    <param name="env" type="Environment"/>
                    <param name="ctx" type="Context"/>
                    <param name="asm" type="Assembler"/>
                </params>
            </method>
            <method name="codeLValue" type="int" line="345">
                <params>
                    <param name="env" type="Environment"/>
                    <param name="ctx" type="Context"/>
                    <param name="asm" type="Assembler"/>
                </params>
            </method>
            <method name="codeLoad" type="void" line="349">
                <params>
                    <param name="env" type="Environment"/>
                    <param name="ctx" type="Context"/>
                    <param name="asm" type="Assembler"/>
                </params>
            </method>
            <method name="codeStore" type="void" line="353">
                <params>
                    <param name="env" type="Environment"/>
                    <param name="ctx" type="Context"/>
                    <param name="asm" type="Assembler"/>
                </params>
            </method>
            <javadoc line="357">
                Convert this expression to a string.                
            </javadoc>
            <method name="ensureString" type="void" line="360">
                <params>
                    <param name="env" type="Environment"/>
                    <param name="ctx" type="Context"/>
                    <param name="asm" type="Assembler"/>
                </params>
                <scope line="361"/>
                <declaration name="sourceClass" type="ClassDefinition" line="364"/>
                <declaration name="stClass" type="ClassDeclaration" line="365"/>
                <declaration name="stClsDef" type="ClassDefinition" line="366"/>
                <scope line="367">
                    <scope line="368">
                        <declaration name="argType1" type="Type" line="369"/>
                        <declaration name="f1" type="MemberDefinition" line="370"/>
                    </scope>
                    <scope line="373">
                        <declaration name="argType2" type="Type" line="374"/>
                        <declaration name="f2" type="MemberDefinition" line="375"/>
                    </scope>
                </scope>
                <scope line="379">
                    <declaration name="argType" type="Type" line="380"/>
                    <declaration name="f" type="MemberDefinition" line="381"/>
                </scope>
            </method>
            <javadoc line="385">
                Convert this expression to a string and append it to the string
                  buffer on the top of the stack.
                  If the needBuffer argument is true, the string buffer needs to be
                  created, initialized, and pushed on the stack, first.                
            </javadoc>
            <method name="codeAppend" type="void" line="391">
                <params>
                    <param name="env" type="Environment"/>
                    <param name="ctx" type="Context"/>
                    <param name="asm" type="Assembler"/>
                    <param name="sbClass" type="ClassDeclaration"/>
                    <param name="needBuffer" type="boolean"/>
                </params>
                <declaration name="sourceClass" type="ClassDefinition" line="392"/>
                <declaration name="sbClsDef" type="ClassDefinition" line="393"/>
                <declaration name="f" type="MemberDefinition" line="394"/>
                <scope line="395">
                    <scope line="398"/>
                    <scope line="401">
                        <declaration name="argType" type="Type" line="404"/>
                    </scope>
                </scope>
                <scope line="409">
                    <declaration name="argType" type="Type" line="411"/>
                </scope>
            </method>
            <javadoc line="416">
                Code                
            </javadoc>
            <method name="codeDup" type="void" line="419">
                <params>
                    <param name="env" type="Environment"/>
                    <param name="ctx" type="Context"/>
                    <param name="asm" type="Assembler"/>
                    <param name="items" type="int"/>
                    <param name="depth" type="int"/>
                </params>
            </method>
            <method name="codeConversion" type="void" line="452">
                <params>
                    <param name="env" type="Environment"/>
                    <param name="ctx" type="Context"/>
                    <param name="asm" type="Assembler"/>
                    <param name="f" type="Type"/>
                    <param name="t" type="Type"/>
                </params>
                <declaration name="from" type="int" line="453"/>
                <declaration name="to" type="int" line="454"/>
                <scope line="457"/>
                <scope line="462"/>
                <scope line="468"/>
                <scope line="474"/>
                <scope line="557">
                    <scope line="558"/>
                </scope>
                <scope line="562"/>
                <scope line="574">
                    <scope line="575"/>
                </scope>
                <scope line="580"/>
            </method>
            <javadoc line="588">
                Check if the first thing is a constructor invocation                
            </javadoc>
            <method name="firstConstructor" type="Expression" line="591"/>
            <javadoc line="594">
                Create a copy of the expression for method inlining                
            </javadoc>
            <method name="copyInline" type="Expression" line="597">
                <params>
                    <param name="ctx" type="Context"/>
                </params>
            </method>
            <javadoc line="600">
                Print                
            </javadoc>
            <method name="print" type="void" line="603">
                <params>
                    <param name="out" type="PrintStream"/>
                </params>
            </method>
        </class>
    </source>