<?xml version="1.0" encoding="UTF-8"?>
    <source package="sun.nio">
        <import package="java.nio.ByteBuffer"/>
        <import package="java.io.IOException"/>
        <interface name="ByteBuffered">
            <javadoc line="31">
                This is an interface to adapt existing APIs to use {@link java.nio.ByteBuffer&lt;tt&gt;ByteBuffers&lt;/tt&gt;} as the underlying
                  data format.  Only the initial producer and final consumer have to be changed.&lt;p&gt;
                  For example, the Zip/Jar code supports {@link java.io.InputStream &lt;tt&gt;InputStreams&lt;/tt&gt;}.
                  To make the Zip code use {@link java.nio.MappedByteBuffer &lt;tt&gt;MappedByteBuffers&lt;/tt&gt;} as
                  the underlying data structure, it can create a class of InputStream that wraps the ByteBuffer,
                  and implements the ByteBuffered interface. A co-operating class several layers
                  away can ask the InputStream if it is an instance of ByteBuffered, then
                  call the {@link #getByteBuffer()} method.                
            </javadoc>
            <method name="getByteBuffer" type="ByteBuffer" line="44"/>
            <javadoc line="44">
                Returns the &lt;tt&gt;ByteBuffer&lt;/tt&gt; behind this object, if this particular
                  instance has one. An implementation of &lt;tt&gt;getByteBuffer()&lt;/tt&gt; is allowed
                  to return &lt;tt&gt;null&lt;/tt&gt; for any reason.                
                <return>
                    The <tt>ByteBuffer</tt>, if this particular instance has one,
                      or <tt>null</tt> otherwise.                    
                </return>
                <throws>
                    IOExceptionIf the ByteBuffer is no longer valid.                    
                </throws>
                <since>
                    1.5                    
                </since>
            </javadoc>
        </interface>
    </source>