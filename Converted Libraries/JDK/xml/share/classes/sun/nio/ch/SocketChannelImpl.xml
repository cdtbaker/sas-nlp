<?xml version="1.0" encoding="UTF-8"?>
    <source package="sun.nio.ch">
        <import package="java.io.FileDescriptor"/>
        <import package="java.io.IOException"/>
        <import package="java.net"/>
        <import package="java.nio.ByteBuffer"/>
        <import package="java.nio.channels"/>
        <import package="java.nio.channels.spi"/>
        <import package="java.util"/>
        <import package="sun.net.NetHooks"/>
        <class name="SocketChannelImpl" line="38">
            <extends class="SocketChannel"/>
            <comment line="48">
                Used to make native read and write calls                
            </comment>
            <comment line="51">
                Our file descriptor object                
            </comment>
            <comment line="54">
                fd value needed for dev/poll. This value will remain valid
                 even after the value in the file descriptor object has been set to -1                
            </comment>
            <comment line="58">
                IDs of native threads doing reads and writes, for signalling                
            </comment>
            <comment line="62">
                Lock held by current reading or connecting thread                
            </comment>
            <comment line="65">
                Lock held by current writing or connecting thread                
            </comment>
            <comment line="68">
                Lock held by any thread that modifies the state fields declared below
                 DO NOT invoke a blocking I/O operation while holding this lock!                
            </comment>
            <comment line="72">
                -- The following fields are protected by stateLock                
            </comment>
            <comment line="74">
                State, increases monotonically                
            </comment>
            <comment line="83">
                Binding                
            </comment>
            <comment line="87">
                Input/Output open                
            </comment>
            <comment line="92">
                Socket adaptor, created on demand                
            </comment>
            <comment line="95">
                -- End of fields protected by stateLock                
            </comment>
            <comment line="98">
                Constructor for normal connecting sockets                
            </comment>
            <comment line="120">
                Constructor for sockets obtained from server sockets                
            </comment>
            <comment line="501">
                package-private                
            </comment>
            <comment line="805">
                AbstractInterruptibleChannel synchronizes invocations of this method
                 using AbstractInterruptibleChannel.closeLock, and also ensures that this
                 method is only ever invoked once.  Before we get to this method, isOpen
                 (which is volatile) will have been set to false.                
            </comment>
            <comment line="984">
                -- Native methods --                
            </comment>
            <implements interface="SelChImpl"/>
            <javadoc line="38">
                An implementation of SocketChannels                
            </javadoc>
            <declaration name="nd" type="NativeDispatcher" line="48"/>
            <declaration name="fd" type="FileDescriptor" line="51"/>
            <declaration name="fdVal" type="int" line="55"/>
            <declaration name="readerThread" type="long" line="58"/>
            <declaration name="writerThread" type="long" line="59"/>
            <declaration name="readLock" type="Object" line="62"/>
            <declaration name="writeLock" type="Object" line="65"/>
            <declaration name="stateLock" type="Object" line="69"/>
            <declaration name="ST_UNINITIALIZED" type="int" line="74"/>
            <declaration name="ST_UNCONNECTED" type="int" line="75"/>
            <declaration name="ST_PENDING" type="int" line="76"/>
            <declaration name="ST_CONNECTED" type="int" line="77"/>
            <declaration name="ST_KILLPENDING" type="int" line="78"/>
            <declaration name="ST_KILLED" type="int" line="79"/>
            <declaration name="state" type="int" line="80"/>
            <declaration name="localAddress" type="SocketAddress" line="83"/>
            <declaration name="remoteAddress" type="SocketAddress" line="84"/>
            <declaration name="isInputOpen" type="boolean" line="87"/>
            <declaration name="isOutputOpen" type="boolean" line="88"/>
            <declaration name="readyToConnect" type="boolean" line="89"/>
            <declaration name="socket" type="Socket" line="92"/>
            <method name="SocketChannelImpl" type="constructor" line="99">
                <params>
                    <param name="sp" type="SelectorProvider"/>
                </params>
            </method>
            <method name="SocketChannelImpl" type="constructor" line="110">
                <params>
                    <param name="sp" type="SelectorProvider"/>
                    <param name="fd" type="FileDescriptor"/>
                    <param name="bound" type="boolean"/>
                </params>
            </method>
            <method name="SocketChannelImpl" type="constructor" line="124">
                <params>
                    <param name="sp" type="SelectorProvider"/>
                    <param name="fd" type="FileDescriptor"/>
                    <param name="remote" type="InetSocketAddress"/>
                </params>
            </method>
            <method name="socket" type="Socket" line="133">
                <scope line="134"/>
            </method>
            <method name="getLocalAddress" type="SocketAddress" line="142">
                <scope line="143"/>
            </method>
            <method name="getRemoteAddress" type="SocketAddress" line="151">
                <scope line="152"/>
            </method>
            <method name="setOption" type="SocketChannel" line="162">
                <params>
                    <param name="name" type="SocketOption<T>"/>
                    <param name="value" type="T"/>
                </params>
                <comment line="173">
                    special handling for IP_TOS: no-op when IPv6                    
                </comment>
                <comment line="180">
                    no options that require special handling                    
                </comment>
                <scope line="168">
                    <scope line="173"/>
                </scope>
            </method>
            <method name="getOption" type="T" line="189">
                <params>
                    <param name="name" type="SocketOption<T>"/>
                </params>
                <comment line="200">
                    special handling for IP_TOS: always return 0 when IPv6                    
                </comment>
                <comment line="206">
                    no options that require special handling                    
                </comment>
                <scope line="195">
                    <scope line="200"/>
                </scope>
            </method>
            <class name="DefaultOptionsHolder" line="210">
                <declaration name="defaultOptions" type="Set&lt;SocketOption&lt;?&gt;&gt;" line="211"/>
                <method name="defaultOptions" type="Set<SocketOption<?>>" line="213">
                    <comment line="222">
                        additional options required by socket adaptor                        
                    </comment>
                    <declaration name="set" type="HashSet&lt;SocketOption&lt;?&gt;&gt;" line="214"/>
                </method>
            </class>
            <method name="supportedOptions" type="Set<SocketOption<?>>" line="229"/>
            <method name="ensureReadOpen" type="boolean" line="233">
                <scope line="234"/>
            </method>
            <method name="ensureWriteOpen" type="void" line="246">
                <scope line="247"/>
            </method>
            <method name="readerCleanup" type="void" line="257">
                <scope line="258"/>
            </method>
            <method name="writerCleanup" type="void" line="265">
                <scope line="266"/>
            </method>
            <method name="read" type="int" line="273">
                <params>
                    <param name="buf" type="ByteBuffer"/>
                </params>
                <comment line="285">
                    Set up the interruption machinery; see
                     AbstractInterruptibleChannel for details                    
                </comment>
                <comment line="292">
                    Either the current thread is already interrupted, so
                     begin() closed the channel, or another thread closed the
                     channel since we checked it a few bytecodes ago.  In
                     either case the value returned here is irrelevant since
                     the invocation of end() in the finally block will throw
                     an appropriate exception.                    
                </comment>
                <comment line="303">
                    Save this thread so that it can be signalled on those
                     platforms that require it                    
                </comment>
                <comment line="309">
                    Between the previous test of isOpen() and the return of the
                     IOUtil.read invocation below, this channel might be closed
                     or this thread might be interrupted.  We rely upon the
                     implicit synchronization point in the kernel read() call to
                     make sure that the right thing happens.  In either case the
                     implCloseSelectableChannel method is ultimately invoked in
                     some other thread, so there are three possibilities:
                    
                       - implCloseSelectableChannel() invokes nd.preClose()
                         before this thread invokes read(), in which case the
                         read returns immediately with either EOF or an error,
                         the latter of which will cause an IOException to be
                         thrown.
                    
                       - implCloseSelectableChannel() invokes nd.preClose() after
                         this thread is blocked in read().  On some operating
                         systems (e.g., Solaris and Windows) this causes the read
                         to return immediately with either EOF or an error
                         indication.
                    
                       - implCloseSelectableChannel() invokes nd.preClose() after
                         this thread is blocked in read() but the operating
                         system (e.g., Linux) doesn&apos;t support preemptive close,
                         so implCloseSelectableChannel() proceeds to signal this
                         thread, thereby causing the read to return immediately
                         with IOStatus.INTERRUPTED.
                    
                     In all three cases the invocation of end() in the finally
                     clause will notice that the channel has been closed and
                     throw an appropriate exception (AsynchronousCloseException
                     or ClosedByInterruptException) if necessary.
                    
                     *There is A fourth possibility. implCloseSelectableChannel()
                     invokes nd.preClose(), signals reader/writer thred and quickly
                     moves on to nd.close() in kill(), which does a real close.
                     Then a third thread accepts a new connection, opens file or
                     whatever that causes the released &quot;fd&quot; to be recycled. All
                     above happens just between our last isOpen() check and the
                     next kernel read reached, with the recycled &quot;fd&quot;. The solution
                     is to postpone the real kill() if there is a reader or/and
                     writer thread(s) over there &quot;waiting&quot;, leave the cleanup/kill
                     to the reader or writer thread. (the preClose() still happens
                     so the connection gets cut off as usual).
                    
                     For socket channels there is the additional wrinkle that
                     asynchronous shutdown works much like asynchronous close,
                     except that the channel is shutdown rather than completely
                     closed.  This is analogous to the first two cases above,
                     except that the shutdown operation plays the role of
                     nd.preClose().                    
                </comment>
                <comment line="362">
                    The system call was interrupted but the channel
                     is still open, so retry                    
                </comment>
                <comment line="370">
                    Clear reader thread                    
                </comment>
                <comment line="371">
                    The end method, which is defined in our superclass
                     AbstractInterruptibleChannel, resets the interruption
                     machinery.  If its argument is true then it returns
                     normally; otherwise it checks the interrupt and open state
                     of this channel and throws an appropriate exception if
                     necessary.
                    
                     So, if we actually managed to do any I/O in the above try
                     block then we pass true to the end method.  We also pass
                     true if the channel was in non-blocking mode when the I/O
                     operation was initiated but no data could be transferred;
                     this prevents spurious exceptions from being thrown in the
                     rare event that a channel is closed or a thread is
                     interrupted at the exact moment that a non-blocking I/O
                     request is made.                    
                </comment>
                <comment line="389">
                    Extra case for socket channels: Asynchronous shutdown                    
                </comment>
                <scope line="278">
                    <declaration name="n" type="int" line="281"/>
                    <scope line="282">
                        <scope line="289">
                            <scope line="290"/>
                        </scope>
                        <scope line="358">
                            <scope line="360"/>
                        </scope>
                    </scope>
                    <scope line="368">
                        <scope line="390"/>
                    </scope>
                </scope>
            </method>
            <method name="read" type="long" line="403">
                <params>
                    <param name="dsts" type="ByteBuffer[]"/>
                    <param name="offset" type="int"/>
                    <param name="length" type="int"/>
                </params>
                <scope line="406">
                    <declaration name="n" type="long" line="409"/>
                    <scope line="410">
                        <scope line="412"/>
                        <scope line="418"/>
                    </scope>
                    <scope line="424">
                        <scope line="427"/>
                    </scope>
                </scope>
            </method>
            <method name="write" type="int" line="436">
                <params>
                    <param name="buf" type="ByteBuffer"/>
                </params>
                <scope line="439">
                    <declaration name="n" type="int" line="441"/>
                    <scope line="442">
                        <scope line="444"/>
                        <scope line="449"/>
                    </scope>
                    <scope line="455">
                        <scope line="458"/>
                    </scope>
                </scope>
            </method>
            <method name="write" type="long" line="469">
                <params>
                    <param name="srcs" type="ByteBuffer[]"/>
                    <param name="offset" type="int"/>
                    <param name="length" type="int"/>
                </params>
                <scope line="472">
                    <declaration name="n" type="long" line="474"/>
                    <scope line="475">
                        <scope line="477"/>
                        <scope line="482"/>
                    </scope>
                    <scope line="488">
                        <scope line="491"/>
                    </scope>
                </scope>
            </method>
            <method name="sendOutOfBandData" type="int" line="501">
                <params>
                    <param name="b" type="byte"/>
                </params>
                <scope line="502">
                    <declaration name="n" type="int" line="504"/>
                    <scope line="505">
                        <scope line="507"/>
                        <scope line="512"/>
                    </scope>
                    <scope line="518">
                        <scope line="521"/>
                    </scope>
                </scope>
            </method>
            <method name="implConfigureBlocking" type="void" line="530">
                <params>
                    <param name="block" type="boolean"/>
                </params>
            </method>
            <method name="localAddress" type="SocketAddress" line="534">
                <scope line="535"/>
            </method>
            <method name="remoteAddress" type="SocketAddress" line="540">
                <scope line="541"/>
            </method>
            <method name="bind" type="SocketChannel" line="547">
                <params>
                    <param name="local" type="SocketAddress"/>
                </params>
                <scope line="548">
                    <scope line="549">
                        <scope line="550">
                            <declaration name="isa" type="InetSocketAddress" line="557"/>
                        </scope>
                    </scope>
                </scope>
            </method>
            <method name="isConnected" type="boolean" line="568">
                <scope line="569"/>
            </method>
            <method name="isConnectionPending" type="boolean" line="574">
                <scope line="575"/>
            </method>
            <method name="ensureOpenAndUnconnected" type="void" line="580">
                <scope line="581"/>
            </method>
            <method name="connect" type="boolean" line="591">
                <params>
                    <param name="sa" type="SocketAddress"/>
                </params>
                <comment line="612">
                    notify hook only if unbound                    
                </comment>
                <comment line="638">
                    Socket was not bound before connecting or
                     Socket was bound with an &quot;anyLocalAddress&quot;                    
                </comment>
                <comment line="650">
                    If an exception was thrown, close the channel after
                     invoking end() so as to avoid bogus
                     AsynchronousCloseExceptions                    
                </comment>
                <comment line="660">
                    Connection succeeded; disallow further
                     invocation                    
                </comment>
                <comment line="665">
                    If nonblocking and no exception then connection
                     pending; disallow another invocation                    
                </comment>
                <declaration name="localPort" type="int" line="592"/>
                <scope line="594">
                    <scope line="595">
                        <declaration name="isa" type="InetSocketAddress" line="597"/>
                        <declaration name="sm" type="SecurityManager" line="598"/>
                        <scope line="602">
                            <declaration name="n" type="int" line="603"/>
                            <scope line="604">
                                <scope line="605">
                                    <scope line="607">
                                        <scope line="608"/>
                                        <scope line="612"/>
                                    </scope>
                                    <scope line="619">
                                        <declaration name="ia" type="InetAddress" line="620"/>
                                    </scope>
                                    <scope line="632">
                                        <scope line="636"/>
                                    </scope>
                                </scope>
                                <scope line="643"/>
                            </scope>
                            <scope line="648"/>
                            <scope line="655">
                                <scope line="657"/>
                            </scope>
                        </scope>
                    </scope>
                </scope>
            </method>
            <method name="finishConnect" type="boolean" line="677">
                <comment line="714">
                    Loop in case of
                     spurious notifications                    
                </comment>
                <comment line="730">
                    poll()/getsockopt() does not report
                     error (throws exception, with n = 0)
                     on Linux platform after dup2 and
                     signal-wakeup. Force n to 0 so the
                     end() can throw appropriate exception                    
                </comment>
                <comment line="742">
                    If an exception was thrown, close the channel after
                     invoking end() so as to avoid bogus
                     AsynchronousCloseExceptions                    
                </comment>
                <scope line="678">
                    <scope line="679">
                        <scope line="680"/>
                        <declaration name="n" type="int" line="688"/>
                        <scope line="689">
                            <scope line="690">
                                <scope line="692">
                                    <scope line="693">
                                        <scope line="694"/>
                                    </scope>
                                    <scope line="699">
                                        <scope line="700"/>
                                    </scope>
                                    <scope line="708">
                                        <scope line="709">
                                            <scope line="712"/>
                                        </scope>
                                    </scope>
                                </scope>
                            </scope>
                            <scope line="724">
                                <scope line="725">
                                    <scope line="727"/>
                                </scope>
                            </scope>
                        </scope>
                        <scope line="740"/>
                        <scope line="747">
                            <scope line="748"/>
                        </scope>
                    </scope>
                </scope>
            </method>
            <method name="shutdownInput" type="SocketChannel" line="759">
                <scope line="760">
                    <scope line="765"/>
                </scope>
            </method>
            <method name="shutdownOutput" type="SocketChannel" line="776">
                <scope line="777">
                    <scope line="782"/>
                </scope>
            </method>
            <method name="isInputOpen" type="boolean" line="792">
                <scope line="793"/>
            </method>
            <method name="isOutputOpen" type="boolean" line="798">
                <scope line="799"/>
            </method>
            <method name="implCloseSelectableChannel" type="void" line="809">
                <comment line="815">
                    Close the underlying file descriptor and dup it to a known fd
                     that&apos;s already closed.  This prevents other operations on this
                     channel from using the old fd, which might be recycled in the
                     meantime and allocated to an entirely different channel.                    
                </comment>
                <comment line="822">
                    Signal native threads, if needed.  If a target thread is not
                     currently blocked in an I/O operation then no harm is done since
                     the signal handler doesn&apos;t actually do anything.                    
                </comment>
                <comment line="832">
                    If this channel is not registered then it&apos;s safe to close the fd
                     immediately since we know at this point that no thread is
                     blocked in an I/O operation upon the channel and, since the
                     channel is marked closed, no thread will start another such
                     operation.  If this channel is registered then we don&apos;t close
                     the fd since it might be in use by a selector.  In that case
                     closing this channel caused its keys to be cancelled, so the
                     last selector to deregister a key for this channel will invoke
                     kill() to close the fd.                    
                </comment>
                <scope line="810"/>
            </method>
            <method name="kill" type="void" line="846">
                <comment line="857">
                    Postpone the kill if there is a waiting reader
                     or writer thread. See the comments in read() for
                     more detailed explanation.                    
                </comment>
                <scope line="847">
                    <scope line="850"/>
                    <scope line="859"/>
                    <scope line="862"/>
                </scope>
            </method>
            <javadoc line="868">
                Translates native poll revent ops into a ready operation ops                
            </javadoc>
            <method name="translateReadyOps" type="boolean" line="872">
                <params>
                    <param name="ops" type="int"/>
                    <param name="initialOps" type="int"/>
                    <param name="sk" type="SelectionKeyImpl"/>
                </params>
                <comment line="874">
                    Do this just once, it synchronizes                    
                </comment>
                <comment line="879">
                    This should only happen if this channel is pre-closed while a
                     selection operation is in progress
                     ## Throw an error if this channel has not been pre-closed                    
                </comment>
                <comment line="889">
                    No need to poll again in checkConnect,
                     the error will be detected there                    
                </comment>
                <declaration name="intOps" type="int" line="873"/>
                <declaration name="oldOps" type="int" line="874"/>
                <declaration name="newOps" type="int" line="875"/>
                <scope line="877"/>
                <scope line="885"/>
                <scope line="901"/>
            </method>
            <method name="translateAndUpdateReadyOps" type="boolean" line="915">
                <params>
                    <param name="ops" type="int"/>
                    <param name="sk" type="SelectionKeyImpl"/>
                </params>
            </method>
            <method name="translateAndSetReadyOps" type="boolean" line="919">
                <params>
                    <param name="ops" type="int"/>
                    <param name="sk" type="SelectionKeyImpl"/>
                </params>
            </method>
            <javadoc line="923">
                Translates an interest operation set into a native poll event set                
            </javadoc>
            <method name="translateAndSetInterestOps" type="void" line="926">
                <params>
                    <param name="ops" type="int"/>
                    <param name="sk" type="SelectionKeyImpl"/>
                </params>
                <declaration name="newOps" type="int" line="927"/>
            </method>
            <method name="getFD" type="FileDescriptor" line="937"/>
            <method name="getFDVal" type="int" line="941"/>
            <method name="toString" type="String" line="945">
                <declaration name="sb" type="StringBuffer" line="946"/>
                <scope line="951">
                    <scope line="952">
                        <scope line="968"/>
                        <scope line="972"/>
                    </scope>
                </scope>
            </method>
            <method name="checkConnect" type="int" line="985"/>
            <method name="sendOutOfBandData" type="int" line="989"/>
            <scope line="992"/>
        </class>
    </source>