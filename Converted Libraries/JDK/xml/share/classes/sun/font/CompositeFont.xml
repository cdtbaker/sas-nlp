<?xml version="1.0" encoding="UTF-8"?>
    <source package="sun.font">
        <import package="java.awt.Font"/>
        <class name="CompositeFont" line="41">
            <extends class="Font2D"/>
            <comment line="47">
                because components can be lazily initialised the components field is
                 private, to ensure all clients call getSlotFont()                
            </comment>
            <comment line="56">
                primary slot for this locale.                
            </comment>
            <comment line="58">
                                
            </comment>
            <comment line="146">
                This method is currently intended to be called only from
                 FontManager.getCompositeFontUIResource(Font)
                 It creates a new CompositeFont with the contents of the Physical
                 one pre-pended as slot 0.                
            </comment>
            <comment line="194">
                This is used for deferred initialisation, so that the components of
                 a logical font are initialised only when the font is used.
                 This can have a positive impact on start-up of most UI applications.
                 Note that this technique cannot be used with a TTC font as it
                 doesn&apos;t know which font in the collection is needed. The solution to
                 this is that the initialisation checks if the returned font is
                 really the one it wants by comparing the name against the name that
                 was passed in (if none was passed in then you aren&apos;t using a TTC
                 as you would have to specify the name in such a case).
                 Assuming there&apos;s only two or three fonts in a collection then it
                 may be sufficient to verify the returned name is the expected one.
                 But half the time it won&apos;t be. However since initialisation of the
                 TTC will initialise all its components then just do a findFont2D call
                 to locate the right one.
                 This code allows for initialisation of each slot on demand.
                 There are two issues with this.
                 1) All metrics slots probably may be initialised anyway as many
                 apps will query the overall font metrics. However this is not an
                 absolute requirement
                 2) Some font configuration files on Solaris reference two versions
                 of a TT font: a Latin-1 version, then a Pan-European version.
                 One from usropenwinlibX11fontsTrueType, the other from
                 a euro_fonts directory which is symlinked from numerous locations.
                 This is difficult to avoid because the two do not share XLFDs so
                 both will be consequently mapped by separate XLFDs needed by AWT.
                 The difficulty this presents for lazy initialisation is that if
                 all the components are not mapped at once, the smaller version may
                 have been used only to be replaced later, and what is the consequence
                 for a client that displayed the contents of this font already.
                 After some thought I think this will not be a problem because when
                 client tries to display a glyph only in the Euro font, the composite
                 will ask all components of this font for that glyph and will get
                 the euro one. Subsequent uses will all come from the 100% compatible
                 euro one.                
            </comment>
            <comment line="277">
                                
            </comment>
            <comment line="360">
                This is set false when the composite is created using a specified
                 physical font as the first slot and called by code which
                 selects composites by locale preferences to know that this
                 isn&apos;t a font which should be adjusted.                
            </comment>
            <comment line="369">
                This isn&apos;t very efficient but its infrequently used.
                 StandardGlyphVector uses it when the client assigns the glyph codes.
                 These may not be valid. This validates them substituting the missing
                 glyph elsewhere.                
            </comment>
            <declaration name="deferredInitialisation" type="boolean[]" line="43"/>
            <declaration name="componentFileNames" type="String[]" line="44"/>
            <declaration name="componentNames" type="String[]" line="45"/>
            <declaration name="components" type="PhysicalFont[]" line="49"/>
            <declaration name="numSlots" type="int" line="50"/>
            <declaration name="numMetricsSlots" type="int" line="51"/>
            <declaration name="exclusionRanges" type="int[]" line="52"/>
            <declaration name="maxIndices" type="int[]" line="53"/>
            <declaration name="numGlyphs" type="int" line="54"/>
            <declaration name="localeSlot" type="int" line="55"/>
            <declaration name="isStdComposite" type="boolean" line="58"/>
            <method name="CompositeFont" type="constructor" line="63">
                <params>
                    <param name="name" type="String"/>
                    <param name="compFileNames" type="String[]"/>
                    <param name="compNames" type="String[]"/>
                    <param name="metricsSlotCnt" type="int"/>
                    <param name="exclRanges" type="int[]"/>
                    <param name="maxIndexes" type="int[]"/>
                    <param name="defer" type="boolean"/>
                    <param name="fm" type="SunFontManager"/>
                </params>
                <comment line="75">
                    Only the first &quot;numMetricsSlots&quot; slots are used for font metrics.
                     the rest are considered &quot;fallback&quot; slots&quot;.                    
                </comment>
                <comment line="82">
                    See if this is a windows locale which has a system EUDC font.
                     If so add it as the final fallback component of the composite.
                     The caller could be responsible for this, but for now it seems
                     better that it is handled internally to the CompositeFont class.                    
                </comment>
                <comment line="124">
                    composites don&apos;t call setStyle() as parsing the style
                     takes place at the same time as parsing the family name.
                     Do I really have to parse the style from the name?                    
                </comment>
                <scope line="69"/>
                <scope line="71"/>
                <scope line="88">
                    <scope line="90"/>
                    <scope line="96"/>
                    <scope line="104">
                        <scope line="105"/>
                    </scope>
                </scope>
                <scope line="109">
                    <scope line="112">
                        <scope line="113"/>
                    </scope>
                </scope>
                <declaration name="index" type="int" line="121"/>
                <scope line="122">
                    <scope line="128">
                        <declaration name="styleStr" type="String" line="129"/>
                        <scope line="130"/>
                        <scope line="132"/>
                        <scope line="134"/>
                        <scope line="136"/>
                    </scope>
                </scope>
                <scope line="140"/>
            </method>
            <method name="CompositeFont" type="constructor" line="150">
                <params>
                    <param name="physFont" type="PhysicalFont"/>
                    <param name="compFont" type="CompositeFont"/>
                </params>
                <comment line="158">
                                        
                </comment>
                <comment line="161">
                    Ugly though it is, we synchronize here on the FontManager class
                     because it is the lock used to do deferred initialisation.
                     We need to ensure that the arrays have consistent information.
                     But it may be possible to dispense with the synchronisation if
                     it is harmless that we do not know a slot is already initialised
                     and just need to discover that and mark it so.                    
                </comment>
                <scope line="168">
                    <scope line="174"/>
                    <scope line="180"/>
                </scope>
            </method>
            <method name="doDeferredInitialisation" type="void" line="228">
                <params>
                    <param name="slot" type="int"/>
                </params>
                <comment line="233">
                    Synchronize on FontManager so that is the global lock
                     to update its static set of deferred fonts.
                     This global lock is rarely likely to be an issue as there
                     are only going to be a few calls into this code.                    
                </comment>
                <comment line="244">
                    Warning: it is possible that the returned component is
                     not derived from the file name argument, this can happen if:
                     - the file can&apos;t be found
                     - the file has a bad font
                     - the font in the file is superseded by a more complete one
                     This should not be a problem for composite font as it will
                     make no further use of this file, but code debuggers
                     maintainers need to be conscious of this possibility.                    
                </comment>
                <scope line="229"/>
                <declaration name="fm" type="SunFontManager" line="238"/>
                <scope line="239">
                    <scope line="240"/>
                    <scope line="243">
                        <scope line="254"/>
                        <scope line="259"/>
                        <declaration name="name" type="String" line="262"/>
                        <scope line="263"/>
                        <scope line="265"/>
                    </scope>
                </scope>
            </method>
            <method name="replaceComponentFont" type="void" line="277">
                <params>
                    <param name="oldFont" type="PhysicalFont"/>
                    <param name="newFont" type="PhysicalFont"/>
                </params>
                <scope line="278"/>
                <scope line="281">
                    <scope line="282">
                        <scope line="284"/>
                    </scope>
                </scope>
            </method>
            <method name="isExcludedChar" type="boolean" line="291">
                <params>
                    <param name="slot" type="int"/>
                    <param name="charcode" type="int"/>
                </params>
                <comment line="307">
                    excluded                    
                </comment>
                <scope line="294"/>
                <declaration name="minIndex" type="int" line="298"/>
                <declaration name="maxIndex" type="int" line="299"/>
                <scope line="300"/>
                <declaration name="curIndex" type="int" line="303"/>
                <scope line="304">
                    <scope line="306"/>
                </scope>
            </method>
            <method name="getStyleMetrics" type="void" line="314">
                <params>
                    <param name="pointSize" type="float"/>
                    <param name="metrics" type="float[]"/>
                    <param name="offset" type="int"/>
                </params>
                <comment line="316">
                    possible?                    
                </comment>
                <declaration name="font" type="PhysicalFont" line="315"/>
                <scope line="316"/>
                <scope line="318"/>
            </method>
            <method name="getNumSlots" type="int" line="323"/>
            <method name="getSlotFont" type="PhysicalFont" line="327">
                <params>
                    <param name="slot" type="int"/>
                </params>
                <comment line="328">
                    This is essentially the runtime overhead for deferred font
                     initialisation: a boolean test on obtaining a slot font,
                     which will happen per slot, on initialisation of a strike
                     (as that is the only frequent call site of this method.                    
                </comment>
                <scope line="333"/>
                <declaration name="fm" type="SunFontManager" line="336"/>
                <scope line="337">
                    <declaration name="font" type="PhysicalFont" line="338"/>
                    <scope line="339">
                        <scope line="340"/>
                        <scope line="345"/>
                    </scope>
                </scope>
                <scope line="350"/>
            </method>
            <method name="createStrike" type="FontStrike" line="355">
                <params>
                    <param name="desc" type="FontStrikeDesc"/>
                </params>
            </method>
            <method name="isStdComposite" type="boolean" line="364"/>
            <method name="getValidatedGlyphCode" type="int" line="373">
                <params>
                    <param name="glyphCode" type="int"/>
                </params>
                <declaration name="slot" type="int" line="374"/>
                <scope line="375"/>
                <declaration name="slotglyphCode" type="int" line="379"/>
                <declaration name="slotFont" type="PhysicalFont" line="380"/>
                <scope line="382"/>
                <scope line="384"/>
            </method>
            <method name="getMapper" type="CharToGlyphMapper" line="389">
                <scope line="390"/>
            </method>
            <method name="hasSupplementaryChars" type="boolean" line="396">
                <scope line="397">
                    <scope line="398"/>
                </scope>
            </method>
            <method name="getNumGlyphs" type="int" line="405">
                <scope line="406"/>
            </method>
            <method name="getMissingGlyphCode" type="int" line="412"/>
            <method name="canDisplay" type="boolean" line="416">
                <params>
                    <param name="c" type="char"/>
                </params>
            </method>
            <method name="useAAForPtSize" type="boolean" line="420">
                <params>
                    <param name="ptsize" type="int"/>
                </params>
                <comment line="421">
                    Find the first slot that supports the default encoding and use
                     that to decide the &quot;gasp&quot; behaviour of the composite font.
                     REMIND &quot;default encoding&quot; isn&apos;t applicable to a Unicode locale
                     and we need to replace this with a better mechanism for deciding
                     if a font &quot;supports&quot; the user&apos;s language. See TrueTypeFont.java                    
                </comment>
                <comment line="428">
                    Ordinarily check numMetricsSlots, but non-standard composites
                     set that to &quot;1&quot; whilst not necessarily supporting the default
                     encoding with that first slot. In such a case check all slots.                    
                </comment>
                <scope line="427">
                    <declaration name="numCoreSlots" type="int" line="432"/>
                    <scope line="433"/>
                    <scope line="436">
                        <scope line="437"/>
                    </scope>
                    <scope line="442"/>
                </scope>
            </method>
            <method name="toString" type="String" line="449">
                <declaration name="ls" type="String" line="450"/>
                <declaration name="componentsStr" type="String" line="452"/>
                <scope line="453"/>
            </method>
        </class>
    </source>