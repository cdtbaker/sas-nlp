<?xml version="1.0" encoding="UTF-8"?>
    <source package="sun.font">
        <import package="java.lang.ref.ReferenceQueue"/>
        <import package="java.lang.ref.SoftReference"/>
        <import package="java.awt.FontMetrics"/>
        <import package="java.awt.Font"/>
        <import package="java.awt.GraphicsEnvironment"/>
        <import package="java.awt.geom.AffineTransform"/>
        <import package="java.awt.geom.NoninvertibleTransformException"/>
        <import package="java.awt.font.FontRenderContext"/>
        <import package="java.awt.font.TextLayout"/>
        <import package="java.io.IOException"/>
        <import package="java.io.ObjectInputStream"/>
        <import package="java.io.ObjectOutputStream"/>
        <import package="java.util.concurrent.ConcurrentHashMap"/>
        <import package="sun.java2d.Disposer"/>
        <import package="sun.java2d.DisposerRecord"/>
        <class name="FontDesignMetrics" line="107">
            <extends class="FontMetrics"/>
            <comment line="115">
                height, ascent, descent, leading are reported to the client                
            </comment>
            <comment line="116">
                as an integer this value is added to the true fp value to                
            </comment>
            <comment line="117">
                obtain a value which is usually going to result in a round up                
            </comment>
            <comment line="118">
                to the next integer except for very marginal cases.                
            </comment>
            <comment line="121">
                These fields are all part of the old serialization representation                
            </comment>
            <comment line="128">
                now unused, still here only for serialization                
            </comment>
            <comment line="129">
                End legacy serialization fields                
            </comment>
            <comment line="131">
                If 1 in readObject, these fields are on the input stream:                
            </comment>
            <comment line="136">
                transient since values could change across runtimes                
            </comment>
            <comment line="165">
                Strongly cache up to 5 most recently requested FontMetrics objects,
                 and softly cache as many as GC allows. In practice this means we
                 should keep references around until memory gets low.
                 We key the cache either by a Font or a combination of the Font and
                 and FRC. A lot of callers use only the font so although there&apos;s code
                 duplication, we allow just a font to be a key implying a default FRC.
                 Also we put the references on a queue so that if they do get nulled
                 out we can clear the keys from the table.                
            </comment>
            <comment line="238">
                All accesses to a CHM do not in general need to be synchronized,
                 as incomplete operations on another thread would just lead to
                 harmless cache misses.                
            </comment>
            <comment line="328">
                Constructs a new FontDesignMetrics object for the given Font.
                 Its private to enable caching - call getMetrics() instead.
                 @param font a Font object.                
            </comment>
            <comment line="339">
                                
            </comment>
            <comment line="420">
                Uses advCache to get character width                
            </comment>
            <comment line="421">
                It is incorrect to call this method for ch &gt; 255                
            </comment>
            <comment line="433">
                                
            </comment>
            <comment line="550">
                Returns the typographic ascent of the font. This is the maximum distance
                 glyphs in this font extend above the base line (measured in typographic
                 units).                
            </comment>
            <comment line="559">
                Returns the typographic descent of the font. This is the maximum distance
                 glyphs in this font extend below the base line.                
            </comment>
            <comment line="580">
                height is calculated as the sum of two separately rounded up values                
            </comment>
            <comment line="581">
                because typically clients use ascent to determine the y location to                
            </comment>
            <comment line="582">
                pass to drawString etc and we need to ensure that the height has enough                
            </comment>
            <comment line="583">
                space below the baseline to fully contain any descender.                
            </comment>
            <declaration name="serialVersionUID" type="long" line="109"/>
            <declaration name="UNKNOWN_WIDTH" type="float" line="111"/>
            <declaration name="CURRENT_VERSION" type="int" line="112"/>
            <declaration name="roundingUpValue" type="float" line="118"/>
            <declaration name="font" type="Font" line="121"/>
            <declaration name="ascent" type="float" line="122"/>
            <declaration name="descent" type="float" line="123"/>
            <declaration name="leading" type="float" line="124"/>
            <declaration name="maxAdvance" type="float" line="125"/>
            <declaration name="matrix" type="double[]" line="126"/>
            <declaration name="cache" type="int[]" line="127"/>
            <declaration name="serVersion" type="int" line="130"/>
            <declaration name="isAntiAliased" type="boolean" line="131"/>
            <declaration name="usesFractionalMetrics" type="boolean" line="132"/>
            <declaration name="frcTx" type="AffineTransform" line="133"/>
            <declaration name="advCache" type="float[]" line="135"/>
            <declaration name="height" type="int" line="136"/>
            <declaration name="frc" type="FontRenderContext" line="138"/>
            <declaration name="devmatrix" type="double[]" line="140"/>
            <declaration name="fontStrike" type="FontStrike" line="142"/>
            <declaration name="DEFAULT_FRC" type="FontRenderContext" line="144"/>
            <method name="getDefaultFrc" type="FontRenderContext" line="146">
                <scope line="148">
                    <declaration name="tx" type="AffineTransform" line="149"/>
                    <scope line="150"/>
                    <scope line="152"/>
                </scope>
            </method>
            <class name="KeyReference" line="173">
                <extends class="SoftReference"/>
                <comment line="187">
                    It is possible that since this reference object has been
                     enqueued, that a new metrics has been put into the table
                     for the same key value. So we&apos;ll test to see if the table maps
                     to THIS reference. If its a new one, we&apos;ll leave it alone.
                     It is possible that a new entry comes in after our test, but
                     it is unlikely and if this were a problem we would need to
                     synchronize all &apos;put&apos; and &apos;remove&apos; accesses to the cache which
                     I would prefer not to do.                    
                </comment>
                <comment line="234">
                                        
                </comment>
                <comment line="533">
                    More efficient than base class implementation - reuses existing cache                    
                </comment>
                <implements interface="DisposerRecord"/>
                <implements interface="Disposer.PollDisposable"/>
                <declaration name="queue" type="ReferenceQueue" line="176"/>
                <declaration name="key" type="Object" line="178"/>
                <method name="KeyReference" type="constructor" line="180">
                    <params>
                        <param name="key" type="Object"/>
                        <param name="value" type="Object"/>
                    </params>
                </method>
                <method name="dispose" type="void" line="195">
                    <scope line="196"/>
                </method>
            </class>
            <class name="MetricsKey" line="202">
                <comment line="187">
                    It is possible that since this reference object has been
                     enqueued, that a new metrics has been put into the table
                     for the same key value. So we&apos;ll test to see if the table maps
                     to THIS reference. If its a new one, we&apos;ll leave it alone.
                     It is possible that a new entry comes in after our test, but
                     it is unlikely and if this were a problem we would need to
                     synchronize all &apos;put&apos; and &apos;remove&apos; accesses to the cache which
                     I would prefer not to do.                    
                </comment>
                <comment line="234">
                                        
                </comment>
                <comment line="533">
                    More efficient than base class implementation - reuses existing cache                    
                </comment>
                <declaration name="font" type="Font" line="203"/>
                <declaration name="frc" type="FontRenderContext" line="204"/>
                <declaration name="hash" type="int" line="205"/>
                <method name="MetricsKey" type="constructor" line="207"/>
                <method name="MetricsKey" type="constructor" line="210">
                    <params>
                        <param name="font" type="Font"/>
                        <param name="frc" type="FontRenderContext"/>
                    </params>
                </method>
                <method name="init" type="void" line="214">
                    <params>
                        <param name="font" type="Font"/>
                        <param name="frc" type="FontRenderContext"/>
                    </params>
                </method>
                <method name="equals" type="boolean" line="220">
                    <params>
                        <param name="key" type="Object"/>
                    </params>
                    <scope line="221"/>
                </method>
                <method name="hashCode" type="int" line="229"/>
                <declaration name="key" type="MetricsKey" line="234"/>
            </class>
            <declaration name="metricsCache" type="ConcurrentHashMap&lt;Object,KeyReference&gt;" line="241"/>
            <declaration name="MAXRECENT" type="int" line="244"/>
            <declaration name="recentMetrics" type="FontDesignMetrics[]" line="245"/>
            <declaration name="recentIndex" type="int" line="247"/>
            <method name="getMetrics" type="FontDesignMetrics" line="249">
                <params>
                    <param name="font" type="Font"/>
                </params>
            </method>
            <method name="getMetrics" type="FontDesignMetrics" line="254">
                <params>
                    <param name="font" type="Font"/>
                    <param name="frc" type="FontRenderContext"/>
                </params>
                <comment line="257">
                    When using alternate composites, can&apos;t cache based just on
                     the java.awt.Font. Since this is rarely used and we can still
                     cache the physical fonts, its not a problem to just return a
                     new instance in this case.
                     Note that currently Swing native L&amp;F composites are not handled
                     by this code as they use the metrics of the physical anyway.                    
                </comment>
                <comment line="273">
                    There are 2 possible keys used to perform lookups in metricsCache.
                     If the FRC is set to all defaults, we just use the font as the key.
                     If the FRC is non-default in any way, we construct a hybrid key
                     that combines the font and FRC.                    
                </comment>
                <comment line="282">
                                        
                </comment>
                <comment line="283">
                    NB synchronization is not needed here because of updates to                    
                </comment>
                <comment line="284">
                    the metrics cache but is needed for the shared key.                    
                </comment>
                <comment line="296">
                    either there was no reference, or it was cleared. Need a new
                     metrics instance. The key to use in the map is a new
                     MetricsKey instance when we&apos;ve determined the FRC is
                     non-default. Its constructed from local vars so we are
                     thread-safe - no need to worry about the shared key changing.                    
                </comment>
                <comment line="305">
                                        
                </comment>
                <comment line="311">
                                        
                </comment>
                <declaration name="fm" type="SunFontManager" line="264"/>
                <scope line="266"/>
                <declaration name="m" type="FontDesignMetrics" line="270"/>
                <declaration name="r" type="KeyReference" line="271"/>
                <declaration name="usefontkey" type="boolean" line="278"/>
                <scope line="280"/>
                <scope line="282">
                    <scope line="285"/>
                </scope>
                <scope line="291"/>
                <scope line="295">
                    <scope line="303"/>
                    <scope line="305">
                        <declaration name="newKey" type="MetricsKey" line="306"/>
                    </scope>
                </scope>
                <scope line="312">
                    <scope line="313"/>
                </scope>
                <scope line="318">
                    <scope line="320"/>
                </scope>
            </method>
            <method name="FontDesignMetrics" type="constructor" line="333">
                <params>
                    <param name="font" type="Font"/>
                </params>
            </method>
            <method name="FontDesignMetrics" type="constructor" line="339">
                <params>
                    <param name="font" type="Font"/>
                    <param name="frc" type="FontRenderContext"/>
                </params>
            </method>
            <method name="initMatrixAndMetrics" type="void" line="355">
                <declaration name="font2D" type="Font2D" line="357"/>
                <declaration name="metrics" type="StrikeMetrics" line="359"/>
            </method>
            <method name="initAdvCache" type="void" line="369">
                <comment line="371">
                    0 is a valid metric so force it to -1                    
                </comment>
                <scope line="372"/>
            </method>
            <method name="readObject" type="void" line="378">
                <params>
                    <param name="in" type="ObjectInputStream"/>
                </params>
                <comment line="391">
                    when deserialized, members are set to their default values for their type--                    
                </comment>
                <comment line="392">
                    not to the values assigned during initialization before the constructor                    
                </comment>
                <comment line="393">
                    body!                    
                </comment>
                <scope line="381"/>
                <scope line="387"/>
            </method>
            <method name="writeObject" type="void" line="402">
                <params>
                    <param name="out" type="ObjectOutputStream"/>
                </params>
                <scope line="405"/>
            </method>
            <method name="handleCharWidth" type="float" line="415">
                <params>
                    <param name="ch" type="int"/>
                </params>
                <comment line="416">
                    x-component of result only                    
                </comment>
            </method>
            <method name="getLatinCharWidth" type="float" line="421">
                <params>
                    <param name="ch" type="char"/>
                </params>
                <declaration name="w" type="float" line="423"/>
                <scope line="424"/>
            </method>
            <method name="getFontRenderContext" type="FontRenderContext" line="433"/>
            <method name="charWidth" type="int" line="437">
                <params>
                    <param name="ch" type="char"/>
                </params>
                <comment line="438">
                    default metrics for compatibility with legacy code                    
                </comment>
                <declaration name="w" type="float" line="439"/>
                <scope line="440"/>
                <scope line="443"/>
            </method>
            <method name="charWidth" type="int" line="449">
                <params>
                    <param name="ch" type="int"/>
                </params>
                <scope line="450"/>
                <declaration name="w" type="float" line="454"/>
            </method>
            <method name="stringWidth" type="int" line="459">
                <params>
                    <param name="str" type="String"/>
                </params>
                <comment line="463">
                                        
                </comment>
                <declaration name="width" type="float" line="461"/>
                <scope line="462">
                    <scope line="464"/>
                    <scope line="467"/>
                </scope>
                <scope line="471">
                    <declaration name="length" type="int" line="472"/>
                    <scope line="473">
                        <declaration name="ch" type="char" line="474"/>
                        <scope line="475"/>
                        <scope line="477"/>
                        <scope line="480"/>
                    </scope>
                </scope>
            </method>
            <method name="charsWidth" type="int" line="489">
                <params>
                    <param name="data" type="char"/>
                    <param name="off" type="int"/>
                    <param name="len" type="int"/>
                </params>
                <comment line="499">
                                        
                </comment>
                <declaration name="width" type="float" line="491"/>
                <scope line="492">
                    <scope line="493"/>
                    <declaration name="str" type="String" line="496"/>
                </scope>
                <scope line="498">
                    <scope line="500"/>
                    <declaration name="limit" type="int" line="503"/>
                    <scope line="504">
                        <declaration name="ch" type="char" line="505"/>
                        <scope line="506"/>
                        <scope line="508">
                            <declaration name="str" type="String" line="509"/>
                        </scope>
                        <scope line="512"/>
                    </scope>
                </scope>
            </method>
            <javadoc line="521">
                Gets the advance widths of the first 256 characters in the
                  &lt;code&gt;Font&lt;/code&gt;.  The advance is the
                  distance from the leftmost point to the rightmost point on the
                  character&apos;s baseline.  Note that the advance of a
                  &lt;code&gt;String&lt;/code&gt; is not necessarily the sum of the advances
                  of its characters.                
                <return>
                    an array storing the advance widths of the
                      characters in the <code>Font</code>
                      described by this <code>FontMetrics</code> object.                    
                </return>
            </javadoc>
            <method name="getWidths" type="int[]" line="533">
                <comment line="532">
                    More efficient than base class implementation - reuses existing cache                    
                </comment>
                <declaration name="widths" type="int[]" line="534"/>
                <scope line="535">
                    <declaration name="w" type="float" line="536"/>
                    <scope line="537"/>
                </scope>
            </method>
            <method name="getMaxAdvance" type="int" line="545"/>
            <method name="getAscent" type="int" line="554"/>
            <method name="getDescent" type="int" line="562"/>
            <method name="getLeading" type="int" line="566">
                <comment line="567">
                    nb this ensures the sum of the results of the public methods                    
                </comment>
                <comment line="568">
                    for leading, ascent &amp; descent sum to height.                    
                </comment>
                <comment line="569">
                    if the calculations in any other methods change this needs                    
                </comment>
                <comment line="570">
                    to be changed too.                    
                </comment>
                <comment line="571">
                    the 0.95 value used here and in the other methods allows some                    
                </comment>
                <comment line="572">
                    tiny fraction of leeway before rouding up. A higher value (0.99)                    
                </comment>
                <comment line="573">
                    caused some excessive rounding up.                    
                </comment>
            </method>
            <method name="getHeight" type="int" line="583">
                <scope line="585"/>
            </method>
        </class>
    </source>