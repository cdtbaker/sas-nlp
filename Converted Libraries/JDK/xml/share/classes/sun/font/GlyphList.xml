<?xml version="1.0" encoding="UTF-8"?>
    <source package="sun.font">
        <import package="java.awt.Font"/>
        <import package="java.awt.font.GlyphVector"/>
        <import package="java.awt.font.FontRenderContext"/>
        <import package="sun.java2d.loops.FontInfo"/>
        <class name="GlyphList" line="79">
            <comment line="89">
                A reference to the strike is needed for the case when the GlyphList
                 may be added to a queue for batch processing, (e.g. OpenGL) and we need
                 to be completely certain that the strike is still valid when the glyphs
                 images are later referenced.  This does mean that if such code discards
                 GlyphList and places only the data it contains on the queue, that the
                 strike needs to be part of that data held by a strong reference.
                 In the cases of drawString() and drawChars(), this is a single strike,
                 although it may be a composite strike.  In the case of
                 drawGlyphVector() it may be a single strike, or a list of strikes.                
            </comment>
            <comment line="99">
                hold multiple strikes during rendering of complex gv                
            </comment>
            <comment line="101">
                In normal usage, the same GlyphList will get recycled, so
                 it makes sense to allocate arrays that will get reused along with
                 it, rather than generating garbage. Garbage will be generated only
                 in MP envts where multiple threads are executing. Throughput should
                 still be higher in those cases.                
            </comment>
            <comment line="118">
                lcdRGBOrder is used only by LCD text rendering. Its here because
                 the Graphics may have a different hint value than the one used
                 by a GlyphVector, so it has to be stored here - and is obtained
                 from the right FontInfo. Another approach would have been to have
                 install a separate pipe for that case but that&apos;s a lot of extra
                 code when a simple boolean will suffice. The overhead to non-LCD
                 text is a redundant boolean assign per call.                
            </comment>
            <comment line="128">
                lcdSubPixPos is used only by LCD text rendering. Its here because
                 the Graphics may have a different hint value than the one used
                 by a GlyphVector, so it has to be stored here - and is obtained
                 from the right FontInfo. Its also needed by the code which
                 calculates glyph positions which already needs to access this
                 GlyphList and would otherwise need the FontInfo.
                 This is true only if LCD text and fractional metrics hints
                 are selected on the graphics.
                 When this is true and the glyph positions as determined by the
                 advances are non-integral, it requests adjustment of the positions.
                 Setting this for surfaces which do not support it through accelerated
                 loops may cause a slow-down as software loops are invoked instead.                
            </comment>
            <comment line="144">
                This scheme creates a singleton GlyphList which is checked out
                 for use. Callers who find its checked out create one that after use
                 is discarded. This means that in a MT-rendering environment,
                 there&apos;s no need to synchronise except for that one instance.
                 Fewer threads will then need to synchronise, perhaps helping
                 throughput on a MP system. If for some reason the reusable
                 GlyphList is checked out for a long time (or never returned?) then
                 we would end up always creating new ones. That situation should not
                 occur and if if did, it would just lead to some extra garbage being
                 created.                
            </comment>
            <comment line="183">
                private GlyphList(int arraylen) {                
            </comment>
            <comment line="184">
                ensureCapacity(arraylen);                
            </comment>
            <comment line="185">
                }                
            </comment>
            <comment line="209">
                In some cases the caller may be able to estimate the size of
                 array needed, and it will usually be long enough. This avoids
                 the unnecessary reallocation that occurs if our default
                 values are too small. This is useful because this object
                 will be discarded so the re-allocation overhead is high.                
            </comment>
            <comment line="215">
                public static GlyphList getInstance(int sz) {                
            </comment>
            <comment line="216">
                if (inUse) {                
            </comment>
            <comment line="217">
                return new GlyphList(sz);                
            </comment>
            <comment line="218">
                } else {                
            </comment>
            <comment line="219">
                synchronized(GlyphList.class) {                
            </comment>
            <comment line="220">
                if (inUse) {                
            </comment>
            <comment line="221">
                return new GlyphList();                
            </comment>
            <comment line="222">
                } else {                
            </comment>
            <comment line="223">
                inUse = true;                
            </comment>
            <comment line="224">
                return reusableGL;                
            </comment>
            <comment line="225">
                }                
            </comment>
            <comment line="226">
                }                
            </comment>
            <comment line="227">
                }                
            </comment>
            <comment line="228">
                }                
            </comment>
            <comment line="230">
                GlyphList is in an invalid state until setFrom method is called.
                 After obtaining a new GlyphList it is the caller&apos;s responsibility
                 that one of these methods is executed before handing off the
                 GlyphList                
            </comment>
            <comment line="319">
                This method now assumes &quot;state&quot;, so must be called 0-&gt;len
                 The metrics it returns are accumulated on the fly
                 So it could be renamed &quot;nextGlyph()&quot;.
                 Note that a laid out GlyphVector which has assigned glyph positions
                 doesn&apos;t have this stricture..                
            </comment>
            <comment line="422">
                There&apos;s a reference equality test overhead here, but it allows us
                 to avoid synchronizing for GL&apos;s that will just be GC&apos;d. This
                 helps MP throughput.                
            </comment>
            <comment line="437">
                The value here is for use by the rendering engine as it reflects
                 the number of glyphs in the array to be blitted. Surrogates pairs
                 may have two slots (the second of these being a dummy entry of the
                 invisible glyph), whereas an application client would expect only
                 one glyph. In other words don&apos;t propagate this value up to client code.
                
                 {dlf} an application client should have _no_ expectations about the
                 number of glyphs per char.  This ultimately depends on the font
                 technology and layout process used, which in general clients will
                 know nothing about.                
            </comment>
            <comment line="452">
                We re-do all this work as we iterate through the glyphs
                 but it seems unavoidable without re-working the Java TextRenderers.                
            </comment>
            <declaration name="MINGRAYLENGTH" type="int" line="80"/>
            <declaration name="MAXGRAYLENGTH" type="int" line="81"/>
            <declaration name="DEFAULT_LENGTH" type="int" line="82"/>
            <declaration name="glyphindex" type="int" line="84"/>
            <declaration name="metrics" type="int" line="85"/>
            <declaration name="graybits" type="byte" line="86"/>
            <declaration name="strikelist" type="Object" line="98"/>
            <declaration name="len" type="int" line="106"/>
            <declaration name="maxLen" type="int" line="107"/>
            <declaration name="maxPosLen" type="int" line="108"/>
            <declaration name="glyphData" type="int" line="109"/>
            <declaration name="chData" type="char" line="110"/>
            <declaration name="images" type="long" line="111"/>
            <declaration name="positions" type="float" line="112"/>
            <declaration name="x" type="float" line="113"/>
            <declaration name="gposx" type="float" line="114"/>
            <declaration name="usePositions" type="boolean" line="115"/>
            <declaration name="lcdRGBOrder" type="boolean" line="125"/>
            <declaration name="lcdSubPixPos" type="boolean" line="141"/>
            <declaration name="reusableGL" type="GlyphList" line="154"/>
            <declaration name="inUse" type="boolean" line="155"/>
            <method name="ensureCapacity" type="void" line="158">
                <params>
                    <param name="len" type="int"/>
                </params>
                <comment line="159">
                    Note len must not be -ve! only setFromChars should be capable
                     of passing down a -ve len, and this guards against it.                    
                </comment>
                <scope line="162"/>
                <scope line="165"/>
                <scope line="170"/>
            </method>
            <method name="GlyphList" type="constructor" line="178">
                <comment line="179">
                    ensureCapacity(DEFAULT_LENGTH);                    
                </comment>
            </method>
            <method name="getInstance" type="GlyphList" line="186">
                <comment line="187">
                    The following heuristic is that if the reusable instance is
                     in use, it probably still will be in a micro-second, so avoid
                     synchronising on the class and just allocate a new instance.
                     The cost is one extra boolean test for the normal case, and some
                     small number of cases where we allocate an extra object when
                     in fact the reusable one would be freed very soon.                    
                </comment>
                <scope line="194"/>
                <scope line="196">
                    <scope line="197">
                        <scope line="198"/>
                        <scope line="200"/>
                    </scope>
                </scope>
            </method>
            <method name="setFromString" type="boolean" line="235">
                <params>
                    <param name="info" type="FontInfo"/>
                    <param name="str" type="String"/>
                    <param name="x" type="float"/>
                    <param name="y" type="float"/>
                </params>
            </method>
            <method name="setFromChars" type="boolean" line="248">
                <params>
                    <param name="info" type="FontInfo"/>
                    <param name="chars" type="char[]"/>
                    <param name="off" type="int"/>
                    <param name="alen" type="int"/>
                    <param name="x" type="float"/>
                    <param name="y" type="float"/>
                </params>
                <scope line="255"/>
                <scope line="257"/>
            </method>
            <method name="mapChars" type="boolean" line="265">
                <params>
                    <param name="info" type="FontInfo"/>
                    <param name="len" type="int"/>
                </params>
                <comment line="266">
                    REMIND.Is it worthwhile for the iteration to convert
                     chars to glyph ids to directly map to images?                    
                </comment>
                <scope line="269"/>
            </method>
            <method name="setFromGlyphVector" type="void" line="279">
                <params>
                    <param name="info" type="FontInfo"/>
                    <param name="gv" type="GlyphVector"/>
                    <param name="x" type="float"/>
                    <param name="y" type="float"/>
                </params>
                <comment line="284">
                    A GV may be rendered in different Graphics. It is possible it is
                     used for one case where LCD text is available, and another where
                     it is not. Pass in the &quot;info&quot;. to ensure get a suitable one.                    
                </comment>
                <comment line="289">
                    call before ensureCapacity :-                    
                </comment>
                <declaration name="sgv" type="StandardGlyphVector" line="288"/>
            </method>
            <method name="getBounds" type="int[]" line="299">
                <comment line="300">
                    We co-opt the 5 element array that holds per glyph metrics in order
                     to return the bounds. So a caller must copy the data out of the
                     array before calling any other methods on this GlyphList                    
                </comment>
                <comment line="310">
                    gposx and gposy are used to accumulate the advance.                    
                </comment>
                <scope line="304"/>
                <scope line="307"/>
            </method>
            <method name="setGlyphIndex" type="void" line="324">
                <params>
                    <param name="i" type="int"/>
                </params>
                <comment line="337">
                                        
                </comment>
                <declaration name="gx" type="float" line="326"/>
                <declaration name="gy" type="float" line="328"/>
                <scope line="331"/>
                <scope line="334"/>
            </method>
            <method name="getMetrics" type="int[]" line="351"/>
            <method name="getGrayBits" type="byte[]" line="355">
                <comment line="377">
                    unsafe is supposed to be fast, but I doubt if this loop can beat
                     a native call which does a getPrimitiveArrayCritical and a
                     memcpy for the typical amount of image data (30-150 bytes)
                     Consider a native method if there is a performance problem (which
                     I haven&apos;t seen so far).                    
                </comment>
                <declaration name="len" type="int" line="356"/>
                <scope line="357"/>
                <scope line="359">
                    <scope line="360"/>
                </scope>
                <declaration name="pixelDataAddress" type="long" line="364"/>
                <scope line="365"/>
                <scope line="369"/>
                <scope line="374"/>
                <scope line="383"/>
            </method>
            <method name="getImages" type="long[]" line="389"/>
            <method name="usePositions" type="boolean" line="393"/>
            <method name="getPositions" type="float[]" line="397"/>
            <method name="getX" type="float" line="401"/>
            <method name="getY" type="float" line="405"/>
            <method name="getStrike" type="Object" line="409"/>
            <method name="isSubPixPos" type="boolean" line="413"/>
            <method name="isRGBOrder" type="boolean" line="417"/>
            <method name="dispose" type="void" line="425">
                <comment line="431">
                    remove reference to the strike list                    
                </comment>
                <scope line="426">
                    <scope line="427"/>
                </scope>
            </method>
            <method name="getNumGlyphs" type="int" line="447"/>
            <method name="fillBounds" type="void" line="454">
                <params>
                    <param name="bounds" type="int[]"/>
                </params>
                <comment line="455">
                                        
                </comment>
                <comment line="498">
                    floor is safe and correct because all glyph widths, heights
                     and offsets are integers                    
                </comment>
                <declaration name="xOffset" type="int" line="456"/>
                <declaration name="yOffset" type="int" line="457"/>
                <declaration name="wOffset" type="int" line="458"/>
                <declaration name="hOffset" type="int" line="459"/>
                <declaration name="xAdvOffset" type="int" line="460"/>
                <declaration name="yAdvOffset" type="int" line="461"/>
                <scope line="463"/>
                <declaration name="bx0" type="float" line="467"/>
                <declaration name="posIndex" type="int" line="471"/>
                <declaration name="glx" type="float" line="472"/>
                <declaration name="gly" type="float" line="473"/>
                <declaration name="gw" type="char" line="474"/>
                <declaration name="gx" type="float" line="475"/>
                <scope line="476">
                    <scope line="482"/>
                    <scope line="485"/>
                </scope>
            </method>
        </class>
    </source>