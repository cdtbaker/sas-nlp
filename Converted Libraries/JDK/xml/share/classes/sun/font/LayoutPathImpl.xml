<?xml version="1.0" encoding="UTF-8"?>
    <source package="sun.font">
        <import package="java.awt.Shape"/>
        <import package="java.awt.font.LayoutPath"/>
        <import package="java.awt.geom.AffineTransform"/>
        <import package="java.awt.geom.GeneralPath"/>
        <import package="java.awt.geom.NoninvertibleTransformException"/>
        <import package="java.awt.geom.PathIterator"/>
        <import package="java.awt.geom.Point2D"/>
        <import package="java.util.Formatter"/>
        <import package="java.util.ArrayList"/>
        <import package="java.awt.geom.PathIterator"/>
        <import package="java.lang.Math.abs"/>
        <import package="java.lang.Math.sqrt"/>
        <class name="LayoutPathImpl" line="50">
            <extends class="LayoutPath"/>
            <comment line="53">
                                
            </comment>
            <comment line="54">
                Convenience APIs                
            </comment>
            <comment line="55">
                                
            </comment>
            <comment line="79">
                                
            </comment>
            <comment line="80">
                extra utility APIs                
            </comment>
            <comment line="81">
                                
            </comment>
            <comment line="88">
                                
            </comment>
            <comment line="89">
                debugging flags                
            </comment>
            <comment line="90">
                                
            </comment>
            <comment line="110">
                                
            </comment>
            <comment line="111">
                Top level construction.                
            </comment>
            <comment line="112">
                                
            </comment>
            <method name="pointToPath" type="Point2D" line="56">
                <params>
                    <param name="x" type="double"/>
                    <param name="y" type="double"/>
                </params>
                <declaration name="pt" type="Point2D.Double" line="57"/>
            </method>
            <method name="pathToPoint" type="Point2D" line="62">
                <params>
                    <param name="a" type="double"/>
                    <param name="o" type="double"/>
                    <param name="preceding" type="boolean"/>
                </params>
                <declaration name="pt" type="Point2D.Double" line="63"/>
            </method>
            <method name="pointToPath" type="void" line="68">
                <params>
                    <param name="x" type="double"/>
                    <param name="y" type="double"/>
                    <param name="pt" type="Point2D"/>
                </params>
            </method>
            <method name="pathToPoint" type="void" line="73">
                <params>
                    <param name="a" type="double"/>
                    <param name="o" type="double"/>
                    <param name="preceding" type="boolean"/>
                    <param name="pt" type="Point2D"/>
                </params>
            </method>
            <method name="start" type="double" line="82"/>
            <method name="end" type="double" line="83"/>
            <method name="length" type="double" line="84"/>
            <method name="mapShape" type="Shape" line="85"/>
            <declaration name="LOGMAP" type="boolean" line="91"/>
            <declaration name="LOG" type="Formatter" line="92"/>
            <javadoc line="94">
                Indicate how positions past the start and limit of the
                  path are treated.  PINNED adjusts these positions so
                  as to be within start and limit.  EXTENDED ignores the
                  start and limit and effectively extends the first and
                  last segments of the path &apos;infinitely&apos;.  CLOSED wraps
                  positions around the ends of the path.                
            </javadoc>
            <method name="isPinned" type="boolean" line="104"/>
            <method name="isExtended" type="boolean" line="105"/>
            <method name="isClosed" type="boolean" line="106"/>
            <javadoc line="113">
                Return a path representing the path from the origin through the points in order.                
            </javadoc>
            <method name="getPath" type="LayoutPathImpl" line="116">
                <params>
                    <param name="etype" type="EndType"/>
                    <param name="coords" type="double"/>
                </params>
                <scope line="117"/>
            </method>
            <class name="SegmentPathBuilder" line="124">
                <comment line="314">
                    triplets x, y, a                    
                </comment>
                <comment line="330">
                                        
                </comment>
                <comment line="331">
                    LayoutPath API                    
                </comment>
                <comment line="332">
                                        
                </comment>
                <comment line="338">
                    the path consists of line segments, which i&apos;ll call                    
                </comment>
                <comment line="339">
                    &apos;path vectors&apos;.  call each run of path vectors a &apos;path segment&apos;.                    
                </comment>
                <comment line="340">
                    no path vector in a path segment is zero length (in the                    
                </comment>
                <comment line="341">
                    data, such vectors start a new path segment).                    
                </comment>
                <comment line="342">
                                        
                </comment>
                <comment line="343">
                    for each path segment...                    
                </comment>
                <comment line="344">
                                        
                </comment>
                <comment line="345">
                    for each path vector...                    
                </comment>
                <comment line="346">
                                        
                </comment>
                <comment line="347">
                    we look at the dot product of the path vector and the vector from the                    
                </comment>
                <comment line="348">
                    origin of the path vector to the test point.  if &lt;0 (case                    
                </comment>
                <comment line="349">
                    A), the projection of the test point is before the start of                    
                </comment>
                <comment line="350">
                    the path vector.  if &gt; the square of the length of the path vector                    
                </comment>
                <comment line="351">
                    (case B), the projection is past the end point of the                    
                </comment>
                <comment line="352">
                    path vector.  otherwise (case C), it lies on the path vector.                    
                </comment>
                <comment line="353">
                    determine the closeset point on the path vector.  if case A, it                    
                </comment>
                <comment line="354">
                    is the start of the path vector.  if case B and this is the last                    
                </comment>
                <comment line="355">
                    path vector in the path segment, it is the end of the path vector.  If                    
                </comment>
                <comment line="356">
                    case C, it is the projection onto the path vector.  Otherwise                    
                </comment>
                <comment line="357">
                    there is no closest point.                    
                </comment>
                <comment line="358">
                                        
                </comment>
                <comment line="359">
                    if we have a closest point, compare the distance from it to                    
                </comment>
                <comment line="360">
                    the test point against our current closest distance.                    
                </comment>
                <comment line="361">
                    (culling should be fast, currently i am using distance                    
                </comment>
                <comment line="362">
                    squared, but there&apos;s probably better ways).  if we&apos;re                    
                </comment>
                <comment line="363">
                    closer, save the new point as the current closest point,                    
                </comment>
                <comment line="364">
                    and record the path vector index so we can determine the final                    
                </comment>
                <comment line="365">
                    info if this turns out to be the closest point in the end.                    
                </comment>
                <comment line="366">
                                        
                </comment>
                <comment line="367">
                    after we have processed all the segments we will have                    
                </comment>
                <comment line="368">
                    tested each path vector and each endpoint.  if our point is not on                    
                </comment>
                <comment line="369">
                    an endpoint, we&apos;re done; we can compute the position and                    
                </comment>
                <comment line="370">
                    offset again, or if we saved it off we can just use it.  if                    
                </comment>
                <comment line="371">
                    we&apos;re on an endpoint we need to see which path vector we should                    
                </comment>
                <comment line="372">
                    associate with.  if we&apos;re at the start or end of a path segment,                    
                </comment>
                <comment line="373">
                    we&apos;re done-- the first or last vector of the segment is the                    
                </comment>
                <comment line="374">
                    one we associate with.  we project against that vector to                    
                </comment>
                <comment line="375">
                    get the offset, and pin to that vector to get the length.                    
                </comment>
                <comment line="376">
                                        
                </comment>
                <comment line="377">
                    otherwise, we compute the information as follows.  if the                    
                </comment>
                <comment line="378">
                    dot product (see above) with the following vector is zero,                    
                </comment>
                <comment line="379">
                    we associate with that vector.  otherwise, if the dot                    
                </comment>
                <comment line="380">
                    product with the previous vector is zero, we associate with                    
                </comment>
                <comment line="381">
                    that vector.  otherwise we&apos;re beyond the end of the                    
                </comment>
                <comment line="382">
                    previous vector and before the start of the current vector.                    
                </comment>
                <comment line="383">
                    we project against both vectors and get the distance from                    
                </comment>
                <comment line="384">
                    the test point to the projection (this will be the offset).                    
                </comment>
                <comment line="385">
                    if they are the same, we take the following vector.                    
                </comment>
                <comment line="386">
                    otherwise use the vector from which the test point is the                    
                </comment>
                <comment line="387">
                    _farthest_ (this is because the point lies most clearly in                    
                </comment>
                <comment line="388">
                    the half of the plane defined by extending that vector).                    
                </comment>
                <comment line="389">
                                        
                </comment>
                <comment line="390">
                    the returned position is the path length to the (possibly                    
                </comment>
                <comment line="391">
                    pinned) point, the offset is the projection onto the line                    
                </comment>
                <comment line="392">
                    along the vector, and we have a boolean flag which if false                    
                </comment>
                <comment line="393">
                    indicates that we associate with the previous vector at a                    
                </comment>
                <comment line="394">
                    junction (which is necessary when projecting such a                    
                </comment>
                <comment line="395">
                    location back to a point).                    
                </comment>
                <comment line="546">
                                        
                </comment>
                <comment line="547">
                    LayoutPathImpl API                    
                </comment>
                <comment line="548">
                                        
                </comment>
                <comment line="566">
                                        
                </comment>
                <comment line="567">
                    Utilities                    
                </comment>
                <comment line="568">
                                        
                </comment>
                <comment line="651">
                                        
                </comment>
                <comment line="652">
                    Mapping classes.                    
                </comment>
                <comment line="653">
                    Map the path onto each path segment.                    
                </comment>
                <comment line="654">
                    Record points where the advance &apos;enters&apos; and &apos;exits&apos; the path segment, and connect successive                    
                </comment>
                <comment line="655">
                    points when appropriate.                    
                </comment>
                <comment line="656">
                                        
                </comment>
                <comment line="929">
                                        
                </comment>
                <comment line="930">
                    for debugging                    
                </comment>
                <comment line="931">
                                        
                </comment>
                <javadoc line="124">
                    Use to build a SegmentPath.  This takes the data and preanalyzes it for
                      information that the SegmentPath needs, then constructs a SegmentPath
                      from that.  Mainly, this lets SegmentPath cache the lengths along
                      the path to each line segment, and so avoid calculating them over and over.                    
                </javadoc>
                <declaration name="data" type="double[]" line="131"/>
                <declaration name="w" type="int" line="132"/>
                <declaration name="px" type="double" line="133"/>
                <declaration name="py" type="double" line="134"/>
                <declaration name="a" type="double" line="135"/>
                <declaration name="pconnect" type="boolean" line="136"/>
                <javadoc line="138">
                    Construct a SegmentPathBuilder.                    
                </javadoc>
                <method name="SegmentPathBuilder" type="constructor" line="141"/>
                <javadoc line="144">
                    Reset the builder for a new path.  Datalen is a hint of how many
                      points will be in the path, and the working buffer will be sized
                      to accomodate at least this number of points.  If datalen is zero,
                      the working buffer is freed (it will be allocated on first use).                    
                </javadoc>
                <method name="reset" type="void" line="150">
                    <params>
                        <param name="datalen" type="int"/>
                    </params>
                    <scope line="151"/>
                    <scope line="153"/>
                </method>
                <javadoc line="161">
                    Automatically build from a list of points represented by pairs of
                      doubles.  Initial advance is zero.                    
                </javadoc>
                <method name="build" type="SegmentPath" line="165">
                    <params>
                        <param name="etype" type="EndType"/>
                        <param name="pts" type="double"/>
                    </params>
                    <scope line="170"/>
                </method>
                <javadoc line="177">
                    Move to a new point.  If there is no data, this will become the
                      first point.  If there is data, and the previous call was a lineTo, this
                      point is checked against the previous point, and if different, this
                      starts a new segment at the same advance as the end of the last
                      segment.  If there is data, and the previous call was a moveTo, this
                      replaces the point used for that previous call.
                      Calling this is optional, lineTo will suffice and the initial point
                      will be set to 0, 0.                    
                </javadoc>
                <method name="moveTo" type="void" line="188">
                    <params>
                        <param name="x" type="double"/>
                        <param name="y" type="double"/>
                    </params>
                </method>
                <javadoc line="192">
                    Connect to a new point.  If there is no data, the previous point
                      is presumed to be 0, 0.  This point is checked against
                      the previous point, and if different, this point is added to
                      the path and the advance extended.  If this point is the same as the
                      previous point, the path remains unchanged.                    
                </javadoc>
                <method name="lineTo" type="void" line="199">
                    <params>
                        <param name="x" type="double"/>
                        <param name="y" type="double"/>
                    </params>
                </method>
                <javadoc line="203">
                    Add a new point, and increment advance if connect is true.
                      This automatically rejects duplicate points and multiple disconnected points.                    
                </javadoc>
                <method name="nextPoint" type="void" line="208">
                    <params>
                        <param name="x" type="double"/>
                        <param name="y" type="double"/>
                        <param name="connect" type="boolean"/>
                    </params>
                    <comment line="210">
                        if zero length move or line, ignore                        
                    </comment>
                    <comment line="215">
                        this is the first point, make sure we have space                        
                    </comment>
                    <comment line="220">
                        default first point to 0, 0                        
                    </comment>
                    <comment line="224">
                        if multiple disconnected move, just update position, leave advance alone                        
                    </comment>
                    <comment line="231">
                        grow data to deal with new point                        
                    </comment>
                    <comment line="244">
                        update data                        
                    </comment>
                    <comment line="249">
                        update state                        
                    </comment>
                    <scope line="211"/>
                    <scope line="215">
                        <scope line="216"/>
                        <scope line="219"/>
                    </scope>
                    <scope line="225"/>
                    <scope line="232">
                        <declaration name="t" type="double[]" line="233"/>
                    </scope>
                    <scope line="238">
                        <declaration name="dx" type="double" line="239"/>
                        <declaration name="dy" type="double" line="240"/>
                    </scope>
                </method>
                <method name="complete" type="SegmentPath" line="255"/>
                <javadoc line="259">
                    Complete building a SegmentPath.  Once this is called, the builder is restored
                      to its initial state and information about the previous path is released.  The
                      end type indicates whether to treat the path as closed, extended, or pinned.                    
                </javadoc>
                <method name="complete" type="SegmentPath" line="264">
                    <params>
                        <param name="etype" type="EndType"/>
                    </params>
                    <comment line="273">
                        releases pointer to data                        
                    </comment>
                    <comment line="278">
                        reuses data, since we held on to it                        
                    </comment>
                    <declaration name="result" type="SegmentPath" line="265"/>
                    <scope line="267"/>
                    <scope line="271"/>
                    <scope line="274">
                        <declaration name="dataToAdopt" type="double[]" line="275"/>
                    </scope>
                </method>
            </class>
            <class name="SegmentPath" line="285">
                <extends class="LayoutPathImpl"/>
                <comment line="314">
                    triplets x, y, a                    
                </comment>
                <comment line="330">
                                        
                </comment>
                <comment line="331">
                    LayoutPath API                    
                </comment>
                <comment line="332">
                                        
                </comment>
                <comment line="338">
                    the path consists of line segments, which i&apos;ll call                    
                </comment>
                <comment line="339">
                    &apos;path vectors&apos;.  call each run of path vectors a &apos;path segment&apos;.                    
                </comment>
                <comment line="340">
                    no path vector in a path segment is zero length (in the                    
                </comment>
                <comment line="341">
                    data, such vectors start a new path segment).                    
                </comment>
                <comment line="342">
                                        
                </comment>
                <comment line="343">
                    for each path segment...                    
                </comment>
                <comment line="344">
                                        
                </comment>
                <comment line="345">
                    for each path vector...                    
                </comment>
                <comment line="346">
                                        
                </comment>
                <comment line="347">
                    we look at the dot product of the path vector and the vector from the                    
                </comment>
                <comment line="348">
                    origin of the path vector to the test point.  if &lt;0 (case                    
                </comment>
                <comment line="349">
                    A), the projection of the test point is before the start of                    
                </comment>
                <comment line="350">
                    the path vector.  if &gt; the square of the length of the path vector                    
                </comment>
                <comment line="351">
                    (case B), the projection is past the end point of the                    
                </comment>
                <comment line="352">
                    path vector.  otherwise (case C), it lies on the path vector.                    
                </comment>
                <comment line="353">
                    determine the closeset point on the path vector.  if case A, it                    
                </comment>
                <comment line="354">
                    is the start of the path vector.  if case B and this is the last                    
                </comment>
                <comment line="355">
                    path vector in the path segment, it is the end of the path vector.  If                    
                </comment>
                <comment line="356">
                    case C, it is the projection onto the path vector.  Otherwise                    
                </comment>
                <comment line="357">
                    there is no closest point.                    
                </comment>
                <comment line="358">
                                        
                </comment>
                <comment line="359">
                    if we have a closest point, compare the distance from it to                    
                </comment>
                <comment line="360">
                    the test point against our current closest distance.                    
                </comment>
                <comment line="361">
                    (culling should be fast, currently i am using distance                    
                </comment>
                <comment line="362">
                    squared, but there&apos;s probably better ways).  if we&apos;re                    
                </comment>
                <comment line="363">
                    closer, save the new point as the current closest point,                    
                </comment>
                <comment line="364">
                    and record the path vector index so we can determine the final                    
                </comment>
                <comment line="365">
                    info if this turns out to be the closest point in the end.                    
                </comment>
                <comment line="366">
                                        
                </comment>
                <comment line="367">
                    after we have processed all the segments we will have                    
                </comment>
                <comment line="368">
                    tested each path vector and each endpoint.  if our point is not on                    
                </comment>
                <comment line="369">
                    an endpoint, we&apos;re done; we can compute the position and                    
                </comment>
                <comment line="370">
                    offset again, or if we saved it off we can just use it.  if                    
                </comment>
                <comment line="371">
                    we&apos;re on an endpoint we need to see which path vector we should                    
                </comment>
                <comment line="372">
                    associate with.  if we&apos;re at the start or end of a path segment,                    
                </comment>
                <comment line="373">
                    we&apos;re done-- the first or last vector of the segment is the                    
                </comment>
                <comment line="374">
                    one we associate with.  we project against that vector to                    
                </comment>
                <comment line="375">
                    get the offset, and pin to that vector to get the length.                    
                </comment>
                <comment line="376">
                                        
                </comment>
                <comment line="377">
                    otherwise, we compute the information as follows.  if the                    
                </comment>
                <comment line="378">
                    dot product (see above) with the following vector is zero,                    
                </comment>
                <comment line="379">
                    we associate with that vector.  otherwise, if the dot                    
                </comment>
                <comment line="380">
                    product with the previous vector is zero, we associate with                    
                </comment>
                <comment line="381">
                    that vector.  otherwise we&apos;re beyond the end of the                    
                </comment>
                <comment line="382">
                    previous vector and before the start of the current vector.                    
                </comment>
                <comment line="383">
                    we project against both vectors and get the distance from                    
                </comment>
                <comment line="384">
                    the test point to the projection (this will be the offset).                    
                </comment>
                <comment line="385">
                    if they are the same, we take the following vector.                    
                </comment>
                <comment line="386">
                    otherwise use the vector from which the test point is the                    
                </comment>
                <comment line="387">
                    _farthest_ (this is because the point lies most clearly in                    
                </comment>
                <comment line="388">
                    the half of the plane defined by extending that vector).                    
                </comment>
                <comment line="389">
                                        
                </comment>
                <comment line="390">
                    the returned position is the path length to the (possibly                    
                </comment>
                <comment line="391">
                    pinned) point, the offset is the projection onto the line                    
                </comment>
                <comment line="392">
                    along the vector, and we have a boolean flag which if false                    
                </comment>
                <comment line="393">
                    indicates that we associate with the previous vector at a                    
                </comment>
                <comment line="394">
                    junction (which is necessary when projecting such a                    
                </comment>
                <comment line="395">
                    location back to a point).                    
                </comment>
                <comment line="546">
                                        
                </comment>
                <comment line="547">
                    LayoutPathImpl API                    
                </comment>
                <comment line="548">
                                        
                </comment>
                <comment line="566">
                                        
                </comment>
                <comment line="567">
                    Utilities                    
                </comment>
                <comment line="568">
                                        
                </comment>
                <comment line="651">
                                        
                </comment>
                <comment line="652">
                    Mapping classes.                    
                </comment>
                <comment line="653">
                    Map the path onto each path segment.                    
                </comment>
                <comment line="654">
                    Record points where the advance &apos;enters&apos; and &apos;exits&apos; the path segment, and connect successive                    
                </comment>
                <comment line="655">
                    points when appropriate.                    
                </comment>
                <comment line="656">
                                        
                </comment>
                <comment line="929">
                                        
                </comment>
                <comment line="930">
                    for debugging                    
                </comment>
                <comment line="931">
                                        
                </comment>
                <javadoc line="285">
                    Represents a path built from segments.  Each segment is
                      represented by a triple: x, y, and cumulative advance.
                      These represent the end point of the segment.  The start
                      point of the first segment is represented by the triple
                      at position 0.
                      The path might have breaks in it, e.g. it is not connected.
                      These will be represented by pairs of triplets that share the
                      same advance.
                      The path might be extended, pinned, or closed.  If extended,
                      the initial and final segments are considered to extend
                      &apos;indefinitely&apos; past the bounds of the advance.  If pinned,
                      they end at the bounds of the advance.  If closed,
                      advances before the start or after the end &apos;wrap around&apos; the
                      path.
                      The start of the path is the initial triple.  This provides
                      the nominal advance at the given x, y position (typically
                      zero).  The end of the path is the final triple.  This provides
                      the advance at the end, the total length of the path is
                      thus the ending advance minus the starting advance.
                      Note: We might want to cache more auxiliary data than the
                      advance, but this seems adequate for now.                    
                </javadoc>
                <declaration name="data" type="double[]" line="313"/>
                <declaration name="etype" type="EndType" line="314"/>
                <method name="get" type="SegmentPath" line="316">
                    <params>
                        <param name="etype" type="EndType"/>
                        <param name="pts" type="double"/>
                    </params>
                </method>
                <javadoc line="320">
                    Internal, use SegmentPathBuilder or one of the static
                      helper functions to construct a SegmentPath.                    
                </javadoc>
                <method name="SegmentPath" type="constructor" line="324">
                    <params>
                        <param name="data" type="double[]"/>
                        <param name="etype" type="EndType"/>
                    </params>
                </method>
                <method name="pathToPoint" type="void" line="333">
                    <params>
                        <param name="location" type="Point2D"/>
                        <param name="preceding" type="boolean"/>
                        <param name="point" type="Point2D"/>
                    </params>
                </method>
                <method name="pointToPath" type="boolean" line="396">
                    <params>
                        <param name="pt" type="Point2D"/>
                        <param name="result" type="Point2D"/>
                    </params>
                    <comment line="397">
                        test point                        
                    </comment>
                    <comment line="400">
                        previous point                        
                    </comment>
                    <comment line="404">
                        start with defaults                        
                    </comment>
                    <comment line="405">
                        current best distance from path, squared                        
                    </comment>
                    <comment line="406">
                        current best x                        
                    </comment>
                    <comment line="407">
                        current best y                        
                    </comment>
                    <comment line="408">
                        current best position along path                        
                    </comment>
                    <comment line="409">
                        current best index into data                        
                    </comment>
                    <comment line="412">
                        current end point                        
                    </comment>
                    <comment line="416">
                        vector from previous to current                        
                    </comment>
                    <comment line="420">
                        vector from previous to test point                        
                    </comment>
                    <comment line="423">
                        determine sign of dot product of vectors from bx, by                        
                    </comment>
                    <comment line="424">
                        if &lt; 0, we&apos;re before the start of this vector                        
                    </comment>
                    <comment line="426">
                        dot product                        
                    </comment>
                    <comment line="427">
                        hold closest point on vector as x, y, l                        
                    </comment>
                    <comment line="428">
                        hold index of line, is data.length if last point on path                        
                    </comment>
                    <comment line="429">
                        use break below, lets us avoid initializing vcx, vcy...                        
                    </comment>
                    <comment line="430">
                        moveto, or                        
                    </comment>
                    <comment line="431">
                        before path vector and                        
                    </comment>
                    <comment line="433">
                        closest point is start of vector                        
                    </comment>
                    <comment line="439">
                        aka dx * dx + dy * dy, square of length                        
                    </comment>
                    <comment line="440">
                        closest point is not past end of vector, or                        
                    </comment>
                    <comment line="441">
                        we&apos;re extended and at the last segment                        
                    </comment>
                    <comment line="443">
                        get parametric along segment                        
                    </comment>
                    <comment line="444">
                        compute closest point                        
                    </comment>
                    <comment line="450">
                        special case, always test last point                        
                    </comment>
                    <comment line="455">
                        typical case, skip point, we&apos;ll pick it up next iteration                        
                    </comment>
                    <comment line="460">
                        compute distance from (usually pinned) projection to test point                        
                    </comment>
                    <comment line="463">
                        new closest point, record info on it                        
                    </comment>
                    <comment line="477">
                        we have our closest point, get the info                        
                    </comment>
                    <comment line="480">
                        not on endpoint, no need to resolve                        
                    </comment>
                    <comment line="483">
                        have a true perpendicular, so can use distance                        
                    </comment>
                    <comment line="485">
                        determine sign of offset                        
                    </comment>
                    <comment line="489">
                        on endpoint, we need to resolve which segment                        
                    </comment>
                    <comment line="500">
                        associate with previous                        
                    </comment>
                    <comment line="503">
                        associate with following                        
                    </comment>
                    <declaration name="x" type="double" line="397"/>
                    <declaration name="y" type="double" line="398"/>
                    <declaration name="bx" type="double" line="400"/>
                    <declaration name="by" type="double" line="401"/>
                    <declaration name="bl" type="double" line="402"/>
                    <declaration name="cd2" type="double" line="405"/>
                    <declaration name="cx" type="double" line="406"/>
                    <declaration name="cy" type="double" line="407"/>
                    <declaration name="cl" type="double" line="408"/>
                    <declaration name="ci" type="int" line="409"/>
                    <scope line="411">
                        <declaration name="nx" type="double" line="412"/>
                        <declaration name="ny" type="double" line="413"/>
                        <declaration name="nl" type="double" line="414"/>
                        <declaration name="dx" type="double" line="416"/>
                        <declaration name="dy" type="double" line="417"/>
                        <declaration name="dl" type="double" line="418"/>
                        <declaration name="px" type="double" line="420"/>
                        <declaration name="py" type="double" line="421"/>
                        <declaration name="dot" type="double" line="426"/>
                        <declaration name="vcx" type="double" line="427"/>
                        <declaration name="vi" type="int" line="428"/>
                        <scope line="429">
                            <scope line="433"/>
                            <scope line="438">
                                <declaration name="l2" type="double" line="439"/>
                                <scope line="442">
                                    <declaration name="p" type="double" line="443"/>
                                </scope>
                                <scope line="448">
                                    <scope line="449"/>
                                    <scope line="454"/>
                                </scope>
                            </scope>
                            <declaration name="tdx" type="double" line="460"/>
                            <declaration name="tdy" type="double" line="461"/>
                            <declaration name="td2" type="double" line="462"/>
                            <scope line="463"/>
                        </scope>
                    </scope>
                    <scope line="480">
                        <declaration name="nx" type="double" line="481"/>
                        <declaration name="ny" type="double" line="482"/>
                        <declaration name="co" type="double" line="483"/>
                        <scope line="484"/>
                    </scope>
                    <scope line="489">
                        <declaration name="havePrev" type="boolean" line="490"/>
                        <declaration name="haveFoll" type="boolean" line="491"/>
                        <declaration name="doExtend" type="boolean" line="492"/>
                        <scope line="493">
                            <declaration name="pp" type="Point2D.Double" line="494"/>
                            <declaration name="fp" type="Point2D.Double" line="496"/>
                            <scope line="498"/>
                            <scope line="501"/>
                        </scope>
                        <scope line="505"/>
                        <scope line="509"/>
                    </scope>
                </method>
                <javadoc line="517">
                    Return the location of the point passed in result as mapped to the
                      line indicated by index.  If doExtend is true, extend the
                      x value without pinning to the ends of the line.
                      this assumes that index is valid and references a line that has
                      non-zero length.                    
                </javadoc>
                <method name="calcoffset" type="void" line="524">
                    <params>
                        <param name="index" type="int"/>
                        <param name="doExtend" type="boolean"/>
                        <param name="result" type="Point2D"/>
                    </params>
                    <comment line="533">
                        rx = A dot B / |B|                        
                    </comment>
                    <comment line="534">
                        ry = A dot invB / |B|                        
                    </comment>
                    <declaration name="bx" type="double" line="525"/>
                    <declaration name="by" type="double" line="526"/>
                    <declaration name="px" type="double" line="527"/>
                    <declaration name="py" type="double" line="528"/>
                    <declaration name="dx" type="double" line="529"/>
                    <declaration name="dy" type="double" line="530"/>
                    <declaration name="l" type="double" line="531"/>
                    <declaration name="rx" type="double" line="535"/>
                    <declaration name="ry" type="double" line="536"/>
                    <scope line="537"/>
                </method>
                <method name="mapShape" type="Shape" line="549">
                    <params>
                        <param name="s" type="Shape"/>
                    </params>
                </method>
                <method name="start" type="double" line="553"/>
                <method name="end" type="double" line="557"/>
                <method name="length" type="double" line="561"/>
                <javadoc line="569">
                    Get the &apos;modulus&apos; of an advance on a closed path.                    
                </javadoc>
                <method name="getClosedAdvance" type="double" line="572">
                    <params>
                        <param name="a" type="double"/>
                        <param name="preceding" type="boolean"/>
                    </params>
                    <scope line="573">
                        <declaration name="count" type="int" line="575"/>
                        <scope line="577"/>
                    </scope>
                </method>
                <javadoc line="586">
                    Return the index of the segment associated with advance. This
                      points to the start of the triple and is a multiple of 3 between
                      3 and data.length-3 inclusive.  It never points to a &apos;moveto&apos; triple.
                      If the path is closed, &apos;a&apos; is mapped to
                      a value between the start and end of the path, inclusive.
                      If preceding is true, and &apos;a&apos; lies on a segment boundary,
                      return the index of the preceding segment, else return the index
                      of the current segment (if it is not a moveto segment) otherwise
                      the following segment (which is never a moveto segment).
                      Note: if the path is not closed, the advance might not actually
                      lie on the returned segment-- it might be before the first, or
                      after the last.  The first or last segment (as appropriate)
                      will be returned in this case.                    
                </javadoc>
                <method name="getSegmentIndexForAdvance" type="int" line="603">
                    <params>
                        <param name="a" type="double"/>
                        <param name="preceding" type="boolean"/>
                    </params>
                    <comment line="604">
                        must have local advance                        
                    </comment>
                    <comment line="607">
                        note we must avoid &apos;moveto&apos; segments.  the first segment is                        
                    </comment>
                    <comment line="608">
                        always a moveto segment, so we always skip it.                        
                    </comment>
                    <comment line="616">
                        adjust to start of segment                        
                    </comment>
                    <declaration name="i" type="int" line="609"/>
                    <scope line="610">
                        <declaration name="v" type="double" line="611"/>
                        <scope line="612"/>
                    </scope>
                </method>
                <javadoc line="619">
                    Map a location based on the provided segment, returning in pt.
                      Seg must be a valid &apos;lineto&apos; segment.  Note: if the path is
                      closed, x must be within the start and end of the path.                    
                </javadoc>
                <method name="map" type="void" line="624">
                    <params>
                        <param name="seg" type="int"/>
                        <param name="a" type="double"/>
                        <param name="o" type="double"/>
                        <param name="pt" type="Point2D"/>
                    </params>
                    <comment line="629">
                        could cache these, but is it worth it?                        
                    </comment>
                    <declaration name="dx" type="double" line="625"/>
                    <declaration name="dy" type="double" line="626"/>
                    <declaration name="dl" type="double" line="627"/>
                    <declaration name="ux" type="double" line="629"/>
                    <declaration name="uy" type="double" line="630"/>
                </method>
                <javadoc line="638">
                    Map the point, and return the segment index.                    
                </javadoc>
                <method name="locateAndGetIndex" type="int" line="641">
                    <params>
                        <param name="loc" type="Point2D"/>
                        <param name="preceding" type="boolean"/>
                        <param name="result" type="Point2D"/>
                    </params>
                    <declaration name="a" type="double" line="642"/>
                    <declaration name="o" type="double" line="643"/>
                    <declaration name="seg" type="int" line="644"/>
                </method>
                <class name="LineInfo" line="657">
                    <comment line="664">
                        start                        
                    </comment>
                    <comment line="665">
                        limit                        
                    </comment>
                    <comment line="666">
                        slope dy/dx                        
                    </comment>
                    <comment line="757">
                        index into data array for this segment                        
                    </comment>
                    <comment line="758">
                        unit vector                        
                    </comment>
                    <comment line="760">
                        working line info                        
                    </comment>
                    <comment line="762">
                        true if a moveto has occurred since we last added to our path                        
                    </comment>
                    <comment line="763">
                        last point in gp                        
                    </comment>
                    <comment line="764">
                        path built for this segment                        
                    </comment>
                    <comment line="828">
                        working line info                        
                    </comment>
                    <comment line="829">
                        cache additional data on segments, working objects                        
                    </comment>
                    <comment line="830">
                        last moveto source point                        
                    </comment>
                    <comment line="831">
                        current source point                        
                    </comment>
                    <comment line="832">
                        true when last op was a moveto                        
                    </comment>
                    <javadoc line="657">
                        This represents a line segment from the iterator.  Each target segment will
                          interpret it, and since this process needs slope along the line
                          segment, this lets us compute it once and pass it around easily.                        
                    </javadoc>
                    <declaration name="sx" type="double" line="663"/>
                    <declaration name="lx" type="double" line="664"/>
                    <declaration name="m" type="double" line="665"/>
                    <javadoc line="667">
                        Set the lineinfo to this line                        
                    </javadoc>
                    <method name="set" type="void" line="670">
                        <params>
                            <param name="sx" type="double"/>
                            <param name="sy" type="double"/>
                            <param name="lx" type="double"/>
                            <param name="ly" type="double"/>
                        </params>
                        <comment line="677">
                            we&apos;ll check for this elsewhere                            
                        </comment>
                        <declaration name="dx" type="double" line="675"/>
                        <scope line="676"/>
                        <scope line="678">
                            <declaration name="dy" type="double" line="679"/>
                        </scope>
                    </method>
                    <method name="set" type="void" line="684">
                        <params>
                            <param name="rhs" type="LineInfo"/>
                        </params>
                    </method>
                    <javadoc line="692">
                        Return true if we intersect the infinitely tall rectangle with
                          lo &lt;= x &lt; hi.  If we do, also return the pinned portion of ourselves in
                          result.                        
                    </javadoc>
                    <method name="pin" type="boolean" line="697">
                        <params>
                            <param name="lo" type="double"/>
                            <param name="hi" type="double"/>
                            <param name="result" type="LineInfo"/>
                        </params>
                        <scope line="699">
                            <scope line="700">
                                <scope line="701"/>
                                <scope line="705"/>
                            </scope>
                        </scope>
                        <scope line="711">
                            <scope line="712">
                                <scope line="713"/>
                                <scope line="717"/>
                            </scope>
                        </scope>
                    </method>
                    <javadoc line="727">
                        Return true if we intersect the segment at ix.  This takes
                          the path end type into account and computes the relevant
                          parameters to pass to pin(double, double, LineInfo).                        
                    </javadoc>
                    <method name="pin" type="boolean" line="732">
                        <params>
                            <param name="ix" type="int"/>
                            <param name="result" type="LineInfo"/>
                        </params>
                        <comment line="743">
                            not implemented                            
                        </comment>
                        <declaration name="lo" type="double" line="733"/>
                        <declaration name="hi" type="double" line="734"/>
                    </method>
                </class>
                <class name="Segment" line="751">
                    <comment line="664">
                        start                        
                    </comment>
                    <comment line="665">
                        limit                        
                    </comment>
                    <comment line="666">
                        slope dy/dx                        
                    </comment>
                    <comment line="757">
                        index into data array for this segment                        
                    </comment>
                    <comment line="758">
                        unit vector                        
                    </comment>
                    <comment line="760">
                        working line info                        
                    </comment>
                    <comment line="762">
                        true if a moveto has occurred since we last added to our path                        
                    </comment>
                    <comment line="763">
                        last point in gp                        
                    </comment>
                    <comment line="764">
                        path built for this segment                        
                    </comment>
                    <comment line="828">
                        working line info                        
                    </comment>
                    <comment line="829">
                        cache additional data on segments, working objects                        
                    </comment>
                    <comment line="830">
                        last moveto source point                        
                    </comment>
                    <comment line="831">
                        current source point                        
                    </comment>
                    <comment line="832">
                        true when last op was a moveto                        
                    </comment>
                    <javadoc line="751">
                        Each segment will construct its own general path, mapping the provided lines
                          into its own simple space.                        
                    </javadoc>
                    <declaration name="ix" type="int" line="756"/>
                    <declaration name="ux" type="double" line="757"/>
                    <declaration name="temp" type="LineInfo" line="759"/>
                    <declaration name="broken" type="boolean" line="761"/>
                    <declaration name="cx" type="double" line="762"/>
                    <declaration name="gp" type="GeneralPath" line="763"/>
                    <method name="Segment" type="constructor" line="765">
                        <params>
                            <param name="ix" type="int"/>
                        </params>
                        <declaration name="len" type="double" line="767"/>
                    </method>
                    <method name="init" type="void" line="773"/>
                    <method name="move" type="void" line="780"/>
                    <method name="close" type="void" line="785">
                        <scope line="786"/>
                    </method>
                    <method name="line" type="void" line="792">
                        <params>
                            <param name="li" type="LineInfo"/>
                        </params>
                        <scope line="795">
                            <declaration name="sx" type="double" line="799"/>
                            <declaration name="sy" type="double" line="800"/>
                            <declaration name="lx" type="double" line="802"/>
                            <declaration name="ly" type="double" line="803"/>
                            <scope line="807">
                                <scope line="808"/>
                                <scope line="811"/>
                            </scope>
                        </scope>
                    </method>
                </class>
                <class name="Mapper" line="826">
                    <comment line="664">
                        start                        
                    </comment>
                    <comment line="665">
                        limit                        
                    </comment>
                    <comment line="666">
                        slope dy/dx                        
                    </comment>
                    <comment line="757">
                        index into data array for this segment                        
                    </comment>
                    <comment line="758">
                        unit vector                        
                    </comment>
                    <comment line="760">
                        working line info                        
                    </comment>
                    <comment line="762">
                        true if a moveto has occurred since we last added to our path                        
                    </comment>
                    <comment line="763">
                        last point in gp                        
                    </comment>
                    <comment line="764">
                        path built for this segment                        
                    </comment>
                    <comment line="828">
                        working line info                        
                    </comment>
                    <comment line="829">
                        cache additional data on segments, working objects                        
                    </comment>
                    <comment line="830">
                        last moveto source point                        
                    </comment>
                    <comment line="831">
                        current source point                        
                    </comment>
                    <comment line="832">
                        true when last op was a moveto                        
                    </comment>
                    <declaration name="li" type="LineInfo" line="827"/>
                    <declaration name="segments" type="ArrayList&lt;Segment&gt;" line="828"/>
                    <declaration name="mpt" type="Point2D.Double" line="829"/>
                    <declaration name="cpt" type="Point2D.Double" line="830"/>
                    <declaration name="haveMT" type="boolean" line="831"/>
                    <method name="Mapper" type="constructor" line="833">
                        <comment line="837">
                            a new segment                            
                        </comment>
                        <scope line="836">
                            <scope line="837"/>
                        </scope>
                    </method>
                    <method name="init" type="void" line="846">
                        <scope line="849"/>
                    </method>
                    <method name="moveTo" type="void" line="854">
                        <params>
                            <param name="x" type="double"/>
                            <param name="y" type="double"/>
                        </params>
                    </method>
                    <method name="lineTo" type="void" line="861">
                        <params>
                            <param name="x" type="double"/>
                            <param name="y" type="double"/>
                        </params>
                        <comment line="865">
                            prepare previous point for no-op check                            
                        </comment>
                        <comment line="871">
                            lineto is a no-op                            
                        </comment>
                        <comment line="876">
                            current point is the most recent moveto point                            
                        </comment>
                        <scope line="864"/>
                        <scope line="870"/>
                        <scope line="875">
                            <scope line="878"/>
                        </scope>
                        <scope line="884"/>
                    </method>
                    <method name="close" type="void" line="892">
                        <scope line="895"/>
                    </method>
                    <method name="mapShape" type="Shape" line="900">
                        <params>
                            <param name="s" type="Shape"/>
                        </params>
                        <comment line="902">
                            cheap way to handle curves.                            
                        </comment>
                        <declaration name="pi" type="PathIterator" line="902"/>
                        <declaration name="coords" type="double[]" line="907"/>
                        <scope line="908"/>
                        <declaration name="gp" type="GeneralPath" line="920"/>
                        <scope line="921"/>
                    </method>
                </class>
                <method name="toString" type="String" line="932">
                    <declaration name="b" type="StringBuilder" line="933"/>
                    <scope line="937">
                        <scope line="938"/>
                        <declaration name="x" type="float" line="941"/>
                        <declaration name="y" type="float" line="942"/>
                        <declaration name="l" type="float" line="943"/>
                    </scope>
                </method>
            </class>
            <class name="EmptyPath" line="958">
                <extends class="LayoutPathImpl"/>
                <comment line="314">
                    triplets x, y, a                    
                </comment>
                <comment line="330">
                                        
                </comment>
                <comment line="331">
                    LayoutPath API                    
                </comment>
                <comment line="332">
                                        
                </comment>
                <comment line="338">
                    the path consists of line segments, which i&apos;ll call                    
                </comment>
                <comment line="339">
                    &apos;path vectors&apos;.  call each run of path vectors a &apos;path segment&apos;.                    
                </comment>
                <comment line="340">
                    no path vector in a path segment is zero length (in the                    
                </comment>
                <comment line="341">
                    data, such vectors start a new path segment).                    
                </comment>
                <comment line="342">
                                        
                </comment>
                <comment line="343">
                    for each path segment...                    
                </comment>
                <comment line="344">
                                        
                </comment>
                <comment line="345">
                    for each path vector...                    
                </comment>
                <comment line="346">
                                        
                </comment>
                <comment line="347">
                    we look at the dot product of the path vector and the vector from the                    
                </comment>
                <comment line="348">
                    origin of the path vector to the test point.  if &lt;0 (case                    
                </comment>
                <comment line="349">
                    A), the projection of the test point is before the start of                    
                </comment>
                <comment line="350">
                    the path vector.  if &gt; the square of the length of the path vector                    
                </comment>
                <comment line="351">
                    (case B), the projection is past the end point of the                    
                </comment>
                <comment line="352">
                    path vector.  otherwise (case C), it lies on the path vector.                    
                </comment>
                <comment line="353">
                    determine the closeset point on the path vector.  if case A, it                    
                </comment>
                <comment line="354">
                    is the start of the path vector.  if case B and this is the last                    
                </comment>
                <comment line="355">
                    path vector in the path segment, it is the end of the path vector.  If                    
                </comment>
                <comment line="356">
                    case C, it is the projection onto the path vector.  Otherwise                    
                </comment>
                <comment line="357">
                    there is no closest point.                    
                </comment>
                <comment line="358">
                                        
                </comment>
                <comment line="359">
                    if we have a closest point, compare the distance from it to                    
                </comment>
                <comment line="360">
                    the test point against our current closest distance.                    
                </comment>
                <comment line="361">
                    (culling should be fast, currently i am using distance                    
                </comment>
                <comment line="362">
                    squared, but there&apos;s probably better ways).  if we&apos;re                    
                </comment>
                <comment line="363">
                    closer, save the new point as the current closest point,                    
                </comment>
                <comment line="364">
                    and record the path vector index so we can determine the final                    
                </comment>
                <comment line="365">
                    info if this turns out to be the closest point in the end.                    
                </comment>
                <comment line="366">
                                        
                </comment>
                <comment line="367">
                    after we have processed all the segments we will have                    
                </comment>
                <comment line="368">
                    tested each path vector and each endpoint.  if our point is not on                    
                </comment>
                <comment line="369">
                    an endpoint, we&apos;re done; we can compute the position and                    
                </comment>
                <comment line="370">
                    offset again, or if we saved it off we can just use it.  if                    
                </comment>
                <comment line="371">
                    we&apos;re on an endpoint we need to see which path vector we should                    
                </comment>
                <comment line="372">
                    associate with.  if we&apos;re at the start or end of a path segment,                    
                </comment>
                <comment line="373">
                    we&apos;re done-- the first or last vector of the segment is the                    
                </comment>
                <comment line="374">
                    one we associate with.  we project against that vector to                    
                </comment>
                <comment line="375">
                    get the offset, and pin to that vector to get the length.                    
                </comment>
                <comment line="376">
                                        
                </comment>
                <comment line="377">
                    otherwise, we compute the information as follows.  if the                    
                </comment>
                <comment line="378">
                    dot product (see above) with the following vector is zero,                    
                </comment>
                <comment line="379">
                    we associate with that vector.  otherwise, if the dot                    
                </comment>
                <comment line="380">
                    product with the previous vector is zero, we associate with                    
                </comment>
                <comment line="381">
                    that vector.  otherwise we&apos;re beyond the end of the                    
                </comment>
                <comment line="382">
                    previous vector and before the start of the current vector.                    
                </comment>
                <comment line="383">
                    we project against both vectors and get the distance from                    
                </comment>
                <comment line="384">
                    the test point to the projection (this will be the offset).                    
                </comment>
                <comment line="385">
                    if they are the same, we take the following vector.                    
                </comment>
                <comment line="386">
                    otherwise use the vector from which the test point is the                    
                </comment>
                <comment line="387">
                    _farthest_ (this is because the point lies most clearly in                    
                </comment>
                <comment line="388">
                    the half of the plane defined by extending that vector).                    
                </comment>
                <comment line="389">
                                        
                </comment>
                <comment line="390">
                    the returned position is the path length to the (possibly                    
                </comment>
                <comment line="391">
                    pinned) point, the offset is the projection onto the line                    
                </comment>
                <comment line="392">
                    along the vector, and we have a boolean flag which if false                    
                </comment>
                <comment line="393">
                    indicates that we associate with the previous vector at a                    
                </comment>
                <comment line="394">
                    junction (which is necessary when projecting such a                    
                </comment>
                <comment line="395">
                    location back to a point).                    
                </comment>
                <comment line="546">
                                        
                </comment>
                <comment line="547">
                    LayoutPathImpl API                    
                </comment>
                <comment line="548">
                                        
                </comment>
                <comment line="566">
                                        
                </comment>
                <comment line="567">
                    Utilities                    
                </comment>
                <comment line="568">
                                        
                </comment>
                <comment line="651">
                                        
                </comment>
                <comment line="652">
                    Mapping classes.                    
                </comment>
                <comment line="653">
                    Map the path onto each path segment.                    
                </comment>
                <comment line="654">
                    Record points where the advance &apos;enters&apos; and &apos;exits&apos; the path segment, and connect successive                    
                </comment>
                <comment line="655">
                    points when appropriate.                    
                </comment>
                <comment line="656">
                                        
                </comment>
                <comment line="929">
                                        
                </comment>
                <comment line="930">
                    for debugging                    
                </comment>
                <comment line="931">
                                        
                </comment>
                <declaration name="tx" type="AffineTransform" line="959"/>
                <method name="EmptyPath" type="constructor" line="961">
                    <params>
                        <param name="tx" type="AffineTransform"/>
                    </params>
                </method>
                <method name="pathToPoint" type="void" line="965">
                    <params>
                        <param name="location" type="Point2D"/>
                        <param name="preceding" type="boolean"/>
                        <param name="point" type="Point2D"/>
                    </params>
                    <scope line="966"/>
                    <scope line="968"/>
                </method>
                <method name="pointToPath" type="boolean" line="973">
                    <params>
                        <param name="pt" type="Point2D"/>
                        <param name="result" type="Point2D"/>
                    </params>
                    <scope line="975">
                        <scope line="976"/>
                        <scope line="979"/>
                    </scope>
                </method>
                <method name="start" type="double" line="985"/>
                <method name="end" type="double" line="987"/>
                <method name="length" type="double" line="989"/>
                <method name="mapShape" type="Shape" line="991">
                    <params>
                        <param name="s" type="Shape"/>
                    </params>
                    <scope line="992"/>
                </method>
            </class>
        </class>
    </source>