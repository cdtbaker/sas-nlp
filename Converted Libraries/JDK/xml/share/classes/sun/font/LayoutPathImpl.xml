<?xml version="1.0" encoding="UTF-8"?>
    <source package="sun.font">
        <import package="java.awt.Shape"/>
        <import package="java.awt.font.LayoutPath"/>
        <import package="java.awt.geom.AffineTransform"/>
        <import package="java.awt.geom.GeneralPath"/>
        <import package="java.awt.geom.NoninvertibleTransformException"/>
        <import package="java.awt.geom.PathIterator"/>
        <import package="java.awt.geom.Point2D"/>
        <import package="java.util.Formatter"/>
        <import package="java.util.ArrayList"/>
        <import package="java.awt.geom.PathIterator"/>
        <import package="java.lang.Math.abs"/>
        <import package="java.lang.Math.sqrt"/>
        <class name="LayoutPathImpl" line="14">
            <extends class="LayoutPath"/>
            <method name="pointToPath" type="Point2D" line="15">
                <params>
                    <param name="x" type="double"/>
                    <param name="y" type="double"/>
                </params>
                <declaration name="pt" type="Point2D.Double" line="16"/>
            </method>
            <method name="pathToPoint" type="Point2D" line="20">
                <params>
                    <param name="a" type="double"/>
                    <param name="o" type="double"/>
                    <param name="preceding" type="boolean"/>
                </params>
                <declaration name="pt" type="Point2D.Double" line="21"/>
            </method>
            <method name="pointToPath" type="void" line="25">
                <params>
                    <param name="x" type="double"/>
                    <param name="y" type="double"/>
                    <param name="pt" type="Point2D"/>
                </params>
            </method>
            <method name="pathToPoint" type="void" line="29">
                <params>
                    <param name="a" type="double"/>
                    <param name="o" type="double"/>
                    <param name="preceding" type="boolean"/>
                    <param name="pt" type="Point2D"/>
                </params>
            </method>
            <method name="start" type="double" line="33"/>
            <method name="end" type="double" line="34"/>
            <method name="length" type="double" line="35"/>
            <method name="mapShape" type="Shape" line="36"/>
            <declaration name="LOGMAP" type="boolean" line="37"/>
            <declaration name="LOG" type="Formatter" line="38"/>
            <declaration name="EndType" type="enum" line="39"/>
            <javadoc line="39">
                Indicate how positions past the start and limit of the
                  path are treated.  PINNED adjusts these positions so
                  as to be within start and limit.  EXTENDED ignores the
                  start and limit and effectively extends the first and
                  last segments of the path &apos;infinitely&apos;.  CLOSED wraps
                  positions around the ends of the path.                
            </javadoc>
            <scope line="47"/>
            <method name="isPinned" type="boolean" line="47"/>
            <method name="isExtended" type="boolean" line="50"/>
            <method name="isClosed" type="boolean" line="53"/>
            <scope line="-1"/>
            <javadoc line="57">
                Return a path representing the path from the origin through the points in order.                
            </javadoc>
            <method name="getPath" type="LayoutPathImpl" line="60">
                <params>
                    <param name="etype" type="EndType"/>
                    <param name="coords" type="double"/>
                </params>
                <scope line="61"/>
            </method>
            <class name="SegmentPathBuilder" line="66">
                <javadoc line="66">
                    Use to build a SegmentPath.  This takes the data and preanalyzes it for
                      information that the SegmentPath needs, then constructs a SegmentPath
                      from that.  Mainly, this lets SegmentPath cache the lengths along
                      the path to each line segment, and so avoid calculating them over and over.                    
                </javadoc>
                <declaration name="data" type="double[]" line="73"/>
                <declaration name="w" type="int" line="74"/>
                <declaration name="px" type="double" line="75"/>
                <declaration name="py" type="double" line="76"/>
                <declaration name="a" type="double" line="77"/>
                <declaration name="pconnect" type="boolean" line="78"/>
                <javadoc line="79">
                    Construct a SegmentPathBuilder.                    
                </javadoc>
                <method name="SegmentPathBuilder" type="constructor" line="82"/>
                <javadoc line="84">
                    Reset the builder for a new path.  Datalen is a hint of how many
                      points will be in the path, and the working buffer will be sized
                      to accomodate at least this number of points.  If datalen is zero,
                      the working buffer is freed (it will be allocated on first use).                    
                </javadoc>
                <method name="reset" type="void" line="90">
                    <params>
                        <param name="datalen" type="int"/>
                    </params>
                    <scope line="91"/>
                    <scope line="94"/>
                </method>
                <javadoc line="101">
                    Automatically build from a list of points represented by pairs of
                      doubles.  Initial advance is zero.                    
                </javadoc>
                <method name="build" type="SegmentPath" line="105">
                    <params>
                        <param name="etype" type="EndType"/>
                        <param name="pts" type="double"/>
                    </params>
                    <scope line="108"/>
                </method>
                <javadoc line="113">
                    Move to a new point.  If there is no data, this will become the
                      first point.  If there is data, and the previous call was a lineTo, this
                      point is checked against the previous point, and if different, this
                      starts a new segment at the same advance as the end of the last
                      segment.  If there is data, and the previous call was a moveTo, this
                      replaces the point used for that previous call.
                      Calling this is optional, lineTo will suffice and the initial point
                      will be set to 0, 0.                    
                </javadoc>
                <method name="moveTo" type="void" line="123">
                    <params>
                        <param name="x" type="double"/>
                        <param name="y" type="double"/>
                    </params>
                </method>
                <javadoc line="126">
                    Connect to a new point.  If there is no data, the previous point
                      is presumed to be 0, 0.  This point is checked against
                      the previous point, and if different, this point is added to
                      the path and the advance extended.  If this point is the same as the
                      previous point, the path remains unchanged.                    
                </javadoc>
                <method name="lineTo" type="void" line="133">
                    <params>
                        <param name="x" type="double"/>
                        <param name="y" type="double"/>
                    </params>
                </method>
                <javadoc line="136">
                    Add a new point, and increment advance if connect is true.
                      This automatically rejects duplicate points and multiple disconnected points.                    
                </javadoc>
                <method name="nextPoint" type="void" line="140">
                    <params>
                        <param name="x" type="double"/>
                        <param name="y" type="double"/>
                        <param name="connect" type="boolean"/>
                    </params>
                    <scope line="141"/>
                    <scope line="144">
                        <scope line="145"/>
                        <scope line="148"/>
                    </scope>
                    <scope line="152"/>
                    <scope line="157">
                        <declaration name="t" type="double[]" line="158"/>
                    </scope>
                    <scope line="162">
                        <declaration name="dx" type="double" line="163"/>
                        <declaration name="dy" type="double" line="164"/>
                    </scope>
                </method>
                <method name="complete" type="SegmentPath" line="174"/>
                <javadoc line="177">
                    Complete building a SegmentPath.  Once this is called, the builder is restored
                      to its initial state and information about the previous path is released.  The
                      end type indicates whether to treat the path as closed, extended, or pinned.                    
                </javadoc>
                <method name="complete" type="SegmentPath" line="182">
                    <params>
                        <param name="etype" type="EndType"/>
                    </params>
                    <declaration name="result" type="SegmentPath" line="183"/>
                    <scope line="184"/>
                    <scope line="187"/>
                    <scope line="191">
                        <declaration name="dataToAdopt" type="double[]" line="192"/>
                    </scope>
                </method>
            </class>
            <class name="SegmentPath" line="200">
                <extends class="LayoutPathImpl"/>
                <javadoc line="200">
                    Represents a path built from segments.  Each segment is
                      represented by a triple: x, y, and cumulative advance.
                      These represent the end point of the segment.  The start
                      point of the first segment is represented by the triple
                      at position 0.
                      The path might have breaks in it, e.g. it is not connected.
                      These will be represented by pairs of triplets that share the
                      same advance.
                      The path might be extended, pinned, or closed.  If extended,
                      the initial and final segments are considered to extend
                      &apos;indefinitely&apos; past the bounds of the advance.  If pinned,
                      they end at the bounds of the advance.  If closed,
                      advances before the start or after the end &apos;wrap around&apos; the
                      path.
                      The start of the path is the initial triple.  This provides
                      the nominal advance at the given x, y position (typically
                      zero).  The end of the path is the final triple.  This provides
                      the advance at the end, the total length of the path is
                      thus the ending advance minus the starting advance.
                      Note: We might want to cache more auxiliary data than the
                      advance, but this seems adequate for now.                    
                </javadoc>
                <declaration name="data" type="double[]" line="224"/>
                <declaration name="etype" type="EndType" line="225"/>
                <method name="get" type="SegmentPath" line="226">
                    <params>
                        <param name="etype" type="EndType"/>
                        <param name="pts" type="double"/>
                    </params>
                </method>
                <javadoc line="229">
                    Internal, use SegmentPathBuilder or one of the static
                      helper functions to construct a SegmentPath.                    
                </javadoc>
                <method name="SegmentPath" type="constructor" line="233">
                    <params>
                        <param name="data" type="double[]"/>
                        <param name="etype" type="EndType"/>
                    </params>
                </method>
                <method name="pathToPoint" type="void" line="237">
                    <params>
                        <param name="location" type="Point2D"/>
                        <param name="preceding" type="boolean"/>
                        <param name="point" type="Point2D"/>
                    </params>
                </method>
                <method name="pointToPath" type="boolean" line="240">
                    <params>
                        <param name="pt" type="Point2D"/>
                        <param name="result" type="Point2D"/>
                    </params>
                    <declaration name="x" type="double" line="241"/>
                    <declaration name="y" type="double" line="242"/>
                    <declaration name="bx" type="double" line="243"/>
                    <declaration name="by" type="double" line="244"/>
                    <declaration name="bl" type="double" line="245"/>
                    <declaration name="cd2" type="double" line="246"/>
                    <declaration name="cx" type="double" line="247"/>
                    <declaration name="cy" type="double" line="248"/>
                    <declaration name="cl" type="double" line="249"/>
                    <declaration name="ci" type="int" line="250"/>
                    <scope line="251">
                        <declaration name="nx" type="double" line="252"/>
                        <declaration name="ny" type="double" line="253"/>
                        <declaration name="nl" type="double" line="254"/>
                        <declaration name="dx" type="double" line="255"/>
                        <declaration name="dy" type="double" line="256"/>
                        <declaration name="dl" type="double" line="257"/>
                        <declaration name="px" type="double" line="258"/>
                        <declaration name="py" type="double" line="259"/>
                        <declaration name="dot" type="double" line="260"/>
                        <declaration name="vcx" type="double" line="261"/>
                        <declaration name="vi" type="int" line="262"/>
                        <scope line="263">
                            <scope line="264"/>
                            <scope line="270">
                                <declaration name="l2" type="double" line="271"/>
                                <scope line="272">
                                    <declaration name="p" type="double" line="273"/>
                                </scope>
                                <scope line="279">
                                    <scope line="280"/>
                                    <scope line="286"/>
                                </scope>
                            </scope>
                            <declaration name="tdx" type="double" line="291"/>
                            <declaration name="tdy" type="double" line="292"/>
                            <declaration name="td2" type="double" line="293"/>
                            <scope line="294"/>
                        </scope>
                    </scope>
                    <scope line="309">
                        <declaration name="nx" type="double" line="310"/>
                        <declaration name="ny" type="double" line="311"/>
                        <declaration name="co" type="double" line="312"/>
                        <scope line="313"/>
                    </scope>
                    <scope line="319">
                        <declaration name="havePrev" type="boolean" line="320"/>
                        <declaration name="haveFoll" type="boolean" line="321"/>
                        <declaration name="doExtend" type="boolean" line="322"/>
                        <scope line="323">
                            <declaration name="pp" type="Point2D.Double" line="324"/>
                            <declaration name="fp" type="Point2D.Double" line="326"/>
                            <scope line="328"/>
                            <scope line="332"/>
                        </scope>
                        <scope line="337"/>
                        <scope line="342"/>
                    </scope>
                </method>
                <javadoc line="349">
                    Return the location of the point passed in result as mapped to the
                      line indicated by index.  If doExtend is true, extend the
                      x value without pinning to the ends of the line.
                      this assumes that index is valid and references a line that has
                      non-zero length.                    
                </javadoc>
                <method name="calcoffset" type="void" line="356">
                    <params>
                        <param name="index" type="int"/>
                        <param name="doExtend" type="boolean"/>
                        <param name="result" type="Point2D"/>
                    </params>
                    <declaration name="bx" type="double" line="357"/>
                    <declaration name="by" type="double" line="358"/>
                    <declaration name="px" type="double" line="359"/>
                    <declaration name="py" type="double" line="360"/>
                    <declaration name="dx" type="double" line="361"/>
                    <declaration name="dy" type="double" line="362"/>
                    <declaration name="l" type="double" line="363"/>
                    <declaration name="rx" type="double" line="364"/>
                    <declaration name="ry" type="double" line="365"/>
                    <scope line="366"/>
                </method>
                <method name="mapShape" type="Shape" line="373">
                    <params>
                        <param name="s" type="Shape"/>
                    </params>
                </method>
                <method name="start" type="double" line="376"/>
                <method name="end" type="double" line="379"/>
                <method name="length" type="double" line="382"/>
                <javadoc line="385">
                    Get the &apos;modulus&apos; of an advance on a closed path.                    
                </javadoc>
                <method name="getClosedAdvance" type="double" line="388">
                    <params>
                        <param name="a" type="double"/>
                        <param name="preceding" type="boolean"/>
                    </params>
                    <scope line="389">
                        <declaration name="count" type="int" line="391"/>
                        <scope line="393"/>
                    </scope>
                </method>
                <javadoc line="400">
                    Return the index of the segment associated with advance. This
                      points to the start of the triple and is a multiple of 3 between
                      3 and data.length-3 inclusive.  It never points to a &apos;moveto&apos; triple.
                      If the path is closed, &apos;a&apos; is mapped to
                      a value between the start and end of the path, inclusive.
                      If preceding is true, and &apos;a&apos; lies on a segment boundary,
                      return the index of the preceding segment, else return the index
                      of the current segment (if it is not a moveto segment) otherwise
                      the following segment (which is never a moveto segment).
                      Note: if the path is not closed, the advance might not actually
                      lie on the returned segment-- it might be before the first, or
                      after the last.  The first or last segment (as appropriate)
                      will be returned in this case.                    
                </javadoc>
                <method name="getSegmentIndexForAdvance" type="int" line="415">
                    <params>
                        <param name="a" type="double"/>
                        <param name="preceding" type="boolean"/>
                    </params>
                    <declaration name="i" type="int" line="417"/>
                    <scope line="418">
                        <declaration name="v" type="double" line="419"/>
                        <scope line="420"/>
                    </scope>
                </method>
                <javadoc line="426">
                    Map a location based on the provided segment, returning in pt.
                      Seg must be a valid &apos;lineto&apos; segment.  Note: if the path is
                      closed, x must be within the start and end of the path.                    
                </javadoc>
                <method name="map" type="void" line="431">
                    <params>
                        <param name="seg" type="int"/>
                        <param name="a" type="double"/>
                        <param name="o" type="double"/>
                        <param name="pt" type="Point2D"/>
                    </params>
                    <declaration name="dx" type="double" line="432"/>
                    <declaration name="dy" type="double" line="433"/>
                    <declaration name="dl" type="double" line="434"/>
                    <declaration name="ux" type="double" line="435"/>
                    <declaration name="uy" type="double" line="436"/>
                </method>
                <javadoc line="440">
                    Map the point, and return the segment index.                    
                </javadoc>
                <method name="locateAndGetIndex" type="int" line="443">
                    <params>
                        <param name="loc" type="Point2D"/>
                        <param name="preceding" type="boolean"/>
                        <param name="result" type="Point2D"/>
                    </params>
                    <declaration name="a" type="double" line="444"/>
                    <declaration name="o" type="double" line="445"/>
                    <declaration name="seg" type="int" line="446"/>
                </method>
                <class name="LineInfo" line="450">
                    <javadoc line="450">
                        This represents a line segment from the iterator.  Each target segment will
                          interpret it, and since this process needs slope along the line
                          segment, this lets us compute it once and pass it around easily.                        
                    </javadoc>
                    <declaration name="sx" type="double" line="456"/>
                    <declaration name="lx" type="double" line="457"/>
                    <declaration name="m" type="double" line="458"/>
                    <javadoc line="459">
                        Set the lineinfo to this line                        
                    </javadoc>
                    <method name="set" type="void" line="462">
                        <params>
                            <param name="sx" type="double"/>
                            <param name="sy" type="double"/>
                            <param name="lx" type="double"/>
                            <param name="ly" type="double"/>
                        </params>
                        <declaration name="dx" type="double" line="467"/>
                        <scope line="468"/>
                        <scope line="471">
                            <declaration name="dy" type="double" line="472"/>
                        </scope>
                    </method>
                    <method name="set" type="void" line="476">
                        <params>
                            <param name="rhs" type="LineInfo"/>
                        </params>
                    </method>
                    <javadoc line="483">
                        Return true if we intersect the infinitely tall rectangle with
                          lo &lt;= x &lt; hi.  If we do, also return the pinned portion of ourselves in
                          result.                        
                    </javadoc>
                    <method name="pin" type="boolean" line="488">
                        <params>
                            <param name="lo" type="double"/>
                            <param name="hi" type="double"/>
                            <param name="result" type="LineInfo"/>
                        </params>
                        <scope line="490">
                            <scope line="491">
                                <scope line="492"/>
                                <scope line="496"/>
                            </scope>
                        </scope>
                        <scope line="503">
                            <scope line="504">
                                <scope line="505"/>
                                <scope line="509"/>
                            </scope>
                        </scope>
                    </method>
                    <javadoc line="518">
                        Return true if we intersect the segment at ix.  This takes
                          the path end type into account and computes the relevant
                          parameters to pass to pin(double, double, LineInfo).                        
                    </javadoc>
                    <method name="pin" type="boolean" line="523">
                        <params>
                            <param name="ix" type="int"/>
                            <param name="result" type="LineInfo"/>
                        </params>
                        <declaration name="lo" type="double" line="524"/>
                        <declaration name="hi" type="double" line="525"/>
                    </method>
                </class>
                <class name="Segment" line="539">
                    <javadoc line="539">
                        Each segment will construct its own general path, mapping the provided lines
                          into its own simple space.                        
                    </javadoc>
                    <declaration name="ix" type="int" line="544"/>
                    <declaration name="ux" type="double" line="545"/>
                    <declaration name="temp" type="LineInfo" line="546"/>
                    <declaration name="broken" type="boolean" line="547"/>
                    <declaration name="cx" type="double" line="548"/>
                    <declaration name="gp" type="GeneralPath" line="549"/>
                    <method name="Segment" type="constructor" line="550">
                        <params>
                            <param name="ix" type="int"/>
                        </params>
                        <declaration name="len" type="double" line="552"/>
                    </method>
                    <method name="init" type="void" line="557"/>
                    <method name="move" type="void" line="563"/>
                    <method name="close" type="void" line="567">
                        <scope line="568"/>
                    </method>
                    <method name="line" type="void" line="573">
                        <params>
                            <param name="li" type="LineInfo"/>
                        </params>
                        <scope line="575">
                            <declaration name="sx" type="double" line="578"/>
                            <declaration name="sy" type="double" line="579"/>
                            <declaration name="lx" type="double" line="581"/>
                            <declaration name="ly" type="double" line="582"/>
                            <scope line="584">
                                <scope line="585"/>
                                <scope line="589"/>
                            </scope>
                        </scope>
                    </method>
                </class>
                <class name="Mapper" line="602">
                    <declaration name="li" type="LineInfo" line="603"/>
                    <declaration name="segments" type="ArrayList&amp;lt;Segment&amp;gt;" line="604"/>
                    <declaration name="mpt" type="Point2D.Double" line="605"/>
                    <declaration name="cpt" type="Point2D.Double" line="606"/>
                    <declaration name="haveMT" type="boolean" line="607"/>
                    <method name="Mapper" type="constructor" line="608">
                        <scope line="611">
                            <scope line="612"/>
                        </scope>
                    </method>
                    <method name="init" type="void" line="619">
                        <scope line="622"/>
                    </method>
                    <method name="moveTo" type="void" line="626">
                        <params>
                            <param name="x" type="double"/>
                            <param name="y" type="double"/>
                        </params>
                    </method>
                    <method name="lineTo" type="void" line="632">
                        <params>
                            <param name="x" type="double"/>
                            <param name="y" type="double"/>
                        </params>
                        <scope line="634"/>
                        <scope line="638"/>
                        <scope line="641">
                            <scope line="643"/>
                        </scope>
                        <scope line="648"/>
                    </method>
                    <method name="close" type="void" line="654">
                        <scope line="657"/>
                    </method>
                    <method name="mapShape" type="Shape" line="661">
                        <params>
                            <param name="s" type="Shape"/>
                        </params>
                        <declaration name="pi" type="PathIterator" line="663"/>
                        <declaration name="coords" type="double[]" line="666"/>
                        <scope line="667"/>
                        <declaration name="gp" type="GeneralPath" line="684"/>
                        <scope line="685"/>
                    </method>
                </class>
                <method name="toString" type="String" line="691">
                    <declaration name="b" type="StringBuilder" line="692"/>
                    <scope line="696">
                        <scope line="697"/>
                        <declaration name="x" type="float" line="700"/>
                        <declaration name="y" type="float" line="701"/>
                        <declaration name="l" type="float" line="702"/>
                    </scope>
                </method>
            </class>
            <class name="EmptyPath" line="715">
                <extends class="LayoutPathImpl"/>
                <declaration name="tx" type="AffineTransform" line="716"/>
                <method name="EmptyPath" type="constructor" line="717">
                    <params>
                        <param name="tx" type="AffineTransform"/>
                    </params>
                </method>
                <method name="pathToPoint" type="void" line="720">
                    <params>
                        <param name="location" type="Point2D"/>
                        <param name="preceding" type="boolean"/>
                        <param name="point" type="Point2D"/>
                    </params>
                    <scope line="721"/>
                    <scope line="724"/>
                </method>
                <method name="pointToPath" type="boolean" line="728">
                    <params>
                        <param name="pt" type="Point2D"/>
                        <param name="result" type="Point2D"/>
                    </params>
                    <scope line="730">
                        <scope line="731"/>
                        <scope line="734"/>
                    </scope>
                </method>
                <method name="start" type="double" line="739"/>
                <method name="end" type="double" line="742"/>
                <method name="length" type="double" line="745"/>
                <method name="mapShape" type="Shape" line="748">
                    <params>
                        <param name="s" type="Shape"/>
                    </params>
                    <scope line="749"/>
                </method>
            </class>
        </class>
    </source>