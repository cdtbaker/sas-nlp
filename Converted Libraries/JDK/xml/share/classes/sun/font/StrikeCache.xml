<?xml version="1.0" encoding="UTF-8"?>
    <source package="sun.font">
        <import package="java.awt.GraphicsConfiguration"/>
        <import package="java.awt.GraphicsEnvironment"/>
        <import package="java.lang.ref.Reference"/>
        <import package="java.lang.ref.ReferenceQueue"/>
        <import package="java.lang.ref.SoftReference"/>
        <import package="java.lang.ref.WeakReference"/>
        <import package="java.util"/>
        <import package="sun.java2d.Disposer"/>
        <import package="sun.java2d.pipe.BufferedContext"/>
        <import package="sun.java2d.pipe.RenderQueue"/>
        <import package="sun.java2d.pipe.hw.AccelGraphicsConfig"/>
        <import package="sun.misc.Unsafe"/>
        <class name="StrikeCache" line="42">
            <comment line="74">
                Reference objects may have their referents cleared when GC chooses.
                 During application client start-up there is typically at least one
                 GC which causes the hotspot VM to clear soft (not just weak) references
                 Thus not only is there a GC pause, but the work done do rasterise
                 glyphs that are fairly certain to be needed again almost immediately
                 is thrown away. So for performance reasons a simple optimisation is to
                 keep up to 8 strong references to strikes to reduce the chance of
                 GC&apos;ing strikes that have been used recently. Note that this may not
                 suffice in Solaris UTF-8 locales where a single composite strike may be
                 composed of 15 individual strikes, plus the composite strike.
                 And this assumes the new architecture doesn&apos;t maintain strikes for
                 natively accessed bitmaps. It may be worth &quot;tuning&quot; the number of
                 strikes kept around for the platform or locale.
                 Since no attempt is made to ensure uniqueness or ensure synchronized
                 access there is no guarantee that this cache will ensure that unique
                 strikes are cached. Every time a strike is looked up it is added
                 to the current index in this cache. All this cache has to do to be
                 worthwhile is prevent excessive cache flushing of strikes that are
                 referenced frequently. The logic that adds references here could be
                 tweaked to keep only strikes  that represent untransformed, screen
                 sizes as that&apos;s the typical performance case.                
            </comment>
            <comment line="96">
                can be overridden by property                
            </comment>
            <comment line="101">
                Native sizes and offsets for glyph cache
                 There are 10 values.                
            </comment>
            <comment line="120">
                Native method used to return information used for unsafe
                 access to native data.
                 return values as follows:-
                 arr[0] = size of an addresspointer.
                 arr[1] = size of a GlyphInfo
                 arr[2] = offset of advanceX
                 arr[3] = offset of advanceY
                 arr[4] = offset of width
                 arr[5] = offset of height
                 arr[6] = offset of rowBytes
                 arr[7] = offset of topLeftX
                 arr[8] = offset of topLeftY
                 arr[9] = offset of pixel data.
                 arr[10] = address of a GlyphImageRef representing the invisible glyph                
            </comment>
            <javadoc line="42">
                A FontStrike is the keeper of scaled glyph image data which is expensive
                  to compute so needs to be cached.
                  So long as that data may be being used it cannot be invalidated.
                  Yet we also need to limit the amount of native memory and number of
                  strike objects in use.
                  For scaleability and ease of use, a key goal is multi-threaded read
                  access to a strike, so that it may be shared by multiple client objects,
                  potentially executing on different threads, with no special reference
                  counting or &quot;check-out/check-in&quot; requirements which would pass on the
                  burden of keeping track of strike references to the SG2D and other clients.
                  A cache of strikes is maintained via Reference objects.
                  This helps in two ways :
                  1. The VM will free references when memory is low or they have not been
                  used in a long time.
                  2. Reference queues provide a way to get notification of this so we can
                  free native memory resources.                
            </javadoc>
            <declaration name="unsafe" type="Unsafe" line="66"/>
            <declaration name="refQueue" type="ReferenceQueue" line="68"/>
            <declaration name="disposeListeners" type="ArrayList&lt;GlyphDisposedListener&gt;" line="70"/>
            <declaration name="MINSTRIKES" type="int" line="95"/>
            <declaration name="recentStrikeIndex" type="int" line="96"/>
            <declaration name="recentStrikes" type="FontStrike[]" line="97"/>
            <declaration name="cacheRefTypeWeak" type="boolean" line="98"/>
            <declaration name="nativeAddressSize" type="int" line="104"/>
            <declaration name="glyphInfoSize" type="int" line="105"/>
            <declaration name="xAdvanceOffset" type="int" line="106"/>
            <declaration name="yAdvanceOffset" type="int" line="107"/>
            <declaration name="boundsOffset" type="int" line="108"/>
            <declaration name="widthOffset" type="int" line="109"/>
            <declaration name="heightOffset" type="int" line="110"/>
            <declaration name="rowBytesOffset" type="int" line="111"/>
            <declaration name="topLeftXOffset" type="int" line="112"/>
            <declaration name="topLeftYOffset" type="int" line="113"/>
            <declaration name="pixelDataOffset" type="int" line="114"/>
            <declaration name="cacheCellOffset" type="int" line="115"/>
            <declaration name="managedOffset" type="int" line="116"/>
            <declaration name="invisibleGlyphPtr" type="long" line="117"/>
            <method name="getGlyphCacheDescription" type="void" line="134"/>
            <scope line="136">
                <declaration name="nativeInfo" type="long[]" line="138"/>
                <scope line="156"/>
                <anonymous_class line="162">
                    <method name="run" type="Object" line="163">
                        <comment line="166">
                            Allow a client to override the reference type used to
                             cache strikes. The default is &quot;soft&quot; which hints to keep
                             the strikes around. This property allows the client to
                             override this to &quot;weak&quot; which hint to the GC to free
                             memory more agressively.                            
                        </comment>
                        <declaration name="refType" type="String" line="171"/>
                        <declaration name="minStrikesStr" type="String" line="175"/>
                        <scope line="177">
                            <scope line="178">
                                <scope line="180"/>
                            </scope>
                            <scope line="183"/>
                        </scope>
                    </method>
                </anonymous_class>
            </scope>
            <method name="refStrike" type="void" line="195">
                <params>
                    <param name="strike" type="FontStrike"/>
                </params>
                <declaration name="index" type="int" line="196"/>
                <scope line="199"/>
            </method>
            <method name="doDispose" type="void" line="205">
                <params>
                    <param name="disposer" type="FontStrikeDisposer"/>
                </params>
                <comment line="214">
                    NB Now making multiple JNI calls in this case.
                     But assuming that there&apos;s a reasonable amount of locality
                     rather than sparse references then it should be OK.                    
                </comment>
                <comment line="222">
                                        
                </comment>
                <comment line="227">
                    This may appear inefficient but it should only be invoked
                     for a strike that never was asked to rasterise a glyph.                    
                </comment>
                <comment line="246">
                    Rarely a strike may have been created that never cached
                     any glyphs. In this case we still want to free the scaler
                     context.                    
                </comment>
                <scope line="206"/>
                <scope line="209"/>
                <scope line="212">
                    <scope line="217">
                        <scope line="218"/>
                    </scope>
                    <scope line="229"/>
                </scope>
                <scope line="232">
                    <scope line="233">
                        <scope line="234"/>
                    </scope>
                    <scope line="241"/>
                </scope>
                <scope line="244">
                    <scope line="249"/>
                    <scope line="251"/>
                </scope>
            </method>
            <method name="longAddresses" type="boolean" line="257"/>
            <method name="disposeStrike" type="void" line="261">
                <params>
                    <param name="disposer" type="FontStrikeDisposer"/>
                </params>
                <comment line="263">
                    we need to execute the strike disposal on the rendering thread
                     because they may be accessed on that thread at the time of the
                     disposal (for example, when the accel. cache is invalidated)                    
                </comment>
                <comment line="267">
                    Whilst this is a bit heavyweight, in most applications
                     strike disposal is a relatively infrequent operation, so it
                     doesn&apos;t matter. But in some tests that use vast numbers
                     of strikes, the switching back and forth is measurable.
                     So the &quot;pollRemove&quot; call is added to batch up the work.
                     If we are polling we know we&apos;ve already been called back
                     and can directly dispose the record.
                     Also worrisome is the necessity of getting a GC here.                    
                </comment>
                <scope line="275"/>
                <declaration name="rq" type="RenderQueue" line="280"/>
                <declaration name="ge" type="GraphicsEnvironment" line="281"/>
                <scope line="283">
                    <declaration name="gc" type="GraphicsConfiguration" line="284"/>
                    <scope line="286">
                        <declaration name="agc" type="AccelGraphicsConfig" line="287"/>
                        <declaration name="bc" type="BufferedContext" line="288"/>
                        <scope line="289"/>
                    </scope>
                </scope>
                <scope line="294">
                    <scope line="296">
                        <anonymous_class line="297">
                            <method name="run" type="void" line="298"/>
                        </anonymous_class>
                    </scope>
                    <scope line="303"/>
                </scope>
                <scope line="306"/>
            </method>
            <method name="freeIntPointer" type="void" line="311"/>
            <method name="freeLongPointer" type="void" line="312"/>
            <method name="freeIntMemory" type="void" line="313"/>
            <method name="freeLongMemory" type="void" line="314"/>
            <method name="freeCachedIntMemory" type="void" line="316">
                <params>
                    <param name="glyphPtrs" type="int[]"/>
                    <param name="pContext" type="long"/>
                </params>
                <comment line="333">
                    Any reference by the disposers to the native glyph ptrs
                     must be done before this returns.                    
                </comment>
                <scope line="317">
                    <scope line="318">
                        <declaration name="gids" type="ArrayList&lt;Long&gt;" line="319"/>
                        <scope line="321">
                            <scope line="322">
                                <scope line="324"/>
                            </scope>
                        </scope>
                        <scope line="331"/>
                    </scope>
                </scope>
            </method>
            <method name="freeCachedLongMemory" type="void" line="342">
                <params>
                    <param name="glyphPtrs" type="long[]"/>
                    <param name="pContext" type="long"/>
                </params>
                <comment line="360">
                    Any reference by the disposers to the native glyph ptrs
                     must be done before this returns.                    
                </comment>
                <scope line="343">
                    <scope line="344">
                        <declaration name="gids" type="ArrayList&lt;Long&gt;" line="345"/>
                        <scope line="347">
                            <scope line="349">
                                <scope line="351"/>
                            </scope>
                        </scope>
                        <scope line="358"/>
                    </scope>
                </scope>
            </method>
            <method name="addGlyphDisposedListener" type="void" line="369">
                <params>
                    <param name="listener" type="GlyphDisposedListener"/>
                </params>
                <scope line="370"/>
            </method>
            <method name="notifyDisposeListeners" type="void" line="375">
                <params>
                    <param name="glyphs" type="ArrayList<Long>"/>
                </params>
                <scope line="376"/>
            </method>
            <method name="getStrikeRef" type="Reference" line="381">
                <params>
                    <param name="strike" type="FontStrike"/>
                </params>
            </method>
            <method name="getStrikeRef" type="Reference" line="385">
                <params>
                    <param name="strike" type="FontStrike"/>
                    <param name="weak" type="boolean"/>
                </params>
                <comment line="387">
                    Some strikes may have no disposer as there&apos;s nothing
                     for them to free, as they allocated no native resource
                     eg, if they did not allocate resources because of a problem,
                     or they never hold native resources. So they create no disposer.
                     But any strike that reaches here that has a null disposer is
                     a potential memory leak.                    
                </comment>
                <scope line="393">
                    <scope line="394"/>
                    <scope line="396"/>
                </scope>
                <scope line="401"/>
                <scope line="403"/>
            </method>
            <interface name="DisposableStrike">
                <method name="getDisposer" type="FontStrikeDisposer" line="409"/>
            </interface>
            <class name="SoftDisposerRef" line="412">
                <extends class="SoftReference"/>
                <implements interface="DisposableStrike"/>
                <declaration name="disposer" type="FontStrikeDisposer" line="415"/>
                <method name="getDisposer" type="FontStrikeDisposer" line="417"/>
                <method name="SoftDisposerRef" type="constructor" line="421">
                    <params>
                        <param name="strike" type="FontStrike"/>
                    </params>
                </method>
            </class>
            <class name="WeakDisposerRef" line="428">
                <extends class="WeakReference"/>
                <implements interface="DisposableStrike"/>
                <declaration name="disposer" type="FontStrikeDisposer" line="431"/>
                <method name="getDisposer" type="FontStrikeDisposer" line="433"/>
                <method name="WeakDisposerRef" type="constructor" line="437">
                    <params>
                        <param name="strike" type="FontStrike"/>
                    </params>
                </method>
            </class>
        </class>
    </source>