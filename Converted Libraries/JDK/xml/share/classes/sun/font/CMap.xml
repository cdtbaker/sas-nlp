<?xml version="1.0" encoding="UTF-8"?>
    <source package="sun.font">
        <import package="java.nio.ByteBuffer"/>
        <import package="java.nio.CharBuffer"/>
        <import package="java.nio.IntBuffer"/>
        <import package="java.util.Locale"/>
        <import package="java.nio.charset"/>
        <class name="CMap" line="52">
            <comment line="55">
                static char WingDings_b2c[] = {                
            </comment>
            <comment line="56">
                0xfffd, 0xfffd, 0xfffd, 0xfffd, 0xfffd, 0xfffd, 0xfffd, 0xfffd,                
            </comment>
            <comment line="57">
                0xfffd, 0xfffd, 0xfffd, 0xfffd, 0xfffd, 0xfffd, 0xfffd, 0xfffd,                
            </comment>
            <comment line="58">
                0xfffd, 0xfffd, 0xfffd, 0xfffd, 0xfffd, 0xfffd, 0xfffd, 0xfffd,                
            </comment>
            <comment line="59">
                0xfffd, 0xfffd, 0xfffd, 0xfffd, 0xfffd, 0xfffd, 0xfffd, 0xfffd,                
            </comment>
            <comment line="60">
                0xfffd, 0xfffd, 0x2702, 0x2701, 0xfffd, 0xfffd, 0xfffd, 0xfffd,                
            </comment>
            <comment line="61">
                0xfffd, 0x2706, 0x2709, 0xfffd, 0xfffd, 0xfffd, 0xfffd, 0xfffd,                
            </comment>
            <comment line="62">
                0xfffd, 0xfffd, 0xfffd, 0xfffd, 0xfffd, 0xfffd, 0xfffd, 0xfffd,                
            </comment>
            <comment line="63">
                0xfffd, 0xfffd, 0xfffd, 0xfffd, 0xfffd, 0xfffd, 0x2707, 0x270d,                
            </comment>
            <comment line="64">
                0xfffd, 0x270c, 0xfffd, 0xfffd, 0xfffd, 0xfffd, 0xfffd, 0xfffd,                
            </comment>
            <comment line="65">
                0xfffd, 0xfffd, 0xfffd, 0xfffd, 0xfffd, 0xfffd, 0xfffd, 0xfffd,                
            </comment>
            <comment line="66">
                0xfffd, 0x2708, 0xfffd, 0xfffd, 0x2744, 0xfffd, 0x271e, 0xfffd,                
            </comment>
            <comment line="67">
                0x2720, 0x2721, 0xfffd, 0xfffd, 0xfffd, 0xfffd, 0xfffd, 0xfffd,                
            </comment>
            <comment line="68">
                0xfffd, 0xfffd, 0xfffd, 0xfffd, 0xfffd, 0xfffd, 0xfffd, 0xfffd,                
            </comment>
            <comment line="69">
                0xfffd, 0xfffd, 0xfffd, 0xfffd, 0xfffd, 0xfffd, 0xfffd, 0xfffd,                
            </comment>
            <comment line="70">
                0xfffd, 0x2751, 0x2752, 0xfffd, 0xfffd, 0x2756, 0xfffd, 0xfffd,                
            </comment>
            <comment line="71">
                0xfffd, 0xfffd, 0xfffd, 0x2740, 0x273f, 0x275d, 0x275e, 0xfffd,                
            </comment>
            <comment line="72">
                0xfffd, 0x2780, 0x2781, 0x2782, 0x2783, 0x2784, 0x2785, 0x2786,                
            </comment>
            <comment line="73">
                0x2787, 0x2788, 0x2789, 0xfffd, 0x278a, 0x278b, 0x278c, 0x278d,                
            </comment>
            <comment line="74">
                0x278e, 0x278f, 0x2790, 0x2791, 0x2792, 0x2793, 0xfffd, 0xfffd,                
            </comment>
            <comment line="75">
                0xfffd, 0xfffd, 0xfffd, 0xfffd, 0xfffd, 0xfffd, 0xfffd, 0xfffd,                
            </comment>
            <comment line="76">
                0xfffd, 0xfffd, 0xfffd, 0xfffd, 0xfffd, 0xfffd, 0x274d, 0xfffd,                
            </comment>
            <comment line="77">
                0xfffd, 0xfffd, 0xfffd, 0xfffd, 0x2736, 0x2734, 0xfffd, 0x2735,                
            </comment>
            <comment line="78">
                0xfffd, 0xfffd, 0xfffd, 0xfffd, 0xfffd, 0x272a, 0x2730, 0xfffd,                
            </comment>
            <comment line="79">
                0xfffd, 0xfffd, 0xfffd, 0xfffd, 0xfffd, 0xfffd, 0xfffd, 0xfffd,                
            </comment>
            <comment line="80">
                0xfffd, 0xfffd, 0xfffd, 0xfffd, 0x27a5, 0xfffd, 0x27a6, 0xfffd,                
            </comment>
            <comment line="81">
                0xfffd, 0xfffd, 0xfffd, 0xfffd, 0xfffd, 0xfffd, 0xfffd, 0xfffd,                
            </comment>
            <comment line="82">
                0xfffd, 0xfffd, 0xfffd, 0xfffd, 0xfffd, 0xfffd, 0xfffd, 0xfffd,                
            </comment>
            <comment line="83">
                0x27a2, 0xfffd, 0xfffd, 0xfffd, 0x27b3, 0xfffd, 0xfffd, 0xfffd,                
            </comment>
            <comment line="84">
                0xfffd, 0xfffd, 0xfffd, 0xfffd, 0xfffd, 0xfffd, 0xfffd, 0xfffd,                
            </comment>
            <comment line="85">
                0x27a1, 0xfffd, 0xfffd, 0xfffd, 0xfffd, 0xfffd, 0xfffd, 0xfffd,                
            </comment>
            <comment line="86">
                0x27a9, 0xfffd, 0xfffd, 0xfffd, 0xfffd, 0xfffd, 0xfffd, 0xfffd,                
            </comment>
            <comment line="87">
                0xfffd, 0xfffd, 0xfffd, 0x2717, 0x2713, 0xfffd, 0xfffd, 0xfffd,                
            </comment>
            <comment line="88">
                };                
            </comment>
            <comment line="90">
                static char Symbols_b2c[] = {                
            </comment>
            <comment line="91">
                0xfffd, 0xfffd, 0xfffd, 0xfffd, 0xfffd, 0xfffd, 0xfffd, 0xfffd,                
            </comment>
            <comment line="92">
                0xfffd, 0xfffd, 0xfffd, 0xfffd, 0xfffd, 0xfffd, 0xfffd, 0xfffd,                
            </comment>
            <comment line="93">
                0xfffd, 0xfffd, 0xfffd, 0xfffd, 0xfffd, 0xfffd, 0xfffd, 0xfffd,                
            </comment>
            <comment line="94">
                0xfffd, 0xfffd, 0xfffd, 0xfffd, 0xfffd, 0xfffd, 0xfffd, 0xfffd,                
            </comment>
            <comment line="95">
                0xfffd, 0xfffd, 0x2200, 0xfffd, 0x2203, 0xfffd, 0xfffd, 0x220d,                
            </comment>
            <comment line="96">
                0xfffd, 0xfffd, 0x2217, 0xfffd, 0xfffd, 0x2212, 0xfffd, 0xfffd,                
            </comment>
            <comment line="97">
                0xfffd, 0xfffd, 0xfffd, 0xfffd, 0xfffd, 0xfffd, 0xfffd, 0xfffd,                
            </comment>
            <comment line="98">
                0xfffd, 0xfffd, 0xfffd, 0xfffd, 0xfffd, 0xfffd, 0xfffd, 0xfffd,                
            </comment>
            <comment line="99">
                0x2245, 0x0391, 0x0392, 0x03a7, 0x0394, 0x0395, 0x03a6, 0x0393,                
            </comment>
            <comment line="100">
                0x0397, 0x0399, 0x03d1, 0x039a, 0x039b, 0x039c, 0x039d, 0x039f,                
            </comment>
            <comment line="101">
                0x03a0, 0x0398, 0x03a1, 0x03a3, 0x03a4, 0x03a5, 0x03c2, 0x03a9,                
            </comment>
            <comment line="102">
                0x039e, 0x03a8, 0x0396, 0xfffd, 0x2234, 0xfffd, 0x22a5, 0xfffd,                
            </comment>
            <comment line="103">
                0xfffd, 0x03b1, 0x03b2, 0x03c7, 0x03b4, 0x03b5, 0x03c6, 0x03b3,                
            </comment>
            <comment line="104">
                0x03b7, 0x03b9, 0x03d5, 0x03ba, 0x03bb, 0x03bc, 0x03bd, 0x03bf,                
            </comment>
            <comment line="105">
                0x03c0, 0x03b8, 0x03c1, 0x03c3, 0x03c4, 0x03c5, 0x03d6, 0x03c9,                
            </comment>
            <comment line="106">
                0x03be, 0x03c8, 0x03b6, 0xfffd, 0xfffd, 0xfffd, 0x223c, 0xfffd,                
            </comment>
            <comment line="107">
                0xfffd, 0xfffd, 0xfffd, 0xfffd, 0xfffd, 0xfffd, 0xfffd, 0xfffd,                
            </comment>
            <comment line="108">
                0xfffd, 0xfffd, 0xfffd, 0xfffd, 0xfffd, 0xfffd, 0xfffd, 0xfffd,                
            </comment>
            <comment line="109">
                0xfffd, 0xfffd, 0xfffd, 0xfffd, 0xfffd, 0xfffd, 0xfffd, 0xfffd,                
            </comment>
            <comment line="110">
                0xfffd, 0xfffd, 0xfffd, 0xfffd, 0xfffd, 0xfffd, 0xfffd, 0xfffd,                
            </comment>
            <comment line="111">
                0xfffd, 0x03d2, 0xfffd, 0x2264, 0x2215, 0x221e, 0xfffd, 0xfffd,                
            </comment>
            <comment line="112">
                0xfffd, 0xfffd, 0xfffd, 0xfffd, 0xfffd, 0xfffd, 0xfffd, 0xfffd,                
            </comment>
            <comment line="113">
                0x2218, 0xfffd, 0xfffd, 0x2265, 0xfffd, 0x221d, 0xfffd, 0x2219,                
            </comment>
            <comment line="114">
                0xfffd, 0x2260, 0x2261, 0x2248, 0x22ef, 0x2223, 0xfffd, 0xfffd,                
            </comment>
            <comment line="115">
                0xfffd, 0xfffd, 0xfffd, 0xfffd, 0x2297, 0x2295, 0x2205, 0x2229,                
            </comment>
            <comment line="116">
                0x222a, 0x2283, 0x2287, 0x2284, 0x2282, 0x2286, 0x2208, 0x2209,                
            </comment>
            <comment line="117">
                0xfffd, 0x2207, 0xfffd, 0xfffd, 0xfffd, 0xfffd, 0x221a, 0x22c5,                
            </comment>
            <comment line="118">
                0xfffd, 0x2227, 0x2228, 0xfffd, 0xfffd, 0xfffd, 0xfffd, 0xfffd,                
            </comment>
            <comment line="119">
                0x22c4, 0xfffd, 0xfffd, 0xfffd, 0xfffd, 0x2211, 0xfffd, 0xfffd,                
            </comment>
            <comment line="120">
                0xfffd, 0xfffd, 0xfffd, 0xfffd, 0xfffd, 0xfffd, 0xfffd, 0xfffd,                
            </comment>
            <comment line="121">
                0xfffd, 0xfffd, 0x222b, 0xfffd, 0xfffd, 0xfffd, 0xfffd, 0xfffd,                
            </comment>
            <comment line="122">
                0xfffd, 0xfffd, 0xfffd, 0xfffd, 0xfffd, 0xfffd, 0xfffd, 0xfffd,                
            </comment>
            <comment line="123">
                };                
            </comment>
            <comment line="138">
                Unicode-&gt;other encoding translation array. A pre-computed look up
                 which can be shared across all fonts using that encoding.
                 Using this saves running character coverters repeatedly.                
            </comment>
            <comment line="269">
                speed up the converting by setting the range for double
                 byte characters;                
            </comment>
            <comment line="386">
                The returned array maps to unicode from some other 2 byte encoding
                 eg for a 2byte index which represents a SJIS char, the indexed
                 value is the corresponding unicode char.                
            </comment>
            <comment line="428">
                final char charVal(byte[] cmap, int index) {
                return (char)(((0xff &amp; cmap[index]) &lt;&lt; 8)+(0xff &amp; cmap[index+1]));
                }
                
                final short shortVal(byte[] cmap, int index) {
                return (short)(((0xff &amp; cmap[index]) &lt;&lt; 8)+(0xff &amp; cmap[index+1]));
                }                
            </comment>
            <comment line="439">
                Format 4 Header is
                 ushort format (off=0)
                 ushort length (off=2)
                 ushort language (off=4)
                 ushort segCountX2 (off=6)
                 ushort searchRange (off=8)
                 ushort entrySelector (off=10)
                 ushort rangeShift (off=12)
                 ushort endCount[segCount] (off=14)
                 ushort reservedPad
                 ushort startCount[segCount]
                 short idDelta[segCount]
                 idRangeOFfset[segCount]
                 ushort glyphIdArray[]                
            </comment>
            <comment line="617">
                Format 0: Byte Encoding table                
            </comment>
            <comment line="646">
                static CMap createSymbolCMap(ByteBuffer buffer, int offset, char[] syms) {                
            </comment>
            <comment line="648">
                CMap cmap = createCMap(buffer, offset, null);                
            </comment>
            <comment line="649">
                if (cmap == null) {                
            </comment>
            <comment line="650">
                return null;                
            </comment>
            <comment line="651">
                } else {                
            </comment>
            <comment line="652">
                return new CMapFormatSymbol(cmap, syms);                
            </comment>
            <comment line="653">
                }                
            </comment>
            <comment line="654">
                }                
            </comment>
            <comment line="656">
                static class CMapFormatSymbol extends CMap {                
            </comment>
            <comment line="658">
                CMap cmap;                
            </comment>
            <comment line="659">
                static final int NUM_BUCKETS = 128;                
            </comment>
            <comment line="660">
                Bucket[] buckets = new Bucket[NUM_BUCKETS];                
            </comment>
            <comment line="662">
                class Bucket {                
            </comment>
            <comment line="663">
                char unicode;                
            </comment>
            <comment line="664">
                char glyph;                
            </comment>
            <comment line="665">
                Bucket next;                
            </comment>
            <comment line="667">
                Bucket(char u, char g) {                
            </comment>
            <comment line="668">
                unicode = u;                
            </comment>
            <comment line="669">
                glyph = g;                
            </comment>
            <comment line="670">
                }                
            </comment>
            <comment line="671">
                }                
            </comment>
            <comment line="673">
                CMapFormatSymbol(CMap cmap, char[] syms) {                
            </comment>
            <comment line="675">
                this.cmap = cmap;                
            </comment>
            <comment line="677">
                for (int i=0;i&lt;syms.length;i++) {                
            </comment>
            <comment line="678">
                char unicode = syms[i];                
            </comment>
            <comment line="679">
                if (unicode != noSuchChar) {                
            </comment>
            <comment line="680">
                char glyph = cmap.getGlyph(i + 0xf000);                
            </comment>
            <comment line="681">
                int hash = unicode % NUM_BUCKETS;                
            </comment>
            <comment line="682">
                Bucket bucket = new Bucket(unicode, glyph);                
            </comment>
            <comment line="683">
                if (buckets[hash] == null) {                
            </comment>
            <comment line="684">
                buckets[hash] = bucket;                
            </comment>
            <comment line="685">
                } else {                
            </comment>
            <comment line="686">
                Bucket b = buckets[hash];                
            </comment>
            <comment line="687">
                while (b.next != null) {                
            </comment>
            <comment line="688">
                b = b.next;                
            </comment>
            <comment line="689">
                }                
            </comment>
            <comment line="690">
                b.next = bucket;                
            </comment>
            <comment line="691">
                }                
            </comment>
            <comment line="692">
                }                
            </comment>
            <comment line="693">
                }                
            </comment>
            <comment line="694">
                }                
            </comment>
            <comment line="696">
                char getGlyph(int unicode) {                
            </comment>
            <comment line="697">
                if (unicode &gt;= 0x1000) {                
            </comment>
            <comment line="698">
                return 0;                
            </comment>
            <comment line="699">
                }                
            </comment>
            <comment line="700">
                else if (unicode &gt;=0xf000 &amp;&amp; unicode &lt; 0xf100) {                
            </comment>
            <comment line="701">
                return cmap.getGlyph(unicode);                
            </comment>
            <comment line="702">
                } else {                
            </comment>
            <comment line="703">
                Bucket b = buckets[unicode % NUM_BUCKETS];                
            </comment>
            <comment line="704">
                while (b != null) {                
            </comment>
            <comment line="705">
                if (b.unicode == unicode) {                
            </comment>
            <comment line="706">
                return b.glyph;                
            </comment>
            <comment line="707">
                } else {                
            </comment>
            <comment line="708">
                b = b.next;                
            </comment>
            <comment line="709">
                }                
            </comment>
            <comment line="710">
                }                
            </comment>
            <comment line="711">
                return 0;                
            </comment>
            <comment line="712">
                }                
            </comment>
            <comment line="713">
                }                
            </comment>
            <comment line="714">
                }                
            </comment>
            <comment line="716">
                Format 2: High-byte mapping through table                
            </comment>
            <comment line="836">
                Format 6: Trimmed table mapping                
            </comment>
            <comment line="875">
                Format 8: mixed 16-bit and 32-bit coverage                
            </comment>
            <comment line="876">
                Seems unlikely this code will ever get tested as we look for                
            </comment>
            <comment line="877">
                MS platform Cmaps and MS states (in the Opentype spec on their website)                
            </comment>
            <comment line="878">
                that MS doesn&apos;t support this format                
            </comment>
            <comment line="907">
                Format 4-byte 10: Trimmed table mapping                
            </comment>
            <comment line="908">
                Seems unlikely this code will ever get tested as we look for                
            </comment>
            <comment line="909">
                MS platform Cmaps and MS states (in the Opentype spec on their website)                
            </comment>
            <comment line="910">
                that MS doesn&apos;t support this format                
            </comment>
            <comment line="945">
                Format 12: Segmented coverage for UCS-4 (fonts supporting                
            </comment>
            <comment line="946">
                surrogate pairs)                
            </comment>
            <comment line="1038">
                                
            </comment>
            <declaration name="ShiftJISEncoding" type="short" line="124"/>
            <declaration name="GBKEncoding" type="short" line="125"/>
            <declaration name="Big5Encoding" type="short" line="126"/>
            <declaration name="WansungEncoding" type="short" line="127"/>
            <declaration name="JohabEncoding" type="short" line="128"/>
            <declaration name="MSUnicodeSurrogateEncoding" type="short" line="129"/>
            <declaration name="noSuchChar" type="char" line="131"/>
            <declaration name="SHORTMASK" type="int" line="132"/>
            <declaration name="INTMASK" type="int" line="133"/>
            <declaration name="converterMaps" type="char[][]" line="135"/>
            <declaration name="xlat" type="char[]" line="142"/>
            <method name="initialize" type="CMap" line="144">
                <params>
                    <param name="font" type="TrueTypeFont"/>
                </params>
                <comment line="158">
                                        
                </comment>
                <comment line="167">
                    MS Symbol encoding                    
                </comment>
                <comment line="168">
                    MS Unicode cmap                    
                </comment>
                <comment line="169">
                    ShiftJIS cmap.                    
                </comment>
                <comment line="170">
                    GBK cmap                    
                </comment>
                <comment line="171">
                    Big 5 cmap                    
                </comment>
                <comment line="172">
                    Wansung                    
                </comment>
                <comment line="173">
                    Johab                    
                </comment>
                <comment line="174">
                    MS Unicode surrogates                    
                </comment>
                <comment line="179">
                                        
                </comment>
                <comment line="185">
                    The special case treatment of these fonts leads to
                     anomalies where a user can view &quot;wingdings&quot; and &quot;wingdings2&quot;
                     and the latter shows all its code points in the unicode
                     private use area at 0xF000-&gt;0XF0FF and the former shows
                     a scattered subset of its glyphs that are known mappings to
                     unicode code points.
                     The primary purpose of these mappings was to facilitate
                     display of symbol chars etc in composite fonts, however
                     this is not needed as all these code points are covered
                     by Lucida Sans Regular.
                     Commenting this out reduces the role of these two files
                     (assuming that they continue to be used in font.properties)
                     to just one of contributing to the overall composite
                     font metrics, and also AWT can still access the fonts.
                     Clients which explicitly accessed these fonts as names
                     &quot;Symbol&quot; and &quot;Wingdings&quot; (ie as physical fonts) and
                     expected to see a scattering of these characters will
                     see them now as missing. How much of a problem is this?
                     Perhaps we could still support this mapping just for
                     &quot;Symbol.ttf&quot; but I suspect some users would prefer it
                     to be mapped in to the Latin range as that is how
                     the &quot;symbol&quot; font is used in native apps.                    
                </comment>
                <comment line="208">
                    String name = font.platName.toLowerCase(Locale.ENGLISH);                    
                </comment>
                <comment line="209">
                    if (name.endsWith(&quot;symbol.ttf&quot;)) {                    
                </comment>
                <comment line="210">
                    cmap = createSymbolCMap(cmapBuffer, three0, Symbols_b2c);                    
                </comment>
                <comment line="211">
                    } else if (name.endsWith(&quot;wingding.ttf&quot;)) {                    
                </comment>
                <comment line="212">
                    cmap = createSymbolCMap(cmapBuffer, three0, WingDings_b2c);                    
                </comment>
                <comment line="213">
                    } else {                    
                </comment>
                <comment line="215">
                    }                    
                </comment>
                <comment line="229">
                    GB2312 TrueType fonts on Solaris have wrong encoding ID for
                     cmap table, these fonts have EncodingID 4 which is Big5
                     encoding according the TrueType spec, but actually the
                     fonts are using gb2312 encoding, have to use this
                     workaround to make Solaris zh_CN locale work.  -sherman                    
                </comment>
                <comment line="259">
                    No 3, subtable was found. Just use whatever is the first
                     table listed. Not very useful but maybe better than
                     rejecting the font entirely?                    
                </comment>
                <declaration name="cmap" type="CMap" line="146"/>
                <declaration name="offset" type="int" line="148"/>
                <declaration name="three0" type="int" line="150"/>
                <declaration name="threeStar" type="boolean" line="152"/>
                <declaration name="cmapBuffer" type="ByteBuffer" line="154"/>
                <declaration name="cmapTableOffset" type="int" line="155"/>
                <declaration name="numberSubTables" type="short" line="156"/>
                <scope line="159">
                    <scope line="162"/>
                </scope>
                <scope line="180">
                    <scope line="181"/>
                    <scope line="184"/>
                    <scope line="217"/>
                    <scope line="220"/>
                    <scope line="224"/>
                    <scope line="228">
                        <scope line="241"/>
                        <scope line="245"/>
                    </scope>
                    <scope line="250"/>
                    <scope line="254"/>
                </scope>
                <scope line="258"/>
            </method>
            <method name="getConverter" type="char[]" line="271">
                <params>
                    <param name="encodingID" type="short"/>
                </params>
                <comment line="321">
                    sjis halfwidth katakana                    
                </comment>
                <comment line="344">
                    ensure single byte ascii                    
                </comment>
                <comment line="349">
                    sjis halfwidth katakana                    
                </comment>
                <comment line="356">
                    It would save heap space (approx 60Kbytes for each of these
                     converters) if stored only valid ranges (ie returned
                     outputChars directly. But this is tricky since want to
                     include the ASCII range too.                    
                </comment>
                <comment line="361">
                    System.err.println(&quot;oc.len=&quot;+outputChars.length);                    
                </comment>
                <comment line="362">
                    System.err.println(&quot;cc.len=&quot;+convertedChars.length);                    
                </comment>
                <comment line="363">
                    System.err.println(&quot;dbegin=&quot;+dBegin);                    
                </comment>
                <comment line="367">
                    return convertedChars;                    
                </comment>
                <comment line="368">
                    invert this map as now want it to map from Unicode
                     to other encoding.                    
                </comment>
                <declaration name="dBegin" type="int" line="272"/>
                <declaration name="dEnd" type="int" line="273"/>
                <declaration name="encoding" type="String" line="274"/>
                <scope line="306">
                    <declaration name="convertedChars" type="char[]" line="307"/>
                    <scope line="308"/>
                    <declaration name="inputBytes" type="byte[]" line="312"/>
                    <declaration name="outputChars" type="char[]" line="313"/>
                    <declaration name="j" type="int" line="315"/>
                    <declaration name="firstByte" type="int" line="316"/>
                    <scope line="317">
                        <scope line="318">
                            <scope line="320"/>
                            <scope line="324"/>
                        </scope>
                    </scope>
                    <scope line="329">
                        <scope line="330"/>
                    </scope>
                    <scope line="345"/>
                    <scope line="350">
                        <scope line="351"/>
                    </scope>
                    <declaration name="invertedChars" type="char[]" line="371"/>
                    <scope line="372">
                        <scope line="373"/>
                    </scope>
                </scope>
                <scope line="379"/>
            </method>
            <method name="getConverterMap" type="char[]" line="390">
                <params>
                    <param name="encodingID" type="short"/>
                </params>
                <scope line="391"/>
            </method>
            <method name="createCMap" type="CMap" line="398">
                <params>
                    <param name="buffer" type="ByteBuffer"/>
                    <param name="offset" type="int"/>
                    <param name="xlat" type="char[]"/>
                </params>
                <comment line="399">
                    First do a sanity check that this cmap subtable is contained
                     within the cmap table.                    
                </comment>
                <declaration name="subtableFormat" type="int" line="402"/>
                <declaration name="subtableLength" type="long" line="403"/>
                <scope line="404"/>
                <scope line="406"/>
                <scope line="409">
                    <scope line="410"/>
                </scope>
            </method>
            <method name="getGlyph" type="char" line="436"/>
            <class name="CMapFormat4" line="453">
                <extends class="CMap"/>
                <comment line="720">
                    Store subheaders in individual arrays
                     A SubHeader entry theortically looks like {
                       char firstCode;
                       char entryCount;
                       short idDelta;
                       char idRangeOffset;
                     }                    
                </comment>
                <declaration name="segCount" type="int" line="454"/>
                <declaration name="entrySelector" type="int" line="455"/>
                <declaration name="rangeShift" type="int" line="456"/>
                <declaration name="endCount" type="char[]" line="457"/>
                <declaration name="startCount" type="char[]" line="458"/>
                <declaration name="idDelta" type="short[]" line="459"/>
                <declaration name="idRangeOffset" type="char[]" line="460"/>
                <declaration name="glyphIds" type="char[]" line="461"/>
                <method name="CMapFormat4" type="constructor" line="463">
                    <params>
                        <param name="bbuffer" type="ByteBuffer"/>
                        <param name="offset" type="int"/>
                        <param name="xlat" type="char[]"/>
                    </params>
                    <comment line="469">
                        skip, we already know format=4                        
                    </comment>
                    <comment line="471">
                        Try to recover from some bad fonts which specify a subtable
                         length that would overflow the byte buffer holding the whole
                         cmap table. If this isn&apos;t a recoverable situation an exception
                         may be thrown which is caught higher up the call stack.
                         Whilst this may seem lenient, in practice, unless the &quot;bad&quot;
                         subtable we are using is the last one in the cmap table we
                         would have no way of knowing about this problem anyway.                        
                    </comment>
                    <comment line="482">
                        skip language                        
                    </comment>
                    <comment line="495">
                        2 bytes for reserved pad                        
                    </comment>
                    <comment line="508">
                        Can calculate the number of glyph IDs by subtracting
                         &quot;pos&quot; from the length of the cmap                        
                    </comment>
                    <comment line="518">
                        System.err.println(&quot;segcount=&quot;+segCount);
                        System.err.println(&quot;entrySelector=&quot;+entrySelector);
                        System.err.println(&quot;rangeShift=&quot;+rangeShift);
                        for (int j=0;j&lt;segCount;j++) {
                        System.err.println(&quot;j=&quot;+j+ &quot; sc=&quot;+(int)(startCount[j]&amp;0xffff)+
                        &quot; ec=&quot;+(int)(endCount[j]&amp;0xffff)+
                        &quot; delta=&quot;+idDelta[j] +
                        &quot; ro=&quot;+(int)idRangeOffset[j]);
                        }
                        
                        System.err.println(&quot;numglyphs=&quot;+glyphIds.length);
                        for (int i=0;i&lt;numGlyphIds;i++) {
                        System.err.println(&quot;gid[&quot;+i+&quot;]=&quot;+(int)glyphIds[i]);
                        }                        
                    </comment>
                    <declaration name="buffer" type="CharBuffer" line="468"/>
                    <declaration name="subtableLength" type="int" line="470"/>
                    <scope line="479"/>
                    <declaration name="searchRange" type="int" line="484"/>
                    <scope line="492"/>
                    <scope line="496"/>
                    <scope line="500"/>
                    <scope line="504">
                        <declaration name="ctmp" type="char" line="505"/>
                    </scope>
                    <declaration name="pos" type="int" line="511"/>
                    <declaration name="numGlyphIds" type="int" line="513"/>
                    <scope line="515"/>
                </method>
                <method name="getGlyph" type="char" line="536">
                    <params>
                        <param name="charCode" type="int"/>
                    </params>
                    <comment line="546">
                        presence of translation array indicates that this
                         cmap is in some other (non-unicode encoding).
                         In order to look-up a char-&gt;glyph mapping we need to
                         translate the unicode code point to the encoding of
                         the cmap.
                         REMIND: VALID CHARCODES??                        
                    </comment>
                    <comment line="557">
                        Citation from the TrueType (and OpenType) spec:
                           The segments are sorted in order of increasing endCode
                           values, and the segment values are specified in four parallel
                           arrays. You search for the first endCode that is greater than
                           or equal to the character code you want to map. If the
                           corresponding startCode is less than or equal to the
                           character code, then you use the corresponding idDelta and
                           idRangeOffset to map the character code to a glyph index
                           (otherwise, the missingGlyph is returned).                        
                    </comment>
                    <comment line="569">
                        CMAP format4 defines several fields for optimized search of
                         the segment list (entrySelector, searchRange, rangeShift).
                         However, benefits are neglible and some fonts have incorrect
                         data - so we use straightforward binary search (see bug 6247425)                        
                    </comment>
                    <comment line="592">
                                                
                    </comment>
                    <comment line="594">
                        System.err.println(&quot;rangeoffset=&quot;+rangeOffset+
                        &quot; charCode=&quot; + charCode +
                        &quot; scnt[&quot;+index+&quot;]=&quot;+(int)startCount[index] +
                        &quot; segCnt=&quot;+segCount);                        
                    </comment>
                    <comment line="610">
                        System.err.println(&quot;cc=&quot;+Integer.toHexString((int)charCode) + &quot; gc=&quot;+(int)glyphCode);                        
                    </comment>
                    <declaration name="index" type="int" line="538"/>
                    <declaration name="glyphCode" type="char" line="539"/>
                    <declaration name="controlGlyph" type="int" line="541"/>
                    <scope line="542"/>
                    <scope line="553"/>
                    <declaration name="left" type="int" line="575"/>
                    <scope line="577">
                        <scope line="578"/>
                        <scope line="580"/>
                    </scope>
                    <scope line="586">
                        <declaration name="rangeOffset" type="int" line="587"/>
                        <scope line="589"/>
                        <scope line="591">
                            <declaration name="glyphIDIndex" type="int" line="601"/>
                            <scope line="604"/>
                        </scope>
                    </scope>
                    <scope line="609"/>
                </method>
            </class>
            <class name="CMapFormat0" line="617">
                <extends class="CMap"/>
                <comment line="720">
                    Store subheaders in individual arrays
                     A SubHeader entry theortically looks like {
                       char firstCode;
                       char entryCount;
                       short idDelta;
                       char idRangeOffset;
                     }                    
                </comment>
                <declaration name="cmap" type="byte[]" line="618"/>
                <method name="CMapFormat0" type="constructor" line="620">
                    <params>
                        <param name="buffer" type="ByteBuffer"/>
                        <param name="offset" type="int"/>
                    </params>
                    <comment line="622">
                                                
                    </comment>
                    <declaration name="len" type="int" line="623"/>
                </method>
                <method name="getGlyph" type="char" line="629">
                    <params>
                        <param name="charCode" type="int"/>
                    </params>
                    <scope line="630">
                        <scope line="631"/>
                    </scope>
                    <scope line="639"/>
                </method>
            </class>
            <class name="CMapFormat2" line="716">
                <extends class="CMap"/>
                <comment line="720">
                    Store subheaders in individual arrays
                     A SubHeader entry theortically looks like {
                       char firstCode;
                       char entryCount;
                       short idDelta;
                       char idRangeOffset;
                     }                    
                </comment>
                <declaration name="subHeaderKey" type="char[]" line="718"/>
                <declaration name="firstCodeArray" type="char[]" line="727"/>
                <declaration name="entryCountArray" type="char[]" line="728"/>
                <declaration name="idDeltaArray" type="short[]" line="729"/>
                <declaration name="idRangeOffSetArray" type="char[]" line="730"/>
                <declaration name="glyphIndexArray" type="char[]" line="732"/>
                <method name="CMapFormat2" type="constructor" line="734">
                    <params>
                        <param name="buffer" type="ByteBuffer"/>
                        <param name="offset" type="int"/>
                        <param name="xlat" type="char[]"/>
                    </params>
                    <comment line="748">
                        The value of the subHeaderKey is 8  the subHeader index,
                         so the number of subHeaders can be obtained by dividing
                         this value bv 8 and adding 1.                        
                    </comment>
                    <comment line="762">
                        System.out.println(&quot;sh[&quot;+i+&quot;]:fc=&quot;+(int)firstCodeArray[i]+                        
                    </comment>
                    <comment line="763">
                        &quot; ec=&quot;+(int)entryCountArray[i]+                        
                    </comment>
                    <comment line="764">
                        &quot; delta=&quot;+(int)idDeltaArray[i]+                        
                    </comment>
                    <comment line="765">
                        &quot; offset=&quot;+(int)idRangeOffSetArray[i]);                        
                    </comment>
                    <declaration name="tableLen" type="int" line="738"/>
                    <declaration name="cBuffer" type="CharBuffer" line="740"/>
                    <declaration name="maxSubHeader" type="char" line="741"/>
                    <scope line="742">
                        <scope line="744"/>
                    </scope>
                    <declaration name="numSubHeaders" type="int" line="752"/>
                    <scope line="757"/>
                    <declaration name="glyphIndexArrSize" type="int" line="768"/>
                    <scope line="770"/>
                </method>
                <method name="getGlyph" type="char" line="775">
                    <params>
                        <param name="charCode" type="int"/>
                    </params>
                    <comment line="787">
                        index into subHeaders                        
                    </comment>
                    <comment line="799">
                        System.err.println(&quot;charCode=&quot;+Integer.toHexString(charCode)+                        
                    </comment>
                    <comment line="800">
                        &quot; key=&quot;+key+ &quot; mapMe=&quot;+Integer.toHexString(mapMe));                        
                    </comment>
                    <comment line="809">
                        &quot;address&quot; arithmetic is needed to calculate the offset
                         into glyphIndexArray. &quot;idRangeOffSetArray[key]&quot; specifies
                         the number of bytes from that location in the table where
                         the subarray of glyphIndexes starting at &quot;firstCode&quot; begins.
                         Each entry in the subHeader table is 8 bytes, and the
                         idRangeOffSetArray field is at offset 6 in the entry.
                         The glyphIndexArray immediately follows the subHeaders.
                         So if there are &quot;N&quot; entries then the number of bytes to the
                         start of glyphIndexArray is (N-key)8-6.
                         Subtract this from the idRangeOffSetArray value to get
                         the number of bytes into glyphIndexArray and divide by 2 to
                         get the (char) array index.                        
                    </comment>
                    <comment line="827">
                        idDelta                        
                    </comment>
                    <declaration name="controlGlyph" type="int" line="776"/>
                    <scope line="777"/>
                    <scope line="781"/>
                    <declaration name="highByte" type="char" line="785"/>
                    <declaration name="lowByte" type="char" line="786"/>
                    <declaration name="key" type="int" line="787"/>
                    <declaration name="mapMe" type="char" line="788"/>
                    <scope line="790"/>
                    <scope line="792">
                        <scope line="794"/>
                    </scope>
                    <declaration name="firstCode" type="char" line="801"/>
                    <scope line="802"/>
                    <scope line="804"/>
                    <scope line="808">
                        <declaration name="glyphArrayOffset" type="int" line="822"/>
                        <declaration name="glyphSubArrayStart" type="int" line="823"/>
                        <declaration name="glyphCode" type="char" line="825"/>
                        <scope line="826"/>
                    </scope>
                </method>
            </class>
            <class name="CMapFormat6" line="836">
                <extends class="CMap"/>
                <comment line="720">
                    Store subheaders in individual arrays
                     A SubHeader entry theortically looks like {
                       char firstCode;
                       char entryCount;
                       short idDelta;
                       char idRangeOffset;
                     }                    
                </comment>
                <declaration name="firstCode" type="char" line="838"/>
                <declaration name="entryCount" type="char" line="839"/>
                <declaration name="glyphIdArray" type="char[]" line="840"/>
                <method name="CMapFormat6" type="constructor" line="842">
                    <params>
                        <param name="bbuffer" type="ByteBuffer"/>
                        <param name="offset" type="int"/>
                        <param name="xlat" type="char[]"/>
                    </params>
                    <declaration name="buffer" type="CharBuffer" line="846"/>
                    <scope line="850"/>
                </method>
                <method name="getGlyph" type="char" line="855">
                    <params>
                        <param name="charCode" type="int"/>
                    </params>
                    <declaration name="controlGlyph" type="int" line="856"/>
                    <scope line="857"/>
                    <scope line="861"/>
                    <scope line="866"/>
                    <scope line="868"/>
                </method>
            </class>
            <class name="CMapFormat8" line="878">
                <extends class="CMap"/>
                <comment line="720">
                    Store subheaders in individual arrays
                     A SubHeader entry theortically looks like {
                       char firstCode;
                       char entryCount;
                       short idDelta;
                       char idRangeOffset;
                     }                    
                </comment>
                <declaration name="is32" type="byte[]" line="879"/>
                <declaration name="nGroups" type="int" line="880"/>
                <declaration name="startCharCode" type="int[]" line="881"/>
                <declaration name="endCharCode" type="int[]" line="882"/>
                <declaration name="startGlyphID" type="int[]" line="883"/>
                <method name="CMapFormat8" type="constructor" line="885">
                    <params>
                        <param name="bbuffer" type="ByteBuffer"/>
                        <param name="offset" type="int"/>
                        <param name="xlat" type="char[]"/>
                    </params>
                </method>
                <method name="getGlyph" type="char" line="896">
                    <params>
                        <param name="charCode" type="int"/>
                    </params>
                    <scope line="897"/>
                </method>
            </class>
            <class name="CMapFormat10" line="910">
                <extends class="CMap"/>
                <comment line="720">
                    Store subheaders in individual arrays
                     A SubHeader entry theortically looks like {
                       char firstCode;
                       char entryCount;
                       short idDelta;
                       char idRangeOffset;
                     }                    
                </comment>
                <declaration name="firstCode" type="long" line="912"/>
                <declaration name="entryCount" type="int" line="913"/>
                <declaration name="glyphIdArray" type="char[]" line="914"/>
                <method name="CMapFormat10" type="constructor" line="916">
                    <params>
                        <param name="bbuffer" type="ByteBuffer"/>
                        <param name="offset" type="int"/>
                        <param name="xlat" type="char[]"/>
                    </params>
                    <declaration name="buffer" type="CharBuffer" line="922"/>
                    <scope line="924"/>
                </method>
                <method name="getGlyph" type="char" line="929">
                    <params>
                        <param name="charCode" type="int"/>
                    </params>
                    <scope line="931"/>
                    <declaration name="code" type="int" line="935"/>
                    <scope line="936"/>
                    <scope line="938"/>
                </method>
            </class>
            <class name="CMapFormat12" line="946">
                <extends class="CMap"/>
                <comment line="720">
                    Store subheaders in individual arrays
                     A SubHeader entry theortically looks like {
                       char firstCode;
                       char entryCount;
                       short idDelta;
                       char idRangeOffset;
                     }                    
                </comment>
                <declaration name="numGroups" type="int" line="948"/>
                <declaration name="highBit" type="int" line="949"/>
                <declaration name="power" type="int" line="950"/>
                <declaration name="extra" type="int" line="951"/>
                <declaration name="startCharCode" type="long[]" line="952"/>
                <declaration name="endCharCode" type="long[]" line="953"/>
                <declaration name="startGlyphID" type="int[]" line="954"/>
                <method name="CMapFormat12" type="constructor" line="956">
                    <params>
                        <param name="buffer" type="ByteBuffer"/>
                        <param name="offset" type="int"/>
                        <param name="xlat" type="char[]"/>
                    </params>
                    <comment line="974">
                                                
                    </comment>
                    <scope line="957"/>
                    <declaration name="ibuffer" type="IntBuffer" line="967"/>
                    <scope line="968"/>
                    <declaration name="value" type="int" line="975"/>
                    <scope line="977"/>
                    <scope line="982"/>
                    <scope line="987"/>
                    <scope line="992"/>
                    <scope line="997"/>
                </method>
                <method name="getGlyph" type="char" line="1006">
                    <params>
                        <param name="charCode" type="int"/>
                    </params>
                    <declaration name="controlGlyph" type="int" line="1007"/>
                    <scope line="1008"/>
                    <declaration name="probe" type="int" line="1011"/>
                    <declaration name="range" type="int" line="1012"/>
                    <scope line="1014"/>
                    <scope line="1018">
                        <scope line="1021"/>
                    </scope>
                    <scope line="1027"/>
                </method>
            </class>
            <class name="NullCMapClass" line="1038">
                <extends class="CMap"/>
                <comment line="720">
                    Store subheaders in individual arrays
                     A SubHeader entry theortically looks like {
                       char firstCode;
                       char entryCount;
                       short idDelta;
                       char idRangeOffset;
                     }                    
                </comment>
                <method name="getGlyph" type="char" line="1040">
                    <params>
                        <param name="charCode" type="int"/>
                    </params>
                </method>
            </class>
            <declaration name="theNullCmap" type="NullCMapClass" line="1045"/>
            <method name="getControlCodeGlyph" type="int" line="1047">
                <params>
                    <param name="charCode" type="int"/>
                    <param name="noSurrogates" type="boolean"/>
                </params>
                <scope line="1048"/>
                <scope line="1054">
                    <scope line="1057"/>
                    <scope line="1059"/>
                </scope>
            </method>
        </class>
    </source>