<?xml version="1.0" encoding="UTF-8"?>
    <source package="sun.font">
        <import package="java.awt.Font"/>
        <import package="java.awt.FontFormatException"/>
        <import package="java.io.BufferedReader"/>
        <import package="java.io.File"/>
        <import package="java.io.FileInputStream"/>
        <import package="java.io.FilenameFilter"/>
        <import package="java.io.IOException"/>
        <import package="java.io.InputStreamReader"/>
        <import package="java.security.AccessController"/>
        <import package="java.security.PrivilegedAction"/>
        <import package="java.util.ArrayList"/>
        <import package="java.util.HashMap"/>
        <import package="java.util.HashSet"/>
        <import package="java.util.Hashtable"/>
        <import package="java.util.Iterator"/>
        <import package="java.util.Locale"/>
        <import package="java.util.Map"/>
        <import package="java.util.NoSuchElementException"/>
        <import package="java.util.StringTokenizer"/>
        <import package="java.util.TreeMap"/>
        <import package="java.util.Vector"/>
        <import package="java.util.concurrent.ConcurrentHashMap"/>
        <import package="javax.swing.plaf.FontUIResource"/>
        <import package="sun.awt.AppContext"/>
        <import package="sun.awt.FontConfiguration"/>
        <import package="sun.awt.SunToolkit"/>
        <import package="sun.java2d.FontSupport"/>
        <import package="sun.util.logging.PlatformLogger"/>
        <class name="SunFontManager" line="58">
            <comment line="139">
                Pool of 20 font file channels chosen because some UTF-8 locale
                 composite fonts can use up to 16 platform fonts (including the
                 Lucida fall back). This should prevent channel thrashing when
                 dealing with one of these fonts.
                 The pool array stores the fonts, rather than directly referencing
                 the channels, as the font needs to do the openclose work.                
            </comment>
            <comment line="150">
                Need to implement a simple linked list scheme for fast
                 traversal and lookup.
                 Also want to &quot;fast path&quot; dialog so there&apos;s minimal overhead.                
            </comment>
            <comment line="154">
                There are at exactly 20 composite fonts: 5 faces (but some are not
                 usually different), in 4 styles. The array may be auto-expanded
                 later if more are needed, eg for user-defined composites or locale
                 variants.                
            </comment>
            <comment line="168">
                given a full name find the Font. Remind: there&apos;s duplication
                 here in that this contains the content of compositeFonts +
                 physicalFonts.                
            </comment>
            <comment line="175">
                TrueType fonts have localised names. Support searching all
                 of these before giving up on a name.                
            </comment>
            <comment line="189">
                initial assumption.                
            </comment>
            <comment line="200">
                fontPath is the location of all fonts on the system, excluding the
                 JRE&apos;s own font directory but including any path specified using the
                 sun.java2d.fontpath property. Together with that property,  it is
                 initialised by the getPlatformFontPath() method
                 This call must be followed by a call to registerFontDirs(fontPath)
                 once any extra debugging path has been appended.                
            </comment>
            <comment line="209">
                discoveredAllFonts is set to true when all fonts on the font path are
                 discovered. This usually also implies opening, validating and
                 registering, but an implementation may be optimized to avold this.
                 So see also &quot;loadedAllFontFiles&quot;                
            </comment>
            <comment line="216">
                No need to keep consing up new instances - reuse a singleton.
                 The trade-off is that these objects don&apos;t get GC&apos;d.                
            </comment>
            <comment line="223">
                cache for default locale only                
            </comment>
            <comment line="228">
                                
            </comment>
            <comment line="365">
                                
            </comment>
            <comment line="648">
                This variant is used only when the application specifies
                 a variant of composite fonts which prefers locale specific or
                 proportional fonts.                
            </comment>
            <comment line="708">
                Systems may have fonts with the same name.
                 We want to register only one of such fonts (at least until
                 such time as there might be APIs which can accommodate &gt; 1).
                 Rank is 1) font configuration fonts, 2) JRE fonts, 3) OTTT fonts,
                 4) Type1 fonts, 5) native fonts.
                
                 If the new font has the same name as the old font, the higher
                 ranked font gets added, replacing the lower ranked one.
                 If the fonts are of equal rank, then make a special case of
                 font configuration rank fonts, which are on closer inspection,
                 OTTT fonts such that the larger font is registered. This is
                 a heuristic since a font may be &quot;larger&quot; in the sense of more
                 code points, or be a larger &quot;file&quot; because it has more bitmaps.
                 So it is possible that using filesize may lead to less glyphs, and
                 using glyphs may lead to lower quality display. Probably number
                 of glyphs is the ideal, but filesize is information we already
                 have and is good enough for the known cases.
                 Also don&apos;t want to register fonts that match JRE font families
                 but are coming from a source other than the JRE.
                 This will ensure that we will algorithmically style the JRE
                 plain font and get the same set of glyphs for all styles.
                
                 Note that this method returns a value
                 if it returns the same object as its argument that means this
                 font was newly registered.
                 If it returns a different object it means this font already exists,
                 and you should use that one.
                 If it returns null means this font was not registered and none
                 in that name is registered. The caller must find a substitute                
            </comment>
            <comment line="876">
                The class FontRegistrationInfo is used when a client says not
                 to register a font immediately. This mechanism is used to defer
                 initialisation of all the components of composite fonts at JRE
                 start-up. The CompositeFont class is &quot;aware&quot; of this and when it
                 is first used it asks for the registration of its components.
                 Also in the event that any physical font is requested the
                 deferred fonts are initialised before triggering a search of the
                 system.
                 Two maps are used. One to track the deferred fonts. The
                 other to track the fonts that have been initialised through this
                 mechanism.                
            </comment>
            <comment line="913">
                Remind: possibly enhance initialiseDeferredFonts() to be
                 optionally given a name and a style and it could stop when it
                 finds that font - but this would be a problem if two of the
                 fonts reference the same font face name (cf the Solaris
                 euro fonts).                
            </comment>
            <comment line="938">
                We keep a map of the files which contain the Lucida fonts so we
                 don&apos;t need to search for them.
                 But since we know what fonts these files contain, we can also avoid
                 opening them to look for a font name we don&apos;t recognise - see
                 findDeferredFont().
                 For typical cases where the font isn&apos;t a JRE one the overhead is
                 this method call, HashMap.get() and null reference test, then
                 a boolean test of noOtherJREFontFiles.                
            </comment>
            <comment line="1020">
                                
            </comment>
            <comment line="1116">
                Note that the return value from this method is not always
                 derived from this file, and may be null. See addToFontList for
                 some explanation of this.                
            </comment>
            <comment line="1198">
                This is the Physical font used when some other font on the system
                 can&apos;t be located. There has to be at least one font or the font
                 system is not useful and the graphics environment cannot sustain
                 the Java platform.                
            </comment>
            <comment line="1241">
                return String representation of style prepended with &quot;.&quot;
                 This is useful for performance to avoid unnecessary string operations.                
            </comment>
            <comment line="1258">
                This is implemented only on windows and is called from code that
                 executes only on windows. This isn&apos;t pretty but its not a precedent
                 in this file. This very probably should be cleaned up at some point.                
            </comment>
            <comment line="1270">
                Obtained from Platform APIs (windows only)
                 Map from lower-case font full name to basename of font file.
                 Eg &quot;arial bold&quot; -&gt; ARIALBD.TTF.
                 For TTC files, there is a mapping for each font in the file.                
            </comment>
            <comment line="1277">
                Obtained from Platform APIs (windows only)
                 Map from lower-case font full name to the name of its font family
                 Eg &quot;arial bold&quot; -&gt; &quot;Arial&quot;                
            </comment>
            <comment line="1283">
                Obtained from Platform APIs (windows only)
                 Map from a lower-case family name to a list of full names of
                 the member fonts, eg:
                 &quot;arial&quot; -&gt; [&quot;Arial&quot;, &quot;Arial Bold&quot;, &quot;Arial Italic&quot;,&quot;Arial Bold Italic&quot;]                
            </comment>
            <comment line="1290">
                                
            </comment>
            <comment line="1332">
                This is needed since some windows registry names don&apos;t match
                 the font names.
                 - UPC styled font names have a double space, but the
                 registry entry mapping to a file doesn&apos;t.
                 - Marlett is in a hidden file not listed in the registry
                 - The registry advertises that the file david.ttf contains a
                 font with the full name &quot;David Regular&quot; when in fact its
                 just &quot;David&quot;.
                 Directly fix up these known cases as this is faster.
                 If a font which doesn&apos;t match these known cases has no file,
                 it may be a font that has been temporarily added to the known set
                 or it may be an installed font with a missing registry entry.
                 Installed fonts are those in the windows font directories.
                 Make a best effort attempt to locate these.
                 We obtain the list of TrueType fonts in these directories and
                 filter out all the font files we already know about from the registry.
                 What remains may be &quot;bad&quot; fonts, duplicate fonts, or perhaps the
                 missing font(s) we are looking for.
                 Open each of these files to find out.                
            </comment>
            <comment line="1599">
                Hardwire the English names and expected file names of fonts
                 commonly used at start up. Avoiding until later even the small
                 cost of calling platform APIs to locate these can help.
                 The code that registers these fonts needs to &quot;bail&quot; if any
                 of the files do not exist, so it will verify the existence of
                 all non-null file names first.
                 They are added in to a map with nominally the first
                 word in the name of the family as the key. In all the cases
                 we are using the the family name is a single word, and as is
                 more or less required the family name is the initial sequence
                 in a full name. So lookup first finds the matching description,
                 then registers the whole family, returning the right font.                
            </comment>
            <comment line="1840">
                                
            </comment>
            <comment line="1887">
                Used to register any font files that are found by platform APIs
                 that weren&apos;t previously found in the standard font locations.
                 the isAbsolute() check is needed since that&apos;s whats stored in the
                 set, and on windows, the fonts in the system font directory that
                 are in the fontToFileMap are just basenames. We don&apos;t want to try
                 to register those again, but we do want to register other registry
                 installed fonts.                
            </comment>
            <comment line="1917">
                Path may be absolute or a base file name relative to one of
                 the platform font directories                
            </comment>
            <comment line="1946">
                lcName is required to be lower case for use as a key.
                 lcName may be a full name, or a family name, and style may
                 be specified in addition to either of these. So be sure to
                 get the right one. Since an app could ask for &quot;Foo Regular&quot;
                 and later ask for &quot;Foo Italic&quot;, if we don&apos;t register all the
                 styles, then logic in findFont2D may try to style the original
                 so we register the entire family if we get a match here.
                 This is still a big win because this code is invoked where
                 otherwise we would register all fonts.
                 It&apos;s also useful for the case where &quot;Foo Bold&quot; was specified with
                 style Font.ITALIC, as we would want in that case to try to return
                 &quot;Foo Bold Italic&quot; if it exists, and it is only by locating &quot;Foo Bold&quot;
                 and opening it that we really &quot;know&quot; it&apos;s Bold, and can look for
                 a font that supports that and the italic style.
                 The code in here is not overtly windows-specific but in fact it
                 is unlikely to be useful as is on other platforms. It is maintained
                 in this shared source file to be close to its sole client and
                 because so much of the logic is intertwined with the logic in
                 findFont2D.                
            </comment>
            <comment line="2060">
                The client supplies a name and a style.
                 The name could be a family name, or a full name.
                 A font may exist with the specified style, or it may
                 exist only in some other style. For non-native fonts the scaler
                 may be able to emulate the required style.                
            </comment>
            <comment line="2420">
                Workaround for apps which are dependent on a font metrics bug
                 in JDK 1.1. This is an unsupported win32 private setting.
                 Left in for a customer - do not remove.                
            </comment>
            <comment line="2541">
                remind: used in X11GraphicsEnvironment and called often enough
                 that we ought to obsolete this code                
            </comment>
            <comment line="2554">
                This is called when font is determined to be invalidbad.
                 It designed to be called (for example) by the font scaler
                 when in processing a font file it is discovered to be incorrect.
                 This is different than the case where fonts are discovered to
                 be incorrect during initial verification, as such fonts are
                 never registered.
                 Handles to this font held are re-directed to a default font.
                 This default may not be an ideal substitute buts it better than
                 crashing This code assumes a PhysicalFont parameter as it doesn&apos;t
                 make sense for a Composite to be &quot;bad&quot;.                
            </comment>
            <comment line="2579">
                This encapsulates all the work that needs to be done when a
                 Font2D is replaced by a different Font2D.                
            </comment>
            <comment line="2702">
                This replicate the core logic of findFont2D but operates on
                 all the locale names. This hasn&apos;t been merged into findFont2D to
                 keep the logic simpler and reduce overhead, since this case is
                 almost never used. The main case in which it is called is when
                 a bogus font name is used and we need to check all possible names
                 before returning the default case.                
            </comment>
            <comment line="2775">
                Supporting &quot;alternate&quot; composite fonts on 2D graphics objects
                 is accessed by the application by calling methods on the local
                 GraphicsEnvironment. The overall implementation is described
                 in one place, here, since otherwise the implementation is spread
                 around it may be difficult to track.
                 The methods below call into SunGraphicsEnvironment which creates a
                 new FontConfiguration instance. The FontConfiguration class,
                 and its platform sub-classes are updated to take parameters requesting
                 these behaviours. This is then used to create new composite font
                 instances. Since this calls the initCompositeFont method in
                 SunGraphicsEnvironment it performs the same initialization as is
                 performed normally. There may be some duplication of effort, but
                 that code is already written to be able to perform properly if called
                 to duplicate work. The main difference is that if we detect we are
                 running in an appletbrowserJava plugin environment these new fonts
                 are not placed in the &quot;default&quot; maps but into an AppContext instance.
                 The font lookup mechanism in java.awt.Font.getFont2D() is also updated
                 so that look-up for composite fonts will in that case always
                 do a lookup rather than returning a cached result.
                 This is inefficient but necessary else singleton java.awt.Font
                 instances would not retrieve the correct Font2D for the appcontext.
                 sun.font.FontManager.findFont2D is also updated to that it uses
                 a name map cache specific to that appcontext.
                
                 Getting an AppContext is expensive, so there is a global variable
                 that records whether these methods have ever been called and can
                 avoid the expense for almost all applications. Once the correct
                 CompositeFont is associated with the Font, everything should work
                 through existing mechanisms.
                 A special case is that GraphicsEnvironment.getAllFonts() must
                 return an AppContext specific list.
                
                 Calling the methods below is &quot;heavyweight&quot; but it is expected that
                 these methods will be called very rarely.
                
                 If _usingPerAppContextComposites is true, we are in &quot;applet&quot;
                 (eg browser) enviroment and at least one context has selected
                 an alternate composite font behaviour.
                 If _usingAlternateComposites is true, we are not in an &quot;applet&quot;
                 environment and the (single) application has selected
                 an alternate composite font behaviour.
                
                 - Printing: The implementation delegates logical fonts to an AWT
                 mechanism which cannot use these alternate configurations.
                 We can detect that alternate fonts are in use and back-off to 2D, but
                 that uses outlines. Much of this can be fixed with additional work
                 but that may have to wait. The results should be correct, just not
                 optimal.                
            </comment>
            <comment line="2830">
                These values are used only if we are running as a standalone
                 application, as determined by maybeMultiAppContext();                
            </comment>
            <comment line="2837">
                This method doesn&apos;t check if alternates are selected in this app
                 context. Its used by the FontMetrics caching code which in such
                 a case cannot retrieve a cached metrics solely on the basis of
                 the Font.equals() method since it needs to also check if the Font2D
                 is the same.
                 We also use non-standard composites for Swing native L&amp;F fonts on
                 Windows. In that case the policy is that the metrics reported are
                 based solely on the physical font in the first slot which is the
                 visible java.awt.Font. So in that case the metrics cache which tests
                 the Font does what we want. In the near future when we expand the GTK
                 logical font definitions we may need to revisit this if GTK reports
                 combined metrics instead. For now though this test can be simple.                
            </comment>
            <comment line="2873">
                Modifies the behaviour of a subsequent call to preferLocaleFonts()
                 to use Mincho instead of Gothic for dialoginput in JA locales
                 on windows. Not needed on other platforms.                
            </comment>
            <comment line="2992">
                                
            </comment>
            <comment line="3092">
                                
            </comment>
            <comment line="3105">
                It may look odd to use TreeMap but its more convenient to the caller.                
            </comment>
            <comment line="3186">
                Begin: Refactored from SunGraphicsEnviroment.                
            </comment>
            <comment line="3188">
                helper function for registerFonts                
            </comment>
            <comment line="3276">
                A call to this method should be followed by a call to
                 registerFontDirs(..)                
            </comment>
            <comment line="3349">
                                
            </comment>
            <comment line="3457">
                This method asks the font configuration API for all platform names
                 used as components of compositelogical fonts and iterates over these
                 looking up their corresponding file name and registers these fonts.
                 It also ensures that the fonts are accessible via platform APIs.
                 The composites themselves are then registered.                
            </comment>
            <comment line="3611">
                A GE may verify whether a font file used in a fontconfiguration
                 exists. If it doesn&apos;t then either we may substitute the default
                 font, or perhaps elide it altogether from the composite font.
                 This makes some sense on windows where the font file is only
                 likely to be in one place. But on other OSes, eg Linux, the file
                 can move around depending. So there we probably don&apos;t want to assume
                 its missing and so won&apos;t add it to this list.
                 If this list - missingFontFiles - is non-null then the composite
                 font initialisation logic tests to see if a font file is in that
                 set.
                 Only one thread should be able to add to this set so we don&apos;t
                 synchronize.                
            </comment>
            <comment line="3632">
                This is for use only within getAllFonts().
                 Fonts listed in the fontconfig files for windows were all
                 on the &quot;deferred&quot; initialisation list. They were registered
                 either in the course of the application, or in the call to
                 loadFonts() within getAllFonts(). The fontconfig file specifies
                 the names of the fonts using the English names. If there&apos;s a
                 different name in the execution locale, then the platform will
                 report that, and we will construct the font with both names, and
                 thereby enumerate it twice. This happens for Japanese fonts listed
                 in the windows fontconfig, when run in the JA locale. The solution
                 is to rely (in this case) on the platform&apos;s font-&gt;file mapping to
                 determine that this name corresponds to a file we already registered.
                 This works because
                 - we know when we get here all deferred fonts are already initialised
                 - when we register a font file, we register all fonts in it.
                 - we know the fontconfig fonts are all in the windows registry                
            </comment>
            <comment line="3658">
                This invocation is not in a privileged block because
                 all privileged operations (reading files and properties)
                 was conducted on the creation of the GE                
            </comment>
            <comment line="3799">
                Really we need only the JRE fonts family names, but there&apos;s little
                 overhead in doing this the easy way by adding all the currently
                 known fonts.                
            </comment>
            <implements interface="FontSupport"/>
            <implements interface="FontManagerForSGE"/>
            <javadoc line="58">
                The base implementation of the {@link FontManager} interface. It implements
                  the platform independent, shared parts of OpenJDK&apos;s FontManager
                  implementations. The platform specific parts are declared as abstract
                  methods that have to be implemented by specific implementations.                
            </javadoc>
            <class name="TTFilter" line="66">
                <comment line="582">
                    static boolean fontSupportsDefaultEncoding(Font font) {
                          String encoding =
                              (String) java.security.AccessController.doPrivileged(
                                    new sun.security.action.GetPropertyAction(&quot;file.encoding&quot;));                    
                </comment>
                <comment line="587">
                    if (encoding == null || font == null) {
                              return false;
                          }                    
                </comment>
                <comment line="591">
                    encoding = encoding.toLowerCase(Locale.ENGLISH);                    
                </comment>
                <comment line="593">
                    return FontManager.fontSupportsEncoding(font, encoding);
                         }                    
                </comment>
                <comment line="948">
                                        
                </comment>
                <implements interface="FilenameFilter"/>
                <method name="accept" type="boolean" line="67">
                    <params>
                        <param name="dir" type="File"/>
                        <param name="name" type="String"/>
                    </params>
                    <comment line="69">
                                                
                    </comment>
                    <comment line="71">
                                                
                    </comment>
                    <declaration name="offset" type="int" line="69"/>
                    <scope line="70"/>
                    <scope line="72"/>
                </method>
            </class>
            <class name="T1Filter" line="83">
                <comment line="582">
                    static boolean fontSupportsDefaultEncoding(Font font) {
                          String encoding =
                              (String) java.security.AccessController.doPrivileged(
                                    new sun.security.action.GetPropertyAction(&quot;file.encoding&quot;));                    
                </comment>
                <comment line="587">
                    if (encoding == null || font == null) {
                              return false;
                          }                    
                </comment>
                <comment line="591">
                    encoding = encoding.toLowerCase(Locale.ENGLISH);                    
                </comment>
                <comment line="593">
                    return FontManager.fontSupportsEncoding(font, encoding);
                         }                    
                </comment>
                <comment line="948">
                                        
                </comment>
                <implements interface="FilenameFilter"/>
                <method name="accept" type="boolean" line="84">
                    <params>
                        <param name="dir" type="File"/>
                        <param name="name" type="String"/>
                    </params>
                    <comment line="89">
                                                
                    </comment>
                    <comment line="91">
                                                
                    </comment>
                    <scope line="85"/>
                    <declaration name="offset" type="int" line="89"/>
                    <scope line="90"/>
                    <scope line="92"/>
                </method>
            </class>
            <class name="TTorT1Filter" line="101">
                <comment line="582">
                    static boolean fontSupportsDefaultEncoding(Font font) {
                          String encoding =
                              (String) java.security.AccessController.doPrivileged(
                                    new sun.security.action.GetPropertyAction(&quot;file.encoding&quot;));                    
                </comment>
                <comment line="587">
                    if (encoding == null || font == null) {
                              return false;
                          }                    
                </comment>
                <comment line="591">
                    encoding = encoding.toLowerCase(Locale.ENGLISH);                    
                </comment>
                <comment line="593">
                    return FontManager.fontSupportsEncoding(font, encoding);
                         }                    
                </comment>
                <comment line="948">
                                        
                </comment>
                <implements interface="FilenameFilter"/>
                <method name="accept" type="boolean" line="102">
                    <params>
                        <param name="dir" type="File"/>
                        <param name="name" type="String"/>
                    </params>
                    <comment line="105">
                                                
                    </comment>
                    <comment line="107">
                                                
                    </comment>
                    <declaration name="offset" type="int" line="105"/>
                    <scope line="106"/>
                    <scope line="108">
                        <declaration name="isTT" type="boolean" line="109"/>
                        <scope line="116"/>
                        <scope line="118"/>
                        <scope line="120"/>
                    </scope>
                </method>
            </class>
            <declaration name="FONTFORMAT_NONE" type="int" line="130"/>
            <declaration name="FONTFORMAT_TRUETYPE" type="int" line="131"/>
            <declaration name="FONTFORMAT_TYPE1" type="int" line="132"/>
            <declaration name="FONTFORMAT_T2K" type="int" line="133"/>
            <declaration name="FONTFORMAT_TTC" type="int" line="134"/>
            <declaration name="FONTFORMAT_COMPOSITE" type="int" line="135"/>
            <declaration name="FONTFORMAT_NATIVE" type="int" line="136"/>
            <declaration name="CHANNELPOOLSIZE" type="int" line="145"/>
            <declaration name="lastPoolIndex" type="int" line="146"/>
            <declaration name="fontFileCache" type="FileFont" line="147"/>
            <declaration name="maxCompFont" type="int" line="158"/>
            <declaration name="compFonts" type="CompositeFont[]" line="159"/>
            <declaration name="compositeFonts" type="ConcurrentHashMap&lt;String,CompositeFont&gt;" line="160"/>
            <declaration name="physicalFonts" type="ConcurrentHashMap&lt;String,PhysicalFont&gt;" line="162"/>
            <declaration name="registeredFonts" type="ConcurrentHashMap&lt;String,PhysicalFont&gt;" line="164"/>
            <declaration name="fullNameToFont" type="ConcurrentHashMap&lt;String,Font2D&gt;" line="171"/>
            <declaration name="localeFullNamesToFont" type="HashMap&lt;String,TrueTypeFont&gt;" line="177"/>
            <declaration name="defaultPhysicalFont" type="PhysicalFont" line="179"/>
            <declaration name="longAddresses" type="boolean" line="181"/>
            <declaration name="loaded1dot0Fonts" type="boolean" line="182"/>
            <declaration name="loadedAllFonts" type="boolean" line="183"/>
            <declaration name="loadedAllFontFiles" type="boolean" line="184"/>
            <declaration name="jreFontMap" type="HashMap&lt;String,String&gt;" line="185"/>
            <declaration name="jreLucidaFontFiles" type="HashSet&lt;String&gt;" line="186"/>
            <declaration name="jreOtherFontFiles" type="String[]" line="187"/>
            <declaration name="noOtherJREFontFiles" type="boolean" line="188"/>
            <declaration name="lucidaFontName" type="String" line="190"/>
            <declaration name="jreLibDirName" type="String" line="191"/>
            <declaration name="jreFontDirName" type="String" line="192"/>
            <declaration name="missingFontFiles" type="HashSet&lt;String&gt;" line="193"/>
            <declaration name="defaultFontName" type="String" line="194"/>
            <declaration name="defaultFontFileName" type="String" line="195"/>
            <declaration name="registeredFontFiles" type="HashSet" line="196"/>
            <declaration name="badFonts" type="ArrayList" line="198"/>
            <declaration name="fontPath" type="String" line="206"/>
            <declaration name="fontConfig" type="FontConfiguration" line="207"/>
            <declaration name="discoveredAllFonts" type="boolean" line="213"/>
            <declaration name="ttFilter" type="FilenameFilter" line="218"/>
            <declaration name="t1Filter" type="FilenameFilter" line="219"/>
            <declaration name="allFonts" type="Font[]" line="221"/>
            <declaration name="allFamilies" type="String[]" line="222"/>
            <declaration name="lastDefaultLocale" type="Locale" line="223"/>
            <declaration name="noType1Font" type="boolean" line="225"/>
            <declaration name="STR_ARRAY" type="String[]" line="228"/>
            <declaration name="usePlatformFontMetrics" type="boolean" line="230"/>
            <javadoc line="230">
                Deprecated, unsupported hack - actually invokes a bug!
                  Left in for a customer, don&apos;t remove.                
            </javadoc>
            <javadoc line="236">
                Returns the global SunFontManager instance. This is similar to{@link FontManagerFactory#getInstance()} but it returns a
                  SunFontManager instance instead. This is only used in internal classes
                  where we can safely assume that a SunFontManager is to be used.                
                <return>
                    the global SunFontManager instance                    
                </return>
            </javadoc>
            <method name="getInstance" type="SunFontManager" line="244">
                <declaration name="fm" type="FontManager" line="245"/>
            </method>
            <method name="getTrueTypeFilter" type="FilenameFilter" line="249"/>
            <method name="getType1Filter" type="FilenameFilter" line="253"/>
            <method name="usingPerAppContextComposites" type="boolean" line="258"/>
            <method name="initJREFontMap" type="void" line="262">
                <comment line="265">
                    Key is familyname+style value as an int.
                     Value is filename containing the font.
                     If no mapping exists, it means there is no font file for the style
                     If the mapping exists but the file doesn&apos;t exist in the deferred
                     list then it means its not installed.
                     This looks like a lot of code and strings but if it saves even
                     a single file being opened at JRE start-up there&apos;s a big payoff.
                     Lucida Sans is probably the only important case as the others
                     are rarely used. Consider removing the other mappings if there&apos;s
                     no evidence they are useful in practice.                    
                </comment>
                <comment line="281">
                                        
                </comment>
                <comment line="284">
                                        
                </comment>
                <comment line="290">
                                        
                </comment>
                <comment line="294">
                                        
                </comment>
                <comment line="304">
                                        
                </comment>
                <comment line="309">
                                        
                </comment>
                <scope line="277"/>
                <scope line="323"/>
            </method>
            <scope line="328">
                <anonymous_class line="331">
                    <method name="run" type="Object" line="333">
                        <comment line="337">
                            JNI throws an exception if a class/method/field is not found,
                             so there&apos;s no need to do anything explicit here.                            
                        </comment>
                        <declaration name="lucidaFile" type="File" line="351"/>
                    </method>
                </anonymous_class>
            </scope>
            <method name="getEUDCFont" type="TrueTypeFont" line="359">
                <comment line="361">
                    Overridden in Windows.                    
                </comment>
            </method>
            <method name="initIDs" type="void" line="365"/>
            <method name="SunFontManager" type="constructor" line="368">
                <comment line="407">
                    Here we get the fonts in jrelibfonts and register
                     them so they are always available and preferred over
                     other fonts. This needs to be registered before the
                     composite fonts as otherwise some native font that
                     corresponds may be found as we don&apos;t have a way to
                     handle two fonts of the same name, so the JRE one
                     must be the first one registered. Pass &quot;true&quot; to
                     registerFonts method as on-screen these JRE fonts
                     always go through the T2K rasteriser.                    
                </comment>
                <comment line="418">
                                        
                </comment>
                <comment line="424">
                    Create the font configuration and get any font path
                     that might be specified.                    
                </comment>
                <comment line="436">
                    In prior releases the debugging font path replaced
                     all normally located font directories except for the
                     JRE fonts dir. This directory is still always located
                     and placed at the head of the path but as an
                     augmentation to the previous behaviour the
                     changes below allow you to additionally append to
                     the font path by starting with append: or prepend by
                     starting with a prepend: sign. Eg: to append
                     -Dsun.java2d.fontpath=append:usrlocalmyfonts
                     and to prepend
                     -Dsun.java2d.fontpath=prepend:usrlocalmyfonts Disp
                    
                     If there is an appendedfontpath it in the font
                     configuration it is used instead of searching the
                     system for dirs.
                     The behaviour of append and prepend is then similar
                     to the normal case. ie it goes after what
                     you prepend and  before what you append. If the
                     sun.java2d.fontpath property is used, but it
                     neither the append or prepend syntaxes is used then
                     as except for the JRE dir the path is replaced and it
                     is up to you to make sure that all the right
                     directories are located. This is platform and
                     locale-specific so its almost impossible to get
                     right, so it should be used with caution.                    
                </comment>
                <comment line="487">
                    In debugging mode we register all the paths
                     Caution: this is a very expensive call on Solaris:-                    
                </comment>
                <comment line="507">
                    If the font configuration contains an
                     &quot;appendedfontpath&quot; entry, it is interpreted as a
                     set of locations that should always be registered.
                     It may be additional to locations normally found
                     for that place, or it may be locations that need
                     to have all their paths registered to locate all
                     the needed platform names.
                     This is typically when the same .TTF file is
                     referenced from multiple font.dir files and all
                     of these must be read to find all the native
                     (XLFD) names for the font, so that X11 font APIs
                     can be used for as many code points as possible.                    
                </comment>
                <comment line="523">
                    On Solaris, we need to register the Japanese TrueType
                     directory so that we can find the corresponding
                     bitmap fonts. This could be done by listing the
                     directory in the font configuration file, but we
                     don&apos;t want to confuse users with this quirk. There
                     are no bitmap fonts for other writing systems that
                     correspond to TrueType fonts and have matching XLFDs.
                     We need to register the bitmap fonts only in
                     environments where they&apos;re on the X font path, i.e.,
                     in the Japanese locale. Note that if the X Toolkit
                     is in use the font path isn&apos;t set up by JDK, but
                     users of a JA locale should have it
                     set up already by their login environment.                    
                </comment>
                <anonymous_class line="372">
                    <method name="run" type="Object" line="373">
                        <comment line="407">
                            Here we get the fonts in jrelibfonts and register
                             them so they are always available and preferred over
                             other fonts. This needs to be registered before the
                             composite fonts as otherwise some native font that
                             corresponds may be found as we don&apos;t have a way to
                             handle two fonts of the same name, so the JRE one
                             must be the first one registered. Pass &quot;true&quot; to
                             registerFonts method as on-screen these JRE fonts
                             always go through the T2K rasteriser.                            
                        </comment>
                        <comment line="418">
                                                        
                        </comment>
                        <comment line="424">
                            Create the font configuration and get any font path
                             that might be specified.                            
                        </comment>
                        <comment line="436">
                            In prior releases the debugging font path replaced
                             all normally located font directories except for the
                             JRE fonts dir. This directory is still always located
                             and placed at the head of the path but as an
                             augmentation to the previous behaviour the
                             changes below allow you to additionally append to
                             the font path by starting with append: or prepend by
                             starting with a prepend: sign. Eg: to append
                             -Dsun.java2d.fontpath=append:usrlocalmyfonts
                             and to prepend
                             -Dsun.java2d.fontpath=prepend:usrlocalmyfonts Disp
                            
                             If there is an appendedfontpath it in the font
                             configuration it is used instead of searching the
                             system for dirs.
                             The behaviour of append and prepend is then similar
                             to the normal case. ie it goes after what
                             you prepend and  before what you append. If the
                             sun.java2d.fontpath property is used, but it
                             neither the append or prepend syntaxes is used then
                             as except for the JRE dir the path is replaced and it
                             is up to you to make sure that all the right
                             directories are located. This is platform and
                             locale-specific so its almost impossible to get
                             right, so it should be used with caution.                            
                        </comment>
                        <comment line="487">
                            In debugging mode we register all the paths
                             Caution: this is a very expensive call on Solaris:-                            
                        </comment>
                        <comment line="507">
                            If the font configuration contains an
                             &quot;appendedfontpath&quot; entry, it is interpreted as a
                             set of locations that should always be registered.
                             It may be additional to locations normally found
                             for that place, or it may be locations that need
                             to have all their paths registered to locate all
                             the needed platform names.
                             This is typically when the same .TTF file is
                             referenced from multiple font.dir files and all
                             of these must be read to find all the native
                             (XLFD) names for the font, so that X11 font APIs
                             can be used for as many code points as possible.                            
                        </comment>
                        <comment line="523">
                            On Solaris, we need to register the Japanese TrueType
                             directory so that we can find the corresponding
                             bitmap fonts. This could be done by listing the
                             directory in the font configuration file, but we
                             don&apos;t want to confuse users with this quirk. There
                             are no bitmap fonts for other writing systems that
                             correspond to TrueType fonts and have matching XLFDs.
                             We need to register the bitmap fonts only in
                             environments where they&apos;re on the X font path, i.e.,
                             in the Japanese locale. Note that if the X Toolkit
                             is in use the font path isn&apos;t set up by JDK, but
                             users of a JA locale should have it
                             set up already by their login environment.                            
                        </comment>
                        <declaration name="badFontFile" type="File" line="374"/>
                        <scope line="377">
                            <declaration name="fis" type="FileInputStream" line="378"/>
                            <scope line="379">
                                <declaration name="isr" type="InputStreamReader" line="382"/>
                                <declaration name="br" type="BufferedReader" line="383"/>
                                <scope line="384">
                                    <declaration name="name" type="String" line="385"/>
                                    <scope line="386"/>
                                    <scope line="388">
                                        <scope line="389"/>
                                    </scope>
                                </scope>
                            </scope>
                            <scope line="396">
                                <scope line="397">
                                    <scope line="398"/>
                                </scope>
                                <scope line="401"/>
                            </scope>
                        </scope>
                        <scope line="416"/>
                        <scope line="427">
                            <declaration name="fontInfo" type="String[]" line="428"/>
                        </scope>
                        <declaration name="extraFontPath" type="String" line="433"/>
                        <declaration name="prependToPath" type="boolean" line="461"/>
                        <declaration name="appendToPath" type="boolean" line="462"/>
                        <declaration name="dbgFontPath" type="String" line="463"/>
                        <scope line="466">
                            <scope line="467"/>
                            <scope line="471"/>
                        </scope>
                        <scope line="478">
                            <declaration name="logger" type="PlatformLogger" line="479"/>
                        </scope>
                        <scope line="485">
                            <scope line="491"/>
                            <scope line="495"/>
                            <scope line="498"/>
                            <scope line="501"/>
                        </scope>
                        <scope line="505"/>
                        <scope line="536"/>
                    </method>
                </anonymous_class>
                <anonymous_class line="547">
                    <method name="run" type="Boolean" line="548">
                        <declaration name="prop" type="String" line="549"/>
                        <declaration name="env" type="String" line="551"/>
                    </method>
                </anonymous_class>
                <declaration name="platformFont" type="boolean" line="546"/>
                <scope line="556"/>
            </method>
            <javadoc line="565">
                This method is provided for internal and exclusive use by Swing.                
                <param>
                    font representing a physical font.                    
                </param>
                <return>
                    true if the underlying font is a TrueType or OpenType font
                      that claims to support the Microsoft Windows encoding corresponding to
                      the default file.encoding property of this JRE instance.
                      This narrow value is useful for Swing to decide if the font is useful
                      for the the Windows Look and Feel, or, if a  composite font should be
                      used instead.
                      The information used to make the decision is obtained from
                      the ulCodePageRange fields in the font.
                      A caller can use isLogicalFont(Font) in this class before calling
                      this method and would not need to call this method if that
                      returns true.                    
                </return>
            </javadoc>
            <method name="getNewComposite" type="Font2DHandle" line="596">
                <params>
                    <param name="family" type="String"/>
                    <param name="style" type="int"/>
                    <param name="handle" type="Font2DHandle"/>
                </params>
                <comment line="582">
                    static boolean fontSupportsDefaultEncoding(Font font) {
                          String encoding =
                              (String) java.security.AccessController.doPrivileged(
                                    new sun.security.action.GetPropertyAction(&quot;file.encoding&quot;));                    
                </comment>
                <comment line="587">
                    if (encoding == null || font == null) {
                              return false;
                          }                    
                </comment>
                <comment line="591">
                    encoding = encoding.toLowerCase(Locale.ENGLISH);                    
                </comment>
                <comment line="593">
                    return FontManager.fontSupportsEncoding(font, encoding);
                         }                    
                </comment>
                <comment line="620">
                                        
                </comment>
                <scope line="598"/>
                <declaration name="oldComp" type="CompositeFont" line="602"/>
                <declaration name="oldFont" type="PhysicalFont" line="603"/>
                <scope line="605"/>
                <scope line="608"/>
                <declaration name="newFont" type="Font2D" line="612"/>
                <scope line="613"/>
                <declaration name="physicalFont" type="PhysicalFont" line="616"/>
                <declaration name="dialog2D" type="CompositeFont" line="617"/>
                <scope line="619"/>
                <declaration name="compFont" type="CompositeFont" line="622"/>
                <declaration name="newHandle" type="Font2DHandle" line="623"/>
            </method>
            <method name="registerCompositeFont" type="void" line="633">
                <params>
                    <param name="compositeName" type="String"/>
                    <param name="componentFileNames" type="String[]"/>
                    <param name="componentNames" type="String[]"/>
                    <param name="numMetricsSlots" type="int"/>
                    <param name="exclusionRanges" type="int[]"/>
                    <param name="exclusionMaxIndex" type="int[]"/>
                    <param name="defer" type="boolean"/>
                </params>
                <declaration name="cf" type="CompositeFont" line="635"/>
                <scope line="642"/>
            </method>
            <method name="registerCompositeFont" type="void" line="659">
                <params>
                    <param name="compositeName" type="String"/>
                    <param name="componentFileNames" type="String[]"/>
                    <param name="componentNames" type="String[]"/>
                    <param name="numMetricsSlots" type="int"/>
                    <param name="exclusionRanges" type="int[]"/>
                    <param name="exclusionMaxIndex" type="int[]"/>
                    <param name="defer" type="boolean"/>
                    <param name="altNameCache" type="ConcurrentHashMap<String,Font2D>"/>
                </params>
                <comment line="670">
                    if the cache has an existing composite for this case, make
                     its handle point to this new font.
                     This ensures that when the altNameCache that is passed in
                     is the global mapNameCache - ie we are running as an application -
                     that any statically created java.awt.Font instances which already
                     have a Font2D instance will have that re-directed to the new Font
                     on subsequent uses. This is particularly important for &quot;the&quot;
                     default font instance, or similar cases where a UI toolkit (eg
                     Swing) has cached a java.awt.Font. Note that if Swing is using
                     a custom composite APIs which update the standard composites have
                     no effect - this is typically the case only when using the Windows
                     L&amp;F where these APIs would conflict with that L&amp;F anyway.                    
                </comment>
                <declaration name="cf" type="CompositeFont" line="661"/>
                <declaration name="oldFont" type="Font2D" line="682"/>
                <scope line="684"/>
            </method>
            <method name="addCompositeToFontList" type="void" line="690">
                <params>
                    <param name="f" type="CompositeFont"/>
                    <param name="rank" type="int"/>
                </params>
                <scope line="692"/>
                <declaration name="family" type="FontFamily" line="700"/>
                <scope line="701"/>
            </method>
            <method name="addToFontList" type="PhysicalFont" line="738">
                <params>
                    <param name="f" type="PhysicalFont"/>
                    <param name="rank" type="int"/>
                </params>
                <comment line="747">
                                        
                </comment>
                <comment line="772">
                    If the new font is of an equal or higher rank, it is a
                     candidate to replace the current one, subject to further tests.                    
                </comment>
                <comment line="777">
                    All fonts initialise their mapper when first
                     used. If the mapper is non-null then this font
                     has been accessed at least once. In that case
                     do not replace it. This may be overly stringent,
                     but its probably better not to replace a font that
                     someone is already using without a compelling reason.
                     Additionally the primary case where it is known
                     this behaviour is important is in certain composite
                     fonts, and since all the components of a given
                     composite are usually initialised together this
                     is unlikely. For this to be a problem, there would
                     have to be a case where two different composites used
                     different versions of the same-named font, and they
                     were initialised and used at separate times.
                     In that case we continue on and allow the new font to
                     be installed, but replaceFont will continue to allow
                     the original font to be used in Composite fonts.                    
                </comment>
                <comment line="799">
                    Normally we require a higher rank to replace a font,
                     but as a special case, if the two fonts are the same rank,
                     and are instances of TrueTypeFont we want the
                     more complete (larger) one.                    
                </comment>
                <comment line="816">
                    Don&apos;t replace ever JRE fonts.
                     This test is in case a font configuration references
                     a Lucida font, which has been mapped to a Lucida
                     from the host OS. The assumption here is that any
                     such font configuration file is probably incorrect, or
                     the host OS version is for the use of AWT.
                     In other words if we reach here, there&apos;s a possible
                     problem with our choice of font configuration fonts.                    
                </comment>
                <declaration name="fontName" type="String" line="740"/>
                <declaration name="familyName" type="String" line="741"/>
                <scope line="742"/>
                <scope line="745"/>
                <scope line="750">
                    <scope line="751"/>
                    <declaration name="family" type="FontFamily" line="756"/>
                    <scope line="757"/>
                    <scope line="760"/>
                </scope>
                <scope line="765">
                    <declaration name="newFont" type="PhysicalFont" line="766"/>
                    <declaration name="oldFont" type="PhysicalFont" line="767"/>
                    <scope line="768"/>
                    <scope line="774">
                        <scope line="794"/>
                        <scope line="803">
                            <scope line="805">
                                <declaration name="oldTTFont" type="TrueTypeFont" line="806"/>
                                <declaration name="newTTFont" type="TrueTypeFont" line="807"/>
                                <scope line="808"/>
                            </scope>
                            <scope line="811"/>
                        </scope>
                        <scope line="824">
                            <scope line="825"/>
                        </scope>
                        <scope line="835"/>
                        <declaration name="family" type="FontFamily" line="847"/>
                        <scope line="848"/>
                        <scope line="851"/>
                    </scope>
                    <scope line="855"/>
                </scope>
            </method>
            <method name="getRegisteredFonts" type="Font2D[]" line="861">
                <comment line="864">
                                        
                </comment>
                <declaration name="physFonts" type="PhysicalFont[]" line="862"/>
                <declaration name="mcf" type="int" line="863"/>
                <declaration name="regFonts" type="Font2D[]" line="864"/>
            </method>
            <method name="getPhysicalFonts" type="PhysicalFont[]" line="870"/>
            <class name="FontRegistrationInfo" line="888">
                <comment line="582">
                    static boolean fontSupportsDefaultEncoding(Font font) {
                          String encoding =
                              (String) java.security.AccessController.doPrivileged(
                                    new sun.security.action.GetPropertyAction(&quot;file.encoding&quot;));                    
                </comment>
                <comment line="587">
                    if (encoding == null || font == null) {
                              return false;
                          }                    
                </comment>
                <comment line="591">
                    encoding = encoding.toLowerCase(Locale.ENGLISH);                    
                </comment>
                <comment line="593">
                    return FontManager.fontSupportsEncoding(font, encoding);
                         }                    
                </comment>
                <comment line="948">
                                        
                </comment>
                <declaration name="fontFilePath" type="String" line="890"/>
                <declaration name="nativeNames" type="String[]" line="891"/>
                <declaration name="fontFormat" type="int" line="892"/>
                <declaration name="javaRasterizer" type="boolean" line="893"/>
                <declaration name="fontRank" type="int" line="894"/>
                <method name="FontRegistrationInfo" type="constructor" line="897">
                    <params>
                        <param name="fontPath" type="String"/>
                        <param name="names" type="String[]"/>
                        <param name="format" type="int"/>
                        <param name="useJavaRasterizer" type="boolean"/>
                        <param name="rank" type="int"/>
                    </params>
                </method>
            </class>
            <declaration name="deferredFontFiles" type="ConcurrentHashMap&lt;String,FontRegistrationInfo&gt;" line="906"/>
            <declaration name="initialisedFonts" type="ConcurrentHashMap&lt;String,Font2DHandle&gt;" line="909"/>
            <method name="initialiseDeferredFonts" type="void" line="918">
                <scope line="919"/>
            </method>
            <method name="registerDeferredJREFonts" type="void" line="924">
                <params>
                    <param name="jreDir" type="String"/>
                </params>
                <scope line="925">
                    <scope line="927"/>
                </scope>
            </method>
            <method name="isDeferredFont" type="boolean" line="933">
                <params>
                    <param name="fileName" type="String"/>
                </params>
            </method>
            <method name="findJREDeferredFont" type="PhysicalFont" line="947">
                <params>
                    <param name="name" type="String"/>
                    <param name="style" type="int"/>
                </params>
                <comment line="948">
                                        
                </comment>
                <comment line="966">
                    Iterate over the deferred font files looking for any in the
                     jre directory that we didn&apos;t recognise, open each of these.
                     In almost all installations this will quickly fall through
                     because only the Lucidas will be present and jreOtherFontFiles
                     will be empty.
                     noOtherJREFontFiles is used so we can skip this block as soon
                     as its determined that its not needed - almost always after the
                     very first time through.                    
                </comment>
                <comment line="985">
                    skip names which aren&apos;t absolute, aren&apos;t in the JRE
                     directory, or are known Lucida fonts.                    
                </comment>
                <declaration name="physicalFont" type="PhysicalFont" line="949"/>
                <declaration name="nameAndStyle" type="String" line="950"/>
                <declaration name="fileName" type="String" line="951"/>
                <scope line="952">
                    <scope line="954">
                        <scope line="959"/>
                    </scope>
                </scope>
                <scope line="974"/>
                <scope line="977">
                    <scope line="978">
                        <declaration name="otherFontFiles" type="HashSet&lt;String&gt;" line="979"/>
                        <scope line="980">
                            <declaration name="file" type="File" line="981"/>
                            <declaration name="dir" type="String" line="982"/>
                            <declaration name="fname" type="String" line="983"/>
                            <scope line="989"/>
                        </scope>
                        <scope line="995"/>
                    </scope>
                    <scope line="1000">
                        <scope line="1002"/>
                        <scope line="1010"/>
                    </scope>
                </scope>
            </method>
            <method name="findOtherDeferredFont" type="PhysicalFont" line="1020">
                <params>
                    <param name="name" type="String"/>
                    <param name="style" type="int"/>
                </params>
                <scope line="1021">
                    <declaration name="file" type="File" line="1022"/>
                    <declaration name="dir" type="String" line="1023"/>
                    <declaration name="fname" type="String" line="1024"/>
                    <scope line="1027"/>
                    <declaration name="physicalFont" type="PhysicalFont" line="1030"/>
                    <scope line="1034"/>
                </scope>
            </method>
            <method name="findDeferredFont" type="PhysicalFont" line="1041">
                <params>
                    <param name="name" type="String"/>
                    <param name="style" type="int"/>
                </params>
                <declaration name="physicalFont" type="PhysicalFont" line="1043"/>
                <scope line="1044"/>
                <scope line="1046"/>
            </method>
            <method name="registerDeferredFont" type="void" line="1056">
                <params>
                    <param name="fileNameKey" type="String"/>
                    <param name="fullPathName" type="String"/>
                    <param name="nativeNames" type="String[]"/>
                    <param name="fontFormat" type="int"/>
                    <param name="useJavaRasterizer" type="boolean"/>
                    <param name="fontRank" type="int"/>
                </params>
                <declaration name="regInfo" type="FontRegistrationInfo" line="1057"/>
            </method>
            <method name="initialiseDeferredFont" type="PhysicalFont" line="1065">
                <params>
                    <param name="fileNameKey" type="String"/>
                </params>
                <comment line="1088">
                    Store the handle, so that if a font is bad, we
                     retrieve the substituted font.                    
                </comment>
                <comment line="1099">
                                        
                </comment>
                <scope line="1067"/>
                <scope line="1070"/>
                <declaration name="physicalFont" type="PhysicalFont" line="1075"/>
                <declaration name="regInfo" type="FontRegistrationInfo" line="1076"/>
                <scope line="1077">
                    <scope line="1086"/>
                    <scope line="1091"/>
                </scope>
                <scope line="1095">
                    <declaration name="handle" type="Font2DHandle" line="1096"/>
                    <scope line="1097"/>
                    <scope line="1100"/>
                </scope>
            </method>
            <method name="isRegisteredFontFile" type="boolean" line="1107">
                <params>
                    <param name="name" type="String"/>
                </params>
            </method>
            <method name="getRegisteredFontFile" type="PhysicalFont" line="1111">
                <params>
                    <param name="name" type="String"/>
                </params>
            </method>
            <method name="registerFontFile" type="PhysicalFont" line="1123">
                <params>
                    <param name="fileName" type="String"/>
                    <param name="nativeNames" type="String[]"/>
                    <param name="fontFormat" type="int"/>
                    <param name="useJavaRasterizer" type="boolean"/>
                    <param name="fontRank" type="int"/>
                </params>
                <declaration name="regFont" type="PhysicalFont" line="1125"/>
                <scope line="1126"/>
                <declaration name="physicalFont" type="PhysicalFont" line="1130"/>
                <scope line="1131">
                    <declaration name="name" type="String" line="1132"/>
                    <declaration name="fn" type="int" line="1137"/>
                    <declaration name="ttf" type="TrueTypeFont" line="1138"/>
                    <scope line="1139">
                        <declaration name="pf" type="PhysicalFont" line="1142"/>
                        <scope line="1143"/>
                    </scope>
                    <declaration name="t1f" type="Type1Font" line="1151"/>
                    <declaration name="nf" type="NativeFont" line="1156"/>
                    <scope line="1161"/>
                </scope>
                <scope line="1166">
                    <scope line="1167"/>
                </scope>
                <scope line="1173"/>
            </method>
            <method name="registerFonts" type="void" line="1184">
                <params>
                    <param name="fileNames" type="String[]"/>
                    <param name="nativeNames" type="String[][]"/>
                    <param name="fontCount" type="int"/>
                    <param name="fontFormat" type="int"/>
                    <param name="useJavaRasterizer" type="boolean"/>
                    <param name="fontRank" type="int"/>
                    <param name="defer" type="boolean"/>
                </params>
                <scope line="1186">
                    <scope line="1187"/>
                    <scope line="1190"/>
                </scope>
            </method>
            <method name="getDefaultPhysicalFont" type="PhysicalFont" line="1203">
                <comment line="1206">
                    findFont2D will load all fonts before giving up the search.
                     If the JRE Lucida isn&apos;t found (eg because the JRE fonts
                     directory is missing), it could find another version of Lucida
                     from the host system. This is OK because at that point we are
                     trying to gracefully handlerecover from a system
                     misconfiguration and this is probably a reasonable substitution.                    
                </comment>
                <comment line="1220">
                    Because of the findFont2D call above, if we reach here, we
                     know all fonts have already been loaded, just accept any
                     match at this point. If this fails we are in real trouble
                     and I don&apos;t know how to recover from there being absolutely
                     no fonts anywhere on the system.                    
                </comment>
                <scope line="1204">
                    <scope line="1214"/>
                    <scope line="1218">
                        <declaration name="i" type="Iterator" line="1225"/>
                        <scope line="1226"/>
                        <scope line="1228"/>
                    </scope>
                </scope>
            </method>
            <method name="getDefaultLogicalFont" type="CompositeFont" line="1236">
                <params>
                    <param name="style" type="int"/>
                </params>
            </method>
            <method name="dotStyleStr" type="String" line="1244">
                <params>
                    <param name="num" type="int"/>
                </params>
            </method>
            <method name="populateFontFileNameMap" type="void" line="1266">
                <params>
                    <param name="fontToFileMap" type="HashMap<String,String>"/>
                    <param name="fontToFamilyNameMap" type="HashMap<String,String>"/>
                    <param name="familyToFontListMap" type="HashMap<String,ArrayList<String>>"/>
                    <param name="locale" type="Locale"/>
                </params>
            </method>
            <declaration name="fontToFileMap" type="HashMap&lt;String,String&gt;" line="1274"/>
            <declaration name="fontToFamilyNameMap" type="HashMap&lt;String,String&gt;" line="1280"/>
            <declaration name="familyToFontListMap" type="HashMap&lt;String,ArrayList&lt;String&gt;&gt;" line="1287"/>
            <declaration name="pathDirs" type="String[]" line="1290"/>
            <declaration name="haveCheckedUnreferencedFontFiles" type="boolean" line="1292"/>
            <method name="getFontFilesFromPath" type="String[]" line="1294">
                <params>
                    <param name="noType1" type="boolean"/>
                </params>
                <declaration name="filter" type="FilenameFilter" line="1295"/>
                <scope line="1296"/>
                <scope line="1298"/>
                <anonymous_class line="1301">
                    <method name="run" type="Object" line="1302">
                        <scope line="1303">
                            <declaration name="dir" type="File" line="1304"/>
                            <declaration name="files" type="String[]" line="1305"/>
                            <scope line="1306"/>
                            <scope line="1309"/>
                        </scope>
                        <scope line="1313">
                            <declaration name="fileList" type="ArrayList&lt;String&gt;" line="1314"/>
                            <scope line="1315">
                                <declaration name="dir" type="File" line="1316"/>
                                <declaration name="files" type="String[]" line="1317"/>
                                <scope line="1318"/>
                                <scope line="1321"/>
                            </scope>
                        </scope>
                    </method>
                </anonymous_class>
            </method>
            <method name="resolveWindowsFonts" type="void" line="1351">
                <comment line="1361">
                    If this name exists and isn&apos;t for a valid name
                     replace the mapping to the file with this font                    
                </comment>
                <comment line="1389">
                    Every font key in fontToFileMap ought to correspond to a
                     font key in fontToFamilyNameMap. Entries that don&apos;t seem
                     to correspond are likely fonts that were named differently
                     by GDI than in the registry. One known cause of this is when
                     Windows has had its regional settings changed so that from
                     GDI we get a localised (eg Chinese or Japanese) name for the
                     font, but the registry retains the English version of the name
                     that corresponded to the &quot;install&quot; locale for windows.
                     Since we are in this code block because there are unmapped
                     font names, we can look to find unused font-&gt;file mappings
                     and then open the files to read the names. We don&apos;t generally
                     want to open font files, as its a performance hit, but this
                     occurs only for a small number of fonts on specific system
                     configs - ie is believed that a &quot;true&quot; Japanese windows would
                     have JA names in the registry too.
                     Clone fontToFileMap and remove from the clone all keys which
                     match a fontToFamilyNameMap key. What remains maps to the
                     files we want to open to find the fonts GDI returned.
                     A font in such a file is added to the fontToFileMap after
                     checking its one of the unmappedFontNames we are looking for.
                     The original name that didn&apos;t map is removed from fontToFileMap
                     so essentially this &quot;fixes up&quot; fontToFileMap to use the same
                     name as GDI.
                     Also note that typically the fonts for which this occurs in
                     CJK locales are TTC fonts and not all fonts in a TTC may have
                     localised names. Eg MSGOTHIC.TTC contains 3 fonts and one of
                     them &quot;MS UI Gothic&quot; has no JA name whereas the other two do.
                     So not every font in these files is unmapped or new.                    
                </comment>
                <comment line="1430">
                    If there are still unmapped font names, this means there&apos;s
                     something that wasn&apos;t in the registry. We need to get all
                     the font files directly and look at the ones that weren&apos;t
                     found in the registry.                    
                </comment>
                <comment line="1437">
                    getFontFilesFromPath() returns all lower case names.
                     To compare we also need lower case
                     versions of the names from the registry.                    
                </comment>
                <comment line="1446">
                    We don&apos;t look for Type1 files here as windows will
                     not enumerate these, so aren&apos;t useful in reconciling
                     GDI&apos;s unmapped files. We do find these later when
                     we enumerate all fonts.                    
                </comment>
                <comment line="1460">
                    remove from the set of names that will be returned to the
                     user any fonts that can&apos;t be mapped to files.                    
                </comment>
                <declaration name="unmappedFontNames" type="ArrayList&lt;String&gt;" line="1353"/>
                <scope line="1354">
                    <declaration name="file" type="String" line="1355"/>
                    <scope line="1356">
                        <scope line="1357">
                            <declaration name="newName" type="String" line="1358"/>
                            <scope line="1364"/>
                        </scope>
                        <scope line="1368"/>
                        <scope line="1370">
                            <scope line="1372"/>
                        </scope>
                        <scope line="1376">
                            <scope line="1377"/>
                        </scope>
                    </scope>
                </scope>
                <scope line="1385">
                    <declaration name="unmappedFontFiles" type="HashSet&lt;String&gt;" line="1386"/>
                    <declaration name="ffmapCopy" type="HashMap&lt;String,String&gt;" line="1417"/>
                    <scope line="1419"/>
                    <scope line="1422"/>
                    <scope line="1434">
                        <declaration name="registryFiles" type="ArrayList&lt;String&gt;" line="1440"/>
                        <scope line="1442"/>
                        <scope line="1450">
                            <scope line="1451"/>
                        </scope>
                    </scope>
                    <scope line="1462">
                        <declaration name="sz" type="int" line="1463"/>
                        <scope line="1464">
                            <declaration name="name" type="String" line="1465"/>
                            <declaration name="familyName" type="String" line="1466"/>
                            <scope line="1467">
                                <declaration name="family" type="ArrayList" line="1468"/>
                                <scope line="1469">
                                    <scope line="1470"/>
                                </scope>
                            </scope>
                            <scope line="1476"/>
                        </scope>
                    </scope>
                </scope>
            </method>
            <javadoc line="1485">
                In some cases windows may have fonts in the fonts folder that
                  don&apos;t show up in the registry or in the GDI calls to enumerate fonts.
                  The only way to find these is to list the directory. We invoke this
                  only in getAllFonts/Families, so most searches for a specific
                  font that is satisfied by the GDI/registry calls don&apos;t take the
                  additional hit of listing the directory. This hit is small enough
                  that its not significant in these &apos;enumerate all the fonts&apos; cases.
                  The basic approach is to cross-reference the files windows found
                  with the ones in the directory listing approach, and for each
                  in the latter list that is missing from the former list, register it.                
            </javadoc>
            <method name="checkForUnreferencedFontFiles" type="void" line="1497">
                <comment line="1506">
                    getFontFilesFromPath() returns all lower case names.
                     To compare we also need lower case
                     versions of the names from the registry.                    
                </comment>
                <comment line="1515">
                    To avoid any issues with concurrent modification, create
                     copies of the existing maps, add the new fonts into these
                     and then replace the references to the old ones with the
                     new maps. ConcurrentHashmap is another option but its a lot
                     more changes and with this exception, these maps are intended
                     to be static.                    
                </comment>
                <scope line="1498"/>
                <scope line="1502"/>
                <declaration name="registryFiles" type="ArrayList&lt;String&gt;" line="1509"/>
                <scope line="1510"/>
                <declaration name="fontToFileMap2" type="HashMap&lt;String,String&gt;" line="1521"/>
                <declaration name="fontToFamilyNameMap2" type="HashMap&lt;String,String&gt;" line="1522"/>
                <declaration name="familyToFontListMap2" type="HashMap&lt;String,ArrayList&lt;String&gt;&gt;" line="1523"/>
                <scope line="1525">
                    <scope line="1526">
                        <scope line="1527"/>
                        <declaration name="f" type="PhysicalFont" line="1531"/>
                        <scope line="1532"/>
                        <scope line="1535"/>
                        <declaration name="fontName" type="String" line="1542"/>
                        <declaration name="family" type="String" line="1543"/>
                        <declaration name="familyLC" type="String" line="1544"/>
                        <declaration name="fonts" type="ArrayList&lt;String&gt;" line="1547"/>
                        <scope line="1548"/>
                        <scope line="1550"/>
                    </scope>
                </scope>
                <scope line="1557"/>
            </method>
            <method name="resolveFontFiles" type="void" line="1565">
                <params>
                    <param name="unmappedFiles" type="HashSet<String>"/>
                    <param name="unmappedFonts" type="ArrayList<String>"/>
                </params>
                <comment line="1581">
                    prefer the font&apos;s locale name.                    
                </comment>
                <declaration name="l" type="Locale" line="1567"/>
                <scope line="1569">
                    <scope line="1570">
                        <declaration name="fn" type="int" line="1571"/>
                        <declaration name="ttf" type="TrueTypeFont" line="1572"/>
                        <declaration name="fullPath" type="String" line="1573"/>
                        <scope line="1574"/>
                        <scope line="1578">
                            <declaration name="fontName" type="String" line="1581"/>
                            <scope line="1582">
                                <scope line="1585"/>
                            </scope>
                        </scope>
                    </scope>
                    <scope line="1593"/>
                </scope>
            </method>
            <class name="FamilyDescription" line="1611">
                <comment line="582">
                    static boolean fontSupportsDefaultEncoding(Font font) {
                          String encoding =
                              (String) java.security.AccessController.doPrivileged(
                                    new sun.security.action.GetPropertyAction(&quot;file.encoding&quot;));                    
                </comment>
                <comment line="587">
                    if (encoding == null || font == null) {
                              return false;
                          }                    
                </comment>
                <comment line="591">
                    encoding = encoding.toLowerCase(Locale.ENGLISH);                    
                </comment>
                <comment line="593">
                    return FontManager.fontSupportsEncoding(font, encoding);
                         }                    
                </comment>
                <comment line="948">
                                        
                </comment>
                <declaration name="familyName" type="String" line="1612"/>
                <declaration name="plainFullName" type="String" line="1613"/>
                <declaration name="boldFullName" type="String" line="1614"/>
                <declaration name="italicFullName" type="String" line="1615"/>
                <declaration name="boldItalicFullName" type="String" line="1616"/>
                <declaration name="plainFileName" type="String" line="1617"/>
                <declaration name="boldFileName" type="String" line="1618"/>
                <declaration name="italicFileName" type="String" line="1619"/>
                <declaration name="boldItalicFileName" type="String" line="1620"/>
            </class>
            <declaration name="platformFontMap" type="HashMap&lt;String,FamilyDescription&gt;" line="1623"/>
            <javadoc line="1625">
                default implementation does nothing.                
            </javadoc>
            <method name="populateHardcodedFileNameMap" type="HashMap<String,FamilyDescription>" line="1628"/>
            <method name="findFontFromPlatformMap" type="Font2D" line="1632">
                <params>
                    <param name="lcName" type="String"/>
                    <param name="style" type="int"/>
                </params>
                <comment line="1652">
                    Once we&apos;ve established that its at least the first word,
                     we need to dig deeper to make sure its a match for either
                     a full name, or the family name, to make sure its not
                     a request for some other font that just happens to start
                     with the same first word.                    
                </comment>
                <comment line="1676">
                    In a terminal server config, its possible that getPathName()
                     will return null, if the file doesn&apos;t exist, hence the null
                     checks on return. But in the normal client config we need to
                     follow this up with a check to see if all the files really
                     exist for the non-null paths.                    
                </comment>
                <comment line="1721">
                                        
                </comment>
                <comment line="1750">
                    If we reach here we know that we have all the files we
                     expect, so all should be fine so long as the contents
                     are what we&apos;d expect. Now on to registering the fonts.
                     Currently this code only looks for TrueType fonts, so format
                     and rank can be specified without looking at the filename.                    
                </comment>
                <comment line="1770">
                    Two general cases need a bit more work here.
                     1) If font is null, then it was perhaps a request for a
                     non-existent font, such as &quot;Tahoma Italic&quot;, or a family name -
                     where family and full name of the plain font differ.
                     Fall back to finding the closest one in the family.
                     This could still fail if a client specified &quot;Segoe&quot; instead of
                     &quot;Segoe UI&quot;.
                     2) The request is of the form &quot;MyFont Bold&quot;, style=Font.ITALIC,
                     and so we want to see if there&apos;s a Bold Italic font, or
                     &quot;MyFamily&quot;, style=Font.BOLD, and we may have matched the plain,
                     but now need to revise that to the BOLD font.                    
                </comment>
                <scope line="1633"/>
                <scope line="1637"/>
                <declaration name="spaceIndex" type="int" line="1641"/>
                <declaration name="firstWord" type="String" line="1642"/>
                <scope line="1643"/>
                <declaration name="fd" type="FamilyDescription" line="1647"/>
                <scope line="1648"/>
                <declaration name="styleIndex" type="int" line="1657"/>
                <scope line="1658"/>
                <scope line="1660"/>
                <scope line="1662"/>
                <scope line="1664"/>
                <scope line="1667"/>
                <declaration name="plainFile" type="String" line="1671"/>
                <declaration name="failure" type="boolean" line="1674"/>
                <scope line="1683">
                    <scope line="1685"/>
                </scope>
                <scope line="1690">
                    <scope line="1692"/>
                </scope>
                <scope line="1697">
                    <scope line="1699"/>
                </scope>
                <scope line="1704">
                    <scope line="1706"/>
                </scope>
                <scope line="1711">
                    <scope line="1712"/>
                </scope>
                <declaration name="files" type="String[]" line="1721"/>
                <anonymous_class line="1725">
                    <method name="run" type="Boolean" line="1726">
                        <scope line="1727">
                            <scope line="1728"/>
                            <declaration name="f" type="File" line="1731"/>
                            <scope line="1732"/>
                        </scope>
                    </method>
                </anonymous_class>
                <scope line="1740">
                    <scope line="1741"/>
                </scope>
                <declaration name="font" type="Font2D" line="1755"/>
                <scope line="1756">
                    <scope line="1757"/>
                    <declaration name="pf" type="PhysicalFont" line="1760"/>
                    <scope line="1763"/>
                </scope>
                <declaration name="fontFamily" type="FontFamily" line="1781"/>
                <scope line="1782">
                    <scope line="1783">
                        <scope line="1785"/>
                    </scope>
                    <scope line="1788">
                        <scope line="1791"/>
                    </scope>
                </scope>
            </method>
            <method name="getFullNameToFileMap" type="HashMap<String,String>" line="1799">
                <scope line="1800">
                    <scope line="1811"/>
                    <scope line="1814"/>
                </scope>
            </method>
            <method name="logPlatformFontInfo" type="void" line="1821">
                <declaration name="logger" type="PlatformLogger" line="1822"/>
                <scope line="1823"/>
                <scope line="1826"/>
                <scope line="1829"/>
                <scope line="1833"/>
            </method>
            <method name="getFontNamesFromPlatform" type="String[]" line="1840">
                <comment line="1846">
                    This odd code with TreeMap is used to preserve a historical                    
                </comment>
                <scope line="1841"/>
                <declaration name="fontNames" type="ArrayList&lt;String&gt;" line="1847"/>
                <scope line="1848">
                    <scope line="1849"/>
                </scope>
            </method>
            <method name="gotFontsFromPlatform" type="boolean" line="1856"/>
            <method name="getFileNameForFontName" type="String" line="1860">
                <params>
                    <param name="fontName" type="String"/>
                </params>
                <declaration name="fontNameLC" type="String" line="1861"/>
            </method>
            <method name="registerFontFile" type="PhysicalFont" line="1865">
                <params>
                    <param name="file" type="String"/>
                </params>
                <scope line="1867">
                    <declaration name="fontFormat" type="int" line="1868"/>
                    <declaration name="fontRank" type="int" line="1869"/>
                    <scope line="1870"/>
                    <scope line="1874"/>
                    <scope line="1878"/>
                </scope>
            </method>
            <method name="registerOtherFontFiles" type="void" line="1894">
                <params>
                    <param name="registeredFontFiles" type="HashSet"/>
                </params>
                <scope line="1895"/>
                <scope line="1898"/>
            </method>
            <method name="getFamilyNamesFromPlatform" type="boolean" line="1905">
                <params>
                    <param name="familyNames" type="TreeMap<String,String>"/>
                    <param name="requestedLocale" type="Locale"/>
                </params>
                <scope line="1906"/>
                <scope line="1910"/>
            </method>
            <method name="getPathName" type="String" line="1919">
                <params>
                    <param name="s" type="String"/>
                </params>
                <comment line="1943">
                    shouldn&apos;t happen, but harmless                    
                </comment>
                <declaration name="f" type="File" line="1920"/>
                <scope line="1921"/>
                <scope line="1923"/>
                <scope line="1925">
                    <anonymous_class line="1927">
                        <method name="run" type="String" line="1928">
                            <scope line="1929">
                                <declaration name="f" type="File" line="1930"/>
                                <scope line="1931"/>
                            </scope>
                        </method>
                    </anonymous_class>
                    <declaration name="path" type="String" line="1926"/>
                    <scope line="1938"/>
                </scope>
            </method>
            <method name="findFontFromPlatform" type="Font2D" line="1965">
                <params>
                    <param name="lcName" type="String"/>
                    <param name="style" type="int"/>
                </params>
                <comment line="1979">
                    is lcName is a family?                    
                </comment>
                <comment line="1995">
                    first check that for every font in this family we can find
                     a font file. The specific reason for doing this is that
                     in at least one case on Windows a font has the face name &quot;David&quot;
                     but the registry entry is &quot;David Regular&quot;. That is the &quot;unique&quot;
                     name of the font but in other cases the registry contains the
                     &quot;full&quot; name. See the specifications of name ids 3 and 4 in the
                     TrueType &apos;name&apos; table.
                     In general this could cause a problem that we fail to register
                     if we all members of a family that we may end up mapping to
                     the wrong font member: eg return Bold when Plain is needed.                    
                </comment>
                <comment line="2019">
                    Currently this code only looks for TrueType fonts, so format
                     and rank can be specified without looking at the filename.                    
                </comment>
                <comment line="2028">
                                        
                </comment>
                <comment line="2035">
                    Currently this code only looks for TrueType fonts, so format
                     and rank can be specified without looking at the filename.                    
                </comment>
                <comment line="2044">
                                        
                </comment>
                <scope line="1966"/>
                <declaration name="family" type="ArrayList&lt;String&gt;" line="1970"/>
                <declaration name="fontFile" type="String" line="1971"/>
                <declaration name="familyName" type="String" line="1972"/>
                <scope line="1973"/>
                <scope line="1977">
                    <scope line="1979">
                        <declaration name="lcFontName" type="String" line="1980"/>
                        <scope line="1981"/>
                    </scope>
                </scope>
                <scope line="1986"/>
                <declaration name="fontList" type="String[]" line="1989"/>
                <scope line="1990"/>
                <scope line="2005">
                    <declaration name="fontNameLC" type="String" line="2006"/>
                    <declaration name="fileName" type="String" line="2007"/>
                    <scope line="2008">
                        <scope line="2009"/>
                    </scope>
                </scope>
                <declaration name="physicalFont" type="PhysicalFont" line="2021"/>
                <scope line="2022"/>
                <scope line="2028">
                    <declaration name="fontNameLC" type="String" line="2029"/>
                    <declaration name="fileName" type="String" line="2030"/>
                    <scope line="2031"/>
                </scope>
                <declaration name="font" type="Font2D" line="2041"/>
                <declaration name="fontFamily" type="FontFamily" line="2042"/>
                <scope line="2044"/>
                <scope line="2047">
                    <scope line="2049"/>
                </scope>
            </method>
            <declaration name="fontNameCache" type="ConcurrentHashMap&lt;String,Font2D&gt;" line="2056"/>
            <method name="findFont2D" type="Font2D" line="2066">
                <params>
                    <param name="name" type="String"/>
                    <param name="style" type="int"/>
                    <param name="fallback" type="int"/>
                </params>
                <comment line="2072">
                    If preferLocaleFonts() or preferProportionalFonts() has been
                     called we may be using an alternate set of composite fonts in this
                     app context. The presence of a pre-built name map indicates whether
                     this is so, and gives access to the alternate composite for the
                     name.                    
                </comment>
                <comment line="2098">
                    The check below is just so that the bitmap fonts being set by
                     AWT and Swing thru the desktop properties do not trigger the
                     the load fonts case. The two bitmap fonts are now mapped to
                     appropriate equivalents for serif and sansserif.
                     Note that the cost of this comparison is only for the first
                     call until the map is filled.                    
                </comment>
                <comment line="2112">
                    This isn&apos;t intended to support a client passing in the
                     string default, but if a client passes in null for the name
                     the java.awt.Font class internally substitutes this name.
                     So we need to recognise it here to prevent a loadFonts
                     on the unrecognised name. The only potential problem with
                     this is it would hide any real font called &quot;default&quot;!
                     But that seems like a potential problem we can ignore for now.                    
                </comment>
                <comment line="2124">
                                        
                </comment>
                <comment line="2143">
                    If it wasn&apos;t a family name, it should be a full name of
                     either a composite, or a physical font                    
                </comment>
                <comment line="2148">
                    Check that the requested style matches the matched font&apos;s style.
                     But also match style automatically if the requested style is
                     &quot;plain&quot;. This because the existing behaviour is that the fonts
                     listed via getAllFonts etc always list their style as PLAIN.
                     This does lead to non-commutative behaviours where you might
                     start with &quot;Lucida Sans Regular&quot; and ask for a BOLD version
                     and get &quot;Lucida Sans DemiBold&quot; but if you ask for the PLAIN
                     style of &quot;Lucida Sans DemiBold&quot; you get &quot;Lucida Sans DemiBold&quot;.
                     This consistent however with what happens if you have a bold
                     version of a font and no plain version exists - alg. styling
                     doesn&apos;t &quot;unbolden&quot; the font.                    
                </comment>
                <comment line="2164">
                    If it was a full name like &quot;Lucida Sans Regular&quot;, but
                     the style requested is &quot;bold&quot;, then we want to see if
                     there&apos;s the appropriate match against another font in
                     that family before trying to load all fonts, or applying a
                     algorithmic styling                    
                </comment>
                <comment line="2173">
                                        
                </comment>
                <comment line="2178">
                    This next call is designed to support the case
                     where bold italic is requested, and if we must
                     style, then base it on either bold or italic -
                     not on plain!                    
                </comment>
                <comment line="2185">
                    The next check is perhaps one
                     that shouldn&apos;t be done. ie if we get this
                     far we have probably as close a match as we
                     are going to get. We could load all fonts to
                     see if somehow some parts of the family are
                     loaded but not all of it.                    
                </comment>
                <comment line="2214">
                    Don&apos;t want Windows to return a Lucida Sans font from
                     C:\Windows\Fonts                    
                </comment>
                <comment line="2237">
                    If reach here and no match has been located, then if there are
                     uninitialised deferred fonts, load as many of those as needed
                     to find the deferred font. If none is found through that
                     search continue on.
                     There is possibly a minor issue when more than one
                     deferred font implements the same font face. Since deferred
                     fonts are only those in font configuration files, this is a
                     controlled situation, the known case being Solaris euro_fonts
                     versions of Arial, Times New Roman, Courier New. However
                     the larger font will transparently replace the smaller one
                      - see addToFontList() - when it is needed by the composite font.                    
                </comment>
                <comment line="2257">
                    Some apps use deprecated 1.0 names such as helvetica and courier. On
                     Solaris these are Type1 fonts in usropenwinlibX11fontsType1.
                     If running on Solaris will register all the fonts in this
                     directory.
                     May as well register the whole directory without actually testing
                     the font name is one of the deprecated names as the next step would
                     load all fonts which are in this directory anyway.
                     In the event that this lookup is successful it potentially &quot;hides&quot;
                     TrueType versions of such fonts that are elsewhere but since they
                     do not exist on Solaris this is not a problem.
                     Set a flag to indicate we&apos;ve done this registration to avoid
                     repetition and more seriously, to avoid recursion.                    
                </comment>
                <comment line="2271">
                    &quot;timesroman&quot; is a special case since that&apos;s not the
                     name of any known font on Solaris or elsewhere.                    
                </comment>
                <comment line="2284">
                    We check for application registered fonts before
                     explicitly loading all fonts as if necessary the registration
                     code will have done so anyway. And we don&apos;t want to needlessly
                     load the actual files for all fonts.
                     Just as for installed fonts we check for family before fullname.
                     We do not add these fonts to fontNameCache for the
                     app context case which eliminates the overhead of a per context
                     cache for these.                    
                </comment>
                <comment line="2334">
                    If reach here and no match has been located, then if all fonts
                     are not yet loaded, do so, and then recurse.                    
                </comment>
                <comment line="2357">
                    The primary name is the locale default - ie not USEnglish but
                     whatever is the default in this locale. This is the way it always
                     has been but may be surprising to some developers if &quot;Arial Regular&quot;
                     were hard-coded in their app and yet &quot;Arial Regular&quot; was not the
                     default name. Fortunately for them, as a consequence of the JDK
                     supporting returning names and family names for arbitrary locales,
                     we also need to support searching all localised names for a match.
                     But because this case of the name used to reference a font is not
                     the same as the default for this locale is rare, it makes sense to
                     search a much shorter list of default locale names and only go to
                     a longer list of names in the event that no match was found.
                     So add here code which searches localised names too.
                     As in 1.4.x this happens only after loading all fonts, which
                     is probably the right order.                    
                </comment>
                <comment line="2377">
                    Perhaps its a &quot;compatibility&quot; name - timesroman, helvetica,
                     or courier, which 1.0 apps used for logical fonts.
                     We look for these &quot;late&quot; after a loadFonts as we must not
                     hide real fonts of these names.
                     Map these appropriately:
                     On windows this means according to the rules specified by the
                     FontConfiguration : do it only for encoding==Cp1252
                    
                     REMIND: this is something we plan to remove.                    
                </comment>
                <declaration name="lowerCaseName" type="String" line="2067"/>
                <declaration name="mapName" type="String" line="2068"/>
                <declaration name="font" type="Font2D" line="2069"/>
                <scope line="2077">
                    <declaration name="altNameCache" type="ConcurrentHashMap&lt;String,Font2D&gt;" line="2078"/>
                    <scope line="2081"/>
                    <scope line="2083"/>
                </scope>
                <scope line="2086"/>
                <scope line="2089"/>
                <scope line="2093"/>
                <scope line="2103">
                    <scope line="2104"/>
                    <scope line="2106"/>
                </scope>
                <scope line="2119"/>
                <declaration name="family" type="FontFamily" line="2124"/>
                <scope line="2125">
                    <scope line="2127"/>
                    <scope line="2130"/>
                    <scope line="2133"/>
                    <scope line="2136"/>
                </scope>
                <scope line="2146">
                    <scope line="2159"/>
                    <scope line="2162">
                        <scope line="2170">
                            <declaration name="familyFont" type="Font2D" line="2171"/>
                            <scope line="2173"/>
                            <scope line="2176">
                                <scope line="2183">
                                    <scope line="2191"/>
                                </scope>
                            </scope>
                        </scope>
                    </scope>
                </scope>
                <scope line="2201">
                    <scope line="2204"/>
                    <scope line="2208"/>
                    <scope line="2216">
                        <scope line="2218"/>
                    </scope>
                    <scope line="2224">
                        <scope line="2225"/>
                    </scope>
                </scope>
                <scope line="2248">
                    <scope line="2250"/>
                </scope>
                <scope line="2269">
                    <scope line="2273"/>
                    <declaration name="ff" type="Font2D" line="2279"/>
                </scope>
                <scope line="2293">
                    <declaration name="familyTable" type="Hashtable&lt;String,FontFamily&gt;" line="2294"/>
                    <declaration name="nameTable" type="Hashtable&lt;String,Font2D&gt;" line="2295"/>
                    <scope line="2297"/>
                    <scope line="2300">
                        <declaration name="appContext" type="AppContext" line="2301"/>
                    </scope>
                    <scope line="2309">
                        <scope line="2311"/>
                        <scope line="2314"/>
                        <scope line="2317">
                            <scope line="2318"/>
                        </scope>
                    </scope>
                    <scope line="2325">
                        <scope line="2326"/>
                    </scope>
                </scope>
                <scope line="2336">
                    <scope line="2337"/>
                </scope>
                <scope line="2346">
                    <scope line="2347"/>
                </scope>
                <scope line="2371"/>
                <scope line="2386">
                    <declaration name="compatName" type="String" line="2387"/>
                    <scope line="2389"/>
                </scope>
                <scope line="2394"/>
                <scope line="2398"/>
                <scope line="2402"/>
                <scope line="2408"/>
            </method>
            <method name="usePlatformFontMetrics" type="boolean" line="2424"/>
            <method name="getNumFonts" type="int" line="2428"/>
            <method name="fontSupportsEncoding" type="boolean" line="2432">
                <params>
                    <param name="font" type="Font"/>
                    <param name="encoding" type="String"/>
                </params>
            </method>
            <method name="getFontPath" type="String" line="2436"/>
            <declaration name="fileCloser" type="Thread" line="2438"/>
            <declaration name="tmpFontFiles" type="Vector&lt;File&gt;" line="2439"/>
            <method name="createFont2D" type="Font2D" line="2443">
                <params>
                    <param name="fontFile" type="File"/>
                    <param name="fontFormat" type="int"/>
                    <param name="isCopy" type="boolean"/>
                    <param name="tracker" type="CreatedFontTracker"/>
                </params>
                <comment line="2520">
                    The thread must be a member of a thread group
                     which will not get GCed before VM exit.
                     Make its parent the top-level thread group.                    
                </comment>
                <declaration name="fontFilePath" type="String" line="2445"/>
                <declaration name="font2D" type="FileFont" line="2446"/>
                <declaration name="fFile" type="File" line="2447"/>
                <declaration name="_tracker" type="CreatedFontTracker" line="2448"/>
                <scope line="2449"/>
                <scope line="2460">
                    <scope line="2461">
                        <anonymous_class line="2463">
                            <method name="run" type="Object" line="2464">
                                <scope line="2465"/>
                            </method>
                        </anonymous_class>
                    </scope>
                </scope>
                <scope line="2475">
                    <scope line="2477">
                        <scope line="2479"/>
                        <scope line="2484">
                            <anonymous_class line="2485">
                                <method name="run" type="void" line="2486">
                                    <anonymous_class line="2488">
                                        <method name="run" type="Object" line="2489">
                                            <scope line="2491">
                                                <scope line="2492">
                                                    <scope line="2493"/>
                                                    <scope line="2495"/>
                                                </scope>
                                            </scope>
                                            <scope line="2499">
                                                <declaration name="files" type="File[]" line="2500"/>
                                                <scope line="2502">
                                                    <scope line="2503"/>
                                                    <scope line="2505"/>
                                                </scope>
                                            </scope>
                                        </method>
                                    </anonymous_class>
                                </method>
                            </anonymous_class>
                            <declaration name="fileCloserRunnable" type="Runnable" line="2485"/>
                            <anonymous_class line="2517">
                                <method name="run" type="Object" line="2518">
                                    <comment line="2520">
                                        The thread must be a member of a thread group
                                         which will not get GCed before VM exit.
                                         Make its parent the top-level thread group.                                        
                                    </comment>
                                    <declaration name="tg" type="ThreadGroup" line="2523"/>
                                </method>
                            </anonymous_class>
                        </scope>
                    </scope>
                </scope>
            </method>
            <method name="getFullNameByFileName" type="String" line="2543">
                <params>
                    <param name="fileName" type="String"/>
                </params>
                <declaration name="physFonts" type="PhysicalFont[]" line="2544"/>
                <scope line="2545">
                    <scope line="2546"/>
                </scope>
            </method>
            <method name="deRegisterBadFont" type="void" line="2565">
                <params>
                    <param name="font2D" type="Font2D"/>
                </params>
                <comment line="2568">
                                        
                </comment>
                <scope line="2566"/>
                <scope line="2569">
                    <scope line="2570"/>
                </scope>
            </method>
            <method name="replaceFont" type="void" line="2583">
                <params>
                    <param name="oldFont" type="PhysicalFont"/>
                    <param name="newFont" type="PhysicalFont"/>
                </params>
                <comment line="2587">
                                        
                </comment>
                <comment line="2591">
                    If we try to replace the font with itself, that won&apos;t work,
                     so pick any alternative physical font                    
                </comment>
                <comment line="2615">
                    eliminate references to this font, so it won&apos;t be located
                     by future callers, and will be eligible for GC when all
                     references are removed                    
                </comment>
                <comment line="2628">
                    Should I be replacing these, or just I just remove
                     the names from the map?                    
                </comment>
                <comment line="2636">
                    some maps don&apos;t support this operation.
                     In this case just give up and remove the entry.                    
                </comment>
                <comment line="2646">
                    Deferred initialization of composites shouldn&apos;t be
                     a problem for this case, since a font must have been
                     initialised to be discovered to be bad.
                     Some JRE composites on Solaris use two versions of the same
                     font. The replaced font isn&apos;t bad, just &quot;smaller&quot; so there&apos;s
                     no need to make the slot point to the new font.
                     Since composites have a direct reference to the Font2D (not
                     via a handle) making this substitution is not safe and could
                     cause an additional problem and so this substitution is
                     warranted only when a font is truly &quot;bad&quot; and could cause
                     a crash. So we now replace it only if its being substituted
                     with some font other than a fontconfig rank font
                     Since in practice a substitution will have the same rank
                     this may never happen, but the code is safer even if its
                     also now a no-op.
                     The only obvious &quot;glitch&quot; from this stems from the current
                     implementation that when asked for the number of glyphs in a
                     composite it lies and returns the number in slot 0 because
                     composite glyphs aren&apos;t contiguous. Since we live with that
                     we can live with the glitch that depending on how it was
                     initialised a composite may return different values for this.
                     Fixing the issues with composite glyph ids is tricky as
                     there are exclusion ranges and unlike other fonts even the
                     true &quot;numGlyphs&quot; isn&apos;t a contiguous range. Likely the only
                     solution is an API that returns an array of glyph ranges
                     which takes precedence over the existing API. That might
                     also need to address excluding ranges which represent a
                     code point supported by an earlier component.                    
                </comment>
                <scope line="2585"/>
                <scope line="2593">
                    <scope line="2594"/>
                    <declaration name="physFonts" type="PhysicalFont[]" line="2598"/>
                    <scope line="2599">
                        <scope line="2600"/>
                    </scope>
                    <scope line="2605">
                        <scope line="2606"/>
                    </scope>
                </scope>
                <scope line="2623">
                    <declaration name="mapEntries" type="Map.Entry[]" line="2624"/>
                    <scope line="2630">
                        <scope line="2631">
                            <scope line="2632"/>
                            <scope line="2634"/>
                        </scope>
                    </scope>
                </scope>
                <scope line="2644">
                    <scope line="2674"/>
                </scope>
            </method>
            <method name="loadLocaleNames" type="void" line="2680">
                <scope line="2681"/>
                <declaration name="fonts" type="Font2D[]" line="2685"/>
                <scope line="2686">
                    <scope line="2687">
                        <declaration name="ttf" type="TrueTypeFont" line="2688"/>
                        <declaration name="fullNames" type="String[]" line="2689"/>
                        <scope line="2690"/>
                        <declaration name="family" type="FontFamily" line="2693"/>
                        <scope line="2694"/>
                    </scope>
                </scope>
            </method>
            <method name="findFont2DAllLocales" type="Font2D" line="2708">
                <params>
                    <param name="name" type="String"/>
                    <param name="style" type="int"/>
                </params>
                <comment line="2716">
                    If reach here and no match has been located, then if we have
                     not yet built the map of localeFullNamesToFont for TT fonts, do so
                     now. This method must be called after all fonts have been loaded.                    
                </comment>
                <comment line="2726">
                                        
                </comment>
                <comment line="2738">
                                        
                </comment>
                <comment line="2749">
                                        
                </comment>
                <comment line="2755">
                    The next check is perhaps one
                     that shouldn&apos;t be done. ie if we get this
                     far we have probably as close a match as we
                     are going to get. We could load all fonts to
                     see if somehow some parts of the family are
                     loaded but not all of it.
                     This check is commented out for now.                    
                </comment>
                <scope line="2710"/>
                <scope line="2719"/>
                <declaration name="lowerCaseName" type="String" line="2722"/>
                <declaration name="font" type="Font2D" line="2723"/>
                <declaration name="family" type="FontFamily" line="2726"/>
                <scope line="2727">
                    <scope line="2729"/>
                    <scope line="2732"/>
                </scope>
                <scope line="2738"/>
                <scope line="2741">
                    <scope line="2742"/>
                    <scope line="2744">
                        <scope line="2746">
                            <declaration name="familyFont" type="Font2D" line="2747"/>
                            <scope line="2749"/>
                            <scope line="2751">
                                <scope line="2753">
                                    <scope line="2762"/>
                                </scope>
                            </scope>
                        </scope>
                    </scope>
                </scope>
            </method>
            <declaration name="altJAFontKey" type="Object" line="2823"/>
            <declaration name="localeFontKey" type="Object" line="2824"/>
            <declaration name="proportionalFontKey" type="Object" line="2825"/>
            <declaration name="_usingPerAppContextComposites" type="boolean" line="2826"/>
            <declaration name="_usingAlternateComposites" type="boolean" line="2827"/>
            <declaration name="gAltJAFont" type="boolean" line="2832"/>
            <declaration name="gLocalePref" type="boolean" line="2833"/>
            <declaration name="gPropPref" type="boolean" line="2834"/>
            <method name="maybeUsingAlternateCompositeFonts" type="boolean" line="2849"/>
            <method name="usingAlternateCompositeFonts" type="boolean" line="2853"/>
            <method name="maybeMultiAppContext" type="boolean" line="2859">
                <anonymous_class line="2862">
                    <method name="run" type="Object" line="2863">
                        <declaration name="sm" type="SecurityManager" line="2864"/>
                    </method>
                </anonymous_class>
                <declaration name="appletSM" type="Boolean" line="2860"/>
            </method>
            <method name="useAlternateFontforJALocales" type="void" line="2876">
                <scope line="2877"/>
                <scope line="2881"/>
                <scope line="2885"/>
                <scope line="2887">
                    <declaration name="appContext" type="AppContext" line="2888"/>
                </scope>
            </method>
            <method name="usingAlternateFontforJALocales" type="boolean" line="2893">
                <scope line="2894"/>
                <scope line="2896">
                    <declaration name="appContext" type="AppContext" line="2897"/>
                </scope>
            </method>
            <method name="preferLocaleFonts" type="void" line="2902">
                <comment line="2907">
                                        
                </comment>
                <comment line="2929">
                                        
                </comment>
                <scope line="2903"/>
                <scope line="2907"/>
                <scope line="2911">
                    <scope line="2912"/>
                </scope>
                <scope line="2918">
                    <declaration name="appContext" type="AppContext" line="2919"/>
                    <scope line="2920"/>
                    <declaration name="acPropPref" type="boolean" line="2924"/>
                    <declaration name="altNameCache" type="ConcurrentHashMap&lt;String,Font2D&gt;" line="2926"/>
                </scope>
            </method>
            <method name="preferProportionalFonts" type="void" line="2935">
                <comment line="2941">
                    If no proportional fonts are configured, there&apos;s no need
                     to take any action.                    
                </comment>
                <comment line="2965">
                                        
                </comment>
                <scope line="2936"/>
                <scope line="2943"/>
                <scope line="2947">
                    <scope line="2948"/>
                </scope>
                <scope line="2954">
                    <declaration name="appContext" type="AppContext" line="2955"/>
                    <scope line="2956"/>
                    <declaration name="acLocalePref" type="boolean" line="2960"/>
                    <declaration name="altNameCache" type="ConcurrentHashMap&lt;String,Font2D&gt;" line="2962"/>
                </scope>
            </method>
            <declaration name="installedNames" type="HashSet&lt;String&gt;" line="2971"/>
            <method name="getInstalledNames" type="HashSet<String>" line="2972">
                <scope line="2973">
                    <declaration name="l" type="Locale" line="2974"/>
                    <declaration name="fontManager" type="SunFontManager" line="2975"/>
                    <declaration name="installedFamilies" type="String[]" line="2976"/>
                    <declaration name="installedFonts" type="Font[]" line="2978"/>
                    <declaration name="names" type="HashSet&lt;String&gt;" line="2979"/>
                    <scope line="2980"/>
                    <scope line="2983"/>
                </scope>
            </method>
            <declaration name="regFamilyKey" type="Object" line="2992"/>
            <declaration name="regFullNameKey" type="Object" line="2993"/>
            <declaration name="createdByFamilyName" type="Hashtable&lt;String,FontFamily&gt;" line="2994"/>
            <declaration name="createdByFullName" type="Hashtable&lt;String,Font2D&gt;" line="2995"/>
            <declaration name="fontsAreRegistered" type="boolean" line="2996"/>
            <declaration name="fontsAreRegisteredPerAppContext" type="boolean" line="2997"/>
            <method name="registerFont" type="boolean" line="2999">
                <params>
                    <param name="font" type="Font"/>
                </params>
                <comment line="3001">
                    This method should not be called with &quot;null&quot;.
                     It is the caller&apos;s responsibility to ensure that.                    
                </comment>
                <comment line="3008">
                                        
                </comment>
                <comment line="3019">
                    We want to ensure that this font cannot override existing
                     installed fonts. Check these conditions :
                     - family name is not that of an installed font
                     - full name is not that of an installed font
                     - family name is not the same as the full name of an installed font
                     - full name is not the same as the family name of an installed font
                     The last two of these may initially look odd but the reason is
                     that (unfortunately) Font constructors do not distinuguish these.
                     An extreme example of such a problem would be a font which has
                     family name &quot;Dialog.Plain&quot; and full name of &quot;Dialog&quot;.
                     The one arguably overly stringent restriction here is that if an
                     application wants to supply a new member of an existing family
                     It will get rejected. But since the JRE can perform synthetic
                     styling in many cases its not necessary.
                     We don&apos;t apply the same logic to registered fonts. If apps want
                     to do this lets assume they have a reason. It won&apos;t cause problems
                     except for themselves.                    
                </comment>
                <comment line="3045">
                                        
                </comment>
                <comment line="3066">
                                        
                </comment>
                <comment line="3074">
                    Remove name cache entries if not using app contexts.
                     To accommodate a case where code may have registered first a plain
                     family member and then used it and is now registering a bold family
                     member, we need to remove all members of the family, so that the
                     new style can get picked up rather than continuing to synthesise.                    
                </comment>
                <scope line="3003"/>
                <scope line="3008">
                    <scope line="3009"/>
                </scope>
                <scope line="3015"/>
                <declaration name="names" type="HashSet&lt;String&gt;" line="3036"/>
                <declaration name="l" type="Locale" line="3037"/>
                <declaration name="familyName" type="String" line="3038"/>
                <declaration name="fullName" type="String" line="3039"/>
                <scope line="3040"/>
                <declaration name="familyTable" type="Hashtable&lt;String,FontFamily&gt;" line="3045"/>
                <declaration name="fullNameTable" type="Hashtable&lt;String,Font2D&gt;" line="3046"/>
                <scope line="3047"/>
                <scope line="3051">
                    <declaration name="appContext" type="AppContext" line="3052"/>
                    <scope line="3057"/>
                </scope>
                <declaration name="font2D" type="Font2D" line="3066"/>
                <declaration name="style" type="int" line="3067"/>
                <declaration name="family" type="FontFamily" line="3068"/>
                <scope line="3069"/>
                <scope line="3079"/>
            </method>
            <method name="removeFromCache" type="void" line="3092">
                <params>
                    <param name="font" type="Font2D"/>
                </params>
                <scope line="3093"/>
                <declaration name="keys" type="String[]" line="3096"/>
                <scope line="3097">
                    <scope line="3098"/>
                </scope>
            </method>
            <method name="getCreatedFontFamilyNames" type="TreeMap<String,String>" line="3105">
                <declaration name="familyTable" type="Hashtable&lt;String,FontFamily&gt;" line="3107"/>
                <scope line="3108"/>
                <scope line="3110">
                    <declaration name="appContext" type="AppContext" line="3111"/>
                </scope>
                <scope line="3114"/>
                <declaration name="l" type="Locale" line="3118"/>
                <scope line="3119">
                    <declaration name="map" type="TreeMap&lt;String,String&gt;" line="3120"/>
                    <scope line="3121">
                        <declaration name="font2D" type="Font2D" line="3122"/>
                        <scope line="3123"/>
                        <declaration name="name" type="String" line="3126"/>
                    </scope>
                </scope>
            </method>
            <method name="getCreatedFonts" type="Font[]" line="3133">
                <declaration name="nameTable" type="Hashtable&lt;String,Font2D&gt;" line="3135"/>
                <scope line="3136"/>
                <scope line="3138">
                    <declaration name="appContext" type="AppContext" line="3139"/>
                </scope>
                <scope line="3142"/>
                <declaration name="l" type="Locale" line="3146"/>
                <scope line="3147">
                    <declaration name="fonts" type="Font[]" line="3148"/>
                    <declaration name="i" type="int" line="3149"/>
                    <scope line="3150"/>
                </scope>
            </method>
            <method name="getPlatformFontDirs" type="String[]" line="3158">
                <params>
                    <param name="noType1Fonts" type="boolean"/>
                </params>
                <comment line="3161">
                                        
                </comment>
                <scope line="3161"/>
                <declaration name="path" type="String" line="3165"/>
                <declaration name="parser" type="StringTokenizer" line="3166"/>
                <declaration name="pathList" type="ArrayList&lt;String&gt;" line="3168"/>
                <scope line="3169">
                    <scope line="3170"/>
                </scope>
                <scope line="3173"/>
            </method>
            <method name="getDefaultPlatformFont" type="String[]" line="3179"/>
            <javadoc line="3179">
                Returns an array of two strings. The first element is the
                  name of the font. The second element is the file name.                
            </javadoc>
            <method name="addDirFonts" type="void" line="3194">
                <params>
                    <param name="dirName" type="String"/>
                    <param name="dirFile" type="File"/>
                    <param name="filter" type="FilenameFilter"/>
                    <param name="fontFormat" type="int"/>
                    <param name="useJavaRasterizer" type="boolean"/>
                    <param name="fontRank" type="int"/>
                    <param name="defer" type="boolean"/>
                    <param name="resolveSymLinks" type="boolean"/>
                </params>
                <comment line="3217">
                    REMIND: case compare depends on platform                    
                </comment>
                <comment line="3227">
                    skip this font file.                    
                </comment>
                <declaration name="ls" type="String[]" line="3195"/>
                <scope line="3196"/>
                <declaration name="fontNames" type="String[]" line="3199"/>
                <declaration name="nativeNames" type="String[][]" line="3200"/>
                <declaration name="fontCount" type="int" line="3201"/>
                <scope line="3203">
                    <declaration name="theFile" type="File" line="3204"/>
                    <declaration name="fullName" type="String" line="3205"/>
                    <scope line="3206">
                        <scope line="3207"/>
                        <scope line="3209"/>
                    </scope>
                    <scope line="3212"/>
                    <scope line="3217"/>
                    <scope line="3221">
                        <scope line="3222"/>
                    </scope>
                    <scope line="3232">
                        <declaration name="message" type="String" line="3233"/>
                        <declaration name="natNames" type="String[]" line="3234"/>
                        <scope line="3235"/>
                        <scope line="3237">
                            <scope line="3239"/>
                        </scope>
                    </scope>
                </scope>
            </method>
            <method name="getNativeNames" type="String[]" line="3254">
                <params>
                    <param name="fontFileName" type="String"/>
                    <param name="platformName" type="String"/>
                </params>
            </method>
            <javadoc line="3258">
                Returns a file name for the physical font represented by this platform
                  font name. The default implementation tries to obtain the file name
                  from the font configuration.
                  Subclasses may override to provide information from other sources.                
            </javadoc>
            <method name="getFileNameFromPlatformName" type="String" line="3264">
                <params>
                    <param name="platformFontName" type="String"/>
                </params>
            </method>
            <javadoc line="3268">
                Return the default font configuration.                
            </javadoc>
            <method name="getFontConfiguration" type="FontConfiguration" line="3271"/>
            <method name="getPlatformFontPath" type="String" line="3278">
                <params>
                    <param name="noType1Font" type="boolean"/>
                </params>
                <scope line="3279"/>
            </method>
            <method name="isOpenJDK" type="boolean" line="3285"/>
            <method name="loadFonts" type="void" line="3289">
                <comment line="3294">
                                        
                </comment>
                <comment line="3311">
                    this will find all fonts including those already
                     registered. But we have checks in place to prevent
                     double registration.                    
                </comment>
                <scope line="3290"/>
                <scope line="3294">
                    <scope line="3295"/>
                    <anonymous_class line="3303">
                        <method name="run" type="Object" line="3304">
                            <comment line="3311">
                                this will find all fonts including those already
                                 registered. But we have checks in place to prevent
                                 double registration.                                
                            </comment>
                            <scope line="3305"/>
                            <scope line="3309">
                                <scope line="3313"/>
                            </scope>
                        </method>
                    </anonymous_class>
                </scope>
            </method>
            <method name="registerFontDirs" type="void" line="3328">
                <params>
                    <param name="pathName" type="String"/>
                </params>
            </method>
            <method name="registerFontsOnPath" type="void" line="3334">
                <params>
                    <param name="pathName" type="String"/>
                    <param name="useJavaRasterizer" type="boolean"/>
                    <param name="fontRank" type="int"/>
                    <param name="defer" type="boolean"/>
                    <param name="resolveSymLinks" type="boolean"/>
                </params>
                <declaration name="parser" type="StringTokenizer" line="3336"/>
                <scope line="3338">
                    <scope line="3339"/>
                </scope>
                <scope line="3344"/>
            </method>
            <method name="registerFontsInDir" type="void" line="3349">
                <params>
                    <param name="dirName" type="String"/>
                </params>
            </method>
            <method name="registerFontsInDir" type="void" line="3355">
                <params>
                    <param name="dirName" type="String"/>
                    <param name="useJavaRasterizer" type="boolean"/>
                    <param name="fontRank" type="int"/>
                    <param name="defer" type="boolean"/>
                    <param name="resolveSymLinks" type="boolean"/>
                </params>
                <declaration name="pathFile" type="File" line="3356"/>
            </method>
            <method name="registerFontDir" type="void" line="3369">
                <params>
                    <param name="path" type="String"/>
                </params>
            </method>
            <javadoc line="3372">
                Returns file name for default font, either absolute
                  or relative as needed by registerFontFile.                
            </javadoc>
            <method name="getDefaultFontFile" type="String" line="3376">
                <scope line="3377"/>
            </method>
            <method name="initDefaultFonts" type="void" line="3383">
                <scope line="3384">
                    <scope line="3386"/>
                    <scope line="3389"/>
                </scope>
            </method>
            <javadoc line="3395">
                Whether registerFontFile expects absolute or relative
                  font file names.                
            </javadoc>
            <method name="useAbsoluteFontFileNames" type="boolean" line="3399"/>
            <method name="createFontConfiguration" type="FontConfiguration" line="3403"/>
            <javadoc line="3403">
                Creates this environment&apos;s FontConfiguration.                
            </javadoc>
            <method name="createFontConfiguration" type="FontConfiguration" line="3408"/>
            <javadoc line="3412">
                Returns face name for default font, or null if
                  no face names are used for CompositeFontDescriptors
                  for this platform.                
            </javadoc>
            <method name="getDefaultFontFaceName" type="String" line="3417">
                <scope line="3418"/>
            </method>
            <method name="loadFontFiles" type="void" line="3424">
                <comment line="3430">
                                        
                </comment>
                <comment line="3443">
                    this will find all fonts including those already
                     registered. But we have checks in place to prevent
                     double registration.                    
                </comment>
                <scope line="3426"/>
                <scope line="3430">
                    <scope line="3431"/>
                    <anonymous_class line="3436">
                        <method name="run" type="Object" line="3437">
                            <comment line="3443">
                                this will find all fonts including those already
                                 registered. But we have checks in place to prevent
                                 double registration.                                
                            </comment>
                            <scope line="3438"/>
                            <scope line="3441"/>
                        </method>
                    </anonymous_class>
                </scope>
            </method>
            <method name="initCompositeFonts" type="void" line="3465">
                <params>
                    <param name="fontConfig" type="FontConfiguration"/>
                    <param name="altNameCache" type="ConcurrentHashMap<String,Font2D>"/>
                </params>
                <comment line="3482">
                    No file located, so register using the platform name,
                     i.e. as a native font.                    
                </comment>
                <comment line="3488">
                    If platform APIs also need to access the font, add it
                     to a set to be registered with the platform too.
                     This may be used to add the parent directory to the X11
                     font path if its not already there. See the docs for the
                     subclass implementation.
                     This is now mainly for the benefit of X11-based AWT
                     But for historical reasons, 2D initialisation code
                     makes these calls.
                     If the fontconfiguration file is properly set up
                     so that all fonts are mapped to files and all their
                     appropriate directories are specified, then this
                     method will be low cost as it will return after
                     a test that finds a null lookup map.                    
                </comment>
                <comment line="3506">
                    Uncomment these two lines to &quot;generate&quot; the XLFD-&gt;filename
                     mappings needed to speed start-up on Solaris.
                     Augment this with the appendedpathname and the mappings
                     for native (F3) fonts                    
                </comment>
                <comment line="3511">
                    String platName = platformFontName.replaceAll(&quot; &quot;, &quot;_&quot;);
                    System.out.println(&quot;filename.&quot;+platName+&quot;=&quot;+fontFileName);                    
                </comment>
                <comment line="3518">
                    This registers accumulated paths from the calls to
                     addFontToPlatformFontPath(..) and any specified by
                     the font configuration. Rather than registering
                     the fonts it puts them in a place and form suitable for
                     the Toolkit to pick up and use if a toolkit is initialised,
                     and if it uses X11 fonts.                    
                </comment>
                <comment line="3534">
                    It would be better eventually to handle this in the
                     FontConfiguration code which should also remove duplicate slots                    
                </comment>
                <comment line="3546">
                    FontConfiguration needs to convey how many fonts it has added
                     as fallback component fonts which should not affect metrics.
                     The core component count will be the number of metrics slots.
                     This does not preclude other mechanisms for adding
                     fall back component fonts to the composite.                    
                </comment>
                <scope line="3467"/>
                <declaration name="numCoreFonts" type="int" line="3472"/>
                <declaration name="fcFonts" type="String[]" line="3473"/>
                <scope line="3474">
                    <declaration name="platformFontName" type="String" line="3475"/>
                    <declaration name="fontFileName" type="String" line="3476"/>
                    <declaration name="nativeNames" type="String[]" line="3478"/>
                    <scope line="3480"/>
                    <scope line="3485">
                        <scope line="3486"/>
                    </scope>
                </scope>
                <declaration name="compositeFontInfo" type="CompositeFontDescriptor[]" line="3526"/>
                <scope line="3528">
                    <declaration name="descriptor" type="CompositeFontDescriptor" line="3529"/>
                    <declaration name="componentFileNames" type="String[]" line="3530"/>
                    <declaration name="componentFaceNames" type="String[]" line="3531"/>
                    <scope line="3536">
                        <scope line="3537">
                            <scope line="3538"/>
                        </scope>
                    </scope>
                    <scope line="3551"/>
                    <scope line="3560"/>
                    <scope line="3568"/>
                </scope>
            </method>
            <javadoc line="3575">
                Notifies graphics environment that the logical font configuration
                  uses the given platform font name. The graphics environment may
                  use this for platform specific initialization.                
            </javadoc>
            <method name="addFontToPlatformFontPath" type="void" line="3580">
                <params>
                    <param name="platformFontName" type="String"/>
                </params>
            </method>
            <method name="registerFontFile" type="void" line="3584">
                <params>
                    <param name="fontFileName" type="String"/>
                    <param name="nativeNames" type="String[]"/>
                    <param name="fontRank" type="int"/>
                    <param name="defer" type="boolean"/>
                </params>
                <comment line="3586">
                    REMIND: case compare depends on platform                    
                </comment>
                <scope line="3586"/>
                <declaration name="fontFormat" type="int" line="3589"/>
                <scope line="3590"/>
                <scope line="3592"/>
                <scope line="3594"/>
                <scope line="3598"/>
                <scope line="3601"/>
            </method>
            <method name="registerPlatformFontsUsedByFontConfiguration" type="void" line="3607"/>
            <method name="addToMissingFontFileList" type="void" line="3624">
                <params>
                    <param name="fileName" type="String"/>
                </params>
                <scope line="3625"/>
            </method>
            <method name="isNameForRegisteredFile" type="boolean" line="3649">
                <params>
                    <param name="fontName" type="String"/>
                </params>
                <declaration name="fileName" type="String" line="3650"/>
                <scope line="3651"/>
            </method>
            <method name="createCompositeFonts" type="void" line="3665">
                <params>
                    <param name="altNameCache" type="ConcurrentHashMap<String,Font2D>"/>
                    <param name="preferLocale" type="boolean"/>
                    <param name="preferProportional" type="boolean"/>
                </params>
                <declaration name="fontConfig" type="FontConfiguration" line="3667"/>
            </method>
            <javadoc line="3672">
                Returns all fonts installed in this environment.                
            </javadoc>
            <method name="getAllInstalledFonts" type="Font[]" line="3675">
                <comment line="3680">
                    warning: the number of composite fonts could change dynamically
                     if applications are allowed to create them. &quot;allfonts&quot; could
                     then be stale.                    
                </comment>
                <scope line="3676">
                    <declaration name="fontMapNames" type="TreeMap" line="3678"/>
                    <declaration name="allfonts" type="Font2D[]" line="3683"/>
                    <scope line="3684">
                        <scope line="3685"/>
                    </scope>
                    <declaration name="platformNames" type="String[]" line="3691"/>
                    <scope line="3692">
                        <scope line="3693">
                            <scope line="3694"/>
                        </scope>
                    </scope>
                    <declaration name="fontNames" type="String[]" line="3700"/>
                    <scope line="3701">
                        <declaration name="keyNames" type="Object[]" line="3703"/>
                        <scope line="3704"/>
                    </scope>
                    <declaration name="fonts" type="Font[]" line="3708"/>
                    <scope line="3709">
                        <declaration name="f2d" type="Font2D" line="3711"/>
                        <scope line="3712"/>
                    </scope>
                </scope>
                <declaration name="copyFonts" type="Font[]" line="3719"/>
            </method>
            <javadoc line="3724">
                Get a list of installed fonts in the requested {@link Locale}.
                  The list contains the fonts Family Names.
                  If Locale is null, the default locale is used.                
                <param>
                    requestedLocale, if null the default locale is used.                    
                </param>
                <return>
                    list of installed fonts in the system.                    
                </return>
            </javadoc>
            <method name="getInstalledFontFamilyNames" type="String[]" line="3732">
                <params>
                    <param name="requestedLocale" type="Locale"/>
                </params>
                <comment line="3746">
                    these names are always there and aren&apos;t localised                    
                </comment>
                <comment line="3754">
                    Platform APIs may be used to get the set of available family
                     names for the current default locale so long as it is the same
                     as the start-up system locale, rather than loading all fonts.                    
                </comment>
                <comment line="3760">
                                        
                </comment>
                <scope line="3733"/>
                <scope line="3737">
                    <declaration name="copyFamilies" type="String[]" line="3738"/>
                </scope>
                <declaration name="familyNames" type="TreeMap&lt;String,String&gt;" line="3744"/>
                <declaration name="str" type="String" line="3746"/>
                <scope line="3758"/>
                <scope line="3761">
                    <declaration name="physicalfonts" type="Font2D[]" line="3763"/>
                    <scope line="3764">
                        <scope line="3765">
                            <declaration name="name" type="String" line="3766"/>
                        </scope>
                    </scope>
                </scope>
                <declaration name="retval" type="String[]" line="3773"/>
                <declaration name="keyNames" type="Object[]" line="3774"/>
                <scope line="3775"/>
                <scope line="3778"/>
            </method>
            <method name="register1dot0Fonts" type="void" line="3786">
                <anonymous_class line="3788">
                    <method name="run" type="Object" line="3789">
                        <declaration name="type1Dir" type="String" line="3790"/>
                    </method>
                </anonymous_class>
            </method>
            <method name="getJREFontFamilyNames" type="void" line="3803">
                <params>
                    <param name="familyNames" type="TreeMap<String,String>"/>
                    <param name="requestedLocale" type="Locale"/>
                </params>
                <declaration name="physicalfonts" type="Font2D[]" line="3805"/>
                <scope line="3806">
                    <scope line="3807">
                        <declaration name="name" type="String" line="3808"/>
                    </scope>
                </scope>
            </method>
            <declaration name="systemLocale" type="Locale" line="3815"/>
            <javadoc line="3815">
                Default locale can be changed but we need to know the initial locale
                  as that is what is used by native code. Changing Java default locale
                  doesn&apos;t affect that.
                  Returns the locale in use when using native code to communicate
                  with platform APIs. On windows this is known as the &quot;system&quot; locale,
                  and it is usually the same as the platform locale, but not always,
                  so this method also checks an implementation property used only
                  on windows and uses that if set.                
            </javadoc>
            <method name="getSystemStartupLocale" type="Locale" line="3826">
                <comment line="3833">
                    On windows the system locale may be different than the
                     user locale. This is an unsupported configuration, but
                     in that case we want to return a dummy locale that will
                     never cause a match in the usage of this API. This is
                     important because Windows documents that the family
                     names of fonts are enumerated using the language of
                     the system locale. BY returning a dummy locale in that
                     case we do not use the platform API which would not
                     return us the names we want.                    
                </comment>
                <scope line="3827">
                    <anonymous_class line="3830">
                        <method name="run" type="Object" line="3831">
                            <comment line="3833">
                                On windows the system locale may be different than the
                                 user locale. This is an unsupported configuration, but
                                 in that case we want to return a dummy locale that will
                                 never cause a match in the usage of this API. This is
                                 important because Windows documents that the family
                                 names of fonts are enumerated using the language of
                                 the system locale. BY returning a dummy locale in that
                                 case we do not use the platform API which would not
                                 return us the names we want.                                
                            </comment>
                            <declaration name="fileEncoding" type="String" line="3842"/>
                            <declaration name="sysEncoding" type="String" line="3843"/>
                            <scope line="3844"/>
                            <declaration name="language" type="String" line="3848"/>
                            <declaration name="country" type="String" line="3849"/>
                            <declaration name="variant" type="String" line="3850"/>
                        </method>
                    </anonymous_class>
                </scope>
            </method>
            <method name="addToPool" type="void" line="3858">
                <params>
                    <param name="font" type="FileFont"/>
                </params>
                <comment line="3865">
                    Avoid duplicate entries in the pool, and don&apos;t close() it,
                     since this method is called only from within open().
                     Seeing a duplicate is most likely to happen if the thread
                     was interrupted during a read, forcing perhaps repeated
                     close and open calls and it eventually it ends up pointing
                     at the same slot.                    
                </comment>
                <comment line="3884">
                                        
                </comment>
                <comment line="3887">
                    lastPoolIndex is updated so that the least recently opened
                     file will be closed next.                    
                </comment>
                <comment line="3893">
                    Need to close the font file outside of the synchronized block,
                     since its possible some other thread is in an open() call on
                     this font file, and could be holding its lock and the pool lock.
                     Releasing the pool lock allows that thread to continue, so it can
                     then release the lock on this font, allowing the close() call
                     below to proceed.
                     Also, calling close() is safe because any other thread using
                     the font we are closing() synchronizes all reading, so we
                     will not close the file while its in use.                    
                </comment>
                <declaration name="fontFileToClose" type="FileFont" line="3860"/>
                <declaration name="freeSlot" type="int" line="3861"/>
                <scope line="3863">
                    <scope line="3871">
                        <scope line="3872"/>
                        <scope line="3875"/>
                    </scope>
                    <scope line="3879"/>
                    <scope line="3882"/>
                </scope>
                <scope line="3902"/>
            </method>
            <method name="getFontConfigFUIR" type="FontUIResource" line="3909">
                <params>
                    <param name="family" type="String"/>
                    <param name="style" type="int"/>
                    <param name="size" type="int"/>
                </params>
            </method>
        </class>
    </source>