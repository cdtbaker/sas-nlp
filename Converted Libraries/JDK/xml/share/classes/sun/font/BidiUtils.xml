<?xml version="1.0" encoding="UTF-8"?>
    <source package="sun.font">
        <import package="java.text.Bidi"/>
        <class name="BidiUtils" line="40">
            <javadoc line="44">
                Return the level of each character into the levels array starting at start.
                  This is a convenience method for clients who prefer to use an explicit levels
                  array instead of iterating over the runs.                
                <param>
                    levels the array to receive the character levels                    
                </param>
                <param>
                    start the starting offset into the the array                    
                </param>
                <throws>
                    IndexOutOfBoundsException if <code>start</code> is less than 0 or
                      <code>start + getLength()</code> is greater than <code>levels.length</code>.                    
                </throws>
            </javadoc>
            <method name="getLevels" type="void" line="54">
                <params>
                    <param name="bidi" type="Bidi"/>
                    <param name="levels" type="byte[]"/>
                    <param name="start" type="int"/>
                </params>
                <declaration name="limit" type="int" line="55"/>
                <scope line="57"/>
                <declaration name="runCount" type="int" line="62"/>
                <declaration name="p" type="int" line="63"/>
                <scope line="64">
                    <declaration name="rlimit" type="int" line="65"/>
                    <declaration name="rlevel" type="byte" line="66"/>
                    <scope line="68"/>
                </scope>
            </method>
            <javadoc line="74">
                Return an array containing the resolved bidi level of each character, in logical order.                
                <return>
                    an array containing the level of each character, in logical order.                    
                </return>
            </javadoc>
            <method name="getLevels" type="byte[]" line="78">
                <params>
                    <param name="bidi" type="Bidi"/>
                </params>
                <declaration name="levels" type="byte[]" line="79"/>
            </method>
            <declaration name="NUMLEVELS" type="char" line="84"/>
            <javadoc line="86">
                Given level data, compute a a visual to logical mapping.
                  The leftmost (or topmost) character is at visual index zero.  The
                  logical index of the character is derived from the visual index
                  by the expression &lt;code&gt;li = map[vi];&lt;/code&gt;.                
                <param>
                    levels the levels array                    
                </param>
                <return>
                    the mapping array from visual to logical                    
                </return>
            </javadoc>
            <method name="createVisualToLogicalMap" type="int[]" line="94">
                <params>
                    <param name="levels" type="byte[]"/>
                </params>
                <comment line="101">
                    initialize mapping and levels                    
                </comment>
                <comment line="125">
                    no more runs at this level                    
                </comment>
                <declaration name="len" type="int" line="95"/>
                <declaration name="mapping" type="int[]" line="96"/>
                <declaration name="lowestOddLevel" type="byte" line="98"/>
                <declaration name="highestLevel" type="byte" line="99"/>
                <scope line="103">
                    <declaration name="level" type="byte" line="106"/>
                    <scope line="107"/>
                    <scope line="111"/>
                </scope>
                <scope line="116">
                    <declaration name="i" type="int" line="117"/>
                    <scope line="118">
                        <scope line="119"/>
                        <declaration name="begin" type="int" line="122"/>
                        <scope line="124"/>
                        <scope line="128"/>
                        <declaration name="end" type="int" line="131"/>
                        <scope line="133">
                            <declaration name="temp" type="int" line="134"/>
                        </scope>
                    </scope>
                </scope>
            </method>
            <javadoc line="148">
                Return the inverse position map.  The source array must map one-to-one (each value
                  is distinct and the values run from zero to the length of the array minus one).
                  For example, if &lt;code&gt;values[i] = j&lt;/code&gt;, then &lt;code&gt;inverse[j] = i&lt;/code&gt;.                
                <param>
                    values the source ordering array                    
                </param>
                <return>
                    the inverse array                    
                </return>
            </javadoc>
            <method name="createInverseMap" type="int[]" line="155">
                <params>
                    <param name="values" type="int[]"/>
                </params>
                <scope line="156"/>
                <declaration name="result" type="int[]" line="160"/>
                <scope line="161"/>
            </method>
            <javadoc line="169">
                Return an array containing contiguous values from 0 to length
                  having the same ordering as the source array. If this would be
                  a canonical ltr ordering, return null.  The data in values[] is NOT
                  required to be a permutation, but elements in values are required
                  to be distinct.                
                <param>
                    values an array containing the discontiguous values                    
                </param>
                <return>
                    the contiguous values                    
                </return>
            </javadoc>
            <method name="createContiguousOrder" type="int[]" line="178">
                <params>
                    <param name="values" type="int[]"/>
                </params>
                <scope line="179"/>
            </method>
            <javadoc line="186">
                Compute a contiguous order for the range start, limit.                
            </javadoc>
            <method name="computeContiguousOrder" type="int[]" line="190">
                <params>
                    <param name="values" type="int[]"/>
                    <param name="start" type="int"/>
                    <param name="limit" type="int"/>
                </params>
                <comment line="197">
                    now we&apos;ll sort result[], with the following comparison:                    
                </comment>
                <comment line="198">
                    result[i] lessthan result[j] iff values[result[i]] &lt; values[result[j]]                    
                </comment>
                <comment line="200">
                    selection sort for now;  use more elaborate sorts if desired                    
                </comment>
                <comment line="215">
                    shift result by start:                    
                </comment>
                <comment line="222">
                    next, check for canonical order:                    
                </comment>
                <comment line="234">
                    now return inverse of result:                    
                </comment>
                <declaration name="result" type="int[]" line="192"/>
                <scope line="193"/>
                <scope line="201">
                    <declaration name="minIndex" type="int" line="202"/>
                    <declaration name="currentValue" type="int" line="203"/>
                    <scope line="204">
                        <scope line="205"/>
                    </scope>
                    <declaration name="temp" type="int" line="210"/>
                </scope>
                <scope line="216">
                    <scope line="217"/>
                </scope>
                <declaration name="k" type="int" line="223"/>
                <scope line="224">
                    <scope line="225"/>
                </scope>
                <scope line="230"/>
            </method>
            <javadoc line="238">
                Return an array containing the data in the values array from start up to limit,
                  normalized to fall within the range from 0 up to limit - start.
                  If this would be a canonical ltr ordering, return null.
                  NOTE: This method assumes that values[] is a logical to visual map
                  generated from levels[].                
                <param>
                    values the source mapping                    
                </param>
                <param>
                    levels the levels corresponding to the values                    
                </param>
                <param>
                    start the starting offset in the values and levels arrays                    
                </param>
                <param>
                    limit the limiting offset in the values and levels arrays                    
                </param>
                <return>
                    the normlized map                    
                </return>
            </javadoc>
            <method name="createNormalizedMap" type="int[]" line="251">
                <params>
                    <param name="values" type="int[]"/>
                    <param name="levels" type="byte[]"/>
                    <param name="start" type="int"/>
                    <param name="limit" type="int"/>
                </params>
                <comment line="255">
                    levels optimization                    
                </comment>
                <comment line="269">
                    scan for levels below primary                    
                </comment>
                <comment line="285">
                    these don&apos;t matter;  but the compiler cares:                    
                </comment>
                <scope line="253">
                    <scope line="254">
                        <declaration name="copyRange" type="boolean" line="256"/>
                        <declaration name="primaryLevel" type="byte" line="257"/>
                        <scope line="259"/>
                        <scope line="264">
                            <scope line="265">
                                <declaration name="i" type="int" line="270"/>
                                <scope line="271">
                                    <scope line="272"/>
                                    <scope line="275"/>
                                </scope>
                            </scope>
                            <scope line="282"/>
                        </scope>
                        <scope line="291">
                            <scope line="292"/>
                            <declaration name="result" type="int[]" line="296"/>
                            <declaration name="baseValue" type="int" line="297"/>
                            <scope line="299"/>
                            <scope line="301"/>
                            <scope line="305"/>
                            <scope line="308">
                                <scope line="309"/>
                            </scope>
                        </scope>
                        <scope line="316"/>
                    </scope>
                    <scope line="320"/>
                </scope>
            </method>
            <javadoc line="328">
                Reorder the objects in the array into visual order based on their levels.
                  This is a utility function to use when you have a collection of objects
                  representing runs of text in logical order, each run containing text
                  at a single level.  The elements in the objects array will be reordered
                  into visual order assuming each run of text has the level provided
                  by the corresponding element in the levels array.                
                <param>
                    levels an array representing the bidi level of each object                    
                </param>
                <param>
                    objects the array of objects to be reordered into visual order                    
                </param>
            </javadoc>
            <method name="reorderVisually" type="void" line="338">
                <params>
                    <param name="levels" type="byte[]"/>
                    <param name="objects" type="Object[]"/>
                </params>
                <comment line="344">
                    initialize mapping and levels                    
                </comment>
                <comment line="366">
                    no more runs at this level                    
                </comment>
                <declaration name="len" type="int" line="339"/>
                <declaration name="lowestOddLevel" type="byte" line="341"/>
                <declaration name="highestLevel" type="byte" line="342"/>
                <scope line="346">
                    <declaration name="level" type="byte" line="347"/>
                    <scope line="348"/>
                    <scope line="352"/>
                </scope>
                <scope line="357">
                    <declaration name="i" type="int" line="358"/>
                    <scope line="359">
                        <scope line="360"/>
                        <declaration name="begin" type="int" line="363"/>
                        <scope line="365"/>
                        <scope line="369"/>
                        <declaration name="end" type="int" line="372"/>
                        <scope line="374">
                            <declaration name="temp" type="Object" line="375"/>
                        </scope>
                    </scope>
                </scope>
            </method>
        </class>
    </source>