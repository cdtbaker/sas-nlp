<?xml version="1.0" encoding="UTF-8"?>
    <source package="sun.font">
        <import package="java.awt.Font"/>
        <import package="java.awt.FontFormatException"/>
        <import package="java.awt.GraphicsEnvironment"/>
        <import package="java.awt.geom.Point2D"/>
        <import package="java.io.FileNotFoundException"/>
        <import package="java.io.IOException"/>
        <import package="java.io.RandomAccessFile"/>
        <import package="java.io.UnsupportedEncodingException"/>
        <import package="java.nio.ByteBuffer"/>
        <import package="java.nio.CharBuffer"/>
        <import package="java.nio.IntBuffer"/>
        <import package="java.nio.ShortBuffer"/>
        <import package="java.nio.channels.ClosedChannelException"/>
        <import package="java.nio.channels.FileChannel"/>
        <import package="java.util.HashMap"/>
        <import package="java.util.HashSet"/>
        <import package="java.util.Map"/>
        <import package="java.util.Locale"/>
        <import package="sun.java2d.Disposer"/>
        <import package="sun.java2d.DisposerRecord"/>
        <class name="TrueTypeFont" line="49">
            <extends class="FileFont"/>
            <comment line="66">
                                
            </comment>
            <comment line="67">
                &apos;cmap&apos;                
            </comment>
            <comment line="68">
                &apos;glyf&apos;                
            </comment>
            <comment line="69">
                &apos;head&apos;                
            </comment>
            <comment line="70">
                &apos;hhea&apos;                
            </comment>
            <comment line="71">
                &apos;hmtx&apos;                
            </comment>
            <comment line="72">
                &apos;loca&apos;                
            </comment>
            <comment line="73">
                &apos;maxp&apos;                
            </comment>
            <comment line="74">
                &apos;name&apos;                
            </comment>
            <comment line="75">
                &apos;post&apos;                
            </comment>
            <comment line="76">
                &apos;OS/2&apos;                
            </comment>
            <comment line="78">
                                
            </comment>
            <comment line="79">
                &apos;GDEF&apos;                
            </comment>
            <comment line="80">
                &apos;GPOS&apos;                
            </comment>
            <comment line="81">
                &apos;GSUB&apos;                
            </comment>
            <comment line="82">
                &apos;mort&apos;                
            </comment>
            <comment line="84">
                                
            </comment>
            <comment line="85">
                &apos;fdsc&apos; - gxFont descriptor                
            </comment>
            <comment line="86">
                &apos;fvar&apos; - gxFont variations                
            </comment>
            <comment line="87">
                &apos;feat&apos; - layout features                
            </comment>
            <comment line="88">
                &apos;EBLC&apos; - embedded bitmaps                
            </comment>
            <comment line="89">
                &apos;gasp&apos; - hint/smooth sizes                
            </comment>
            <comment line="91">
                                
            </comment>
            <comment line="92">
                &apos;ttcf&apos; - TTC file                
            </comment>
            <comment line="93">
                &apos;v1tt&apos; - Version 1 TT font                
            </comment>
            <comment line="94">
                &apos;true&apos; - Version 2 TT font                
            </comment>
            <comment line="95">
                &apos;otto&apos; - OpenType font                
            </comment>
            <comment line="97">
                                
            </comment>
            <comment line="99">
                                
            </comment>
            <comment line="100">
                1033 decimal                
            </comment>
            <comment line="102">
                public static final int STYLE_WEIGHT_ID = 2; // currently unused.                
            </comment>
            <comment line="106">
                US English - default                
            </comment>
            <comment line="116">
                There is a pool which limits the number of fd&apos;s that are in
                 use. Normally fd&apos;s are closed as they are replaced in the pool.
                 But if an instance of this class becomes unreferenced, then there
                 needs to be a way to close the fd. A finalize() method could do this,
                 but using the Disposer class will ensure its called in a more timely
                 manner. This is not something which should be relied upon to free
                 fd&apos;s - its a safeguard.                
            </comment>
            <comment line="142">
                                
            </comment>
            <comment line="145">
                                
            </comment>
            <comment line="148">
                                
            </comment>
            <comment line="149">
                12 if its not a collection.                
            </comment>
            <comment line="151">
                                
            </comment>
            <comment line="154">
                                
            </comment>
            <comment line="157">
                protected byte []gposTable = null;
                     protected byte []gdefTable = null;
                     protected byte []gsubTable = null;
                     protected byte []mortTable = null;
                     protected boolean hintsTabledChecked = false;
                     protected boolean containsHintsTable = false;                
            </comment>
            <comment line="164">
                                
            </comment>
            <comment line="168">
                These are for faster access to the name of the font as
                 typically exposed via API to applications.                
            </comment>
            <comment line="204">
                Enable natives just for fonts picked up from the platform that
                 may have external bitmaps on Solaris. Could do this just for
                 the fonts that are specified in font configuration files which
                 would lighten the burden (think about that).
                 The EBLCTag is used to skip natives for fonts that contain embedded
                 bitmaps as there&apos;s no need to use X11 for those fonts.
                 Skip all the latin fonts as they don&apos;t need this treatment.
                 Further refine this to fonts that are natively accessible (ie
                 as PCF bitmap fonts on the X11 font path).
                 This method is called when creating the first strike for this font.                
            </comment>
            <comment line="279">
                This is intended to be called, and the returned value used,
                 from within a block synchronized on this font object.
                 ie the channel returned may be nulled out at any time by &quot;close()&quot;
                 unless the caller holds a lock.
                 Deadlock warning: FontManager.addToPool(..) acquires a global lock,
                 which means nested locks may be in effect.                
            </comment>
            <comment line="474">
                This is used by native code which can&apos;t allocate a direct byte
                 buffer because of bug 4845371. It, and references to it in native
                 code in scalerMethods.c can be removed once that bug is fixed.
                 4845371 is now fixed but we&apos;ll keep this around as it doesn&apos;t cost
                 us anything if its never usedcalled.                
            </comment>
            <comment line="495">
                                
            </comment>
            <comment line="574">
                The array index corresponds to a bit offset in the TrueType
                 font&apos;s OS2 compatibility table&apos;s code page ranges fields.
                 These are two 32 bit unsigned int fields at offsets 78 and 82.
                 We are only interested in determining if the font supports
                 the windows encodings we expect as the default encoding in
                 supported locales, so we only map the first of these fields.                
            </comment>
            <comment line="616">
                This maps two letter language codes to a Windows code page.
                 Note that eg Cp1252 (the first subarray) is not exactly the same as
                 Latin-1 since Windows code pages are do not necessarily correspond.
                 There are two codepages for zh and ko so if a font supports
                 only one of these ranges then we need to distinguish based on
                 country. So far this only seems to matter for zh.
                 REMIND: Unicode locales such as Hindi do not have a code page so
                 this whole mechansim needs to be revised to map languages to
                 the Unicode ranges either when this fails, or as an additional
                 validating test. Basing it on Unicode ranges should get us away
                 from needing to map to this small and incomplete set of Windows
                 code pages which looks odd on non-Windows platforms.                
            </comment>
            <comment line="734">
                                
            </comment>
            <comment line="789">
                                
            </comment>
            <comment line="863">
                                
            </comment>
            <comment line="915">
                Used to determine if this size has embedded bitmaps, which
                 for CJK fonts should be used in preference to LCD glyphs.                
            </comment>
            <comment line="944">
                This probably won&apos;t get called but is there to support the
                 contract() of setStyle() defined in the superclass.                
            </comment>
            <comment line="952">
                TrueTypeFont can use the fsSelection fields of OS2 table
                 to determine the style. In the unlikely case that doesn&apos;t exist,
                 can use macStyle in the &apos;head&apos; table but simpler to
                 fall back to super class algorithm of looking for well known string.
                 A very few fonts don&apos;t specify this information, but I only
                 came across one: Lucida Sans Thai Typewriter Oblique in
                 usropenwinliblocaleth_THX11fontsTrueTypelucidai.ttf
                 that explicitly specified the wrong value. It says its regular.
                 I didn&apos;t find any fonts that were inconsistent (ie regular plus some
                 other value).                
            </comment>
            <comment line="1192">
                Return the requested name in the requested locale, for the
                 MS platform ID. If the requested locale isn&apos;t found, return US
                 English, if that isn&apos;t found, return null and let the caller
                 figure out how to handle that.                
            </comment>
            <comment line="1256">
                Postscript name is rarely requested. Don&apos;t waste cycles locating it
                 as part of font creation, nor storage to hold it. Get it only on demand.                
            </comment>
            <comment line="1286">
                Return a Microsoft LCID from the given Locale.
                 Used when getting localized font data.                
            </comment>
            <comment line="1532">
                This duplicates initNames() but that has to run fast as its used
                 during typical start-up and the information here is likely never
                 needed.                
            </comment>
            <comment line="1593">
                Used by the OpenType engine for mark positioning.                
            </comment>
            <comment line="1638">
                This is to obtain info from the TT &apos;gasp&apos; (grid-fitting and
                 scan-conversion procedure) table which specifies three combinations:
                 Hint, Smooth (greyscale), Hint and Smooth.
                 In this simplified scheme we don&apos;t distinguish the latter two. We
                 hint even at small sizes, so as to preserve metrics consistency.
                 If the information isn&apos;t available default values are substituted.
                 The more precise defaults we&apos;d do if we distinguished the cases are:
                 Bold (no other style) fonts :
                 0-8 : Smooth ( do grey)
                 9+  : Hint + smooth (gridfit + grey)
                 Plain, Italic and Bold-Italic fonts :
                 0-8 : Smooth ( do grey)
                 9-17 : Hint (gridfit)
                 18+  : Hint + smooth (gridfit + grey)
                 The defaults should rarely come into play as most TT fonts provide
                 better defaults.
                 REMIND: consider unpacking the table into an array of booleans
                 for faster use.                
            </comment>
            <javadoc line="49">
                TrueTypeFont is not called SFntFont because it is not expected
                  to handle all types that may be housed in a such a font file.
                  If additional types are supported later, it may make sense to
                  create an SFnt superclass. Eg to handle sfnt-housed postscript fonts.
                  OpenType fonts are handled by this class, and possibly should be
                  represented by a subclass.
                  An instance stores some information from the font file to faciliate
                  faster access. File size, the table directory and the names of the font
                  are the most important of these. It amounts to approx 400 bytes
                  for a typical font. Systems with mutiple locales sometimes have up to 400
                  font files, and an app which loads all font files would need around
                  160Kbytes. So storing any more info than this would be expensive.                
            </javadoc>
            <declaration name="cmapTag" type="int" line="66"/>
            <declaration name="glyfTag" type="int" line="67"/>
            <declaration name="headTag" type="int" line="68"/>
            <declaration name="hheaTag" type="int" line="69"/>
            <declaration name="hmtxTag" type="int" line="70"/>
            <declaration name="locaTag" type="int" line="71"/>
            <declaration name="maxpTag" type="int" line="72"/>
            <declaration name="nameTag" type="int" line="73"/>
            <declaration name="postTag" type="int" line="74"/>
            <declaration name="os_2Tag" type="int" line="75"/>
            <declaration name="GDEFTag" type="int" line="78"/>
            <declaration name="GPOSTag" type="int" line="79"/>
            <declaration name="GSUBTag" type="int" line="80"/>
            <declaration name="mortTag" type="int" line="81"/>
            <declaration name="fdscTag" type="int" line="84"/>
            <declaration name="fvarTag" type="int" line="85"/>
            <declaration name="featTag" type="int" line="86"/>
            <declaration name="EBLCTag" type="int" line="87"/>
            <declaration name="gaspTag" type="int" line="88"/>
            <declaration name="ttcfTag" type="int" line="91"/>
            <declaration name="v1ttTag" type="int" line="92"/>
            <declaration name="trueTag" type="int" line="93"/>
            <declaration name="ottoTag" type="int" line="94"/>
            <declaration name="MS_PLATFORM_ID" type="int" line="97"/>
            <declaration name="ENGLISH_LOCALE_ID" type="short" line="99"/>
            <declaration name="FAMILY_NAME_ID" type="int" line="100"/>
            <declaration name="FULL_NAME_ID" type="int" line="102"/>
            <declaration name="POSTSCRIPT_NAME_ID" type="int" line="103"/>
            <declaration name="US_LCID" type="short" line="105"/>
            <declaration name="lcidMap" type="Map&lt;String,Short&gt;" line="107"/>
            <class name="DirectoryEntry" line="109">
                <declaration name="tag" type="int" line="110"/>
                <declaration name="offset" type="int" line="111"/>
                <declaration name="length" type="int" line="112"/>
            </class>
            <class name="TTDisposerRecord" line="123">
                <implements interface="DisposerRecord"/>
                <declaration name="channel" type="FileChannel" line="125"/>
                <method name="dispose" type="void" line="127">
                    <scope line="128">
                        <scope line="129"/>
                    </scope>
                    <scope line="132"/>
                    <scope line="133"/>
                </method>
            </class>
            <declaration name="disposerRecord" type="TTDisposerRecord" line="139"/>
            <declaration name="fontIndex" type="int" line="142"/>
            <declaration name="directoryCount" type="int" line="145"/>
            <declaration name="directoryOffset" type="int" line="148"/>
            <declaration name="numTables" type="int" line="151"/>
            <declaration name="tableDirectory" type="DirectoryEntry[]" line="154"/>
            <declaration name="supportsJA" type="boolean" line="164"/>
            <declaration name="supportsCJK" type="boolean" line="165"/>
            <declaration name="nameLocale" type="Locale" line="170"/>
            <declaration name="localeFamilyName" type="String" line="171"/>
            <declaration name="localeFullName" type="String" line="172"/>
            <javadoc line="174">
                - does basic verification of the file
                  - reads the header table for this font (within a collection)
                  - reads the names (full, family).
                  - determines the style of the font.
                  - initializes the CMAP                
                <throws>
                    FontFormatException - if the font can&apos;t be opened
                      or fails verification,  or there&apos;s no usable cmap                    
                </throws>
            </javadoc>
            <method name="TrueTypeFont" type="constructor" line="185">
                <params>
                    <param name="platname" type="String"/>
                    <param name="nativeNames" type="Object"/>
                    <param name="fIndex" type="int"/>
                    <param name="javaRasterizer" type="boolean"/>
                </params>
                <scope line="189"/>
                <scope line="192">
                    <scope line="194"/>
                    <scope line="196"/>
                </scope>
            </method>
            <method name="checkUseNatives" type="boolean" line="215">
                <comment line="225">
                                        
                </comment>
                <comment line="228">
                                        
                </comment>
                <comment line="236">
                    If reach here we have an non-latin font that has
                     external bitmaps and we successfully created it.                    
                </comment>
                <scope line="216"/>
                <scope line="222"/>
                <scope line="225">
                    <declaration name="name" type="String" line="226"/>
                    <scope line="228"/>
                    <scope line="231">
                        <scope line="233"/>
                        <scope line="239"/>
                    </scope>
                </scope>
                <scope line="243">
                    <declaration name="natNames" type="String[]" line="244"/>
                    <declaration name="numNames" type="int" line="245"/>
                    <declaration name="externalBitmaps" type="boolean" line="246"/>
                    <scope line="247">
                        <scope line="248"/>
                        <scope line="251"/>
                    </scope>
                    <scope line="255"/>
                    <scope line="261">
                        <scope line="262"/>
                        <scope line="264"/>
                    </scope>
                </scope>
                <scope line="270"/>
            </method>
            <method name="open" type="FileChannel" line="285">
                <comment line="313">
                    NIO IO is interruptible, recurse to retry operation.
                     The call to channel.size() above can throw this exception.
                     Clear interrupts before recursing in case NIO didn&apos;t.
                     Note that close() sets disposerRecord.channel to null.                    
                </comment>
                <scope line="286">
                    <scope line="287"/>
                    <scope line="290">
                        <anonymous_class line="293">
                            <method name="run" type="Object" line="294">
                                <scope line="295"/>
                                <scope line="297"/>
                            </method>
                        </anonymous_class>
                        <declaration name="raf" type="RandomAccessFile" line="291"/>
                        <declaration name="fm" type="FontManager" line="304"/>
                        <scope line="305"/>
                    </scope>
                    <scope line="308"/>
                    <scope line="311"/>
                    <scope line="320"/>
                </scope>
            </method>
            <method name="close" type="void" line="328"/>
            <method name="readBlock" type="int" line="333">
                <params>
                    <param name="buffer" type="ByteBuffer"/>
                    <param name="offset" type="int"/>
                    <param name="length" type="int"/>
                </params>
                <comment line="343">
                    Since the caller ensures that offset is &lt; fileSize
                     this condition suggests that fileSize is now
                     different than the value we originally provided
                     to native when the scaler was created.
                     Also fileSize is updated every time we
                     open() the file here, but in native the value
                     isn&apos;t updated. If the file has changed whilst we
                     are executing we want to bail, not spin.                    
                </comment>
                <comment line="377">
                    We could still flip() the buffer here because
                     it&apos;s possible that we did read some data in
                     an earlier loop, and we probably should
                     return that to the caller. Although if
                     the caller expected 8K of data and we return
                     only a few bytes then maybe it&apos;s better instead to
                     set bread = -1 to indicate failure.
                     The following is therefore using arbitrary values
                     but is meant to allow cases where enough
                     data was read to probably continue.                    
                </comment>
                <comment line="402">
                    possible if buffer.size() &gt; length                    
                </comment>
                <comment line="411">
                    signal EOF                    
                </comment>
                <comment line="414">
                    NIO IO is interruptible, recurse to retry operation.
                     Clear interrupts before recursing in case NIO didn&apos;t.                    
                </comment>
                <comment line="421">
                    If we did not read any bytes at all and the exception is
                     not a recoverable one (ie is not ClosedChannelException) then
                     we should indicate that there is no point in re-trying.
                     Other than an attempt to read past the end of the file it
                     seems unlikely this would occur as problems opening the
                     file are handled as a FontFormatException.                    
                </comment>
                <comment line="433">
                    signal EOF                    
                </comment>
                <declaration name="bread" type="int" line="334"/>
                <scope line="335">
                    <scope line="336">
                        <scope line="337"/>
                        <scope line="340">
                            <scope line="341">
                                <scope line="351">
                                    <declaration name="msg" type="String" line="352"/>
                                </scope>
                            </scope>
                            <scope line="358"/>
                        </scope>
                        <scope line="364">
                            <declaration name="cnt" type="int" line="365"/>
                            <scope line="366">
                                <declaration name="msg" type="String" line="367"/>
                                <declaration name="currSize" type="int" line="368"/>
                                <scope line="369"/>
                                <scope line="373"/>
                                <scope line="386">
                                    <scope line="388"/>
                                </scope>
                                <scope line="393"/>
                            </scope>
                        </scope>
                        <scope line="401"/>
                    </scope>
                </scope>
                <scope line="405">
                    <scope line="406"/>
                </scope>
                <scope line="412"/>
                <scope line="419">
                    <scope line="427"/>
                    <scope line="431"/>
                </scope>
            </method>
            <method name="readBlock" type="ByteBuffer" line="439">
                <params>
                    <param name="offset" type="int"/>
                    <param name="length" type="int"/>
                </params>
                <comment line="450">
                    assert?                    
                </comment>
                <comment line="462">
                    NIO IO is interruptible, recurse to retry operation.
                     Clear interrupts before recursing in case NIO didn&apos;t.                    
                </comment>
                <declaration name="buffer" type="ByteBuffer" line="441"/>
                <scope line="442">
                    <scope line="443">
                        <scope line="444"/>
                        <scope line="447">
                            <scope line="448"/>
                            <scope line="450"/>
                        </scope>
                    </scope>
                </scope>
                <scope line="458"/>
                <scope line="460"/>
                <scope line="467"/>
            </method>
            <method name="readBytes" type="byte[]" line="479">
                <params>
                    <param name="offset" type="int"/>
                    <param name="length" type="int"/>
                </params>
                <declaration name="buffer" type="ByteBuffer" line="480"/>
                <scope line="481"/>
                <scope line="483">
                    <declaration name="bufferBytes" type="byte[]" line="484"/>
                </scope>
            </method>
            <method name="verify" type="void" line="490"/>
            <declaration name="TTCHEADERSIZE" type="int" line="495"/>
            <declaration name="DIRECTORYHEADERSIZE" type="int" line="496"/>
            <declaration name="DIRECTORYENTRYSIZE" type="int" line="497"/>
            <method name="init" type="void" line="499">
                <params>
                    <param name="fIndex" type="int"/>
                </params>
                <comment line="507">
                    skip TTC version ID                    
                </comment>
                <comment line="527">
                    Now have the offset of this TT font (possibly within a TTC)
                     After the TT versionscaler type field, is the short
                     representing the number of tables in the table directory.
                     The table directory begins at 12 bytes after the header.
                     Each table entry is 16 bytes long (4 32-bit ints)                    
                </comment>
                <comment line="544">
                                        
                </comment>
                <comment line="565">
                    The os2_Table is needed to gather some info, but we don&apos;t
                     want to keep it around (as a field) so obtain it once and
                     pass it to the code that needs it.                    
                </comment>
                <declaration name="headerOffset" type="int" line="500"/>
                <declaration name="buffer" type="ByteBuffer" line="501"/>
                <scope line="502">
                    <scope line="508"/>
                    <declaration name="bbuffer" type="ByteBuffer" line="535"/>
                    <declaration name="ibuffer" type="IntBuffer" line="537"/>
                    <declaration name="table" type="DirectoryEntry" line="538"/>
                    <scope line="540">
                        <scope line="546"/>
                    </scope>
                </scope>
                <scope line="551">
                    <scope line="552"/>
                    <scope line="555"/>
                    <scope line="557"/>
                </scope>
                <scope line="561"/>
                <declaration name="os2_Table" type="ByteBuffer" line="568"/>
            </method>
            <declaration name="encoding_mapping" type="String" line="580"/>
            <declaration name="languages" type="String" line="628"/>
            <declaration name="codePages" type="String" line="675"/>
            <declaration name="defaultCodePage" type="String" line="692"/>
            <method name="getCodePage" type="String" line="693">
                <scope line="695"/>
                <scope line="699"/>
                <scope line="703">
                    <scope line="704"/>
                    <declaration name="locale" type="Locale" line="707"/>
                    <declaration name="language" type="String" line="709"/>
                    <scope line="710">
                        <scope line="711">
                            <declaration name="country" type="String" line="712"/>
                            <scope line="713"/>
                        </scope>
                        <scope line="717">
                            <scope line="718">
                                <scope line="719"/>
                            </scope>
                        </scope>
                    </scope>
                </scope>
                <scope line="727"/>
            </method>
            <declaration name="reserved_bits1" type="int" line="734"/>
            <declaration name="reserved_bits2" type="int" line="735"/>
            <method name="supportsEncoding" type="boolean" line="737">
                <params>
                    <param name="encoding" type="String"/>
                </params>
                <comment line="748">
                    java_props_md.c has a couple of special cases
                     if language packs are installed. In these encodings the
                     fontconfig files pick up different fonts :
                     SimSun-18030 and MingLiU_HKSCS. Since these fonts will
                     indicate they support the base encoding, we need to rewrite
                     these encodings here before checking the maparray.                    
                </comment>
                <comment line="762">
                                        
                </comment>
                <comment line="767">
                                        
                </comment>
                <comment line="768">
                                        
                </comment>
                <comment line="770">
                    This test is too stringent for Arial on Solaris (and perhaps
                     other fonts). Arial has at least one reserved bit set for an
                     unknown reason.                    
                </comment>
                <comment line="774">
                    if (((range1 &amp; reserved_bits1) | (range2 &amp; reserved_bits2)) != 0) {
                                 return false;
                             }                    
                </comment>
                <scope line="738"/>
                <scope line="741"/>
                <scope line="754"/>
                <scope line="756"/>
                <declaration name="buffer" type="ByteBuffer" line="760"/>
                <scope line="762"/>
                <declaration name="range1" type="int" line="766"/>
                <declaration name="range2" type="int" line="767"/>
                <scope line="777">
                    <scope line="778">
                        <scope line="779"/>
                    </scope>
                </scope>
            </method>
            <method name="setCJKSupport" type="void" line="789">
                <params>
                    <param name="os2Table" type="ByteBuffer"/>
                </params>
                <comment line="791">
                                        
                </comment>
                <comment line="795">
                                        
                </comment>
                <comment line="797">
                    Any of these bits set in the 32-63 range indicate a font with
                     support for a CJK range. We aren&apos;t looking at some other bits
                     in the 64-69 range such as half width forms as its unlikely a font
                     would include those and none of these.                    
                </comment>
                <comment line="804">
                    This should be generalised, but for now just need to know if
                     Hiragana or Katakana ranges are supported by the font.
                     In the 4 longs representing unicode ranges supported
                     bits 49 &amp; 50 indicate hiragana and katakana
                     This is bits 17 &amp; 18 in the 2nd ulong. If either is supported
                     we presume this is a JA font.                    
                </comment>
                <scope line="791"/>
                <declaration name="range2" type="int" line="794"/>
            </method>
            <method name="supportsJA" type="boolean" line="813"/>
            <method name="getTableBuffer" type="ByteBuffer" line="817">
                <params>
                    <param name="tag" type="int"/>
                </params>
                <comment line="843">
                    NIO IO is interruptible, recurse to retry operation.
                     Clear interrupts before recursing in case NIO didn&apos;t.                    
                </comment>
                <declaration name="entry" type="DirectoryEntry" line="818"/>
                <scope line="820">
                    <scope line="821"/>
                </scope>
                <scope line="827"/>
                <declaration name="bread" type="int" line="831"/>
                <declaration name="buffer" type="ByteBuffer" line="832"/>
                <scope line="833">
                    <scope line="834">
                        <scope line="835"/>
                    </scope>
                    <scope line="841"/>
                    <scope line="848"/>
                    <scope line="850"/>
                    <scope line="854"/>
                    <scope line="856"/>
                </scope>
            </method>
            <method name="getLayoutTableCache" type="long" line="863">
                <scope line="864"/>
                <scope line="866"/>
            </method>
            <method name="getTableBytes" type="byte[]" line="872">
                <params>
                    <param name="tag" type="int"/>
                </params>
                <declaration name="buffer" type="ByteBuffer" line="873"/>
                <scope line="874"/>
                <scope line="876">
                    <scope line="877"/>
                    <scope line="879"/>
                </scope>
                <declaration name="data" type="byte[]" line="882"/>
            </method>
            <method name="getTableSize" type="int" line="887">
                <params>
                    <param name="tag" type="int"/>
                </params>
                <scope line="888">
                    <scope line="889"/>
                </scope>
            </method>
            <method name="getTableOffset" type="int" line="896">
                <params>
                    <param name="tag" type="int"/>
                </params>
                <scope line="897">
                    <scope line="898"/>
                </scope>
            </method>
            <method name="getDirectoryEntry" type="DirectoryEntry" line="905">
                <params>
                    <param name="tag" type="int"/>
                </params>
                <scope line="906">
                    <scope line="907"/>
                </scope>
            </method>
            <method name="useEmbeddedBitmapsForSize" type="boolean" line="917">
                <params>
                    <param name="ptSize" type="int"/>
                </params>
                <comment line="927">
                    The bitmapSizeTable&apos;s start at offset of 8.
                     Each bitmapSizeTable entry is 48 bytes.
                     The offset of ppemY in the entry is 45.                    
                </comment>
                <scope line="918"/>
                <scope line="921"/>
                <declaration name="eblcTable" type="ByteBuffer" line="924"/>
                <declaration name="numSizes" type="int" line="925"/>
                <scope line="930">
                    <declaration name="ppemY" type="int" line="931"/>
                    <scope line="932"/>
                </scope>
            </method>
            <method name="getFullName" type="String" line="939"/>
            <method name="setStyle" type="void" line="947"/>
            <declaration name="fsSelectionItalicBit" type="int" line="962"/>
            <declaration name="fsSelectionBoldBit" type="int" line="963"/>
            <declaration name="fsSelectionRegularBit" type="int" line="964"/>
            <method name="setStyle" type="void" line="965">
                <params>
                    <param name="os_2Table" type="ByteBuffer"/>
                </params>
                <comment line="967">
                                        
                </comment>
                <comment line="976">
                    System.out.println(&quot;platname=&quot;+platName+&quot; font=&quot;+fullName+
                                             &quot; family=&quot;+familyName+
                                             &quot; R=&quot;+regular+&quot; I=&quot;+italic+&quot; B=&quot;+bold);                    
                </comment>
                <comment line="980">
                                        
                </comment>
                <comment line="984">
                                        
                </comment>
                <comment line="994">
                    Workaround for Solaris&apos;s use of a JA font that&apos;s marked as
                     being designed bold, but is used as a PLAIN font.                    
                </comment>
                <scope line="967"/>
                <declaration name="fsSelection" type="int" line="971"/>
                <declaration name="italic" type="int" line="972"/>
                <declaration name="bold" type="int" line="973"/>
                <declaration name="regular" type="int" line="974"/>
                <scope line="978"/>
                <scope line="982"/>
                <scope line="992"/>
                <scope line="997"/>
            </method>
            <declaration name="stSize" type="float" line="1006"/>
            <method name="setStrikethroughMetrics" type="void" line="1008">
                <params>
                    <param name="os_2Table" type="ByteBuffer"/>
                    <param name="upem" type="int"/>
                </params>
                <scope line="1009"/>
                <declaration name="sb" type="ShortBuffer" line="1014"/>
            </method>
            <method name="setUnderlineMetrics" type="void" line="1019">
                <params>
                    <param name="postTable" type="ByteBuffer"/>
                    <param name="upem" type="int"/>
                </params>
                <scope line="1020"/>
                <declaration name="sb" type="ShortBuffer" line="1025"/>
            </method>
            <method name="getStyleMetrics" type="void" line="1031">
                <params>
                    <param name="pointSize" type="float"/>
                    <param name="metrics" type="float[]"/>
                    <param name="offset" type="int"/>
                </params>
                <scope line="1033">
                    <declaration name="head_Table" type="ByteBuffer" line="1035"/>
                    <declaration name="upem" type="int" line="1036"/>
                    <scope line="1037">
                        <declaration name="sb" type="ShortBuffer" line="1038"/>
                    </scope>
                    <declaration name="os2_Table" type="ByteBuffer" line="1042"/>
                    <declaration name="post_Table" type="ByteBuffer" line="1045"/>
                </scope>
            </method>
            <method name="makeString" type="String" line="1056">
                <params>
                    <param name="bytes" type="byte[]"/>
                    <param name="len" type="int"/>
                    <param name="encoding" type="short"/>
                </params>
                <comment line="1059">
                    Check for fonts using encodings 2-&gt;6 is just for
                     some old DBCS fonts, apparently mostly on Solaris.
                     Some of these fonts encode ascii names as double-byte characters.
                     ie with a leading zero byte for what properly should be a
                     single byte-char.                    
                </comment>
                <comment line="1079">
                    most common case first.                    
                </comment>
                <comment line="1080">
                    symbol uses this                    
                </comment>
                <scope line="1064">
                    <declaration name="oldbytes" type="byte[]" line="1065"/>
                    <declaration name="oldlen" type="int" line="1066"/>
                    <scope line="1069">
                        <scope line="1070"/>
                    </scope>
                </scope>
                <declaration name="charset" type="String" line="1076"/>
                <scope line="1088"/>
                <scope line="1090">
                    <scope line="1091"/>
                </scope>
                <scope line="1095"/>
            </method>
            <method name="initNames" type="void" line="1100">
                <comment line="1108">
                    format - not needed.                    
                </comment>
                <comment line="1110">
                    The name table uses unsigned shorts. Many of these
                     are known small values that fit in a short.
                     The values that are sizes or offsets into the table could be
                     greater than 32767, so read and store those as ints                    
                </comment>
                <comment line="1124">
                    skip over this record.                    
                </comment>
                <comment line="1150">
                    for (int ii=0;ii&lt;nameLen;ii++) {
                    int val = (int)name[ii]&amp;0xff;
                    System.err.print(Integer.toHexString(val)+ &quot; &quot;);
                    }
                    System.err.println();
                    System.err.println(&quot;familyName=&quot;+familyName +
                    &quot; nameLen=&quot;+nameLen+
                    &quot; langID=&quot;+langID+ &quot; eid=&quot;+encodingID +
                    &quot; str len=&quot;+familyName.length());                    
                </comment>
                <declaration name="name" type="byte[]" line="1102"/>
                <declaration name="buffer" type="ByteBuffer" line="1103"/>
                <scope line="1105">
                    <declaration name="sbuffer" type="ShortBuffer" line="1106"/>
                    <declaration name="numRecords" type="short" line="1108"/>
                    <declaration name="stringPtr" type="int" line="1114"/>
                    <declaration name="nameLocaleID" type="short" line="1117"/>
                    <scope line="1119">
                        <declaration name="platformID" type="short" line="1120"/>
                        <scope line="1121"/>
                        <declaration name="encodingID" type="short" line="1125"/>
                        <declaration name="langID" type="short" line="1126"/>
                        <declaration name="nameID" type="short" line="1127"/>
                        <declaration name="nameLen" type="int" line="1128"/>
                        <declaration name="namePtr" type="int" line="1129"/>
                        <declaration name="tmpName" type="String" line="1130"/>
                        <scope line="1137">
                            <scope line="1142"/>
                            <scope line="1145"/>
                        </scope>
                        <scope line="1167">
                            <scope line="1172"/>
                            <scope line="1175"/>
                        </scope>
                    </scope>
                    <scope line="1182"/>
                    <scope line="1185"/>
                </scope>
            </method>
            <method name="lookupName" type="String" line="1196">
                <params>
                    <param name="findLocaleID" type="short"/>
                    <param name="findNameID" type="int"/>
                </params>
                <comment line="1204">
                    format - not needed.                    
                </comment>
                <comment line="1207">
                    The name table uses unsigned shorts. Many of these
                     are known small values that fit in a short.
                     The values that are sizes or offsets into the table could be
                     greater than 32767, so read and store those as ints                    
                </comment>
                <comment line="1218">
                    skip over this record.                    
                </comment>
                <declaration name="foundName" type="String" line="1197"/>
                <declaration name="name" type="byte[]" line="1198"/>
                <declaration name="buffer" type="ByteBuffer" line="1200"/>
                <scope line="1201">
                    <declaration name="sbuffer" type="ShortBuffer" line="1202"/>
                    <declaration name="numRecords" type="short" line="1204"/>
                    <declaration name="stringPtr" type="int" line="1211"/>
                    <scope line="1213">
                        <declaration name="platformID" type="short" line="1214"/>
                        <scope line="1215"/>
                        <declaration name="encodingID" type="short" line="1219"/>
                        <declaration name="langID" type="short" line="1220"/>
                        <declaration name="nameID" type="short" line="1221"/>
                        <declaration name="nameLen" type="int" line="1222"/>
                        <declaration name="namePtr" type="int" line="1223"/>
                        <scope line="1226">
                            <scope line="1230"/>
                        </scope>
                    </scope>
                </scope>
            </method>
            <javadoc line="1239">
                @return number of logical fonts. Is &quot;1&quot; for all but TTC files                
            </javadoc>
            <method name="getFontCount" type="int" line="1242"/>
            <method name="getScaler" type="FontScaler" line="1246">
                <scope line="1247"/>
            </method>
            <method name="getPostscriptName" type="String" line="1259">
                <declaration name="name" type="String" line="1260"/>
                <scope line="1261"/>
                <scope line="1263"/>
            </method>
            <method name="getFontName" type="String" line="1269">
                <params>
                    <param name="locale" type="Locale"/>
                </params>
                <scope line="1270"/>
                <scope line="1272"/>
                <scope line="1274">
                    <declaration name="localeID" type="short" line="1275"/>
                    <declaration name="name" type="String" line="1276"/>
                    <scope line="1277"/>
                    <scope line="1279"/>
                </scope>
            </method>
            <method name="addLCIDMapEntry" type="void" line="1289">
                <params>
                    <param name="map" type="Map<String,Short>"/>
                    <param name="key" type="String"/>
                    <param name="value" type="short"/>
                </params>
            </method>
            <method name="createLCIDMap" type="void" line="1293">
                <comment line="1301">
                    the following statements are derived from the langIDMap
                     in src/windows/native/java/lang/java_props_md.c using the following
                     awk script:
                        $1~/\/\*/   { next}
                        $3~/\?\?/   { next }
                        $3!~/_/     { next }
                        $1~/0x0409/ { next }
                        $1~/0x0c0a/ { next }
                        $1~/0x042c/ { next }
                        $1~/0x0443/ { next }
                        $1~/0x0812/ { next }
                        $1~/0x04/   { print &quot;        addLCIDMapEntry(map, &quot; substr($3, 0, 3) &quot;\&quot;, (short) &quot; substr($1, 0, 6) &quot;);&quot; ; next }
                        $3~/,/      { print &quot;        addLCIDMapEntry(map, &quot; $3  &quot; (short) &quot; substr($1, 0, 6) &quot;);&quot; ; next }
                                    { print &quot;        addLCIDMapEntry(map, &quot; $3 &quot;, (short) &quot; substr($1, 0, 6) &quot;);&quot; ; next }
                     The lines of this script:
                     - eliminate comments
                     - eliminate questionable locales
                     - eliminate language-only locales
                     - eliminate the default LCID value
                     - eliminate a few other unneeded LCID values
                     - print language-only locale entries for x04* LCID values
                       (apparently Microsoft doesn&apos;t use language-only LCID values -
                       see http:www.microsoft.com/OpenType/otspec/name.htm
                     - print complete entries for all other LCID values
                     Run
                         awk -f awk-script langIDMap &gt; statements                    
                </comment>
                <scope line="1294"/>
                <declaration name="map" type="Map&lt;String,Short&gt;" line="1298"/>
            </method>
            <method name="getLCIDFromLocale" type="short" line="1481">
                <params>
                    <param name="locale" type="Locale"/>
                </params>
                <comment line="1483">
                    optimize for common case                    
                </comment>
                <scope line="1483"/>
                <scope line="1487"/>
                <declaration name="key" type="String" line="1491"/>
                <scope line="1492">
                    <declaration name="lcidObject" type="Short" line="1493"/>
                    <scope line="1494"/>
                    <declaration name="pos" type="int" line="1497"/>
                    <scope line="1498"/>
                </scope>
            </method>
            <method name="getFamilyName" type="String" line="1508">
                <params>
                    <param name="locale" type="Locale"/>
                </params>
                <scope line="1509"/>
                <scope line="1511"/>
                <scope line="1513">
                    <declaration name="localeID" type="short" line="1514"/>
                    <declaration name="name" type="String" line="1515"/>
                    <scope line="1516"/>
                    <scope line="1518"/>
                </scope>
            </method>
            <method name="getMapper" type="CharToGlyphMapper" line="1524">
                <scope line="1525"/>
            </method>
            <method name="initAllNames" type="void" line="1535">
                <params>
                    <param name="requestedID" type="int"/>
                    <param name="names" type="HashSet"/>
                </params>
                <comment line="1543">
                    format - not needed.                    
                </comment>
                <comment line="1546">
                    The name table uses unsigned shorts. Many of these
                     are known small values that fit in a short.
                     The values that are sizes or offsets into the table could be
                     greater than 32767, so read and store those as ints                    
                </comment>
                <comment line="1556">
                    skip over this record.                    
                </comment>
                <declaration name="name" type="byte[]" line="1537"/>
                <declaration name="buffer" type="ByteBuffer" line="1538"/>
                <scope line="1540">
                    <declaration name="sbuffer" type="ShortBuffer" line="1541"/>
                    <declaration name="numRecords" type="short" line="1543"/>
                    <declaration name="stringPtr" type="int" line="1550"/>
                    <scope line="1551">
                        <declaration name="platformID" type="short" line="1552"/>
                        <scope line="1553"/>
                        <declaration name="encodingID" type="short" line="1557"/>
                        <declaration name="langID" type="short" line="1558"/>
                        <declaration name="nameID" type="short" line="1559"/>
                        <declaration name="nameLen" type="int" line="1560"/>
                        <declaration name="namePtr" type="int" line="1561"/>
                        <scope line="1563"/>
                    </scope>
                </scope>
            </method>
            <method name="getAllFamilyNames" type="String[]" line="1572">
                <comment line="1578">
                                        
                </comment>
                <declaration name="aSet" type="HashSet" line="1573"/>
                <scope line="1574"/>
                <scope line="1576"/>
            </method>
            <method name="getAllFullNames" type="String[]" line="1582">
                <comment line="1588">
                                        
                </comment>
                <declaration name="aSet" type="HashSet" line="1583"/>
                <scope line="1584"/>
                <scope line="1586"/>
            </method>
            <method name="getGlyphPoint" type="Point2D.Float" line="1596">
                <params>
                    <param name="pScalerContext" type="long"/>
                    <param name="glyphCode" type="int"/>
                    <param name="ptNumber" type="int"/>
                </params>
                <scope line="1597"/>
                <scope line="1600"/>
            </method>
            <declaration name="gaspTable" type="char[]" line="1605"/>
            <method name="getGaspTable" type="char[]" line="1607">
                <comment line="1621">
                    format &quot;1&quot; has appeared for some Windows Vista fonts.
                     Its presently undocumented but the existing values
                     seem to be still valid so we can use it.                    
                </comment>
                <comment line="1625">
                    unrecognised format                    
                </comment>
                <comment line="1630">
                    sanity check                    
                </comment>
                <scope line="1609"/>
                <declaration name="buffer" type="ByteBuffer" line="1613"/>
                <scope line="1614"/>
                <declaration name="cbuffer" type="CharBuffer" line="1618"/>
                <declaration name="format" type="char" line="1619"/>
                <scope line="1624"/>
                <declaration name="numRanges" type="char" line="1628"/>
                <scope line="1629"/>
            </method>
            <method name="useAAForPtSize" type="boolean" line="1657">
                <params>
                    <param name="ptsize" type="int"/>
                </params>
                <comment line="1664">
                    bit 2 means DO_GRAY;                    
                </comment>
                <declaration name="gasp" type="char[]" line="1659"/>
                <scope line="1660">
                    <scope line="1661">
                        <scope line="1662"/>
                    </scope>
                </scope>
                <scope line="1669"/>
                <scope line="1671"/>
            </method>
            <method name="hasSupplementaryChars" type="boolean" line="1677"/>
            <method name="toString" type="String" line="1682"/>
        </class>
    </source>