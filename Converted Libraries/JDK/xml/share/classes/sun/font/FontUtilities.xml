<?xml version="1.0" encoding="UTF-8"?>
    <source package="sun.font">
        <import package="java.awt.Font"/>
        <import package="java.io.BufferedReader"/>
        <import package="java.io.File"/>
        <import package="java.io.FileInputStream"/>
        <import package="java.io.InputStreamReader"/>
        <import package="java.lang.ref.SoftReference"/>
        <import package="java.util.concurrent.ConcurrentHashMap"/>
        <import package="java.security.AccessController"/>
        <import package="java.security.PrivilegedAction"/>
        <import package="javax.swing.plaf.FontUIResource"/>
        <import package="sun.util.logging.PlatformLogger"/>
        <class name="FontUtilities" line="42">
            <comment line="70">
                This static initializer block figures out the OS constants.                
            </comment>
            <comment line="210">
                This is almost the same as the method above, except it takes a
                 char which means it may include undecoded surrogate pairs.
                 The distinction is made so that code which needs to identify all
                 cases in which we do not have a simple mapping from
                 char-&gt;unicode character-&gt;glyph can be be identified.
                 For example measurement cannot simply sum advances of &apos;chars&apos;,
                 the caret in editable text cannot advance one &apos;char&apos; at a time, etc.
                 These callers really are asking for more than whether &apos;layout&apos;
                 needs to be run, they need to know if they can assume 1-&gt;1
                 char-&gt;glyph mapping.                
            </comment>
            <comment line="228">
                If the character code falls into any of a number of unicode ranges
                 where we know that simple left-&gt;right layout mapping chars to glyphs
                 1:1 and accumulating advances is going to produce incorrect results,
                 we want to know this so the caller can use a more intelligent layout
                 approach. A caller who cares about optimum performance may want to
                 check the first case and skip the method call if its in that range.
                 Although there&apos;s a lot of tests in here, knowing you can skip
                 CTL saves a great deal more. The rest of the checks are ordered
                 so that rather than checking explicitly if (&gt;= start &amp; &lt;= end)
                 which would mean all ranges would need to be checked so be sure
                 CTL is not needed, the method returns as soon as it recognises
                 the code point is outside of a CTL ranges.
                 NOTE: Since this method accepts an &apos;int&apos; it is asssumed to properly
                 represent a CHARACTER. ie it assumes the caller has already
                 converted surrogate pairs into supplementary characters, and so
                 can handle this case and doesn&apos;t need to be told such a case is
                 &apos;complex&apos;.                
            </comment>
            <comment line="328">
                The following methods are used by Swing.                
            </comment>
            <comment line="330">
                Revise the implementation to in fact mean &quot;font is a composite font.
                 This ensures that Swing components will always benefit from the
                 fall back fonts                
            </comment>
            <comment line="436">
                A small &quot;map&quot; from GTKfontconfig names to the equivalent JDK
                 logical font name.                
            </comment>
            <comment line="456">
                This is called by Swing passing in a fontconfig family name
                 such as &quot;sans&quot;. In return Swing gets a FontUIResource instance
                 that has queried fontconfig to resolve the font(s) used for this.
                 Fontconfig will if asked return a list of fonts to give the largest
                 possible code point coverage.
                 For now we use only the first font returned by fontconfig, and
                 back it up with the most closely matching JDK logical font.
                 Essentially this means pre-pending what we return now with fontconfig&apos;s
                 preferred physical font. This could lead to some duplication in cases,
                 if we already included that font later. We probably should remove such
                 duplicates, but it is not a significant problem. It can be addressed
                 later as part of creating a Composite which uses more of the
                 same fonts as fontconfig. At that time we also should pay more
                 attention to the special rendering instructions fontconfig returns,
                 such as whether we should prefer embedded bitmaps over antialiasing.
                 There&apos;s no way to express that via a Font at present.                
            </comment>
            <javadoc line="42">
                A collection of utility methods.                
            </javadoc>
            <declaration name="isSolaris" type="boolean" line="47"/>
            <declaration name="isLinux" type="boolean" line="49"/>
            <declaration name="isSolaris8" type="boolean" line="51"/>
            <declaration name="isSolaris9" type="boolean" line="53"/>
            <declaration name="isOpenSolaris" type="boolean" line="55"/>
            <declaration name="useT2K" type="boolean" line="57"/>
            <declaration name="isWindows" type="boolean" line="59"/>
            <declaration name="isOpenJDK" type="boolean" line="61"/>
            <declaration name="LUCIDA_FILE_NAME" type="String" line="63"/>
            <declaration name="debugFonts" type="boolean" line="65"/>
            <declaration name="logger" type="PlatformLogger" line="66"/>
            <declaration name="logging" type="boolean" line="67"/>
            <scope line="70">
                <anonymous_class line="72">
                    <method name="run" type="Object" line="73">
                        <comment line="102">
                            Nothing to do here.                            
                        </comment>
                        <declaration name="osName" type="String" line="74"/>
                        <declaration name="t2kStr" type="String" line="79"/>
                        <scope line="80"/>
                        <scope line="82"/>
                        <scope line="85">
                            <declaration name="version" type="String" line="86"/>
                            <declaration name="ver" type="float" line="89"/>
                            <scope line="90">
                                <declaration name="f" type="File" line="91"/>
                                <declaration name="line" type="String" line="92"/>
                                <scope line="93">
                                    <declaration name="fis" type="FileInputStream" line="94"/>
                                    <declaration name="isr" type="InputStreamReader" line="95"/>
                                    <declaration name="br" type="BufferedReader" line="97"/>
                                </scope>
                                <scope line="100"/>
                                <scope line="103"/>
                                <scope line="105"/>
                            </scope>
                            <scope line="108"/>
                        </scope>
                        <scope line="111"/>
                        <declaration name="jreLibDirName" type="String" line="117"/>
                        <declaration name="jreFontDirName" type="String" line="119"/>
                        <declaration name="lucidaFile" type="File" line="121"/>
                        <declaration name="debugLevel" type="String" line="125"/>
                        <scope line="128">
                            <scope line="131"/>
                            <scope line="133"/>
                        </scope>
                        <scope line="138"/>
                    </method>
                </anonymous_class>
            </scope>
            <declaration name="MIN_LAYOUT_CHARCODE" type="int" line="148"/>
            <javadoc line="148">
                Referenced by code in the JDK which wants to test for the
                  minimum char code for which layout may be required.
                  Note that even basic latin text can benefit from ligatures,
                  eg &quot;ffi&quot; but we presently apply those only if explicitly
                  requested with TextAttribute.LIGATURES_ON.
                  The value here indicates the lowest char code for which failing
                  to invoke layout would prevent acceptable rendering.                
            </javadoc>
            <declaration name="MAX_LAYOUT_CHARCODE" type="int" line="159"/>
            <javadoc line="159">
                Referenced by code in the JDK which wants to test for the
                  maximum char code for which layout may be required.
                  Note this does not account for supplementary characters
                  where the caller interprets &apos;layout&apos; to mean any case where
                  one &apos;char&apos; (ie the java type char) does not map to one glyph                
            </javadoc>
            <javadoc line="168">
                Calls the private getFont2D() method in java.awt.Font objects.                
                <param>
                    font the font object to call                    
                </param>
                <return>
                    the Font2D object returned by Font.getFont2D()                    
                </return>
            </javadoc>
            <method name="getFont2D" type="Font2D" line="175">
                <params>
                    <param name="font" type="Font"/>
                </params>
            </method>
            <javadoc line="179">
                If there is anything in the text which triggers a case
                  where char-&gt;glyph does not map 1:1 in straightforward
                  left-&gt;right ordering, then this method returns true.
                  Scripts which might require it but are not treated as such
                  due to JDK implementations will not return true.
                  ie a &apos;true&apos; return is an indication of the treatment by
                  the implementation.
                  Whether supplementary characters should be considered is dependent
                  on the needs of the caller. Since this method accepts the &apos;char&apos; type
                  then such chars are always represented by a pair. From a rendering
                  perspective these will all (in the cases I know of) still be one
                  unicode character -&gt; one glyph. But if a caller is using this to
                  discover any case where it cannot make naive assumptions about
                  the number of chars, and how to index through them, then it may
                  need the option to have a &apos;true&apos; return in such a case.                
            </javadoc>
            <method name="isComplexText" type="boolean" line="196">
                <params>
                    <param name="chs" type="char[]"/>
                    <param name="start" type="int"/>
                    <param name="limit" type="int"/>
                </params>
                <scope line="198">
                    <scope line="199"/>
                    <scope line="202"/>
                </scope>
            </method>
            <method name="isNonSimpleChar" type="boolean" line="220">
                <params>
                    <param name="ch" type="char"/>
                </params>
            </method>
            <method name="isComplexCharCode" type="boolean" line="245">
                <params>
                    <param name="code" type="int"/>
                </params>
                <comment line="252">
                    Trigger layout for combining diacriticals 0x0300-&gt;0x036f                    
                </comment>
                <comment line="256">
                    No automatic layout for Greek, Cyrillic, Armenian.                    
                </comment>
                <comment line="260">
                    Hebrew 0590 - 05ff
                     Arabic 0600 - 06ff                    
                </comment>
                <comment line="265">
                    Syriac and Thaana                    
                </comment>
                <comment line="268">
                    if Indic, assume shaping for conjuncts, reordering:
                     0900 - 097F Devanagari
                     0980 - 09FF Bengali
                     0A00 - 0A7F Gurmukhi
                     0A80 - 0AFF Gujarati
                     0B00 - 0B7F Oriya
                     0B80 - 0BFF Tamil
                     0C00 - 0C7F Telugu
                     0C80 - 0CFF Kannada
                     0D00 - 0D7F Malayalam
                     0D80 - 0DFF Sinhala
                     0E00 - 0E7F if Thai, assume shaping for vowel, tone marks                    
                </comment>
                <comment line="285">
                    U+0F00 - U+0FFF Tibetan                    
                </comment>
                <comment line="291">
                    U+1100 - U+11FF Old Hangul                    
                </comment>
                <comment line="297">
                    1780 - 17FF Khmer                    
                </comment>
                <comment line="303">
                    zwj or zwnj                    
                </comment>
                <comment line="306">
                    directional control                    
                </comment>
                <comment line="309">
                    directional control                    
                </comment>
                <scope line="247"/>
                <scope line="250"/>
                <scope line="254"/>
                <scope line="258"/>
                <scope line="263"/>
                <scope line="266"/>
                <scope line="281"/>
                <scope line="284"/>
                <scope line="287"/>
                <scope line="290"/>
                <scope line="293"/>
                <scope line="296"/>
                <scope line="299"/>
                <scope line="302"/>
                <scope line="305"/>
                <scope line="308"/>
            </method>
            <method name="getLogger" type="PlatformLogger" line="314"/>
            <method name="isLogging" type="boolean" line="318"/>
            <method name="debugFonts" type="boolean" line="322"/>
            <method name="fontSupportsDefaultEncoding" type="boolean" line="333">
                <params>
                    <param name="font" type="Font"/>
                </params>
            </method>
            <declaration name="compMapRef" type="SoftReference&lt;ConcurrentHashMap&lt;PhysicalFont,CompositeFont&gt;&gt;" line="337"/>
            <javadoc line="337">
                This method is provided for internal and exclusive use by Swing.
                  It may be used in conjunction with fontSupportsDefaultEncoding(Font)
                  In the event that a desktop properties font doesn&apos;t directly
                  support the default encoding, (ie because the host OS supports
                  adding support for the current locale automatically for native apps),
                  then Swing calls this method to get a font which  uses the specified
                  font for the code points it covers, but also supports this locale
                  just as the standard composite fonts do.
                  Note: this will over-ride any setting where an application
                  specifies it prefers locale specific composite fonts.
                  The logic for this, is that this method is used only where the user or
                  application has specified that the native L&amp;F be used, and that
                  we should honour that request to use the same font as native apps use.
                  The behaviour of this method is to construct a new composite
                  Font object that uses the specified physical font as its first
                  component, and adds all the components of &quot;dialog&quot; as fall back
                  components.
                  The method currently assumes that only the size and style attributes
                  are set on the specified font. It doesn&apos;t copy the font transform or
                  other attributes because they aren&apos;t set on a font created from
                  the desktop. This will need to be fixed if use is broadened.
                  Operations such as Font.deriveFont will work properly on the
                  font returned by this method for deriving a different point size.
                  Additionally it tries to support a different style by calling
                  getNewComposite() below. That also supports replacing slot zero
                  with a different physical font but that is expected to be &quot;rare&quot;.
                  Deriving with a different style is needed because its been shown
                  that some applications try to do this for Swing FontUIResources.
                  Also operations such as new Font(font.getFontName(..), Font.PLAIN, 14);
                  will NOT yield the same result, as the new underlying CompositeFont
                  cannot be &quot;looked up&quot; in the font registry.
                  This returns a FontUIResource as that is the Font sub-class needed
                  by Swing.
                  Suggested usage is something like :
                  FontUIResource fuir;
                  Font desktopFont = getDesktopFont(..);
                  // NOTE even if fontSupportsDefaultEncoding returns true because
                  // you get Tahoma and are running in an English locale, you may
                  // still want to just call getCompositeFontUIResource() anyway
                  // as only then will you get fallback fonts - eg for CJK.
                  if (FontManager.fontSupportsDefaultEncoding(desktopFont)) {
                  fuir = new FontUIResource(..);
                  } else {
                  fuir = FontManager.getCompositeFontUIResource(desktopFont);
                  }
                  return fuir;                
            </javadoc>
            <method name="getCompositeFontUIResource" type="FontUIResource" line="392">
                <params>
                    <param name="font" type="Font"/>
                </params>
                <comment line="399">
                    Swing should only be calling this when a font is obtained
                     from desktop properties, so should generally be a physical font,
                     an exception might be for names like &quot;MS Serif&quot; which are
                     automatically mapped to &quot;Serif&quot;, so there&apos;s no need to do
                     anything special in that case. But note that suggested usage
                     is first to call fontSupportsDefaultEncoding(Font) and this
                     method should not be called if that were to return true.                    
                </comment>
                <comment line="414">
                                        
                </comment>
                <comment line="419">
                    Its been collected.                    
                </comment>
                <comment line="429">
                    marking this as a created font is needed as only created fonts
                     copy their creator&apos;s handles.                    
                </comment>
                <declaration name="fuir" type="FontUIResource" line="394"/>
                <declaration name="font2D" type="Font2D" line="395"/>
                <scope line="397"/>
                <declaration name="fm" type="FontManager" line="409"/>
                <declaration name="dialog2D" type="CompositeFont" line="410"/>
                <scope line="413"/>
                <declaration name="physicalFont" type="PhysicalFont" line="416"/>
                <declaration name="compMap" type="ConcurrentHashMap&lt;PhysicalFont,CompositeFont&gt;" line="417"/>
                <scope line="418"/>
                <declaration name="compFont" type="CompositeFont" line="422"/>
                <scope line="423"/>
            </method>
            <declaration name="nameMap" type="String[][]" line="438"/>
            <method name="mapFcName" type="String" line="445">
                <params>
                    <param name="name" type="String"/>
                </params>
                <scope line="446">
                    <scope line="447"/>
                </scope>
            </method>
            <method name="getFontConfigFUIR" type="FontUIResource" line="473">
                <params>
                    <param name="fcFamily" type="String"/>
                    <param name="style" type="int"/>
                    <param name="size" type="int"/>
                </params>
                <declaration name="mapped" type="String" line="475"/>
                <scope line="476"/>
                <declaration name="fuir" type="FontUIResource" line="480"/>
                <declaration name="fm" type="FontManager" line="481"/>
                <scope line="482">
                    <declaration name="sfm" type="SunFontManager" line="483"/>
                </scope>
                <scope line="485"/>
            </method>
            <javadoc line="492">
                Used by windows printing to assess if a font is likely to
                  be layout compatible with JDK
                  TrueType fonts should be, but if they have no GPOS table,
                  but do have a GSUB table, then they are probably older
                  fonts GDI handles differently.                
            </javadoc>
            <method name="textLayoutIsCompatible" type="boolean" line="499">
                <params>
                    <param name="font" type="Font"/>
                </params>
                <declaration name="font2D" type="Font2D" line="501"/>
                <scope line="502">
                    <declaration name="ttf" type="TrueTypeFont" line="503"/>
                </scope>
                <scope line="507"/>
            </method>
        </class>
    </source>