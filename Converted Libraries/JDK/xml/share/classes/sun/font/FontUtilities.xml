<?xml version="1.0" encoding="UTF-8"?>
    <source package="sun.font">
        <import package="java.awt.Font"/>
        <import package="java.io.BufferedReader"/>
        <import package="java.io.File"/>
        <import package="java.io.FileInputStream"/>
        <import package="java.io.InputStreamReader"/>
        <import package="java.lang.ref.SoftReference"/>
        <import package="java.util.concurrent.ConcurrentHashMap"/>
        <import package="java.security.AccessController"/>
        <import package="java.security.PrivilegedAction"/>
        <import package="javax.swing.plaf.FontUIResource"/>
        <import package="sun.util.logging.PlatformLogger"/>
        <class name="FontUtilities" line="13">
            <javadoc line="13">
                A collection of utility methods.                
            </javadoc>
            <declaration name="isSolaris" type="boolean" line="17"/>
            <declaration name="isLinux" type="boolean" line="18"/>
            <declaration name="isSolaris8" type="boolean" line="19"/>
            <declaration name="isSolaris9" type="boolean" line="20"/>
            <declaration name="isOpenSolaris" type="boolean" line="21"/>
            <declaration name="useT2K" type="boolean" line="22"/>
            <declaration name="isWindows" type="boolean" line="23"/>
            <declaration name="isOpenJDK" type="boolean" line="24"/>
            <declaration name="LUCIDA_FILE_NAME" type="String" line="25"/>
            <declaration name="debugFonts" type="boolean" line="26"/>
            <declaration name="logger" type="PlatformLogger" line="27"/>
            <declaration name="logging" type="boolean" line="28"/>
            <scope line="29">
                <anonymous_class line="30">
                    <method name="run" type="Object" line="31">
                        <declaration name="osName" type="String" line="32"/>
                        <declaration name="t2kStr" type="String" line="35"/>
                        <scope line="36"/>
                        <scope line="39"/>
                        <scope line="42">
                            <declaration name="version" type="String" line="43"/>
                            <declaration name="ver" type="float" line="46"/>
                            <scope line="47">
                                <declaration name="f" type="File" line="48"/>
                                <declaration name="line" type="String" line="49"/>
                                <scope line="50">
                                    <declaration name="fis" type="FileInputStream" line="51"/>
                                    <declaration name="isr" type="InputStreamReader" line="52"/>
                                    <declaration name="br" type="BufferedReader" line="53"/>
                                </scope>
                                <scope line="57"/>
                                <scope line="59"/>
                                <scope line="62"/>
                            </scope>
                            <scope line="66"/>
                        </scope>
                        <scope line="70"/>
                        <declaration name="jreLibDirName" type="String" line="76"/>
                        <declaration name="jreFontDirName" type="String" line="77"/>
                        <declaration name="lucidaFile" type="File" line="78"/>
                        <declaration name="debugLevel" type="String" line="80"/>
                        <scope line="81">
                            <scope line="84"/>
                            <scope line="87"/>
                        </scope>
                        <scope line="91"/>
                    </method>
                </anonymous_class>
            </scope>
            <declaration name="MIN_LAYOUT_CHARCODE" type="int" line="100"/>
            <javadoc line="100">
                Referenced by code in the JDK which wants to test for the
                  minimum char code for which layout may be required.
                  Note that even basic latin text can benefit from ligatures,
                  eg &quot;ffi&quot; but we presently apply those only if explicitly
                  requested with TextAttribute.LIGATURES_ON.
                  The value here indicates the lowest char code for which failing
                  to invoke layout would prevent acceptable rendering.                
            </javadoc>
            <declaration name="MAX_LAYOUT_CHARCODE" type="int" line="110"/>
            <javadoc line="110">
                Referenced by code in the JDK which wants to test for the
                  maximum char code for which layout may be required.
                  Note this does not account for supplementary characters
                  where the caller interprets &apos;layout&apos; to mean any case where
                  one &apos;char&apos; (ie the java type char) does not map to one glyph                
            </javadoc>
            <javadoc line="118">
                Calls the private getFont2D() method in java.awt.Font objects.                
                <param>
                    font the font object to call                    
                </param>
                <return>
                    the Font2D object returned by Font.getFont2D()                    
                </return>
            </javadoc>
            <method name="getFont2D" type="Font2D" line="123">
                <params>
                    <param name="font" type="Font"/>
                </params>
            </method>
            <javadoc line="126">
                If there is anything in the text which triggers a case
                  where char-&gt;glyph does not map 1:1 in straightforward
                  left-&gt;right ordering, then this method returns true.
                  Scripts which might require it but are not treated as such
                  due to JDK implementations will not return true.
                  ie a &apos;true&apos; return is an indication of the treatment by
                  the implementation.
                  Whether supplementary characters should be considered is dependent
                  on the needs of the caller. Since this method accepts the &apos;char&apos; type
                  then such chars are always represented by a pair. From a rendering
                  perspective these will all (in the cases I know of) still be one
                  unicode character -&gt; one glyph. But if a caller is using this to
                  discover any case where it cannot make naive assumptions about
                  the number of chars, and how to index through them, then it may
                  need the option to have a &apos;true&apos; return in such a case.                
            </javadoc>
            <method name="isComplexText" type="boolean" line="143">
                <params>
                    <param name="chs" type="char[]"/>
                    <param name="start" type="int"/>
                    <param name="limit" type="int"/>
                </params>
                <scope line="144">
                    <scope line="145"/>
                    <scope line="148"/>
                </scope>
            </method>
            <method name="isNonSimpleChar" type="boolean" line="154">
                <params>
                    <param name="ch" type="char"/>
                </params>
            </method>
            <method name="isComplexCharCode" type="boolean" line="157">
                <params>
                    <param name="code" type="int"/>
                </params>
                <scope line="158"/>
                <scope line="161"/>
                <scope line="164"/>
                <scope line="167"/>
                <scope line="170"/>
                <scope line="173"/>
                <scope line="176"/>
                <scope line="179"/>
                <scope line="182"/>
                <scope line="185"/>
                <scope line="188"/>
                <scope line="191"/>
                <scope line="194"/>
                <scope line="197"/>
                <scope line="200"/>
                <scope line="203"/>
            </method>
            <method name="getLogger" type="PlatformLogger" line="208"/>
            <method name="isLogging" type="boolean" line="211"/>
            <method name="debugFonts" type="boolean" line="214"/>
            <method name="fontSupportsDefaultEncoding" type="boolean" line="217">
                <params>
                    <param name="font" type="Font"/>
                </params>
            </method>
            <declaration name="compMapRef" type="SoftReference&lt;ConcurrentHashMap&lt;PhysicalFont,CompositeFont&gt;&gt;" line="220"/>
            <javadoc line="220">
                This method is provided for internal and exclusive use by Swing.
                  It may be used in conjunction with fontSupportsDefaultEncoding(Font)
                  In the event that a desktop properties font doesn&apos;t directly
                  support the default encoding, (ie because the host OS supports
                  adding support for the current locale automatically for native apps),
                  then Swing calls this method to get a font which  uses the specified
                  font for the code points it covers, but also supports this locale
                  just as the standard composite fonts do.
                  Note: this will over-ride any setting where an application
                  specifies it prefers locale specific composite fonts.
                  The logic for this, is that this method is used only where the user or
                  application has specified that the native L&amp;F be used, and that
                  we should honour that request to use the same font as native apps use.
                  The behaviour of this method is to construct a new composite
                  Font object that uses the specified physical font as its first
                  component, and adds all the components of &quot;dialog&quot; as fall back
                  components.
                  The method currently assumes that only the size and style attributes
                  are set on the specified font. It doesn&apos;t copy the font transform or
                  other attributes because they aren&apos;t set on a font created from
                  the desktop. This will need to be fixed if use is broadened.
                  Operations such as Font.deriveFont will work properly on the
                  font returned by this method for deriving a different point size.
                  Additionally it tries to support a different style by calling
                  getNewComposite() below. That also supports replacing slot zero
                  with a different physical font but that is expected to be &quot;rare&quot;.
                  Deriving with a different style is needed because its been shown
                  that some applications try to do this for Swing FontUIResources.
                  Also operations such as new Font(font.getFontName(..), Font.PLAIN, 14);
                  will NOT yield the same result, as the new underlying CompositeFont
                  cannot be &quot;looked up&quot; in the font registry.
                  This returns a FontUIResource as that is the Font sub-class needed
                  by Swing.
                  Suggested usage is something like :
                  FontUIResource fuir;
                  Font desktopFont = getDesktopFont(..);
                  // NOTE even if fontSupportsDefaultEncoding returns true because
                  // you get Tahoma and are running in an English locale, you may
                  // still want to just call getCompositeFontUIResource() anyway
                  // as only then will you get fallback fonts - eg for CJK.
                  if (FontManager.fontSupportsDefaultEncoding(desktopFont)) {
                  fuir = new FontUIResource(..);
                  } else {
                  fuir = FontManager.getCompositeFontUIResource(desktopFont);
                  }
                  return fuir;                
            </javadoc>
            <method name="getCompositeFontUIResource" type="FontUIResource" line="269">
                <params>
                    <param name="font" type="Font"/>
                </params>
                <declaration name="fuir" type="FontUIResource" line="270"/>
                <declaration name="font2D" type="Font2D" line="271"/>
                <scope line="272"/>
                <declaration name="fm" type="FontManager" line="275"/>
                <declaration name="dialog2D" type="CompositeFont" line="276"/>
                <scope line="277"/>
                <declaration name="physicalFont" type="PhysicalFont" line="280"/>
                <declaration name="compMap" type="ConcurrentHashMap&lt;PhysicalFont,CompositeFont&gt;" line="281"/>
                <scope line="282"/>
                <declaration name="compFont" type="CompositeFont" line="286"/>
                <scope line="287"/>
            </method>
            <declaration name="nameMap" type="String[][]" line="295"/>
            <method name="mapFcName" type="String" line="296">
                <params>
                    <param name="name" type="String"/>
                </params>
                <scope line="297">
                    <scope line="298"/>
                </scope>
            </method>
            <method name="getFontConfigFUIR" type="FontUIResource" line="304">
                <params>
                    <param name="fcFamily" type="String"/>
                    <param name="style" type="int"/>
                    <param name="size" type="int"/>
                </params>
                <declaration name="mapped" type="String" line="305"/>
                <scope line="306"/>
                <declaration name="fuir" type="FontUIResource" line="309"/>
                <declaration name="fm" type="FontManager" line="310"/>
                <scope line="311">
                    <declaration name="sfm" type="SunFontManager" line="312"/>
                </scope>
                <scope line="315"/>
            </method>
            <javadoc line="320">
                Used by windows printing to assess if a font is likely to
                  be layout compatible with JDK
                  TrueType fonts should be, but if they have no GPOS table,
                  but do have a GSUB table, then they are probably older
                  fonts GDI handles differently.                
            </javadoc>
            <method name="textLayoutIsCompatible" type="boolean" line="327">
                <params>
                    <param name="font" type="Font"/>
                </params>
                <declaration name="font2D" type="Font2D" line="328"/>
                <scope line="329">
                    <declaration name="ttf" type="TrueTypeFont" line="330"/>
                </scope>
                <scope line="333"/>
            </method>
        </class>
    </source>