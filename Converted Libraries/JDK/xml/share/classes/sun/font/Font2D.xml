<?xml version="1.0" encoding="UTF-8"?>
    <source package="sun.font">
        <import package="java.awt.Font"/>
        <import package="java.awt.font.FontRenderContext"/>
        <import package="java.awt.geom.AffineTransform"/>
        <import package="java.lang.ref.Reference"/>
        <import package="java.lang.ref.SoftReference"/>
        <import package="java.util.concurrent.ConcurrentHashMap"/>
        <import package="java.util.Locale"/>
        <class name="Font2D" line="36">
            <comment line="39">
                Note: JRE and FONT_CONFIG ranks are identical. I don&apos;t know of a reason
                 to distingish these. Possibly if a user adds fonts to the JRE font
                 directory that are the same font as the ones specified in the font
                 configuration but that is more likely to be the legitimate intention
                 than a problem. One reason why these should be the same is that on
                 Linux the JRE fonts ARE the font configuration fonts, and although I
                 believe all are assigned FONT_CONFIG rank, it is conceivable that if
                 this were not so, that some JRE font would not be allowed to joint the
                 family of its siblings which were assigned FONT_CONFIG rank. Giving
                 them the same rank is the easy solution for now at least.                
            </comment>
            <comment line="73">
                                
            </comment>
            <comment line="74">
                                
            </comment>
            <comment line="79">
                A mapper can be independent of the strike.
                 Perhaps the reference to the mapper ought to be held on the
                 scaler, as it may be implemented via scaler functionality anyway
                 and so the mapper would be useless if its native portion was
                 freed when the scaler was GC&apos;d.                
            </comment>
            <comment line="88">
                The strike cache is maintained per &quot;Font2D&quot; as that is the
                 principal object by which you look up fonts.
                 It means more Hashmaps, but look ups can be quicker because
                 the map will have fewer entries, and there&apos;s no need to try to
                 make the Font2D part of the key.                
            </comment>
            <comment line="98">
                Store the last Strike in a Reference object.
                 Similarly to the strike that was stored on a C++ font object,
                 this is an optimisation which helps if multiple clients (ie
                 typically SunGraphics2D instances) are using the same font, then
                 as may be typical of many UIs, they are probably using it in the
                 same style, so it can be a win to first quickly check if the last
                 strike obtained from this Font2D satifies the needs of the next
                 client too.
                 This pre-supposes that a FontStrike is a shareable object, which
                 it should.                
            </comment>
            <comment line="111">
                POSSIBLE OPTIMISATION:
                 Array of length 1024 elements of 64 bits indicating if a font
                 contains these. This kind of information can be shared between
                 all point sizes.
                 if corresponding bit in knownBitmaskMap is set then canDisplayBitmaskMap
                 is valid. This is 16Kbytes of data per composite font style.
                 What about UTF-32 and surrogates?
                 REMIND: This is too much storage. Probably can only cache this
                 information for latin range, although possibly OK to store all
                 for just the &quot;logical&quot; fonts.
                 Or instead store arrays of subranges of 1024 bits (128 bytes) in
                 the range below surrogate pairs.                
            </comment>
            <comment line="125">
                protected long[] knownBitmaskMap;                
            </comment>
            <comment line="126">
                protected long[] canDisplayBitmaskMap;                
            </comment>
            <comment line="128">
                Returns the &quot;real&quot; style of this Font2D. Eg the font face
                 Lucida Sans Bold&quot; has a real style of Font.BOLD, even though
                 it may be able to used to simulate bold italic                
            </comment>
            <comment line="174">
                This isn&apos;t very efficient but its infrequently used.
                 StandardGlyphVector uses it when the client assigns the glyph codes.
                 These may not be valid. This validates them substituting the missing
                 glyph elsewhere.                
            </comment>
            <comment line="186">
                Creates an appropriate strike for the Font2D subclass                
            </comment>
            <comment line="191">
                this may be useful for APIs like canDisplay where the answer
                 is dependent on the font and its scaler, but not the strike.
                 If no strike has ever been returned, then create a one that matches
                 this font with the default FRC. It will become the lastStrike and
                 there&apos;s a good chance that the next call will be to get exactly that
                 strike.                
            </comment>
            <comment line="207">
                SunGraphics2D has font, tx, aa and fm. From this info
                 can get a Strike object from the cache, creating it if necessary.
                 This code is designed for multi-threaded access.
                 For that reason it creates a local FontStrikeDesc rather than filling
                 in a shared one. Up to two AffineTransforms and one FontStrikeDesc will
                 be created by every lookup. This appears to perform more than
                 adequately. But it may make sense to expose FontStrikeDesc
                 as a parameter so a caller can use its own.
                 In such a case if a FontStrikeDesc is stored as a key then
                 we would need to use a private copy.
                
                 Note that this code doesn&apos;t prevent two threads from creating
                 two different FontStrike instances and having one of the threads
                 overwrite the other in the map. This is likely to be a rare
                 occurrence and the only consequence is that these callers will have
                 different instances of the strike, and there&apos;d be some duplication of
                 population of the strikes. However since users of these strikes are
                 transient, then the one that was overwritten would soon be freed.
                 If there is any problem then a small synchronized block would be
                 required with its attendant consequences for MP scaleability.                
            </comment>
            <comment line="446">
                Currently the layout code calls this. May be better for layout code
                 to check the font class before attempting to run, rather than needing
                 to promote this method up from TrueTypeFont                
            </comment>
            <comment line="454">
                                
            </comment>
            <comment line="467">
                All the important subclasses override this which is principally for
                 the TrueType &apos;gasp&apos; table.                
            </comment>
            <comment line="479">
                                
            </comment>
            <declaration name="FONT_CONFIG_RANK" type="int" line="49"/>
            <declaration name="JRE_RANK" type="int" line="50"/>
            <declaration name="TTF_RANK" type="int" line="51"/>
            <declaration name="TYPE1_RANK" type="int" line="52"/>
            <declaration name="NATIVE_RANK" type="int" line="53"/>
            <declaration name="UNKNOWN_RANK" type="int" line="54"/>
            <declaration name="DEFAULT_RANK" type="int" line="55"/>
            <declaration name="boldNames" type="String[]" line="57"/>
            <declaration name="italicNames" type="String[]" line="60"/>
            <declaration name="boldItalicNames" type="String[]" line="63"/>
            <declaration name="DEFAULT_FRC" type="FontRenderContext" line="68"/>
            <declaration name="handle" type="Font2DHandle" line="71"/>
            <declaration name="familyName" type="String" line="72"/>
            <declaration name="fullName" type="String" line="73"/>
            <declaration name="style" type="int" line="74"/>
            <declaration name="family" type="FontFamily" line="75"/>
            <declaration name="fontRank" type="int" line="76"/>
            <declaration name="mapper" type="CharToGlyphMapper" line="85"/>
            <declaration name="strikeCache" type="ConcurrentHashMap&lt;FontStrikeDesc,Reference&gt;" line="94"/>
            <declaration name="lastFontStrike" type="Reference" line="108"/>
            <method name="getStyle" type="int" line="131"/>
            <method name="setStyle" type="void" line="134">
                <declaration name="fName" type="String" line="136"/>
                <scope line="138">
                    <scope line="139"/>
                </scope>
                <scope line="145">
                    <scope line="146"/>
                </scope>
                <scope line="152">
                    <scope line="153"/>
                </scope>
            </method>
            <method name="getRank" type="int" line="161"/>
            <method name="setRank" type="void" line="165">
                <params>
                    <param name="rank" type="int"/>
                </params>
            </method>
            <method name="getMapper" type="CharToGlyphMapper" line="169"/>
            <method name="getValidatedGlyphCode" type="int" line="178">
                <params>
                    <param name="glyphCode" type="int"/>
                </params>
                <scope line="179"/>
            </method>
            <method name="createStrike" type="FontStrike" line="188"/>
            <method name="getStrike" type="FontStrike" line="197">
                <params>
                    <param name="font" type="Font"/>
                </params>
                <declaration name="strike" type="FontStrike" line="198"/>
                <scope line="199"/>
                <scope line="201"/>
            </method>
            <method name="getStrike" type="FontStrike" line="228">
                <params>
                    <param name="font" type="Font"/>
                    <param name="devTx" type="AffineTransform"/>
                    <param name="aa" type="int"/>
                    <param name="fm" type="int"/>
                </params>
                <comment line="230">
                    Create the descriptor which is used to identify a strike
                     in the strike cachemap. A strike is fully described by
                     the attributes of this descriptor.                    
                </comment>
                <comment line="234">
                    REMIND: generating garbage and doing computation here in order
                     to include pt size in the tx just for a lookup! Figure out a
                     better way.                    
                </comment>
                <declaration name="ptSize" type="double" line="238"/>
                <declaration name="glyphTx" type="AffineTransform" line="239"/>
                <scope line="241"/>
                <scope line="244"/>
                <declaration name="desc" type="FontStrikeDesc" line="251"/>
            </method>
            <method name="getStrike" type="FontStrike" line="258">
                <params>
                    <param name="font" type="Font"/>
                    <param name="devTx" type="AffineTransform"/>
                    <param name="glyphTx" type="AffineTransform"/>
                    <param name="aa" type="int"/>
                    <param name="fm" type="int"/>
                </params>
                <comment line="260">
                    Create the descriptor which is used to identify a strike
                     in the strike cachemap. A strike is fully described by
                     the attributes of this descriptor.                    
                </comment>
                <declaration name="desc" type="FontStrikeDesc" line="264"/>
            </method>
            <method name="getStrike" type="FontStrike" line="269">
                <params>
                    <param name="font" type="Font"/>
                    <param name="frc" type="FontRenderContext"/>
                </params>
                <declaration name="at" type="AffineTransform" line="271"/>
                <declaration name="ptSize" type="double" line="272"/>
                <scope line="274">
                    <scope line="276"/>
                </scope>
                <declaration name="aa" type="int" line="284"/>
                <declaration name="fm" type="int" line="285"/>
                <declaration name="desc" type="FontStrikeDesc" line="286"/>
            </method>
            <method name="getStrike" type="FontStrike" line="292">
                <params>
                    <param name="desc" type="FontStrikeDesc"/>
                </params>
            </method>
            <method name="getStrike" type="FontStrike" line="296">
                <params>
                    <param name="desc" type="FontStrikeDesc"/>
                    <param name="copy" type="boolean"/>
                </params>
                <comment line="297">
                    Before looking in the map, see if the descriptor matches the
                     last strike returned from this Font2D. This should often be a win
                     since its common for the same font, in the same size to be
                     used frequently, for example in many parts of a UI.
                    
                     If its not the same then we use the descriptor to locate a
                     Reference to the strike. If it exists and points to a strike,
                     then we update the last strike to refer to that and return it.
                    
                     If the key isn&apos;t in the map, or its reference object has been
                     collected, then we create a new strike, put it in the map and
                     set it to be the last strike.                    
                </comment>
                <comment line="312">
                    strike.lastlookupTime = System.currentTimeMillis();                    
                </comment>
                <comment line="319">
                    strike.lastlookupTime = System.currentTimeMillis();                    
                </comment>
                <comment line="325">
                    When we create a new FontStrike instance, we must
                     ask the StrikeCache for a reference. We must then ensure
                     this reference remains reachable, by storing it in the
                     Font2D&apos;s strikeCache map.
                     So long as the Reference is there (reachable) then if the
                     reference is cleared, it will be enqueued for disposal.
                     If for some reason we explicitly remove this reference, it
                     must only be done when holding a strong reference to the
                     referent (the FontStrike), or if the reference is cleared,
                     then we must explicitly &quot;dispose&quot; of the native resources.
                     The only place this currently happens is in this same method,
                     where we find a cleared reference and need to overwrite it
                     here with a new reference.
                     Clearing the whilst holding a strong reference, should only
                     be done if the                    
                </comment>
                <comment line="345">
                    StrikeCache.addStrike();                    
                </comment>
                <comment line="346">
                    If we are creating many strikes on this font which
                     involve non-quadrant rotations, or more general
                     transforms which include shears, then force the use
                     of weak references rather than soft references.
                     This means that it won&apos;t live much beyond the next GC,
                     which is what we want for what is likely a transient strike.                    
                </comment>
                <comment line="362">
                    strike.lastlookupTime = System.currentTimeMillis();                    
                </comment>
                <declaration name="strike" type="FontStrike" line="310"/>
                <scope line="311"/>
                <scope line="314">
                    <declaration name="strikeRef" type="Reference" line="315"/>
                    <scope line="316">
                        <scope line="318"/>
                    </scope>
                    <scope line="341"/>
                    <declaration name="txType" type="int" line="353"/>
                    <scope line="356"/>
                    <scope line="358"/>
                </scope>
            </method>
            <method name="removeFromCache" type="void" line="369">
                <params>
                    <param name="desc" type="FontStrikeDesc"/>
                </params>
                <declaration name="ref" type="Reference" line="370"/>
                <scope line="371">
                    <declaration name="o" type="Object" line="372"/>
                    <scope line="373"/>
                </scope>
            </method>
            <javadoc line="379">
                The length of the metrics array must be &gt;= 8.  This method will
                  store the following elements in that array before returning:
                  metrics[0]: ascent
                  metrics[1]: descent
                  metrics[2]: leading
                  metrics[3]: max advance
                  metrics[4]: strikethrough offset
                  metrics[5]: strikethrough thickness
                  metrics[6]: underline offset
                  metrics[7]: underline thickness                
            </javadoc>
            <method name="getFontMetrics" type="void" line="393">
                <params>
                    <param name="font" type="Font"/>
                    <param name="at" type="AffineTransform"/>
                    <param name="aaHint" type="Object"/>
                    <param name="fmHint" type="Object"/>
                    <param name="metrics" type="float"/>
                </params>
                <comment line="394">
                    This is called in just one place in Font with &quot;at&quot; == identity.
                     Perhaps this can be eliminated.                    
                </comment>
                <declaration name="aa" type="int" line="397"/>
                <declaration name="fm" type="int" line="398"/>
                <declaration name="strike" type="FontStrike" line="399"/>
                <declaration name="strikeMetrics" type="StrikeMetrics" line="400"/>
            </method>
            <javadoc line="409">
                The length of the metrics array must be &gt;= offset+4, and offset must be
                  &gt;= 0.  Typically offset is 4.  This method will
                  store the following elements in that array before returning:
                  metrics[off+0]: strikethrough offset
                  metrics[off+1]: strikethrough thickness
                  metrics[off+2]: underline offset
                  metrics[off+3]: underline thickness
                  Note that this implementation simply returns default values;
                  subclasses can override this method to provide more accurate values.                
            </javadoc>
            <method name="getStyleMetrics" type="void" line="421">
                <params>
                    <param name="pointSize" type="float"/>
                    <param name="metrics" type="float[]"/>
                    <param name="offset" type="int"/>
                </params>
            </method>
            <javadoc line="428">
                The length of the metrics array must be &gt;= 4.  This method will
                  store the following elements in that array before returning:
                  metrics[0]: ascent
                  metrics[1]: descent
                  metrics[2]: leading
                  metrics[3]: max advance                
            </javadoc>
            <method name="getFontMetrics" type="void" line="437">
                <params>
                    <param name="font" type="Font"/>
                    <param name="frc" type="FontRenderContext"/>
                    <param name="metrics" type="float"/>
                </params>
                <declaration name="strikeMetrics" type="StrikeMetrics" line="438"/>
            </method>
            <method name="getTableBytes" type="byte[]" line="449">
                <params>
                    <param name="tag" type="int"/>
                </params>
            </method>
            <method name="getUnitsPerEm" type="long" line="454"/>
            <method name="supportsEncoding" type="boolean" line="458">
                <params>
                    <param name="encoding" type="String"/>
                </params>
            </method>
            <method name="canDoStyle" type="boolean" line="462">
                <params>
                    <param name="style" type="int"/>
                </params>
            </method>
            <method name="useAAForPtSize" type="boolean" line="470">
                <params>
                    <param name="ptsize" type="int"/>
                </params>
            </method>
            <method name="hasSupplementaryChars" type="boolean" line="474"/>
            <method name="getPostscriptName" type="String" line="479"/>
            <method name="getFontName" type="String" line="483">
                <params>
                    <param name="l" type="Locale"/>
                </params>
            </method>
            <method name="getFamilyName" type="String" line="487">
                <params>
                    <param name="l" type="Locale"/>
                </params>
            </method>
            <method name="getNumGlyphs" type="int" line="491"/>
            <method name="charToGlyph" type="int" line="495">
                <params>
                    <param name="wchar" type="int"/>
                </params>
            </method>
            <method name="getMissingGlyphCode" type="int" line="499"/>
            <method name="canDisplay" type="boolean" line="503">
                <params>
                    <param name="c" type="char"/>
                </params>
            </method>
            <method name="canDisplay" type="boolean" line="507">
                <params>
                    <param name="cp" type="int"/>
                </params>
            </method>
            <method name="getBaselineFor" type="byte" line="511">
                <params>
                    <param name="c" type="char"/>
                </params>
            </method>
            <method name="getItalicAngle" type="float" line="516">
                <params>
                    <param name="font" type="Font"/>
                    <param name="at" type="AffineTransform"/>
                    <param name="aaHint" type="Object"/>
                    <param name="fmHint" type="Object"/>
                </params>
                <comment line="517">
                    hardwire psz=12 as that&apos;s typical and AA vs non-AA for &apos;gasp&apos; mode
                     isn&apos;t important for the caret slope of this rarely used API.                    
                </comment>
                <comment line="527">
                    ascent is &quot;up&quot; from the baseline so its typically
                     a negative value, so we need to compensate                    
                </comment>
                <declaration name="aa" type="int" line="520"/>
                <declaration name="fm" type="int" line="521"/>
                <declaration name="strike" type="FontStrike" line="522"/>
                <declaration name="metrics" type="StrikeMetrics" line="523"/>
                <scope line="524"/>
                <scope line="526"/>
            </method>
        </class>
    </source>