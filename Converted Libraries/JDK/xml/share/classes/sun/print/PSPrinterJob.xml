<?xml version="1.0" encoding="UTF-8"?>
    <source package="sun.print">
        <import package="java.awt.Color"/>
        <import package="java.awt.Component"/>
        <import package="java.awt.Font"/>
        <import package="java.awt.FontMetrics"/>
        <import package="java.awt.GraphicsEnvironment"/>
        <import package="java.awt.Graphics"/>
        <import package="java.awt.Graphics2D"/>
        <import package="java.awt.HeadlessException"/>
        <import package="java.awt.Rectangle"/>
        <import package="java.awt.Shape"/>
        <import package="java.awt.image.BufferedImage"/>
        <import package="java.awt.font.FontRenderContext"/>
        <import package="java.awt.geom.AffineTransform"/>
        <import package="java.awt.geom.PathIterator"/>
        <import package="java.awt.geom.Rectangle2D"/>
        <import package="java.awt.image.BufferedImage"/>
        <import package="java.awt.print.Pageable"/>
        <import package="java.awt.print.PageFormat"/>
        <import package="java.awt.print.Paper"/>
        <import package="java.awt.print.Printable"/>
        <import package="java.awt.print.PrinterException"/>
        <import package="java.awt.print.PrinterIOException"/>
        <import package="java.awt.print.PrinterJob"/>
        <import package="javax.print.DocFlavor"/>
        <import package="javax.print.PrintService"/>
        <import package="javax.print.StreamPrintService"/>
        <import package="javax.print.attribute.HashPrintRequestAttributeSet"/>
        <import package="javax.print.attribute.PrintRequestAttributeSet"/>
        <import package="javax.print.attribute.standard.Chromaticity"/>
        <import package="javax.print.attribute.standard.Copies"/>
        <import package="javax.print.attribute.standard.Destination"/>
        <import package="javax.print.attribute.standard.DialogTypeSelection"/>
        <import package="javax.print.attribute.standard.JobName"/>
        <import package="javax.print.attribute.standard.Sides"/>
        <import package="java.io.BufferedInputStream"/>
        <import package="java.io.BufferedOutputStream"/>
        <import package="java.io.CharConversionException"/>
        <import package="java.io.File"/>
        <import package="java.io.InputStream"/>
        <import package="java.io.IOException"/>
        <import package="java.io.FileInputStream"/>
        <import package="java.io.FileOutputStream"/>
        <import package="java.io.OutputStream"/>
        <import package="java.io.PrintStream"/>
        <import package="java.util.ArrayList"/>
        <import package="java.util.Enumeration"/>
        <import package="java.util.Locale"/>
        <import package="java.util.Properties"/>
        <import package="sun.awt.CharsetString"/>
        <import package="sun.awt.FontConfiguration"/>
        <import package="sun.awt.FontDescriptor"/>
        <import package="sun.awt.PlatformFont"/>
        <import package="sun.awt.SunToolkit"/>
        <import package="sun.font.FontManagerFactory"/>
        <import package="sun.font.FontUtilities"/>
        <import package="java.nio.charset"/>
        <import package="java.nio.CharBuffer"/>
        <import package="java.nio.ByteBuffer"/>
        <import package="java.lang.reflect.Method"/>
        <class name="PSPrinterJob" line="100">
            <extends class="RasterPrinterJob"/>
            <comment line="108">
                                
            </comment>
            <comment line="124">
                PostScript has a 64K maximum on its strings.                
            </comment>
            <comment line="254">
                                
            </comment>
            <comment line="272">
                                
            </comment>
            <comment line="286">
                                
            </comment>
            <comment line="336">
                                
            </comment>
            <comment line="349">
                Initialize PostScript font properties.
                 Copied from PSPrintStream                
            </comment>
            <comment line="403">
                                
            </comment>
            <comment line="409">
                                
            </comment>
            <comment line="645">
                Inner class to run &quot;privileged&quot; to open the printer output stream.                
            </comment>
            <comment line="672">
                Inner class to run &quot;privileged&quot; to invoke the system print command                
            </comment>
            <comment line="1160">
                return of 0 means unsupported. Other return indicates the number
                 of distinct PS fonts needed to draw this text. This saves us
                 doing this processing one extra time.                
            </comment>
            <comment line="1592">
                Currently CharToByteConverter.getCharacterEncoding() return values are
                 not fixed yet. These are used as the part of the key of
                 psfont.propeties. When those name are fixed this routine can
                 be erased.                
            </comment>
            <comment line="1862">
                Fill the path defined by &lt;code&gt;pathIter&lt;code&gt;
                 with the specified color.
                 The path is provided in current user space.                
            </comment>
            <comment line="1884">
                Run length encode byte array in a form suitable for decoding
                 by the PS Level 2 filter RunLengthDecode.
                 Array data to encode is inArr. Encoded data is written to outArr
                 outArr must be long enough to hold the encoded data but this
                 can&apos;t be known ahead of time.
                 A safe assumption is to use double the length of the input array.
                 This is then copied into a new array of the correct length which
                 is returned.
                 Algorithm:
                 Encoding is a lead byte followed by data bytes.
                 Lead byte of 0-&gt;127 indicates leadByte + 1 distinct bytes follow
                 Lead byte of 129-&gt;255 indicates 257 - leadByte is the number of times
                 the following byte is repeated in the source.
                 128 is a special lead byte indicating end of data (EOD) and is
                 written as the final byte of the returned encoded data.                
            </comment>
            <comment line="1946">
                written acc. to Adobe Spec. &quot;Filtered Files: ASCIIEncode Filter&quot;,
                 &quot;PS Language Reference Manual, 2nd edition: Section 3.13&quot;                
            </comment>
            <comment line="2117">
                This class can take an application-client supplied printable object
                 and send the result to a stream.
                 The application does not need to send any postscript to this stream
                 unless it needs to specify a translation etc.
                 It assumes that its importing application obeys all the conventions
                 for importation of EPS. See Appendix H - Encapsulated Postscript File
                 Format - of the Adobe Postscript Language Reference Manual, 2nd edition.
                 This class could be used as the basis for exposing the ability to
                 generate EPSF from 2D graphics as a StreamPrintService.
                 In that case a MediaPrintableArea attribute could be used to
                 communicate the bounding box.                
            </comment>
            <javadoc line="100">
                A class which initiates and executes a PostScript printer job.                
                <author>
                    Richard Blanchard                    
                </author>
            </javadoc>
            <declaration name="FILL_EVEN_ODD" type="int" line="109"/>
            <javadoc line="109">
                Passed to the &lt;code&gt;setFillMode&lt;/code&gt;
                  method this value forces fills to be
                  done using the even-odd fill rule.                
            </javadoc>
            <declaration name="FILL_WINDING" type="int" line="116"/>
            <javadoc line="116">
                Passed to the &lt;code&gt;setFillMode&lt;/code&gt;
                  method this value forces fills to be
                  done using the non-zero winding rule.                
            </javadoc>
            <declaration name="MAX_PSSTR" type="int" line="125"/>
            <declaration name="RED_MASK" type="int" line="127"/>
            <declaration name="GREEN_MASK" type="int" line="128"/>
            <declaration name="BLUE_MASK" type="int" line="129"/>
            <declaration name="RED_SHIFT" type="int" line="131"/>
            <declaration name="GREEN_SHIFT" type="int" line="132"/>
            <declaration name="BLUE_SHIFT" type="int" line="133"/>
            <declaration name="LOWNIBBLE_MASK" type="int" line="135"/>
            <declaration name="HINIBBLE_MASK" type="int" line="136"/>
            <declaration name="HINIBBLE_SHIFT" type="int" line="137"/>
            <declaration name="hexDigits" type="byte" line="138"/>
            <declaration name="PS_XRES" type="int" line="145"/>
            <declaration name="PS_YRES" type="int" line="146"/>
            <declaration name="ADOBE_PS_STR" type="String" line="148"/>
            <declaration name="EOF_COMMENT" type="String" line="149"/>
            <declaration name="PAGE_COMMENT" type="String" line="150"/>
            <declaration name="READIMAGEPROC" type="String" line="152"/>
            <declaration name="COPIES" type="String" line="156"/>
            <declaration name="PAGE_SAVE" type="String" line="157"/>
            <declaration name="PAGE_RESTORE" type="String" line="158"/>
            <declaration name="SHOWPAGE" type="String" line="159"/>
            <declaration name="IMAGE_SAVE" type="String" line="160"/>
            <declaration name="IMAGE_STR" type="String" line="161"/>
            <declaration name="IMAGE_RESTORE" type="String" line="162"/>
            <declaration name="COORD_PREP" type="String" line="164"/>
            <declaration name="SetFontName" type="String" line="171"/>
            <declaration name="DrawStringName" type="String" line="173"/>
            <declaration name="EVEN_ODD_FILL_STR" type="String" line="175"/>
            <javadoc line="175">
                The PostScript invocation to fill a path using the
                  even-odd rule. (eofill)                
            </javadoc>
            <declaration name="WINDING_FILL_STR" type="String" line="181"/>
            <javadoc line="181">
                The PostScript invocation to fill a path using the
                  non-zero winding rule. (fill)                
            </javadoc>
            <declaration name="EVEN_ODD_CLIP_STR" type="String" line="187"/>
            <javadoc line="187">
                The PostScript to set the clip to be the current path
                  using the even odd rule. (eoclip)                
            </javadoc>
            <declaration name="WINDING_CLIP_STR" type="String" line="193"/>
            <javadoc line="193">
                The PostScript to set the clip to be the current path
                  using the non-zero winding rule. (clip)                
            </javadoc>
            <declaration name="MOVETO_STR" type="String" line="199"/>
            <javadoc line="199">
                Expecting two numbers on the PostScript stack, this
                  invocation moves the current pen position. (moveto)                
            </javadoc>
            <declaration name="LINETO_STR" type="String" line="204"/>
            <javadoc line="204">
                Expecting two numbers on the PostScript stack, this
                  invocation draws a PS line from the current pen
                  position to the point on the stack. (lineto)                
            </javadoc>
            <declaration name="CURVETO_STR" type="String" line="211"/>
            <javadoc line="211">
                This PostScript operator takes two control points
                  and an ending point and using the current pen
                  position as a starting point adds a bezier
                  curve to the current path. (curveto)                
            </javadoc>
            <declaration name="GRESTORE_STR" type="String" line="219"/>
            <javadoc line="219">
                The PostScript to pop a state off of the printer&apos;s
                  gstate stack. (grestore)                
            </javadoc>
            <declaration name="GSAVE_STR" type="String" line="224"/>
            <javadoc line="224">
                The PostScript to push a state on to the printer&apos;s
                  gstate stack. (gsave)                
            </javadoc>
            <declaration name="NEWPATH_STR" type="String" line="230"/>
            <javadoc line="230">
                Make the current PostScript path an empty path. (newpath)                
            </javadoc>
            <declaration name="CLOSEPATH_STR" type="String" line="235"/>
            <javadoc line="235">
                Close the current subpath by generating a line segment
                  from the current position to the start of the subpath. (closepath)                
            </javadoc>
            <declaration name="SETRGBCOLOR_STR" type="String" line="241"/>
            <javadoc line="241">
                Use the three numbers on top of the PS operator
                  stack to set the rgb color. (setrgbcolor)                
            </javadoc>
            <declaration name="SETGRAY_STR" type="String" line="247"/>
            <javadoc line="247">
                Use the top number on the stack to set the printer&apos;s
                  current gray value. (setgray)                
            </javadoc>
            <declaration name="mDestType" type="int" line="255"/>
            <declaration name="mDestination" type="String" line="257"/>
            <declaration name="mNoJobSheet" type="boolean" line="259"/>
            <declaration name="mOptions" type="String" line="261"/>
            <declaration name="mLastFont" type="Font" line="263"/>
            <declaration name="mLastColor" type="Color" line="265"/>
            <declaration name="mLastClip" type="Shape" line="267"/>
            <declaration name="mLastTransform" type="AffineTransform" line="269"/>
            <declaration name="epsPrinter" type="EPSPrinter" line="272"/>
            <declaration name="mCurMetrics" type="FontMetrics" line="274"/>
            <javadoc line="274">
                The metrics for the font currently set.                
            </javadoc>
            <declaration name="mPSStream" type="PrintStream" line="279"/>
            <javadoc line="279">
                The output stream to which the generated PostScript
                  is written.                
            </javadoc>
            <declaration name="spoolFile" type="File" line="287"/>
            <declaration name="mFillOpStr" type="String" line="289"/>
            <javadoc line="289">
                This string holds the PostScript operator to
                  be used to fill a path. It can be changed
                  by the &lt;code&gt;setFillMode&lt;/code&gt; method.                
            </javadoc>
            <declaration name="mClipOpStr" type="String" line="296"/>
            <javadoc line="296">
                This string holds the PostScript operator to
                  be used to clip to a path. It can be changed
                  by the &lt;code&gt;setFillMode&lt;/code&gt; method.                
            </javadoc>
            <declaration name="mGStateStack" type="ArrayList" line="303"/>
            <javadoc line="303">
                A stack that represents the PostScript gstate stack.                
            </javadoc>
            <declaration name="mPenX" type="float" line="308"/>
            <javadoc line="308">
                The x coordinate of the current pen position.                
            </javadoc>
            <declaration name="mPenY" type="float" line="313"/>
            <javadoc line="313">
                The y coordinate of the current pen position.                
            </javadoc>
            <declaration name="mStartPathX" type="float" line="318"/>
            <javadoc line="318">
                The x coordinate of the starting point of
                  the current subpath.                
            </javadoc>
            <declaration name="mStartPathY" type="float" line="324"/>
            <javadoc line="324">
                The y coordinate of the starting point of
                  the current subpath.                
            </javadoc>
            <declaration name="mFontProps" type="Properties" line="330"/>
            <javadoc line="330">
                An optional mapping of fonts to PostScript names.                
            </javadoc>
            <scope line="336">
                <anonymous_class line="340">
                    <method name="run" type="Object" line="341"/>
                </anonymous_class>
            </scope>
            <method name="initProps" type="Properties" line="352">
                <comment line="354">
                    search psfont.properties for fonts
                     and create and initialize fontProps if it exist.                    
                </comment>
                <comment line="389">
                    Load property file                    
                </comment>
                <declaration name="jhome" type="String" line="356"/>
                <scope line="358">
                    <declaration name="ulocale" type="String" line="359"/>
                    <scope line="360">
                        <declaration name="f" type="File" line="362"/>
                        <scope line="366">
                            <scope line="371">
                                <scope line="376">
                                    <scope line="381"/>
                                </scope>
                            </scope>
                        </scope>
                        <declaration name="in" type="InputStream" line="389"/>
                        <declaration name="props" type="Properties" line="391"/>
                    </scope>
                    <scope line="395"/>
                </scope>
            </method>
            <method name="PSPrinterJob" type="constructor" line="405"/>
            <javadoc line="410">
                Presents the user a dialog for changing properties of the
                  print job interactively.                
                <returns>
                    false if the user cancels the dialog and
                      true otherwise.                    
                </returns>
                <exception>
                    HeadlessException if GraphicsEnvironment.isHeadless()
                      returns true.                    
                </exception>
                <see>
                    java.awt.GraphicsEnvironment#isHeadless                    
                </see>
            </javadoc>
            <method name="printDialog" type="boolean" line="419">
                <comment line="436">
                    Remove DialogTypeSelection.NATIVE to prevent infinite loop in
                     RasterPrinterJob.                    
                </comment>
                <comment line="440">
                    restore attribute                    
                </comment>
                <scope line="421"/>
                <scope line="425"/>
                <declaration name="doPrint" type="boolean" line="431"/>
                <declaration name="dts" type="DialogTypeSelection" line="432"/>
                <scope line="434"/>
                <scope line="441"/>
                <scope line="445">
                    <declaration name="jobName" type="JobName" line="446"/>
                    <scope line="447"/>
                    <declaration name="copies" type="Copies" line="450"/>
                    <scope line="451"/>
                    <declaration name="dest" type="Destination" line="455"/>
                    <scope line="457">
                        <scope line="458"/>
                        <scope line="461"/>
                    </scope>
                    <scope line="464">
                        <declaration name="pServ" type="PrintService" line="466"/>
                        <scope line="467"/>
                    </scope>
                </scope>
            </method>
            <javadoc line="476">
                Invoked by the RasterPrinterJob super class
                  this method is called to mark the start of a
                  document.                
            </javadoc>
            <method name="startDoc" type="void" line="481">
                <comment line="484">
                    A security check has been performed in the
                     java.awt.print.printerJob.getPrinterJob method.
                     We use an inner class to execute the privilged open operations.
                     Note that we only open a file if it has been nominated by
                     the end-user in a dialog that we ouselves put up.                    
                </comment>
                <comment line="504">
                                        
                </comment>
                <comment line="555">
                    The following procedure takes args: string, x, y, desiredWidth.
                     It calculates using stringwidth the width of the string in the
                     current font and subtracts it from the desiredWidth and divides
                     this by stringLen-1. This gives us a per-glyph adjustment in
                     the spacing needed (either +ve or -ve) to make the string
                     print at the desiredWidth. The ashow procedure call takes this
                     per-glyph adjustment as an argument. This is necessary for WYSIWYG                    
                </comment>
                <comment line="598">
                    Set Page Size using first page&apos;s format.                    
                </comment>
                <comment line="603">
                    PostScript printers can always generate uncollated copies.                    
                </comment>
                <declaration name="output" type="OutputStream" line="489"/>
                <scope line="491">
                    <scope line="492">
                        <declaration name="sps" type="StreamPrintService" line="493"/>
                        <scope line="495"/>
                        <scope line="499"/>
                    </scope>
                    <scope line="502">
                        <scope line="505"/>
                        <scope line="509">
                            <scope line="510"/>
                            <scope line="513"/>
                        </scope>
                        <scope line="516">
                            <declaration name="po" type="PrinterOpener" line="517"/>
                            <scope line="519"/>
                        </scope>
                    </scope>
                </scope>
                <scope line="567"/>
                <scope line="580">
                    <declaration name="cnt" type="int" line="581"/>
                    <scope line="582"/>
                </scope>
                <scope line="596">
                    <declaration name="pageFormat" type="PageFormat" line="598"/>
                    <declaration name="paperHeight" type="double" line="599"/>
                    <declaration name="paperWidth" type="double" line="600"/>
                    <declaration name="pservice" type="PrintService" line="607"/>
                    <anonymous_class line="609">
                        <method name="run" type="Object" line="610">
                            <scope line="611">
                                <declaration name="psClass" type="Class" line="612"/>
                                <scope line="613">
                                    <declaration name="isPSMethod" type="Method" line="614"/>
                                </scope>
                            </scope>
                            <scope line="618"/>
                        </method>
                    </anonymous_class>
                    <declaration name="isPS" type="Boolean" line="608"/>
                    <scope line="624"/>
                    <scope line="632">
                        <scope line="633"/>
                        <scope line="635"/>
                    </scope>
                </scope>
            </method>
            <class name="PrinterOpener" line="646">
                <implements interface="java.security.PrivilegedAction"/>
                <declaration name="pex" type="PrinterException" line="647"/>
                <declaration name="result" type="OutputStream" line="648"/>
                <method name="run" type="Object" line="650">
                    <comment line="654">
                        Write to a temporary file which will be spooled to
                         the printer then deleted. In the case that the file
                         is not removed for some reason, request that it is
                         removed when the VM exits.                        
                    </comment>
                    <comment line="665">
                        If there is an IOError we subvert it to a PrinterException.                        
                    </comment>
                    <scope line="651"/>
                    <scope line="663"/>
                </method>
            </class>
            <class name="PrinterSpooler" line="673">
                <implements interface="java.security.PrivilegedAction"/>
                <declaration name="pex" type="PrinterException" line="674"/>
                <method name="run" type="Object" line="676">
                    <comment line="679">
                        Spool to the printer.                        
                    </comment>
                    <scope line="677">
                        <scope line="681"/>
                        <declaration name="fileName" type="String" line="685"/>
                        <declaration name="execCmd" type="String" line="686"/>
                        <declaration name="process" type="Process" line="690"/>
                    </scope>
                    <scope line="694"/>
                    <scope line="696"/>
                </method>
            </class>
            <javadoc line="704">
                Invoked if the application cancelled the printjob.                
            </javadoc>
            <method name="abortDoc" type="void" line="707">
                <scope line="708"/>
                <anonymous_class line="712">
                    <method name="run" type="Object" line="714">
                        <scope line="715"/>
                    </method>
                </anonymous_class>
            </method>
            <javadoc line="723">
                Invoked by the RasterPrintJob super class
                  this method is called after that last page
                  has been imaged.                
            </javadoc>
            <method name="endDoc" type="void" line="728">
                <scope line="729">
                    <scope line="732"/>
                </scope>
                <scope line="736">
                    <scope line="737"/>
                    <declaration name="spooler" type="PrinterSpooler" line="740"/>
                    <scope line="742"/>
                </scope>
            </method>
            <javadoc line="748">
                The RasterPrintJob super class calls this method
                  at the start of each page.                
            </javadoc>
            <method name="startPage" type="void" line="755">
                <params>
                    <param name="pageFormat" type="PageFormat"/>
                    <param name="painter" type="Printable"/>
                    <param name="index" type="int"/>
                    <param name="paperChanged" type="boolean"/>
                </params>
                <comment line="761">
                    Place an initial gstate on to our gstate stack.
                     It will have the default PostScript gstate
                     attributes.                    
                </comment>
                <comment line="770">
                    Check current page&apos;s pageFormat against the previous pageFormat,                    
                </comment>
                <declaration name="paperHeight" type="double" line="756"/>
                <declaration name="paperWidth" type="double" line="757"/>
                <declaration name="pageNumber" type="int" line="758"/>
                <scope line="771">
                    <declaration name="pservice" type="PrintService" line="776"/>
                    <anonymous_class line="780">
                        <method name="run" type="Object" line="781">
                            <scope line="782">
                                <declaration name="psClass" type="Class" line="783"/>
                                <scope line="785">
                                    <declaration name="isPSMethod" type="Method" line="786"/>
                                </scope>
                            </scope>
                            <scope line="793"/>
                        </method>
                    </anonymous_class>
                    <declaration name="isPS" type="Boolean" line="777"/>
                    <scope line="800"/>
                </scope>
            </method>
            <javadoc line="809">
                The RastePrintJob super class calls this method
                  at the end of each page.                
            </javadoc>
            <method name="endPage" type="void" line="816">
                <params>
                    <param name="format" type="PageFormat"/>
                    <param name="painter" type="Printable"/>
                    <param name="index" type="int"/>
                </params>
            </method>
            <javadoc line="821">
                Convert the 24 bit BGR image buffer represented by
                  &lt;code&gt;image&lt;/code&gt; to PostScript. The image is drawn at
                  &lt;code&gt;(destX, destY)&lt;/code&gt; in device coordinates.
                  The image is scaled into a square of size
                  specified by &lt;code&gt;destWidth&lt;/code&gt; and
                  &lt;code&gt;destHeight&lt;/code&gt;. The portion of the
                  source image copied into that square is specified
                  by &lt;code&gt;srcX&lt;/code&gt;, &lt;code&gt;srcY&lt;/code&gt;,
                  &lt;code&gt;srcWidth&lt;/code&gt;, and srcHeight.                
            </javadoc>
            <method name="drawImageBGR" type="void" line="837">
                <params>
                    <param name="bgrData" type="byte[]"/>
                    <param name="destX" type="float"/>
                    <param name="destY" type="float"/>
                    <param name="destWidth" type="float"/>
                    <param name="destHeight" type="float"/>
                    <param name="srcX" type="float"/>
                    <param name="srcY" type="float"/>
                    <param name="srcWidth" type="float"/>
                    <param name="srcHeight" type="float"/>
                    <param name="srcBitMapWidth" type="int"/>
                    <param name="srcBitMapHeight" type="int"/>
                </params>
                <comment line="840">
                    We draw images at device resolution so we probably need
                     to change the current PostScript transform.                    
                </comment>
                <comment line="851">
                    Create a PS string big enough to hold a row of pixels.                    
                </comment>
                <comment line="860">
                    Scale and translate the unit image.                    
                </comment>
                <comment line="867">
                    Color Image invocation.                    
                </comment>
                <comment line="875">
                    Image data.                    
                </comment>
                <comment line="881">
                    Skip the parts of the image that are not part
                     of the source rectangle.                    
                </comment>
                <comment line="888">
                    Skip the left part of the image that is not
                     part of the source rectangle.                    
                </comment>
                <comment line="900">
                    If there is an IOError we subvert it to a PrinterException.
                     Fix: There has got to be a better way, maybe define
                     a PrinterIOException and then throw that?                    
                </comment>
                <comment line="906">
                    throw new PrinterException(e.toString());                    
                </comment>
                <declaration name="intSrcWidth" type="int" line="845"/>
                <declaration name="intSrcHeight" type="int" line="846"/>
                <declaration name="psBytesPerRow" type="int" line="852"/>
                <scope line="853"/>
                <declaration name="index" type="int" line="876"/>
                <declaration name="rgbData" type="byte[]" line="877"/>
                <scope line="879">
                    <scope line="885">
                        <declaration name="encodedData" type="byte[]" line="893"/>
                        <declaration name="asciiData" type="byte[]" line="894"/>
                    </scope>
                </scope>
                <scope line="904"/>
            </method>
            <javadoc line="911">
                Prints the contents of the array of ints, &apos;data&apos;
                  to the current page. The band is placed at the
                  location (x, y) in device coordinates on the
                  page. The width and height of the band is
                  specified by the caller. Currently the data
                  is 24 bits per pixel in BGR format.                
            </javadoc>
            <method name="printBand" type="void" line="922">
                <params>
                    <param name="bgrData" type="byte[]"/>
                    <param name="x" type="int"/>
                    <param name="y" type="int"/>
                    <param name="width" type="int"/>
                    <param name="height" type="int"/>
                </params>
                <comment line="927">
                    Create a PS string big enough to hold a row of pixels.                    
                </comment>
                <comment line="936">
                    Scale and translate the unit image.                    
                </comment>
                <comment line="943">
                    Color Image invocation.                    
                </comment>
                <comment line="951">
                    Image data.                    
                </comment>
                <declaration name="psBytesPerRow" type="int" line="928"/>
                <scope line="929"/>
                <declaration name="index" type="int" line="952"/>
                <declaration name="rgbData" type="byte[]" line="953"/>
                <scope line="955">
                    <scope line="956">
                        <declaration name="encodedData" type="byte[]" line="958"/>
                        <declaration name="asciiData" type="byte[]" line="959"/>
                    </scope>
                </scope>
                <scope line="964"/>
            </method>
            <javadoc line="971">
                Examine the metrics captured by the
                  &lt;code&gt;PeekGraphics&lt;/code&gt; instance and
                  if capable of directly converting this
                  print job to the printer&apos;s control language
                  or the native OS&apos;s graphics primitives, then
                  return a &lt;code&gt;PSPathGraphics&lt;/code&gt; to perform
                  that conversion. If there is not an object
                  capable of the conversion then return
                  &lt;code&gt;null&lt;/code&gt;. Returning &lt;code&gt;null&lt;/code&gt;
                  causes the print job to be rasterized.                
            </javadoc>
            <method name="createPathGraphics" type="Graphics2D" line="988">
                <params>
                    <param name="peekGraphics" type="PeekGraphics"/>
                    <param name="printerJob" type="PrinterJob"/>
                    <param name="painter" type="Printable"/>
                    <param name="pageFormat" type="PageFormat"/>
                    <param name="pageIndex" type="int"/>
                </params>
                <comment line="994">
                    If the application has drawn anything that
                     out PathGraphics class can not handle then
                     return a null PathGraphics.                    
                </comment>
                <declaration name="pathGraphics" type="PSPathGraphics" line="990"/>
                <declaration name="metrics" type="PeekMetrics" line="991"/>
                <scope line="999"/>
                <scope line="1002">
                    <declaration name="bufferedImage" type="BufferedImage" line="1004"/>
                    <declaration name="bufferedGraphics" type="Graphics2D" line="1006"/>
                    <declaration name="canRedraw" type="boolean" line="1007"/>
                </scope>
            </method>
            <javadoc line="1017">
                Intersect the gstate&apos;s current path with the
                  current clip and make the result the new clip.                
            </javadoc>
            <method name="selectClipPath" type="void" line="1021"/>
            <method name="setClip" type="void" line="1026">
                <params>
                    <param name="clip" type="Shape"/>
                </params>
            </method>
            <method name="setTransform" type="void" line="1031">
                <params>
                    <param name="transform" type="AffineTransform"/>
                </params>
            </method>
            <javadoc line="1035">
                Set the current PostScript font.
                  Taken from outFont in PSPrintStream.                
            </javadoc>
            <method name="setFont" type="boolean" line="1039">
                <params>
                    <param name="font" type="Font"/>
                </params>
            </method>
            <javadoc line="1044">
                Given an array of CharsetStrings that make up a run
                  of text, this routine converts each CharsetString to
                  an index into our PostScript font list. If one or more
                  CharsetStrings can not be represented by a PostScript
                  font, then this routine will return a null array.                
            </javadoc>
            <method name="getPSFontIndexArray" type="int[]" line="1051">
                <params>
                    <param name="font" type="Font"/>
                    <param name="charSet" type="CharsetString[]"/>
                </params>
                <comment line="1061">
                    Get the encoding of the run of text.                    
                </comment>
                <comment line="1067">
                    sun.awt.Symbol perhaps should return &quot;symbol&quot; for encoding.
                     Similarly X11Dingbats should return &quot;dingbats&quot;
                     Forced to check for win32 &amp; xunix names for these converters.                    
                </comment>
                <comment line="1087">
                    First we map the font name through the properties file.
                     This mapping provides alias names for fonts, for example,
                     &quot;timesroman&quot; is mapped to &quot;serif&quot;.                    
                </comment>
                <comment line="1095">
                    Now map the alias name, character set name, and style
                     to a PostScript name.                    
                </comment>
                <comment line="1104">
                    Get the PostScript font index for the PostScript font.                    
                </comment>
                <comment line="1110">
                    If there is no PostScript font for this font name,
                     then we want to termintate the loop and the method
                     indicating our failure. Setting the array to null
                     is used to indicate these failures.                    
                </comment>
                <comment line="1119">
                    There was no PostScript name for the font, character set,
                     and style so give up.                    
                </comment>
                <declaration name="psFont" type="int[]" line="1052"/>
                <scope line="1054"/>
                <scope line="1058">
                    <declaration name="cs" type="CharsetString" line="1062"/>
                    <declaration name="fontCS" type="CharsetEncoder" line="1064"/>
                    <declaration name="charsetName" type="String" line="1065"/>
                    <scope line="1072"/>
                    <scope line="1075"/>
                    <scope line="1077"/>
                    <declaration name="styleMask" type="int" line="1081"/>
                    <declaration name="style" type="String" line="1084"/>
                    <declaration name="fontName" type="String" line="1090"/>
                    <declaration name="name" type="String" line="1092"/>
                    <declaration name="psName" type="String" line="1097"/>
                    <scope line="1101">
                        <scope line="1105"/>
                        <scope line="1114"/>
                    </scope>
                    <scope line="1121"/>
                </scope>
            </method>
            <method name="escapeParens" type="String" line="1130">
                <params>
                    <param name="str" type="String"/>
                </params>
                <scope line="1131"/>
                <scope line="1133">
                    <declaration name="count" type="int" line="1134"/>
                    <declaration name="pos" type="int" line="1135"/>
                    <scope line="1136"/>
                    <scope line="1141"/>
                    <declaration name="inArr" type="char[]" line="1145"/>
                    <declaration name="outArr" type="char[]" line="1146"/>
                    <scope line="1148">
                        <scope line="1149"/>
                    </scope>
                </scope>
            </method>
            <method name="platformFontCount" type="int" line="1163">
                <params>
                    <param name="font" type="Font"/>
                    <param name="str" type="String"/>
                </params>
                <comment line="1171">
                                        
                </comment>
                <scope line="1164"/>
                <declaration name="acs" type="CharsetString[]" line="1167"/>
                <scope line="1169"/>
                <declaration name="psFonts" type="int[]" line="1173"/>
            </method>
            <method name="textOut" type="boolean" line="1179">
                <params>
                    <param name="g" type="Graphics"/>
                    <param name="str" type="String"/>
                    <param name="x" type="float"/>
                    <param name="y" type="float"/>
                    <param name="mLastFont" type="Font"/>
                    <param name="frc" type="FontRenderContext"/>
                    <param name="width" type="float"/>
                </params>
                <comment line="1188">
                    On-screen drawString renders most control chars as the missing
                     glyph and have the non-zero advance of that glyph.
                     Exceptions are \t, \n and \r which are considered zero-width.
                     Postscript handles control chars mostly as a missing glyph.
                     But we use &apos;ashow&apos; specifying a width for the string which
                     assumes zero-width for those three exceptions, and Postscript
                     tries to squeeze the extra char in, with the result that the
                     glyphs look compressed or even overlap.
                     So exclude those control chars from the string sent to PS.                    
                </comment>
                <comment line="1206">
                                        
                </comment>
                <comment line="1209">
                    Get an array of indices into our PostScript name
                     table. If all of the runs can not be converted
                     to PostScript fonts then null is returned and
                     we&apos;ll want to fall back to printing the text
                     as shapes.                    
                </comment>
                <comment line="1238">
                    The width to fit to may either be specified,
                     or calculated. Specifying by the caller is only
                     valid if the text does not need to be decomposed
                     into multiple calls.                    
                </comment>
                <comment line="1254">
                    unprintable chars had width of 0, causing a PS error                    
                </comment>
                <comment line="1262">
                    to avoid encoding conversion with println()                    
                </comment>
                <comment line="1275">
                                        
                </comment>
                <comment line="1276">
                    mPSStream.println(&quot;% Font[&quot; + mLastFont.getName() + &quot;, &quot; +
                                                 FontConfiguration.getStyleString(mLastFont.getStyle()) + &quot;, &quot;
                                                 + mLastFont.getSize2D() + &quot;]&quot;);                    
                </comment>
                <comment line="1281">
                    out String                    
                </comment>
                <declaration name="didText" type="boolean" line="1180"/>
                <scope line="1182"/>
                <scope line="1184">
                    <scope line="1198"/>
                    <declaration name="acs" type="CharsetString[]" line="1201"/>
                    <scope line="1204"/>
                    <declaration name="psFonts" type="int[]" line="1214"/>
                    <scope line="1215">
                        <scope line="1217">
                            <declaration name="cs" type="CharsetString" line="1218"/>
                            <declaration name="fontCS" type="CharsetEncoder" line="1219"/>
                            <declaration name="nativeStr" type="StringBuffer" line="1221"/>
                            <declaration name="strSeg" type="byte[]" line="1222"/>
                            <declaration name="len" type="int" line="1223"/>
                            <scope line="1224">
                                <declaration name="bb" type="ByteBuffer" line="1225"/>
                            </scope>
                            <scope line="1232"/>
                            <scope line="1234"/>
                            <declaration name="desiredWidth" type="float" line="1242"/>
                            <scope line="1243"/>
                            <scope line="1245">
                                <declaration name="r2d" type="Rectangle2D" line="1246"/>
                            </scope>
                            <scope line="1255"/>
                            <scope line="1259">
                                <declaration name="b" type="byte" line="1260"/>
                                <declaration name="hexS" type="String" line="1262"/>
                                <declaration name="length" type="int" line="1263"/>
                                <scope line="1264"/>
                                <scope line="1266"/>
                                <scope line="1268"/>
                            </scope>
                        </scope>
                    </scope>
                    <scope line="1286"/>
                </scope>
            </method>
            <javadoc line="1293">
                Set the current path rule to be either
                  &lt;code&gt;FILL_EVEN_ODD&lt;/code&gt; (using the
                  even-odd file rule) or &lt;code&gt;FILL_WINDING&lt;/code&gt;
                  (using the non-zero winding rule.)                
            </javadoc>
            <method name="setFillMode" type="void" line="1299">
                <params>
                    <param name="fillRule" type="int"/>
                </params>
            </method>
            <javadoc line="1319">
                Set the printer&apos;s current color to be that
                  defined by &lt;code&gt;color&lt;/code&gt;                
            </javadoc>
            <method name="setColor" type="void" line="1323">
                <params>
                    <param name="color" type="Color"/>
                </params>
            </method>
            <javadoc line="1327">
                Fill the current path using the current fill mode
                  and color.                
            </javadoc>
            <method name="fillPath" type="void" line="1331"/>
            <javadoc line="1336">
                Called to mark the start of a new path.                
            </javadoc>
            <method name="beginPath" type="void" line="1339"/>
            <javadoc line="1348">
                Close the current subpath by appending a straight
                  line from the current point to the subpath&apos;s
                  starting point.                
            </javadoc>
            <method name="closeSubpath" type="void" line="1353"/>
            <javadoc line="1362">
                Generate PostScript to move the current pen
                  position to &lt;code&gt;(x, y)&lt;/code&gt;.                
            </javadoc>
            <method name="moveTo" type="void" line="1366">
                <params>
                    <param name="x" type="float"/>
                    <param name="y" type="float"/>
                </params>
                <comment line="1371">
                    moveto marks the start of a new subpath
                     and we need to remember that starting
                     position so that we know where the
                     pen returns to with a close path.                    
                </comment>
            </method>
            <javadoc line="1381">
                Generate PostScript to draw a line from the
                  current pen position to &lt;code&gt;(x, y)&lt;/code&gt;.                
            </javadoc>
            <method name="lineTo" type="void" line="1385">
                <params>
                    <param name="x" type="float"/>
                    <param name="y" type="float"/>
                </params>
            </method>
            <javadoc line="1393">
                Add to the current path a bezier curve formed
                  by the current pen position and the method parameters
                  which are two control points and an ending
                  point.                
            </javadoc>
            <method name="bezierTo" type="void" line="1401">
                <params>
                    <param name="control1x" type="float"/>
                    <param name="control1y" type="float"/>
                    <param name="control2x" type="float"/>
                    <param name="control2y" type="float"/>
                    <param name="endX" type="float"/>
                    <param name="endY" type="float"/>
                </params>
                <comment line="1404">
                    mPSStream.println(control1x + &quot; &quot; + control1y
                                            + &quot; &quot; + control2x + &quot; &quot; + control2y
                                            + &quot; &quot; + endX + &quot; &quot; + endY
                                            + CURVETO_STR);                    
                </comment>
            </method>
            <method name="trunc" type="String" line="1417">
                <params>
                    <param name="f" type="float"/>
                </params>
                <declaration name="af" type="float" line="1418"/>
                <scope line="1419"/>
            </method>
            <javadoc line="1425">
                Return the x coordinate of the pen in the
                  current path.                
            </javadoc>
            <method name="getPenX" type="float" line="1429"/>
            <javadoc line="1433">
                Return the y coordinate of the pen in the
                  current path.                
            </javadoc>
            <method name="getPenY" type="float" line="1437"/>
            <javadoc line="1442">
                Return the x resolution of the coordinates
                  to be rendered.                
            </javadoc>
            <method name="getXRes" type="double" line="1446"/>
            <javadoc line="1449">
                Return the y resolution of the coordinates
                  to be rendered.                
            </javadoc>
            <method name="getYRes" type="double" line="1453"/>
            <javadoc line="1457">
                For PostScript the origin is in the upper-left of the
                  paper not at the imageable area corner.                
            </javadoc>
            <method name="getPhysicalPrintableX" type="double" line="1461">
                <params>
                    <param name="p" type="Paper"/>
                </params>
            </method>
            <javadoc line="1466">
                For PostScript the origin is in the upper-left of the
                  paper not at the imageable area corner.                
            </javadoc>
            <method name="getPhysicalPrintableY" type="double" line="1470">
                <params>
                    <param name="p" type="Paper"/>
                </params>
            </method>
            <method name="getPhysicalPrintableWidth" type="double" line="1474">
                <params>
                    <param name="p" type="Paper"/>
                </params>
            </method>
            <method name="getPhysicalPrintableHeight" type="double" line="1478">
                <params>
                    <param name="p" type="Paper"/>
                </params>
            </method>
            <method name="getPhysicalPageWidth" type="double" line="1482">
                <params>
                    <param name="p" type="Paper"/>
                </params>
            </method>
            <method name="getPhysicalPageHeight" type="double" line="1486">
                <params>
                    <param name="p" type="Paper"/>
                </params>
            </method>
            <javadoc line="1490">
                Returns how many times each page in the book
                  should be consecutively printed by PrintJob.
                  If the printer makes copies itself then this
                  method should return 1.                
            </javadoc>
            <method name="getNoncollatedCopies" type="int" line="1496"/>
            <method name="getCollatedCopies" type="int" line="1500"/>
            <method name="printExecCmd" type="String[]" line="1506">
                <params>
                    <param name="printer" type="String"/>
                    <param name="options" type="String"/>
                    <param name="noJobSheet" type="boolean"/>
                    <param name="banner" type="String"/>
                    <param name="copies" type="int"/>
                    <param name="spoolFile" type="String"/>
                </params>
                <comment line="1515">
                    minimum number of print args                    
                </comment>
                <comment line="1557">
                    add 1 arg for lp                    
                </comment>
                <comment line="1560">
                    make a copy of the spool file                    
                </comment>
                <declaration name="PRINTER" type="int" line="1507"/>
                <declaration name="OPTIONS" type="int" line="1508"/>
                <declaration name="BANNER" type="int" line="1509"/>
                <declaration name="COPIES" type="int" line="1510"/>
                <declaration name="NOSHEET" type="int" line="1511"/>
                <declaration name="pFlags" type="int" line="1512"/>
                <declaration name="execCmd" type="String" line="1513"/>
                <declaration name="ncomps" type="int" line="1514"/>
                <declaration name="n" type="int" line="1515"/>
                <scope line="1517"/>
                <scope line="1521"/>
                <scope line="1525"/>
                <scope line="1529"/>
                <scope line="1533"/>
                <scope line="1537">
                    <scope line="1540"/>
                    <scope line="1543"/>
                    <scope line="1546"/>
                    <scope line="1549"/>
                    <scope line="1552"/>
                </scope>
                <scope line="1555">
                    <scope line="1560"/>
                    <scope line="1563"/>
                    <scope line="1566"/>
                    <scope line="1569"/>
                    <scope line="1572"/>
                </scope>
            </method>
            <method name="swapBGRtoRGB" type="int" line="1580">
                <params>
                    <param name="image" type="byte[]"/>
                    <param name="index" type="int"/>
                    <param name="dest" type="byte[]"/>
                </params>
                <declaration name="destIndex" type="int" line="1581"/>
                <scope line="1582"/>
            </method>
            <method name="makeCharsetName" type="String" line="1597">
                <params>
                    <param name="name" type="String"/>
                    <param name="chs" type="char[]"/>
                </params>
                <comment line="1602">
                    same as latin 1 if all chars &lt; 256                    
                </comment>
                <comment line="1610">
                    same as latin 1 if all chars &lt; 128                    
                </comment>
                <scope line="1598"/>
                <scope line="1600">
                    <scope line="1602">
                        <scope line="1603"/>
                    </scope>
                </scope>
                <scope line="1608">
                    <scope line="1610">
                        <scope line="1611"/>
                    </scope>
                </scope>
                <scope line="1616"/>
            </method>
            <method name="prepDrawing" type="void" line="1621">
                <comment line="1624">
                    Pop gstates until we can set the needed clip
                     and transform or until we are at the outer most
                     gstate.                    
                </comment>
                <comment line="1636">
                    Set the color. This can push the color to the
                     outer most gsave which is often a good thing.                    
                </comment>
                <comment line="1641">
                    We do not want to change the outermost
                     transform or clip so if we are at the
                     outer clip the generate a gsave.                    
                </comment>
                <comment line="1651">
                    Set the font if we have been asked to. It is
                     important that the font is set after the
                     transform in order to get the font size
                     correct.                    
                </comment>
                <comment line="1656">
                    if (g != null) {
                              getGState().emitPSFont(g, mLastFont);
                          }                    
                </comment>
                <scope line="1629"/>
                <scope line="1644"/>
            </method>
            <javadoc line="1661">
                Return the GState that is currently on top
                  of the GState stack. There should always be
                  a GState on top of the stack. If there isn&apos;t
                  then this method will throw an IndexOutOfBounds
                  exception.                
            </javadoc>
            <method name="getGState" type="GState" line="1668">
                <declaration name="count" type="int" line="1669"/>
            </method>
            <javadoc line="1673">
                Emit a PostScript gsave command and add a
                  new GState on to our stack which represents
                  the printer&apos;s gstate stack.                
            </javadoc>
            <method name="gsave" type="void" line="1678">
                <declaration name="oldGState" type="GState" line="1679"/>
            </method>
            <javadoc line="1684">
                Emit a PostScript grestore command and remove
                  a GState from our stack which represents the
                  printer&apos;s gstate stack.                
            </javadoc>
            <method name="grestore" type="void" line="1689">
                <declaration name="count" type="int" line="1690"/>
            </method>
            <javadoc line="1695">
                Return true if the current GState is the
                  outermost GState and therefore should not
                  be restored.                
            </javadoc>
            <method name="isOuterGState" type="boolean" line="1700"/>
            <class name="GState" line="1704">
                <javadoc line="1704">
                    A stack of GStates is maintained to model the printer&apos;s
                      gstate stack. Each GState holds information about
                      the current graphics attributes.                    
                </javadoc>
                <declaration name="mColor" type="Color" line="1710"/>
                <declaration name="mClip" type="Shape" line="1711"/>
                <declaration name="mFont" type="Font" line="1712"/>
                <declaration name="mTransform" type="AffineTransform" line="1713"/>
                <method name="GState" type="constructor" line="1715"/>
                <method name="GState" type="constructor" line="1722">
                    <params>
                        <param name="copyGState" type="GState"/>
                    </params>
                </method>
                <method name="canSetClip" type="boolean" line="1729">
                    <params>
                        <param name="clip" type="Shape"/>
                    </params>
                </method>
                <method name="emitPSClip" type="void" line="1735">
                    <params>
                        <param name="clip" type="Shape"/>
                    </params>
                    <comment line="1744">
                                                
                    </comment>
                    <scope line="1737">
                        <declaration name="saveFillOp" type="String" line="1738"/>
                        <declaration name="saveClipOp" type="String" line="1739"/>
                    </scope>
                </method>
                <method name="emitTransform" type="void" line="1749">
                    <params>
                        <param name="transform" type="AffineTransform"/>
                    </params>
                    <scope line="1751">
                        <declaration name="matrix" type="double[]" line="1752"/>
                    </scope>
                </method>
                <method name="emitPSColor" type="void" line="1766">
                    <params>
                        <param name="color" type="Color"/>
                    </params>
                    <comment line="1771">
                        If the color is a gray value then use
                         setgray.                        
                    </comment>
                    <comment line="1777">
                        It&apos;s not gray so use setrgbcolor.                        
                    </comment>
                    <scope line="1767">
                        <declaration name="rgb" type="float[]" line="1768"/>
                        <scope line="1773"/>
                        <scope line="1778"/>
                    </scope>
                </method>
                <method name="emitPSFont" type="void" line="1790">
                    <params>
                        <param name="psFontIndex" type="int"/>
                        <param name="fontSize" type="float"/>
                    </params>
                </method>
            </class>
            <javadoc line="1796">
                Given a Java2D &lt;code&gt;PathIterator&lt;/code&gt; instance,
                  this method translates that into a PostScript path..                
            </javadoc>
            <method name="convertToPSPath" type="void" line="1800">
                <params>
                    <param name="pathIter" type="PathIterator"/>
                </params>
                <comment line="1806">
                    Map the PathIterator&apos;s fill rule into the PostScript
                     fill rule.                    
                </comment>
                <comment line="1832">
                    Convert the quad path to a bezier.                    
                </comment>
                <declaration name="segment" type="float[]" line="1802"/>
                <declaration name="segmentType" type="int" line="1803"/>
                <declaration name="fillRule" type="int" line="1808"/>
                <scope line="1809"/>
                <scope line="1811"/>
                <scope line="1819">
                    <declaration name="lastX" type="float" line="1834"/>
                    <declaration name="lastY" type="float" line="1835"/>
                    <declaration name="c1x" type="float" line="1836"/>
                    <declaration name="c1y" type="float" line="1837"/>
                    <declaration name="c2x" type="float" line="1838"/>
                    <declaration name="c2y" type="float" line="1839"/>
                </scope>
            </method>
            <method name="deviceFill" type="void" line="1867">
                <params>
                    <param name="pathIter" type="PathIterator"/>
                    <param name="color" type="Color"/>
                    <param name="tx" type="AffineTransform"/>
                    <param name="clip" type="Shape"/>
                </params>
                <comment line="1874">
                    Specify the path to fill as the clip, this ensures that only
                     pixels which are inside the path will be filled, which is
                     what the Java 2D APIs specify                    
                </comment>
            </method>
            <method name="rlEncode" type="byte[]" line="1900">
                <params>
                    <param name="inArr" type="byte[]"/>
                </params>
                <comment line="1916">
                    count run of same value                    
                </comment>
                <comment line="1924">
                    back to top of while loop.                    
                </comment>
                <comment line="1927">
                    if reach here have a run of different values, or at the end.                    
                </comment>
                <comment line="1930">
                    count run of different values                    
                </comment>
                <declaration name="inIndex" type="int" line="1902"/>
                <declaration name="outIndex" type="int" line="1903"/>
                <declaration name="startIndex" type="int" line="1904"/>
                <declaration name="runLen" type="int" line="1905"/>
                <declaration name="outArr" type="byte[]" line="1906"/>
                <scope line="1907">
                    <scope line="1908"/>
                    <scope line="1914"/>
                    <scope line="1919"/>
                    <scope line="1928"/>
                    <scope line="1933"/>
                </scope>
                <declaration name="encodedData" type="byte[]" line="1939"/>
            </method>
            <method name="ascii85Encode" type="byte[]" line="1948">
                <params>
                    <param name="inArr" type="byte[]"/>
                </params>
                <comment line="1977">
                    input not a multiple of 4 bytes, write partial output.                    
                </comment>
                <comment line="1979">
                    n bytes remain to be written                    
                </comment>
                <comment line="2003">
                    write EOD marker.                    
                </comment>
                <comment line="2006">
                    The original intention was to insert a newline after every 78 bytes.
                     This was mainly intended for legibility but I decided against this
                     partially because of the (small) amount of extra space, and
                     partially because for line breaks either would have to hardwire
                     ascii 10 (newline) or calculate space in bytes to allocate for
                     the platform&apos;s newline byte sequence. Also need to be careful
                     about where its inserted:
                     Ascii 85 decoder ignores white space except for one special case:
                     you must ensure you do not split the EOD marker across lines.                    
                </comment>
                <declaration name="outArr" type="byte[]" line="1949"/>
                <declaration name="p1" type="long" line="1950"/>
                <declaration name="p2" type="long" line="1951"/>
                <declaration name="p3" type="long" line="1952"/>
                <declaration name="p4" type="long" line="1953"/>
                <declaration name="pling" type="byte" line="1954"/>
                <declaration name="i" type="int" line="1956"/>
                <declaration name="olen" type="int" line="1957"/>
                <declaration name="val" type="long" line="1958"/>
                <scope line="1960">
                    <scope line="1965"/>
                    <scope line="1967"/>
                </scope>
                <scope line="1977">
                    <declaration name="n" type="int" line="1978"/>
                    <scope line="1981"/>
                    <declaration name="append" type="int" line="1985"/>
                    <scope line="1986"/>
                    <declaration name="c" type="byte[]" line="1989"/>
                    <scope line="1997"/>
                </scope>
                <declaration name="retArr" type="byte[]" line="2015"/>
            </method>
            <class name="PluginPrinter" line="2021">
                <implements interface="Printable"/>
                <javadoc line="2021">
                    PluginPrinter generates EPSF wrapped with a header and trailer
                      comment. This conforms to the new requirements of Mozilla 1.7
                      and FireFox 1.5 and later. Earlier versions of these browsers
                      did not support plugin printing in the general sense (not just Java).
                      A notable limitation of these browsers is that they handle plugins
                      which would span page boundaries by scaling plugin content to fit on a
                      single page. This means white space is left at the bottom of the
                      previous page and its impossible to print these cases as they appear on
                      the web page. This is contrast to how the same browsers behave on
                      Windows where it renders as on-screen.
                      Cases where the content fits on a single page do work fine, and they
                      are the majority of cases.
                      The scaling that the browser specifies to make the plugin content fit
                      when it is larger than a single page can hold is non-uniform. It
                      scales the axis in which the content is too large just enough to
                      ensure it fits. For content which is extremely long this could lead
                      to noticeable distortion. However that is probably rare enough that
                      its not worth compensating for that here, but we can revisit that if
                      needed, and compensate by making the scale for the other axis the
                      same.                    
                </javadoc>
                <declaration name="epsPrinter" type="EPSPrinter" line="2045"/>
                <declaration name="applet" type="Component" line="2046"/>
                <declaration name="stream" type="PrintStream" line="2047"/>
                <declaration name="epsTitle" type="String" line="2048"/>
                <declaration name="bx" type="int" line="2049"/>
                <declaration name="width" type="int" line="2050"/>
                <javadoc line="2052">
                    This is called from the Java Plug-in to print an Applet&apos;s
                      contents as EPS to a postscript stream provided by the browser.                    
                    <param>
                        applet the applet component to print.                        
                    </param>
                    <param>
                        stream the print stream provided by the plug-in                        
                    </param>
                    <param>
                        x the x location of the applet panel in the browser window                        
                    </param>
                    <param>
                        y the y location of the applet panel in the browser window                        
                    </param>
                    <param>
                        w the width of the applet panel in the browser window                        
                    </param>
                    <param>
                        h the width of the applet panel in the browser window                        
                    </param>
                </javadoc>
                <method name="PluginPrinter" type="constructor" line="2064">
                    <params>
                        <param name="applet" type="Component"/>
                        <param name="stream" type="PrintStream"/>
                        <param name="x" type="int"/>
                        <param name="y" type="int"/>
                        <param name="w" type="int"/>
                        <param name="h" type="int"/>
                    </params>
                </method>
                <method name="printPluginPSHeader" type="void" line="2079"/>
                <method name="printPluginApplet" type="void" line="2083">
                    <scope line="2084"/>
                    <scope line="2086"/>
                </method>
                <method name="printPluginPSTrailer" type="void" line="2090"/>
                <method name="printAll" type="void" line="2095"/>
                <method name="print" type="int" line="2101">
                    <params>
                        <param name="g" type="Graphics"/>
                        <param name="pf" type="PageFormat"/>
                        <param name="pgIndex" type="int"/>
                    </params>
                    <comment line="2106">
                        &quot;aware&quot; client code can detect that its been passed a
                         PrinterGraphics and could theoretically print
                         differently. I think this is more likely useful than
                         a problem.                        
                    </comment>
                    <scope line="2102"/>
                    <scope line="2104"/>
                </method>
            </class>
            <class name="EPSPrinter" line="2129">
                <implements interface="Pageable"/>
                <declaration name="pf" type="PageFormat" line="2131"/>
                <declaration name="job" type="PSPrinterJob" line="2132"/>
                <declaration name="llx" type="int" line="2133"/>
                <declaration name="printable" type="Printable" line="2134"/>
                <declaration name="stream" type="PrintStream" line="2135"/>
                <declaration name="epsTitle" type="String" line="2136"/>
                <method name="EPSPrinter" type="constructor" line="2140">
                    <params>
                        <param name="printable" type="Printable"/>
                        <param name="title" type="String"/>
                        <param name="stream" type="PrintStream"/>
                        <param name="x" type="int"/>
                        <param name="y" type="int"/>
                        <param name="wid" type="int"/>
                        <param name="hgt" type="int"/>
                    </params>
                    <comment line="2150">
                        construct a PageFormat with zero margins representing the
                         exact bounds of the applet. ie construct a theoretical
                         paper which happens to exactly match applet panel size.                        
                    </comment>
                    <declaration name="p" type="Paper" line="2152"/>
                </method>
                <method name="print" type="void" line="2159">
                    <comment line="2169">
                        for restoring stack state on return                        
                    </comment>
                    <comment line="2172">
                        modifies the behaviour of PSPrinterJob                        
                    </comment>
                    <comment line="2174">
                        prevents closure                        
                    </comment>
                    <comment line="2186">
                        restore stack state                        
                    </comment>
                    <scope line="2176"/>
                    <scope line="2178">
                        <scope line="2179"/>
                        <scope line="2181"/>
                    </scope>
                    <scope line="2184"/>
                </method>
                <method name="getNumberOfPages" type="int" line="2192"/>
                <method name="getPageFormat" type="PageFormat" line="2196">
                    <params>
                        <param name="pgIndex" type="int"/>
                    </params>
                    <scope line="2197"/>
                    <scope line="2199"/>
                </method>
                <method name="getPrintable" type="Printable" line="2204">
                    <params>
                        <param name="pgIndex" type="int"/>
                    </params>
                    <scope line="2205"/>
                    <scope line="2207"/>
                </method>
            </class>
        </class>
    </source>