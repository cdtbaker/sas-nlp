<?xml version="1.0" encoding="UTF-8"?>
    <source package="sun.print">
        <import package="java.awt.Color"/>
        <import package="java.awt.Font"/>
        <import package="java.awt.Graphics"/>
        <import package="java.awt.Graphics2D"/>
        <import package="java.awt.Image"/>
        <import package="java.awt.Shape"/>
        <import package="java.awt.Transparency"/>
        <import package="java.awt.font.FontRenderContext"/>
        <import package="java.awt.font.TextLayout"/>
        <import package="java.awt.geom.AffineTransform"/>
        <import package="java.awt.geom.Area"/>
        <import package="java.awt.geom.PathIterator"/>
        <import package="java.awt.geom.Point2D"/>
        <import package="java.awt.geom.Rectangle2D"/>
        <import package="java.awt.geom.Line2D"/>
        <import package="java.awt.image.BufferedImage"/>
        <import package="sun.awt.image.ByteComponentRaster"/>
        <import package="java.awt.print.PageFormat"/>
        <import package="java.awt.print.Printable"/>
        <import package="java.awt.print.PrinterException"/>
        <import package="java.awt.print.PrinterJob"/>
        <class name="PSPathGraphics" line="54">
            <extends class="PathGraphics"/>
            <comment line="733">
                Fill the path defined by &lt;code&gt;pathIter&lt;code&gt;
                 with the specified color.
                 The path is provided in current user space.                
            </comment>
            <comment line="744">
                Draw the bounding rectangle using path by calling draw()
                 function and passing a rectangle shape.                
            </comment>
            <comment line="754">
                Draw a line using path by calling draw() function and passing
                 a line shape.                
            </comment>
            <comment line="764">
                Fill the rectangle with the specified color by calling fill().                
            </comment>
            <comment line="773">
                This method should not be invoked by PSPathGraphics.
                 FIX: Rework PathGraphics so that this method is
                 not an abstract method there.                
            </comment>
            <javadoc line="54">
                This class converts paths into PostScript
                  by breaking all graphics into fills and
                  clips of paths.                
            </javadoc>
            <declaration name="DEFAULT_USER_RES" type="int" line="62"/>
            <javadoc line="62">
                For a drawing application the initial user space
                  resolution is 72dpi.                
            </javadoc>
            <method name="PSPathGraphics" type="constructor" line="70">
                <params>
                    <param name="graphics" type="Graphics2D"/>
                    <param name="printerJob" type="PrinterJob"/>
                    <param name="painter" type="Printable"/>
                    <param name="pageFormat" type="PageFormat"/>
                    <param name="pageIndex" type="int"/>
                    <param name="canRedraw" type="boolean"/>
                </params>
            </method>
            <javadoc line="74">
                Creates a new &lt;code&gt;Graphics&lt;/code&gt; object that is
                  a copy of this &lt;code&gt;Graphics&lt;/code&gt; object.                
                <return>
                    a new graphics context that is a copy of
                      this graphics context.                    
                </return>
                <since>
                    JDK1.0                    
                </since>
            </javadoc>
            <method name="create" type="Graphics" line="81"/>
            <javadoc line="92">
                Override the inherited implementation of fill
                  so that we can generate PostScript in user space
                  rather than device space.                
            </javadoc>
            <method name="fill" type="void" line="97">
                <params>
                    <param name="s" type="Shape"/>
                    <param name="color" type="Color"/>
                </params>
            </method>
            <javadoc line="101">
                Draws the text given by the specified string, using this
                  graphics context&apos;s current font and color. The baseline of the
                  first character is at position (&lt;i&gt;x&lt;/i&gt;,&amp;nbsp;&lt;i&gt;y&lt;/i&gt;) in this
                  graphics context&apos;s coordinate system.                
                <param>
                    str      the string to be drawn.                    
                </param>
                <param>
                    x        the &lt;i&gt;x&lt;/i&gt; coordinate.                    
                </param>
                <param>
                    y        the &lt;i&gt;y&lt;/i&gt; coordinate.                    
                </param>
                <see>
                    java.awt.Graphics#drawBytes                    
                </see>
                <see>
                    java.awt.Graphics#drawChars                    
                </see>
                <since>
                    JDK1.0                    
                </since>
            </javadoc>
            <method name="drawString" type="void" line="113">
                <params>
                    <param name="str" type="String"/>
                    <param name="x" type="int"/>
                    <param name="y" type="int"/>
                </params>
            </method>
            <javadoc line="117">
                Renders the text specified by the specified &lt;code&gt;String&lt;/code&gt;,
                  using the current &lt;code&gt;Font&lt;/code&gt; and &lt;code&gt;Paint&lt;/code&gt; attributes
                  in the &lt;code&gt;Graphics2D&lt;/code&gt; context.
                  The baseline of the first character is at position
                  (&lt;i&gt;x&lt;/i&gt;,&amp;nbsp;&lt;i&gt;y&lt;/i&gt;) in the User Space.
                  The rendering attributes applied include the &lt;code&gt;Clip&lt;/code&gt;,
                  &lt;code&gt;Transform&lt;/code&gt;, &lt;code&gt;Paint&lt;/code&gt;, &lt;code&gt;Font&lt;/code&gt; and
                  &lt;code&gt;Composite&lt;/code&gt; attributes. For characters in script systems
                  such as Hebrew and Arabic, the glyphs can be rendered from right to
                  left, in which case the coordinate supplied is the location of the
                  leftmost character on the baseline.                
                <param>
                    s the &lt;code&gt;String&lt;/code&gt; to be rendered                    
                </param>
                <param>
                    x,&amp;nbsp;y the coordinates where the &lt;code&gt;String&lt;/code&gt;
                      should be rendered                    
                </param>
                <see>
                    #setPaint                    
                </see>
                <see>
                    java.awt.Graphics#setColor                    
                </see>
                <see>
                    java.awt.Graphics#setFont                    
                </see>
                <see>
                    #setTransform                    
                </see>
                <see>
                    #setComposite                    
                </see>
                <see>
                    #setClip                    
                </see>
            </javadoc>
            <method name="drawString" type="void" line="139">
                <params>
                    <param name="str" type="String"/>
                    <param name="x" type="float"/>
                    <param name="y" type="float"/>
                </params>
            </method>
            <method name="canDrawStringToWidth" type="boolean" line="144"/>
            <method name="platformFontCount" type="int" line="148">
                <params>
                    <param name="font" type="Font"/>
                    <param name="str" type="String"/>
                </params>
                <declaration name="psPrinterJob" type="PSPrinterJob" line="149"/>
            </method>
            <method name="drawString" type="void" line="154">
                <params>
                    <param name="str" type="String"/>
                    <param name="x" type="float"/>
                    <param name="y" type="float"/>
                    <param name="font" type="Font"/>
                    <param name="frc" type="FontRenderContext"/>
                    <param name="w" type="float"/>
                </params>
                <comment line="160">
                    If the Font has layout attributes we need to delegate to TextLayout.
                     TextLayout renders text as GlyphVectors. We try to print those
                     using printer fonts - ie using Postscript text operators so
                     we may be reinvoked. In that case the &quot;!printingGlyphVector&quot; test
                     prevents us recursing and instead sends us into the body of the
                     method where we can safely ignore layout attributes as those
                     are already handled by TextLayout.                    
                </comment>
                <comment line="189">
                    TYPE_TRANSLATION is a flag bit but we can do &quot;==&quot; here
                     because we want to detect when its just that bit set and                    
                </comment>
                <comment line="209">
                    Set the text color.
                     We should not be in this shape printing path
                     if the application is drawing with non-solid
                     colors. We should be in the raster path. Because
                     we are here in the shape path, the cast of the
                     paint to a Color should be fine.                    
                </comment>
                <comment line="235">
                    The text could not be converted directly to PS text
                     calls so decompose the text into a shape.                    
                </comment>
                <scope line="155"/>
                <scope line="167">
                    <declaration name="layout" type="TextLayout" line="168"/>
                </scope>
                <declaration name="oldFont" type="Font" line="173"/>
                <scope line="174"/>
                <scope line="176"/>
                <declaration name="drawnWithPS" type="boolean" line="180"/>
                <declaration name="translateX" type="float" line="182"/>
                <declaration name="fontisTransformed" type="boolean" line="183"/>
                <scope line="185">
                    <declaration name="fontTx" type="AffineTransform" line="186"/>
                    <declaration name="transformType" type="int" line="187"/>
                    <scope line="192"/>
                </scope>
                <declaration name="directToPS" type="boolean" line="201"/>
                <scope line="203">
                    <declaration name="psPrinterJob" type="PSPrinterJob" line="205"/>
                    <scope line="206">
                        <scope line="215"/>
                        <scope line="217">
                            <scope line="218"/>
                        </scope>
                    </scope>
                </scope>
                <scope line="237">
                    <scope line="238"/>
                </scope>
                <scope line="245"/>
            </method>
            <javadoc line="250">
                The various &lt;code&gt;drawImage()&lt;/code&gt; methods for
                  &lt;code&gt;WPathGraphics&lt;/code&gt; are all decomposed
                  into an invocation of &lt;code&gt;drawImageToPlatform&lt;/code&gt;.
                  The portion of the passed in image defined by
                  &lt;code&gt;srcX, srcY, srcWidth, and srcHeight&lt;/code&gt;
                  is transformed by the supplied AffineTransform and
                  drawn using PS to the printer context.                
                <param>
                    img     The image to be drawn.
                      This method does nothing if &lt;code&gt;img&lt;/code&gt; is null.                    
                </param>
                <param>
                    xform   Used to tranform the image before drawing.
                      This can be null.                    
                </param>
                <param>
                    bgcolor This color is drawn where the image has transparent
                      pixels. If this parameter is null then the
                      pixels already in the destination should show
                      through.                    
                </param>
                <param>
                    srcX    With srcY this defines the upper-left corner
                      of the portion of the image to be drawn.                    
                </param>
                <param>
                    srcY    With srcX this defines the upper-left corner
                      of the portion of the image to be drawn.                    
                </param>
                <param>
                    srcWidth    The width of the portion of the image to
                      be drawn.                    
                </param>
                <param>
                    srcHeight   The height of the portion of the image to
                      be drawn.                    
                </param>
                <param>
                    handlingTransparency if being recursively called to
                      print opaque region of transparent image                    
                </param>
            </javadoc>
            <method name="drawImageToPlatform" type="boolean" line="283">
                <params>
                    <param name="image" type="Image"/>
                    <param name="xform" type="AffineTransform"/>
                    <param name="bgcolor" type="Color"/>
                    <param name="srcX" type="int"/>
                    <param name="srcY" type="int"/>
                    <param name="srcWidth" type="int"/>
                    <param name="srcHeight" type="int"/>
                    <param name="handlingTransparency" type="boolean"/>
                </params>
                <comment line="293">
                    The full transform to be applied to the image is the
                     caller&apos;s transform concatenated on to the transform
                     from user space to device space. If the caller didn&apos;t
                     supply a transform then we just act as if they passed
                     in the identify transform.                    
                </comment>
                <comment line="305">
                    Split the full transform into a pair of
                     transforms. The first transform holds effects
                     such as rotation and shearing. The second transform
                     is setup to hold only the scaling effects.
                     These transforms are created such that a point,
                     p, in user space, when transformed by &apos;fullTransform&apos;
                     lands in the same place as when it is transformed
                     by &apos;rotTransform&apos; and then &apos;scaleTransform&apos;.
                    
                     The entire image transformation is not in Java in order
                     to minimize the amount of memory needed in the VM. By
                     dividing the transform in two, we rotate and shear
                     the source image in its own space and only go to
                     the, usually, larger, device space when we ask
                     PostScript to perform the final scaling.                    
                </comment>
                <comment line="324">
                    Calculate the amount of scaling in the x
                     and y directions. This scaling is computed by
                     transforming a unit vector along each axis
                     and computing the resulting magnitude.
                     The computed values &apos;scaleX&apos; and &apos;scaleY&apos;
                     represent the amount of scaling PS will be asked
                     to perform.
                     Clamp this to the device scale for better quality printing.                    
                </comment>
                <comment line="347">
                                        
                </comment>
                <comment line="357">
                    We do not need to draw anything if either scaling
                     factor is zero.                    
                </comment>
                <comment line="362">
                    Here&apos;s the transformation we will do with Java2D,                    
                </comment>
                <comment line="365">
                    m00                    
                </comment>
                <comment line="366">
                    m10                    
                </comment>
                <comment line="367">
                    m01                    
                </comment>
                <comment line="368">
                    m11                    
                </comment>
                <comment line="369">
                    m02                    
                </comment>
                <comment line="370">
                    m12                    
                </comment>
                <comment line="372">
                    The scale transform is not used directly: we instead
                     directly multiply by scaleX and scaleY.
                    
                     Conceptually here is what the scaleTransform is:
                    
                     AffineTransform scaleTransform = new AffineTransform(
                                          scaleX,                     m00
                                          0,                          m10
                                          0,                          m01
                                          scaleY,                     m11
                                          0,                          m02
                                          0);                         m12                    
                </comment>
                <comment line="386">
                    Convert the image source&apos;s rectangle into the rotated
                     and sheared space. Once there, we calculate a rectangle
                     that encloses the resulting shape. It is this rectangle
                     which defines the size of the BufferedImage we need to
                     create to hold the transformed image.                    
                </comment>
                <comment line="399">
                    add a fudge factor as some fp precision problems have
                     been observed which caused pixels to be rounded down and
                     out of the image.                    
                </comment>
                <comment line="413">
                    If the image has transparent or semi-transparent
                     pixels then we&apos;ll have the application re-render
                     the portion of the page covered by the image.
                     This will be done in a later call to print using the
                     saved graphics state.
                     However several special cases can be handled otherwise:
                     - bitmask transparency with a solid background colour
                     - images which have transparency color models but no
                     transparent pixels
                     - images with bitmask transparency and an IndexColorModel
                     (the common transparent GIF case) can be handled by
                     rendering just the opaque pixels.                    
                </comment>
                <comment line="434">
                    image drawn, just return.                    
                </comment>
                <comment line="446">
                    if there&apos;s no transparent pixels there&apos;s no need
                     for a background colour. This can avoid edge artifacts
                     in rotation cases.                    
                </comment>
                <comment line="451">
                    if src region extends beyond the image, the &quot;opaque&quot; path
                     may blit b/g colour (including white) where it shoudn&apos;t.                    
                </comment>
                <comment line="463">
                    m00                    
                </comment>
                <comment line="464">
                    m10                    
                </comment>
                <comment line="465">
                    m01                    
                </comment>
                <comment line="466">
                    m11                    
                </comment>
                <comment line="467">
                    m02                    
                </comment>
                <comment line="468">
                    m12                    
                </comment>
                <comment line="474">
                    Region isn&apos;t user space because its potentially
                     been rotated for landscape.                    
                </comment>
                <comment line="482">
                    Try to limit the amount of memory used to 8Mb, so
                     if at device resolution this exceeds a certain
                     image size then scale down the region to fit in
                     that memory, but never to less than 72 dpi.                    
                </comment>
                <comment line="515">
                    We need to have the clip as part of the saved state,
                     either directly, or all the components that are
                     needed to reconstitute it (image source area,
                     image transform and current graphics transform).
                     The clip is described in user space, so we need to
                     save the current graphics transform anyway so just
                     save these two.                    
                </comment>
                <comment line="528">
                    The image can be rendered directly by PS so we
                     copy it into a BufferedImage (this takes care of
                     ColorSpace and BufferedImageOp issues) and then
                     send that to PS.                    
                </comment>
                <comment line="535">
                    Create a buffered image big enough to hold the portion
                     of the source image being printed.                    
                </comment>
                <comment line="543">
                    Setup a Graphics2D on to the BufferedImage so that the
                     source image when copied, lands within the image buffer.                    
                </comment>
                <comment line="555">
                    Fill the BufferedImage either with the caller supplied
                     color, &apos;bgColor&apos; or, if null, with white.                    
                </comment>
                <comment line="562">
                                        
                </comment>
                <comment line="570">
                    In PSPrinterJob images are printed in device space
                     and therefore we need to set a device space clip.
                     FIX: this is an overly tight coupling of these
                     two classes.
                     The temporary clip set needs to be an intersection
                     with the previous user clip.
                     REMIND: two xfms may lose accuracy in clip path.                    
                </comment>
                <comment line="589">
                    Scale the bounding rectangle by the scale transform.
                     Because the scaling transform has only x and y
                     scaling components it is equivalent to multiply
                     the x components of the bounding rectangle by
                     the x scaling factor and to multiply the y components
                     by the y scaling factor.                    
                </comment>
                <comment line="604">
                    Pull the raster data from the buffered image
                     and pass it along to PS.                    
                </comment>
                <comment line="618">
                                        
                </comment>
                <declaration name="img" type="BufferedImage" line="285"/>
                <scope line="286"/>
                <declaration name="psPrinterJob" type="PSPrinterJob" line="290"/>
                <declaration name="fullTransform" type="AffineTransform" line="298"/>
                <scope line="299"/>
                <declaration name="fullMatrix" type="double[]" line="320"/>
                <declaration name="unitVectorX" type="Point2D.Float" line="332"/>
                <declaration name="unitVectorY" type="Point2D.Float" line="333"/>
                <declaration name="origin" type="Point2D.Float" line="337"/>
                <declaration name="scaleX" type="double" line="338"/>
                <declaration name="scaleY" type="double" line="339"/>
                <declaration name="devResX" type="double" line="341"/>
                <declaration name="devResY" type="double" line="342"/>
                <declaration name="devScaleX" type="double" line="343"/>
                <declaration name="devScaleY" type="double" line="344"/>
                <declaration name="transformType" type="int" line="347"/>
                <declaration name="clampScale" type="boolean" line="348"/>
                <scope line="351"/>
                <scope line="359">
                    <declaration name="rotTransform" type="AffineTransform" line="363"/>
                    <declaration name="srcRect" type="Rectangle2D.Float" line="391"/>
                    <declaration name="rotShape" type="Shape" line="395"/>
                    <declaration name="rotBounds" type="Rectangle2D" line="396"/>
                    <declaration name="boundsWidth" type="int" line="406"/>
                    <declaration name="boundsHeight" type="int" line="407"/>
                    <scope line="409">
                        <declaration name="drawOpaque" type="boolean" line="425"/>
                        <scope line="426">
                            <scope line="428">
                                <scope line="429">
                                    <scope line="432"/>
                                </scope>
                                <scope line="437"/>
                            </scope>
                            <scope line="441"/>
                        </scope>
                        <scope line="444"/>
                        <scope line="454"/>
                        <scope line="457">
                            <declaration name="tx" type="AffineTransform" line="460"/>
                            <declaration name="rect" type="Rectangle2D.Float" line="469"/>
                            <declaration name="shape" type="Shape" line="472"/>
                            <declaration name="region" type="Rectangle2D" line="475"/>
                            <declaration name="w" type="int" line="486"/>
                            <declaration name="h" type="int" line="487"/>
                            <declaration name="nbytes" type="int" line="488"/>
                            <declaration name="maxBytes" type="int" line="489"/>
                            <declaration name="origDpi" type="double" line="490"/>
                            <declaration name="dpi" type="int" line="491"/>
                            <declaration name="scaleFactor" type="double" line="492"/>
                            <declaration name="maxSFX" type="double" line="494"/>
                            <declaration name="maxSFY" type="double" line="495"/>
                            <declaration name="maxSF" type="double" line="496"/>
                            <declaration name="minDpi" type="int" line="497"/>
                            <scope line="500"/>
                            <scope line="505"/>
                        </scope>
                        <scope line="532">
                            <declaration name="deepImage" type="BufferedImage" line="537"/>
                            <declaration name="imageGraphics" type="Graphics2D" line="545"/>
                            <scope line="557"/>
                            <declaration name="holdClip" type="Shape" line="577"/>
                            <declaration name="oldClip" type="Shape" line="578"/>
                            <declaration name="sat" type="AffineTransform" line="580"/>
                            <declaration name="imgClip" type="Shape" line="582"/>
                            <declaration name="imgArea" type="Area" line="583"/>
                            <declaration name="oldArea" type="Area" line="584"/>
                            <declaration name="scaledBounds" type="Rectangle2D.Float" line="595"/>
                            <declaration name="tile" type="ByteComponentRaster" line="606"/>
                        </scope>
                    </scope>
                </scope>
            </method>
            <javadoc line="631">
                Redraw a rectanglular area using a proxy graphics
                  To do this we need to know the rectangular area to redraw and
                  the transform &amp; clip in effect at the time of the original drawImage                
            </javadoc>
            <method name="redrawRegion" type="void" line="640">
                <params>
                    <param name="region" type="Rectangle2D"/>
                    <param name="scaleX" type="double"/>
                    <param name="scaleY" type="double"/>
                    <param name="savedClip" type="Shape"/>
                    <param name="savedTransform" type="AffineTransform"/>
                </params>
                <comment line="648">
                    Create a buffered image big enough to hold the portion
                     of the source image being printed.                    
                </comment>
                <comment line="656">
                    Get a graphics for the application to render into.
                     We initialize the buffer to white in order to
                     match the paper and then we shift the BufferedImage
                     so that it covers the area on the page where the
                     caller&apos;s Image will be drawn.                    
                </comment>
                <comment line="670">
                    Calculate the resolution of the source image.                    
                </comment>
                <comment line="675">
                    The application expects to see user space at 72 dpi.
                     so change user space from image source resolution to
                      72 dpi.                    
                </comment>
                <comment line="686">
                                        
                </comment>
                <comment line="695">
                    In PSPrinterJob images are printed in device space
                     and therefore we need to set a device space clip.                    
                </comment>
                <comment line="701">
                    Scale the bounding rectangle by the scale transform.
                     Because the scaling transform has only x and y
                     scaling components it is equivalent to multiply
                     the x components of the bounding rectangle by
                     the x scaling factor and to multiply the y components
                     by the y scaling factor.                    
                </comment>
                <comment line="716">
                    Pull the raster data from the buffered image
                     and pass it along to PS.                    
                </comment>
                <declaration name="psPrinterJob" type="PSPrinterJob" line="642"/>
                <declaration name="painter" type="Printable" line="643"/>
                <declaration name="pageFormat" type="PageFormat" line="644"/>
                <declaration name="pageIndex" type="int" line="645"/>
                <declaration name="deepImage" type="BufferedImage" line="650"/>
                <declaration name="g" type="Graphics2D" line="661"/>
                <declaration name="proxy" type="ProxyGraphics2D" line="662"/>
                <declaration name="sourceResX" type="float" line="671"/>
                <declaration name="sourceResY" type="float" line="672"/>
                <declaration name="scaledBounds" type="Rectangle2D.Float" line="707"/>
                <declaration name="tile" type="ByteComponentRaster" line="718"/>
            </method>
            <method name="deviceFill" type="void" line="737">
                <params>
                    <param name="pathIter" type="PathIterator"/>
                    <param name="color" type="Color"/>
                </params>
                <declaration name="psPrinterJob" type="PSPrinterJob" line="739"/>
            </method>
            <method name="deviceFrameRect" type="void" line="748">
                <params>
                    <param name="x" type="int"/>
                    <param name="y" type="int"/>
                    <param name="width" type="int"/>
                    <param name="height" type="int"/>
                    <param name="color" type="Color"/>
                </params>
            </method>
            <method name="deviceDrawLine" type="void" line="758">
                <params>
                    <param name="xBegin" type="int"/>
                    <param name="yBegin" type="int"/>
                    <param name="xEnd" type="int"/>
                    <param name="yEnd" type="int"/>
                    <param name="color" type="Color"/>
                </params>
            </method>
            <method name="deviceFillRect" type="void" line="767">
                <params>
                    <param name="x" type="int"/>
                    <param name="y" type="int"/>
                    <param name="width" type="int"/>
                    <param name="height" type="int"/>
                    <param name="color" type="Color"/>
                </params>
            </method>
            <method name="deviceClip" type="void" line="777">
                <params>
                    <param name="pathIter" type="PathIterator"/>
                </params>
            </method>
        </class>
    </source>