<?xml version="1.0" encoding="UTF-8"?>
    <source package="sun.java2d">
        <import package="java.util.Comparator"/>
        <import package="java.util.Collections"/>
        <import package="java.util.Iterator"/>
        <import package="java.util.List"/>
        <import package="java.util.Vector"/>
        <class name="Spans" line="34">
            <comment line="200">
                For debugging.
                
                private void printSpans() {
                System.out.println(&quot;----------&quot;);
                if (mSpans != null) {
                Iterator iter = mSpans.iterator();
                while (iter.hasNext()) {
                Span span = (Span) iter.next();
                System.out.println(span);
                }
                }
                System.out.println(&quot;----------&quot;);
                
                }                
            </comment>
            <javadoc line="34">
                Maintains a list of half-open intervals, called Spans.
                  A Span can be tested against the list of Spans
                  for intersection.                
            </javadoc>
            <declaration name="kMaxAddsSinceSort" type="int" line="41"/>
            <javadoc line="41">
                This class will sort and collapse its span
                  entries after this many span additions via
                  the &lt;code&gt;add&lt;/code&gt; method.                
            </javadoc>
            <declaration name="mSpans" type="List" line="48"/>
            <javadoc line="48">
                Holds a list of individual
                  Span instances.                
            </javadoc>
            <declaration name="mAddsSinceSort" type="int" line="54"/>
            <javadoc line="54">
                The number of &lt;code&gt;Span&lt;/code&gt;
                  instances that have been added
                  to this object without a sort
                  and collapse taking place.                
            </javadoc>
            <method name="Spans" type="constructor" line="62"/>
            <javadoc line="66">
                Add a span covering the half open interval
                  including &lt;code&gt;start&lt;/code&gt; up to
                  but not including &lt;code&gt;end&lt;/code&gt;.                
            </javadoc>
            <method name="add" type="void" line="71">
                <params>
                    <param name="start" type="float"/>
                    <param name="end" type="float"/>
                </params>
                <scope line="73">
                    <scope line="76"/>
                </scope>
            </method>
            <javadoc line="82">
                Add a span which covers the entire range.
                  This call is logically equivalent to
                  &lt;code&gt;add(Float.NEGATIVE_INFINITY, Float.POSITIVE_INFINITY)&lt;/code&gt;
                  The result of making this call is that
                  all future &lt;code&gt;add&lt;/code&gt; calls are ignored
                  and the &lt;code&gt;intersects&lt;/code&gt; method always
                  returns true.                
            </javadoc>
            <method name="addInfinite" type="void" line="91"/>
            <javadoc line="95">
                Returns true if the span defined by the half-open
                  interval from &lt;code&gt;start&lt;/code&gt; up to,
                  but not including, &lt;code&gt;end&lt;/code&gt; intersects
                  any of the spans defined by this instance.                
            </javadoc>
            <method name="intersects" type="boolean" line="101">
                <params>
                    <param name="start" type="float"/>
                    <param name="end" type="float"/>
                </params>
                <comment line="107">
                    If we have added any spans since we last
                     sorted and collapsed our list of spans
                     then we need to resort and collapse.                    
                </comment>
                <comment line="115">
                    The SpanIntersection comparator considers
                     two spans equal if they intersect. If
                     the search finds a match then we have an
                     intersection.                    
                </comment>
                <comment line="126">
                    The addInfinite() method has been invoked so
                     everything intersect this instance.                    
                </comment>
                <declaration name="doesIntersect" type="boolean" line="102"/>
                <scope line="104">
                    <scope line="110"/>
                    <declaration name="found" type="int" line="119"/>
                </scope>
                <scope line="128"/>
            </method>
            <javadoc line="135">
                Sort the spans in ascending order by their
                  start position. After the spans are sorted
                  collapse any spans that intersect into a
                  single span. The result is a sorted,
                  non-overlapping list of spans.                
            </javadoc>
            <method name="sortAndCollapse" type="void" line="142">
                <comment line="150">
                    Have &apos;span&apos; start at the first span in
                     the collection. The collection may be empty
                     so we&apos;re careful.                    
                </comment>
                <comment line="159">
                    Loop over the spans collapsing those that intersect
                     into a single span.                    
                </comment>
                <comment line="166">
                    The spans are in ascending start position
                     order and so the next span&apos;s starting point
                     is either in the span we are trying to grow
                     or it is beyond the first span and thus the
                     two spans do not intersect.
                    
                     span:    &lt;----------&lt;
                     nextSpan:        &lt;------         (intersects)
                     nextSpan:                &lt;------ (doesn&apos;t intersect)
                    
                     If the spans intersect then we&apos;ll remove
                     nextSpan from the list. If nextSpan&apos;s
                     ending was beyond the first&apos;s then
                     we extend the first.
                    
                     span:    &lt;----------&lt;
                     nextSpan:   &lt;-----&lt;              (don&apos;t change span)
                     nextSpan:        &lt;-----------&lt;   (grow span)                    
                </comment>
                <comment line="189">
                    The next span did not intersect the current
                     span and so it can not be collapsed. Instead
                     it becomes the start of the next set of spans
                     to be collapsed.                    
                </comment>
                <declaration name="iter" type="Iterator" line="147"/>
                <declaration name="span" type="Span" line="153"/>
                <scope line="154"/>
                <scope line="161">
                    <declaration name="nextSpan" type="Span" line="163"/>
                    <scope line="185"/>
                    <scope line="193"/>
                </scope>
            </method>
            <class name="Span" line="216">
                <implements interface="Comparable"/>
                <javadoc line="216">
                    Holds a single half-open interval.                    
                </javadoc>
                <declaration name="mStart" type="float" line="221"/>
                <javadoc line="221">
                    The span includes the starting point.                    
                </javadoc>
                <declaration name="mEnd" type="float" line="226"/>
                <javadoc line="226">
                    The span goes up to but does not include
                      the ending point.                    
                </javadoc>
                <javadoc line="232">
                    Create a half-open interval including
                      &lt;code&gt;start&lt;/code&gt; but not including
                      &lt;code&gt;end&lt;/code&gt;.                    
                </javadoc>
                <method name="Span" type="constructor" line="237">
                    <params>
                        <param name="start" type="float"/>
                        <param name="end" type="float"/>
                    </params>
                </method>
                <javadoc line="242">
                    Return the start of the &lt;code&gt;Span&lt;/code&gt;.
                      The start is considered part of the
                      half-open interval.                    
                </javadoc>
                <method name="getStart" type="float" line="247"/>
                <javadoc line="251">
                    Return the end of the &lt;code&gt;Span&lt;/code&gt;.
                      The end is not considered part of the
                      half-open interval.                    
                </javadoc>
                <method name="getEnd" type="float" line="256"/>
                <javadoc line="260">
                    Change the initial position of the
                      &lt;code&gt;Span&lt;/code&gt;.                    
                </javadoc>
                <method name="setStart" type="void" line="264">
                    <params>
                        <param name="start" type="float"/>
                    </params>
                </method>
                <javadoc line="268">
                    Change the terminal position of the
                      &lt;code&gt;Span&lt;/code&gt;.                    
                </javadoc>
                <method name="setEnd" type="void" line="272">
                    <params>
                        <param name="end" type="float"/>
                    </params>
                </method>
                <javadoc line="276">
                    Attempt to alter this &lt;code&gt;Span&lt;/code&gt;
                      to include &lt;code&gt;otherSpan&lt;/code&gt; without
                      altering this span&apos;s starting position.
                      If &lt;code&gt;otherSpan&lt;/code&gt; can be so consumed
                      by this &lt;code&gt;Span&lt;/code&gt; then &lt;code&gt;true&lt;/code&gt;
                      is returned.                    
                </javadoc>
                <method name="subsume" type="boolean" line="284">
                    <params>
                        <param name="otherSpan" type="Span"/>
                    </params>
                    <comment line="287">
                        We can only subsume &apos;otherSpan&apos; if
                         its starting position lies in our
                         interval.                        
                    </comment>
                    <comment line="293">
                        If the other span&apos;s starting position
                         was in our interval and the other span
                         was longer than this span, then we need
                         to grow this span to cover the difference.                        
                    </comment>
                    <declaration name="isSubsumed" type="boolean" line="290"/>
                    <scope line="297"/>
                </method>
                <javadoc line="304">
                    Return true if the passed in position
                      lies in the half-open interval defined
                      by this &lt;code&gt;Span&lt;/code&gt;.                    
                </javadoc>
                <method name="contains" type="boolean" line="309">
                    <params>
                        <param name="pos" type="float"/>
                    </params>
                </method>
                <javadoc line="313">
                    Rank spans according to their starting
                      position. The end position is ignored
                      in this ranking.                    
                </javadoc>
                <method name="compareTo" type="int" line="318">
                    <params>
                        <param name="o" type="Object"/>
                    </params>
                    <declaration name="otherSpan" type="Span" line="319"/>
                    <declaration name="otherStart" type="float" line="320"/>
                    <declaration name="result" type="int" line="321"/>
                    <scope line="323"/>
                    <scope line="325"/>
                    <scope line="327"/>
                </method>
                <method name="toString" type="String" line="334"/>
            </class>
            <class name="SpanIntersection" line="340">
                <implements interface="Comparator"/>
                <javadoc line="340">
                    This class ranks a pair of &lt;code&gt;Span&lt;/code&gt;
                      instances. If the instances intersect they
                      are deemed equal otherwise they are ranked
                      by their relative position. Use
                      &lt;code&gt;SpanIntersection.instance&lt;/code&gt; to
                      get the single instance of this class.                    
                </javadoc>
                <declaration name="instance" type="SpanIntersection" line="350"/>
                <javadoc line="350">
                    This class is a Singleton and the following
                      is the single instance.                    
                </javadoc>
                <javadoc line="357">
                    Only this class can create instances of itself.                    
                </javadoc>
                <method name="SpanIntersection" type="constructor" line="360"/>
                <method name="compare" type="int" line="364">
                    <params>
                        <param name="o1" type="Object"/>
                        <param name="o2" type="Object"/>
                    </params>
                    <comment line="370">
                        Span 1 is entirely to the left of span2.
                         span1:   &lt;-----&lt;
                         span2:            &lt;-----&lt;                        
                    </comment>
                    <comment line="377">
                        Span 2 is entirely to the right of span2.
                         span1:                     &lt;-----&lt;
                         span2:            &lt;-----&lt;                        
                    </comment>
                    <comment line="384">
                        Otherwise they intersect and we declare them equal.                        
                    </comment>
                    <declaration name="result" type="int" line="365"/>
                    <declaration name="span1" type="Span" line="366"/>
                    <declaration name="span2" type="Span" line="367"/>
                    <scope line="373"/>
                    <scope line="380"/>
                    <scope line="385"/>
                </method>
            </class>
        </class>
    </source>