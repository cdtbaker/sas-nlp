<?xml version="1.0" encoding="UTF-8"?>
    <source package="sun.java2d.pipe">
        <import package="java.util.HashSet"/>
        <import package="java.util.Set"/>
        <import package="sun.awt.SunToolkit"/>
        <class name="RenderQueue" line="32">
            <javadoc line="32">
                The RenderQueue class encapsulates a RenderBuffer on which rendering
                  operations are enqueued.  Note that the RenderQueue lock must be acquired
                  before performing any operations on the queue (e.g. enqueuing an operation
                  or flushing the queue).  A sample usage scenario follows:
                  public void drawSomething(...) {
                  rq.lock();
                  try {
                  ctx.validate(...);
                  rq.ensureCapacity(4);
                  rq.getBuffer().putInt(DRAW_SOMETHING);
                  ...
                  } finally {
                  rq.unlock();
                  }
                  }
                  If you are enqueuing an operation that involves 8-byte parameters (i.e.
                  long or double values), it is imperative that you ensure proper
                  alignment of the underlying RenderBuffer.  This can be accomplished
                  simply by providing an offset to the first 8-byte parameter in your
                  operation to the ensureCapacityAndAlignment() method.  For example:
                  public void drawStuff(...) {
                  rq.lock();
                  try {
                  RenderBuffer buf = rq.getBuffer();
                  ctx.validate(...);
                  // 28 total bytes in the operation, 12 bytes to the first long
                  rq.ensureCapacityAndAlignment(28, 12);
                  buf.putInt(DRAW_STUFF);
                  buf.putInt(x).putInt(y);
                  buf.putLong(addr1);
                  buf.putLong(addr2);
                  } finally {
                  rq.unlock();
                  }
                  }                
            </javadoc>
            <declaration name="BUFFER_SIZE" type="int" line="74"/>
            <javadoc line="74">
                The size of the underlying buffer, in bytes.                
            </javadoc>
            <declaration name="buf" type="RenderBuffer" line="77"/>
            <javadoc line="77">
                The underlying buffer for this queue.                
            </javadoc>
            <declaration name="refSet" type="Set" line="80"/>
            <javadoc line="80">
                A Set containing hard references to Objects that must stay alive until
                  the queue has been completely flushed.                
            </javadoc>
            <method name="RenderQueue" type="constructor" line="86"/>
            <javadoc line="91">
                Locks the queue for read/write access.                
            </javadoc>
            <method name="lock" type="void" line="94">
                <comment line="95">
                    Implementation note: In theory we should have two separate locks:
                     one lock to synchronize access to the RenderQueue, and then a
                     separate lock (the AWT lock) that only needs to be acquired when
                     we are about to flush the queue (using native windowing system
                     operations).  In practice it has been difficult to enforce the
                     correct lock ordering; sometimes AWT will have already acquired
                     the AWT lock before grabbing the RQ lock (see 6253009), while the
                     expected order should be RQ lock and then AWT lock.  Due to this
                     issue, using two separate locks is prone to deadlocks.  Therefore,
                     to solve this issue we have decided to eliminate the separate RQ
                     lock and instead just acquire the AWT lock here.  (Someday it might
                     be nice to go back to the old two-lock system, but that would
                     require potentially risky changes to AWT to ensure that it never
                     acquires the AWT lock before calling into 2D code that wants to
                     acquire the RQ lock.)                    
                </comment>
            </method>
            <javadoc line="115">
                Attempts to lock the queue.  If successful, this method returns true,
                  indicating that the caller is responsible for calling
                  &lt;code&gt;unlock&lt;/code&gt;; otherwise this method returns false.                
            </javadoc>
            <method name="tryLock" type="boolean" line="120"/>
            <javadoc line="124">
                Unlocks the queue.                
            </javadoc>
            <method name="unlock" type="void" line="127"/>
            <javadoc line="131">
                Adds the given Object to the set of hard references, which will
                  prevent that Object from being disposed until the queue has been
                  flushed completely.  This is useful in cases where some enqueued
                  data could become invalid if the reference Object were garbage
                  collected before the queue could be processed.  (For example, keeping
                  a hard reference to a FontStrike will prevent any enqueued glyph
                  images associated with that strike from becoming invalid before the
                  queue is flushed.)  The reference set will be cleared immediately
                  after the queue is flushed each time.                
            </javadoc>
            <method name="addReference" type="void" line="142">
                <params>
                    <param name="ref" type="Object"/>
                </params>
            </method>
            <javadoc line="146">
                Returns the encapsulated RenderBuffer object.                
            </javadoc>
            <method name="getBuffer" type="RenderBuffer" line="149"/>
            <javadoc line="153">
                Ensures that there will be enough room on the underlying buffer
                  for the following operation.  If the operation will not fit given
                  the remaining space, the buffer will be flushed immediately, leaving
                  an empty buffer for the impending operation.                
                <param>
                    opsize size (in bytes) of the following operation                    
                </param>
            </javadoc>
            <method name="ensureCapacity" type="void" line="161">
                <params>
                    <param name="opsize" type="int"/>
                </params>
                <scope line="162"/>
            </method>
            <javadoc line="167">
                Convenience method that is equivalent to calling ensureCapacity()
                  followed by ensureAlignment().  The ensureCapacity() call allows for an
                  extra 4 bytes of space in case the ensureAlignment() method needs to
                  insert a NOOP token on the buffer.                
                <param>
                    opsize size (in bytes) of the following operation                    
                </param>
                <param>
                    first8ByteValueOffset offset (in bytes) from the current
                      position to the first 8-byte value used in the following operation                    
                </param>
            </javadoc>
            <method name="ensureCapacityAndAlignment" type="void" line="179">
                <params>
                    <param name="opsize" type="int"/>
                    <param name="first8ByteValueOffset" type="int"/>
                </params>
            </method>
            <javadoc line="184">
                Inserts a 4-byte NOOP token when necessary to ensure that all 8-byte
                  parameters for the following operation are added to the underlying
                  buffer with an 8-byte memory alignment.                
                <param>
                    first8ByteValueOffset offset (in bytes) from the current
                      position to the first 8-byte value used in the following operation                    
                </param>
            </javadoc>
            <method name="ensureAlignment" type="void" line="192">
                <params>
                    <param name="first8ByteValueOffset" type="int"/>
                </params>
                <declaration name="first8ByteValuePosition" type="int" line="193"/>
                <scope line="194"/>
            </method>
            <method name="flushNow" type="void" line="199"/>
            <javadoc line="199">
                Immediately processes each operation currently pending on the buffer.
                  This method will block until the entire buffer has been flushed.  The
                  queue lock must be acquired before calling this method.                
            </javadoc>
            <method name="flushAndInvokeNow" type="void" line="206"/>
            <javadoc line="206">
                Immediately processes each operation currently pending on the buffer,
                  and then invokes the provided task.  This method will block until the
                  entire buffer has been flushed and the provided task has been executed.
                  The queue lock must be acquired before calling this method.                
            </javadoc>
            <javadoc line="214">
                Updates the current position of the underlying buffer, and then
                  flushes the queue immediately.  This method is useful when native code
                  has added data to the queue and needs to flush immediately.                
            </javadoc>
            <method name="flushNow" type="void" line="219">
                <params>
                    <param name="position" type="int"/>
                </params>
            </method>
        </class>
    </source>