<?xml version="1.0" encoding="UTF-8"?>
    <source package="sun.java2d.pipe">
        <import package="java.awt.AlphaComposite"/>
        <import package="java.awt.Color"/>
        <import package="java.awt.Graphics2D"/>
        <import package="java.awt.Image"/>
        <import package="java.awt.Rectangle"/>
        <import package="java.awt.Transparency"/>
        <import package="java.awt.geom.AffineTransform"/>
        <import package="java.awt.geom.NoninvertibleTransformException"/>
        <import package="java.awt.image.AffineTransformOp"/>
        <import package="java.awt.image.BufferedImage"/>
        <import package="java.awt.image.BufferedImageOp"/>
        <import package="java.awt.image.ColorModel"/>
        <import package="java.awt.image.DataBuffer"/>
        <import package="java.awt.image.DirectColorModel"/>
        <import package="java.awt.image.ImageObserver"/>
        <import package="java.awt.image.IndexColorModel"/>
        <import package="java.awt.image.Raster"/>
        <import package="java.awt.image.VolatileImage"/>
        <import package="java.awt.image.WritableRaster"/>
        <import package="java.awt.image.ImagingOpException"/>
        <import package="sun.awt.SunHints"/>
        <import package="sun.awt.image.ImageRepresentation"/>
        <import package="sun.awt.image.ToolkitImage"/>
        <import package="sun.java2d.InvalidPipeException"/>
        <import package="sun.java2d.SunGraphics2D"/>
        <import package="sun.java2d.SurfaceData"/>
        <import package="sun.java2d.loops.Blit"/>
        <import package="sun.java2d.loops.BlitBg"/>
        <import package="sun.java2d.loops.TransformHelper"/>
        <import package="sun.java2d.loops.MaskBlit"/>
        <import package="sun.java2d.loops.CompositeType"/>
        <import package="sun.java2d.loops.ScaledBlit"/>
        <import package="sun.java2d.loops.SurfaceType"/>
        <class name="DrawImage" line="62">
            <comment line="134">
                This method is only called in those circumstances where the
                 operation has a non-null secondary transform specfied.  Its
                 role is to check for various optimizations based on the types
                 of both the secondary and SG2D transforms and to do some
                 quick calculations to avoid having to combine the transforms
                 andor to call a more generalized method.                
            </comment>
            <comment line="221">
                This method is called with a final rendering transform that
                 has combined all of the information about the Graphics2D
                 transform attribute with the transformations specified by
                 the arguments to the drawImage call.
                 Its role is to see if the combined transform ends up being
                 acceleratable by either a renderImageCopy or renderImageScale
                 once all of the math is done.
                
                 Note: The transform supplied here has an origin that is
                 already adjusted to point to the device location where
                 the (sx1, sy1) location of the source image should be placed.                
            </comment>
            <comment line="272">
                Check the bounding coordinates of the transformed source
                 image to see if they fall on integer coordinates such
                 that they will cause no interpolation anomalies if we
                 use our simplified Blit or ScaledBlit operations instead
                 of a full transform operation.                
            </comment>
            <comment line="318">
                Return a BufferedImage of the requested type with the indicated
                 subimage of the original image located at 0,0 in the new image.
                 If a bgColor is supplied, composite the original image over that
                 color with a SrcOver operation, otherwise make a SrcNoEa copy.                
            </comment>
            <comment line="551">
                Render an image using only integer translation
                 (no scale or transform or sub-pixel interpolated translations).                
            </comment>
            <comment line="608">
                Render an image using only integer scaling (no transform).                
            </comment>
            <comment line="835">
                Return the color model to be used with this BufferedImage and
                 transform.                
            </comment>
            <implements interface="DrawImagePipe"/>
            <method name="copyImage" type="boolean" line="67">
                <params>
                    <param name="sg" type="SunGraphics2D"/>
                    <param name="img" type="Image"/>
                    <param name="x" type="int"/>
                    <param name="y" type="int"/>
                    <param name="bgColor" type="Color"/>
                </params>
                <declaration name="imgw" type="int" line="68"/>
                <declaration name="imgh" type="int" line="69"/>
                <scope line="70"/>
                <declaration name="atfm" type="AffineTransform" line="75"/>
                <scope line="76"/>
            </method>
            <method name="copyImage" type="boolean" line="88">
                <params>
                    <param name="sg" type="SunGraphics2D"/>
                    <param name="img" type="Image"/>
                    <param name="dx" type="int"/>
                    <param name="dy" type="int"/>
                    <param name="sx" type="int"/>
                    <param name="sy" type="int"/>
                    <param name="w" type="int"/>
                    <param name="h" type="int"/>
                    <param name="bgColor" type="Color"/>
                </params>
                <scope line="89"/>
            </method>
            <method name="scaleImage" type="boolean" line="102">
                <params>
                    <param name="sg" type="SunGraphics2D"/>
                    <param name="img" type="Image"/>
                    <param name="x" type="int"/>
                    <param name="y" type="int"/>
                    <param name="width" type="int"/>
                    <param name="height" type="int"/>
                    <param name="bgColor" type="Color"/>
                </params>
                <comment line="106">
                    Only accelerate scale if:
                              - w/h positive values
                              - sg transform integer translate/identity only
                              - no bgColor in operation                    
                </comment>
                <declaration name="imgw" type="int" line="103"/>
                <declaration name="imgh" type="int" line="104"/>
                <scope line="109">
                    <declaration name="dx1" type="double" line="110"/>
                    <declaration name="dy1" type="double" line="111"/>
                    <declaration name="dx2" type="double" line="112"/>
                    <declaration name="dy2" type="double" line="113"/>
                    <scope line="117"/>
                </scope>
                <declaration name="atfm" type="AffineTransform" line="122"/>
                <scope line="123"/>
            </method>
            <method name="transformImage" type="void" line="143">
                <params>
                    <param name="sg" type="SunGraphics2D"/>
                    <param name="img" type="Image"/>
                    <param name="x" type="int"/>
                    <param name="y" type="int"/>
                    <param name="extraAT" type="AffineTransform"/>
                    <param name="interpType" type="int"/>
                </params>
                <comment line="154">
                    First optimization - both are some kind of translate                    
                </comment>
                <comment line="156">
                    Combine the translations and check if interpolation is necessary.                    
                </comment>
                <comment line="175">
                    Second optimization - both are some kind of translate or scale                    
                </comment>
                <comment line="177">
                    Combine the scales and check if interpolation is necessary.                    
                </comment>
                <comment line="179">
                    Transform source bounds by extraAT,
                     then translate the bounds again by x, y
                     then transform the bounds again by sg.transform                    
                </comment>
                <comment line="202">
                    Begin Transform                    
                </comment>
                <comment line="207">
                    Do not try any more optimizations if either of the cases
                     above was tried as we have already verified that the
                     resulting transform will not simplify.                    
                </comment>
                <comment line="211">
                    In this case neither of the above simple transform
                     pairs was found so we will do some final tests on
                     the final rendering transform which may be the
                     simple product of two complex transforms.                    
                </comment>
                <declaration name="txtype" type="int" line="144"/>
                <declaration name="imgw" type="int" line="145"/>
                <declaration name="imgh" type="int" line="146"/>
                <declaration name="checkfinalxform" type="boolean" line="147"/>
                <scope line="152">
                    <declaration name="tx" type="double" line="156"/>
                    <declaration name="ty" type="double" line="157"/>
                    <declaration name="itx" type="int" line="160"/>
                    <declaration name="ity" type="int" line="161"/>
                    <scope line="164"/>
                </scope>
                <scope line="173">
                    <declaration name="coords" type="double" line="181"/>
                    <scope line="193"/>
                </scope>
                <scope line="197"/>
                <declaration name="tx" type="AffineTransform" line="202"/>
                <scope line="209"/>
                <scope line="215"/>
            </method>
            <method name="transformImage" type="void" line="237">
                <params>
                    <param name="sg" type="SunGraphics2D"/>
                    <param name="img" type="Image"/>
                    <param name="tx" type="AffineTransform"/>
                    <param name="interpType" type="int"/>
                    <param name="sx1" type="int"/>
                    <param name="sy1" type="int"/>
                    <param name="sx2" type="int"/>
                    <param name="sy2" type="int"/>
                    <param name="bgColor" type="Color"/>
                </params>
                <comment line="239">
                    Transform 3 source corners by tx and analyze them
                     for simplified operations (Copy or Scale).  Using
                     3 points lets us analyze any kind of transform,
                     even transforms that involve very tiny amounts of
                     rotation or skew to see if they degenerate to a
                     simple scale or copy operation within the allowable
                     error bounds.
                     Note that we use (0,0,w,h) instead of (sx1,sy1,sx2,sy2)
                     because the transform is already translated such that
                     the origin is where sx1, sy1 should go.                    
                </comment>
                <comment line="250">
                                        
                </comment>
                <comment line="251">
                                        
                </comment>
                <comment line="255">
                    First test if the X coords of the transformed UL
                     and LL points match and that the Y coords of the
                     transformed LR and LL points also match.
                     If they do then it is a &quot;rectilinear&quot; transform and
                     tryCopyOrScale will make sure it is upright and
                     integer-based.                    
                </comment>
                <declaration name="coords" type="double" line="248"/>
                <scope line="264"/>
            </method>
            <method name="tryCopyOrScale" type="boolean" line="284">
                <params>
                    <param name="sg" type="SunGraphics2D"/>
                    <param name="img" type="Image"/>
                    <param name="sx1" type="int"/>
                    <param name="sy1" type="int"/>
                    <param name="sx2" type="int"/>
                    <param name="sy2" type="int"/>
                    <param name="bgColor" type="Color"/>
                    <param name="interpType" type="int"/>
                    <param name="coords" type="double"/>
                </params>
                <comment line="290">
                    First check if width and height are very close to img w&amp;h.                    
                </comment>
                <comment line="292">
                    Round location to nearest pixel and then test
                     if it will cause interpolation anomalies.                    
                </comment>
                <comment line="305">
                    (For now) We can only use our ScaledBlits if the image
                     is upright (i.e. dw &amp; dh both &gt; 0)                    
                </comment>
                <declaration name="dx" type="double" line="285"/>
                <declaration name="dy" type="double" line="286"/>
                <declaration name="dw" type="double" line="287"/>
                <declaration name="dh" type="double" line="288"/>
                <scope line="290">
                    <declaration name="idx" type="int" line="293"/>
                    <declaration name="idy" type="int" line="294"/>
                    <scope line="297"/>
                </scope>
                <scope line="306">
                    <scope line="310"/>
                </scope>
            </method>
            <method name="makeBufferedImage" type="BufferedImage" line="325">
                <params>
                    <param name="img" type="Image"/>
                    <param name="bgColor" type="Color"/>
                    <param name="type" type="int"/>
                    <param name="sx1" type="int"/>
                    <param name="sy1" type="int"/>
                    <param name="sx2" type="int"/>
                    <param name="sy2" type="int"/>
                </params>
                <declaration name="bimg" type="BufferedImage" line="326"/>
                <declaration name="g2d" type="Graphics2D" line="327"/>
                <scope line="329"/>
            </method>
            <method name="renderImageXform" type="void" line="343">
                <params>
                    <param name="sg" type="SunGraphics2D"/>
                    <param name="img" type="Image"/>
                    <param name="tx" type="AffineTransform"/>
                    <param name="interpType" type="int"/>
                    <param name="sx1" type="int"/>
                    <param name="sy1" type="int"/>
                    <param name="sx2" type="int"/>
                    <param name="sy2" type="int"/>
                    <param name="bgColor" type="Color"/>
                </params>
                <comment line="359">
                    REMIND: Is this correct?  Can this happen?                    
                </comment>
                <comment line="365">
                    We cannot perform bg operations during transform so make
                     an opaque temp image with the appropriate background
                     and work from there.                    
                </comment>
                <comment line="370">
                    Temp image has appropriate subimage at 0,0 now.                    
                </comment>
                <comment line="385">
                    We have no helper for this source image type.
                     But we know that we do have helpers for both RGB and ARGB,
                     so convert to one of those types depending on transparency.
                     ARGB_PRE might be a better choice if the source image has
                     alpha, but it may cause some recursion here since we only
                     tend to have converters that convert to ARGB.                    
                </comment>
                <comment line="396">
                    Temp image has appropriate subimage at 0,0 now.                    
                </comment>
                <comment line="407">
                    assert(helper != null);                    
                </comment>
                <comment line="414">
                    Non-invertible transform means no output                    
                </comment>
                <comment line="418">
                    Find the maximum bounds on the destination that will be
                     affected by the transformed source.  First, transform all
                     four corners of the source and then min and max the resulting
                     destination coordinates of the transformed corners.
                     Note that tx already has the offset to sx1,sy1 accounted
                     for so we use the box (0, 0, sx2-sx1, sy2-sy1) as the
                     source coordinates.                    
                </comment>
                <comment line="428">
                                        
                </comment>
                <comment line="429">
                                        
                </comment>
                <comment line="430">
                                        
                </comment>
                <comment line="454">
                    NOTE: We either have, or we can make,
                     a MaskBlit for any alpha composite type                    
                </comment>
                <comment line="461">
                    NOTE: We can only use the native TransformHelper
                     func to go directly to the dest if both the helper
                     and the MaskBlit are native.
                     All helpers are native at this point, but some MaskBlit
                     objects are implemented in Java, so we need to check.                    
                </comment>
                <comment line="468">
                    We can render directly.                    
                </comment>
                <comment line="479">
                    NOTE: We either have, or we can make,
                     a Blit for any composite type, even Custom                    
                </comment>
                <comment line="488">
                    We need to transform to a temp image and then copy
                     just the pieces that are valid data to the dest.                    
                </comment>
                <comment line="498">
                    The helper function fills a temporary edges buffer
                     for us with the bounding coordinates of each scanline
                     in the following format:
                    
                     edges[0, 1] = [top y, bottom y)
                     edges[2, 3] = [left x, right x) of top row
                     ...
                     edges[h2, h2+1] = [left x, right x) of bottom row
                    
                     all coordinates in the edges array will be relative to dx1, dy1
                    
                     edges thus has to be h2+2 in length                    
                </comment>
                <comment line="513">
                    It is important that edges[0]=edges[1]=0 when we call
                     Transform in case it must return early and we would
                     not want to render anything on an error condition.                    
                </comment>
                <comment line="523">
                    Now copy the results, scanline by scanline, into the dest.
                     The edges array helps us minimize the work.                    
                </comment>
                <declaration name="clip" type="Region" line="344"/>
                <declaration name="dstData" type="SurfaceData" line="345"/>
                <declaration name="srcData" type="SurfaceData" line="346"/>
                <scope line="351">
                    <scope line="357"/>
                </scope>
                <scope line="363"/>
                <declaration name="srcType" type="SurfaceType" line="380"/>
                <declaration name="helper" type="TransformHelper" line="381"/>
                <scope line="383">
                    <declaration name="type" type="int" line="391"/>
                </scope>
                <declaration name="itx" type="AffineTransform" line="409"/>
                <scope line="410"/>
                <scope line="412"/>
                <declaration name="coords" type="double" line="426"/>
                <declaration name="ddx1" type="double" line="433"/>
                <scope line="436">
                    <declaration name="d" type="double" line="437"/>
                </scope>
                <declaration name="dx1" type="int" line="444"/>
                <declaration name="dy1" type="int" line="445"/>
                <declaration name="dx2" type="int" line="446"/>
                <declaration name="dy2" type="int" line="447"/>
                <declaration name="dstType" type="SurfaceType" line="449"/>
                <declaration name="maskblit" type="MaskBlit" line="450"/>
                <declaration name="blit" type="Blit" line="451"/>
                <scope line="452">
                    <scope line="466"/>
                </scope>
                <scope line="477"/>
                <declaration name="tmpimg" type="BufferedImage" line="489"/>
                <declaration name="tmpData" type="SurfaceData" line="491"/>
                <declaration name="tmpType" type="SurfaceType" line="492"/>
                <declaration name="tmpmaskblit" type="MaskBlit" line="493"/>
                <declaration name="edges" type="int" line="511"/>
                <declaration name="index" type="int" line="526"/>
                <scope line="527">
                    <declaration name="relx1" type="int" line="528"/>
                    <declaration name="relx2" type="int" line="529"/>
                    <scope line="530"/>
                    <scope line="533"/>
                    <scope line="540"/>
                </scope>
            </method>
            <method name="renderImageCopy" type="boolean" line="557">
                <params>
                    <param name="sg" type="SunGraphics2D"/>
                    <param name="img" type="Image"/>
                    <param name="bgColor" type="Color"/>
                    <param name="dx" type="int"/>
                    <param name="dy" type="int"/>
                    <param name="sx" type="int"/>
                    <param name="sy" type="int"/>
                    <param name="w" type="int"/>
                    <param name="h" type="int"/>
                </params>
                <comment line="563">
                    Loop up to twice through; this gives us a chance to
                     revalidate the surfaceData objects in case of an exception
                     and try it once more                    
                </comment>
                <comment line="587">
                    Something else caused the exception, throw it...                    
                </comment>
                <comment line="591">
                    NOP if we have been disposed                    
                </comment>
                <comment line="593">
                    Always catch the exception; try this a couple of times
                     and fail silently if the system is not yet ready to
                     revalidate the source or dest surfaceData objects.                    
                </comment>
                <comment line="597">
                    ensures sg.surfaceData is valid                    
                </comment>
                <declaration name="clip" type="Region" line="558"/>
                <declaration name="dstData" type="SurfaceData" line="559"/>
                <declaration name="attempts" type="int" line="561"/>
                <scope line="565">
                    <declaration name="srcData" type="SurfaceData" line="566"/>
                    <scope line="571"/>
                    <scope line="575">
                        <declaration name="srcType" type="SurfaceType" line="576"/>
                        <declaration name="dstType" type="SurfaceType" line="577"/>
                    </scope>
                    <scope line="582">
                        <scope line="585"/>
                    </scope>
                    <scope line="591">
                        <scope line="600"/>
                    </scope>
                </scope>
            </method>
            <method name="renderImageScale" type="boolean" line="614">
                <params>
                    <param name="sg" type="SunGraphics2D"/>
                    <param name="img" type="Image"/>
                    <param name="bgColor" type="Color"/>
                    <param name="interpType" type="int"/>
                    <param name="sx1" type="int"/>
                    <param name="sy1" type="int"/>
                    <param name="sx2" type="int"/>
                    <param name="sy2" type="int"/>
                    <param name="dx1" type="double"/>
                    <param name="dy1" type="double"/>
                    <param name="dx2" type="double"/>
                    <param name="dy2" type="double"/>
                </params>
                <comment line="616">
                    Currently only NEAREST_NEIGHBOR interpolation is implemented
                     for ScaledBlit operations.                    
                </comment>
                <comment line="626">
                    Loop up to twice through; this gives us a chance to
                     revalidate the surfaceData objects in case of an exception
                     and try it once more                    
                </comment>
                <comment line="649">
                    Something else caused the exception, throw it...                    
                </comment>
                <comment line="653">
                    NOP if we have been disposed                    
                </comment>
                <comment line="655">
                    Always catch the exception; try this a couple of times
                     and fail silently if the system is not yet ready to
                     revalidate the source or dest surfaceData objects.                    
                </comment>
                <comment line="659">
                    ensures sg.surfaceData is valid                    
                </comment>
                <scope line="617"/>
                <declaration name="clip" type="Region" line="621"/>
                <declaration name="dstData" type="SurfaceData" line="622"/>
                <declaration name="attempts" type="int" line="624"/>
                <scope line="628">
                    <declaration name="srcData" type="SurfaceData" line="629"/>
                    <scope line="635"/>
                    <scope line="639">
                        <declaration name="srcType" type="SurfaceType" line="640"/>
                        <declaration name="dstType" type="SurfaceType" line="641"/>
                    </scope>
                    <scope line="646">
                        <scope line="647"/>
                    </scope>
                    <scope line="653">
                        <scope line="662"/>
                    </scope>
                </scope>
            </method>
            <method name="scaleImage" type="boolean" line="673">
                <params>
                    <param name="sg" type="SunGraphics2D"/>
                    <param name="img" type="Image"/>
                    <param name="dx1" type="int"/>
                    <param name="dy1" type="int"/>
                    <param name="dx2" type="int"/>
                    <param name="dy2" type="int"/>
                    <param name="sx1" type="int"/>
                    <param name="sy1" type="int"/>
                    <param name="sx2" type="int"/>
                    <param name="sy2" type="int"/>
                    <param name="bgColor" type="Color"/>
                </params>
                <comment line="717">
                    Only accelerate scale if it does not involve a flip or transform                    
                </comment>
                <comment line="745">
                    Make sure we are not out of bounds                    
                </comment>
                <comment line="763">
                    Note: src[WH] are currently the right and bottom coordinates.
                     The following two lines would adjust src[WH] back to being
                     dimensions.
                         srcW -= srcX;
                         srcH -= srcY;
                     Since transformImage needs right and bottom coords we will
                     omit this adjustment.                    
                </comment>
                <declaration name="srcW" type="int" line="674"/>
                <declaration name="srcX" type="int" line="675"/>
                <declaration name="srcWidthFlip" type="boolean" line="676"/>
                <declaration name="srcHeightFlip" type="boolean" line="677"/>
                <declaration name="dstWidthFlip" type="boolean" line="678"/>
                <declaration name="dstHeightFlip" type="boolean" line="679"/>
                <scope line="681"/>
                <scope line="684"/>
                <scope line="689"/>
                <scope line="692"/>
                <scope line="697"/>
                <scope line="700"/>
                <scope line="705"/>
                <scope line="708"/>
                <scope line="713"/>
                <scope line="720">
                    <declaration name="ddx1" type="double" line="721"/>
                    <declaration name="ddy1" type="double" line="722"/>
                    <declaration name="ddx2" type="double" line="723"/>
                    <declaration name="ddy2" type="double" line="724"/>
                    <scope line="728"/>
                </scope>
                <declaration name="atfm" type="AffineTransform" line="733"/>
                <declaration name="m00" type="double" line="735"/>
                <declaration name="m11" type="double" line="736"/>
                <declaration name="imgW" type="int" line="740"/>
                <declaration name="imgH" type="int" line="741"/>
                <scope line="745"/>
                <scope line="748"/>
                <scope line="751"/>
                <scope line="755"/>
                <scope line="759"/>
            </method>
            <declaration name="MAX_TX_ERROR" type="double" line="775"/>
            <javadoc line="775">
                Utilities
                  The following methods are used by the public methods above
                  for performing various operations                
            </javadoc>
            <method name="closeToInteger" type="boolean" line="797">
                <params>
                    <param name="i" type="int"/>
                    <param name="d" type="double"/>
                </params>
            </method>
            <method name="isSimpleTranslate" type="boolean" line="801">
                <params>
                    <param name="sg" type="SunGraphics2D"/>
                </params>
                <comment line="805">
                    Integer translates are always &quot;simple&quot;                    
                </comment>
                <comment line="809">
                    Scales and beyond are always &quot;not simple&quot;                    
                </comment>
                <comment line="812">
                    non-integer translates are only simple when not interpolating                    
                </comment>
                <declaration name="ts" type="int" line="802"/>
                <scope line="803"/>
                <scope line="807"/>
                <scope line="812"/>
            </method>
            <method name="isBgOperation" type="boolean" line="818">
                <params>
                    <param name="srcData" type="SurfaceData"/>
                    <param name="bgColor" type="Color"/>
                </params>
                <comment line="820">
                    If we cannot get the srcData, then cannot assume anything about
                     the image                    
                </comment>
            </method>
            <method name="getBufferedImage" type="BufferedImage" line="826">
                <params>
                    <param name="img" type="Image"/>
                </params>
                <comment line="831">
                    Must be VolatileImage; get BufferedImage representation                    
                </comment>
                <scope line="827"/>
            </method>
            <method name="getTransformColorModel" type="ColorModel" line="840">
                <params>
                    <param name="sg" type="SunGraphics2D"/>
                    <param name="bImg" type="BufferedImage"/>
                    <param name="tx" type="AffineTransform"/>
                </params>
                <comment line="855">
                    Check out the matrix.  A non-integral scale will force ARGB
                     since the edge conditions cannot be guaranteed.                    
                </comment>
                <comment line="864">
                    Just need to make sure that we have a transparent pixel                    
                </comment>
                <comment line="866">
                    Fix 4221407                    
                </comment>
                <comment line="875">
                    Only scaling so do not need to create                    
                </comment>
                <comment line="892">
                                        
                </comment>
                <comment line="893">
                                        
                </comment>
                <comment line="894">
                                        
                </comment>
                <comment line="895">
                                        
                </comment>
                <comment line="897">
                    Need a bitmask transparency
                     REMIND: for now, use full transparency since no loops
                     for bitmask                    
                </comment>
                <comment line="902">
                                        
                </comment>
                <comment line="908">
                    Need a bitmask transparency
                     REMIND: for now, use full transparency since no loops
                     for bitmask                    
                </comment>
                <declaration name="cm" type="ColorModel" line="841"/>
                <declaration name="dstCM" type="ColorModel" line="842"/>
                <scope line="844"/>
                <declaration name="type" type="int" line="847"/>
                <declaration name="needTrans" type="boolean" line="848"/>
                <scope line="851">
                    <declaration name="mtx" type="double[]" line="852"/>
                </scope>
                <scope line="859">
                    <scope line="860">
                        <declaration name="raster" type="Raster" line="861"/>
                        <declaration name="icm" type="IndexColorModel" line="862"/>
                        <scope line="864">
                            <scope line="866"/>
                            <scope line="869">
                                <declaration name="matrix" type="double[]" line="870"/>
                                <scope line="873"/>
                                <scope line="876">
                                    <declaration name="mapSize" type="int" line="877"/>
                                    <scope line="878">
                                        <declaration name="cmap" type="int[]" line="879"/>
                                    </scope>
                                    <scope line="888"/>
                                </scope>
                            </scope>
                        </scope>
                    </scope>
                    <scope line="895"/>
                </scope>
                <scope line="902">
                    <scope line="906"/>
                </scope>
            </method>
            <method name="blitSurfaceData" type="void" line="926">
                <params>
                    <param name="sg" type="SunGraphics2D"/>
                    <param name="clipRegion" type="Region"/>
                    <param name="srcData" type="SurfaceData"/>
                    <param name="dstData" type="SurfaceData"/>
                    <param name="srcType" type="SurfaceType"/>
                    <param name="dstType" type="SurfaceType"/>
                    <param name="sx" type="int"/>
                    <param name="sy" type="int"/>
                    <param name="dx" type="int"/>
                    <param name="dy" type="int"/>
                    <param name="w" type="int"/>
                    <param name="h" type="int"/>
                    <param name="bgColor" type="Color"/>
                </params>
                <comment line="929">
                    Fix for bugid 4783274 - BlitBg throws an exception for
                     a particular set of anomalous parameters.
                     REMIND: The native loops do proper clipping and would
                     detect this situation themselves, but the Java loops
                     all seem to trust their parameters a little too well
                     to the point where they will try to process a negative
                     area of pixels and throw exceptions.  The real fix is
                     to modify the Java loops to do proper clipping so that
                     they can deal with negative dimensions as well as
                     improperly large dimensions, but that fix is too risky
                     to integrate for Mantis at this point.  In the meantime
                     eliminating the negative or zero dimensions here is
                     &quot;correct&quot; and saves them from some nasty exceptional
                     conditions, one of which is the test case of 4783274.                    
                </comment>
                <scope line="927"/>
                <declaration name="comp" type="CompositeType" line="946"/>
                <scope line="951"/>
                <scope line="954">
                    <declaration name="blit" type="Blit" line="955"/>
                </scope>
                <scope line="958">
                    <declaration name="blit" type="BlitBg" line="959"/>
                </scope>
            </method>
            <method name="scaleSurfaceData" type="boolean" line="975">
                <params>
                    <param name="sg" type="SunGraphics2D"/>
                    <param name="clipRegion" type="Region"/>
                    <param name="srcData" type="SurfaceData"/>
                    <param name="dstData" type="SurfaceData"/>
                    <param name="srcType" type="SurfaceType"/>
                    <param name="dstType" type="SurfaceType"/>
                    <param name="sx1" type="int"/>
                    <param name="sy1" type="int"/>
                    <param name="sx2" type="int"/>
                    <param name="sy2" type="int"/>
                    <param name="dx1" type="double"/>
                    <param name="dy1" type="double"/>
                    <param name="dx2" type="double"/>
                    <param name="dy2" type="double"/>
                </params>
                <declaration name="comp" type="CompositeType" line="976"/>
                <scope line="979"/>
                <declaration name="blit" type="ScaledBlit" line="983"/>
                <scope line="984"/>
            </method>
            <method name="imageReady" type="boolean" line="994">
                <params>
                    <param name="sunimg" type="ToolkitImage"/>
                    <param name="observer" type="ImageObserver"/>
                </params>
                <scope line="995">
                    <scope line="996"/>
                </scope>
            </method>
            <method name="copyImage" type="boolean" line="1009">
                <params>
                    <param name="sg" type="SunGraphics2D"/>
                    <param name="img" type="Image"/>
                    <param name="x" type="int"/>
                    <param name="y" type="int"/>
                    <param name="bgColor" type="Color"/>
                    <param name="observer" type="ImageObserver"/>
                </params>
                <scope line="1010"/>
                <scope line="1012">
                    <declaration name="sunimg" type="ToolkitImage" line="1013"/>
                    <scope line="1014"/>
                    <declaration name="ir" type="ImageRepresentation" line="1017"/>
                </scope>
            </method>
            <method name="copyImage" type="boolean" line="1025">
                <params>
                    <param name="sg" type="SunGraphics2D"/>
                    <param name="img" type="Image"/>
                    <param name="dx" type="int"/>
                    <param name="dy" type="int"/>
                    <param name="sx" type="int"/>
                    <param name="sy" type="int"/>
                    <param name="w" type="int"/>
                    <param name="h" type="int"/>
                    <param name="bgColor" type="Color"/>
                    <param name="observer" type="ImageObserver"/>
                </params>
                <scope line="1026"/>
                <scope line="1028">
                    <declaration name="sunimg" type="ToolkitImage" line="1029"/>
                    <scope line="1030"/>
                    <declaration name="ir" type="ImageRepresentation" line="1033"/>
                </scope>
            </method>
            <method name="scaleImage" type="boolean" line="1045">
                <params>
                    <param name="sg" type="SunGraphics2D"/>
                    <param name="img" type="Image"/>
                    <param name="x" type="int"/>
                    <param name="y" type="int"/>
                    <param name="width" type="int"/>
                    <param name="height" type="int"/>
                    <param name="bgColor" type="Color"/>
                    <param name="observer" type="ImageObserver"/>
                </params>
                <scope line="1046"/>
                <scope line="1048">
                    <declaration name="sunimg" type="ToolkitImage" line="1049"/>
                    <scope line="1050"/>
                    <declaration name="ir" type="ImageRepresentation" line="1053"/>
                </scope>
            </method>
            <method name="scaleImage" type="boolean" line="1063">
                <params>
                    <param name="sg" type="SunGraphics2D"/>
                    <param name="img" type="Image"/>
                    <param name="dx1" type="int"/>
                    <param name="dy1" type="int"/>
                    <param name="dx2" type="int"/>
                    <param name="dy2" type="int"/>
                    <param name="sx1" type="int"/>
                    <param name="sy1" type="int"/>
                    <param name="sx2" type="int"/>
                    <param name="sy2" type="int"/>
                    <param name="bgColor" type="Color"/>
                    <param name="observer" type="ImageObserver"/>
                </params>
                <scope line="1064"/>
                <scope line="1067">
                    <declaration name="sunimg" type="ToolkitImage" line="1068"/>
                    <scope line="1069"/>
                    <declaration name="ir" type="ImageRepresentation" line="1072"/>
                </scope>
            </method>
            <method name="transformImage" type="boolean" line="1080">
                <params>
                    <param name="sg" type="SunGraphics2D"/>
                    <param name="img" type="Image"/>
                    <param name="atfm" type="AffineTransform"/>
                    <param name="observer" type="ImageObserver"/>
                </params>
                <scope line="1081"/>
                <scope line="1084">
                    <declaration name="sunimg" type="ToolkitImage" line="1085"/>
                    <scope line="1086"/>
                    <declaration name="ir" type="ImageRepresentation" line="1089"/>
                </scope>
            </method>
            <method name="transformImage" type="void" line="1096">
                <params>
                    <param name="sg" type="SunGraphics2D"/>
                    <param name="img" type="BufferedImage"/>
                    <param name="op" type="BufferedImageOp"/>
                    <param name="x" type="int"/>
                    <param name="y" type="int"/>
                </params>
                <scope line="1097">
                    <scope line="1098">
                        <declaration name="atop" type="AffineTransformOp" line="1099"/>
                    </scope>
                    <scope line="1104"/>
                </scope>
            </method>
        </class>
    </source>