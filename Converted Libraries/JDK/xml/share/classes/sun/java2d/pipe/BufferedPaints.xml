<?xml version="1.0" encoding="UTF-8"?>
    <source package="sun.java2d.pipe">
        <import package="java.awt.Color"/>
        <import package="java.awt.GradientPaint"/>
        <import package="java.awt.LinearGradientPaint"/>
        <import package="java.awt.MultipleGradientPaint"/>
        <import package="java.awt.MultipleGradientPaint.ColorSpaceType"/>
        <import package="java.awt.MultipleGradientPaint.CycleMethod"/>
        <import package="java.awt.Paint"/>
        <import package="java.awt.RadialGradientPaint"/>
        <import package="java.awt.TexturePaint"/>
        <import package="java.awt.geom.AffineTransform"/>
        <import package="java.awt.geom.Point2D"/>
        <import package="java.awt.geom.Rectangle2D"/>
        <import package="java.awt.image.AffineTransformOp"/>
        <import package="java.awt.image.BufferedImage"/>
        <import package="sun.awt.image.PixelConverter"/>
        <import package="sun.java2d.SunGraphics2D"/>
        <import package="sun.java2d.SurfaceData"/>
        <import package="sun.java2d.loops.CompositeType"/>
        <import package="sun.java2d.loops.SurfaceType"/>
        <import package="sun.java2d.pipe.BufferedOpCodes"/>
        <class name="BufferedPaints" line="49">
            <comment line="99">
                                
            </comment>
            <comment line="213">
                                
            </comment>
            <comment line="287">
                                
            </comment>
            <comment line="366">
                                
            </comment>
            <comment line="456">
                                
            </comment>
            <method name="setPaint" type="void" line="53">
                <params>
                    <param name="rq" type="RenderQueue"/>
                    <param name="sg2d" type="SunGraphics2D"/>
                    <param name="paint" type="Paint"/>
                    <param name="ctxflags" type="int"/>
                </params>
                <scope line="54"/>
                <scope line="56">
                    <declaration name="useMask" type="boolean" line="57"/>
                </scope>
            </method>
            <method name="resetPaint" type="void" line="81">
                <params>
                    <param name="rq" type="RenderQueue"/>
                </params>
                <comment line="83">
                    assert rq.lock.isHeldByCurrentThread();                    
                </comment>
                <declaration name="buf" type="RenderBuffer" line="84"/>
            </method>
            <javadoc line="88">
                Color support                
            </javadoc>
            <method name="setColor" type="void" line="90">
                <params>
                    <param name="rq" type="RenderQueue"/>
                    <param name="pixel" type="int"/>
                </params>
                <comment line="92">
                    assert rq.lock.isHeldByCurrentThread();                    
                </comment>
                <declaration name="buf" type="RenderBuffer" line="93"/>
            </method>
            <javadoc line="100">
                Note: This code is factored out into a separate static method
                  so that it can be shared by both the Gradient and LinearGradient
                  implementations.  LinearGradient uses this code (for the
                  two-color sRGB case only) because it can be much faster than the
                  equivalent implementation that uses fragment shaders.
                  We use OpenGL&apos;s texture coordinate generator to automatically
                  apply a smooth gradient (either cyclic or acyclic) to the geometry
                  being rendered.  This technique is almost identical to the one
                  described in the comments for BufferedPaints.setTexturePaint(),
                  except the calculations take place in one dimension instead of two.
                  Instead of an anchor rectangle in the TexturePaint case, we use
                  the vector between the two GradientPaint end points in our
                  calculations.  The generator uses a single plane equation that
                  takes the (x,y) location (in device space) of the fragment being
                  rendered to calculate a (u) texture coordinate for that fragment:
                  u = Ax + By + Cz + Dw
                  The gradient renderer uses a two-pixel 1D texture where the first
                  pixel contains the first GradientPaint color, and the second pixel
                  contains the second GradientPaint color.  (Note that we use the
                  GL_CLAMP_TO_EDGE wrapping mode for acyclic gradients so that we
                  clamp the colors properly at the extremes.)  The following diagram
                  attempts to show the layout of the texture containing the two
                  GradientPaint colors (C1 and C2):
                  +-----------------+
                  |   C1   |   C2   |
                  |        |        |
                  +-----------------+
                  u=0  .25  .5   .75  1
                  We calculate our plane equation constants (A,B,D) such that u=0.25
                  corresponds to the first GradientPaint end point in user space and
                  u=0.75 corresponds to the second end point.  This is somewhat
                  non-obvious, but since the gradient colors are generated by
                  interpolating between C1 and C2, we want the pure color at the
                  end points, and we will get the pure color only when u correlates
                  to the center of a texel.  The following chart shows the expected
                  color for some sample values of u (where C&apos; is the color halfway
                  between C1 and C2):
                  u value      acyclic (GL_CLAMP)      cyclic (GL_REPEAT)
                  -------      ------------------      ------------------
                  -0.25              C1                       C2
                  0.0               C1                       C&apos;
                  0.25              C1                       C1
                  0.5               C&apos;                       C&apos;
                  0.75              C2                       C2
                  1.0               C2                       C&apos;
                  1.25              C2                       C1
                  Original inspiration for this technique came from UMD&apos;s Agile2D
                  project (GradientManager.java).                
            </javadoc>
            <method name="setGradientPaint" type="void" line="160">
                <params>
                    <param name="rq" type="RenderQueue"/>
                    <param name="at" type="AffineTransform"/>
                    <param name="c1" type="Color"/>
                    <param name="c2" type="Color"/>
                    <param name="pt1" type="Point2D"/>
                    <param name="pt2" type="Point2D"/>
                    <param name="isCyclic" type="boolean"/>
                    <param name="useMask" type="boolean"/>
                </params>
                <comment line="162">
                    convert gradient colors to IntArgbPre format                    
                </comment>
                <comment line="167">
                    calculate plane equation constants                    
                </comment>
                <comment line="171">
                    now gradient point 1 is at the origin                    
                </comment>
                <comment line="176">
                    now gradient point 2 is on the positive x-axis                    
                </comment>
                <comment line="178">
                    now gradient point 2 is at (0.5, 0)                    
                </comment>
                <comment line="180">
                    now gradient point 1 is at (0.25, 0), point 2 is at (0.75, 0)                    
                </comment>
                <comment line="192">
                    assert rq.lock.isHeldByCurrentThread();                    
                </comment>
                <declaration name="pc" type="PixelConverter" line="162"/>
                <declaration name="pixel1" type="int" line="163"/>
                <declaration name="pixel2" type="int" line="164"/>
                <declaration name="x" type="double" line="167"/>
                <declaration name="y" type="double" line="168"/>
                <declaration name="len" type="double" line="173"/>
                <declaration name="p0" type="double" line="181"/>
                <scope line="182"/>
                <scope line="187"/>
                <declaration name="buf" type="RenderBuffer" line="193"/>
            </method>
            <method name="setGradientPaint" type="void" line="205">
                <params>
                    <param name="rq" type="RenderQueue"/>
                    <param name="sg2d" type="SunGraphics2D"/>
                    <param name="paint" type="GradientPaint"/>
                    <param name="useMask" type="boolean"/>
                </params>
            </method>
            <javadoc line="214">
                We use OpenGL&apos;s texture coordinate generator to automatically
                  map the TexturePaint image to the geometry being rendered.  The
                  generator uses two separate plane equations that take the (x,y)
                  location (in device space) of the fragment being rendered to
                  calculate (u,v) texture coordinates for that fragment:
                  u = Ax + By + Cz + Dw
                  v = Ex + Fy + Gz + Hw
                  Since we use a 2D orthographic projection, we can assume that z=0
                  and w=1 for any fragment.  So we need to calculate appropriate
                  values for the plane equation constants (A,B,D) and (E,F,H) such
                  that {u,v}=0 for the top-left of the TexturePaint&apos;s anchor
                  rectangle and {u,v}=1 for the bottom-right of the anchor rectangle.
                  We can easily make the texture image repeat for {u,v} values
                  outside the range [0,1] by specifying the GL_REPEAT texture wrap
                  mode.
                  Calculating the plane equation constants is surprisingly simple.
                  We can think of it as an inverse matrix operation that takes
                  device space coordinates and transforms them into user space
                  coordinates that correspond to a location relative to the anchor
                  rectangle.  First, we translate and scale the current user space
                  transform by applying the anchor rectangle bounds.  We then take
                  the inverse of this affine transform.  The rows of the resulting
                  inverse matrix correlate nicely to the plane equation constants
                  we were seeking.                
            </javadoc>
            <method name="setTexturePaint" type="void" line="246">
                <params>
                    <param name="rq" type="RenderQueue"/>
                    <param name="sg2d" type="SunGraphics2D"/>
                    <param name="paint" type="TexturePaint"/>
                    <param name="useMask" type="boolean"/>
                </params>
                <comment line="257">
                    calculate plane equation constants                    
                </comment>
                <comment line="276">
                    assert rq.lock.isHeldByCurrentThread();                    
                </comment>
                <declaration name="bi" type="BufferedImage" line="247"/>
                <declaration name="dstData" type="SurfaceData" line="248"/>
                <declaration name="srcData" type="SurfaceData" line="249"/>
                <declaration name="filter" type="boolean" line="252"/>
                <declaration name="at" type="AffineTransform" line="257"/>
                <declaration name="anchor" type="Rectangle2D" line="258"/>
                <declaration name="xp0" type="double" line="262"/>
                <scope line="263"/>
                <scope line="271"/>
                <declaration name="buf" type="RenderBuffer" line="277"/>
            </method>
            <declaration name="MULTI_MAX_FRACTIONS" type="int" line="288"/>
            <javadoc line="288">
                The maximum number of gradient &quot;stops&quot; supported by our native
                  fragment shader implementations.
                  This value has been empirically determined and capped to allow
                  our native shaders to run on all shader-level graphics hardware,
                  even on the older, more limited GPUs.  Even the oldest Nvidia
                  hardware could handle 16, or even 32 fractions without any problem.
                  But the first-generation boards from ATI would fall back into
                  software mode (which is unusably slow) for values larger than 12;
                  it appears that those boards do not have enough native registers
                  to support the number of array accesses required by our gradient
                  shaders.  So for now we will cap this value at 12, but we can
                  re-evaluate this in the future as hardware becomes more capable.                
            </javadoc>
            <javadoc line="305">
                Helper function to convert a color component in sRGB space to
                  linear RGB space.  Copied directly from the
                  MultipleGradientPaintContext class.                
            </javadoc>
            <method name="convertSRGBtoLinearRGB" type="int" line="310">
                <params>
                    <param name="color" type="int"/>
                </params>
                <declaration name="input" type="float" line="311"/>
                <scope line="314"/>
                <scope line="316"/>
            </method>
            <javadoc line="323">
                Helper function to convert a (non-premultiplied) Color in sRGB
                  space to an IntArgbPre pixel value, optionally in linear RGB space.
                  Based on the PixelConverter.ArgbPre.rgbToPixel() method.                
            </javadoc>
            <method name="colorToIntArgbPrePixel" type="int" line="328">
                <params>
                    <param name="c" type="Color"/>
                    <param name="linear" type="boolean"/>
                </params>
                <declaration name="rgb" type="int" line="329"/>
                <scope line="330"/>
                <declaration name="a" type="int" line="333"/>
                <declaration name="r" type="int" line="334"/>
                <declaration name="g" type="int" line="335"/>
                <declaration name="b" type="int" line="336"/>
                <scope line="337"/>
                <declaration name="a2" type="int" line="342"/>
            </method>
            <javadoc line="349">
                Converts the given array of Color objects into an int array
                  containing IntArgbPre pixel values.  If the linear parameter
                  is true, the Color values will be converted into a linear RGB
                  color space before being returned.                
            </javadoc>
            <method name="convertToIntArgbPrePixels" type="int[]" line="357">
                <params>
                    <param name="colors" type="Color[]"/>
                    <param name="linear" type="boolean"/>
                </params>
                <declaration name="pixels" type="int[]" line="358"/>
                <scope line="359"/>
            </method>
            <javadoc line="367">
                This method uses techniques that are nearly identical to those
                  employed in setGradientPaint() above.  The primary difference
                  is that at the native level we use a fragment shader to manually
                  apply the plane equation constants to the current fragment position
                  to calculate the gradient position in the range [0,1] (the native
                  code for GradientPaint does the same, except that it uses OpenGL&apos;s
                  automatic texture coordinate generation facilities).
                  One other minor difference worth mentioning is that
                  setGradientPaint() calculates the plane equation constants
                  such that the gradient end points are positioned at 0.25 and 0.75
                  (for reasons discussed in the comments for that method).  In
                  contrast, for LinearGradientPaint we setup the equation constants
                  such that the gradient end points fall at 0.0 and 1.0.  The
                  reason for this difference is that in the fragment shader we
                  have more control over how the gradient values are interpreted
                  (depending on the paint&apos;s CycleMethod).                
            </javadoc>
            <method name="setLinearGradientPaint" type="void" line="390">
                <params>
                    <param name="rq" type="RenderQueue"/>
                    <param name="sg2d" type="SunGraphics2D"/>
                    <param name="paint" type="LinearGradientPaint"/>
                    <param name="useMask" type="boolean"/>
                </params>
                <comment line="404">
                    delegate to the optimized two-color gradient codepath                    
                </comment>
                <comment line="418">
                    calculate plane equation constants                    
                </comment>
                <comment line="422">
                    now gradient point 1 is at the origin                    
                </comment>
                <comment line="427">
                    now gradient point 2 is on the positive x-axis                    
                </comment>
                <comment line="429">
                    now gradient point 1 is at (0.0, 0), point 2 is at (1.0, 0)                    
                </comment>
                <comment line="441">
                    assert rq.lock.isHeldByCurrentThread();                    
                </comment>
                <declaration name="linear" type="boolean" line="391"/>
                <declaration name="colors" type="Color[]" line="393"/>
                <declaration name="numStops" type="int" line="394"/>
                <declaration name="pt1" type="Point2D" line="395"/>
                <declaration name="pt2" type="Point2D" line="396"/>
                <declaration name="at" type="AffineTransform" line="397"/>
                <scope line="402">
                    <declaration name="isCyclic" type="boolean" line="404"/>
                </scope>
                <declaration name="cycleMethod" type="int" line="413"/>
                <declaration name="fractions" type="float[]" line="414"/>
                <declaration name="pixels" type="int[]" line="415"/>
                <declaration name="x" type="double" line="418"/>
                <declaration name="y" type="double" line="419"/>
                <declaration name="len" type="double" line="424"/>
                <declaration name="p0" type="float" line="430"/>
                <scope line="431"/>
                <scope line="436"/>
                <declaration name="buf" type="RenderBuffer" line="442"/>
            </method>
            <javadoc line="457">
                This method calculates six m values and a focusX value that
                  are used by the native fragment shader.  These techniques are
                  based on a whitepaper by Daniel Rice on radial gradient performance
                  (attached to the bug report for 6521533).  One can refer to that
                  document for the complete set of formulas and calculations, but
                  the basic goal is to compose a transform that will convert an
                  (x,y) position in device space into a &quot;u&quot; value that represents
                  the relative distance to the gradient focus point.  The resulting
                  value can be used to look up the appropriate color by linearly
                  interpolating between the two nearest colors in the gradient.                
            </javadoc>
            <method name="setRadialGradientPaint" type="void" line="473">
                <params>
                    <param name="rq" type="RenderQueue"/>
                    <param name="sg2d" type="SunGraphics2D"/>
                    <param name="paint" type="RadialGradientPaint"/>
                    <param name="useMask" type="boolean"/>
                </params>
                <comment line="486">
                    save original (untransformed) center and focus points                    
                </comment>
                <comment line="492">
                    transform from gradient coords to device coords                    
                </comment>
                <comment line="497">
                    transform unit circle to gradient coords; we start with the
                     unit circle (center=(0,0), focus on positive x-axis, radius=1)
                     and then transform into gradient space                    
                </comment>
                <comment line="504">
                    invert to get mapping from device coords to unit circle                    
                </comment>
                <comment line="512">
                    clamp the focus point so that it does not rest on, or outside
                     of, the circumference of the gradient circle                    
                </comment>
                <comment line="516">
                    assert rq.lock.isHeldByCurrentThread();                    
                </comment>
                <declaration name="linear" type="boolean" line="474"/>
                <declaration name="cycleMethod" type="int" line="476"/>
                <declaration name="fractions" type="float[]" line="477"/>
                <declaration name="colors" type="Color[]" line="478"/>
                <declaration name="numStops" type="int" line="479"/>
                <declaration name="pixels" type="int[]" line="480"/>
                <declaration name="center" type="Point2D" line="481"/>
                <declaration name="focus" type="Point2D" line="482"/>
                <declaration name="radius" type="float" line="483"/>
                <declaration name="cx" type="double" line="486"/>
                <declaration name="cy" type="double" line="487"/>
                <declaration name="fx" type="double" line="488"/>
                <declaration name="fy" type="double" line="489"/>
                <declaration name="at" type="AffineTransform" line="492"/>
                <scope line="504"/>
                <scope line="506"/>
                <declaration name="buf" type="RenderBuffer" line="517"/>
            </method>
        </class>
    </source>