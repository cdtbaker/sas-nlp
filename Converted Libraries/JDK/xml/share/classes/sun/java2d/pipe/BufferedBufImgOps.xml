<?xml version="1.0" encoding="UTF-8"?>
    <source package="sun.java2d.pipe">
        <import package="java.awt.color.ColorSpace"/>
        <import package="java.awt.image.AffineTransformOp"/>
        <import package="java.awt.image.BufferedImage"/>
        <import package="java.awt.image.BufferedImageOp"/>
        <import package="java.awt.image.BufferedImageOp"/>
        <import package="java.awt.image.ByteLookupTable"/>
        <import package="java.awt.image.ColorModel"/>
        <import package="java.awt.image.ConvolveOp"/>
        <import package="java.awt.image.IndexColorModel"/>
        <import package="java.awt.image.Kernel"/>
        <import package="java.awt.image.LookupOp"/>
        <import package="java.awt.image.LookupTable"/>
        <import package="java.awt.image.RescaleOp"/>
        <import package="java.awt.image.ShortLookupTable"/>
        <import package="sun.java2d.SurfaceData"/>
        <import package="sun.java2d.loops.CompositeType"/>
        <import package="sun.java2d.pipe.BufferedOpCodes"/>
        <class name="BufferedBufImgOps" line="46">
            <method name="enableBufImgOp" type="void" line="51">
                <params>
                    <param name="rq" type="RenderQueue"/>
                    <param name="srcData" type="SurfaceData"/>
                    <param name="srcImg" type="BufferedImage"/>
                    <param name="biop" type="BufferedImageOp"/>
                </params>
                <scope line="52"/>
                <scope line="54"/>
                <scope line="56"/>
                <scope line="58"/>
            </method>
            <method name="disableBufImgOp" type="void" line="63">
                <params>
                    <param name="rq" type="RenderQueue"/>
                    <param name="biop" type="BufferedImageOp"/>
                </params>
                <scope line="64"/>
                <scope line="66"/>
                <scope line="68"/>
                <scope line="70"/>
            </method>
            <javadoc line="75">
                ConvolveOp support                
            </javadoc>
            <method name="isConvolveOpValid" type="boolean" line="77">
                <params>
                    <param name="cop" type="ConvolveOp"/>
                </params>
                <comment line="81">
                    REMIND: we currently can only handle 3x3 and 5x5 kernels,                    
                </comment>
                <comment line="82">
                    but hopefully this is just a temporary restriction;                    
                </comment>
                <comment line="83">
                    see native shader comments for more details                    
                </comment>
                <declaration name="kernel" type="Kernel" line="78"/>
                <declaration name="kw" type="int" line="79"/>
                <declaration name="kh" type="int" line="80"/>
                <scope line="84"/>
            </method>
            <method name="enableConvolveOp" type="void" line="93">
                <params>
                    <param name="rq" type="RenderQueue"/>
                    <param name="srcData" type="SurfaceData"/>
                    <param name="cop" type="ConvolveOp"/>
                </params>
                <comment line="94">
                    assert rq.lock.isHeldByCurrentThread();                    
                </comment>
                <declaration name="edgeZero" type="boolean" line="95"/>
                <declaration name="kernel" type="Kernel" line="97"/>
                <declaration name="kernelWidth" type="int" line="98"/>
                <declaration name="kernelHeight" type="int" line="99"/>
                <declaration name="kernelSize" type="int" line="100"/>
                <declaration name="sizeofFloat" type="int" line="101"/>
                <declaration name="totalBytesRequired" type="int" line="102"/>
                <declaration name="buf" type="RenderBuffer" line="104"/>
            </method>
            <method name="disableConvolveOp" type="void" line="114">
                <params>
                    <param name="rq" type="RenderQueue"/>
                </params>
                <comment line="115">
                    assert rq.lock.isHeldByCurrentThread();                    
                </comment>
                <declaration name="buf" type="RenderBuffer" line="116"/>
            </method>
            <javadoc line="121">
                RescaleOp support                
            </javadoc>
            <method name="isRescaleOpValid" type="boolean" line="125">
                <params>
                    <param name="rop" type="RescaleOp"/>
                    <param name="srcImg" type="BufferedImage"/>
                </params>
                <comment line="148">
                    Not prepared to deal with other color spaces                    
                </comment>
                <comment line="153">
                    Not really prepared to handle this at the native level, so...                    
                </comment>
                <declaration name="numFactors" type="int" line="126"/>
                <declaration name="srcCM" type="ColorModel" line="127"/>
                <scope line="129"/>
                <scope line="137"/>
                <declaration name="csType" type="int" line="144"/>
                <scope line="147"/>
                <scope line="152"/>
            </method>
            <method name="enableRescaleOp" type="void" line="164">
                <params>
                    <param name="rq" type="RenderQueue"/>
                    <param name="srcData" type="SurfaceData"/>
                    <param name="srcImg" type="BufferedImage"/>
                    <param name="rop" type="RescaleOp"/>
                </params>
                <comment line="165">
                    assert rq.lock.isHeldByCurrentThread();                    
                </comment>
                <comment line="171">
                    Note: The user-provided scale factors and offsets are arranged
                     in RGBA order, regardless of the raw data order of the
                     underlying RasterDataBuffer.  The source image data is ultimately
                     converted into RGBA data when uploaded to an OpenGL texture
                     (even for TYPE_GRAY), so the scale factors and offsets are already
                     in the order expected by the native OpenGL code.
                    
                     However, the offsets provided by the user are in a range dictated
                     by the size of each coloralpha band in the source image.  For
                     example, for 888 data each offset is in the range [0,255],
                     for 555 data each offset is in the range [0,31], and so on.
                     The OpenGL shader only thinks in terms of [0,1], so below we need
                     to normalize the user-provided offset values into the range [0,1].                    
                </comment>
                <comment line="190">
                    To make things easier, we will always pass all four bands                    
                </comment>
                <comment line="191">
                    down to native code...                    
                </comment>
                <comment line="202">
                    Leave alpha untouched...                    
                </comment>
                <comment line="212">
                    Leave alpha untouched...                    
                </comment>
                <comment line="215">
                    (numFactors == 4)                    
                </comment>
                <comment line="220">
                    The user-provided offsets are specified in the range                    
                </comment>
                <comment line="221">
                    of each source color band, but the OpenGL shader only wants                    
                </comment>
                <comment line="222">
                    to deal with data in the range [0,1], so we need to normalize                    
                </comment>
                <comment line="223">
                    each offset value to the range [0,1] here.                    
                </comment>
                <comment line="225">
                    Gray data                    
                </comment>
                <comment line="232">
                    RGB(A) data                    
                </comment>
                <declaration name="srcCM" type="ColorModel" line="166"/>
                <declaration name="nonPremult" type="boolean" line="167"/>
                <declaration name="numFactors" type="int" line="186"/>
                <declaration name="origScaleFactors" type="float[]" line="187"/>
                <declaration name="origOffsets" type="float[]" line="188"/>
                <declaration name="normScaleFactors" type="float[]" line="192"/>
                <declaration name="normOffsets" type="float[]" line="193"/>
                <scope line="195">
                    <scope line="198"/>
                </scope>
                <scope line="205">
                    <scope line="208"/>
                </scope>
                <scope line="215"/>
                <scope line="224">
                    <declaration name="nBits" type="int" line="226"/>
                    <declaration name="maxValue" type="int" line="227"/>
                    <scope line="228"/>
                </scope>
                <scope line="231">
                    <scope line="233">
                        <declaration name="nBits" type="int" line="234"/>
                        <declaration name="maxValue" type="int" line="235"/>
                    </scope>
                </scope>
                <declaration name="sizeofFloat" type="int" line="240"/>
                <declaration name="totalBytesRequired" type="int" line="241"/>
                <declaration name="buf" type="RenderBuffer" line="243"/>
            </method>
            <method name="disableRescaleOp" type="void" line="252">
                <params>
                    <param name="rq" type="RenderQueue"/>
                </params>
                <comment line="253">
                    assert rq.lock.isHeldByCurrentThread();                    
                </comment>
                <declaration name="buf" type="RenderBuffer" line="254"/>
            </method>
            <javadoc line="259">
                LookupOp support                
            </javadoc>
            <method name="isLookupOpValid" type="boolean" line="263">
                <params>
                    <param name="lop" type="LookupOp"/>
                    <param name="srcImg" type="BufferedImage"/>
                </params>
                <comment line="288">
                    Not prepared to deal with other color spaces                    
                </comment>
                <comment line="293">
                    Not really prepared to handle this at the native level, so...                    
                </comment>
                <comment line="297">
                    The LookupTable spec says that &quot;all arrays must be the                    
                </comment>
                <comment line="298">
                    same size&quot; but unfortunately the constructors do not                    
                </comment>
                <comment line="299">
                    enforce that.  Also, our native code only works with                    
                </comment>
                <comment line="300">
                    arrays no larger than 256 elements, so check both of                    
                </comment>
                <comment line="301">
                    these restrictions here.                    
                </comment>
                <declaration name="table" type="LookupTable" line="264"/>
                <declaration name="numComps" type="int" line="265"/>
                <declaration name="srcCM" type="ColorModel" line="266"/>
                <scope line="268"/>
                <scope line="276"/>
                <declaration name="csType" type="int" line="284"/>
                <scope line="287"/>
                <scope line="292"/>
                <scope line="302">
                    <declaration name="data" type="byte[][]" line="303"/>
                    <scope line="304">
                        <scope line="307"/>
                    </scope>
                </scope>
                <scope line="311">
                    <declaration name="data" type="short[][]" line="312"/>
                    <scope line="313">
                        <scope line="316"/>
                    </scope>
                </scope>
                <scope line="320"/>
            </method>
            <method name="enableLookupOp" type="void" line="331">
                <params>
                    <param name="rq" type="RenderQueue"/>
                    <param name="srcData" type="SurfaceData"/>
                    <param name="srcImg" type="BufferedImage"/>
                    <param name="lop" type="LookupOp"/>
                </params>
                <comment line="332">
                    assert rq.lock.isHeldByCurrentThread();                    
                </comment>
                <comment line="349">
                    (table instanceof ByteLookupTable)                    
                </comment>
                <comment line="356">
                    Adjust the LUT length so that it ends on a 4-byte boundary                    
                </comment>
                <declaration name="nonPremult" type="boolean" line="333"/>
                <declaration name="table" type="LookupTable" line="337"/>
                <declaration name="numBands" type="int" line="338"/>
                <declaration name="offset" type="int" line="339"/>
                <declaration name="bandLength" type="int" line="340"/>
                <declaration name="bytesPerElem" type="int" line="341"/>
                <declaration name="shortData" type="boolean" line="342"/>
                <scope line="344">
                    <declaration name="data" type="short[][]" line="345"/>
                </scope>
                <scope line="349">
                    <declaration name="data" type="byte[][]" line="350"/>
                </scope>
                <declaration name="totalLutBytes" type="int" line="357"/>
                <declaration name="paddedLutBytes" type="int" line="358"/>
                <declaration name="padding" type="int" line="359"/>
                <declaration name="totalBytesRequired" type="int" line="360"/>
                <declaration name="buf" type="RenderBuffer" line="362"/>
                <scope line="371">
                    <declaration name="data" type="short[][]" line="372"/>
                    <scope line="373"/>
                </scope>
                <scope line="376">
                    <declaration name="data" type="byte[][]" line="377"/>
                    <scope line="378"/>
                </scope>
                <scope line="382"/>
            </method>
            <method name="disableLookupOp" type="void" line="387">
                <params>
                    <param name="rq" type="RenderQueue"/>
                </params>
                <comment line="388">
                    assert rq.lock.isHeldByCurrentThread();                    
                </comment>
                <declaration name="buf" type="RenderBuffer" line="389"/>
            </method>
        </class>
    </source>