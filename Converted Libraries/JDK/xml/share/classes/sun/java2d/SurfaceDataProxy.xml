<?xml version="1.0" encoding="UTF-8"?>
    <source package="sun.java2d">
        <import package="java.awt.Color"/>
        <import package="java.awt.Rectangle"/>
        <import package="java.awt.AlphaComposite"/>
        <import package="java.awt.GraphicsEnvironment"/>
        <import package="sun.awt.DisplayChangedListener"/>
        <import package="sun.java2d.StateTrackable.State"/>
        <import package="sun.java2d.loops.CompositeType"/>
        <import package="sun.java2d.loops.SurfaceType"/>
        <import package="sun.java2d.loops.Blit"/>
        <import package="sun.java2d.loops.BlitBg"/>
        <import package="sun.awt.image.SurfaceManager"/>
        <import package="sun.awt.image.SurfaceManager.FlushableCacheData"/>
        <import package="java.security.AccessController"/>
        <import package="sun.security.action.GetPropertyAction"/>
        <class name="SurfaceDataProxy" line="16">
            <implements interface="DisplayChangedListener"/>
            <implements interface="SurfaceManager.FlushableCacheData"/>
            <javadoc line="16">
                The proxy class encapsulates the logic for managing alternate
                  SurfaceData representations of a primary SurfaceData.
                  The main class will handle tracking the state changes of the
                  primary SurfaceData and updating the associated SurfaceData
                  proxy variants.
                  &lt;p&gt;
                  Subclasses have 2 main responsibilities:
                  &lt;ul&gt;
                  &lt;li&gt; Override the isSupportedOperation() method to determine if
                  a given operation can be accelerated with a given source
                  SurfaceData
                  &lt;li&gt; Override the validateSurfaceData() method to create or update
                  a given accelerated surface to hold the pixels for the indicated
                  source SurfaceData
                  &lt;/ul&gt;
                  If necessary, a subclass may also override the updateSurfaceData
                  method to transfer the pixels to the accelerated surface.
                  By default the parent class will transfer the pixels using a
                  standard Blit operation between the two SurfaceData objects.                
            </javadoc>
            <declaration name="cachingAllowed" type="boolean" line="38"/>
            <declaration name="defaultThreshold" type="int" line="39"/>
            <scope line="40">
                <declaration name="manimg" type="String" line="42"/>
                <scope line="43"/>
                <declaration name="num" type="String" line="48"/>
                <scope line="49">
                    <scope line="50">
                        <declaration name="parsed" type="int" line="51"/>
                        <scope line="52"/>
                    </scope>
                    <scope line="57"/>
                </scope>
            </scope>
            <method name="isCachingAllowed" type="boolean" line="62"/>
            <method name="isSupportedOperation" type="boolean" line="65"/>
            <javadoc line="65">
                Determine if an alternate form for the srcData is needed
                  and appropriate from the given operational parameters.                
            </javadoc>
            <method name="validateSurfaceData" type="SurfaceData" line="70"/>
            <javadoc line="70">
                Construct an alternate form of the given SurfaceData.
                  The contents of the returned SurfaceData may be undefined
                  since the calling code will take care of updating the
                  contents with a subsequent call to updateSurfaceData.
                  &lt;p&gt;
                  If the method returns null then there was a problem with
                  allocating the accelerated surface.  The getRetryTracker()
                  method will be called to track when to attempt another
                  revalidation.                
            </javadoc>
            <javadoc line="82">
                If the subclass is unable to validate or create a cached
                  SurfaceData then this method will be used to get a
                  StateTracker object that will indicate when to attempt
                  to validate the surface again.  Subclasses may return
                  trackers which count down an ever increasing threshold
                  to provide hysteresis on creating surfaces during low
                  memory conditions.  The default implementation just waits
                  another &quot;threshold&quot; number of accesses before trying again.                
            </javadoc>
            <method name="getRetryTracker" type="StateTracker" line="92">
                <params>
                    <param name="srcData" type="SurfaceData"/>
                </params>
            </method>
            <class name="CountdownTracker" line="95">
                <implements interface="StateTracker"/>
                <declaration name="countdown" type="int" line="96"/>
                <method name="CountdownTracker" type="constructor" line="97">
                    <params>
                        <param name="threshold" type="int"/>
                    </params>
                </method>
                <method name="isCurrent" type="boolean" line="100"/>
            </class>
            <declaration name="UNCACHED" type="SurfaceDataProxy" line="104"/>
            <javadoc line="104">
                This instance is for cases where a caching implementation
                  determines that a particular source image will never need
                  to be cached - either the source SurfaceData was of an
                  incompatible type, or it was in an UNTRACKABLE state or
                  some other factor is discovered that permanently prevents
                  acceleration or caching.
                  This class optimally implements NOP variants of all necessary
                  methods to avoid caching with a minimum of fuss.                
            </javadoc>
            <anonymous_class line="114">
                <method name="isAccelerated" type="boolean" line="115"/>
                <method name="isSupportedOperation" type="boolean" line="118">
                    <params>
                        <param name="srcData" type="SurfaceData"/>
                        <param name="txtype" type="int"/>
                        <param name="comp" type="CompositeType"/>
                        <param name="bgColor" type="Color"/>
                    </params>
                </method>
                <method name="validateSurfaceData" type="SurfaceData" line="121">
                    <params>
                        <param name="srcData" type="SurfaceData"/>
                        <param name="cachedData" type="SurfaceData"/>
                        <param name="w" type="int"/>
                        <param name="h" type="int"/>
                    </params>
                </method>
                <method name="replaceData" type="SurfaceData" line="124">
                    <params>
                        <param name="srcData" type="SurfaceData"/>
                        <param name="txtype" type="int"/>
                        <param name="comp" type="CompositeType"/>
                        <param name="bgColor" type="Color"/>
                    </params>
                </method>
            </anonymous_class>
            <declaration name="threshold" type="int" line="129"/>
            <declaration name="srcTracker" type="StateTracker" line="130"/>
            <declaration name="numtries" type="int" line="131"/>
            <declaration name="cachedSD" type="SurfaceData" line="132"/>
            <declaration name="cacheTracker" type="StateTracker" line="133"/>
            <declaration name="valid" type="boolean" line="134"/>
            <javadoc line="135">
                Create a SurfaceData proxy manager that attempts to create
                  and cache a variant copy of the source SurfaceData after
                  the default threshold number of attempts to copy from the
                  STABLE source.                
            </javadoc>
            <method name="SurfaceDataProxy" type="constructor" line="141"/>
            <javadoc line="144">
                Create a SurfaceData proxy manager that attempts to create
                  and cache a variant copy of the source SurfaceData after
                  the specified threshold number of attempts to copy from
                  the STABLE source.                
            </javadoc>
            <method name="SurfaceDataProxy" type="constructor" line="150">
                <params>
                    <param name="threshold" type="int"/>
                </params>
            </method>
            <javadoc line="156">
                Returns true iff this SurfaceData proxy is still the best
                  way to control caching of the given source on the given
                  destination.                
            </javadoc>
            <method name="isValid" type="boolean" line="161"/>
            <javadoc line="164">
                Sets the valid state to false so that the next time this
                  proxy is fetched to generate a replacement SurfaceData,
                  the code in SurfaceData knows to replace the proxy first.                
            </javadoc>
            <method name="invalidate" type="void" line="169"/>
            <javadoc line="172">
                Flush all cached resources as per the FlushableCacheData interface.
                  The deaccelerated parameter indicates if the flush is
                  happening because the associated surface is no longer
                  being accelerated (for instance the acceleration priority
                  is set below the threshold needed for acceleration).
                  Returns a boolean that indicates if the cached object is
                  no longer needed and should be removed from the cache.                
            </javadoc>
            <method name="flush" type="boolean" line="181">
                <params>
                    <param name="deaccelerated" type="boolean"/>
                </params>
                <scope line="182"/>
            </method>
            <javadoc line="188">
                Actively flushes (drops and invalidates) the cached surface
                  so that it can be reclaimed quickly.                
            </javadoc>
            <method name="flush" type="void" line="192">
                <declaration name="csd" type="SurfaceData" line="193"/>
                <scope line="196"/>
            </method>
            <javadoc line="200">
                Returns true iff this SurfaceData proxy is still valid
                  and if it has a currently cached replacement that is also
                  valid and current.                
            </javadoc>
            <method name="isAccelerated" type="boolean" line="205"/>
            <javadoc line="208">
                This method should be called from subclasses which create
                  cached SurfaceData objects that depend on the current
                  properties of the display.                
            </javadoc>
            <method name="activateDisplayListener" type="void" line="213">
                <declaration name="ge" type="GraphicsEnvironment" line="214"/>
                <scope line="215"/>
            </method>
            <javadoc line="219">
                Invoked when the display mode has changed.
                  This method will invalidate and drop the internal cachedSD object.                
            </javadoc>
            <method name="displayChanged" type="void" line="223"/>
            <javadoc line="226">
                Invoked when the palette has changed.                
            </javadoc>
            <method name="paletteChanged" type="void" line="229"/>
            <javadoc line="232">
                This method attempts to replace the srcData with a cached version.
                  It relies on the subclass to determine if the cached version will
                  be useful given the operational parameters.
                  This method checks any preexisting cached copy for being &quot;up to date&quot;
                  and tries to update it if it is stale or non-existant and the
                  appropriate number of accesses have occured since it last was stale.
                  &lt;p&gt;
                  An outline of the process is as follows:
                  &lt;ol&gt;
                  &lt;li&gt; Check the operational parameters (txtype, comp, bgColor)
                  to make sure that the operation is supported.  Return the
                  original SurfaceData if the operation cannot be accelerated.
                  &lt;li&gt; Check the tracker for the source surface to see if it has
                  remained stable since it was last cached.  Update the state
                  variables to cause both a threshold countdown and an update
                  of the cached copy if it is not.  (Setting cacheTracker to
                  NEVER_CURRENT effectively marks it as &quot;needing to be updated&quot;.)
                  &lt;li&gt; Check the tracker for the cached copy to see if is still
                  valid and up to date.  Note that the cacheTracker may be
                  non-current if either something happened to the cached copy
                  (eg. surfaceLost) or if the source was out of date and the
                  cacheTracker was set to NEVER_CURRENT to force an update.
                  Decrement the countdown and copy the source to the cache
                  as necessary and then update the variables to show that
                  the cached copy is stable.
                  &lt;/ol&gt;                
            </javadoc>
            <method name="replaceData" type="SurfaceData" line="260">
                <params>
                    <param name="srcData" type="SurfaceData"/>
                    <param name="txtype" type="int"/>
                    <param name="comp" type="CompositeType"/>
                    <param name="bgColor" type="Color"/>
                </params>
                <scope line="261">
                    <scope line="262">
                        <scope line="263"/>
                        <scope line="268">
                            <scope line="269"/>
                        </scope>
                    </scope>
                    <declaration name="csd" type="SurfaceData" line="276"/>
                    <scope line="277">
                        <scope line="278">
                            <scope line="279"/>
                        </scope>
                        <declaration name="r" type="Rectangle" line="284"/>
                        <declaration name="w" type="int" line="285"/>
                        <declaration name="h" type="int" line="286"/>
                        <declaration name="curTracker" type="StateTracker" line="287"/>
                        <scope line="289">
                            <scope line="290">
                                <scope line="291"/>
                            </scope>
                        </scope>
                        <scope line="299"/>
                        <scope line="302">
                            <scope line="303"/>
                        </scope>
                    </scope>
                    <scope line="309"/>
                </scope>
            </method>
            <javadoc line="315">
                This is the default implementation for updating the cached
                  SurfaceData from the source (primary) SurfaceData.
                  A simple Blit is used to copy the pixels from the source to
                  the destination SurfaceData.
                  A subclass can override this implementation if a more complex
                  operation is required to update its cached copies.                
            </javadoc>
            <method name="updateSurfaceData" type="void" line="323">
                <params>
                    <param name="srcData" type="SurfaceData"/>
                    <param name="dstData" type="SurfaceData"/>
                    <param name="w" type="int"/>
                    <param name="h" type="int"/>
                </params>
                <declaration name="srcType" type="SurfaceType" line="324"/>
                <declaration name="dstType" type="SurfaceType" line="325"/>
                <declaration name="blit" type="Blit" line="326"/>
            </method>
            <javadoc line="330">
                This is an alternate implementation for updating the cached
                  SurfaceData from the source (primary) SurfaceData using a
                  background color for transparent pixels.
                  A simple BlitBg is used to copy the pixels from the source to
                  the destination SurfaceData with the specified bgColor.
                  A subclass can override the normal updateSurfaceData method
                  and call this implementation instead if it wants to use color
                  keying for bitmask images.                
            </javadoc>
            <method name="updateSurfaceDataBg" type="void" line="340">
                <params>
                    <param name="srcData" type="SurfaceData"/>
                    <param name="dstData" type="SurfaceData"/>
                    <param name="w" type="int"/>
                    <param name="h" type="int"/>
                    <param name="bgColor" type="Color"/>
                </params>
                <declaration name="srcType" type="SurfaceType" line="341"/>
                <declaration name="dstType" type="SurfaceType" line="342"/>
                <declaration name="blitbg" type="BlitBg" line="343"/>
            </method>
        </class>
    </source>