<?xml version="1.0" encoding="UTF-8"?>
    <source package="sun.java2d">
        <import package="java.awt.Color"/>
        <import package="java.awt.Rectangle"/>
        <import package="java.awt.AlphaComposite"/>
        <import package="java.awt.GraphicsEnvironment"/>
        <import package="sun.awt.DisplayChangedListener"/>
        <import package="sun.java2d.StateTrackable.State"/>
        <import package="sun.java2d.loops.CompositeType"/>
        <import package="sun.java2d.loops.SurfaceType"/>
        <import package="sun.java2d.loops.Blit"/>
        <import package="sun.java2d.loops.BlitBg"/>
        <import package="sun.awt.image.SurfaceManager"/>
        <import package="sun.awt.image.SurfaceManager.FlushableCacheData"/>
        <import package="java.security.AccessController"/>
        <import package="sun.security.action.GetPropertyAction"/>
        <class name="SurfaceDataProxy" line="45">
            <comment line="197">
                The number of attempts to copy from a STABLE source before
                 a cached copy is created or updated.                
            </comment>
            <comment line="201">
                Source tracking data
                
                 Every time that srcTracker is out of date we will reset numtries
                 to threshold and set the cacheTracker to one that is non-current.
                 numtries will then count down to 0 at which point the cacheTracker
                 will remind us that we need to update the cachedSD before we can
                 use it.
                
                 Note that since these fields interrelate we should synchronize
                 whenever we update them, but it should be OK to read them
                 without synchronization.                
            </comment>
            <comment line="217">
                Cached data
                
                 We cache a SurfaceData created by the subclass in cachedSD and
                 track its state (isValid and !surfaceLost) in cacheTracker.
                
                 Also, when we want to note that cachedSD needs to be updated
                 we replace the cacheTracker with a NEVER_CURRENT tracker which
                 will cause us to try to revalidate and update the surface on
                 next use.                
            </comment>
            <comment line="231">
                Are we still the best object to control caching of data
                 for the source image?                
            </comment>
            <implements interface="DisplayChangedListener"/>
            <implements interface="SurfaceManager.FlushableCacheData"/>
            <javadoc line="45">
                The proxy class encapsulates the logic for managing alternate
                  SurfaceData representations of a primary SurfaceData.
                  The main class will handle tracking the state changes of the
                  primary SurfaceData and updating the associated SurfaceData
                  proxy variants.
                  &lt;p&gt;
                  Subclasses have 2 main responsibilities:
                  &lt;ul&gt;
                  &lt;li&gt; Override the isSupportedOperation() method to determine if
                  a given operation can be accelerated with a given source
                  SurfaceData
                  &lt;li&gt; Override the validateSurfaceData() method to create or update
                  a given accelerated surface to hold the pixels for the indicated
                  source SurfaceData
                  &lt;/ul&gt;
                  If necessary, a subclass may also override the updateSurfaceData
                  method to transfer the pixels to the accelerated surface.
                  By default the parent class will transfer the pixels using a
                  standard Blit operation between the two SurfaceData objects.                
            </javadoc>
            <declaration name="cachingAllowed" type="boolean" line="69"/>
            <declaration name="defaultThreshold" type="int" line="70"/>
            <scope line="72">
                <declaration name="manimg" type="String" line="74"/>
                <scope line="76"/>
                <declaration name="num" type="String" line="82"/>
                <scope line="84">
                    <scope line="85">
                        <declaration name="parsed" type="int" line="86"/>
                        <scope line="87"/>
                    </scope>
                    <scope line="92"/>
                </scope>
            </scope>
            <method name="isCachingAllowed" type="boolean" line="98"/>
            <method name="isSupportedOperation" type="boolean" line="102"/>
            <javadoc line="102">
                Determine if an alternate form for the srcData is needed
                  and appropriate from the given operational parameters.                
            </javadoc>
            <method name="validateSurfaceData" type="SurfaceData" line="111"/>
            <javadoc line="111">
                Construct an alternate form of the given SurfaceData.
                  The contents of the returned SurfaceData may be undefined
                  since the calling code will take care of updating the
                  contents with a subsequent call to updateSurfaceData.
                  &lt;p&gt;
                  If the method returns null then there was a problem with
                  allocating the accelerated surface.  The getRetryTracker()
                  method will be called to track when to attempt another
                  revalidation.                
            </javadoc>
            <javadoc line="126">
                If the subclass is unable to validate or create a cached
                  SurfaceData then this method will be used to get a
                  StateTracker object that will indicate when to attempt
                  to validate the surface again.  Subclasses may return
                  trackers which count down an ever increasing threshold
                  to provide hysteresis on creating surfaces during low
                  memory conditions.  The default implementation just waits
                  another &quot;threshold&quot; number of accesses before trying again.                
            </javadoc>
            <method name="getRetryTracker" type="StateTracker" line="136">
                <params>
                    <param name="srcData" type="SurfaceData"/>
                </params>
            </method>
            <class name="CountdownTracker" line="140">
                <implements interface="StateTracker"/>
                <declaration name="countdown" type="int" line="141"/>
                <method name="CountdownTracker" type="constructor" line="143">
                    <params>
                        <param name="threshold" type="int"/>
                    </params>
                </method>
                <method name="isCurrent" type="boolean" line="147"/>
            </class>
            <declaration name="UNCACHED" type="SurfaceDataProxy" line="152"/>
            <javadoc line="152">
                This instance is for cases where a caching implementation
                  determines that a particular source image will never need
                  to be cached - either the source SurfaceData was of an
                  incompatible type, or it was in an UNTRACKABLE state or
                  some other factor is discovered that permanently prevents
                  acceleration or caching.
                  This class optimally implements NOP variants of all necessary
                  methods to avoid caching with a minimum of fuss.                
            </javadoc>
            <anonymous_class line="162">
                <method name="isAccelerated" type="boolean" line="164"/>
                <method name="isSupportedOperation" type="boolean" line="173">
                    <params>
                        <param name="srcData" type="SurfaceData"/>
                        <param name="txtype" type="int"/>
                        <param name="comp" type="CompositeType"/>
                        <param name="bgColor" type="Color"/>
                    </params>
                </method>
                <method name="validateSurfaceData" type="SurfaceData" line="181">
                    <params>
                        <param name="srcData" type="SurfaceData"/>
                        <param name="cachedData" type="SurfaceData"/>
                        <param name="w" type="int"/>
                        <param name="h" type="int"/>
                    </params>
                </method>
                <method name="replaceData" type="SurfaceData" line="190">
                    <params>
                        <param name="srcData" type="SurfaceData"/>
                        <param name="txtype" type="int"/>
                        <param name="comp" type="CompositeType"/>
                        <param name="bgColor" type="Color"/>
                    </params>
                    <comment line="192">
                        Not necessary to override this, but doing so is faster                        
                    </comment>
                </method>
            </anonymous_class>
            <declaration name="threshold" type="int" line="198"/>
            <declaration name="srcTracker" type="StateTracker" line="213"/>
            <declaration name="numtries" type="int" line="214"/>
            <declaration name="cachedSD" type="SurfaceData" line="227"/>
            <declaration name="cacheTracker" type="StateTracker" line="228"/>
            <declaration name="valid" type="boolean" line="234"/>
            <javadoc line="236">
                Create a SurfaceData proxy manager that attempts to create
                  and cache a variant copy of the source SurfaceData after
                  the default threshold number of attempts to copy from the
                  STABLE source.                
            </javadoc>
            <method name="SurfaceDataProxy" type="constructor" line="242"/>
            <javadoc line="246">
                Create a SurfaceData proxy manager that attempts to create
                  and cache a variant copy of the source SurfaceData after
                  the specified threshold number of attempts to copy from
                  the STABLE source.                
            </javadoc>
            <method name="SurfaceDataProxy" type="constructor" line="252">
                <params>
                    <param name="threshold" type="int"/>
                </params>
                <comment line="257">
                    numtries will be reset on first use                    
                </comment>
            </method>
            <javadoc line="262">
                Returns true iff this SurfaceData proxy is still the best
                  way to control caching of the given source on the given
                  destination.                
            </javadoc>
            <method name="isValid" type="boolean" line="267"/>
            <javadoc line="271">
                Sets the valid state to false so that the next time this
                  proxy is fetched to generate a replacement SurfaceData,
                  the code in SurfaceData knows to replace the proxy first.                
            </javadoc>
            <method name="invalidate" type="void" line="276"/>
            <javadoc line="280">
                Flush all cached resources as per the FlushableCacheData interface.
                  The deaccelerated parameter indicates if the flush is
                  happening because the associated surface is no longer
                  being accelerated (for instance the acceleration priority
                  is set below the threshold needed for acceleration).
                  Returns a boolean that indicates if the cached object is
                  no longer needed and should be removed from the cache.                
            </javadoc>
            <method name="flush" type="boolean" line="289">
                <params>
                    <param name="deaccelerated" type="boolean"/>
                </params>
                <scope line="290"/>
            </method>
            <javadoc line="297">
                Actively flushes (drops and invalidates) the cached surface
                  so that it can be reclaimed quickly.                
            </javadoc>
            <method name="flush" type="void" line="301">
                <declaration name="csd" type="SurfaceData" line="302"/>
                <scope line="305"/>
            </method>
            <javadoc line="310">
                Returns true iff this SurfaceData proxy is still valid
                  and if it has a currently cached replacement that is also
                  valid and current.                
            </javadoc>
            <method name="isAccelerated" type="boolean" line="315"/>
            <javadoc line="321">
                This method should be called from subclasses which create
                  cached SurfaceData objects that depend on the current
                  properties of the display.                
            </javadoc>
            <method name="activateDisplayListener" type="void" line="326">
                <comment line="330">
                    We could have a HeadlessGE at this point, so double-check before
                     assuming anything.
                     Also, no point in listening to display change events if
                     the image is never going to be accelerated.                    
                </comment>
                <declaration name="ge" type="GraphicsEnvironment" line="327"/>
                <scope line="333"/>
            </method>
            <javadoc line="338">
                Invoked when the display mode has changed.
                  This method will invalidate and drop the internal cachedSD object.                
            </javadoc>
            <method name="displayChanged" type="void" line="342"/>
            <javadoc line="346">
                Invoked when the palette has changed.                
            </javadoc>
            <method name="paletteChanged" type="void" line="349">
                <comment line="351">
                    We could potentially get away with just resetting cacheTracker
                     here but there is a small window of vulnerability in the
                     replaceData method where we could be just finished with
                     updating the cachedSD when this method is called and even
                     though we set a non-current cacheTracker here it will then
                     immediately get set to a current one by the thread that is
                     updating the cachedSD.  It is safer to just replace the
                     srcTracker with a non-current version that will trigger a
                     full update cycle the next time this proxy is used.
                     The downside is having to go through a full threshold count
                     before we can update and use our cache again, but palette
                     changes should be relatively rare...                    
                </comment>
            </method>
            <javadoc line="365">
                This method attempts to replace the srcData with a cached version.
                  It relies on the subclass to determine if the cached version will
                  be useful given the operational parameters.
                  This method checks any preexisting cached copy for being &quot;up to date&quot;
                  and tries to update it if it is stale or non-existant and the
                  appropriate number of accesses have occured since it last was stale.
                  &lt;p&gt;
                  An outline of the process is as follows:
                  &lt;ol&gt;
                  &lt;li&gt; Check the operational parameters (txtype, comp, bgColor)
                  to make sure that the operation is supported.  Return the
                  original SurfaceData if the operation cannot be accelerated.
                  &lt;li&gt; Check the tracker for the source surface to see if it has
                  remained stable since it was last cached.  Update the state
                  variables to cause both a threshold countdown and an update
                  of the cached copy if it is not.  (Setting cacheTracker to
                  NEVER_CURRENT effectively marks it as &quot;needing to be updated&quot;.)
                  &lt;li&gt; Check the tracker for the cached copy to see if is still
                  valid and up to date.  Note that the cacheTracker may be
                  non-current if either something happened to the cached copy
                  (eg. surfaceLost) or if the source was out of date and the
                  cacheTracker was set to NEVER_CURRENT to force an update.
                  Decrement the countdown and copy the source to the cache
                  as necessary and then update the variables to show that
                  the cached copy is stable.
                  &lt;/ol&gt;                
            </javadoc>
            <method name="replaceData" type="SurfaceData" line="397">
                <params>
                    <param name="srcData" type="SurfaceData"/>
                    <param name="txtype" type="int"/>
                    <param name="comp" type="CompositeType"/>
                    <param name="bgColor" type="Color"/>
                </params>
                <comment line="400">
                    First deal with tracking the source.                    
                </comment>
                <comment line="409">
                    Dynamic or Untrackable (or a very recent modification)                    
                </comment>
                <comment line="411">
                    UNTRACKABLE means we can never cache again.                    
                </comment>
                <comment line="413">
                    Invalidate so we get replaced next time we are used
                     (presumably with an UNCACHED proxy).                    
                </comment>
                <comment line="417">
                    Aggressively drop our reference to the cachedSD
                     in case this proxy is not consulted again (and
                     thus replaced) for a long time.                    
                </comment>
                <comment line="426">
                    Then deal with checking the validity of the cached SurfaceData                    
                </comment>
                <comment line="429">
                    Next make sure the dust has settled                    
                </comment>
                <comment line="441">
                    Snapshot the tracker in case it changes while
                     we are updating the cached SD...                    
                </comment>
                <comment line="462">
                    We only reset these variables if the tracker from
                     before the surface update is still in use and current
                     Note that we must use a srcTracker that was fetched
                     from before the update process to make sure that we
                     do not lose some pixel changes in the shuffle.                    
                </comment>
                <scope line="398">
                    <scope line="400">
                        <scope line="401"/>
                        <scope line="407">
                            <scope line="409"/>
                        </scope>
                    </scope>
                    <declaration name="csd" type="SurfaceData" line="426"/>
                    <scope line="427">
                        <scope line="429">
                            <scope line="430"/>
                        </scope>
                        <declaration name="r" type="Rectangle" line="436"/>
                        <declaration name="w" type="int" line="437"/>
                        <declaration name="h" type="int" line="438"/>
                        <declaration name="curTracker" type="StateTracker" line="442"/>
                        <scope line="445">
                            <scope line="446">
                                <scope line="447"/>
                            </scope>
                        </scope>
                        <scope line="456"/>
                        <scope line="460">
                            <scope line="466"/>
                        </scope>
                    </scope>
                    <scope line="473"/>
                </scope>
            </method>
            <javadoc line="481">
                This is the default implementation for updating the cached
                  SurfaceData from the source (primary) SurfaceData.
                  A simple Blit is used to copy the pixels from the source to
                  the destination SurfaceData.
                  A subclass can override this implementation if a more complex
                  operation is required to update its cached copies.                
            </javadoc>
            <method name="updateSurfaceData" type="void" line="492">
                <params>
                    <param name="srcData" type="SurfaceData"/>
                    <param name="dstData" type="SurfaceData"/>
                    <param name="w" type="int"/>
                    <param name="h" type="int"/>
                </params>
                <declaration name="srcType" type="SurfaceType" line="493"/>
                <declaration name="dstType" type="SurfaceType" line="494"/>
                <declaration name="blit" type="Blit" line="495"/>
            </method>
            <javadoc line="504">
                This is an alternate implementation for updating the cached
                  SurfaceData from the source (primary) SurfaceData using a
                  background color for transparent pixels.
                  A simple BlitBg is used to copy the pixels from the source to
                  the destination SurfaceData with the specified bgColor.
                  A subclass can override the normal updateSurfaceData method
                  and call this implementation instead if it wants to use color
                  keying for bitmask images.                
            </javadoc>
            <method name="updateSurfaceDataBg" type="void" line="517">
                <params>
                    <param name="srcData" type="SurfaceData"/>
                    <param name="dstData" type="SurfaceData"/>
                    <param name="w" type="int"/>
                    <param name="h" type="int"/>
                    <param name="bgColor" type="Color"/>
                </params>
                <declaration name="srcType" type="SurfaceType" line="518"/>
                <declaration name="dstType" type="SurfaceType" line="519"/>
                <declaration name="blitbg" type="BlitBg" line="520"/>
            </method>
        </class>
    </source>