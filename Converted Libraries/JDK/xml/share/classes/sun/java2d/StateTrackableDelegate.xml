<?xml version="1.0" encoding="UTF-8"?>
    <source package="sun.java2d">
        <import package="sun.java2d.StateTrackable.State"/>
        <import package="sun.java2d.StateTrackable.State"/>
        <class name="StateTrackableDelegate" line="31">
            <comment line="85">
                package private for easy access from tracker                
            </comment>
            <implements interface="StateTrackable"/>
            <javadoc line="31">
                This class provides a basic pre-packaged implementation of the
                  complete {@link StateTrackable} interface with implementations
                  of the required methods in the interface and methods to manage
                  transitions in the state of the object.
                  Classes which wish to implement StateTrackable could create an
                  instance of this class and delegate all of their implementations
                  for {@code StateTrackable} methods to the corresponding methods
                  of this class.                
            </javadoc>
            <declaration name="UNTRACKABLE_DELEGATE" type="StateTrackableDelegate" line="42"/>
            <javadoc line="42">
                The {@code UNTRACKABLE_DELEGATE} provides an implementation
                  of the StateTrackable interface that is permanently in the{@link State#UNTRACKABLE UNTRACKABLE} state.                
            </javadoc>
            <declaration name="IMMUTABLE_DELEGATE" type="StateTrackableDelegate" line="50"/>
            <javadoc line="50">
                The {@code IMMUTABLE_DELEGATE} provides an implementation
                  of the StateTrackable interface that is permanently in the{@link State#IMMUTABLE IMMUTABLE} state.                
            </javadoc>
            <javadoc line="58">
                Returns a {@code StateTrackableDelegate} instance with the
                  specified initial {@link State State}.
                  If the specified {@code State} is{@link State#UNTRACKABLE UNTRACKABLE} or{@link State#IMMUTABLE IMMUTABLE}then the approprirate static instance{@link #UNTRACKABLE_DELEGATE} or {@link #IMMUTABLE_DELEGATE}is returned.                
            </javadoc>
            <method name="createInstance" type="StateTrackableDelegate" line="68">
                <params>
                    <param name="state" type="State"/>
                </params>
            </method>
            <declaration name="theState" type="State" line="83"/>
            <declaration name="theTracker" type="StateTracker" line="84"/>
            <declaration name="numDynamicAgents" type="int" line="85"/>
            <javadoc line="87">
                Constructs a StateTrackableDelegate object with the specified
                  initial State.                
            </javadoc>
            <method name="StateTrackableDelegate" type="constructor" line="91">
                <params>
                    <param name="state" type="State"/>
                </params>
            </method>
            <javadoc line="95">
                @inheritDoc                
                <since>
                    1.7                    
                </since>
            </javadoc>
            <method name="getState" type="State" line="99"/>
            <javadoc line="103">
                @inheritDoc                
                <since>
                    1.7                    
                </since>
            </javadoc>
            <method name="getStateTracker" type="StateTracker" line="107">
                <comment line="122">
                    We return the NEVER_CURRENT tracker, but that is                    
                </comment>
                <comment line="123">
                    just temporary while we are in the DYNAMIC state.                    
                </comment>
                <comment line="124">
                    NO BREAK                    
                </comment>
                <declaration name="st" type="StateTracker" line="108"/>
                <scope line="109">
                    <anonymous_class line="115">
                        <method name="isCurrent" type="boolean" line="116"/>
                    </anonymous_class>
                </scope>
            </method>
            <javadoc line="134">
                This method provides an easy way for delegating classes to
                  change the overall {@link State State} of the delegate to{@link State#IMMUTABLE IMMUTABLE}.                
                <throws>
                    IllegalStateException if the current state is{@link State#UNTRACKABLE UNTRACKABLE}                    
                </throws>
                <see>
                    #setUntrackable                    
                </see>
                <since>
                    1.7                    
                </since>
            </javadoc>
            <method name="setImmutable" type="void" line="143">
                <scope line="144"/>
            </method>
            <javadoc line="152">
                This method provides an easy way for delegating classes to
                  change the overall {@link State State} of the delegate to{@link State#UNTRACKABLE UNTRACKABLE}.
                  This method is typically called when references to the
                  internal data buffers have been made public.                
                <throws>
                    IllegalStateException if the current state is{@link State#IMMUTABLE IMMUTABLE}                    
                </throws>
                <see>
                    #setImmutable                    
                </see>
                <since>
                    1.7                    
                </since>
            </javadoc>
            <method name="setUntrackable" type="void" line="163">
                <scope line="164"/>
            </method>
            <javadoc line="172">
                This method provides an easy way for delegating classes to
                  manage temporarily setting the overall {@link State State}of the delegate to {@link State#DYNAMIC DYNAMIC}during well-defined time frames of dynamic pixel updating.
                  This method should be called once before each flow of control
                  that might dynamically update the pixels in an uncontrolled
                  or unpredictable fashion.
                  &lt;p&gt;
                  The companion method {@link #removeDynamicAgent} method should
                  also be called once after each such flow of control has ended.
                  Failing to call the remove method will result in this object
                  permanently becoming {@link State#DYNAMIC DYNAMIC}and therefore effectively untrackable.
                  &lt;p&gt;
                  This method will only change the {@link State State} of the
                  delegate if it is currently {@link State#STABLE STABLE}.                
                <throws>
                    IllegalStateException if the current state is{@link State#IMMUTABLE IMMUTABLE}                    
                </throws>
                <since>
                    1.7                    
                </since>
            </javadoc>
            <method name="addDynamicAgent" type="void" line="194">
                <scope line="195"/>
                <scope line="200"/>
            </method>
            <javadoc line="206">
                This method provides an easy way for delegating classes to
                  manage restoring the overall {@link State State} of the
                  delegate back to {@link State#STABLE STABLE}after a well-defined time frame of dynamic pixel updating.
                  This method should be called once after each flow of control
                  that might dynamically update the pixels in an uncontrolled
                  or unpredictable fashion has ended.
                  &lt;p&gt;
                  The companion method {@link #addDynamicAgent} method should
                  have been called at some point before each such flow of
                  control began.
                  If this method is called without having previously called
                  the add method, the {@link State State} of this object
                  will become unreliable.
                  &lt;p&gt;
                  This method will only change the {@link State State} of the
                  delegate if the number of outstanding dynamic agents has
                  gone to 0 and it is currently{@link State#DYNAMIC DYNAMIC}.                
                <since>
                    1.7                    
                </since>
            </javadoc>
            <method name="removeDynamicAgent" type="void" line="229">
                <scope line="230"/>
            </method>
            <javadoc line="236">
                This method provides an easy way for delegating classes to
                  indicate that the contents have changed.
                  This method will invalidate outstanding StateTracker objects
                  so that any other agents which maintain cached information
                  about the pixels will know to refresh their cached copies.
                  This method should be called after every modification to
                  the data, such as any calls to any of the setElem methods.
                  &lt;p&gt;
                  Note that, for efficiency, this method does not check the{@link State State} of the object to see if it is compatible
                  with being marked dirty
                  (i.e. not {@link State#IMMUTABLE IMMUTABLE}).
                  It is up to the callers to enforce the fact that an{@code IMMUTABLE} delegate is never modified.                
                <since>
                    1.7                    
                </since>
            </javadoc>
            <method name="markDirty" type="void" line="253"/>
        </class>
    </source>