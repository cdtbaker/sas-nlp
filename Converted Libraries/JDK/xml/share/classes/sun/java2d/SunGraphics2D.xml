<?xml version="1.0" encoding="UTF-8"?>
    <source package="sun.java2d">
        <import package="java.awt.Graphics"/>
        <import package="java.awt.Graphics2D"/>
        <import package="java.awt.RenderingHints"/>
        <import package="java.awt.RenderingHints.Key"/>
        <import package="java.awt.geom.Area"/>
        <import package="java.awt.geom.AffineTransform"/>
        <import package="java.awt.geom.NoninvertibleTransformException"/>
        <import package="java.awt.AlphaComposite"/>
        <import package="java.awt.BasicStroke"/>
        <import package="java.awt.image.BufferedImage"/>
        <import package="java.awt.image.BufferedImageOp"/>
        <import package="java.awt.image.RenderedImage"/>
        <import package="java.awt.image.renderable.RenderableImage"/>
        <import package="java.awt.image.renderable.RenderContext"/>
        <import package="java.awt.image.AffineTransformOp"/>
        <import package="java.awt.image.Raster"/>
        <import package="java.awt.image.WritableRaster"/>
        <import package="java.awt.Image"/>
        <import package="java.awt.Composite"/>
        <import package="java.awt.Color"/>
        <import package="java.awt.image.ColorModel"/>
        <import package="java.awt.GraphicsConfiguration"/>
        <import package="java.awt.Paint"/>
        <import package="java.awt.GradientPaint"/>
        <import package="java.awt.LinearGradientPaint"/>
        <import package="java.awt.RadialGradientPaint"/>
        <import package="java.awt.TexturePaint"/>
        <import package="java.awt.geom.Rectangle2D"/>
        <import package="java.awt.geom.PathIterator"/>
        <import package="java.awt.geom.GeneralPath"/>
        <import package="java.awt.Shape"/>
        <import package="java.awt.Stroke"/>
        <import package="java.awt.FontMetrics"/>
        <import package="java.awt.Rectangle"/>
        <import package="java.text.AttributedCharacterIterator"/>
        <import package="java.awt.Font"/>
        <import package="java.awt.image.ImageObserver"/>
        <import package="java.awt.Transparency"/>
        <import package="java.awt.font.GlyphVector"/>
        <import package="java.awt.font.TextLayout"/>
        <import package="sun.font.FontDesignMetrics"/>
        <import package="sun.font.FontUtilities"/>
        <import package="sun.java2d.pipe.PixelDrawPipe"/>
        <import package="sun.java2d.pipe.PixelFillPipe"/>
        <import package="sun.java2d.pipe.ShapeDrawPipe"/>
        <import package="sun.java2d.pipe.ValidatePipe"/>
        <import package="sun.java2d.pipe.ShapeSpanIterator"/>
        <import package="sun.java2d.pipe.Region"/>
        <import package="sun.java2d.pipe.TextPipe"/>
        <import package="sun.java2d.pipe.DrawImagePipe"/>
        <import package="sun.java2d.pipe.LoopPipe"/>
        <import package="sun.java2d.loops.FontInfo"/>
        <import package="sun.java2d.loops.RenderLoops"/>
        <import package="sun.java2d.loops.CompositeType"/>
        <import package="sun.java2d.loops.SurfaceType"/>
        <import package="sun.java2d.loops.Blit"/>
        <import package="sun.java2d.loops.MaskFill"/>
        <import package="sun.font.FontManager"/>
        <import package="java.awt.font.FontRenderContext"/>
        <import package="sun.java2d.loops.XORComposite"/>
        <import package="sun.awt.ConstrainableGraphics"/>
        <import package="sun.awt.SunHints"/>
        <import package="java.util.Map"/>
        <import package="java.util.Iterator"/>
        <import package="sun.java2d.DestSurfaceProvider"/>
        <import package="sun.misc.PerformanceLogger"/>
        <class name="SunGraphics2D" line="95">
            <extends class="Graphics2D"/>
            <comment line="109">
                Attribute States                
            </comment>
            <comment line="112">
                                
            </comment>
            <comment line="113">
                                
            </comment>
            <comment line="114">
                                
            </comment>
            <comment line="115">
                                
            </comment>
            <comment line="116">
                                
            </comment>
            <comment line="117">
                                
            </comment>
            <comment line="118">
                                
            </comment>
            <comment line="119">
                                
            </comment>
            <comment line="121">
                                
            </comment>
            <comment line="131">
                                
            </comment>
            <comment line="132">
                                
            </comment>
            <comment line="133">
                                
            </comment>
            <comment line="134">
                                
            </comment>
            <comment line="135">
                                
            </comment>
            <comment line="137">
                                
            </comment>
            <comment line="138">
                                
            </comment>
            <comment line="139">
                                
            </comment>
            <comment line="140">
                                
            </comment>
            <comment line="141">
                                
            </comment>
            <comment line="142">
                                
            </comment>
            <comment line="144">
                                
            </comment>
            <comment line="145">
                                
            </comment>
            <comment line="146">
                                
            </comment>
            <comment line="147">
                                
            </comment>
            <comment line="149">
                                
            </comment>
            <comment line="150">
                ARGB value with ExtraAlpha baked in                
            </comment>
            <comment line="151">
                pixel value for eargb                
            </comment>
            <comment line="164">
                                
            </comment>
            <comment line="195">
                                
            </comment>
            <comment line="199">
                raw value of rendering Hint                
            </comment>
            <comment line="202">
                algorithm choice based on                
            </comment>
            <comment line="203">
                interpolation and render Hints                
            </comment>
            <comment line="207">
                lightweight bounds                
            </comment>
            <comment line="213">
                Actual physical drawable                
            </comment>
            <comment line="215">
                cached state for text rendering                
            </comment>
            <comment line="361">
                Invalidate the pipeline                
            </comment>
            <comment line="377">
                Intersect two Shapes by the simplest method, attempting to produce
                 a simplified result.
                 The boolean arguments keep1 and keep2 specify whether or not
                 the first or second shapes can be modified during the operation
                 or whether that shape must be &quot;kept&quot; unmodified.                
            </comment>
            <comment line="396">
                Intersect a Rectangle with a Shape by the simplest method,
                 attempting to produce a simplified result.
                 The boolean arguments keep1 and keep2 specify whether or not
                 the first or second shapes can be modified during the operation
                 or whether that shape must be &quot;kept&quot; unmodified.                
            </comment>
            <comment line="442">
                Intersect two Shapes using the Area class.  Presumably other
                 attempts at simpler intersection methods proved fruitless.
                 The boolean arguments keep1 and keep2 specify whether or not
                 the first or second shapes can be modified during the operation
                 or whether that shape must be &quot;kept&quot; unmodified.
                 @see #intersectShapes
                 @see #intersectRectShape                
            </comment>
            <comment line="479">
                Intersect usrClip bounds and device bounds to determine the composite
                 rendering boundaries.                
            </comment>
            <comment line="516">
                cached state for various draw[String,Char,Byte] optimizations                
            </comment>
            <comment line="764">
                                
            </comment>
            <comment line="968">
                Since inaccuracies in the trig package can cause us to                
            </comment>
            <comment line="969">
                calculated a rotated pen width of just slightly greater                
            </comment>
            <comment line="970">
                than 1.0, we add a fudge factor to our comparison value                
            </comment>
            <comment line="971">
                here so that we do not misclassify single width lines as                
            </comment>
            <comment line="972">
                wide lines under certain rotations.                
            </comment>
            <comment line="1075">
                Sets the Stroke in the current graphics state.
                 @param s The Stroke object to be used to stroke a Path in
                 the rendering process.
                 @see BasicStroke                
            </comment>
            <comment line="1630">
                Validate the eargb and pixel fields against the current color.
                
                 The eargb field must take into account the extraAlpha
                 value of an AlphaComposite.  It may also take into account
                 the Fsrc Porter-Duff blending function if such a function is
                 a constant (see handling of Clear mode below).  For instance,
                 by factoring in the (Fsrc == 0) state of the Clear mode we can
                 use a SrcNoEa loop just as easily as a general Alpha loop
                 since the math will be the same in both cases.
                
                 The pixel field will always be the best pixel data choice for
                 the final result of all calculations applied to the eargb field.
                
                 Note that this method is only necessary under the following
                 conditions:
                     (paintState &lt;= PAINT_ALPHA_COLOR &amp;&amp;
                      compositeState &lt;= COMP_CUSTOM)
                 though nothing bad will happen if it is run in other states.                
            </comment>
            <comment line="2061">
                public void XcopyArea(int x, int y, int w, int h, int dx, int dy) {
                Rectangle rect = new Rectangle(x, y, w, h);
                rect = transformBounds(rect, transform);
                Point2D    point = new Point2D.Float(dx, dy);
                Point2D    root  = new Point2D.Float(0, 0);
                point = transform.transform(point, point);
                root  = transform.transform(root, root);
                int fdx = (int)(point.getX()-root.getX());
                int fdy = (int)(point.getY()-root.getY());
                
                Rectangle r = getCompBounds().intersection(rect.getBounds());
                
                if (r.isEmpty()) {
                return;
                }
                
                 Begin Rasterizer for Clip Shape
                boolean skipClip = true;
                byte[] clipAlpha = null;
                
                if (clipState == CLIP_SHAPE) {
                
                int box[] = new int[4];
                
                clipRegion.getBounds(box);
                Rectangle devR = new Rectangle(box[0], box[1],
                box[2] - box[0],
                box[3] - box[1]);
                if (!devR.isEmpty()) {
                OutputManager mgr = getOutputManager();
                RegionIterator ri = clipRegion.getIterator();
                while (ri.nextYRange(box)) {
                int spany = box[1];
                int spanh = box[3] - spany;
                while (ri.nextXBand(box)) {
                int spanx = box[0];
                int spanw = box[2] - spanx;
                mgr.copyArea(this, null,
                spanw, 0,
                spanx, spany,
                spanw, spanh,
                fdx, fdy,
                null);
                }
                }
                }
                return;
                }
                 End Rasterizer for Clip Shape
                
                getOutputManager().copyArea(this, null,
                r.width, 0,
                r.x, r.y, r.width,
                r.height, fdx, fdy,
                null);
                }                
            </comment>
            <comment line="2780">
                Transform the bounding box of the BufferedImage                
            </comment>
            <comment line="2793">
                text rendering methods                
            </comment>
            <comment line="2967">
                end of text rendering methods                
            </comment>
            <implements interface="ConstrainableGraphics"/>
            <implements interface="Cloneable"/>
            <implements interface="DestSurfaceProvider"/>
            <javadoc line="95">
                This is a the master Graphics2D superclass for all of the Sun
                  Graphics implementations.  This class relies on subclasses to
                  manage the various device information, but provides an overall
                  general framework for performing all of the requests in the
                  Graphics and Graphics2D APIs.                
                <author>
                    Jim Graham                    
                </author>
            </javadoc>
            <declaration name="PAINT_CUSTOM" type="int" line="112"/>
            <declaration name="PAINT_TEXTURE" type="int" line="113"/>
            <declaration name="PAINT_RAD_GRADIENT" type="int" line="114"/>
            <declaration name="PAINT_LIN_GRADIENT" type="int" line="115"/>
            <declaration name="PAINT_GRADIENT" type="int" line="116"/>
            <declaration name="PAINT_ALPHACOLOR" type="int" line="117"/>
            <declaration name="PAINT_OPAQUECOLOR" type="int" line="118"/>
            <declaration name="COMP_CUSTOM" type="int" line="121"/>
            <declaration name="COMP_XOR" type="int" line="122"/>
            <declaration name="COMP_ALPHA" type="int" line="123"/>
            <declaration name="COMP_ISCOPY" type="int" line="124"/>
            <declaration name="STROKE_CUSTOM" type="int" line="131"/>
            <declaration name="STROKE_WIDE" type="int" line="132"/>
            <declaration name="STROKE_THINDASHED" type="int" line="133"/>
            <declaration name="STROKE_THIN" type="int" line="134"/>
            <declaration name="TRANSFORM_GENERIC" type="int" line="137"/>
            <declaration name="TRANSFORM_TRANSLATESCALE" type="int" line="138"/>
            <declaration name="TRANSFORM_ANY_TRANSLATE" type="int" line="139"/>
            <declaration name="TRANSFORM_INT_TRANSLATE" type="int" line="140"/>
            <declaration name="TRANSFORM_ISIDENT" type="int" line="141"/>
            <declaration name="CLIP_SHAPE" type="int" line="144"/>
            <declaration name="CLIP_RECTANGULAR" type="int" line="145"/>
            <declaration name="CLIP_DEVICE" type="int" line="146"/>
            <declaration name="eargb" type="int" line="149"/>
            <declaration name="pixel" type="int" line="150"/>
            <declaration name="surfaceData" type="SurfaceData" line="152"/>
            <declaration name="drawpipe" type="PixelDrawPipe" line="154"/>
            <declaration name="fillpipe" type="PixelFillPipe" line="155"/>
            <declaration name="imagepipe" type="DrawImagePipe" line="156"/>
            <declaration name="shapepipe" type="ShapeDrawPipe" line="157"/>
            <declaration name="textpipe" type="TextPipe" line="158"/>
            <declaration name="alphafill" type="MaskFill" line="159"/>
            <declaration name="loops" type="RenderLoops" line="161"/>
            <declaration name="imageComp" type="CompositeType" line="163"/>
            <declaration name="paintState" type="int" line="165"/>
            <declaration name="compositeState" type="int" line="166"/>
            <declaration name="strokeState" type="int" line="167"/>
            <declaration name="transformState" type="int" line="168"/>
            <declaration name="clipState" type="int" line="169"/>
            <declaration name="foregroundColor" type="Color" line="171"/>
            <declaration name="backgroundColor" type="Color" line="172"/>
            <declaration name="transform" type="AffineTransform" line="174"/>
            <declaration name="transX" type="int" line="175"/>
            <declaration name="transY" type="int" line="176"/>
            <declaration name="defaultStroke" type="Stroke" line="178"/>
            <declaration name="defaultComposite" type="Composite" line="179"/>
            <declaration name="defaultFont" type="Font" line="180"/>
            <declaration name="paint" type="Paint" line="183"/>
            <declaration name="stroke" type="Stroke" line="184"/>
            <declaration name="composite" type="Composite" line="185"/>
            <declaration name="font" type="Font" line="186"/>
            <declaration name="fontMetrics" type="FontMetrics" line="187"/>
            <declaration name="renderHint" type="int" line="189"/>
            <declaration name="antialiasHint" type="int" line="190"/>
            <declaration name="textAntialiasHint" type="int" line="191"/>
            <declaration name="fractionalMetricsHint" type="int" line="192"/>
            <declaration name="lcdTextContrast" type="int" line="195"/>
            <declaration name="lcdTextContrastDefaultValue" type="int" line="196"/>
            <declaration name="interpolationHint" type="int" line="198"/>
            <declaration name="strokeHint" type="int" line="199"/>
            <declaration name="interpolationType" type="int" line="201"/>
            <declaration name="hints" type="RenderingHints" line="204"/>
            <declaration name="constrainClip" type="Region" line="206"/>
            <declaration name="constrainX" type="int" line="207"/>
            <declaration name="constrainY" type="int" line="208"/>
            <declaration name="clipRegion" type="Region" line="210"/>
            <declaration name="usrClip" type="Shape" line="211"/>
            <declaration name="devClip" type="Region" line="212"/>
            <declaration name="validFontInfo" type="boolean" line="215"/>
            <declaration name="fontInfo" type="FontInfo" line="216"/>
            <declaration name="glyphVectorFontInfo" type="FontInfo" line="217"/>
            <declaration name="glyphVectorFRC" type="FontRenderContext" line="218"/>
            <declaration name="slowTextTransformMask" type="int" line="220"/>
            <scope line="225">
                <scope line="226"/>
            </scope>
            <method name="SunGraphics2D" type="constructor" line="231">
                <params>
                    <param name="sd" type="SurfaceData"/>
                    <param name="fg" type="Color"/>
                    <param name="bg" type="Color"/>
                    <param name="f" type="Font"/>
                </params>
                <scope line="256"/>
            </method>
            <method name="clone" type="Object" line="264">
                <comment line="271">
                    FontInfos are re-used, so must be cloned too, if they
                     are valid, and be nulled out if invalid.
                     The implied trade-off is that there is more to be gained
                     from re-using these objects than is lost by having to
                     clone them when the SG2D is cloned.                    
                </comment>
                <comment line="289">
                    g.invalidatePipe();                    
                </comment>
                <scope line="265">
                    <declaration name="g" type="SunGraphics2D" line="266"/>
                    <scope line="268"/>
                    <scope line="277">
                        <scope line="278"/>
                        <scope line="280"/>
                    </scope>
                    <scope line="284"/>
                </scope>
                <scope line="291"/>
            </method>
            <javadoc line="296">
                Create a new SunGraphics2D based on this one.                
            </javadoc>
            <method name="create" type="Graphics" line="299"/>
            <method name="setDevClip" type="void" line="303">
                <params>
                    <param name="x" type="int"/>
                    <param name="y" type="int"/>
                    <param name="w" type="int"/>
                    <param name="h" type="int"/>
                </params>
                <declaration name="c" type="Region" line="304"/>
                <scope line="305"/>
                <scope line="307"/>
            </method>
            <method name="setDevClip" type="void" line="313">
                <params>
                    <param name="r" type="Rectangle"/>
                </params>
            </method>
            <javadoc line="317">
                Constrain rendering for lightweight objects.
                  REMIND: This method will back off to the &quot;workaround&quot;
                  of using translate and clipRect if the Graphics
                  to be constrained has a complex transform.  The
                  drawback of the workaround is that the resulting
                  clip and device origin cannot be &quot;enforced&quot;.                
                <exception>
                    IllegalStateException If the Graphics
                      to be constrained has a complex transform.                    
                </exception>
            </javadoc>
            <method name="constrain" type="void" line="329">
                <params>
                    <param name="x" type="int"/>
                    <param name="y" type="int"/>
                    <param name="w" type="int"/>
                    <param name="h" type="int"/>
                </params>
                <comment line="347">
                    Common case to ignore                    
                </comment>
                <scope line="330"/>
                <scope line="333"/>
                <declaration name="c" type="Region" line="341"/>
                <scope line="342"/>
                <scope line="344">
                    <scope line="346"/>
                </scope>
                <scope line="352"/>
            </method>
            <declaration name="invalidpipe" type="ValidatePipe" line="358"/>
            <method name="invalidatePipe" type="void" line="363"/>
            <method name="validatePipe" type="void" line="372"/>
            <method name="intersectShapes" type="Shape" line="383">
                <params>
                    <param name="s1" type="Shape"/>
                    <param name="s2" type="Shape"/>
                    <param name="keep1" type="boolean"/>
                    <param name="keep2" type="boolean"/>
                </params>
                <scope line="384"/>
                <scope line="387"/>
                <scope line="389"/>
            </method>
            <method name="intersectRectShape" type="Shape" line="403">
                <params>
                    <param name="r" type="Rectangle2D"/>
                    <param name="s" type="Shape"/>
                    <param name="keep1" type="boolean"/>
                    <param name="keep2" type="boolean"/>
                </params>
                <comment line="422">
                    Width or height is negative. No intersection.                    
                </comment>
                <scope line="404">
                    <declaration name="r2" type="Rectangle2D" line="405"/>
                    <declaration name="outrect" type="Rectangle2D" line="406"/>
                    <scope line="407"/>
                    <scope line="409"/>
                    <scope line="411"/>
                    <declaration name="x1" type="double" line="414"/>
                    <declaration name="x2" type="double" line="415"/>
                    <declaration name="y1" type="double" line="417"/>
                    <declaration name="y2" type="double" line="418"/>
                </scope>
                <scope line="428">
                    <scope line="429"/>
                </scope>
            </method>
            <method name="cloneShape" type="Shape" line="437">
                <params>
                    <param name="s" type="Shape"/>
                </params>
            </method>
            <method name="intersectByArea" type="Shape" line="450">
                <params>
                    <param name="s1" type="Shape"/>
                    <param name="s2" type="Shape"/>
                    <param name="keep1" type="boolean"/>
                    <param name="keep2" type="boolean"/>
                </params>
                <comment line="453">
                    First see if we can find an overwriteable source shape                    
                </comment>
                <comment line="454">
                    to use as our destination area to avoid duplication.                    
                </comment>
                <declaration name="a1" type="Area" line="451"/>
                <scope line="455"/>
                <scope line="457"/>
                <scope line="460"/>
                <scope line="464"/>
                <scope line="466"/>
                <scope line="471"/>
            </method>
            <method name="getCompClip" type="Region" line="482">
                <comment line="484">
                    revalidateAll() implicitly recalculcates the composite clip                    
                </comment>
                <scope line="483"/>
            </method>
            <method name="getFont" type="Font" line="491">
                <scope line="492"/>
            </method>
            <declaration name="IDENT_MATRIX" type="double[]" line="498"/>
            <declaration name="IDENT_ATX" type="AffineTransform" line="499"/>
            <declaration name="MINALLOCATED" type="int" line="502"/>
            <declaration name="TEXTARRSIZE" type="int" line="503"/>
            <declaration name="textTxArr" type="double[][]" line="504"/>
            <declaration name="textAtArr" type="AffineTransform[]" line="505"/>
            <scope line="508">
                <scope line="509"/>
            </scope>
            <method name="checkFontInfo" type="FontInfo" line="517">
                <params>
                    <param name="info" type="FontInfo"/>
                    <param name="font" type="Font"/>
                    <param name="frc" type="FontRenderContext"/>
                </params>
                <comment line="518">
                    Do not create a FontInfo object as part of construction of an
                     SG2D as its possible it may never be needed - ie if no text
                     is drawn using this SG2D.                    
                </comment>
                <comment line="569">
                    If the double represents a common integral, we
                     may have pre-allocated objects.
                     A &quot;sparse&quot; array be seems to be as fast as a switch
                     even for 3 or 4 pt sizes, and is more flexible.
                     This should perform comparably in single-threaded
                     rendering to the old code which synchronized on the
                     class and scale better on MP systems.                    
                </comment>
                <comment line="602">
                    conditionally set true in LCD mode.                    
                </comment>
                <comment line="604">
                    The text anti-aliasing hints that are set by the client need
                     to be interpreted for the current state and stored in the
                     FontInfo.aahint which is what will actually be used and
                     will be one of OFF, ON, LCD_HRGB or LCD_VRGB.
                     This is what pipe selection code should typically refer to, not
                     textAntialiasHint. This means we are now evaluating the meaning
                     of &quot;default&quot; here. Any pipe that really cares about that will
                     also need to consult that variable.
                     Otherwise these are being used only as args to getStrike,
                     and are encapsulated in that object which is part of the
                     FontInfo, so we do not need to store them directly as fields
                     in the FontInfo object.
                     That could change if FontInfo&apos;s were more selectively
                     revalidated when graphics state changed. Presently this
                     method re-evaluates all fields in the fontInfo.
                     The strike doesn&apos;t need to know the RGB subpixel order. Just
                     if its H or V orientation, so if an LCD option is specified we
                     always pass in the RGB hint to the strike.
                     frc is non-null only if this is a GlyphVector. For reasons
                     which are probably a historical mistake the AA hint in a GV
                     is honoured when we render, overriding the Graphics setting.                    
                </comment>
                <comment line="639">
                    If we are in checkFontInfo because a rendering hint has been
                     set then all pipes are revalidated. But we can also
                     be here because setFont() has been called when the &apos;gasp&apos;
                     hint is set, as then the font size determines the text pipe.
                     See comments in SunGraphics2d.setFont(Font).                    
                </comment>
                <comment line="652">
                    loops for default rendering modes are installed in the SG2D
                     constructor. If there are none this will be null.
                     Not all compositing modes update the render loops, so
                     we also test that this is a mode we know should support
                     this. One minor issue is that the loops aren&apos;t necessarily
                     installed for a new rendering mode until after this
                     method is called during pipeline validation. So it is
                     theoretically possible that it was set to null for a
                     compositing mode, the composite is then set back to Src,
                     but the loop is still null when this is called and AA=ON
                     is installed instead of an LCD mode.
                     However this is done in the right order in SurfaceData.java
                     so this is not likely to be a problem - but not
                     guaranteed.                    
                </comment>
                <comment line="669">
                    loops.drawGlyphListLCDLoop == null ||                    
                </comment>
                <comment line="670">
                    compositeState &gt; COMP_ISCOPY ||                    
                </comment>
                <comment line="671">
                    paintState &gt; PAINT_ALPHACOLOR                    
                </comment>
                <comment line="676">
                    Collapse these into just HRGB or VRGB.
                     Pipe selection code needs only to test for these two.
                     Since these both select the same pipe anyway its
                     tempting to collapse into one value. But they are
                     different strikes (glyph caches) so the distinction
                     needs to be made for that purpose.                    
                </comment>
                <comment line="691">
                    Support subpixel positioning only for the case in
                     which the horizontal resolution is increased                    
                </comment>
                <scope line="522"/>
                <declaration name="ptSize" type="float" line="526"/>
                <declaration name="txFontType" type="int" line="527"/>
                <declaration name="devAt" type="AffineTransform" line="528"/>
                <scope line="529">
                    <scope line="536"/>
                    <scope line="540"/>
                    <declaration name="shearx" type="double" line="545"/>
                    <declaration name="scaley" type="double" line="546"/>
                    <scope line="547"/>
                </scope>
                <scope line="551">
                    <scope line="554">
                        <scope line="558"/>
                        <declaration name="shearx" type="double" line="562"/>
                        <declaration name="scaley" type="double" line="563"/>
                        <scope line="564"/>
                    </scope>
                    <scope line="568">
                        <declaration name="pszInt" type="int" line="577"/>
                        <scope line="579"/>
                        <scope line="583"/>
                        <scope line="586"/>
                    </scope>
                </scope>
                <declaration name="fmhint" type="int" line="598"/>
                <scope line="599"/>
                <declaration name="aahint" type="int" line="626"/>
                <scope line="627"/>
                <scope line="629"/>
                <scope line="632">
                    <scope line="633"/>
                    <scope line="635"/>
                </scope>
                <scope line="638">
                    <scope line="645">
                        <scope line="646"/>
                        <scope line="648"/>
                    </scope>
                    <scope line="651">
                        <scope line="672"/>
                        <scope line="674">
                            <scope line="683"/>
                            <scope line="687"/>
                        </scope>
                    </scope>
                </scope>
            </method>
            <method name="isRotated" type="boolean" line="706">
                <params>
                    <param name="mtx" type="double[]"/>
                </params>
                <scope line="711"/>
            </method>
            <method name="setFont" type="void" line="718">
                <params>
                    <param name="font" type="Font"/>
                </params>
                <comment line="719">
                    replacing the reference equality test font != this.font with
                     !font.equals(this.font) did not yield any measurable difference
                     in testing, but there may be yet to be identified cases where it
                     is beneficial.                    
                </comment>
                <comment line="724">
                                        
                </comment>
                <comment line="725">
                    In the GASP AA case the textpipe depends on the glyph size
                     as determined by graphics and font transforms as well as the
                     font size, and information in the font. But we may invalidate
                     the pipe only to find that it made no difference.
                     Deferring pipe invalidation to checkFontInfo won&apos;t work because
                     when called we may already be rendering to the wrong pipe.
                     So, if the font is transformed, or the graphics has more than
                     a simple scale, we&apos;ll take that as enough of a hint to
                     revalidate everything. But if they aren&apos;t we will
                     use the font&apos;s point size to query the gasp table and see if
                     what it says matches what&apos;s currently being used, in which
                     case there&apos;s no need to invalidate the textpipe.
                     This should be sufficient for all typical uses cases.                    
                </comment>
                <comment line="743">
                    Precaution, if true shouldn&apos;t get here                    
                </comment>
                <scope line="724">
                    <scope line="746"/>
                </scope>
            </method>
            <method name="getFontInfo" type="FontInfo" line="755">
                <scope line="756"/>
            </method>
            <method name="getGVFontInfo" type="FontInfo" line="764">
                <params>
                    <param name="font" type="Font"/>
                    <param name="frc" type="FontRenderContext"/>
                </params>
                <scope line="767"/>
                <scope line="769"/>
            </method>
            <method name="getFontMetrics" type="FontMetrics" line="776">
                <comment line="780">
                                        
                </comment>
                <scope line="777"/>
            </method>
            <method name="getFontMetrics" type="FontMetrics" line="785">
                <params>
                    <param name="font" type="Font"/>
                </params>
                <scope line="786"/>
                <declaration name="fm" type="FontMetrics" line="789"/>
                <scope line="792"/>
            </method>
            <javadoc line="798">
                Checks to see if a Path intersects the specified Rectangle in device
                  space.  The rendering attributes taken into account include the
                  clip, transform, and stroke attributes.                
                <param>
                    rect The area in device space to check for a hit.                    
                </param>
                <param>
                    p The path to check for a hit.                    
                </param>
                <param>
                    onStroke Flag to choose between testing the stroked or
                      the filled path.                    
                </param>
                <return>
                    True if there is a hit, false otherwise.                    
                </return>
                <see>
                    #setStroke                    
                </see>
                <see>
                    #fillPath                    
                </see>
                <see>
                    #drawPath                    
                </see>
                <see>
                    #transform                    
                </see>
                <see>
                    #setTransform                    
                </see>
                <see>
                    #clip                    
                </see>
                <see>
                    #setClip                    
                </see>
            </javadoc>
            <method name="hit" type="boolean" line="815">
                <params>
                    <param name="rect" type="Rectangle"/>
                    <param name="s" type="Shape"/>
                    <param name="onStroke" type="boolean"/>
                </params>
                <scope line="816"/>
                <scope line="821"/>
            </method>
            <javadoc line="829">
                Return the ColorModel associated with this Graphics2D.                
            </javadoc>
            <method name="getDeviceColorModel" type="ColorModel" line="832"/>
            <javadoc line="836">
                Return the device configuration associated with this Graphics2D.                
            </javadoc>
            <method name="getDeviceConfiguration" type="GraphicsConfiguration" line="839"/>
            <javadoc line="843">
                Return the SurfaceData object assigned to manage the destination
                  drawable surface of this Graphics2D.                
            </javadoc>
            <method name="getSurfaceData" type="SurfaceData" line="847"/>
            <javadoc line="851">
                Sets the Composite in the current graphics state. Composite is used
                  in all drawing methods such as drawImage, drawString, drawPath,
                  and fillPath.  It specifies how new pixels are to be combined with
                  the existing pixels on the graphics device in the rendering process.                
                <param>
                    comp The Composite object to be used for drawing.                    
                </param>
                <see>
                    java.awt.Graphics#setXORMode                    
                </see>
                <see>
                    java.awt.Graphics#setPaintMode                    
                </see>
                <see>
                    AlphaComposite                    
                </see>
            </javadoc>
            <method name="setComposite" type="void" line="861">
                <params>
                    <param name="comp" type="Composite"/>
                </params>
                <scope line="862"/>
                <declaration name="newCompState" type="int" line="865"/>
                <declaration name="newCompType" type="CompositeType" line="866"/>
                <scope line="867">
                    <declaration name="alphacomp" type="AlphaComposite" line="868"/>
                    <scope line="870">
                        <scope line="874"/>
                        <scope line="876"/>
                    </scope>
                    <scope line="882"/>
                    <scope line="886"/>
                    <scope line="888"/>
                </scope>
                <scope line="891"/>
                <scope line="894"/>
                <scope line="896"/>
                <scope line="903"/>
                <scope line="910"/>
            </method>
            <javadoc line="915">
                Sets the Paint in the current graphics state.                
                <param>
                    paint The Paint object to be used to generate color in
                      the rendering process.                    
                </param>
                <see>
                    java.awt.Graphics#setColor                    
                </see>
                <see>
                    GradientPaint                    
                </see>
                <see>
                    TexturePaint                    
                </see>
            </javadoc>
            <method name="setPaint" type="void" line="923">
                <params>
                    <param name="paint" type="Paint"/>
                </params>
                <comment line="933">
                    special case where compState depends on opacity of paint                    
                </comment>
                <scope line="924"/>
                <scope line="928"/>
                <scope line="932">
                    <scope line="934">
                        <scope line="935"/>
                    </scope>
                    <scope line="938">
                        <scope line="939"/>
                    </scope>
                </scope>
                <declaration name="paintClass" type="Class" line="944"/>
                <scope line="945"/>
                <scope line="947"/>
                <scope line="949"/>
                <scope line="951"/>
                <scope line="953"/>
            </method>
            <declaration name="NON_UNIFORM_SCALE_MASK" type="int" line="960"/>
            <declaration name="MinPenSizeAA" type="double" line="963"/>
            <declaration name="MinPenSizeAASquared" type="double" line="965"/>
            <declaration name="MinPenSizeSquared" type="double" line="972"/>
            <method name="validateBasicStroke" type="void" line="974">
                <params>
                    <param name="bs" type="BasicStroke"/>
                </params>
                <comment line="1003">
                                        
                </comment>
                <comment line="1006">
                                        
                </comment>
                <comment line="1007">
                    m00                    
                </comment>
                <comment line="1008">
                    m01                    
                </comment>
                <comment line="1009">
                    m10                    
                </comment>
                <comment line="1010">
                    m11                    
                </comment>
                <comment line="1012">
                    Given a 2 x 2 affine matrix [ A B ] such that
                                                 [ C D ]
                     v&apos; = [x&apos; y&apos;] = [Ax + Cy, Bx + Dy], we want to
                     find the maximum magnitude (norm) of the vector v&apos;
                     with the constraint (x^2 + y^2 = 1).
                     The equation to maximize is
                         |v&apos;| = sqrt((Ax+Cy)^2+(Bx+Dy)^2)
                     or  |v&apos;| = sqrt((AA+BB)x^2 + 2(AC+BD)xy + (CC+DD)y^2).
                     Since sqrt is monotonic we can maximize |v&apos;|^2
                     instead and plug in the substitution y = sqrt(1 - x^2).
                     Trigonometric equalities can then be used to get
                     rid of most of the sqrt terms.                    
                </comment>
                <comment line="1026">
                    x^2 coefficient                    
                </comment>
                <comment line="1027">
                    xy coefficient                    
                </comment>
                <comment line="1028">
                    y^2 coefficient                    
                </comment>
                <comment line="1030">
                    There is a lot of calculus omitted here.
                    
                     Conceptually, in the interests of understanding the
                     terms that the calculus produced we can consider
                     that EA and EC end up providing the lengths along
                     the major axes and the hypot term ends up being an
                     adjustment for the additional length along the off-axis
                     angle of rotated or sheared ellipses as well as an
                     adjustment for the fact that the equation below
                     averages the two major axis lengths.  (Notice that
                     the hypot term contains a part which resolves to the
                     difference of these two axis lengths in the absence
                     of rotation.)
                    
                     In the calculus, the ratio of the EB and (EA-EC) terms
                     ends up being the tangent of 2theta where theta is
                     the angle that the long axis of the ellipse makes
                     with the horizontal axis.  Thus, this equation is
                     calculating the length of the hypotenuse of a triangle
                     along that axis.                    
                </comment>
                <comment line="1054">
                                        
                </comment>
                <declaration name="aa" type="boolean" line="975"/>
                <scope line="976">
                    <scope line="977">
                        <scope line="978">
                            <scope line="979"/>
                            <scope line="981"/>
                        </scope>
                        <scope line="984"/>
                    </scope>
                    <scope line="987">
                        <scope line="988"/>
                        <scope line="990">
                            <scope line="991"/>
                            <scope line="993"/>
                        </scope>
                        <scope line="996"/>
                    </scope>
                </scope>
                <scope line="1000">
                    <declaration name="widthsquared" type="double" line="1001"/>
                    <scope line="1002"/>
                    <scope line="1005">
                        <declaration name="A" type="double" line="1007"/>
                        <declaration name="C" type="double" line="1008"/>
                        <declaration name="B" type="double" line="1009"/>
                        <declaration name="D" type="double" line="1010"/>
                        <declaration name="EA" type="double" line="1026"/>
                        <declaration name="EB" type="double" line="1027"/>
                        <declaration name="EC" type="double" line="1028"/>
                        <declaration name="hypot" type="double" line="1052"/>
                    </scope>
                    <scope line="1057"/>
                    <scope line="1062">
                        <scope line="1063"/>
                        <scope line="1065"/>
                    </scope>
                    <scope line="1068"/>
                </scope>
            </method>
            <method name="setStroke" type="void" line="1080">
                <params>
                    <param name="s" type="Stroke"/>
                </params>
                <scope line="1081"/>
                <declaration name="saveStrokeState" type="int" line="1084"/>
                <scope line="1086"/>
                <scope line="1088"/>
                <scope line="1091"/>
            </method>
            <javadoc line="1096">
                Sets the preferences for the rendering algorithms.
                  Hint categories include controls for rendering quality and
                  overall time/quality trade-off in the rendering process.                
                <param>
                    hintKey The key of hint to be set. The strings are
                      defined in the RenderingHints class.                    
                </param>
                <param>
                    hintValue The value indicating preferences for the specified
                      hint category. These strings are defined in the RenderingHints
                      class.                    
                </param>
                <see>
                    RenderingHints                    
                </see>
            </javadoc>
            <method name="setRenderingHint" type="void" line="1107">
                <params>
                    <param name="hintKey" type="Key"/>
                    <param name="hintValue" type="Object"/>
                </params>
                <comment line="1108">
                    If we recognize the key, we must recognize the value                    
                </comment>
                <comment line="1109">
                    otherwise throw an IllegalArgumentException                    
                </comment>
                <comment line="1110">
                    and do not change the Hints object                    
                </comment>
                <comment line="1111">
                    If we do not recognize the key, just pass it through                    
                </comment>
                <comment line="1112">
                    to the Hints object untouched                    
                </comment>
                <comment line="1165">
                                        
                </comment>
                <comment line="1210">
                    Nothing we recognize so none of &quot;our state&quot; has changed                    
                </comment>
                <scope line="1113"/>
                <scope line="1117">
                    <declaration name="stateChanged" type="boolean" line="1118"/>
                    <declaration name="textStateChanged" type="boolean" line="1119"/>
                    <declaration name="recognized" type="boolean" line="1120"/>
                    <declaration name="sunKey" type="SunHints.Key" line="1121"/>
                    <declaration name="newHint" type="int" line="1122"/>
                    <scope line="1123"/>
                    <scope line="1125"/>
                    <scope line="1131">
                        <scope line="1133"/>
                    </scope>
                    <scope line="1144">
                        <scope line="1148"/>
                    </scope>
                    <scope line="1194">
                        <scope line="1195">
                            <scope line="1197"/>
                        </scope>
                        <scope line="1204"/>
                    </scope>
                </scope>
                <scope line="1211"/>
            </method>
            <javadoc line="1218">
                Returns the preferences for the rendering algorithms.                
                <param>
                    hintCategory The category of hint to be set. The strings
                      are defined in the RenderingHints class.                    
                </param>
                <return>
                    The preferences for rendering algorithms. The strings
                      are defined in the RenderingHints class.                    
                </return>
                <see>
                    RenderingHints                    
                </see>
            </javadoc>
            <method name="getRenderingHint" type="Object" line="1226">
                <params>
                    <param name="hintKey" type="Key"/>
                </params>
                <scope line="1227"/>
                <scope line="1230"/>
                <declaration name="keyindex" type="int" line="1233"/>
            </method>
            <javadoc line="1266">
                Sets the preferences for the rendering algorithms.
                  Hint categories include controls for rendering quality and
                  overall time/quality trade-off in the rendering process.                
                <param>
                    hints The rendering hints to be set                    
                </param>
                <see>
                    RenderingHints                    
                </see>
            </javadoc>
            <method name="setRenderingHints" type="void" line="1273">
                <params>
                    <param name="hints" type="Map<?,?>"/>
                </params>
                <declaration name="customHintPresent" type="boolean" line="1282"/>
                <declaration name="iter" type="Iterator" line="1283"/>
                <scope line="1284">
                    <declaration name="key" type="Object" line="1285"/>
                    <scope line="1293"/>
                    <scope line="1295"/>
                </scope>
                <scope line="1299"/>
            </method>
            <javadoc line="1305">
                Adds a number of preferences for the rendering algorithms.
                  Hint categories include controls for rendering quality and
                  overall time/quality trade-off in the rendering process.                
                <param>
                    hints The rendering hints to be set                    
                </param>
                <see>
                    RenderingHints                    
                </see>
            </javadoc>
            <method name="addRenderingHints" type="void" line="1312">
                <params>
                    <param name="hints" type="Map<?,?>"/>
                </params>
                <declaration name="customHintPresent" type="boolean" line="1313"/>
                <declaration name="iter" type="Iterator" line="1314"/>
                <scope line="1315">
                    <declaration name="key" type="Object" line="1316"/>
                    <scope line="1324"/>
                    <scope line="1326"/>
                </scope>
                <scope line="1330">
                    <scope line="1331"/>
                    <scope line="1333"/>
                </scope>
            </method>
            <javadoc line="1339">
                Gets the preferences for the rendering algorithms.
                  Hint categories include controls for rendering quality and
                  overall time/quality trade-off in the rendering process.                
                <see>
                    RenderingHints                    
                </see>
            </javadoc>
            <method name="getRenderingHints" type="RenderingHints" line="1345">
                <scope line="1346"/>
                <scope line="1348"/>
            </method>
            <method name="makeHints" type="RenderingHints" line="1353">
                <params>
                    <param name="hints" type="Map"/>
                </params>
                <declaration name="model" type="RenderingHints" line="1354"/>
                <declaration name="value" type="Object" line="1369"/>
                <scope line="1384"/>
            </method>
            <javadoc line="1393">
                Concatenates the current transform of this Graphics2D with a
                  translation transformation.
                  This is equivalent to calling transform(T), where T is an
                  AffineTransform represented by the following matrix:
                  &lt;pre&gt;
                  [   1    0    tx  ]
                  [   0    1    ty  ]
                  [   0    0    1   ]
                  &lt;/pre&gt;                
            </javadoc>
            <method name="translate" type="void" line="1404">
                <params>
                    <param name="tx" type="double"/>
                    <param name="ty" type="double"/>
                </params>
            </method>
            <javadoc line="1409">
                Concatenates the current transform of this Graphics2D with a
                  rotation transformation.
                  This is equivalent to calling transform(R), where R is an
                  AffineTransform represented by the following matrix:
                  &lt;pre&gt;
                  [   cos(theta)    -sin(theta)    0   ]
                  [   sin(theta)     cos(theta)    0   ]
                  [       0              0         1   ]
                  &lt;/pre&gt;
                  Rotating with a positive angle theta rotates points on the positive
                  x axis toward the positive y axis.                
                <param>
                    theta The angle of rotation in radians.                    
                </param>
            </javadoc>
            <method name="rotate" type="void" line="1423">
                <params>
                    <param name="theta" type="double"/>
                </params>
            </method>
            <javadoc line="1428">
                Concatenates the current transform of this Graphics2D with a
                  translated rotation transformation.
                  This is equivalent to the following sequence of calls:
                  &lt;pre&gt;
                  translate(x, y);
                  rotate(theta);
                  translate(-x, -y);
                  &lt;/pre&gt;
                  Rotating with a positive angle theta rotates points on the positive
                  x axis toward the positive y axis.                
                <param>
                    theta The angle of rotation in radians.                    
                </param>
                <param>
                    x The x coordinate of the origin of the rotation                    
                </param>
                <param>
                    y The x coordinate of the origin of the rotation                    
                </param>
            </javadoc>
            <method name="rotate" type="void" line="1443">
                <params>
                    <param name="theta" type="double"/>
                    <param name="x" type="double"/>
                    <param name="y" type="double"/>
                </params>
            </method>
            <javadoc line="1448">
                Concatenates the current transform of this Graphics2D with a
                  scaling transformation.
                  This is equivalent to calling transform(S), where S is an
                  AffineTransform represented by the following matrix:
                  &lt;pre&gt;
                  [   sx   0    0   ]
                  [   0    sy   0   ]
                  [   0    0    1   ]
                  &lt;/pre&gt;                
            </javadoc>
            <method name="scale" type="void" line="1459">
                <params>
                    <param name="sx" type="double"/>
                    <param name="sy" type="double"/>
                </params>
            </method>
            <javadoc line="1464">
                Concatenates the current transform of this Graphics2D with a
                  shearing transformation.
                  This is equivalent to calling transform(SH), where SH is an
                  AffineTransform represented by the following matrix:
                  &lt;pre&gt;
                  [   1   shx   0   ]
                  [  shy   1    0   ]
                  [   0    0    1   ]
                  &lt;/pre&gt;                
                <param>
                    shx The factor by which coordinates are shifted towards the
                      positive X axis direction according to their Y coordinate                    
                </param>
                <param>
                    shy The factor by which coordinates are shifted towards the
                      positive Y axis direction according to their X coordinate                    
                </param>
            </javadoc>
            <method name="shear" type="void" line="1479">
                <params>
                    <param name="shx" type="double"/>
                    <param name="shy" type="double"/>
                </params>
            </method>
            <javadoc line="1484">
                Composes a Transform object with the transform in this
                  Graphics2D according to the rule last-specified-first-applied.
                  If the currrent transform is Cx, the result of composition
                  with Tx is a new transform Cx&apos;.  Cx&apos; becomes the current
                  transform for this Graphics2D.
                  Transforming a point p by the updated transform Cx&apos; is
                  equivalent to first transforming p by Tx and then transforming
                  the result by the original transform Cx.  In other words,
                  Cx&apos;(p) = Cx(Tx(p)).
                  A copy of the Tx is made, if necessary, so further
                  modifications to Tx do not affect rendering.                
                <param>
                    Tx The Transform object to be composed with the current
                      transform.                    
                </param>
                <see>
                    #setTransform                    
                </see>
                <see>
                    AffineTransform                    
                </see>
            </javadoc>
            <method name="transform" type="void" line="1501">
                <params>
                    <param name="xform" type="AffineTransform"/>
                </params>
            </method>
            <javadoc line="1506">
                Translate                
            </javadoc>
            <method name="translate" type="void" line="1509">
                <params>
                    <param name="x" type="int"/>
                    <param name="y" type="int"/>
                </params>
                <scope line="1511"/>
                <scope line="1516"/>
            </method>
            <javadoc line="1521">
                Sets the Transform in the current graphics state.                
                <param>
                    Tx The Transform object to be used in the rendering process.                    
                </param>
                <see>
                    #transform                    
                </see>
                <see>
                    TransformChain                    
                </see>
                <see>
                    AffineTransform                    
                </see>
            </javadoc>
            <method name="setTransform" type="void" line="1528">
                <params>
                    <param name="Tx" type="AffineTransform"/>
                </params>
                <scope line="1529"/>
                <scope line="1531"/>
            </method>
            <method name="invalidateTransform" type="void" line="1538">
                <comment line="1568">
                    Its only in this case that the previous or current transform
                     was more than a translate that font info is invalidated                    
                </comment>
                <declaration name="type" type="int" line="1539"/>
                <declaration name="origTransformState" type="int" line="1540"/>
                <scope line="1541"/>
                <scope line="1544">
                    <declaration name="dtx" type="double" line="1545"/>
                    <declaration name="dty" type="double" line="1546"/>
                    <scope line="1549"/>
                    <scope line="1551"/>
                </scope>
                <scope line="1557"/>
                <scope line="1560"/>
                <scope line="1567">
                    <scope line="1576"/>
                </scope>
                <scope line="1580"/>
            </method>
            <javadoc line="1585">
                Returns the current Transform in the Graphics2D state.                
                <see>
                    #transform                    
                </see>
                <see>
                    #setTransform                    
                </see>
            </javadoc>
            <method name="getTransform" type="AffineTransform" line="1590">
                <scope line="1591"/>
                <declaration name="tx" type="AffineTransform" line="1594"/>
            </method>
            <javadoc line="1600">
                Returns the current Transform ignoring the &quot;constrain&quot;
                  rectangle.                
            </javadoc>
            <method name="cloneTransform" type="AffineTransform" line="1604"/>
            <javadoc line="1608">
                Returns the current Paint in the Graphics2D state.                
                <see>
                    #setPaint                    
                </see>
                <see>
                    java.awt.Graphics#setColor                    
                </see>
            </javadoc>
            <method name="getPaint" type="Paint" line="1613"/>
            <javadoc line="1617">
                Returns the current Composite in the Graphics2D state.                
                <see>
                    #setComposite                    
                </see>
            </javadoc>
            <method name="getComposite" type="Composite" line="1621"/>
            <method name="getColor" type="Color" line="1625"/>
            <method name="validateColor" type="void" line="1649">
                <declaration name="eargb" type="int" line="1650"/>
                <scope line="1651"/>
                <scope line="1653">
                    <scope line="1658">
                        <declaration name="alphacomp" type="AlphaComposite" line="1659"/>
                        <declaration name="a" type="int" line="1660"/>
                    </scope>
                </scope>
            </method>
            <method name="setColor" type="void" line="1668">
                <params>
                    <param name="color" type="Color"/>
                </params>
                <comment line="1680">
                    special case where compState depends on opacity of paint                    
                </comment>
                <comment line="1689">
                    special case where compState depends on opacity of paint                    
                </comment>
                <scope line="1669"/>
                <scope line="1674">
                    <scope line="1675"/>
                    <scope line="1679"/>
                </scope>
                <scope line="1683">
                    <scope line="1684"/>
                    <scope line="1688"/>
                </scope>
            </method>
            <javadoc line="1697">
                Sets the background color in this context used for clearing a region.
                  When Graphics2D is constructed for a component, the backgroung color is
                  inherited from the component. Setting the background color in the
                  Graphics2D context only affects the subsequent clearRect() calls and
                  not the background color of the component. To change the background
                  of the component, use appropriate methods of the component.                
                <param>
                    color The background color that should be used in
                      subsequent calls to clearRect().                    
                </param>
                <see>
                    getBackground                    
                </see>
                <see>
                    Graphics.clearRect()                    
                </see>
            </javadoc>
            <method name="setBackground" type="void" line="1709">
                <params>
                    <param name="color" type="Color"/>
                </params>
            </method>
            <javadoc line="1713">
                Returns the background color used for clearing a region.                
                <see>
                    setBackground                    
                </see>
            </javadoc>
            <method name="getBackground" type="Color" line="1717"/>
            <javadoc line="1721">
                Returns the current Stroke in the Graphics2D state.                
                <see>
                    setStroke                    
                </see>
            </javadoc>
            <method name="getStroke" type="Stroke" line="1725"/>
            <method name="getClipBounds" type="Rectangle" line="1729">
                <declaration name="r" type="Rectangle" line="1730"/>
                <scope line="1731"/>
                <scope line="1733">
                    <scope line="1734"/>
                    <scope line="1736"/>
                </scope>
                <scope line="1740"/>
            </method>
            <method name="getClipBounds" type="Rectangle" line="1746">
                <params>
                    <param name="r" type="Rectangle"/>
                </params>
                <scope line="1747">
                    <scope line="1748">
                        <scope line="1749"/>
                        <scope line="1751"/>
                    </scope>
                    <scope line="1755"/>
                </scope>
                <scope line="1758"/>
            </method>
            <method name="hitClip" type="boolean" line="1764">
                <params>
                    <param name="x" type="int"/>
                    <param name="y" type="int"/>
                    <param name="width" type="int"/>
                    <param name="height" type="int"/>
                </params>
                <comment line="1769">
                    Note: Technically the most accurate test would be to                    
                </comment>
                <comment line="1770">
                    raster scan the parallelogram of the transformed rectangle                    
                </comment>
                <comment line="1771">
                    and do a span for span hit test against the clip, but for                    
                </comment>
                <comment line="1772">
                    speed we approximate the test with a bounding box of the                    
                </comment>
                <comment line="1773">
                    transformed rectangle.  The cost of rasterizing the                    
                </comment>
                <comment line="1774">
                    transformed rectangle is probably high enough that it is                    
                </comment>
                <comment line="1775">
                    not worth doing so to save the caller from having to call                    
                </comment>
                <comment line="1776">
                    a rendering method where we will end up discovering the                    
                </comment>
                <comment line="1777">
                    same answer in about the same amount of time anyway.                    
                </comment>
                <comment line="1778">
                    This logic breaks down if this hit test is being performed                    
                </comment>
                <comment line="1779">
                    on the bounds of a group of shapes in which case it might                    
                </comment>
                <comment line="1780">
                    be beneficial to be a little more accurate to avoid lots                    
                </comment>
                <comment line="1781">
                    of subsequent rendering calls.  In either case, this relaxed                    
                </comment>
                <comment line="1782">
                    test should not be significantly less accurate than the                    
                </comment>
                <comment line="1783">
                    optimal test for most transforms and so the conservative                    
                </comment>
                <comment line="1784">
                    answer should not cause too much extra work.                    
                </comment>
                <comment line="1810">
                    REMIND: We could go one step further here and examine the                    
                </comment>
                <comment line="1811">
                    non-rectangular clip shape more closely if there is one.                    
                </comment>
                <comment line="1812">
                    Since the clip has already been rasterized, the performance                    
                </comment>
                <comment line="1813">
                    penalty of doing the scan is probably still within the bounds                    
                </comment>
                <comment line="1814">
                    of a good tradeoff between speed and quality of the answer.                    
                </comment>
                <scope line="1765"/>
                <scope line="1768">
                    <declaration name="d" type="double" line="1786"/>
                </scope>
                <scope line="1801"/>
                <scope line="1807"/>
            </method>
            <method name="validateCompClip" type="void" line="1818">
                <declaration name="origClipState" type="int" line="1819"/>
                <scope line="1820"/>
                <scope line="1823">
                    <scope line="1825"/>
                    <scope line="1827"/>
                </scope>
                <scope line="1830">
                    <declaration name="cpi" type="PathIterator" line="1831"/>
                    <declaration name="box" type="int" line="1832"/>
                    <declaration name="sr" type="ShapeSpanIterator" line="1833"/>
                    <scope line="1834">
                        <declaration name="r" type="Region" line="1838"/>
                    </scope>
                    <scope line="1843"/>
                </scope>
                <scope line="1849"/>
            </method>
            <declaration name="NON_RECTILINEAR_TRANSFORM_MASK" type="int" line="1855"/>
            <method name="transformShape" type="Shape" line="1859">
                <params>
                    <param name="s" type="Shape"/>
                </params>
                <scope line="1860"/>
                <scope line="1863"/>
                <scope line="1865"/>
            </method>
            <method name="untransformShape" type="Shape" line="1870">
                <params>
                    <param name="s" type="Shape"/>
                </params>
                <scope line="1871"/>
                <scope line="1874">
                    <scope line="1875"/>
                    <scope line="1877"/>
                </scope>
                <scope line="1880"/>
            </method>
            <method name="transformShape" type="Shape" line="1885">
                <params>
                    <param name="tx" type="int"/>
                    <param name="ty" type="int"/>
                    <param name="s" type="Shape"/>
                </params>
                <scope line="1886"/>
                <scope line="1890">
                    <declaration name="r" type="Rectangle" line="1891"/>
                </scope>
                <scope line="1895">
                    <declaration name="rect" type="Rectangle2D" line="1896"/>
                </scope>
                <scope line="1903"/>
                <declaration name="mat" type="AffineTransform" line="1907"/>
            </method>
            <method name="transformShape" type="Shape" line="1911">
                <params>
                    <param name="tx" type="AffineTransform"/>
                    <param name="clip" type="Shape"/>
                </params>
                <scope line="1912"/>
                <scope line="1918">
                    <declaration name="rect" type="Rectangle2D" line="1919"/>
                    <declaration name="matrix" type="double" line="1920"/>
                </scope>
                <scope line="1932"/>
            </method>
            <method name="clipRect" type="void" line="1939">
                <params>
                    <param name="x" type="int"/>
                    <param name="y" type="int"/>
                    <param name="w" type="int"/>
                    <param name="h" type="int"/>
                </params>
            </method>
            <method name="setClip" type="void" line="1943">
                <params>
                    <param name="x" type="int"/>
                    <param name="y" type="int"/>
                    <param name="w" type="int"/>
                    <param name="h" type="int"/>
                </params>
            </method>
            <method name="getClip" type="Shape" line="1947"/>
            <method name="setClip" type="void" line="1951">
                <params>
                    <param name="sh" type="Shape"/>
                </params>
            </method>
            <javadoc line="1956">
                Intersects the current clip with the specified Path and sets the
                  current clip to the resulting intersection. The clip is transformed
                  with the current transform in the Graphics2D state before being
                  intersected with the current clip. This method is used to make the
                  current clip smaller. To make the clip larger, use any setClip method.                
                <param>
                    p The Path to be intersected with the current clip.                    
                </param>
            </javadoc>
            <method name="clip" type="void" line="1964">
                <params>
                    <param name="s" type="Shape"/>
                </params>
                <scope line="1966"/>
            </method>
            <method name="setPaintMode" type="void" line="1973"/>
            <method name="setXORMode" type="void" line="1977">
                <params>
                    <param name="c" type="Color"/>
                </params>
                <scope line="1978"/>
            </method>
            <declaration name="lastCAblit" type="Blit" line="1984"/>
            <declaration name="lastCAcomp" type="Composite" line="1985"/>
            <method name="copyArea" type="void" line="1987">
                <params>
                    <param name="x" type="int"/>
                    <param name="y" type="int"/>
                    <param name="w" type="int"/>
                    <param name="h" type="int"/>
                    <param name="dx" type="int"/>
                    <param name="dy" type="int"/>
                </params>
                <comment line="1995">
                    Still catching the exception; we are not yet ready to                    
                </comment>
                <comment line="1996">
                    validate the surfaceData correctly.  Fail for now and                    
                </comment>
                <comment line="1997">
                    try again next time around.                    
                </comment>
                <scope line="1988"/>
                <scope line="1990">
                    <scope line="1992"/>
                    <scope line="1994"/>
                </scope>
                <scope line="1999"/>
            </method>
            <method name="doCopyArea" type="void" line="2004">
                <params>
                    <param name="x" type="int"/>
                    <param name="y" type="int"/>
                    <param name="w" type="int"/>
                    <param name="h" type="int"/>
                    <param name="dx" type="int"/>
                    <param name="dy" type="int"/>
                </params>
                <comment line="2015">
                    REMIND: This method does not deal with missing data from the                    
                </comment>
                <comment line="2016">
                    source object (i.e. it does not send exposure events...)                    
                </comment>
                <scope line="2005"/>
                <declaration name="theData" type="SurfaceData" line="2008"/>
                <scope line="2009"/>
                <scope line="2012"/>
                <declaration name="clip" type="Region" line="2018"/>
                <declaration name="comp" type="Composite" line="2020"/>
                <scope line="2021">
                    <declaration name="dsttype" type="SurfaceType" line="2022"/>
                    <declaration name="comptype" type="CompositeType" line="2023"/>
                    <scope line="2026"/>
                </scope>
                <declaration name="ob" type="Blit" line="2036"/>
                <scope line="2037">
                    <scope line="2038">
                        <declaration name="partW" type="int" line="2039"/>
                        <declaration name="sx" type="int" line="2041"/>
                    </scope>
                </scope>
                <scope line="2047">
                    <scope line="2048">
                        <declaration name="partH" type="int" line="2049"/>
                        <declaration name="sy" type="int" line="2051"/>
                    </scope>
                </scope>
            </method>
            <method name="drawLine" type="void" line="2119">
                <params>
                    <param name="x1" type="int"/>
                    <param name="y1" type="int"/>
                    <param name="x2" type="int"/>
                    <param name="y2" type="int"/>
                </params>
                <comment line="2127">
                    Still catching the exception; we are not yet ready to                    
                </comment>
                <comment line="2128">
                    validate the surfaceData correctly.  Fail for now and                    
                </comment>
                <comment line="2129">
                    try again next time around.                    
                </comment>
                <scope line="2120"/>
                <scope line="2122">
                    <scope line="2124"/>
                    <scope line="2126"/>
                </scope>
                <scope line="2131"/>
            </method>
            <method name="drawRoundRect" type="void" line="2136">
                <params>
                    <param name="x" type="int"/>
                    <param name="y" type="int"/>
                    <param name="w" type="int"/>
                    <param name="h" type="int"/>
                    <param name="arcW" type="int"/>
                    <param name="arcH" type="int"/>
                </params>
                <comment line="2144">
                    Still catching the exception; we are not yet ready to                    
                </comment>
                <comment line="2145">
                    validate the surfaceData correctly.  Fail for now and                    
                </comment>
                <comment line="2146">
                    try again next time around.                    
                </comment>
                <scope line="2137"/>
                <scope line="2139">
                    <scope line="2141"/>
                    <scope line="2143"/>
                </scope>
                <scope line="2148"/>
            </method>
            <method name="fillRoundRect" type="void" line="2153">
                <params>
                    <param name="x" type="int"/>
                    <param name="y" type="int"/>
                    <param name="w" type="int"/>
                    <param name="h" type="int"/>
                    <param name="arcW" type="int"/>
                    <param name="arcH" type="int"/>
                </params>
                <comment line="2161">
                    Still catching the exception; we are not yet ready to                    
                </comment>
                <comment line="2162">
                    validate the surfaceData correctly.  Fail for now and                    
                </comment>
                <comment line="2163">
                    try again next time around.                    
                </comment>
                <scope line="2154"/>
                <scope line="2156">
                    <scope line="2158"/>
                    <scope line="2160"/>
                </scope>
                <scope line="2165"/>
            </method>
            <method name="drawOval" type="void" line="2170">
                <params>
                    <param name="x" type="int"/>
                    <param name="y" type="int"/>
                    <param name="w" type="int"/>
                    <param name="h" type="int"/>
                </params>
                <comment line="2178">
                    Still catching the exception; we are not yet ready to                    
                </comment>
                <comment line="2179">
                    validate the surfaceData correctly.  Fail for now and                    
                </comment>
                <comment line="2180">
                    try again next time around.                    
                </comment>
                <scope line="2171"/>
                <scope line="2173">
                    <scope line="2175"/>
                    <scope line="2177"/>
                </scope>
                <scope line="2182"/>
            </method>
            <method name="fillOval" type="void" line="2187">
                <params>
                    <param name="x" type="int"/>
                    <param name="y" type="int"/>
                    <param name="w" type="int"/>
                    <param name="h" type="int"/>
                </params>
                <comment line="2195">
                    Still catching the exception; we are not yet ready to                    
                </comment>
                <comment line="2196">
                    validate the surfaceData correctly.  Fail for now and                    
                </comment>
                <comment line="2197">
                    try again next time around.                    
                </comment>
                <scope line="2188"/>
                <scope line="2190">
                    <scope line="2192"/>
                    <scope line="2194"/>
                </scope>
                <scope line="2199"/>
            </method>
            <method name="drawArc" type="void" line="2205">
                <params>
                    <param name="x" type="int"/>
                    <param name="y" type="int"/>
                    <param name="w" type="int"/>
                    <param name="h" type="int"/>
                    <param name="startAngl" type="int"/>
                    <param name="arcAngl" type="int"/>
                </params>
                <comment line="2213">
                    Still catching the exception; we are not yet ready to                    
                </comment>
                <comment line="2214">
                    validate the surfaceData correctly.  Fail for now and                    
                </comment>
                <comment line="2215">
                    try again next time around.                    
                </comment>
                <scope line="2206"/>
                <scope line="2208">
                    <scope line="2210"/>
                    <scope line="2212"/>
                </scope>
                <scope line="2217"/>
            </method>
            <method name="fillArc" type="void" line="2223">
                <params>
                    <param name="x" type="int"/>
                    <param name="y" type="int"/>
                    <param name="w" type="int"/>
                    <param name="h" type="int"/>
                    <param name="startAngl" type="int"/>
                    <param name="arcAngl" type="int"/>
                </params>
                <comment line="2231">
                    Still catching the exception; we are not yet ready to                    
                </comment>
                <comment line="2232">
                    validate the surfaceData correctly.  Fail for now and                    
                </comment>
                <comment line="2233">
                    try again next time around.                    
                </comment>
                <scope line="2224"/>
                <scope line="2226">
                    <scope line="2228"/>
                    <scope line="2230"/>
                </scope>
                <scope line="2235"/>
            </method>
            <method name="drawPolyline" type="void" line="2240">
                <params>
                    <param name="xPoints" type="int"/>
                    <param name="yPoints" type="int"/>
                    <param name="nPoints" type="int"/>
                </params>
                <comment line="2248">
                    Still catching the exception; we are not yet ready to                    
                </comment>
                <comment line="2249">
                    validate the surfaceData correctly.  Fail for now and                    
                </comment>
                <comment line="2250">
                    try again next time around.                    
                </comment>
                <scope line="2241"/>
                <scope line="2243">
                    <scope line="2245"/>
                    <scope line="2247"/>
                </scope>
                <scope line="2252"/>
            </method>
            <method name="drawPolygon" type="void" line="2257">
                <params>
                    <param name="xPoints" type="int"/>
                    <param name="yPoints" type="int"/>
                    <param name="nPoints" type="int"/>
                </params>
                <comment line="2265">
                    Still catching the exception; we are not yet ready to                    
                </comment>
                <comment line="2266">
                    validate the surfaceData correctly.  Fail for now and                    
                </comment>
                <comment line="2267">
                    try again next time around.                    
                </comment>
                <scope line="2258"/>
                <scope line="2260">
                    <scope line="2262"/>
                    <scope line="2264"/>
                </scope>
                <scope line="2269"/>
            </method>
            <method name="fillPolygon" type="void" line="2274">
                <params>
                    <param name="xPoints" type="int"/>
                    <param name="yPoints" type="int"/>
                    <param name="nPoints" type="int"/>
                </params>
                <comment line="2282">
                    Still catching the exception; we are not yet ready to                    
                </comment>
                <comment line="2283">
                    validate the surfaceData correctly.  Fail for now and                    
                </comment>
                <comment line="2284">
                    try again next time around.                    
                </comment>
                <scope line="2275"/>
                <scope line="2277">
                    <scope line="2279"/>
                    <scope line="2281"/>
                </scope>
                <scope line="2286"/>
            </method>
            <method name="drawRect" type="void" line="2291">
                <params>
                    <param name="x" type="int"/>
                    <param name="y" type="int"/>
                    <param name="w" type="int"/>
                    <param name="h" type="int"/>
                </params>
                <comment line="2299">
                    Still catching the exception; we are not yet ready to                    
                </comment>
                <comment line="2300">
                    validate the surfaceData correctly.  Fail for now and                    
                </comment>
                <comment line="2301">
                    try again next time around.                    
                </comment>
                <scope line="2292"/>
                <scope line="2294">
                    <scope line="2296"/>
                    <scope line="2298"/>
                </scope>
                <scope line="2303"/>
            </method>
            <method name="fillRect" type="void" line="2308">
                <params>
                    <param name="x" type="int"/>
                    <param name="y" type="int"/>
                    <param name="w" type="int"/>
                    <param name="h" type="int"/>
                </params>
                <comment line="2316">
                    Still catching the exception; we are not yet ready to                    
                </comment>
                <comment line="2317">
                    validate the surfaceData correctly.  Fail for now and                    
                </comment>
                <comment line="2318">
                    try again next time around.                    
                </comment>
                <scope line="2309"/>
                <scope line="2311">
                    <scope line="2313"/>
                    <scope line="2315"/>
                </scope>
                <scope line="2320"/>
            </method>
            <method name="revalidateAll" type="void" line="2325">
                <comment line="2327">
                    REMIND: This locking needs to be done around the                    
                </comment>
                <comment line="2328">
                    caller of this method so that the pipe stays valid                    
                </comment>
                <comment line="2329">
                    long enough to call the new primitive.                    
                </comment>
                <comment line="2330">
                    REMIND: No locking yet in screen SurfaceData objects!                    
                </comment>
                <comment line="2331">
                    surfaceData.lock();                    
                </comment>
                <comment line="2337">
                    this will recalculate the composite clip                    
                </comment>
                <comment line="2349">
                    REMIND: No locking yet in screen SurfaceData objects!                    
                </comment>
                <comment line="2350">
                    surfaceData.unlock();                    
                </comment>
                <scope line="2326">
                    <scope line="2333"/>
                    <scope line="2340"/>
                    <scope line="2343">
                        <declaration name="c" type="Color" line="2344"/>
                    </scope>
                </scope>
                <scope line="2348"/>
            </method>
            <method name="clearRect" type="void" line="2354">
                <params>
                    <param name="x" type="int"/>
                    <param name="y" type="int"/>
                    <param name="w" type="int"/>
                    <param name="h" type="int"/>
                </params>
                <comment line="2355">
                    REMIND: has some &quot;interesting&quot; consequences if threads are                    
                </comment>
                <comment line="2356">
                    not synchronized                    
                </comment>
                <declaration name="c" type="Composite" line="2357"/>
                <declaration name="p" type="Paint" line="2358"/>
            </method>
            <javadoc line="2367">
                Strokes the outline of a Path using the settings of the current
                  graphics state.  The rendering attributes applied include the
                  clip, transform, paint or color, composite and stroke attributes.                
                <param>
                    p The path to be drawn.                    
                </param>
                <see>
                    #setStroke                    
                </see>
                <see>
                    #setPaint                    
                </see>
                <see>
                    java.awt.Graphics#setColor                    
                </see>
                <see>
                    #transform                    
                </see>
                <see>
                    #setTransform                    
                </see>
                <see>
                    #clip                    
                </see>
                <see>
                    #setClip                    
                </see>
                <see>
                    #setComposite                    
                </see>
            </javadoc>
            <method name="draw" type="void" line="2381">
                <params>
                    <param name="s" type="Shape"/>
                </params>
                <comment line="2389">
                    Still catching the exception; we are not yet ready to                    
                </comment>
                <comment line="2390">
                    validate the surfaceData correctly.  Fail for now and                    
                </comment>
                <comment line="2391">
                    try again next time around.                    
                </comment>
                <scope line="2382"/>
                <scope line="2384">
                    <scope line="2386"/>
                    <scope line="2388"/>
                </scope>
                <scope line="2393"/>
            </method>
            <javadoc line="2399">
                Fills the interior of a Path using the settings of the current
                  graphics state. The rendering attributes applied include the
                  clip, transform, paint or color, and composite.                
                <see>
                    #setPaint                    
                </see>
                <see>
                    java.awt.Graphics#setColor                    
                </see>
                <see>
                    #transform                    
                </see>
                <see>
                    #setTransform                    
                </see>
                <see>
                    #setComposite                    
                </see>
                <see>
                    #clip                    
                </see>
                <see>
                    #setClip                    
                </see>
            </javadoc>
            <method name="fill" type="void" line="2411">
                <params>
                    <param name="s" type="Shape"/>
                </params>
                <comment line="2419">
                    Still catching the exception; we are not yet ready to                    
                </comment>
                <comment line="2420">
                    validate the surfaceData correctly.  Fail for now and                    
                </comment>
                <comment line="2421">
                    try again next time around.                    
                </comment>
                <scope line="2412"/>
                <scope line="2414">
                    <scope line="2416"/>
                    <scope line="2418"/>
                </scope>
                <scope line="2423"/>
            </method>
            <javadoc line="2428">
                Returns true if the given AffineTransform is an integer
                  translation.                
            </javadoc>
            <method name="isIntegerTranslation" type="boolean" line="2432">
                <params>
                    <param name="xform" type="AffineTransform"/>
                </params>
                <scope line="2433"/>
                <scope line="2436">
                    <declaration name="tx" type="double" line="2437"/>
                    <declaration name="ty" type="double" line="2438"/>
                </scope>
            </method>
            <javadoc line="2444">
                Returns the index of the tile corresponding to the supplied position
                  given the tile grid offset and size along the same axis.                
            </javadoc>
            <method name="getTileIndex" type="int" line="2448">
                <params>
                    <param name="p" type="int"/>
                    <param name="tileGridOffset" type="int"/>
                    <param name="tileSize" type="int"/>
                </params>
                <comment line="2451">
                    force round to -infinity (ceiling)                    
                </comment>
                <scope line="2450"/>
            </method>
            <javadoc line="2456">
                Returns a rectangle in image coordinates that may be required
                  in order to draw the given image into the given clipping region
                  through a pair of AffineTransforms.  In addition, horizontal and
                  vertical padding factors for antialising and interpolation may
                  be used.                
            </javadoc>
            <method name="getImageRegion" type="Rectangle" line="2467">
                <params>
                    <param name="img" type="RenderedImage"/>
                    <param name="compClip" type="Region"/>
                    <param name="transform" type="AffineTransform"/>
                    <param name="xform" type="AffineTransform"/>
                    <param name="padX" type="int"/>
                    <param name="padY" type="int"/>
                </params>
                <comment line="2480">
                    Inverse transform the output bounding rect                    
                </comment>
                <comment line="2484">
                    Determine a bounding box for the inverse transformed region                    
                </comment>
                <comment line="2504">
                    This is padding for anti-aliasing and such.  It may                    
                </comment>
                <comment line="2505">
                    be more than is needed.                    
                </comment>
                <comment line="2514">
                    Worst case bounds are the bounds of the image.                    
                </comment>
                <declaration name="imageRect" type="Rectangle" line="2468"/>
                <declaration name="result" type="Rectangle" line="2472"/>
                <scope line="2473">
                    <declaration name="p" type="double" line="2474"/>
                    <declaration name="x0" type="double" line="2485"/>
                    <scope line="2489">
                        <declaration name="pt" type="double" line="2490"/>
                        <scope line="2491"/>
                        <scope line="2493"/>
                        <scope line="2497"/>
                        <scope line="2499"/>
                    </scope>
                    <declaration name="x" type="int" line="2506"/>
                    <declaration name="w" type="int" line="2507"/>
                    <declaration name="y" type="int" line="2508"/>
                    <declaration name="h" type="int" line="2509"/>
                    <declaration name="clipRect" type="Rectangle" line="2511"/>
                </scope>
                <scope line="2513"/>
            </method>
            <javadoc line="2521">
                Draws an image, applying a transform from image space into user space
                  before drawing.
                  The transformation from user space into device space is done with
                  the current transform in the Graphics2D.
                  The given transformation is applied to the image before the
                  transform attribute in the Graphics2D state is applied.
                  The rendering attributes applied include the clip, transform,
                  and composite attributes. Note that the result is
                  undefined, if the given transform is noninvertible.                
                <param>
                    img The image to be drawn. Does nothing if img is null.                    
                </param>
                <param>
                    xform The transformation from image space into user space.                    
                </param>
                <see>
                    #transform                    
                </see>
                <see>
                    #setTransform                    
                </see>
                <see>
                    #setComposite                    
                </see>
                <see>
                    #clip                    
                </see>
                <see>
                    #setClip                    
                </see>
            </javadoc>
            <method name="drawRenderedImage" type="void" line="2540">
                <params>
                    <param name="img" type="RenderedImage"/>
                    <param name="xform" type="AffineTransform"/>
                </params>
                <comment line="2546">
                    BufferedImage case: use a simple drawImage call                    
                </comment>
                <comment line="2553">
                    transformState tracks the state of transform and                    
                </comment>
                <comment line="2554">
                    transX, transY contain the integer casts of the                    
                </comment>
                <comment line="2555">
                    translation factors                    
                </comment>
                <comment line="2560">
                    Include padding for interpolation/antialiasing if necessary                    
                </comment>
                <comment line="2563">
                    Determine the region of the image that may contribute to                    
                </comment>
                <comment line="2564">
                    the clipped drawing area                    
                </comment>
                <comment line="2574">
                    Attempt to optimize integer translation of tiled images.                    
                </comment>
                <comment line="2575">
                    Although theoretically we are O.K. if the concatenation of                    
                </comment>
                <comment line="2576">
                    the user transform and the device transform is an integer                    
                </comment>
                <comment line="2577">
                    translation, we&apos;ll play it safe and only optimize the case                    
                </comment>
                <comment line="2578">
                    where both are integer translations.                    
                </comment>
                <comment line="2580">
                    Use optimized code                    
                </comment>
                <comment line="2581">
                    Note that drawTranslatedRenderedImage calls copyImage                    
                </comment>
                <comment line="2582">
                    which takes the user space to device space transform into                    
                </comment>
                <comment line="2583">
                    account, but we need to provide the image space to user space                    
                </comment>
                <comment line="2584">
                    translations.                    
                </comment>
                <comment line="2592">
                    General case: cobble the necessary region into a single Raster                    
                </comment>
                <comment line="2595">
                    Make a new Raster with the same contents as raster                    
                </comment>
                <comment line="2596">
                    but starting at (0, 0).  This raster is thus in the same                    
                </comment>
                <comment line="2597">
                    coordinate system as the SampleModel of the original raster.                    
                </comment>
                <comment line="2603">
                    If the original raster was in a different coordinate                    
                </comment>
                <comment line="2604">
                    system than its SampleModel, we need to perform an                    
                </comment>
                <comment line="2605">
                    additional translation in order to get the (minX, minY)                    
                </comment>
                <comment line="2606">
                    pixel of raster to be pixel (0, 0) of wRaster.  We also                    
                </comment>
                <comment line="2607">
                    have to have the correct width and height.                    
                </comment>
                <comment line="2625">
                    Now we have a BufferedImage starting at (0, 0)                    
                </comment>
                <comment line="2626">
                    with the same contents that started at (minX, minY)                    
                </comment>
                <comment line="2627">
                    in raster.  So we must draw the BufferedImage with a                    
                </comment>
                <comment line="2628">
                    translation of (minX, minY).                    
                </comment>
                <scope line="2542"/>
                <scope line="2547">
                    <declaration name="bufImg" type="BufferedImage" line="2548"/>
                </scope>
                <declaration name="isIntegerTranslate" type="boolean" line="2556"/>
                <declaration name="pad" type="int" line="2561"/>
                <declaration name="region" type="Rectangle" line="2565"/>
                <scope line="2570"/>
                <scope line="2579"/>
                <declaration name="raster" type="Raster" line="2593"/>
                <declaration name="wRaster" type="WritableRaster" line="2598"/>
                <declaration name="minX" type="int" line="2608"/>
                <declaration name="minY" type="int" line="2609"/>
                <declaration name="width" type="int" line="2610"/>
                <declaration name="height" type="int" line="2611"/>
                <declaration name="px" type="int" line="2612"/>
                <declaration name="py" type="int" line="2613"/>
                <scope line="2615"/>
                <declaration name="transXform" type="AffineTransform" line="2629"/>
                <declaration name="cm" type="ColorModel" line="2632"/>
                <declaration name="bufImg" type="BufferedImage" line="2633"/>
            </method>
            <javadoc line="2640">
                Intersects &lt;code&gt;destRect&lt;/code&gt; with &lt;code&gt;clip&lt;/code&gt; and
                  overwrites &lt;code&gt;destRect&lt;/code&gt; with the result.
                  Returns false if the intersection was empty, true otherwise.                
            </javadoc>
            <method name="clipTo" type="boolean" line="2645">
                <params>
                    <param name="destRect" type="Rectangle"/>
                    <param name="clip" type="Rectangle"/>
                </params>
                <comment line="2651">
                    Set both just to be safe                    
                </comment>
                <declaration name="x1" type="int" line="2646"/>
                <declaration name="x2" type="int" line="2647"/>
                <declaration name="y1" type="int" line="2648"/>
                <declaration name="y2" type="int" line="2649"/>
                <scope line="2650"/>
                <scope line="2654"/>
            </method>
            <javadoc line="2663">
                Draw a portion of a RenderedImage tile-by-tile with a given
                  integer image to user space translation.  The user to
                  device transform must also be an integer translation.                
            </javadoc>
            <method name="drawTranslatedRenderedImage" type="void" line="2671">
                <params>
                    <param name="img" type="RenderedImage"/>
                    <param name="region" type="Rectangle"/>
                    <param name="i2uTransX" type="int"/>
                    <param name="i2uTransY" type="int"/>
                </params>
                <comment line="2672">
                    Cache tile grid info                    
                </comment>
                <comment line="2678">
                    Determine the tile index extrema in each direction                    
                </comment>
                <comment line="2690">
                    Create a single ColorModel to use for all BufferedImages                    
                </comment>
                <comment line="2693">
                    Reuse the same Rectangle for each iteration                    
                </comment>
                <comment line="2698">
                    Get the current tile.                    
                </comment>
                <comment line="2701">
                    Fill in tileRect with the tile bounds                    
                </comment>
                <comment line="2707">
                    Clip the tile against the image bounds and                    
                </comment>
                <comment line="2708">
                    backwards mapped clip region                    
                </comment>
                <comment line="2709">
                    The result can&apos;t be empty                    
                </comment>
                <comment line="2712">
                    Create a WritableRaster containing the tile                    
                </comment>
                <comment line="2717">
                    Create a WritableRaster in the same coordinate system                    
                </comment>
                <comment line="2718">
                    as the original raster.                    
                </comment>
                <comment line="2725">
                    Translate wRaster to start at (0, 0) and to contain                    
                </comment>
                <comment line="2726">
                    only the relevent portion of the tile                    
                </comment>
                <comment line="2733">
                    Wrap wRaster in a BufferedImage                    
                </comment>
                <comment line="2739">
                    Now we have a BufferedImage starting at (0, 0) that                    
                </comment>
                <comment line="2740">
                    represents data from a Raster starting at                    
                </comment>
                <comment line="2741">
                    (tileRect.x, tileRect.y).  Additionally, it needs                    
                </comment>
                <comment line="2742">
                    to be translated by (i2uTransX, i2uTransY).  We call                    
                </comment>
                <comment line="2743">
                    copyImage to draw just the region of interest                    
                </comment>
                <comment line="2744">
                    without needing to create a child image.                    
                </comment>
                <declaration name="tileGridXOffset" type="int" line="2673"/>
                <declaration name="tileGridYOffset" type="int" line="2674"/>
                <declaration name="tileWidth" type="int" line="2675"/>
                <declaration name="tileHeight" type="int" line="2676"/>
                <declaration name="minTileX" type="int" line="2679"/>
                <declaration name="minTileY" type="int" line="2681"/>
                <declaration name="maxTileX" type="int" line="2683"/>
                <declaration name="maxTileY" type="int" line="2686"/>
                <declaration name="colorModel" type="ColorModel" line="2691"/>
                <declaration name="tileRect" type="Rectangle" line="2694"/>
                <scope line="2696">
                    <scope line="2697">
                        <declaration name="raster" type="Raster" line="2699"/>
                        <declaration name="wRaster" type="WritableRaster" line="2713"/>
                        <scope line="2714"/>
                        <scope line="2716"/>
                        <declaration name="bufImg" type="BufferedImage" line="2734"/>
                    </scope>
                </scope>
            </method>
            <method name="drawRenderableImage" type="void" line="2753">
                <params>
                    <param name="img" type="RenderableImage"/>
                    <param name="xform" type="AffineTransform"/>
                </params>
                <scope line="2755"/>
                <declaration name="pipeTransform" type="AffineTransform" line="2759"/>
                <declaration name="concatTransform" type="AffineTransform" line="2760"/>
                <declaration name="reverseTransform" type="AffineTransform" line="2762"/>
                <declaration name="rc" type="RenderContext" line="2764"/>
                <scope line="2766"/>
                <scope line="2768"/>
                <declaration name="rendering" type="RenderedImage" line="2773"/>
            </method>
            <method name="transformBounds" type="Rectangle" line="2783">
                <params>
                    <param name="rect" type="Rectangle"/>
                    <param name="tx" type="AffineTransform"/>
                </params>
                <scope line="2784"/>
                <declaration name="s" type="Shape" line="2788"/>
            </method>
            <method name="drawString" type="void" line="2793">
                <params>
                    <param name="str" type="String"/>
                    <param name="x" type="int"/>
                    <param name="y" type="int"/>
                </params>
                <comment line="2813">
                    Still catching the exception; we are not yet ready to                    
                </comment>
                <comment line="2814">
                    validate the surfaceData correctly.  Fail for now and                    
                </comment>
                <comment line="2815">
                    try again next time around.                    
                </comment>
                <scope line="2794"/>
                <scope line="2798">
                    <scope line="2799"/>
                </scope>
                <scope line="2806"/>
                <scope line="2808">
                    <scope line="2810"/>
                    <scope line="2812"/>
                </scope>
                <scope line="2817"/>
            </method>
            <method name="drawString" type="void" line="2822">
                <params>
                    <param name="str" type="String"/>
                    <param name="x" type="float"/>
                    <param name="y" type="float"/>
                </params>
                <comment line="2842">
                    Still catching the exception; we are not yet ready to                    
                </comment>
                <comment line="2843">
                    validate the surfaceData correctly.  Fail for now and                    
                </comment>
                <comment line="2844">
                    try again next time around.                    
                </comment>
                <scope line="2823"/>
                <scope line="2827">
                    <scope line="2828"/>
                </scope>
                <scope line="2835"/>
                <scope line="2837">
                    <scope line="2839"/>
                    <scope line="2841"/>
                </scope>
                <scope line="2846"/>
            </method>
            <method name="drawString" type="void" line="2852">
                <params>
                    <param name="iterator" type="AttributedCharacterIterator"/>
                    <param name="x" type="int"/>
                    <param name="y" type="int"/>
                </params>
                <comment line="2857">
                                        
                </comment>
                <scope line="2853"/>
                <scope line="2856"/>
                <declaration name="tl" type="TextLayout" line="2859"/>
            </method>
            <method name="drawString" type="void" line="2864">
                <params>
                    <param name="iterator" type="AttributedCharacterIterator"/>
                    <param name="x" type="float"/>
                    <param name="y" type="float"/>
                </params>
                <comment line="2869">
                                        
                </comment>
                <scope line="2865"/>
                <scope line="2868"/>
                <declaration name="tl" type="TextLayout" line="2871"/>
            </method>
            <method name="drawGlyphVector" type="void" line="2876">
                <params>
                    <param name="gv" type="GlyphVector"/>
                    <param name="x" type="float"/>
                    <param name="y" type="float"/>
                </params>
                <comment line="2888">
                    Still catching the exception; we are not yet ready to                    
                </comment>
                <comment line="2889">
                    validate the surfaceData correctly.  Fail for now and                    
                </comment>
                <comment line="2890">
                    try again next time around.                    
                </comment>
                <scope line="2877"/>
                <scope line="2881"/>
                <scope line="2883">
                    <scope line="2885"/>
                    <scope line="2887"/>
                </scope>
                <scope line="2892"/>
            </method>
            <method name="drawChars" type="void" line="2897">
                <params>
                    <param name="data" type="char"/>
                    <param name="offset" type="int"/>
                    <param name="length" type="int"/>
                    <param name="x" type="int"/>
                    <param name="y" type="int"/>
                </params>
                <comment line="2921">
                    Still catching the exception; we are not yet ready to                    
                </comment>
                <comment line="2922">
                    validate the surfaceData correctly.  Fail for now and                    
                </comment>
                <comment line="2923">
                    try again next time around.                    
                </comment>
                <scope line="2899"/>
                <scope line="2902"/>
                <scope line="2905">
                    <scope line="2906"/>
                </scope>
                <scope line="2914"/>
                <scope line="2916">
                    <scope line="2918"/>
                    <scope line="2920"/>
                </scope>
                <scope line="2925"/>
            </method>
            <method name="drawBytes" type="void" line="2930">
                <params>
                    <param name="data" type="byte"/>
                    <param name="offset" type="int"/>
                    <param name="length" type="int"/>
                    <param name="x" type="int"/>
                    <param name="y" type="int"/>
                </params>
                <comment line="2937">
                                        
                </comment>
                <comment line="2958">
                    Still catching the exception; we are not yet ready to                    
                </comment>
                <comment line="2959">
                    validate the surfaceData correctly.  Fail for now and                    
                </comment>
                <comment line="2960">
                    try again next time around.                    
                </comment>
                <scope line="2931"/>
                <scope line="2934"/>
                <declaration name="chData" type="char" line="2938"/>
                <scope line="2939"/>
                <scope line="2942">
                    <scope line="2943"/>
                </scope>
                <scope line="2951"/>
                <scope line="2953">
                    <scope line="2955"/>
                    <scope line="2957"/>
                </scope>
                <scope line="2962"/>
            </method>
            <javadoc line="2968">
                Draws an image scaled to x,y,w,h in nonblocking mode with a
                  callback object.                
            </javadoc>
            <method name="drawImage" type="boolean" line="2973">
                <params>
                    <param name="img" type="Image"/>
                    <param name="x" type="int"/>
                    <param name="y" type="int"/>
                    <param name="width" type="int"/>
                    <param name="height" type="int"/>
                    <param name="observer" type="ImageObserver"/>
                </params>
            </method>
            <javadoc line="2977">
                Not part of the advertised API but a useful utility method
                  to call internally.  This is for the case where we are
                  drawing to/from given coordinates using a given width/height,
                  but we guarantee that the weidth/height of the src and dest
                  areas are equal (no scale needed).                
            </javadoc>
            <method name="copyImage" type="boolean" line="2986">
                <params>
                    <param name="img" type="Image"/>
                    <param name="dx" type="int"/>
                    <param name="dy" type="int"/>
                    <param name="sx" type="int"/>
                    <param name="sy" type="int"/>
                    <param name="width" type="int"/>
                    <param name="height" type="int"/>
                    <param name="bgcolor" type="Color"/>
                    <param name="observer" type="ImageObserver"/>
                </params>
                <comment line="2996">
                    Still catching the exception; we are not yet ready to                    
                </comment>
                <comment line="2997">
                    validate the surfaceData correctly.  Fail for now and                    
                </comment>
                <comment line="2998">
                    try again next time around.                    
                </comment>
                <scope line="2987"/>
                <scope line="2990">
                    <scope line="2992"/>
                    <scope line="2995"/>
                </scope>
                <scope line="3001"/>
            </method>
            <javadoc line="3006">
                Draws an image scaled to x,y,w,h in nonblocking mode with a
                  solid background color and a callback object.                
            </javadoc>
            <method name="drawImage" type="boolean" line="3011">
                <params>
                    <param name="img" type="Image"/>
                    <param name="x" type="int"/>
                    <param name="y" type="int"/>
                    <param name="width" type="int"/>
                    <param name="height" type="int"/>
                    <param name="bg" type="Color"/>
                    <param name="observer" type="ImageObserver"/>
                </params>
                <comment line="3033">
                    Still catching the exception; we are not yet ready to                    
                </comment>
                <comment line="3034">
                    validate the surfaceData correctly.  Fail for now and                    
                </comment>
                <comment line="3035">
                    try again next time around.                    
                </comment>
                <scope line="3013"/>
                <scope line="3017"/>
                <scope line="3020"/>
                <scope line="3024"/>
                <scope line="3027">
                    <scope line="3029"/>
                    <scope line="3032"/>
                </scope>
                <scope line="3038"/>
            </method>
            <javadoc line="3043">
                Draws an image at x,y in nonblocking mode.                
            </javadoc>
            <method name="drawImage" type="boolean" line="3046">
                <params>
                    <param name="img" type="Image"/>
                    <param name="x" type="int"/>
                    <param name="y" type="int"/>
                    <param name="observer" type="ImageObserver"/>
                </params>
            </method>
            <javadoc line="3050">
                Draws an image at x,y in nonblocking mode with a solid background
                  color and a callback object.                
            </javadoc>
            <method name="drawImage" type="boolean" line="3055">
                <params>
                    <param name="img" type="Image"/>
                    <param name="x" type="int"/>
                    <param name="y" type="int"/>
                    <param name="bg" type="Color"/>
                    <param name="observer" type="ImageObserver"/>
                </params>
                <comment line="3068">
                    Still catching the exception; we are not yet ready to                    
                </comment>
                <comment line="3069">
                    validate the surfaceData correctly.  Fail for now and                    
                </comment>
                <comment line="3070">
                    try again next time around.                    
                </comment>
                <scope line="3057"/>
                <scope line="3061"/>
                <scope line="3063">
                    <scope line="3065"/>
                    <scope line="3067"/>
                </scope>
                <scope line="3073"/>
            </method>
            <javadoc line="3078">
                Draws a subrectangle of an image scaled to a destination rectangle
                  in nonblocking mode with a callback object.                
            </javadoc>
            <method name="drawImage" type="boolean" line="3085">
                <params>
                    <param name="img" type="Image"/>
                    <param name="dx1" type="int"/>
                    <param name="dy1" type="int"/>
                    <param name="dx2" type="int"/>
                    <param name="dy2" type="int"/>
                    <param name="sx1" type="int"/>
                    <param name="sy1" type="int"/>
                    <param name="sx2" type="int"/>
                    <param name="sy2" type="int"/>
                    <param name="observer" type="ImageObserver"/>
                </params>
            </method>
            <javadoc line="3090">
                Draws a subrectangle of an image scaled to a destination rectangle in
                  nonblocking mode with a solid background color and a callback object.                
            </javadoc>
            <method name="drawImage" type="boolean" line="3097">
                <params>
                    <param name="img" type="Image"/>
                    <param name="dx1" type="int"/>
                    <param name="dy1" type="int"/>
                    <param name="dx2" type="int"/>
                    <param name="dy2" type="int"/>
                    <param name="sx1" type="int"/>
                    <param name="sy1" type="int"/>
                    <param name="sx2" type="int"/>
                    <param name="sy2" type="int"/>
                    <param name="bgcolor" type="Color"/>
                    <param name="observer" type="ImageObserver"/>
                </params>
                <comment line="3112">
                    Not a scale - forward it to a copy routine                    
                </comment>
                <comment line="3147">
                    Still catching the exception; we are not yet ready to                    
                </comment>
                <comment line="3148">
                    validate the surfaceData correctly.  Fail for now and                    
                </comment>
                <comment line="3149">
                    try again next time around.                    
                </comment>
                <scope line="3099"/>
                <scope line="3105"/>
                <scope line="3111">
                    <declaration name="srcX" type="int" line="3113"/>
                    <scope line="3114"/>
                    <scope line="3118"/>
                    <scope line="3123"/>
                    <scope line="3127"/>
                </scope>
                <scope line="3136"/>
                <scope line="3140">
                    <scope line="3142"/>
                    <scope line="3146"/>
                </scope>
                <scope line="3152"/>
            </method>
            <javadoc line="3157">
                Draw an image, applying a transform from image space into user space
                  before drawing.
                  The transformation from user space into device space is done with
                  the current transform in the Graphics2D.
                  The given transformation is applied to the image before the
                  transform attribute in the Graphics2D state is applied.
                  The rendering attributes applied include the clip, transform,
                  paint or color and composite attributes. Note that the result is
                  undefined, if the given transform is non-invertible.                
                <param>
                    img The image to be drawn.                    
                </param>
                <param>
                    xform The transformation from image space into user space.                    
                </param>
                <param>
                    observer The image observer to be notified on the image producing
                      progress.                    
                </param>
                <see>
                    #transform                    
                </see>
                <see>
                    #setComposite                    
                </see>
                <see>
                    #setClip                    
                </see>
            </javadoc>
            <method name="drawImage" type="boolean" line="3177">
                <params>
                    <param name="img" type="Image"/>
                    <param name="xform" type="AffineTransform"/>
                    <param name="observer" type="ImageObserver"/>
                </params>
                <comment line="3194">
                    Still catching the exception; we are not yet ready to                    
                </comment>
                <comment line="3195">
                    validate the surfaceData correctly.  Fail for now and                    
                </comment>
                <comment line="3196">
                    try again next time around.                    
                </comment>
                <scope line="3179"/>
                <scope line="3183"/>
                <scope line="3187"/>
                <scope line="3189">
                    <scope line="3191"/>
                    <scope line="3193"/>
                </scope>
                <scope line="3199"/>
            </method>
            <method name="drawImage" type="void" line="3207">
                <params>
                    <param name="bImg" type="BufferedImage"/>
                    <param name="op" type="BufferedImageOp"/>
                    <param name="x" type="int"/>
                    <param name="y" type="int"/>
                </params>
                <comment line="3220">
                    Still catching the exception; we are not yet ready to                    
                </comment>
                <comment line="3221">
                    validate the surfaceData correctly.  Fail for now and                    
                </comment>
                <comment line="3222">
                    try again next time around.                    
                </comment>
                <scope line="3209"/>
                <scope line="3213"/>
                <scope line="3215">
                    <scope line="3217"/>
                    <scope line="3219"/>
                </scope>
                <scope line="3224"/>
            </method>
            <javadoc line="3229">
                Get the rendering context of the font
                  within this Graphics2D context.                
            </javadoc>
            <method name="getFontRenderContext" type="FontRenderContext" line="3233">
                <comment line="3240">
                    Translation components should be excluded from the FRC transform                    
                </comment>
                <scope line="3234">
                    <declaration name="aahint" type="int" line="3235"/>
                    <scope line="3237"/>
                    <declaration name="tx" type="AffineTransform" line="3241"/>
                    <scope line="3242">
                        <scope line="3244"/>
                        <scope line="3246"/>
                    </scope>
                </scope>
            </method>
            <declaration name="cachedFRC" type="FontRenderContext" line="3261"/>
            <javadoc line="3263">
                This object has no resources to dispose of per se, but the
                  doc comments for the base method in java.awt.Graphics imply
                  that this object will not be useable after it is disposed.
                  So, we sabotage the object to prevent further use to prevent
                  developers from relying on behavior that may not work on
                  other, less forgiving, VMs that really need to dispose of
                  resources.                
            </javadoc>
            <method name="dispose" type="void" line="3272"/>
            <javadoc line="3277">
                Graphics has a finalize method that automatically calls dispose()
                  for subclasses.  For SunGraphics2D we do not need to be finalized
                  so that method simply causes us to be enqueued on the Finalizer
                  queues for no good reason.  Unfortunately, that method and
                  implementation are now considered part of the public contract
                  of that base class so we can not remove or gut the method.
                  We override it here with an empty method and the VM is smart
                  enough to know that if our override is empty then it should not
                  mark us as finalizeable.                
            </javadoc>
            <method name="finalize" type="void" line="3288">
                <comment line="3289">
                    DO NOT REMOVE THIS METHOD                    
                </comment>
            </method>
            <javadoc line="3292">
                Returns destination that this Graphics renders to.  This could be
                  either an Image or a Component; subclasses of SurfaceData are
                  responsible for returning the appropriate object.                
            </javadoc>
            <method name="getDestination" type="Object" line="3297"/>
            <javadoc line="3301">
                {@inheritDoc}                
                <see>
                    sun.java2d.DestSurfaceProvider#getDestSurface                    
                </see>
            </javadoc>
            <method name="getDestSurface" type="Surface" line="3307"/>
        </class>
    </source>