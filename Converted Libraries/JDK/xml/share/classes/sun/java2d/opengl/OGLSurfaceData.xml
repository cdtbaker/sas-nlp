<?xml version="1.0" encoding="UTF-8"?>
    <source package="sun.java2d.opengl">
        <import package="java.awt.AlphaComposite"/>
        <import package="java.awt.GraphicsEnvironment"/>
        <import package="java.awt.Rectangle"/>
        <import package="java.awt.Transparency"/>
        <import package="java.awt.image.ColorModel"/>
        <import package="java.awt.image.Raster"/>
        <import package="sun.awt.SunHints"/>
        <import package="sun.awt.image.PixelConverter"/>
        <import package="sun.java2d.pipe.hw.AccelSurface"/>
        <import package="sun.java2d.SunGraphics2D"/>
        <import package="sun.java2d.SurfaceData"/>
        <import package="sun.java2d.SurfaceDataProxy"/>
        <import package="sun.java2d.loops.CompositeType"/>
        <import package="sun.java2d.loops.GraphicsPrimitive"/>
        <import package="sun.java2d.loops.MaskFill"/>
        <import package="sun.java2d.loops.SurfaceType"/>
        <import package="sun.java2d.pipe.ParallelogramPipe"/>
        <import package="sun.java2d.pipe.PixelToParallelogramConverter"/>
        <import package="sun.java2d.pipe.RenderBuffer"/>
        <import package="sun.java2d.pipe.TextPipe"/>
        <import package="sun.java2d.pipe.BufferedOpCodes"/>
        <import package="sun.java2d.opengl.OGLContext.OGLContextCaps"/>
        <class name="OGLSurfaceData" line="51">
            <extends class="SurfaceData"/>
            <comment line="156">
                these fields are set from the native code when the surface is                
            </comment>
            <comment line="157">
                initialized                
            </comment>
            <implements interface="AccelSurface"/>
            <javadoc line="51">
                This class describes an OpenGL &quot;surface&quot;, that is, a region of pixels
                  managed via OpenGL.  An OGLSurfaceData can be tagged with one of three
                  different SurfaceType objects for the purpose of registering loops, etc.
                  This diagram shows the hierarchy of OGL SurfaceTypes:
                  Any
                  /     \
                  OpenGLSurface     OpenGLTexture
                  |
                  OpenGLSurfaceRTT
                  OpenGLSurface
                  This kind of surface can be rendered to using OpenGL APIs.  It is also
                  possible to copy an OpenGLSurface to another OpenGLSurface (or to itself).
                  This is typically accomplished by calling MakeContextCurrent(dstSD, srcSD)
                  and then calling glCopyPixels() (although there are other techniques to
                  achieve the same goal).
                  OpenGLTexture
                  This kind of surface cannot be rendered to using OpenGL (in the same sense
                  as in OpenGLSurface).  However, it is possible to upload a region of pixels
                  to an OpenGLTexture object via glTexSubImage2D().  One can also copy a
                  surface of type OpenGLTexture to an OpenGLSurface by binding the texture
                  to a quad and then rendering it to the destination surface (this process
                  is known as &quot;texture mapping&quot;).
                  OpenGLSurfaceRTT
                  This kind of surface can be thought of as a sort of hybrid between
                  OpenGLSurface and OpenGLTexture, in that one can render to this kind of
                  surface as if it were of type OpenGLSurface, but the process of copying
                  this kind of surface to another is more like an OpenGLTexture.  (Note that
                  &quot;RTT&quot; stands for &quot;render-to-texture&quot;.)
                  In addition to these SurfaceType variants, we have also defined some
                  constants that describe in more detail the type of underlying OpenGL
                  surface.  This table helps explain the relationships between those
                  &quot;type&quot; constants and their corresponding SurfaceType:
                  OGL Type          Corresponding SurfaceType
                  --------          -------------------------
                  WINDOW            OpenGLSurface
                  PBUFFER           OpenGLSurface
                  TEXTURE           OpenGLTexture
                  FLIP_BACKBUFFER   OpenGLSurface
                  FBOBJECT          OpenGLSurfaceRTT                
            </javadoc>
            <declaration name="PBUFFER" type="int" line="101"/>
            <javadoc line="101">
                OGL-specific surface types                
                <see>
                    sun.java2d.pipe.hw.AccelSurface                    
                </see>
            </javadoc>
            <declaration name="FBOBJECT" type="int" line="107"/>
            <declaration name="PF_INT_ARGB" type="int" line="109"/>
            <javadoc line="109">
                Pixel formats                
            </javadoc>
            <declaration name="PF_INT_ARGB_PRE" type="int" line="113"/>
            <declaration name="PF_INT_RGB" type="int" line="114"/>
            <declaration name="PF_INT_RGBX" type="int" line="115"/>
            <declaration name="PF_INT_BGR" type="int" line="116"/>
            <declaration name="PF_INT_BGRX" type="int" line="117"/>
            <declaration name="PF_USHORT_565_RGB" type="int" line="118"/>
            <declaration name="PF_USHORT_555_RGB" type="int" line="119"/>
            <declaration name="PF_USHORT_555_RGBX" type="int" line="120"/>
            <declaration name="PF_BYTE_GRAY" type="int" line="121"/>
            <declaration name="PF_USHORT_GRAY" type="int" line="122"/>
            <declaration name="PF_3BYTE_BGR" type="int" line="123"/>
            <declaration name="DESC_OPENGL_SURFACE" type="String" line="125"/>
            <javadoc line="125">
                SurfaceTypes                
            </javadoc>
            <declaration name="DESC_OPENGL_SURFACE_RTT" type="String" line="129"/>
            <declaration name="DESC_OPENGL_TEXTURE" type="String" line="131"/>
            <declaration name="OpenGLSurface" type="SurfaceType" line="133"/>
            <declaration name="OpenGLSurfaceRTT" type="SurfaceType" line="136"/>
            <declaration name="OpenGLTexture" type="SurfaceType" line="138"/>
            <declaration name="isFBObjectEnabled" type="boolean" line="141"/>
            <javadoc line="141">
                This will be true if the fbobject system property has been enabled.                
            </javadoc>
            <declaration name="isLCDShaderEnabled" type="boolean" line="144"/>
            <javadoc line="144">
                This will be true if the lcdshader system property has been enabled.                
            </javadoc>
            <declaration name="isBIOpShaderEnabled" type="boolean" line="147"/>
            <javadoc line="147">
                This will be true if the biopshader system property has been enabled.                
            </javadoc>
            <declaration name="isGradShaderEnabled" type="boolean" line="150"/>
            <javadoc line="150">
                This will be true if the gradshader system property has been enabled.                
            </javadoc>
            <declaration name="graphicsConfig" type="OGLGraphicsConfig" line="153"/>
            <declaration name="type" type="int" line="154"/>
            <declaration name="nativeWidth" type="int" line="157"/>
            <declaration name="oglRenderPipe" type="OGLRenderer" line="159"/>
            <declaration name="oglTxRenderPipe" type="PixelToParallelogramConverter" line="160"/>
            <declaration name="oglAAPgramPipe" type="ParallelogramPipe" line="161"/>
            <declaration name="oglTextPipe" type="OGLTextRenderer" line="162"/>
            <declaration name="oglImagePipe" type="OGLDrawImage" line="163"/>
            <method name="initTexture" type="boolean" line="165"/>
            <method name="initFBObject" type="boolean" line="169"/>
            <method name="initFlipBackbuffer" type="boolean" line="173"/>
            <method name="initPbuffer" type="boolean" line="174"/>
            <method name="getTextureTarget" type="int" line="178"/>
            <method name="getTextureID" type="int" line="179"/>
            <scope line="181">
                <scope line="182">
                    <declaration name="fbo" type="String" line="184"/>
                    <declaration name="lcd" type="String" line="190"/>
                    <declaration name="biop" type="String" line="196"/>
                    <declaration name="grad" type="String" line="202"/>
                    <declaration name="rq" type="OGLRenderQueue" line="207"/>
                    <scope line="211"/>
                </scope>
            </scope>
            <method name="OGLSurfaceData" type="constructor" line="230">
                <params>
                    <param name="gc" type="OGLGraphicsConfig"/>
                    <param name="cm" type="ColorModel"/>
                    <param name="type" type="int"/>
                </params>
            </method>
            <method name="makeProxyFor" type="SurfaceDataProxy" line="238">
                <params>
                    <param name="srcData" type="SurfaceData"/>
                </params>
            </method>
            <javadoc line="242">
                Returns the appropriate SurfaceType corresponding to the given OpenGL
                  surface type constant (e.g. TEXTURE -&gt; OpenGLTexture).                
            </javadoc>
            <method name="getCustomSurfaceType" type="SurfaceType" line="246">
                <params>
                    <param name="oglType" type="int"/>
                </params>
            </method>
            <javadoc line="258">
                Note: This should only be called from the QFT under the AWT lock.
                  This method is kept separate from the initSurface() method below just
                  to keep the code a bit cleaner.                
            </javadoc>
            <method name="initSurfaceNow" type="void" line="263">
                <params>
                    <param name="width" type="int"/>
                    <param name="height" type="int"/>
                </params>
                <declaration name="isOpaque" type="boolean" line="264"/>
                <declaration name="success" type="boolean" line="265"/>
                <scope line="297"/>
            </method>
            <javadoc line="302">
                Initializes the appropriate OpenGL offscreen surface based on the value
                  of the type parameter.  If the surface creation fails for any reason,
                  an OutOfMemoryError will be thrown.                
            </javadoc>
            <method name="initSurface" type="void" line="307">
                <params>
                    <param name="width" type="int"/>
                    <param name="height" type="int"/>
                </params>
                <comment line="315">
                    need to make sure the context is current before                    
                </comment>
                <comment line="316">
                    creating the texture (or pbuffer, or fbobject)                    
                </comment>
                <declaration name="rq" type="OGLRenderQueue" line="308"/>
                <scope line="310">
                    <anonymous_class line="322">
                        <method name="run" type="void" line="323"/>
                    </anonymous_class>
                </scope>
                <scope line="327"/>
            </method>
            <javadoc line="332">
                Returns the OGLContext for the GraphicsConfig associated with this
                  surface.                
            </javadoc>
            <method name="getContext" type="OGLContext" line="336"/>
            <javadoc line="340">
                Returns the OGLGraphicsConfig associated with this surface.                
            </javadoc>
            <method name="getOGLGraphicsConfig" type="OGLGraphicsConfig" line="343"/>
            <javadoc line="347">
                Returns one of the surface type constants defined above.                
            </javadoc>
            <method name="getType" type="int" line="350"/>
            <javadoc line="354">
                If this surface is backed by a texture object, returns the target
                  for that texture (either GL_TEXTURE_2D or GL_TEXTURE_RECTANGLE_ARB).
                  Otherwise, this method will return zero.                
            </javadoc>
            <method name="getTextureTarget" type="int" line="359"/>
            <javadoc line="363">
                If this surface is backed by a texture object, returns the texture ID
                  for that texture.
                  Otherwise, this method will return zero.                
            </javadoc>
            <method name="getTextureID" type="int" line="368"/>
            <javadoc line="372">
                Returns native resource of specified {@code resType} associated with
                  this surface.
                  Specifically, for {@code OGLSurfaceData} this method returns the
                  the following:
                  &lt;pre&gt;
                  TEXTURE              - texture id
                  &lt;/pre&gt;
                  Note: the resource returned by this method is only valid on the rendering
                  thread.                
                <return>
                    native resource of specified type or 0L if
                      such resource doesn't exist or can not be retrieved.                    
                </return>
                <see>
                    sun.java2d.pipe.hw.AccelSurface#getNativeResource                    
                </see>
            </javadoc>
            <method name="getNativeResource" type="long" line="389">
                <params>
                    <param name="resType" type="int"/>
                </params>
                <scope line="390"/>
            </method>
            <method name="getRaster" type="Raster" line="396">
                <params>
                    <param name="x" type="int"/>
                    <param name="y" type="int"/>
                    <param name="w" type="int"/>
                    <param name="h" type="int"/>
                </params>
            </method>
            <javadoc line="400">
                For now, we can only render LCD text if:
                  - the fragment shader extension is available, and
                  - blending is disabled, and
                  - the source color is opaque
                  - and the destination is opaque
                  Eventually, we could enhance the native OGL text rendering code
                  and remove the above restrictions, but that would require significantly
                  more code just to support a few uncommon cases.                
            </javadoc>
            <method name="canRenderLCDText" type="boolean" line="411">
                <params>
                    <param name="sg2d" type="SunGraphics2D"/>
                </params>
            </method>
            <method name="validatePipe" type="void" line="419">
                <params>
                    <param name="sg2d" type="SunGraphics2D"/>
                </params>
                <comment line="423">
                    OGLTextRenderer handles both AA and non-AA text, but                    
                </comment>
                <comment line="424">
                    only works with the following modes:                    
                </comment>
                <comment line="425">
                    (Note: For LCD text we only enter this code path if                    
                </comment>
                <comment line="426">
                    canRenderLCDText() has already validated that the mode is                    
                </comment>
                <comment line="427">
                    CompositeType.SrcNoEa (opaque color), which will be subsumed                    
                </comment>
                <comment line="428">
                    by the CompositeType.SrcNoEa (any color) test below.)                    
                </comment>
                <comment line="430">
                                        
                </comment>
                <comment line="434">
                                        
                </comment>
                <comment line="440">
                                        
                </comment>
                <comment line="446">
                    do this to initialize textpipe correctly; we will attempt                    
                </comment>
                <comment line="447">
                    to override the non-text pipes below                    
                </comment>
                <comment line="467">
                    custom paints handled by super.validatePipe() below                    
                </comment>
                <comment line="488">
                    install the solid pipes when AA and XOR are both enabled                    
                </comment>
                <comment line="493">
                    other cases handled by super.validatePipe() below                    
                </comment>
                <comment line="507">
                    Note that we use the transforming pipe here because it                    
                </comment>
                <comment line="508">
                    will examine the shape and possibly perform an optimized                    
                </comment>
                <comment line="509">
                    operation if it can be simplified.  The simplifications                    
                </comment>
                <comment line="510">
                    will be valid for all STROKE and TRANSFORM types.                    
                </comment>
                <comment line="518">
                    install the text pipe based on our earlier decision                    
                </comment>
                <comment line="521">
                    always override the image pipe with the specialized OGL pipe                    
                </comment>
                <declaration name="textpipe" type="TextPipe" line="420"/>
                <declaration name="validated" type="boolean" line="421"/>
                <scope line="443"/>
                <scope line="445"/>
                <declaration name="txPipe" type="PixelToParallelogramConverter" line="453"/>
                <declaration name="nonTxPipe" type="OGLRenderer" line="454"/>
                <scope line="456">
                    <scope line="457">
                        <scope line="458"/>
                    </scope>
                    <scope line="462">
                        <scope line="463"/>
                    </scope>
                </scope>
                <scope line="469">
                    <scope line="470">
                        <scope line="474">
                            <scope line="475"/>
                            <declaration name="aaConverter" type="PixelToParallelogramConverter" line="479"/>
                        </scope>
                        <scope line="487"/>
                    </scope>
                </scope>
                <scope line="496">
                    <scope line="497"/>
                    <scope line="500"/>
                    <scope line="503"/>
                </scope>
                <scope line="512">
                    <scope line="513"/>
                </scope>
            </method>
            <method name="getMaskFill" type="MaskFill" line="526">
                <params>
                    <param name="sg2d" type="SunGraphics2D"/>
                </params>
                <comment line="528">
                    We can only accelerate non-Color MaskFill operations if
                     all of the following conditions hold true:
                       - there is an implementation for the given paintState
                       - the current Paint can be accelerated for this destination
                       - multitexturing is available (since we need to modulate
                         the alpha mask texture with the paint texture)
                    
                     In all other cases, we return null, in which case the
                     validation code will choose a more general software-based loop.                    
                </comment>
                <scope line="527">
                    <scope line="541"/>
                </scope>
            </method>
            <method name="copyArea" type="boolean" line="550">
                <params>
                    <param name="sg2d" type="SunGraphics2D"/>
                    <param name="x" type="int"/>
                    <param name="y" type="int"/>
                    <param name="w" type="int"/>
                    <param name="h" type="int"/>
                    <param name="dx" type="int"/>
                    <param name="dy" type="int"/>
                </params>
                <scope line="553"/>
            </method>
            <method name="flush" type="void" line="564">
                <comment line="569">
                    make sure we have a current context before                    
                </comment>
                <comment line="570">
                    disposing the native resources (e.g. texture object)                    
                </comment>
                <comment line="578">
                    this call is expected to complete synchronously, so flush now                    
                </comment>
                <declaration name="rq" type="OGLRenderQueue" line="566"/>
                <scope line="568">
                    <declaration name="buf" type="RenderBuffer" line="573"/>
                </scope>
                <scope line="580"/>
            </method>
            <javadoc line="585">
                Disposes the native resources associated with the given OGLSurfaceData
                  (referenced by the pData parameter).  This method is invoked from
                  the native Dispose() method from the Disposer thread when the
                  Java-level OGLSurfaceData object is about to go away.  Note that we
                  also pass a reference to the native GLX/WGLGraphicsConfigInfo
                  (pConfigInfo) for the purposes of making a context current.                
            </javadoc>
            <method name="dispose" type="void" line="593">
                <params>
                    <param name="pData" type="long"/>
                    <param name="pConfigInfo" type="long"/>
                </params>
                <comment line="597">
                    make sure we have a current context before                    
                </comment>
                <comment line="598">
                    disposing the native resources (e.g. texture object)                    
                </comment>
                <comment line="606">
                    this call is expected to complete synchronously, so flush now                    
                </comment>
                <declaration name="rq" type="OGLRenderQueue" line="594"/>
                <scope line="596">
                    <declaration name="buf" type="RenderBuffer" line="601"/>
                </scope>
                <scope line="608"/>
            </method>
            <method name="swapBuffers" type="void" line="613">
                <params>
                    <param name="window" type="long"/>
                </params>
                <declaration name="rq" type="OGLRenderQueue" line="614"/>
                <scope line="616">
                    <declaration name="buf" type="RenderBuffer" line="617"/>
                </scope>
                <scope line="622"/>
            </method>
            <javadoc line="627">
                Returns true if OpenGL textures can have non-power-of-two dimensions
                  when using the basic GL_TEXTURE_2D target.                
            </javadoc>
            <method name="isTexNonPow2Available" type="boolean" line="631"/>
            <javadoc line="635">
                Returns true if OpenGL textures can have non-power-of-two dimensions
                  when using the GL_TEXTURE_RECTANGLE_ARB target (only available when the
                  GL_ARB_texture_rectangle extension is present).                
            </javadoc>
            <method name="isTexRectAvailable" type="boolean" line="640"/>
            <method name="getNativeBounds" type="Rectangle" line="644">
                <declaration name="rq" type="OGLRenderQueue" line="645"/>
                <scope line="647"/>
                <scope line="649"/>
            </method>
        </class>
    </source>