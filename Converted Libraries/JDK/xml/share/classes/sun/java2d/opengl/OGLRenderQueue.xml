<?xml version="1.0" encoding="UTF-8"?>
    <source package="sun.java2d.opengl">
        <import package="sun.java2d.pipe.RenderBuffer"/>
        <import package="sun.java2d.pipe.RenderQueue"/>
        <import package="sun.java2d.pipe.BufferedOpCodes"/>
        <class name="OGLRenderQueue" line="32">
            <extends class="RenderQueue"/>
            <javadoc line="32">
                OGL-specific implementation of RenderQueue.  This class provides a
                  single (daemon) thread that is responsible for periodically flushing
                  the queue, thus ensuring that only one thread communicates with the native
                  OpenGL libraries for the entire process.                
            </javadoc>
            <declaration name="theInstance" type="OGLRenderQueue" line="40"/>
            <declaration name="flusher" type="QueueFlusher" line="41"/>
            <method name="OGLRenderQueue" type="constructor" line="43"/>
            <javadoc line="47">
                Returns the single OGLRenderQueue instance.  If it has not yet been
                  initialized, this method will first construct the single instance
                  before returning it.                
            </javadoc>
            <method name="getInstance" type="OGLRenderQueue" line="52">
                <scope line="53"/>
            </method>
            <javadoc line="59">
                Flushes the single OGLRenderQueue instance synchronously.  If an
                  OGLRenderQueue has not yet been instantiated, this method is a no-op.
                  This method is useful in the case of Toolkit.sync(), in which we want
                  to flush the OGL pipeline, but only if the OGL pipeline is currently
                  enabled.  Since this class has few external dependencies, callers need
                  not be concerned that calling this method will trigger initialization
                  of the OGL pipeline and related classes.                
            </javadoc>
            <method name="sync" type="void" line="68">
                <scope line="69">
                    <scope line="71"/>
                    <scope line="75"/>
                </scope>
            </method>
            <javadoc line="81">
                Disposes the native memory associated with the given native
                  graphics config info pointer on the single queue flushing thread.                
            </javadoc>
            <method name="disposeGraphicsConfig" type="void" line="85">
                <params>
                    <param name="pConfigInfo" type="long"/>
                </params>
                <comment line="90">
                    make sure we make the context associated with the given
                     GraphicsConfig current before disposing the native resources                    
                </comment>
                <comment line="99">
                    this call is expected to complete synchronously, so flush now                    
                </comment>
                <declaration name="rq" type="OGLRenderQueue" line="86"/>
                <scope line="88">
                    <declaration name="buf" type="RenderBuffer" line="93"/>
                </scope>
                <scope line="100"/>
            </method>
            <javadoc line="105">
                Returns true if the current thread is the OGL QueueFlusher thread.                
            </javadoc>
            <method name="isQueueFlusherThread" type="boolean" line="108"/>
            <method name="flushNow" type="void" line="112">
                <comment line="114">
                    assert lock.isHeldByCurrentThread();                    
                </comment>
                <scope line="114"/>
                <scope line="116"/>
            </method>
            <method name="flushAndInvokeNow" type="void" line="122">
                <params>
                    <param name="r" type="Runnable"/>
                </params>
                <comment line="124">
                    assert lock.isHeldByCurrentThread();                    
                </comment>
                <scope line="124"/>
                <scope line="126"/>
            </method>
            <method name="flushBuffer" type="void" line="132"/>
            <method name="flushBuffer" type="void" line="134">
                <comment line="136">
                    assert lock.isHeldByCurrentThread();                    
                </comment>
                <comment line="139">
                    process the queue                    
                </comment>
                <comment line="142">
                    reset the buffer position                    
                </comment>
                <comment line="144">
                    clear the set of references, since we no longer need them                    
                </comment>
                <declaration name="limit" type="int" line="136"/>
                <scope line="137"/>
            </method>
            <class name="QueueFlusher" line="147">
                <extends class="Thread"/>
                <declaration name="needsFlush" type="boolean" line="148"/>
                <declaration name="task" type="Runnable" line="149"/>
                <declaration name="error" type="Error" line="150"/>
                <method name="QueueFlusher" type="constructor" line="152"/>
                <method name="flushNow" type="void" line="159">
                    <comment line="161">
                        wake up the flusher                        
                    </comment>
                    <comment line="165">
                        wait for flush to complete                        
                    </comment>
                    <comment line="173">
                        re-throw any error that may have occurred during the flush                        
                    </comment>
                    <scope line="165">
                        <scope line="166"/>
                        <scope line="168"/>
                    </scope>
                    <scope line="173"/>
                </method>
                <method name="flushAndInvokeNow" type="void" line="178">
                    <params>
                        <param name="task" type="Runnable"/>
                    </params>
                </method>
                <method name="run" type="void" line="183">
                    <comment line="190">
                        Wait until we&apos;re woken up with a flushNow() call,
                         or the timeout period elapses (so that we can
                         flush the queue periodically).                        
                    </comment>
                    <comment line="196">
                        We will automatically flush the queue if the
                         following conditions apply:
                           - the wait() timed out
                           - we can lock the queue (without blocking)
                           - there is something in the queue to flush
                         Otherwise, just continue (we&apos;ll flush eventually).                        
                    </comment>
                    <comment line="215">
                        reset the throwable state                        
                    </comment>
                    <comment line="217">
                        flush the buffer now                        
                    </comment>
                    <comment line="219">
                        if there&apos;s a task, invoke that now as well                        
                    </comment>
                    <comment line="233">
                        allow the waiting thread to continue                        
                    </comment>
                    <declaration name="timedOut" type="boolean" line="184"/>
                    <scope line="185">
                        <scope line="186">
                            <scope line="187">
                                <scope line="203">
                                    <scope line="204"/>
                                    <scope line="206"/>
                                </scope>
                            </scope>
                            <scope line="210"/>
                        </scope>
                        <scope line="213">
                            <scope line="219"/>
                        </scope>
                        <scope line="222"/>
                        <scope line="224"/>
                        <scope line="227">
                            <scope line="228"/>
                        </scope>
                    </scope>
                </method>
            </class>
        </class>
    </source>