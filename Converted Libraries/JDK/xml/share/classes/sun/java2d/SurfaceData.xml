<?xml version="1.0" encoding="UTF-8"?>
    <source package="sun.java2d">
        <import package="java.awt.Color"/>
        <import package="java.awt.Rectangle"/>
        <import package="java.awt.Transparency"/>
        <import package="java.awt.GraphicsConfiguration"/>
        <import package="java.awt.Image"/>
        <import package="java.awt.image.ColorModel"/>
        <import package="java.awt.image.IndexColorModel"/>
        <import package="java.awt.image.Raster"/>
        <import package="sun.java2d.loops.RenderCache"/>
        <import package="sun.java2d.loops.RenderLoops"/>
        <import package="sun.java2d.loops.CompositeType"/>
        <import package="sun.java2d.loops.SurfaceType"/>
        <import package="sun.java2d.loops.MaskFill"/>
        <import package="sun.java2d.loops.DrawLine"/>
        <import package="sun.java2d.loops.FillRect"/>
        <import package="sun.java2d.loops.DrawRect"/>
        <import package="sun.java2d.loops.DrawPolygons"/>
        <import package="sun.java2d.loops.DrawPath"/>
        <import package="sun.java2d.loops.FillPath"/>
        <import package="sun.java2d.loops.FillSpans"/>
        <import package="sun.java2d.loops.FillParallelogram"/>
        <import package="sun.java2d.loops.DrawParallelogram"/>
        <import package="sun.java2d.loops.FontInfo"/>
        <import package="sun.java2d.loops.DrawGlyphList"/>
        <import package="sun.java2d.loops.DrawGlyphListAA"/>
        <import package="sun.java2d.loops.DrawGlyphListLCD"/>
        <import package="sun.java2d.pipe.LoopPipe"/>
        <import package="sun.java2d.pipe.ShapeDrawPipe"/>
        <import package="sun.java2d.pipe.ParallelogramPipe"/>
        <import package="sun.java2d.pipe.CompositePipe"/>
        <import package="sun.java2d.pipe.GeneralCompositePipe"/>
        <import package="sun.java2d.pipe.SpanClipRenderer"/>
        <import package="sun.java2d.pipe.SpanShapeRenderer"/>
        <import package="sun.java2d.pipe.AAShapePipe"/>
        <import package="sun.java2d.pipe.AlphaPaintPipe"/>
        <import package="sun.java2d.pipe.AlphaColorPipe"/>
        <import package="sun.java2d.pipe.PixelToShapeConverter"/>
        <import package="sun.java2d.pipe.PixelToParallelogramConverter"/>
        <import package="sun.java2d.pipe.TextPipe"/>
        <import package="sun.java2d.pipe.TextRenderer"/>
        <import package="sun.java2d.pipe.AATextRenderer"/>
        <import package="sun.java2d.pipe.LCDTextRenderer"/>
        <import package="sun.java2d.pipe.SolidTextRenderer"/>
        <import package="sun.java2d.pipe.OutlineTextRenderer"/>
        <import package="sun.java2d.pipe.DrawImagePipe"/>
        <import package="sun.java2d.pipe.DrawImage"/>
        <import package="sun.awt.SunHints"/>
        <import package="sun.awt.image.SurfaceManager"/>
        <import package="sun.java2d.pipe.LoopBasedPipe"/>
        <class name="SurfaceData" line="79">
            <comment line="107">
                = false;                
            </comment>
            <comment line="407">
                Utility subclass to add the LoopBasedPipe tagging interface                
            </comment>
            <comment line="417">
                Utility subclass to add the LoopBasedPipe tagging interface                
            </comment>
            <comment line="496">
                                
            </comment>
            <comment line="731">
                Return the text pipe to be used based on the graphics AA hint setting,
                 and the rest of the graphics state is compatible with these loops.
                 If the text AA hint is &quot;DEFAULT&quot;, then the AA graphics hint requests
                 the AA text renderer, else it requests the B&amp;W text renderer.                
            </comment>
            <implements interface="Transparency"/>
            <implements interface="DisposerTarget"/>
            <implements interface="StateTrackable"/>
            <implements interface="Surface"/>
            <javadoc line="79">
                This class provides various pieces of information relevant to a
                  particular drawing surface.  The information obtained from this
                  object describes the pixels of a particular instance of a drawing
                  surface and can only be shared among the various graphics objects
                  that target the same BufferedImage or the same screen Component.
                  &lt;p&gt;
                  Each SurfaceData object holds a StateTrackableDelegate object
                  which tracks both changes to the content of the pixels of this
                  surface and changes to the overall state of the pixels - such
                  as becoming invalid or losing the surface.  The delegate is
                  marked &quot;dirty&quot; whenever the setSurfaceLost() or invalidate()
                  methods are called and should also be marked &quot;dirty&quot; by the
                  rendering pipelines whenever they modify the pixels of this
                  SurfaceData.
                  &lt;p&gt;
                  If you get a StateTracker from a SurfaceData and it reports
                  that it is still &quot;current&quot;, then you can trust that the pixels
                  have not changed and that the SurfaceData is still valid and
                  has not lost its underlying storage (surfaceLost) since you
                  retrieved the tracker.                
            </javadoc>
            <declaration name="pData" type="long" line="104"/>
            <declaration name="valid" type="boolean" line="105"/>
            <declaration name="surfaceLost" type="boolean" line="106"/>
            <declaration name="surfaceType" type="SurfaceType" line="107"/>
            <declaration name="colorModel" type="ColorModel" line="108"/>
            <declaration name="disposerReferent" type="Object" line="110"/>
            <method name="initIDs" type="void" line="112"/>
            <declaration name="blitProxyKey" type="Object" line="114"/>
            <declaration name="stateDelegate" type="StateTrackableDelegate" line="115"/>
            <scope line="117"/>
            <method name="SurfaceData" type="constructor" line="121">
                <params>
                    <param name="surfaceType" type="SurfaceType"/>
                    <param name="cm" type="ColorModel"/>
                </params>
            </method>
            <method name="SurfaceData" type="constructor" line="125">
                <params>
                    <param name="state" type="State"/>
                    <param name="surfaceType" type="SurfaceType"/>
                    <param name="cm" type="ColorModel"/>
                </params>
            </method>
            <method name="SurfaceData" type="constructor" line="131">
                <params>
                    <param name="trackable" type="StateTrackableDelegate"/>
                    <param name="surfaceType" type="SurfaceType"/>
                    <param name="cm" type="ColorModel"/>
                </params>
            </method>
            <method name="SurfaceData" type="constructor" line="138">
                <params>
                    <param name="state" type="State"/>
                </params>
            </method>
            <javadoc line="143">
                Subclasses can set a &quot;blit proxy key&quot; which will be used
                  along with the SurfaceManager.getCacheData() mechanism to
                  store acceleration-compatible cached copies of source images.
                  This key is a &quot;tag&quot; used to identify which cached copies
                  are compatible with this destination SurfaceData.
                  The getSourceSurfaceData() method uses this key to manage
                  cached copies of a source image as described below.
                  &lt;p&gt;
                  The Object used as this key should be as unique as it needs
                  to be to ensure that multiple acceleratible destinations can
                  each store their cached copies separately under different keys
                  without interfering with each other or getting back the wrong
                  cached copy.
                  &lt;p&gt;
                  Many acceleratable SurfaceData objects can use their own
                  GraphicsConfiguration as their proxy key as the GC object will
                  typically be unique to a given screen and pixel format, but
                  other rendering destinations may have more or less stringent
                  sharing requirements.  For instance, X11 pixmaps can be
                  shared on a given screen by any GraphicsConfiguration that
                  has the same depth and SurfaceType.  Multiple such GCs with
                  the same depth and SurfaceType can exist per screen so storing
                  a different cached proxy for each would be a waste.  One can
                  imagine platforms where a single cached copy can be created
                  and shared across all screens and pixel formats - such
                  implementations could use a single heavily shared key Object.                
            </javadoc>
            <method name="setBlitProxyKey" type="void" line="171">
                <params>
                    <param name="key" type="Object"/>
                </params>
                <comment line="173">
                    Caching is effectively disabled if we never have a proxy key
                     since the getSourceSurfaceData() method only does caching
                     if the key is not null.                    
                </comment>
                <scope line="175"/>
            </method>
            <javadoc line="180">
                This method is called on a destination SurfaceData to choose
                  the best SurfaceData from a source Image for an imaging
                  operation, with help from its SurfaceManager.
                  The method may determine that the default SurfaceData was
                  really the best choice in the first place, or it may decide
                  to use a cached surface.  Some general decisions about whether
                  acceleration is enabled are made by this method, but any
                  decision based on the type of the source image is made in
                  the makeProxyFor method below when it comes up with the
                  appropriate SurfaceDataProxy instance.
                  The parameters describe the type of imaging operation being performed.
                  &lt;p&gt;
                  If a blitProxyKey was supplied by the subclass then it is
                  used to potentially override the choice of source SurfaceData.
                  The outline of this process is:
                  &lt;ol&gt;
                  &lt;li&gt; Image pipeline asks destSD to find an appropriate
                  srcSD for a given source Image object.
                  &lt;li&gt; destSD gets the SurfaceManager of the source Image
                  and first retrieves the default SD from it using
                  getPrimarySurfaceData()
                  &lt;li&gt; destSD uses its &quot;blit proxy key&quot; (if set) to look for
                  some cached data stored in the source SurfaceManager
                  &lt;li&gt; If the cached data is null then makeProxyFor() is used
                  to create some cached data which is stored back in the
                  source SurfaceManager under the same key for future uses.
                  &lt;li&gt; The cached data will be a SurfaceDataProxy object.
                  &lt;li&gt; The SurfaceDataProxy object is then consulted to
                  return a replacement SurfaceData object (typically
                  a cached copy if appropriate, or the original if not).
                  &lt;/ol&gt;                
            </javadoc>
            <method name="getSourceSurfaceData" type="SurfaceData" line="217">
                <params>
                    <param name="img" type="Image"/>
                    <param name="txtype" type="int"/>
                    <param name="comp" type="CompositeType"/>
                    <param name="bgColor" type="Color"/>
                </params>
                <declaration name="srcMgr" type="SurfaceManager" line="218"/>
                <declaration name="srcData" type="SurfaceData" line="219"/>
                <scope line="222">
                    <declaration name="sdp" type="SurfaceDataProxy" line="223"/>
                    <scope line="225">
                        <scope line="226"/>
                        <scope line="228"/>
                    </scope>
                </scope>
            </method>
            <javadoc line="238">
                This method is called on a destination SurfaceData to choose
                  a proper SurfaceDataProxy subclass for a source SurfaceData
                  to use to control when and with what surface to override a
                  given image operation.  The argument is the default SurfaceData
                  for the source Image.
                  &lt;p&gt;
                  The type of the return object is chosen based on the
                  acceleration capabilities of this SurfaceData and the
                  type of the given source SurfaceData object.
                  &lt;p&gt;
                  In some cases the original SurfaceData will always be the
                  best choice to use to blit to this SurfaceData.  This can
                  happen if the source image is a hardware surface of the
                  same type as this one and so acceleration will happen without
                  any caching.  It may also be the case that the source image
                  can never be accelerated on this SurfaceData - for example
                  because it is translucent and there are no accelerated
                  translucent image ops for this surface.
                  &lt;p&gt;
                  In those cases there is a special SurfaceDataProxy.UNCACHED
                  instance that represents a NOP for caching purposes - it
                  always returns the original sourceSD object as the replacement
                  copy so no caching is ever performed.                
            </javadoc>
            <method name="makeProxyFor" type="SurfaceDataProxy" line="263">
                <params>
                    <param name="srcData" type="SurfaceData"/>
                </params>
            </method>
            <javadoc line="267">
                Extracts the SurfaceManager from the given Image, and then
                  returns the SurfaceData object that would best be suited as the
                  destination surface in some rendering operation.                
            </javadoc>
            <method name="getPrimarySurfaceData" type="SurfaceData" line="272">
                <params>
                    <param name="img" type="Image"/>
                </params>
                <declaration name="sMgr" type="SurfaceManager" line="273"/>
            </method>
            <javadoc line="277">
                Restores the contents of the given Image and then returns the new
                  SurfaceData object in use by the Image&apos;s SurfaceManager.                
            </javadoc>
            <method name="restoreContents" type="SurfaceData" line="281">
                <params>
                    <param name="img" type="Image"/>
                </params>
                <declaration name="sMgr" type="SurfaceManager" line="282"/>
            </method>
            <method name="getState" type="State" line="286"/>
            <method name="getStateTracker" type="StateTracker" line="290"/>
            <javadoc line="294">
                Marks this surface as dirty.                
            </javadoc>
            <method name="markDirty" type="void" line="297"/>
            <javadoc line="301">
                Sets the value of the surfaceLost variable, which indicates whether
                  something has happened to the rendering surface such that it needs
                  to be restored and re-rendered.                
            </javadoc>
            <method name="setSurfaceLost" type="void" line="306">
                <params>
                    <param name="lost" type="boolean"/>
                </params>
            </method>
            <method name="isSurfaceLost" type="boolean" line="311"/>
            <javadoc line="315">
                Returns a boolean indicating whether or not this SurfaceData is valid.                
            </javadoc>
            <method name="isValid" type="boolean" line="318"/>
            <method name="getDisposerReferent" type="Object" line="322"/>
            <method name="getNativeOps" type="long" line="326"/>
            <javadoc line="330">
                Sets this SurfaceData object to the invalid state.  All Graphics
                  objects must get a new SurfaceData object via the refresh method
                  and revalidate their pipelines before continuing.                
            </javadoc>
            <method name="invalidate" type="void" line="335"/>
            <method name="getReplacement" type="SurfaceData" line="340"/>
            <javadoc line="340">
                Certain changes in the configuration of a surface require the
                  invalidation of existing associated SurfaceData objects and
                  the creation of brand new ones.  These changes include size,
                  ColorModel, or SurfaceType.  Existing Graphics objects
                  which are directed at such surfaces, however, must continue
                  to render to them even after the change occurs underneath
                  the covers.  The getReplacement() method is called from
                  SunGraphics2D.revalidateAll() when the associated SurfaceData
                  is found to be invalid so that a Graphics object can continue
                  to render to the surface in its new configuration.
                  Such changes only tend to happen to window based surfaces since
                  most image based surfaces never change size or pixel format.
                  Even VolatileImage objects never change size and they only
                  change their pixel format when manually validated against a
                  new GraphicsConfiguration, at which point old Graphics objects
                  are no longer expected to render to them after the validation
                  step.  Thus, only window based surfaces really need to deal
                  with this form of replacement.                
            </javadoc>
            <declaration name="colorPrimitives" type="LoopPipe" line="363"/>
            <declaration name="outlineTextRenderer" type="TextPipe" line="365"/>
            <declaration name="solidTextRenderer" type="TextPipe" line="366"/>
            <declaration name="aaTextRenderer" type="TextPipe" line="367"/>
            <declaration name="lcdTextRenderer" type="TextPipe" line="368"/>
            <declaration name="colorPipe" type="AlphaColorPipe" line="370"/>
            <declaration name="colorViaShape" type="PixelToShapeConverter" line="371"/>
            <declaration name="colorViaPgram" type="PixelToParallelogramConverter" line="372"/>
            <declaration name="colorText" type="TextPipe" line="373"/>
            <declaration name="clipColorPipe" type="CompositePipe" line="374"/>
            <declaration name="clipColorText" type="TextPipe" line="375"/>
            <declaration name="AAColorShape" type="AAShapePipe" line="376"/>
            <declaration name="AAColorViaShape" type="PixelToParallelogramConverter" line="377"/>
            <declaration name="AAColorViaPgram" type="PixelToParallelogramConverter" line="378"/>
            <declaration name="AAClipColorShape" type="AAShapePipe" line="379"/>
            <declaration name="AAClipColorViaShape" type="PixelToParallelogramConverter" line="380"/>
            <declaration name="paintPipe" type="CompositePipe" line="382"/>
            <declaration name="paintShape" type="SpanShapeRenderer" line="383"/>
            <declaration name="paintViaShape" type="PixelToShapeConverter" line="384"/>
            <declaration name="paintText" type="TextPipe" line="385"/>
            <declaration name="clipPaintPipe" type="CompositePipe" line="386"/>
            <declaration name="clipPaintText" type="TextPipe" line="387"/>
            <declaration name="AAPaintShape" type="AAShapePipe" line="388"/>
            <declaration name="AAPaintViaShape" type="PixelToParallelogramConverter" line="389"/>
            <declaration name="AAClipPaintShape" type="AAShapePipe" line="390"/>
            <declaration name="AAClipPaintViaShape" type="PixelToParallelogramConverter" line="391"/>
            <declaration name="compPipe" type="CompositePipe" line="393"/>
            <declaration name="compShape" type="SpanShapeRenderer" line="394"/>
            <declaration name="compViaShape" type="PixelToShapeConverter" line="395"/>
            <declaration name="compText" type="TextPipe" line="396"/>
            <declaration name="clipCompPipe" type="CompositePipe" line="397"/>
            <declaration name="clipCompText" type="TextPipe" line="398"/>
            <declaration name="AACompShape" type="AAShapePipe" line="399"/>
            <declaration name="AACompViaShape" type="PixelToParallelogramConverter" line="400"/>
            <declaration name="AAClipCompShape" type="AAShapePipe" line="401"/>
            <declaration name="AAClipCompViaShape" type="PixelToParallelogramConverter" line="402"/>
            <declaration name="imagepipe" type="DrawImagePipe" line="404"/>
            <class name="PixelToShapeLoopConverter" line="407">
                <extends class="PixelToShapeConverter"/>
                <implements interface="LoopBasedPipe"/>
                <method name="PixelToShapeLoopConverter" type="constructor" line="411">
                    <params>
                        <param name="pipe" type="ShapeDrawPipe"/>
                    </params>
                </method>
            </class>
            <class name="PixelToPgramLoopConverter" line="417">
                <extends class="PixelToParallelogramConverter"/>
                <implements interface="LoopBasedPipe"/>
                <method name="PixelToPgramLoopConverter" type="constructor" line="426">
                    <params>
                        <param name="shapepipe" type="ShapeDrawPipe"/>
                        <param name="pgrampipe" type="ParallelogramPipe"/>
                        <param name="minPenSize" type="double"/>
                        <param name="normPosition" type="double"/>
                        <param name="adjustfill" type="boolean"/>
                    </params>
                </method>
            </class>
            <method name="makeConverter" type="PixelToParallelogramConverter" line="434">
                <params>
                    <param name="renderer" type="AAShapePipe"/>
                    <param name="pgrampipe" type="ParallelogramPipe"/>
                </params>
            </method>
            <method name="makeConverter" type="PixelToParallelogramConverter" line="443">
                <params>
                    <param name="renderer" type="AAShapePipe"/>
                </params>
            </method>
            <scope line="447"/>
            <declaration name="LOOP_UNKNOWN" type="int" line="496"/>
            <declaration name="LOOP_FOUND" type="int" line="497"/>
            <declaration name="LOOP_NOTFOUND" type="int" line="498"/>
            <declaration name="haveLCDLoop" type="int" line="499"/>
            <declaration name="havePgramXORLoop" type="int" line="500"/>
            <declaration name="havePgramSolidLoop" type="int" line="501"/>
            <method name="canRenderLCDText" type="boolean" line="503">
                <params>
                    <param name="sg2d" type="SunGraphics2D"/>
                </params>
                <comment line="505">
                    For now the answer can only be true in the following cases:                    
                </comment>
                <comment line="520">
                                        
                </comment>
                <scope line="509">
                    <scope line="510">
                        <declaration name="loop" type="DrawGlyphListLCD" line="511"/>
                    </scope>
                </scope>
            </method>
            <method name="canRenderParallelograms" type="boolean" line="522">
                <params>
                    <param name="sg2d" type="SunGraphics2D"/>
                </params>
                <scope line="523">
                    <scope line="524">
                        <scope line="525">
                            <declaration name="loop" type="FillParallelogram" line="526"/>
                        </scope>
                    </scope>
                    <scope line="537">
                        <scope line="538">
                            <declaration name="loop" type="FillParallelogram" line="539"/>
                        </scope>
                    </scope>
                </scope>
            </method>
            <method name="validatePipe" type="void" line="552">
                <params>
                    <param name="sg2d" type="SunGraphics2D"/>
                </params>
                <comment line="560">
                    REMIND: Ideally custom paint mode would use glyph
                     rendering as opposed to outline rendering but the
                     glyph paint rendering pipeline uses MaskBlit which
                     is not defined for XOR.  This means that text drawn
                     in XOR mode with a Color object is different than
                     text drawn in XOR mode with a Paint object.                    
                </comment>
                <comment line="571">
                    Note that we use the transforming pipe here because it
                     will examine the shape and possibly perform an optimized
                     operation if it can be simplified.  The simplifications
                     will be valid for all STROKE and TRANSFORM types.                    
                </comment>
                <comment line="583">
                    REMIND: We should not be changing text strategies
                     between outline and glyph rendering based upon the
                     presence of a complex clip as that could cause a
                     mismatch when drawing the same text both clipped
                     and unclipped on two separate rendering passes.
                     Unfortunately, all of the clipped glyph rendering
                     pipelines rely on the use of the MaskBlit operation
                     which is not defined for XOR.                    
                </comment>
                <comment line="606">
                    assert(sg2d.surfaceData == this);                    
                </comment>
                <comment line="633">
                    assert(sg2d.surfaceData == this);                    
                </comment>
                <comment line="653">
                                        
                </comment>
                <comment line="677">
                    assert(sg2d.surfaceData == this);                    
                </comment>
                <comment line="695">
                    Note that we use the transforming pipe here because it
                     will examine the shape and possibly perform an optimized
                     operation if it can be simplified.  The simplifications
                     will be valid for all STROKE and TRANSFORM types.                    
                </comment>
                <comment line="716">
                                        
                </comment>
                <comment line="717">
                    assert(sg2d.surfaceData == this);                    
                </comment>
                <comment line="720">
                    check for loops                    
                </comment>
                <scope line="554">
                    <scope line="555"/>
                    <scope line="566">
                        <declaration name="converter" type="PixelToShapeConverter" line="567"/>
                        <scope line="568"/>
                        <scope line="575"/>
                        <scope line="579"/>
                        <scope line="591">
                            <scope line="592"/>
                            <scope line="595">
                                <scope line="596"/>
                                <scope line="598"/>
                            </scope>
                        </scope>
                    </scope>
                </scope>
                <scope line="607">
                    <scope line="608">
                        <scope line="609"/>
                        <scope line="614"/>
                    </scope>
                    <scope line="620">
                        <scope line="624"/>
                        <scope line="626"/>
                    </scope>
                </scope>
                <scope line="630">
                    <scope line="633">
                        <scope line="634"/>
                        <scope line="639">
                            <declaration name="converter" type="PixelToParallelogramConverter" line="640"/>
                            <scope line="649"/>
                            <scope line="651"/>
                        </scope>
                    </scope>
                    <scope line="655">
                        <scope line="656"/>
                        <scope line="661"/>
                    </scope>
                </scope>
                <scope line="671">
                    <scope line="677">
                        <scope line="678"/>
                        <scope line="680"/>
                    </scope>
                    <scope line="683">
                        <scope line="684"/>
                        <scope line="686"/>
                    </scope>
                </scope>
                <scope line="690">
                    <declaration name="converter" type="PixelToShapeConverter" line="691"/>
                    <scope line="692"/>
                    <scope line="699"/>
                    <scope line="703"/>
                    <scope line="706">
                        <scope line="707"/>
                        <scope line="709"/>
                    </scope>
                </scope>
                <scope line="725"/>
            </method>
            <method name="getTextPipe" type="TextPipe" line="735">
                <params>
                    <param name="sg2d" type="SunGraphics2D"/>
                    <param name="aaHintIsOn" type="boolean"/>
                </params>
                <comment line="738">
                    Try to avoid calling getFontInfo() unless its needed to
                     resolve one of the new AA types.                    
                </comment>
                <comment line="767">
                    This should not be reached as the FontInfo will
                     always explicitly set its hint value. So whilst
                     this could be collapsed to returning say just
                     solidTextRenderer, or even removed, its left
                     here in case DEFAULT is ever passed in.                    
                </comment>
                <scope line="742"/>
                <scope line="744"/>
                <scope line="773"/>
                <scope line="775"/>
            </method>
            <method name="getPaintSurfaceType" type="SurfaceType" line="782">
                <params>
                    <param name="sg2d" type="SunGraphics2D"/>
                </params>
                <scope line="789"/>
                <scope line="791"/>
                <scope line="795"/>
                <scope line="797"/>
                <scope line="801"/>
                <scope line="803"/>
                <scope line="807"/>
                <scope line="809"/>
            </method>
            <method name="getFillCompositeType" type="CompositeType" line="818">
                <params>
                    <param name="sg2d" type="SunGraphics2D"/>
                </params>
                <declaration name="compType" type="CompositeType" line="819"/>
                <scope line="820">
                    <scope line="821"/>
                    <scope line="823"/>
                </scope>
            </method>
            <javadoc line="830">
                Returns a MaskFill object that can be used on this destination
                  with the source (paint) and composite types determined by the given
                  SunGraphics2D, or null if no such MaskFill object can be located.
                  Subclasses can override this method if they wish to filter other
                  attributes (such as the hardware capabilities of the destination
                  surface) before returning a specific MaskFill object.                
            </javadoc>
            <method name="getMaskFill" type="MaskFill" line="838">
                <params>
                    <param name="sg2d" type="SunGraphics2D"/>
                </params>
                <declaration name="src" type="SurfaceType" line="839"/>
                <declaration name="comp" type="CompositeType" line="840"/>
                <declaration name="dst" type="SurfaceType" line="841"/>
            </method>
            <declaration name="loopcache" type="RenderCache" line="845"/>
            <javadoc line="847">
                Return a RenderLoops object containing all of the basic
                  GraphicsPrimitive objects for rendering to the destination
                  surface with the current attributes of the given SunGraphics2D.                
            </javadoc>
            <method name="getRenderLoops" type="RenderLoops" line="852">
                <params>
                    <param name="sg2d" type="SunGraphics2D"/>
                </params>
                <declaration name="src" type="SurfaceType" line="853"/>
                <declaration name="comp" type="CompositeType" line="854"/>
                <declaration name="dst" type="SurfaceType" line="855"/>
                <declaration name="o" type="Object" line="857"/>
                <scope line="858"/>
                <declaration name="loops" type="RenderLoops" line="862"/>
            </method>
            <javadoc line="867">
                Construct and return a RenderLoops object containing all of
                  the basic GraphicsPrimitive objects for rendering to the
                  destination surface with the given source, destination, and
                  composite types.                
            </javadoc>
            <method name="makeRenderLoops" type="RenderLoops" line="876">
                <params>
                    <param name="src" type="SurfaceType"/>
                    <param name="comp" type="CompositeType"/>
                    <param name="dst" type="SurfaceType"/>
                </params>
                <comment line="891">
                    System.out.println(&quot;drawLine: &quot;+loops.drawLineLoop);
                    System.out.println(&quot;fillRect: &quot;+loops.fillRectLoop);
                    System.out.println(&quot;drawRect: &quot;+loops.drawRectLoop);
                    System.out.println(&quot;drawPolygons: &quot;+loops.drawPolygonsLoop);
                    System.out.println(&quot;fillSpans: &quot;+loops.fillSpansLoop);
                    System.out.println(&quot;drawGlyphList: &quot;+loops.drawGlyphListLoop);
                    System.out.println(&quot;drawGlyphListAA: &quot;+loops.drawGlyphListAALoop);
                    System.out.println(&quot;drawGlyphListLCD: &quot;+loops.drawGlyphListLCDLoop);                    
                </comment>
                <declaration name="loops" type="RenderLoops" line="877"/>
            </method>
            <method name="getDeviceConfiguration" type="GraphicsConfiguration" line="903"/>
            <javadoc line="903">
                Return the GraphicsConfiguration object that describes this
                  destination surface.                
            </javadoc>
            <javadoc line="909">
                Return the SurfaceType object that describes the destination
                  surface.                
            </javadoc>
            <method name="getSurfaceType" type="SurfaceType" line="913"/>
            <javadoc line="917">
                Return the ColorModel for the destination surface.                
            </javadoc>
            <method name="getColorModel" type="ColorModel" line="920"/>
            <javadoc line="924">
                Returns the type of this &lt;code&gt;Transparency&lt;/code&gt;.                
                <return>
                    the field type of this <code>Transparency</code>, which is
                      either OPAQUE, BITMASK or TRANSLUCENT.                    
                </return>
            </javadoc>
            <method name="getTransparency" type="int" line="929"/>
            <method name="getRaster" type="Raster" line="933"/>
            <javadoc line="933">
                Return a readable Raster which contains the pixels for the
                  specified rectangular region of the destination surface.
                  The coordinate origin of the returned Raster is the same as
                  the device space origin of the destination surface.
                  In some cases the returned Raster might also be writeable.
                  In most cases, the returned Raster might contain more pixels
                  than requested.                
                <see>
                    useTightBBoxes                    
                </see>
            </javadoc>
            <javadoc line="946">
                Does the pixel accessibility of the destination surface
                  suggest that rendering algorithms might want to take
                  extra time to calculate a more accurate bounding box for
                  the operation being performed?
                  The typical case when this will be true is when a copy of
                  the pixels has to be made when doing a getRaster.  The
                  fewer pixels copied, the faster the operation will go.                
                <see>
                    getRaster                    
                </see>
            </javadoc>
            <method name="useTightBBoxes" type="boolean" line="957">
                <comment line="959">
                    Note: The native equivalent would trigger on VISIBLE_TO_NATIVE
                     REMIND: This is not used - should be obsoleted maybe                    
                </comment>
            </method>
            <javadoc line="963">
                Returns the pixel data for the specified Argb value packed
                  into an integer for easy storage and conveyance.                
            </javadoc>
            <method name="pixelFor" type="int" line="967">
                <params>
                    <param name="rgb" type="int"/>
                </params>
            </method>
            <javadoc line="971">
                Returns the pixel data for the specified color packed into an
                  integer for easy storage and conveyance.
                  This method will use the getRGB() method of the Color object
                  and defer to the pixelFor(int rgb) method if not overridden.
                  For now this is a convenience function, but for cases where
                  the highest quality color conversion is requested, this method
                  should be overridden in those cases so that a more direct
                  conversion of the color to the destination color space
                  can be done using the additional information in the Color
                  object.                
            </javadoc>
            <method name="pixelFor" type="int" line="985">
                <params>
                    <param name="c" type="Color"/>
                </params>
            </method>
            <javadoc line="989">
                Returns the Argb representation for the specified integer value
                  which is packed in the format of the associated ColorModel.                
            </javadoc>
            <method name="rgbFor" type="int" line="993">
                <params>
                    <param name="pixel" type="int"/>
                </params>
            </method>
            <method name="getBounds" type="Rectangle" line="997"/>
            <javadoc line="997">
                Returns the bounds of the destination surface.                
            </javadoc>
            <declaration name="compPermission" type="java.security.Permission" line="1002"/>
            <javadoc line="1004">
                Performs Security Permissions checks to see if a Custom
                  Composite object should be allowed access to the pixels
                  of this surface.                
            </javadoc>
            <method name="checkCustomComposite" type="void" line="1009">
                <declaration name="sm" type="SecurityManager" line="1010"/>
                <scope line="1011">
                    <scope line="1012"/>
                </scope>
            </method>
            <method name="isOpaqueGray" type="boolean" line="1020"/>
            <javadoc line="1020">
                Fetches private field IndexColorModel.allgrayopaque
                  which is true when all palette entries in the color
                  model are gray and opaque.                
            </javadoc>
            <javadoc line="1027">
                For our purposes null and NullSurfaceData are the same as
                  they represent a disposed surface.                
            </javadoc>
            <method name="isNull" type="boolean" line="1031">
                <params>
                    <param name="sd" type="SurfaceData"/>
                </params>
                <scope line="1032"/>
            </method>
            <javadoc line="1038">
                Performs a copyarea within this surface.  Returns
                  false if there is no algorithm to perform the copyarea
                  given the current settings of the SunGraphics2D.                
            </javadoc>
            <method name="copyArea" type="boolean" line="1045">
                <params>
                    <param name="sg2d" type="SunGraphics2D"/>
                    <param name="x" type="int"/>
                    <param name="y" type="int"/>
                    <param name="w" type="int"/>
                    <param name="h" type="int"/>
                    <param name="dx" type="int"/>
                    <param name="dy" type="int"/>
                </params>
            </method>
            <javadoc line="1049">
                Synchronously releases resources associated with this surface.                
            </javadoc>
            <method name="flush" type="void" line="1052"/>
            <method name="getDestination" type="Object" line="1054"/>
            <javadoc line="1054">
                Returns destination associated with this SurfaceData.  This could be
                  either an Image or a Component; subclasses of SurfaceData are
                  responsible for returning the appropriate object.                
            </javadoc>
        </class>
    </source>