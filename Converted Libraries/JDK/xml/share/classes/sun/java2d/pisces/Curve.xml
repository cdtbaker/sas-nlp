<?xml version="1.0" encoding="UTF-8"?>
    <source package="sun.java2d.pisces">
        <import package="java.util.Iterator"/>
        <class name="Curve" line="30">
            <comment line="124">
                finds points where the first and second derivative are
                 perpendicular. This happens when g(t) = f&apos;(t)*f&apos;&apos;(t) == 0 (where
                 * is a dot product). Unfortunately, we have to solve a cubic.                
            </comment>
            <comment line="140">
                Tries to find the roots of the function ROC(t)-w in [0, 1). It uses
                 a variant of the false position algorithm to find the roots. False
                 position requires that 2 initial values x0,x1 be given, and that the
                 function must have opposite signs at those values. To find such
                 values, we need the local extrema of the ROC function, for which we
                 need the roots of its derivative; however, it&apos;s harder to find the
                 roots of the derivative in this case than it is to find the roots
                 of the original function. So, we find all points where this curve&apos;s
                 first and second derivative are perpendicular, and we pretend these
                 are our local extrema. There are at most 3 of these, so we will check
                 at most 4 sub-intervals of (0,1). ROC has asymptotes at inflection
                 points, so roc-w can have at least 6 roots. This shouldn&apos;t be a
                 problem for what we&apos;re trying to do (draw a nice looking curve).                
            </comment>
            <comment line="182">
                A slight modification of the false position algorithm on wikipedia.
                 This only works for the ROCsq-x functions. It might be nice to have
                 the function as an argument, but that would be awkward in java6.
                 TODO: It is something to consider for java8 (or whenever lambda
                 expressions make it into the language), depending on how closures
                 and turn out. Same goes for the newton&apos;s method
                 algorithm in Helpers.java                
            </comment>
            <comment line="228">
                returns the radius of curvature squared at t of this curve
                 see http:en.wikipedia.org/wiki/Radius_of_curvature_(applications)                
            </comment>
            <comment line="242">
                curve to be broken should be in pts
                 this will change the contents of pts but not Ts
                 TODO: There&apos;s no reason for Ts to be an array. All we need is a sequence
                 of t values at which to subdivide. An array statisfies this condition,
                 but is unnecessarily restrictive. Ts should be an Iterator&lt;Float&gt; instead.
                 Doing this will also make dashing easier, since we could easily make
                 LengthIterator an Iterator&lt;Float&gt; and feed it to this function to simplify
                 the loop in Dasher.somethingTo.                
            </comment>
            <declaration name="ax" type="float" line="32"/>
            <declaration name="dax" type="float" line="33"/>
            <method name="Curve" type="constructor" line="35"/>
            <method name="set" type="void" line="38">
                <params>
                    <param name="points" type="float[]"/>
                    <param name="type" type="int"/>
                </params>
            </method>
            <method name="set" type="void" line="60">
                <params>
                    <param name="x1" type="float"/>
                    <param name="y1" type="float"/>
                    <param name="x2" type="float"/>
                    <param name="y2" type="float"/>
                    <param name="x3" type="float"/>
                    <param name="y3" type="float"/>
                    <param name="x4" type="float"/>
                    <param name="y4" type="float"/>
                </params>
            </method>
            <method name="set" type="void" line="76">
                <params>
                    <param name="x1" type="float"/>
                    <param name="y1" type="float"/>
                    <param name="x2" type="float"/>
                    <param name="y2" type="float"/>
                    <param name="x3" type="float"/>
                    <param name="y3" type="float"/>
                </params>
            </method>
            <method name="xat" type="float" line="89">
                <params>
                    <param name="t" type="float"/>
                </params>
            </method>
            <method name="yat" type="float" line="92">
                <params>
                    <param name="t" type="float"/>
                </params>
            </method>
            <method name="dxat" type="float" line="96">
                <params>
                    <param name="t" type="float"/>
                </params>
            </method>
            <method name="dyat" type="float" line="100">
                <params>
                    <param name="t" type="float"/>
                </params>
            </method>
            <method name="dxRoots" type="int" line="104">
                <params>
                    <param name="roots" type="float[]"/>
                    <param name="off" type="int"/>
                </params>
            </method>
            <method name="dyRoots" type="int" line="108">
                <params>
                    <param name="roots" type="float[]"/>
                    <param name="off" type="int"/>
                </params>
            </method>
            <method name="infPoints" type="int" line="112">
                <params>
                    <param name="pts" type="float[]"/>
                    <param name="off" type="int"/>
                </params>
                <comment line="114">
                    inflection point at t if -f&apos;(t)x*f&apos;&apos;(t)y + f&apos;(t)y*f&apos;&apos;(t)x == 0
                     Fortunately, this turns out to be quadratic, so there are at
                     most 2 inflection points.                    
                </comment>
                <declaration name="a" type="float" line="116"/>
                <declaration name="b" type="float" line="117"/>
                <declaration name="c" type="float" line="118"/>
            </method>
            <method name="perpendiculardfddf" type="int" line="126">
                <params>
                    <param name="pts" type="float[]"/>
                    <param name="off" type="int"/>
                </params>
                <comment line="130">
                    these are the coefficients of some multiple of g(t) (not g(t),
                     because the roots of a polynomial are not changed after multiplication
                     by a constant, and this way we save a few multiplications).                    
                </comment>
                <declaration name="a" type="float" line="132"/>
                <declaration name="b" type="float" line="133"/>
                <declaration name="c" type="float" line="134"/>
                <declaration name="d" type="float" line="135"/>
            </method>
            <method name="rootsOfROCMinusW" type="int" line="152">
                <params>
                    <param name="roots" type="float[]"/>
                    <param name="off" type="int"/>
                    <param name="w" type="float"/>
                    <param name="err" type="float"/>
                </params>
                <comment line="154">
                    no OOB exception, because by now off&lt;=6, and roots.length &gt;= 10                    
                </comment>
                <comment line="159">
                    always check interval end points                    
                </comment>
                <comment line="165">
                    have opposite signs                    
                </comment>
                <comment line="166">
                    (ROC(t)^2 == w^2) == (ROC(t) == w) is true because
                     ROC(t) &gt;= 0 for all t.                    
                </comment>
                <declaration name="ret" type="int" line="155"/>
                <declaration name="numPerpdfddf" type="int" line="156"/>
                <declaration name="t0" type="float" line="157"/>
                <scope line="160">
                    <declaration name="t1" type="float" line="161"/>
                    <scope line="162"/>
                    <scope line="164"/>
                </scope>
            </method>
            <method name="eliminateInf" type="float" line="176">
                <params>
                    <param name="x" type="float"/>
                </params>
            </method>
            <method name="falsePositionROCsqMinusX" type="float" line="190">
                <params>
                    <param name="x0" type="float"/>
                    <param name="x1" type="float"/>
                    <param name="x" type="float"/>
                    <param name="err" type="float"/>
                </params>
                <declaration name="iterLimit" type="int" line="191"/>
                <declaration name="side" type="int" line="192"/>
                <declaration name="t" type="float" line="193"/>
                <declaration name="s" type="float" line="194"/>
                <declaration name="r" type="float" line="195"/>
                <scope line="196">
                    <scope line="199">
                        <scope line="201"/>
                        <scope line="204"/>
                    </scope>
                    <scope line="207">
                        <scope line="209"/>
                        <scope line="212"/>
                    </scope>
                    <scope line="215"/>
                </scope>
            </method>
            <method name="sameSign" type="boolean" line="222">
                <params>
                    <param name="x" type="double"/>
                    <param name="y" type="double"/>
                </params>
                <comment line="224">
                    another way is to test if x*y &gt; 0. This is bad for small x, y.                    
                </comment>
            </method>
            <method name="ROCsq" type="float" line="229">
                <params>
                    <param name="t" type="float"/>
                </params>
                <comment line="231">
                    dx=xat(t) and dy=yat(t). These calls have been inlined for efficiency                    
                </comment>
                <declaration name="dx" type="float" line="231"/>
                <declaration name="dy" type="float" line="232"/>
                <declaration name="ddx" type="float" line="233"/>
                <declaration name="ddy" type="float" line="234"/>
                <declaration name="dx2dy2" type="float" line="235"/>
                <declaration name="ddx2ddy2" type="float" line="236"/>
                <declaration name="ddxdxddydy" type="float" line="237"/>
            </method>
            <method name="breakPtsAtTs" type="Iterator<Integer>" line="251">
                <params>
                    <param name="pts" type="float[]"/>
                    <param name="type" type="int"/>
                    <param name="Ts" type="float[]"/>
                    <param name="numTs" type="int"/>
                </params>
                <comment line="255">
                    these prevent object creation and destruction during autoboxing.
                     Because of this, the compiler should be able to completely
                     eliminate the boxing costs.                    
                </comment>
                <anonymous_class line="253">
                    <declaration name="i0" type="Integer" line="257"/>
                    <declaration name="itype" type="Integer" line="258"/>
                    <declaration name="nextCurveIdx" type="int" line="259"/>
                    <declaration name="curCurveOff" type="Integer" line="260"/>
                    <declaration name="prevT" type="float" line="261"/>
                    <method name="hasNext" type="boolean" line="263"/>
                    <method name="next" type="Integer" line="267">
                        <declaration name="ret" type="Integer" line="268"/>
                        <scope line="269">
                            <declaration name="curT" type="float" line="270"/>
                            <declaration name="splitT" type="float" line="271"/>
                        </scope>
                        <scope line="279"/>
                    </method>
                    <method name="remove" type="void" line="286"/>
                </anonymous_class>
            </method>
        </class>
    </source>