<?xml version="1.0" encoding="UTF-8"?>
    <source package="sun.java2d.pisces">
        <import package="java.util.Iterator"/>
        <class name="Curve" line="30">
            <comment line="124">
                finds points where the first and second derivative are                
            </comment>
            <comment line="125">
                perpendicular. This happens when g(t) = f&apos;(t)*f&apos;&apos;(t) == 0 (where                
            </comment>
            <comment line="126">
                * is a dot product). Unfortunately, we have to solve a cubic.                
            </comment>
            <comment line="140">
                Tries to find the roots of the function ROC(t)-w in [0, 1). It uses                
            </comment>
            <comment line="141">
                a variant of the false position algorithm to find the roots. False                
            </comment>
            <comment line="142">
                position requires that 2 initial values x0,x1 be given, and that the                
            </comment>
            <comment line="143">
                function must have opposite signs at those values. To find such                
            </comment>
            <comment line="144">
                values, we need the local extrema of the ROC function, for which we                
            </comment>
            <comment line="145">
                need the roots of its derivative; however, it&apos;s harder to find the                
            </comment>
            <comment line="146">
                roots of the derivative in this case than it is to find the roots                
            </comment>
            <comment line="147">
                of the original function. So, we find all points where this curve&apos;s                
            </comment>
            <comment line="148">
                first and second derivative are perpendicular, and we pretend these                
            </comment>
            <comment line="149">
                are our local extrema. There are at most 3 of these, so we will check                
            </comment>
            <comment line="150">
                at most 4 sub-intervals of (0,1). ROC has asymptotes at inflection                
            </comment>
            <comment line="151">
                points, so roc-w can have at least 6 roots. This shouldn&apos;t be a                
            </comment>
            <comment line="152">
                problem for what we&apos;re trying to do (draw a nice looking curve).                
            </comment>
            <comment line="182">
                A slight modification of the false position algorithm on wikipedia.                
            </comment>
            <comment line="183">
                This only works for the ROCsq-x functions. It might be nice to have                
            </comment>
            <comment line="184">
                the function as an argument, but that would be awkward in java6.                
            </comment>
            <comment line="185">
                TODO: It is something to consider for java8 (or whenever lambda                
            </comment>
            <comment line="186">
                expressions make it into the language), depending on how closures                
            </comment>
            <comment line="187">
                and turn out. Same goes for the newton&apos;s method                
            </comment>
            <comment line="188">
                algorithm in Helpers.java                
            </comment>
            <comment line="228">
                returns the radius of curvature squared at t of this curve                
            </comment>
            <comment line="229">
                see http://en.wikipedia.org/wiki/Radius_of_curvature_(applications)                
            </comment>
            <comment line="242">
                curve to be broken should be in pts                
            </comment>
            <comment line="243">
                this will change the contents of pts but not Ts                
            </comment>
            <comment line="244">
                TODO: There&apos;s no reason for Ts to be an array. All we need is a sequence                
            </comment>
            <comment line="245">
                of t values at which to subdivide. An array statisfies this condition,                
            </comment>
            <comment line="246">
                but is unnecessarily restrictive. Ts should be an Iterator&lt;Float&gt; instead.                
            </comment>
            <comment line="247">
                Doing this will also make dashing easier, since we could easily make                
            </comment>
            <comment line="248">
                LengthIterator an Iterator&lt;Float&gt; and feed it to this function to simplify                
            </comment>
            <comment line="249">
                the loop in Dasher.somethingTo.                
            </comment>
            <declaration name="ax" type="float" line="32"/>
            <declaration name="dax" type="float" line="33"/>
            <method name="Curve" type="constructor" line="35"/>
            <method name="set" type="void" line="38">
                <params>
                    <param name="points" type="float[]"/>
                    <param name="type" type="int"/>
                </params>
            </method>
            <method name="set" type="void" line="60">
                <params>
                    <param name="x1" type="float"/>
                    <param name="y1" type="float"/>
                    <param name="x2" type="float"/>
                    <param name="y2" type="float"/>
                    <param name="x3" type="float"/>
                    <param name="y3" type="float"/>
                    <param name="x4" type="float"/>
                    <param name="y4" type="float"/>
                </params>
            </method>
            <method name="set" type="void" line="76">
                <params>
                    <param name="x1" type="float"/>
                    <param name="y1" type="float"/>
                    <param name="x2" type="float"/>
                    <param name="y2" type="float"/>
                    <param name="x3" type="float"/>
                    <param name="y3" type="float"/>
                </params>
            </method>
            <method name="xat" type="float" line="89">
                <params>
                    <param name="t" type="float"/>
                </params>
            </method>
            <method name="yat" type="float" line="92">
                <params>
                    <param name="t" type="float"/>
                </params>
            </method>
            <method name="dxat" type="float" line="96">
                <params>
                    <param name="t" type="float"/>
                </params>
            </method>
            <method name="dyat" type="float" line="100">
                <params>
                    <param name="t" type="float"/>
                </params>
            </method>
            <method name="dxRoots" type="int" line="104">
                <params>
                    <param name="roots" type="float[]"/>
                    <param name="off" type="int"/>
                </params>
            </method>
            <method name="dyRoots" type="int" line="108">
                <params>
                    <param name="roots" type="float[]"/>
                    <param name="off" type="int"/>
                </params>
            </method>
            <method name="infPoints" type="int" line="112">
                <params>
                    <param name="pts" type="float[]"/>
                    <param name="off" type="int"/>
                </params>
                <comment line="113">
                    inflection point at t if -f&apos;(t)x*f&apos;&apos;(t)y + f&apos;(t)y*f&apos;&apos;(t)x == 0                    
                </comment>
                <comment line="114">
                    Fortunately, this turns out to be quadratic, so there are at                    
                </comment>
                <comment line="115">
                    most 2 inflection points.                    
                </comment>
                <declaration name="a" type="float" line="116"/>
                <declaration name="b" type="float" line="117"/>
                <declaration name="c" type="float" line="118"/>
            </method>
            <method name="perpendiculardfddf" type="int" line="126">
                <params>
                    <param name="pts" type="float[]"/>
                    <param name="off" type="int"/>
                </params>
                <comment line="129">
                    these are the coefficients of some multiple of g(t) (not g(t),                    
                </comment>
                <comment line="130">
                    because the roots of a polynomial are not changed after multiplication                    
                </comment>
                <comment line="131">
                    by a constant, and this way we save a few multiplications).                    
                </comment>
                <declaration name="a" type="float" line="132"/>
                <declaration name="b" type="float" line="133"/>
                <declaration name="c" type="float" line="134"/>
                <declaration name="d" type="float" line="135"/>
            </method>
            <method name="rootsOfROCMinusW" type="int" line="152">
                <params>
                    <param name="roots" type="float[]"/>
                    <param name="off" type="int"/>
                    <param name="w" type="float"/>
                    <param name="err" type="float"/>
                </params>
                <comment line="153">
                    no OOB exception, because by now off&lt;=6, and roots.length &gt;= 10                    
                </comment>
                <comment line="158">
                    always check interval end points                    
                </comment>
                <comment line="164">
                    have opposite signs                    
                </comment>
                <comment line="165">
                    (ROC(t)^2 == w^2) == (ROC(t) == w) is true because                    
                </comment>
                <comment line="166">
                    ROC(t) &gt;= 0 for all t.                    
                </comment>
                <declaration name="ret" type="int" line="155"/>
                <declaration name="numPerpdfddf" type="int" line="156"/>
                <declaration name="t0" type="float" line="157"/>
                <scope line="160">
                    <declaration name="t1" type="float" line="161"/>
                    <scope line="162"/>
                    <scope line="164"/>
                </scope>
            </method>
            <method name="eliminateInf" type="float" line="176">
                <params>
                    <param name="x" type="float"/>
                </params>
            </method>
            <method name="falsePositionROCsqMinusX" type="float" line="190">
                <params>
                    <param name="x0" type="float"/>
                    <param name="x1" type="float"/>
                    <param name="x" type="float"/>
                    <param name="err" type="float"/>
                </params>
                <declaration name="iterLimit" type="int" line="191"/>
                <declaration name="side" type="int" line="192"/>
                <declaration name="t" type="float" line="193"/>
                <declaration name="s" type="float" line="194"/>
                <declaration name="r" type="float" line="195"/>
                <scope line="196">
                    <scope line="199">
                        <scope line="201"/>
                        <scope line="204"/>
                    </scope>
                    <scope line="207">
                        <scope line="209"/>
                        <scope line="212"/>
                    </scope>
                    <scope line="215"/>
                </scope>
            </method>
            <method name="sameSign" type="boolean" line="222">
                <params>
                    <param name="x" type="double"/>
                    <param name="y" type="double"/>
                </params>
                <comment line="223">
                    another way is to test if x*y &gt; 0. This is bad for small x, y.                    
                </comment>
            </method>
            <method name="ROCsq" type="float" line="229">
                <params>
                    <param name="t" type="float"/>
                </params>
                <comment line="230">
                    dx=xat(t) and dy=yat(t). These calls have been inlined for efficiency                    
                </comment>
                <declaration name="dx" type="float" line="231"/>
                <declaration name="dy" type="float" line="232"/>
                <declaration name="ddx" type="float" line="233"/>
                <declaration name="ddy" type="float" line="234"/>
                <declaration name="dx2dy2" type="float" line="235"/>
                <declaration name="ddx2ddy2" type="float" line="236"/>
                <declaration name="ddxdxddydy" type="float" line="237"/>
            </method>
            <method name="breakPtsAtTs" type="Iterator<Integer>" line="251">
                <params>
                    <param name="pts" type="float[]"/>
                    <param name="type" type="int"/>
                    <param name="Ts" type="float[]"/>
                    <param name="numTs" type="int"/>
                </params>
                <comment line="254">
                    these prevent object creation and destruction during autoboxing.                    
                </comment>
                <comment line="255">
                    Because of this, the compiler should be able to completely                    
                </comment>
                <comment line="256">
                    eliminate the boxing costs.                    
                </comment>
                <anonymous_class line="253">
                    <declaration name="i0" type="Integer" line="257"/>
                    <declaration name="itype" type="Integer" line="258"/>
                    <declaration name="nextCurveIdx" type="int" line="259"/>
                    <declaration name="curCurveOff" type="Integer" line="260"/>
                    <declaration name="prevT" type="float" line="261"/>
                    <method name="hasNext" type="boolean" line="263"/>
                    <method name="next" type="Integer" line="267">
                        <declaration name="ret" type="Integer" line="268"/>
                        <scope line="269">
                            <declaration name="curT" type="float" line="270"/>
                            <declaration name="splitT" type="float" line="271"/>
                        </scope>
                        <scope line="279"/>
                    </method>
                    <method name="remove" type="void" line="286"/>
                </anonymous_class>
            </method>
        </class>
    </source>