<?xml version="1.0" encoding="UTF-8"?>
    <source package="sun.java2d.pisces">
        <import package="java.util.Map"/>
        <import package="java.util.concurrent.ConcurrentHashMap"/>
        <import package="sun.java2d.pipe.AATileGenerator"/>
        <class name="PiscesTileGenerator" line="33">
            <comment line="37">
                perhaps we should be using weak references here, but right now                
            </comment>
            <comment line="38">
                that&apos;s not necessary. The way the renderer is, this map will                
            </comment>
            <comment line="39">
                never contain more than one element - the one with key 64, since                
            </comment>
            <comment line="40">
                we only do 8x8 supersampling.                
            </comment>
            <comment line="49">
                The alpha map used by this object (taken out of our map cache) to convert                
            </comment>
            <comment line="50">
                pixel coverage counts gotten from PiscesCache (which are in the range                
            </comment>
            <comment line="51">
                [0, maxalpha]) into alpha values, which are in [0,256).                
            </comment>
            <implements interface="AATileGenerator"/>
            <declaration name="TILE_SIZE" type="int" line="34"/>
            <declaration name="alphaMapsCache" type="Map&lt;Integer,byte[]&gt;" line="40"/>
            <declaration name="cache" type="PiscesCache" line="43"/>
            <declaration name="x" type="int" line="44"/>
            <declaration name="maxalpha" type="int" line="45"/>
            <declaration name="maxTileAlphaSum" type="int" line="46"/>
            <declaration name="alphaMap" type="byte" line="51"/>
            <method name="PiscesTileGenerator" type="constructor" line="53">
                <params>
                    <param name="r" type="Renderer"/>
                    <param name="maxalpha" type="int"/>
                </params>
            </method>
            <method name="buildAlphaMap" type="byte[]" line="62">
                <params>
                    <param name="maxalpha" type="int"/>
                </params>
                <declaration name="alMap" type="byte[]" line="63"/>
                <declaration name="halfmaxalpha" type="int" line="64"/>
                <scope line="65"/>
            </method>
            <method name="getAlphaMap" type="byte[]" line="71">
                <params>
                    <param name="maxalpha" type="int"/>
                </params>
                <scope line="72"/>
            </method>
            <method name="getBbox" type="void" line="78">
                <params>
                    <param name="bbox" type="int"/>
                </params>
                <comment line="83">
                    System.out.println(&quot;bbox[&quot;+bbox[0]+&quot;, &quot;+bbox[1]+&quot; =&gt; &quot;+bbox[2]+&quot;, &quot;+bbox[3]+&quot;]&quot;);                    
                </comment>
            </method>
            <javadoc line="86">
                Gets the width of the tiles that the generator batches output into.                
                <return>
                    the width of the standard alpha tile                    
                </return>
            </javadoc>
            <method name="getTileWidth" type="int" line="90"/>
            <javadoc line="94">
                Gets the height of the tiles that the generator batches output into.                
                <return>
                    the height of the standard alpha tile                    
                </return>
            </javadoc>
            <method name="getTileHeight" type="int" line="98"/>
            <javadoc line="102">
                Gets the typical alpha value that will characterize the current
                  tile.
                  The answer may be 0x00 to indicate that the current tile has
                  no coverage in any of its pixels, or it may be 0xff to indicate
                  that the current tile is completely covered by the path, or any
                  other value to indicate non-trivial coverage cases.                
                <return>
                    0x00 for no coverage, 0xff for total coverage, or any other
                      value for partial coverage of the tile                    
                </return>
            </javadoc>
            <method name="getTypicalAlpha" type="int" line="112">
                <comment line="114">
                    Note: if we have a filled rectangle that doesn&apos;t end on a tile                    
                </comment>
                <comment line="115">
                    border, we could still return 0xff, even though al!=maxTileAlphaSum                    
                </comment>
                <comment line="116">
                    This is because if we return 0xff, our users will fill a rectangle                    
                </comment>
                <comment line="117">
                    starting at x,y that has width = Math.min(TILE_SIZE, bboxX1-x),                    
                </comment>
                <comment line="118">
                    and height min(TILE_SIZE,bboxY1-y), which is what should happen.                    
                </comment>
                <comment line="119">
                    However, to support this, we would have to use 2 Math.min&apos;s                    
                </comment>
                <comment line="120">
                    and 2 multiplications per tile, instead of just 2 multiplications                    
                </comment>
                <comment line="121">
                    to compute maxTileAlphaSum. The savings offered would probably                    
                </comment>
                <comment line="122">
                    not be worth it, considering how rare this case is.                    
                </comment>
                <comment line="123">
                    Note: I have not tested this, so in the future if it is determined                    
                </comment>
                <comment line="124">
                    that it is worth it, it should be implemented. Perhaps this method&apos;s                    
                </comment>
                <comment line="125">
                    interface should be changed to take arguments the width and height                    
                </comment>
                <comment line="126">
                    of the current tile. This would eliminate the 2 Math.min calls that                    
                </comment>
                <comment line="127">
                    would be needed here, since our caller needs to compute these 2                    
                </comment>
                <comment line="128">
                    values anyway.                    
                </comment>
                <declaration name="al" type="int" line="113"/>
            </method>
            <javadoc line="133">
                Skips the current tile and moves on to the next tile.
                  Either this method, or the getAlpha() method should be called
                  once per tile, but not both.                
            </javadoc>
            <method name="nextTile" type="void" line="138">
                <scope line="139"/>
            </method>
            <javadoc line="145">
                Gets the alpha coverage values for the current tile.
                  Either this method, or the nextTile() method should be called
                  once per tile, but not both.                
            </javadoc>
            <method name="getAlpha" type="void" line="150">
                <params>
                    <param name="tile" type="byte"/>
                    <param name="offset" type="int"/>
                    <param name="rowstride" type="int"/>
                </params>
                <comment line="151">
                    Decode run-length encoded alpha mask data                    
                </comment>
                <comment line="152">
                    The data for row j begins at cache.rowOffsetsRLE[j]                    
                </comment>
                <comment line="153">
                    and is encoded as a set of 2-byte pairs (val, runLen)                    
                </comment>
                <comment line="154">
                    terminated by a (0, 0) pair.                    
                </comment>
                <comment line="203">
                    System.out.println(&quot;M[&quot;+runLen+&quot;]&quot;);                    
                </comment>
                <comment line="227">
                    for (int i = idx - (x1-x0); i &lt; idx; i++) {
                    System.out.print(hex(tile[i], 2));
                    }
                    System.out.println();                    
                </comment>
                <declaration name="x0" type="int" line="156"/>
                <declaration name="x1" type="int" line="157"/>
                <declaration name="y0" type="int" line="158"/>
                <declaration name="y1" type="int" line="159"/>
                <declaration name="idx" type="int" line="165"/>
                <scope line="166">
                    <declaration name="row" type="int[]" line="167"/>
                    <declaration name="cx" type="int" line="169"/>
                    <scope line="172"/>
                    <declaration name="pos" type="int" line="176"/>
                    <scope line="177">
                        <declaration name="val" type="byte" line="178"/>
                        <declaration name="runLen" type="int" line="179"/>
                        <scope line="181"/>
                        <scope line="185"/>
                        <declaration name="rx0" type="int" line="197"/>
                        <declaration name="rx1" type="int" line="199"/>
                        <scope line="204">
                            <scope line="205"/>
                            <scope line="207"/>
                        </scope>
                    </scope>
                    <scope line="222"/>
                    <scope line="223"/>
                </scope>
            </method>
            <method name="hex" type="String" line="238">
                <params>
                    <param name="v" type="int"/>
                    <param name="d" type="int"/>
                </params>
                <declaration name="s" type="String" line="239"/>
                <scope line="240"/>
            </method>
            <javadoc line="246">
                Disposes this tile generator.
                  No further calls will be made on this instance.                
            </javadoc>
            <method name="dispose" type="void" line="250"/>
        </class>
    </source>