<?xml version="1.0" encoding="UTF-8"?>
    <source package="sun.java2d.pisces">
        <import package="java.awt.Shape"/>
        <import package="java.awt.BasicStroke"/>
        <import package="java.awt.geom.Path2D"/>
        <import package="java.awt.geom.AffineTransform"/>
        <import package="java.awt.geom.PathIterator"/>
        <import package="sun.awt.geom.PathConsumer2D"/>
        <import package="sun.java2d.pipe.Region"/>
        <import package="sun.java2d.pipe.RenderingEngine"/>
        <import package="sun.java2d.pipe.AATileGenerator"/>
        <class name="PiscesRenderingEngine" line="39">
            <extends class="RenderingEngine"/>
            <javadoc line="42">
                Create a widened path as specified by the parameters.
                  &lt;p&gt;
                  The specified {@code src} {@link Shape} is widened according
                  to the specified attribute parameters as per the{@link BasicStroke} specification.                
                <param>
                    src the source path to be widened                    
                </param>
                <param>
                    width the width of the widened path as per {@code BasicStroke}                    
                </param>
                <param>
                    caps the end cap decorations as per {@code BasicStroke}                    
                </param>
                <param>
                    join the segment join decorations as per {@code BasicStroke}                    
                </param>
                <param>
                    miterlimit the miter limit as per {@code BasicStroke}                    
                </param>
                <param>
                    dashes the dash length array as per {@code BasicStroke}                    
                </param>
                <param>
                    dashphase the initial dash phase as per {@code BasicStroke}                    
                </param>
                <return>
                    the widened path stored in a new {@code Shape} object                    
                </return>
                <since>
                    1.7                    
                </since>
            </javadoc>
            <method name="createStrokedShape" type="Shape" line="66">
                <params>
                    <param name="src" type="Shape"/>
                    <param name="width" type="float"/>
                    <param name="caps" type="int"/>
                    <param name="join" type="int"/>
                    <param name="miterlimit" type="float"/>
                    <param name="dashes" type="float"/>
                    <param name="dashphase" type="float"/>
                </params>
                <declaration name="p2d" type="Path2D" line="67"/>
                <anonymous_class line="78">
                    <method name="moveTo" type="void" line="79">
                        <params>
                            <param name="x0" type="float"/>
                            <param name="y0" type="float"/>
                        </params>
                    </method>
                    <method name="lineTo" type="void" line="82">
                        <params>
                            <param name="x1" type="float"/>
                            <param name="y1" type="float"/>
                        </params>
                    </method>
                    <method name="closePath" type="void" line="85"/>
                    <method name="pathDone" type="void" line="88"/>
                    <method name="curveTo" type="void" line="91">
                        <params>
                            <param name="x1" type="float"/>
                            <param name="y1" type="float"/>
                            <param name="x2" type="float"/>
                            <param name="y2" type="float"/>
                            <param name="x3" type="float"/>
                            <param name="y3" type="float"/>
                        </params>
                    </method>
                    <method name="quadTo" type="void" line="94">
                        <params>
                            <param name="x1" type="float"/>
                            <param name="y1" type="float"/>
                            <param name="x2" type="float"/>
                            <param name="y2" type="float"/>
                        </params>
                    </method>
                    <method name="getNativeConsumer" type="long" line="97"/>
                </anonymous_class>
            </method>
            <javadoc line="104">
                Sends the geometry for a widened path as specified by the parameters
                  to the specified consumer.
                  &lt;p&gt;
                  The specified {@code src} {@link Shape} is widened according
                  to the parameters specified by the {@link BasicStroke} object.
                  Adjustments are made to the path as appropriate for the{@link VALUE_STROKE_NORMALIZE} hint if the {@code normalize}boolean parameter is true.
                  Adjustments are made to the path as appropriate for the{@link VALUE_ANTIALIAS_ON} hint if the {@code antialias}boolean parameter is true.
                  &lt;p&gt;
                  The geometry of the widened path is forwarded to the indicated{@link PathConsumer2D} object as it is calculated.                
                <param>
                    src the source path to be widened                    
                </param>
                <param>
                    bs the {@code BasicSroke} object specifying the
                      decorations to be applied to the widened path                    
                </param>
                <param>
                    normalize indicates whether stroke normalization should
                      be applied                    
                </param>
                <param>
                    antialias indicates whether or not adjustments appropriate
                      to antialiased rendering should be applied                    
                </param>
                <param>
                    consumer the {@code PathConsumer2D} instance to forward
                      the widened geometry to                    
                </param>
                <since>
                    1.7                    
                </since>
            </javadoc>
            <method name="strokeTo" type="void" line="138">
                <params>
                    <param name="src" type="Shape"/>
                    <param name="at" type="AffineTransform"/>
                    <param name="bs" type="BasicStroke"/>
                    <param name="thin" type="boolean"/>
                    <param name="normalize" type="boolean"/>
                    <param name="antialias" type="boolean"/>
                    <param name="consumer" type="PathConsumer2D"/>
                </params>
                <declaration name="norm" type="NormMode" line="139"/>
            </method>
            <method name="strokeTo" type="void" line="152">
                <params>
                    <param name="src" type="Shape"/>
                    <param name="at" type="AffineTransform"/>
                    <param name="bs" type="BasicStroke"/>
                    <param name="thin" type="boolean"/>
                    <param name="normalize" type="NormMode"/>
                    <param name="antialias" type="boolean"/>
                    <param name="pc2d" type="PathConsumer2D"/>
                </params>
                <declaration name="lw" type="float" line="153"/>
                <scope line="154">
                    <scope line="155"/>
                    <scope line="157"/>
                </scope>
                <scope line="160"/>
            </method>
            <method name="userSpaceLineWidth" type="float" line="175">
                <params>
                    <param name="at" type="AffineTransform"/>
                    <param name="lw" type="float"/>
                </params>
                <comment line="183">
                                        
                </comment>
                <comment line="184">
                    m00                    
                </comment>
                <comment line="185">
                    m01                    
                </comment>
                <comment line="186">
                    m10                    
                </comment>
                <comment line="187">
                    m11                    
                </comment>
                <comment line="189">
                    Given a 2 x 2 affine matrix [ A B ] such that
                                                 [ C D ]
                     v&apos; = [x&apos; y&apos;] = [Ax + Cy, Bx + Dy], we want to
                     find the maximum magnitude (norm) of the vector v&apos;
                     with the constraint (x^2 + y^2 = 1).
                     The equation to maximize is
                         |v&apos;| = sqrt((Ax+Cy)^2+(Bx+Dy)^2)
                     or  |v&apos;| = sqrt((AA+BB)x^2 + 2(AC+BD)xy + (CC+DD)y^2).
                     Since sqrt is monotonic we can maximize |v&apos;|^2
                     instead and plug in the substitution y = sqrt(1 - x^2).
                     Trigonometric equalities can then be used to get
                     rid of most of the sqrt terms.                    
                </comment>
                <comment line="204">
                    x^2 coefficient                    
                </comment>
                <comment line="205">
                    xy coefficient                    
                </comment>
                <comment line="206">
                    y^2 coefficient                    
                </comment>
                <comment line="208">
                    There is a lot of calculus omitted here.
                    
                     Conceptually, in the interests of understanding the
                     terms that the calculus produced we can consider
                     that EA and EC end up providing the lengths along
                     the major axes and the hypot term ends up being an
                     adjustment for the additional length along the off-axis
                     angle of rotated or sheared ellipses as well as an
                     adjustment for the fact that the equation below
                     averages the two major axis lengths.  (Notice that
                     the hypot term contains a part which resolves to the
                     difference of these two axis lengths in the absence
                     of rotation.)
                    
                     In the calculus, the ratio of the EB and (EA-EC) terms
                     ends up being the tangent of 2theta where theta is
                     the angle that the long axis of the ellipse makes
                     with the horizontal axis.  Thus, this equation is
                     calculating the length of the hypotenuse of a triangle
                     along that axis.                    
                </comment>
                <comment line="232">
                                        
                </comment>
                <declaration name="widthScale" type="double" line="177"/>
                <scope line="180"/>
                <scope line="182">
                    <declaration name="A" type="double" line="184"/>
                    <declaration name="C" type="double" line="185"/>
                    <declaration name="B" type="double" line="186"/>
                    <declaration name="D" type="double" line="187"/>
                    <declaration name="EA" type="double" line="204"/>
                    <declaration name="EB" type="double" line="205"/>
                    <declaration name="EC" type="double" line="206"/>
                    <declaration name="hypot" type="double" line="231"/>
                    <declaration name="widthsquared" type="double" line="233"/>
                </scope>
            </method>
            <method name="strokeTo" type="void" line="251">
                <params>
                    <param name="src" type="Shape"/>
                    <param name="at" type="AffineTransform"/>
                    <param name="width" type="float"/>
                    <param name="normalize" type="NormMode"/>
                    <param name="caps" type="int"/>
                    <param name="join" type="int"/>
                    <param name="miterlimit" type="float"/>
                    <param name="dashes" type="float"/>
                    <param name="dashphase" type="float"/>
                    <param name="pc2d" type="PathConsumer2D"/>
                </params>
                <comment line="252">
                    We use strokerat and outat so that in Stroker and Dasher we can work only                    
                </comment>
                <comment line="253">
                    with the pre-transformation coordinates. This will repeat a lot of                    
                </comment>
                <comment line="254">
                    computations done in the path iterator, but the alternative is to                    
                </comment>
                <comment line="255">
                    work with transformed paths and compute untransformed coordinates                    
                </comment>
                <comment line="256">
                    as needed. This would be faster but I do not think the complexity                    
                </comment>
                <comment line="257">
                    of working with both untransformed and transformed coordinates in                    
                </comment>
                <comment line="258">
                    the same code is worth it.                    
                </comment>
                <comment line="259">
                    However, if a path&apos;s width is constant after a transformation,                    
                </comment>
                <comment line="260">
                    we can skip all this untransforming.                    
                </comment>
                <comment line="262">
                    If normalization is off we save some transformations by not                    
                </comment>
                <comment line="263">
                    transforming the input to pisces. Instead, we apply the                    
                </comment>
                <comment line="264">
                    transformation after the path processing has been done.                    
                </comment>
                <comment line="265">
                    We can&apos;t do this if normalization is on, because it isn&apos;t a good                    
                </comment>
                <comment line="266">
                    idea to normalize before the transformation is applied.                    
                </comment>
                <comment line="279">
                    this rendering engine takes one dimensional curves and turns                    
                </comment>
                <comment line="280">
                    them into 2D shapes by giving them width.                    
                </comment>
                <comment line="281">
                    However, if everything is to be passed through a singular                    
                </comment>
                <comment line="282">
                    transformation, these 2D shapes will be squashed down to 1D                    
                </comment>
                <comment line="283">
                    again so, nothing can be drawn.                    
                </comment>
                <comment line="285">
                    Every path needs an initial moveTo and a pathDone. If these                    
                </comment>
                <comment line="286">
                    are not there this causes a SIGSEGV in libawt.so (at the time                    
                </comment>
                <comment line="287">
                    of writing of this comment (September 16, 2010)). Actually,                    
                </comment>
                <comment line="288">
                    I am not sure if the moveTo is necessary to avoid the SIGSEGV                    
                </comment>
                <comment line="289">
                    but the pathDone is definitely needed.                    
                </comment>
                <comment line="295">
                    If the transform is a constant multiple of an orthogonal transformation                    
                </comment>
                <comment line="296">
                    then every length is just multiplied by a constant, so we just                    
                </comment>
                <comment line="297">
                    need to transform input paths to stroker and tell stroker                    
                </comment>
                <comment line="298">
                    the scaled width. This condition is satisfied if                    
                </comment>
                <comment line="299">
                    a*b == -c*d &amp;&amp; a*a+c*c == b*b+d*d. In the actual check below, we                    
                </comment>
                <comment line="300">
                    leave a bit of room for error.                    
                </comment>
                <comment line="315">
                    by now strokerat == null &amp;&amp; outat == null. Input paths to                    
                </comment>
                <comment line="316">
                    stroker (and maybe dasher) will have the full transform at                    
                </comment>
                <comment line="317">
                    applied to them and nothing will happen to the output paths.                    
                </comment>
                <comment line="323">
                    by now strokerat == at &amp;&amp; outat == null. Input paths to                    
                </comment>
                <comment line="324">
                    stroker (and maybe dasher) will have the full transform at                    
                </comment>
                <comment line="325">
                    applied to them, then they will be normalized, and then                    
                </comment>
                <comment line="326">
                    the inverse of *only the non translation part of at* will                    
                </comment>
                <comment line="327">
                    be applied to the normalized paths. This won&apos;t cause problems                    
                </comment>
                <comment line="328">
                    in stroker, because, suppose at = T*A, where T is just the                    
                </comment>
                <comment line="329">
                    translation part of at, and A is the rest. T*A has already                    
                </comment>
                <comment line="330">
                    been applied to Stroker/Dasher&apos;s input. Then Ainv will be                    
                </comment>
                <comment line="331">
                    applied. Ainv*T*A is not equal to T, but it is a translation,                    
                </comment>
                <comment line="332">
                    which means that none of stroker&apos;s assumptions about its                    
                </comment>
                <comment line="333">
                    input will be violated. After all this, A will be applied                    
                </comment>
                <comment line="334">
                    to stroker&apos;s output.                    
                </comment>
                <comment line="338">
                    outat == at &amp;&amp; strokerat == null. This is because if no                    
                </comment>
                <comment line="339">
                    normalization is done, we can just apply all our                    
                </comment>
                <comment line="340">
                    transformations to stroker&apos;s output.                    
                </comment>
                <comment line="344">
                    either at is null or it&apos;s the identity. In either case                    
                </comment>
                <comment line="345">
                    we don&apos;t transform the path.                    
                </comment>
                <comment line="352">
                    by now, at least one of outat and strokerat will be null. Unless at is not                    
                </comment>
                <comment line="353">
                    a constant multiple of an orthogonal transformation, they will both be                    
                </comment>
                <comment line="354">
                    null. In other cases, outat == at if normalization is off, and if                    
                </comment>
                <comment line="355">
                    normalization is on, strokerat == at.                    
                </comment>
                <declaration name="strokerat" type="AffineTransform" line="267"/>
                <declaration name="outat" type="AffineTransform" line="268"/>
                <declaration name="pi" type="PathIterator" line="270"/>
                <scope line="272">
                    <declaration name="a" type="double" line="273"/>
                    <declaration name="b" type="double" line="274"/>
                    <declaration name="c" type="double" line="275"/>
                    <declaration name="d" type="double" line="276"/>
                    <declaration name="det" type="double" line="277"/>
                    <scope line="278"/>
                    <scope line="301">
                        <declaration name="scale" type="double" line="302"/>
                        <scope line="303">
                            <scope line="305"/>
                        </scope>
                        <scope line="312"/>
                    </scope>
                    <scope line="318">
                        <scope line="319"/>
                        <scope line="335"/>
                    </scope>
                </scope>
                <scope line="343">
                    <scope line="347"/>
                </scope>
                <scope line="359"/>
            </method>
            <method name="nearZero" type="boolean" line="366">
                <params>
                    <param name="num" type="double"/>
                    <param name="nulps" type="int"/>
                </params>
            </method>
            <class name="NormalizingPathIterator" line="370">
                <comment line="375">
                    the adjustment applied to the current position.                    
                </comment>
                <comment line="377">
                    the adjustment applied to the last moveTo position.                    
                </comment>
                <comment line="380">
                    constants used in normalization computations                    
                </comment>
                <implements interface="PathIterator"/>
                <declaration name="src" type="PathIterator" line="372"/>
                <declaration name="curx_adjust" type="float" line="375"/>
                <declaration name="movx_adjust" type="float" line="377"/>
                <declaration name="lval" type="float" line="380"/>
                <method name="NormalizingPathIterator" type="constructor" line="382">
                    <params>
                        <param name="src" type="PathIterator"/>
                        <param name="mode" type="NormMode"/>
                    </params>
                    <comment line="386">
                        round to nearest (0.25, 0.25) pixel                        
                    </comment>
                    <comment line="390">
                        round to nearest pixel center                        
                    </comment>
                </method>
                <method name="currentSegment" type="int" line="402">
                    <params>
                        <param name="coords" type="float[]"/>
                    </params>
                    <comment line="418">
                        we don&apos;t want to deal with this case later. We just exit now                        
                    </comment>
                    <comment line="426">
                        normalize endpoint                        
                    </comment>
                    <comment line="435">
                        now that the end points are done, normalize the control points                        
                    </comment>
                    <declaration name="type" type="int" line="403"/>
                    <declaration name="lastCoord" type="int" line="405"/>
                    <declaration name="x_adjust" type="float" line="427"/>
                    <declaration name="y_adjust" type="float" line="429"/>
                </method>
                <method name="currentSegment" type="int" line="461">
                    <params>
                        <param name="coords" type="double[]"/>
                    </params>
                    <declaration name="tmp" type="float[]" line="462"/>
                    <declaration name="type" type="int" line="463"/>
                    <scope line="464"/>
                </method>
                <method name="getWindingRule" type="int" line="470"/>
                <method name="isDone" type="boolean" line="474"/>
                <method name="next" type="void" line="478"/>
            </class>
            <method name="pathTo" type="void" line="483">
                <params>
                    <param name="pi" type="PathIterator"/>
                    <param name="pc2d" type="PathConsumer2D"/>
                </params>
            </method>
            <javadoc line="488">
                Construct an antialiased tile generator for the given shape with
                  the given rendering attributes and store the bounds of the tile
                  iteration in the bbox parameter.
                  The {@code at} parameter specifies a transform that should affect
                  both the shape and the {@code BasicStroke} attributes.
                  The {@code clip} parameter specifies the current clip in effect
                  in device coordinates and can be used to prune the data for the
                  operation, but the renderer is not required to perform any
                  clipping.
                  If the {@code BasicStroke} parameter is null then the shape
                  should be filled as is, otherwise the attributes of the{@code BasicStroke} should be used to specify a draw operation.
                  The {@code thin} parameter indicates whether or not the
                  transformed {@code BasicStroke} represents coordinates smaller
                  than the minimum resolution of the antialiasing rasterizer as
                  specified by the {@code getMinimumAAPenWidth()} method.
                  &lt;p&gt;
                  Upon returning, this method will fill the {@code bbox} parameter
                  with 4 values indicating the bounds of the iteration of the
                  tile generator.
                  The iteration order of the tiles will be as specified by the
                  pseudo-code:
                  &lt;pre&gt;
                  for (y = bbox[1]; y &lt; bbox[3]; y += tileheight) {
                  for (x = bbox[0]; x &lt; bbox[2]; x += tilewidth) {
                  }
                  }
                  &lt;/pre&gt;
                  If there is no output to be rendered, this method may return
                  null.                
                <param>
                    s the shape to be rendered (fill or draw)                    
                </param>
                <param>
                    at the transform to be applied to the shape and the
                      stroke attributes                    
                </param>
                <param>
                    clip the current clip in effect in device coordinates                    
                </param>
                <param>
                    bs if non-null, a {@code BasicStroke} whose attributes
                      should be applied to this operation                    
                </param>
                <param>
                    thin true if the transformed stroke attributes are smaller
                      than the minimum dropout pen width                    
                </param>
                <param>
                    normalize true if the {@code VALUE_STROKE_NORMALIZE}{@code RenderingHint} is in effect                    
                </param>
                <param>
                    bbox returns the bounds of the iteration                    
                </param>
                <return>
                    the {@code AATileGenerator} instance to be consulted
                      for tile coverages, or null if there is no output to render                    
                </return>
                <since>
                    1.7                    
                </since>
            </javadoc>
            <method name="getAATileGenerator" type="AATileGenerator" line="542">
                <params>
                    <param name="s" type="Shape"/>
                    <param name="at" type="AffineTransform"/>
                    <param name="clip" type="Region"/>
                    <param name="bs" type="BasicStroke"/>
                    <param name="thin" type="boolean"/>
                    <param name="normalize" type="boolean"/>
                    <param name="bbox" type="int"/>
                </params>
                <declaration name="r" type="Renderer" line="543"/>
                <declaration name="norm" type="NormMode" line="544"/>
                <scope line="545">
                    <declaration name="pi" type="PathIterator" line="546"/>
                    <scope line="547"/>
                    <scope line="549"/>
                </scope>
                <scope line="557"/>
                <declaration name="ptg" type="PiscesTileGenerator" line="565"/>
            </method>
            <method name="getAATileGenerator" type="AATileGenerator" line="576">
                <params>
                    <param name="x" type="double"/>
                    <param name="y" type="double"/>
                    <param name="dx1" type="double"/>
                    <param name="dy1" type="double"/>
                    <param name="dx2" type="double"/>
                    <param name="dy2" type="double"/>
                    <param name="lw1" type="double"/>
                    <param name="lw2" type="double"/>
                    <param name="clip" type="Region"/>
                    <param name="bbox" type="int"/>
                </params>
                <comment line="577">
                    REMIND: Deal with large coordinates!                    
                </comment>
                <comment line="593">
                    Inner parallelogram was entirely consumed by stroke...                    
                </comment>
                <declaration name="ldx1" type="double" line="578"/>
                <declaration name="innerpgram" type="boolean" line="579"/>
                <scope line="581">
                    <scope line="592"/>
                </scope>
                <scope line="596"/>
                <declaration name="r" type="Renderer" line="600"/>
                <scope line="611"/>
                <declaration name="ptg" type="PiscesTileGenerator" line="628"/>
            </method>
            <javadoc line="633">
                Returns the minimum pen width that the antialiasing rasterizer
                  can represent without dropouts occuring.                
                <since>
                    1.7                    
                </since>
            </javadoc>
            <method name="getMinimumAAPenSize" type="float" line="638"/>
            <scope line="642">
                <scope line="651"/>
            </scope>
        </class>
    </source>