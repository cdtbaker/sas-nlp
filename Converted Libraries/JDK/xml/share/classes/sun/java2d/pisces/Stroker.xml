<?xml version="1.0" encoding="UTF-8"?>
    <source package="sun.java2d.pisces">
        <import package="java.util.Arrays"/>
        <import package="java.util.Iterator"/>
        <import package="java.lang.Math.ulp"/>
        <import package="java.lang.Math.sqrt"/>
        <import package="sun.awt.geom.PathConsumer2D"/>
        <class name="Stroker" line="38">
            <comment line="42">
                ie. curve, line, or quad                
            </comment>
            <comment line="88">
                The starting point of the path, and the slope there.                
            </comment>
            <comment line="90">
                the current point and the slope there.                
            </comment>
            <comment line="91">
                c stands for current                
            </comment>
            <comment line="92">
                vectors that when added to (sx0,sy0) and (cx0,cy0) respectively yield the
                 first and last points on the left parallel path. Since this path is
                 parallel, it&apos;s slope at any point is parallel to the slope of the
                 original path (thought they may have different directions), so these
                 could be computed from sdx,sdy and cdx,cdy (and vice versa), but that
                 would be error prone and hard to read, so we keep these anyway.                
            </comment>
            <comment line="145">
                Returns true if the vectors (dx1, dy1) and (dx2, dy2) are
                 clockwise (if dx1,dy1 needs to be rotated clockwise to close
                 the smallest angle between it and dx2,dy2).
                 This is equivalent to detecting whether a point q is on the right side
                 of a line passing through points p1, p2 where p2 = p1+(dx1,dy1) and
                 q = p2+(dx2,dy2), which is the same as saying p1, p2, q are in a
                 clockwise order.
                 NOTE: &quot;clockwise&quot; here assumes coordinates with 0,0 at the bottom left.                
            </comment>
            <comment line="159">
                pisces used to use fixed point arithmetic with 16 decimal digits. I
                 didn&apos;t want to change the values of the constant below when I converted
                 it to floating point, so that&apos;s why the divisions by 2^16 are there.                
            </comment>
            <comment line="240">
                the input arc defined by omx,omy and mx,my must span &lt;= 90 degrees.                
            </comment>
            <comment line="290">
                Put the intersection point of the lines (x0, y0) -&gt; (x1, y1)
                 and (x0p, y0p) -&gt; (x1p, y1p) in m[off] and m[off+1].
                 If the lines are parallel, it will put a non finite number in m.                
            </comment>
            <comment line="697">
                return the kind of curve in the right and left arrays.                
            </comment>
            <comment line="768">
                This is where the curve to be processed is put. We give it
                 enough room to store 2 curves: one for the current subdivision, the
                 other for the rest of the curve.                
            </comment>
            <comment line="777">
                If this class is compiled with ecj, then Hotspot crashes when OSR
                 compiling this function. See bugs 7004570 and 6675699
                 TODO: until those are fixed, we should work around that by
                 manually inlining this into curveTo and quadTo.                
            </comment>
            <comment line="1108">
                a stack of polynomial curves where each curve shares endpoints with
                 adjacent ones.                
            </comment>
            <implements interface="PathConsumer2D"/>
            <declaration name="MOVE_TO" type="int" line="40"/>
            <declaration name="DRAWING_OP_TO" type="int" line="41"/>
            <declaration name="CLOSE" type="int" line="42"/>
            <declaration name="JOIN_MITER" type="int" line="44"/>
            <javadoc line="44">
                Constant value for join style.                
            </javadoc>
            <declaration name="JOIN_ROUND" type="int" line="49"/>
            <javadoc line="49">
                Constant value for join style.                
            </javadoc>
            <declaration name="JOIN_BEVEL" type="int" line="54"/>
            <javadoc line="54">
                Constant value for join style.                
            </javadoc>
            <declaration name="CAP_BUTT" type="int" line="59"/>
            <javadoc line="59">
                Constant value for end cap style.                
            </javadoc>
            <declaration name="CAP_ROUND" type="int" line="64"/>
            <javadoc line="64">
                Constant value for end cap style.                
            </javadoc>
            <declaration name="CAP_SQUARE" type="int" line="69"/>
            <javadoc line="69">
                Constant value for end cap style.                
            </javadoc>
            <declaration name="out" type="PathConsumer2D" line="74"/>
            <declaration name="capStyle" type="int" line="76"/>
            <declaration name="joinStyle" type="int" line="77"/>
            <declaration name="lineWidth2" type="float" line="79"/>
            <declaration name="offset" type="float[][]" line="81"/>
            <declaration name="miter" type="float[]" line="82"/>
            <declaration name="miterLimitSq" type="float" line="83"/>
            <declaration name="prev" type="int" line="85"/>
            <declaration name="sx0" type="float" line="88"/>
            <declaration name="cx0" type="float" line="90"/>
            <declaration name="smx" type="float" line="97"/>
            <declaration name="reverse" type="PolyStack" line="99"/>
            <javadoc line="101">
                Constructs a &lt;code&gt;Stroker&lt;/code&gt;.                
                <param>
                    pc2d an output &lt;code&gt;PathConsumer2D&lt;/code&gt;.                    
                </param>
                <param>
                    lineWidth the desired line width in pixels                    
                </param>
                <param>
                    capStyle the desired end cap style, one of
                      &lt;code&gt;CAP_BUTT&lt;/code&gt;, &lt;code&gt;CAP_ROUND&lt;/code&gt; or
                      &lt;code&gt;CAP_SQUARE&lt;/code&gt;.                    
                </param>
                <param>
                    joinStyle the desired line join style, one of
                      &lt;code&gt;JOIN_MITER&lt;/code&gt;, &lt;code&gt;JOIN_ROUND&lt;/code&gt; or
                      &lt;code&gt;JOIN_BEVEL&lt;/code&gt;.                    
                </param>
                <param>
                    miterLimit the desired miter limit                    
                </param>
            </javadoc>
            <method name="Stroker" type="constructor" line="119">
                <params>
                    <param name="pc2d" type="PathConsumer2D"/>
                    <param name="lineWidth" type="float"/>
                    <param name="capStyle" type="int"/>
                    <param name="joinStyle" type="int"/>
                    <param name="miterLimit" type="float"/>
                </params>
                <declaration name="limit" type="float" line="126"/>
            </method>
            <method name="computeOffset" type="void" line="134">
                <params>
                    <param name="lx" type="float"/>
                    <param name="ly" type="float"/>
                    <param name="w" type="float"/>
                    <param name="m" type="float[]"/>
                </params>
                <declaration name="len" type="float" line="135"/>
                <scope line="136"/>
                <scope line="138"/>
            </method>
            <method name="isCW" type="boolean" line="154">
                <params>
                    <param name="dx1" type="float"/>
                    <param name="dy1" type="float"/>
                    <param name="dx2" type="float"/>
                    <param name="dy2" type="float"/>
                </params>
            </method>
            <declaration name="ROUND_JOIN_THRESHOLD" type="float" line="161"/>
            <method name="drawRoundJoin" type="void" line="167">
                <params>
                    <param name="x" type="float"/>
                    <param name="y" type="float"/>
                    <param name="omx" type="float"/>
                    <param name="omy" type="float"/>
                    <param name="mx" type="float"/>
                    <param name="my" type="float"/>
                    <param name="rev" type="boolean"/>
                    <param name="threshold" type="float"/>
                </params>
                <scope line="168"/>
                <declaration name="domx" type="float" line="172"/>
                <declaration name="domy" type="float" line="173"/>
                <declaration name="len" type="float" line="174"/>
                <scope line="175"/>
                <scope line="179"/>
            </method>
            <method name="drawRoundJoin" type="void" line="192">
                <params>
                    <param name="cx" type="float"/>
                    <param name="cy" type="float"/>
                    <param name="omx" type="float"/>
                    <param name="omy" type="float"/>
                    <param name="mx" type="float"/>
                    <param name="my" type="float"/>
                    <param name="rev" type="boolean"/>
                </params>
                <comment line="194">
                    The sign of the dot product of mx,my and omx,omy is equal to the
                     the sign of the cosine of ext
                     (ext is the angle between omx,omy and mx,my).                    
                </comment>
                <comment line="198">
                    If it is &gt;=0, we know that abs(ext) is &lt;= 90 degrees, so we only
                     need 1 curve to approximate the circle section that joins omx,omy
                     and mx,my.                    
                </comment>
                <comment line="208">
                    we need to split the arc into 2 arcs spanning the same angle.
                     The point we want will be one of the 2 intersections of the
                     perpendicular bisector of the chord (omx,omy)-&gt;(mx,my) and the
                     circle. We could find this by scaling the vector
                     (omx+mx, omy+my)/2 so that it has length=lineWidth2 (and thus lies
                     on the circle), but that can have numerical problems when the angle
                     between omx,omy and mx,my is close to 180 degrees. So we compute a
                     normal of (omx,omy)-(mx,my). This will be the direction of the
                     perpendicular bisector. To get one of the intersections, we just scale
                     this vector that its length is lineWidth2 (this works because the
                     perpendicular bisector goes through the origin). This scaling doesn&apos;t
                     have numerical problems because we know that lineWidth2 divided by
                     this normal&apos;s length is at least 0.5 and at most sqrt(2)/2 (because
                     we know the angle of the arc is &gt; 90 degrees).                    
                </comment>
                <comment line="227">
                    if (isCW(omx, omy, mx, my) != isCW(mmx, mmy, mx, my)) then we&apos;ve
                     computed the wrong intersection so we get the other one.
                     The test above is equivalent to if (rev).                    
                </comment>
                <declaration name="cosext" type="double" line="196"/>
                <declaration name="numCurves" type="int" line="200"/>
                <declaration name="nx" type="float" line="221"/>
                <declaration name="nlen" type="float" line="222"/>
                <declaration name="scale" type="float" line="223"/>
                <declaration name="mmx" type="float" line="224"/>
                <scope line="229"/>
            </method>
            <method name="drawBezApproxForArc" type="void" line="244">
                <params>
                    <param name="cx" type="float"/>
                    <param name="cy" type="float"/>
                    <param name="omx" type="float"/>
                    <param name="omy" type="float"/>
                    <param name="mx" type="float"/>
                    <param name="my" type="float"/>
                    <param name="rev" type="boolean"/>
                </params>
                <comment line="247">
                    cv is the length of P1-P0 and P2-P3 divided by the radius of the arc
                     (so, cv assumes the arc has radius 1). P0, P1, P2, P3 are the points that
                     define the bezier curve we&apos;re computing.
                     It is computed using the constraints that P1-P0 and P3-P2 are parallel
                     to the arc tangents at the endpoints, and that |P1-P0|=|P3-P2|.                    
                </comment>
                <comment line="254">
                    if clockwise, we need to negate cv.                    
                </comment>
                <comment line="255">
                    rev is equivalent to isCW(omx, omy, mx, my)                    
                </comment>
                <declaration name="cosext2" type="float" line="245"/>
                <declaration name="cv" type="float" line="251"/>
                <scope line="254"/>
                <declaration name="x1" type="float" line="257"/>
                <declaration name="y1" type="float" line="258"/>
                <declaration name="x2" type="float" line="259"/>
                <declaration name="y2" type="float" line="260"/>
                <declaration name="x4" type="float" line="262"/>
                <declaration name="y4" type="float" line="263"/>
                <declaration name="x3" type="float" line="264"/>
                <declaration name="y3" type="float" line="265"/>
            </method>
            <method name="drawRoundCap" type="void" line="270">
                <params>
                    <param name="cx" type="float"/>
                    <param name="cy" type="float"/>
                    <param name="mx" type="float"/>
                    <param name="my" type="float"/>
                </params>
                <comment line="273">
                    the first and second arguments of the following two calls
                     are really will be ignored by emitCurveTo (because of the false),
                     but we put them in anyway, as opposed to just giving it 4 zeroes,
                     because it&apos;s just 4 additions and it&apos;s not good to rely on this
                     sort of assumption (right now it&apos;s true, but that may change).                    
                </comment>
                <declaration name="C" type="float" line="271"/>
            </method>
            <method name="computeIntersection" type="void" line="297">
                <params>
                    <param name="x0" type="float"/>
                    <param name="y0" type="float"/>
                    <param name="x1" type="float"/>
                    <param name="y1" type="float"/>
                    <param name="x0p" type="float"/>
                    <param name="y0p" type="float"/>
                    <param name="x1p" type="float"/>
                    <param name="y1p" type="float"/>
                    <param name="m" type="float[]"/>
                    <param name="off" type="int"/>
                </params>
                <declaration name="x10" type="float" line="298"/>
                <declaration name="y10" type="float" line="299"/>
                <declaration name="x10p" type="float" line="300"/>
                <declaration name="y10p" type="float" line="301"/>
                <declaration name="den" type="float" line="303"/>
                <declaration name="t" type="float" line="304"/>
            </method>
            <method name="drawMiter" type="void" line="315">
                <params>
                    <param name="pdx" type="float"/>
                    <param name="pdy" type="float"/>
                    <param name="x0" type="float"/>
                    <param name="y0" type="float"/>
                    <param name="dx" type="float"/>
                    <param name="dy" type="float"/>
                    <param name="omx" type="float"/>
                    <param name="omy" type="float"/>
                    <param name="mx" type="float"/>
                    <param name="my" type="float"/>
                    <param name="rev" type="boolean"/>
                </params>
                <comment line="337">
                    If the lines are parallel, lenSq will be either NaN or +inf
                     (actually, I&apos;m not sure if the latter is possible. The important
                     thing is that -inf is not possible, because lenSq is a square).
                     For both of those values, the comparison below will fail and
                     no miter will be drawn, which is correct.                    
                </comment>
                <scope line="319"/>
                <scope line="323"/>
                <declaration name="lenSq" type="float" line="334"/>
                <scope line="341"/>
            </method>
            <method name="moveTo" type="void" line="346">
                <params>
                    <param name="x0" type="float"/>
                    <param name="y0" type="float"/>
                </params>
                <scope line="347"/>
            </method>
            <method name="lineTo" type="void" line="357">
                <params>
                    <param name="x1" type="float"/>
                    <param name="y1" type="float"/>
                </params>
                <declaration name="dx" type="float" line="358"/>
                <declaration name="dy" type="float" line="359"/>
                <scope line="360"/>
                <declaration name="mx" type="float" line="364"/>
                <declaration name="my" type="float" line="365"/>
            </method>
            <method name="closePath" type="void" line="384">
                <scope line="385">
                    <scope line="386"/>
                </scope>
                <scope line="398"/>
            </method>
            <method name="emitReverse" type="void" line="413">
                <scope line="414"/>
            </method>
            <method name="pathDone" type="void" line="419">
                <comment line="426">
                    this shouldn&apos;t matter since this object won&apos;t be used
                     after the call to this method.                    
                </comment>
                <scope line="420"/>
            </method>
            <method name="finish" type="void" line="430">
                <scope line="431"/>
                <scope line="433"/>
                <scope line="440"/>
                <scope line="442"/>
            </method>
            <method name="emitMoveTo" type="void" line="450">
                <params>
                    <param name="x0" type="float"/>
                    <param name="y0" type="float"/>
                </params>
            </method>
            <method name="emitLineTo" type="void" line="454">
                <params>
                    <param name="x1" type="float"/>
                    <param name="y1" type="float"/>
                </params>
            </method>
            <method name="emitLineTo" type="void" line="460">
                <params>
                    <param name="x1" type="float"/>
                    <param name="y1" type="float"/>
                    <param name="rev" type="boolean"/>
                </params>
                <scope line="461"/>
                <scope line="463"/>
            </method>
            <method name="emitQuadTo" type="void" line="471">
                <params>
                    <param name="x0" type="float"/>
                    <param name="y0" type="float"/>
                    <param name="x1" type="float"/>
                    <param name="y1" type="float"/>
                    <param name="x2" type="float"/>
                    <param name="y2" type="float"/>
                    <param name="rev" type="boolean"/>
                </params>
                <scope line="472"/>
                <scope line="474"/>
            </method>
            <method name="emitCurveTo" type="void" line="483">
                <params>
                    <param name="x0" type="float"/>
                    <param name="y0" type="float"/>
                    <param name="x1" type="float"/>
                    <param name="y1" type="float"/>
                    <param name="x2" type="float"/>
                    <param name="y2" type="float"/>
                    <param name="x3" type="float"/>
                    <param name="y3" type="float"/>
                    <param name="rev" type="boolean"/>
                </params>
                <scope line="484"/>
                <scope line="486"/>
            </method>
            <method name="emitClose" type="void" line="491"/>
            <method name="drawJoin" type="void" line="500">
                <params>
                    <param name="pdx" type="float"/>
                    <param name="pdy" type="float"/>
                    <param name="x0" type="float"/>
                    <param name="y0" type="float"/>
                    <param name="dx" type="float"/>
                    <param name="dy" type="float"/>
                    <param name="omx" type="float"/>
                    <param name="omy" type="float"/>
                    <param name="mx" type="float"/>
                    <param name="my" type="float"/>
                </params>
                <scope line="501"/>
                <scope line="507">
                    <declaration name="cw" type="boolean" line="508"/>
                    <scope line="509"/>
                    <scope line="511"/>
                </scope>
            </method>
            <method name="within" type="boolean" line="525">
                <params>
                    <param name="x1" type="float"/>
                    <param name="y1" type="float"/>
                    <param name="x2" type="float"/>
                    <param name="y2" type="float"/>
                    <param name="ERR" type="float"/>
                </params>
                <comment line="528">
                    compare taxicab distance. ERR will always be small, so using
                     true distance won&apos;t give much benefit                    
                </comment>
                <comment line="530">
                    we want to avoid calling Math.abs                    
                </comment>
                <comment line="531">
                    this is just as good.                    
                </comment>
            </method>
            <method name="getLineOffsets" type="void" line="535">
                <params>
                    <param name="x1" type="float"/>
                    <param name="y1" type="float"/>
                    <param name="x2" type="float"/>
                    <param name="y2" type="float"/>
                    <param name="left" type="float[]"/>
                    <param name="right" type="float[]"/>
                </params>
            </method>
            <method name="computeOffsetCubic" type="int" line="549">
                <params>
                    <param name="pts" type="float[]"/>
                    <param name="off" type="int"/>
                    <param name="leftOff" type="float[]"/>
                    <param name="rightOff" type="float[]"/>
                </params>
                <comment line="551">
                    if p1=p2 or p3=p4 it means that the derivative at the endpoint
                     vanishes, which creates problems with computeOffset. Usually
                     this happens when this stroker object is trying to winden
                     a curve with a cusp. What happens is that curveTo splits
                     the input curve at the cusp, and passes it to this function.
                     because of inaccuracies in the splitting, we consider points
                     equal if they&apos;re very close to each other.                    
                </comment>
                <comment line="568">
                    if p1 == p2 &amp;&amp; p3 == p4: draw line from p1-&gt;p4, unless p1 == p4,
                     in which case ignore if p1 == p2                    
                </comment>
                <comment line="583">
                    if p2-p1 and p4-p3 are parallel, that must mean this curve is a line                    
                </comment>
                <comment line="592">
                    What we&apos;re trying to do in this function is to approximate an ideal
                          offset curve (call it I) of the input curve B using a bezier curve Bp.
                          The constraints I use to get the equations are:
                    
                          1. The computed curve Bp should go through I(0) and I(1). These are
                          x1p, y1p, x4p, y4p, which are p1p and p4p. We still need to find
                          4 variables: the x and y components of p2p and p3p (i.e. x2p, y2p, x3p, y3p).
                    
                          2. Bp should have slope equal in absolute value to I at the endpoints. So,
                          (by the way, the operator || in the comments below means &quot;aligned with&quot;.
                          It is defined on vectors, so when we say I&apos;(0) || Bp&apos;(0) we mean that
                          vectors I&apos;(0) and Bp&apos;(0) are aligned, which is the same as saying
                          that the tangent lines of I and Bp at 0 are parallel. Mathematically
                          this means (I&apos;(t) || Bp&apos;(t)) &lt;==&gt; (I&apos;(t) = c * Bp&apos;(t)) where c is some
                          nonzero constant.)
                          I&apos;(0) || Bp&apos;(0) and I&apos;(1) || Bp&apos;(1). Obviously, I&apos;(0) || B&apos;(0) and
                          I&apos;(1) || B&apos;(1); therefore, Bp&apos;(0) || B&apos;(0) and Bp&apos;(1) || B&apos;(1).
                          We know that Bp&apos;(0) || (p2p-p1p) and Bp&apos;(1) || (p4p-p3p) and the same
                          is true for any bezier curve; therefore, we get the equations
                              (1) p2p = c1 * (p2-p1) + p1p
                              (2) p3p = c2 * (p4-p3) + p4p
                          We know p1p, p4p, p2, p1, p3, and p4; therefore, this reduces the number
                          of unknowns from 4 to 2 (i.e. just c1 and c2).
                          To eliminate these 2 unknowns we use the following constraint:
                    
                          3. Bp(0.5) == I(0.5). Bp(0.5)=(x,y) and I(0.5)=(xi,yi), and I should note
                          that I(0.5) is *the only* reason for computing dxm,dym. This gives us
                              (3) Bp(0.5) = (p1p + 3 * (p2p + p3p) + p4p)/8, which is equivalent to
                              (4) p2p + p3p = (Bp(0.5)*8 - p1p - p4p) / 3
                          We can substitute (1) and (2) from above into (4) and we get:
                              (5) c1*(p2-p1) + c2*(p4-p3) = (Bp(0.5)*8 - p1p - p4p)/3 - p1p - p4p
                          which is equivalent to
                              (6) c1*(p2-p1) + c2*(p4-p3) = (4/3) * (Bp(0.5) * 2 - p1p - p4p)
                    
                          The right side of this is a 2D vector, and we know I(0.5), which gives us
                          Bp(0.5), which gives us the value of the right side.
                          The left side is just a matrix vector multiplication in disguise. It is
                    
                          [x2-x1, x4-x3][c1]
                          [y2-y1, y4-y3][c2]
                          which, is equal to
                          [dx1, dx4][c1]
                          [dy1, dy4][c2]
                          At this point we are left with a simple linear system and we solve it by
                          getting the inverse of the matrix above. Then we use [c1,c2] to compute
                          p2p and p3p.                    
                </comment>
                <comment line="641">
                    (dxm,dym) is some tangent of B at t=0.5. This means it&apos;s equal to
                     c*B&apos;(0.5) for some constant c.                    
                </comment>
                <comment line="645">
                    this computes the offsets at t=0, 0.5, 1, using the property that
                     for any bezier curve the vectors p2-p1 and p4-p3 are parallel to
                     the (dx/dt, dy/dt) vectors at the endpoints.                    
                </comment>
                <comment line="651">
                    start                    
                </comment>
                <comment line="652">
                    point                    
                </comment>
                <comment line="653">
                    interpolation                    
                </comment>
                <comment line="654">
                    point                    
                </comment>
                <comment line="655">
                    end                    
                </comment>
                <comment line="656">
                    point                    
                </comment>
                <declaration name="x1" type="float" line="557"/>
                <declaration name="x2" type="float" line="558"/>
                <declaration name="x3" type="float" line="559"/>
                <declaration name="x4" type="float" line="560"/>
                <declaration name="dx4" type="float" line="562"/>
                <declaration name="dy4" type="float" line="563"/>
                <declaration name="dx1" type="float" line="564"/>
                <declaration name="dy1" type="float" line="565"/>
                <declaration name="p1eqp2" type="boolean" line="569"/>
                <declaration name="p3eqp4" type="boolean" line="570"/>
                <scope line="571"/>
                <scope line="574"/>
                <scope line="577"/>
                <declaration name="dotsq" type="float" line="583"/>
                <declaration name="l1sq" type="float" line="585"/>
                <scope line="586"/>
                <declaration name="x" type="float" line="638"/>
                <declaration name="y" type="float" line="639"/>
                <declaration name="dxm" type="float" line="642"/>
                <declaration name="x1p" type="float" line="650"/>
                <declaration name="y1p" type="float" line="651"/>
                <declaration name="xi" type="float" line="652"/>
                <declaration name="yi" type="float" line="653"/>
                <declaration name="x4p" type="float" line="654"/>
                <declaration name="y4p" type="float" line="655"/>
                <declaration name="invdet43" type="float" line="657"/>
                <declaration name="two_pi_m_p1_m_p4x" type="float" line="659"/>
                <declaration name="two_pi_m_p1_m_p4y" type="float" line="660"/>
                <declaration name="c1" type="float" line="661"/>
                <declaration name="c2" type="float" line="662"/>
                <declaration name="x2p" type="float" line="664"/>
            </method>
            <method name="computeOffsetQuad" type="int" line="699">
                <params>
                    <param name="pts" type="float[]"/>
                    <param name="off" type="int"/>
                    <param name="leftOff" type="float[]"/>
                    <param name="rightOff" type="float[]"/>
                </params>
                <comment line="710">
                    this computes the offsets at t = 0, 1                    
                </comment>
                <comment line="719">
                    start                    
                </comment>
                <comment line="720">
                    point                    
                </comment>
                <comment line="721">
                    end                    
                </comment>
                <comment line="722">
                    point                    
                </comment>
                <comment line="724">
                    Corner cases:
                     1. If the two control vectors are parallel, we&apos;ll end up with NaN&apos;s
                        in leftOff (and rightOff in the body of the if below), so we&apos;ll
                        do getLineOffsets, which is right.
                     2. If the first or second two points are equal, then (dx1,dy1)==(0,0)
                        or (dx3,dy3)==(0,0), so (x1p, y1p)==(x1p+dx1, y1p+dy1)
                        or (x3p, y3p)==(x3p-dx3, y3p-dy3), which means that
                        computeIntersection will put NaN&apos;s in leftOff and right off, and
                        we will do getLineOffsets, which is right.                    
                </comment>
                <comment line="738">
                    maybe the right path is not degenerate.                    
                </comment>
                <comment line="747">
                    both are degenerate. This curve is a line.                    
                </comment>
                <comment line="751">
                    {left,right}Off[0,1,4,5] are already set to the correct values.                    
                </comment>
                <comment line="757">
                    rightOff[2,3] = (x2,y2) - ((left_x2, left_y2) - (x2, y2))
                     == 2*(x2, y2) - (left_x2, left_y2)                    
                </comment>
                <declaration name="x1" type="float" line="700"/>
                <declaration name="x2" type="float" line="701"/>
                <declaration name="x3" type="float" line="702"/>
                <declaration name="dx3" type="float" line="704"/>
                <declaration name="dy3" type="float" line="705"/>
                <declaration name="dx1" type="float" line="706"/>
                <declaration name="dy1" type="float" line="707"/>
                <declaration name="x1p" type="float" line="718"/>
                <declaration name="y1p" type="float" line="719"/>
                <declaration name="x3p" type="float" line="720"/>
                <declaration name="y3p" type="float" line="721"/>
                <declaration name="cx" type="float" line="733"/>
                <declaration name="cy" type="float" line="734"/>
                <scope line="736">
                    <scope line="745"/>
                </scope>
            </method>
            <method name="isFinite" type="boolean" line="763">
                <params>
                    <param name="x" type="float"/>
                </params>
            </method>
            <declaration name="middle" type="float[]" line="770"/>
            <declaration name="lp" type="float[]" line="771"/>
            <declaration name="rp" type="float[]" line="772"/>
            <declaration name="MAX_N_CURVES" type="int" line="773"/>
            <declaration name="subdivTs" type="float[]" line="774"/>
            <declaration name="c" type="Curve" line="780"/>
            <javadoc line="780">
                WORKAROUND 
                  private void somethingTo(final int type) {
                  // need these so we can update the state at the end of this method
                  final float xf = middle[type-2], yf = middle[type-1];
                  float dxs = middle[2] - middle[0];
                  float dys = middle[3] - middle[1];
                  float dxf = middle[type - 2] - middle[type - 4];
                  float dyf = middle[type - 1] - middle[type - 3];
                  switch(type) {
                  case 6:
                  if ((dxs == 0f &amp;&amp; dys == 0f) ||
                  (dxf == 0f &amp;&amp; dyf == 0f)) {
                  dxs = dxf = middle[4] - middle[0];
                  dys = dyf = middle[5] - middle[1];
                  }
                  break;
                  case 8:
                  boolean p1eqp2 = (dxs == 0f &amp;&amp; dys == 0f);
                  boolean p3eqp4 = (dxf == 0f &amp;&amp; dyf == 0f);
                  if (p1eqp2) {
                  dxs = middle[4] - middle[0];
                  dys = middle[5] - middle[1];
                  if (dxs == 0f &amp;&amp; dys == 0f) {
                  dxs = middle[6] - middle[0];
                  dys = middle[7] - middle[1];
                  }
                  }
                  if (p3eqp4) {
                  dxf = middle[6] - middle[2];
                  dyf = middle[7] - middle[3];
                  if (dxf == 0f &amp;&amp; dyf == 0f) {
                  dxf = middle[6] - middle[0];
                  dyf = middle[7] - middle[1];
                  }
                  }
                  }
                  if (dxs == 0f &amp;&amp; dys == 0f) {
                  // this happens iff the &quot;curve&quot; is just a point
                  lineTo(middle[0], middle[1]);
                  return;
                  }
                  // if these vectors are too small, normalize them, to avoid future
                  // precision problems.
                  if (Math.abs(dxs) &lt; 0.1f &amp;&amp; Math.abs(dys) &lt; 0.1f) {
                  float len = (float) sqrt(dxsdxs + dysdys);
                  dxs /= len;
                  dys /= len;
                  }
                  if (Math.abs(dxf) &lt; 0.1f &amp;&amp; Math.abs(dyf) &lt; 0.1f) {
                  float len = (float) sqrt(dxfdxf + dyfdyf);
                  dxf /= len;
                  dyf /= len;
                  }
                  computeOffset(dxs, dys, lineWidth2, offset[0]);
                  final float mx = offset[0][0];
                  final float my = offset[0][1];
                  drawJoin(cdx, cdy, cx0, cy0, dxs, dys, cmx, cmy, mx, my);
                  int nSplits = findSubdivPoints(middle, subdivTs, type, lineWidth2);
                  int kind = 0;
                  Iterator&lt;Integer&gt; it = Curve.breakPtsAtTs(middle, type, subdivTs, nSplits);
                  while(it.hasNext()) {
                  int curCurveOff = it.next();
                  switch (type) {
                  case 8:
                  kind = computeOffsetCubic(middle, curCurveOff, lp, rp);
                  break;
                  case 6:
                  kind = computeOffsetQuad(middle, curCurveOff, lp, rp);
                  break;
                  }
                  emitLineTo(lp[0], lp[1]);
                  switch(kind) {
                  case 8:
                  emitCurveTo(lp[0], lp[1], lp[2], lp[3], lp[4], lp[5], lp[6], lp[7], false);
                  emitCurveTo(rp[0], rp[1], rp[2], rp[3], rp[4], rp[5], rp[6], rp[7], true);
                  break;
                  case 6:
                  emitQuadTo(lp[0], lp[1], lp[2], lp[3], lp[4], lp[5], false);
                  emitQuadTo(rp[0], rp[1], rp[2], rp[3], rp[4], rp[5], true);
                  break;
                  case 4:
                  emitLineTo(lp[2], lp[3]);
                  emitLineTo(rp[0], rp[1], true);
                  break;
                  }
                  emitLineTo(rp[kind - 2], rp[kind - 1], true);
                  }
                  this.cmx = (lp[kind - 2] - rp[kind - 2]) / 2;
                  this.cmy = (lp[kind - 1] - rp[kind - 1]) / 2;
                  this.cdx = dxf;
                  this.cdy = dyf;
                  this.cx0 = xf;
                  this.cy0 = yf;
                  this.prev = DRAWING_OP_TO;
                  }
                  END WORKAROUND                
            </javadoc>
            <method name="findSubdivPoints" type="int" line="887">
                <params>
                    <param name="pts" type="float[]"/>
                    <param name="ts" type="float[]"/>
                    <param name="type" type="int"/>
                    <param name="w" type="float"/>
                </params>
                <comment line="891">
                    if the curve is already parallel to either axis we gain nothing
                     from rotating it.                    
                </comment>
                <comment line="894">
                    we rotate it so that the first vector in the control polygon is
                     parallel to the x-axis. This will ensure that rotated quarter
                     circles won&apos;t be subdivided.                    
                </comment>
                <comment line="921">
                    we subdivide at values of t such that the remaining rotated
                     curves are monotonic in x and y.                    
                </comment>
                <comment line="925">
                    subdivide at inflection points.                    
                </comment>
                <comment line="927">
                    quadratic curves can&apos;t have inflection points                    
                </comment>
                <comment line="931">
                    now we must subdivide at points where one of the offset curves will have
                     a cusp. This happens at ts where the radius of curvature is equal to w.                    
                </comment>
                <declaration name="x12" type="float" line="888"/>
                <declaration name="y12" type="float" line="889"/>
                <scope line="892">
                    <declaration name="hypot" type="float" line="896"/>
                    <declaration name="cos" type="float" line="897"/>
                    <declaration name="sin" type="float" line="898"/>
                    <declaration name="x1" type="float" line="899"/>
                    <declaration name="y1" type="float" line="900"/>
                    <declaration name="x2" type="float" line="901"/>
                    <declaration name="y2" type="float" line="902"/>
                    <declaration name="x3" type="float" line="903"/>
                    <declaration name="y3" type="float" line="904"/>
                    <declaration name="x4" type="float" line="907"/>
                    <declaration name="y4" type="float" line="908"/>
                </scope>
                <scope line="915"/>
                <declaration name="ret" type="int" line="919"/>
                <scope line="925"/>
            </method>
            <method name="curveTo" type="void" line="942">
                <params>
                    <param name="x1" type="float"/>
                    <param name="y1" type="float"/>
                    <param name="x2" type="float"/>
                    <param name="y2" type="float"/>
                    <param name="x3" type="float"/>
                    <param name="y3" type="float"/>
                </params>
                <comment line="949">
                    inlined version of somethingTo(8);
                     See the TODO on somethingTo                    
                </comment>
                <comment line="952">
                    need these so we can update the state at the end of this method                    
                </comment>
                <comment line="978">
                    this happens iff the &quot;curve&quot; is just a point                    
                </comment>
                <comment line="983">
                    if these vectors are too small, normalize them, to avoid future
                     precision problems.                    
                </comment>
                <declaration name="xf" type="float" line="952"/>
                <declaration name="dxs" type="float" line="953"/>
                <declaration name="dys" type="float" line="954"/>
                <declaration name="dxf" type="float" line="955"/>
                <declaration name="dyf" type="float" line="956"/>
                <declaration name="p1eqp2" type="boolean" line="958"/>
                <declaration name="p3eqp4" type="boolean" line="959"/>
                <scope line="960">
                    <scope line="963"/>
                </scope>
                <scope line="968">
                    <scope line="971"/>
                </scope>
                <scope line="976"/>
                <scope line="984">
                    <declaration name="len" type="float" line="985"/>
                </scope>
                <scope line="989">
                    <declaration name="len" type="float" line="990"/>
                </scope>
                <declaration name="mx" type="float" line="996"/>
                <declaration name="my" type="float" line="997"/>
                <declaration name="nSplits" type="int" line="1000"/>
                <declaration name="kind" type="int" line="1002"/>
                <declaration name="it" type="Iterator&lt;Integer&gt;" line="1003"/>
                <scope line="1004">
                    <declaration name="curCurveOff" type="int" line="1005"/>
                </scope>
            </method>
            <method name="quadTo" type="void" line="1031">
                <params>
                    <param name="x1" type="float"/>
                    <param name="y1" type="float"/>
                    <param name="x2" type="float"/>
                    <param name="y2" type="float"/>
                </params>
                <comment line="1037">
                    inlined version of somethingTo(8);
                     See the TODO on somethingTo                    
                </comment>
                <comment line="1040">
                    need these so we can update the state at the end of this method                    
                </comment>
                <comment line="1051">
                    this happens iff the &quot;curve&quot; is just a point                    
                </comment>
                <comment line="1055">
                    if these vectors are too small, normalize them, to avoid future
                     precision problems.                    
                </comment>
                <declaration name="xf" type="float" line="1040"/>
                <declaration name="dxs" type="float" line="1041"/>
                <declaration name="dys" type="float" line="1042"/>
                <declaration name="dxf" type="float" line="1043"/>
                <declaration name="dyf" type="float" line="1044"/>
                <scope line="1045"/>
                <scope line="1049"/>
                <scope line="1056">
                    <declaration name="len" type="float" line="1057"/>
                </scope>
                <scope line="1061">
                    <declaration name="len" type="float" line="1062"/>
                </scope>
                <declaration name="mx" type="float" line="1068"/>
                <declaration name="my" type="float" line="1069"/>
                <declaration name="nSplits" type="int" line="1072"/>
                <declaration name="kind" type="int" line="1074"/>
                <declaration name="it" type="Iterator&lt;Integer&gt;" line="1075"/>
                <scope line="1076">
                    <declaration name="curCurveOff" type="int" line="1077"/>
                </scope>
            </method>
            <method name="getNativeConsumer" type="long" line="1103"/>
            <class name="PolyStack" line="1109">
                <comment line="883">
                    finds values of t where the curve in pts should be subdivided in order
                     to get good offset curves a distance of w away from the middle curve.
                     Stores the points in ts, and returns how many of them there were.                    
                </comment>
                <declaration name="curves" type="float[]" line="1110"/>
                <declaration name="end" type="int" line="1111"/>
                <declaration name="curveTypes" type="int[]" line="1112"/>
                <declaration name="numCurves" type="int" line="1113"/>
                <declaration name="INIT_SIZE" type="int" line="1115"/>
                <method name="PolyStack" type="constructor" line="1117"/>
                <method name="isEmpty" type="boolean" line="1124"/>
                <method name="ensureSpace" type="void" line="1128">
                    <params>
                        <param name="n" type="int"/>
                    </params>
                    <scope line="1129">
                        <declaration name="newSize" type="int" line="1130"/>
                    </scope>
                    <scope line="1133">
                        <declaration name="newSize" type="int" line="1134"/>
                    </scope>
                </method>
                <method name="pushCubic" type="void" line="1142">
                    <params>
                        <param name="x0" type="float"/>
                        <param name="y0" type="float"/>
                        <param name="x1" type="float"/>
                        <param name="y1" type="float"/>
                        <param name="x2" type="float"/>
                        <param name="y2" type="float"/>
                    </params>
                    <comment line="1146">
                        assert(x0 == lastX &amp;&amp; y0 == lastY)                        
                    </comment>
                    <comment line="1148">
                        we reverse the coordinate order to make popping easier                        
                    </comment>
                </method>
                <method name="pushQuad" type="void" line="1155">
                    <params>
                        <param name="x0" type="float"/>
                        <param name="y0" type="float"/>
                        <param name="x1" type="float"/>
                        <param name="y1" type="float"/>
                    </params>
                    <comment line="1159">
                        assert(x0 == lastX &amp;&amp; y0 == lastY)                        
                    </comment>
                </method>
                <method name="pushLine" type="void" line="1163">
                    <params>
                        <param name="x" type="float"/>
                        <param name="y" type="float"/>
                    </params>
                    <comment line="1167">
                        assert(x0 == lastX &amp;&amp; y0 == lastY)                        
                    </comment>
                </method>
                <method name="pop" type="int" line="1171">
                    <params>
                        <param name="pts" type="float[]"/>
                    </params>
                    <declaration name="ret" type="int" line="1172"/>
                </method>
                <method name="pop" type="void" line="1179">
                    <params>
                        <param name="io" type="PathConsumer2D"/>
                    </params>
                    <declaration name="type" type="int" line="1181"/>
                </method>
                <method name="toString" type="String" line="1199">
                    <declaration name="ret" type="String" line="1200"/>
                    <declaration name="nc" type="int" line="1201"/>
                    <declaration name="end" type="int" line="1202"/>
                    <scope line="1203">
                        <declaration name="type" type="int" line="1205"/>
                    </scope>
                </method>
            </class>
        </class>
    </source>