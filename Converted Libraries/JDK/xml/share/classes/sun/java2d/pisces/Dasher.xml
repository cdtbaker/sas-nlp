<?xml version="1.0" encoding="UTF-8"?>
    <source package="sun.java2d.pisces">
        <import package="sun.awt.geom.PathConsumer2D"/>
        <class name="Dasher" line="30">
            <comment line="60">
                temporary storage for the current curve                
            </comment>
            <comment line="136">
                We don&apos;t emit the first dash right away. If we did, caps would be                
            </comment>
            <comment line="137">
                drawn on it, but we need joins to be drawn if there&apos;s a closePath()                
            </comment>
            <comment line="138">
                So, we store the path elements that make up the first dash in the                
            </comment>
            <comment line="139">
                buffer below.                
            </comment>
            <comment line="142">
                precondition: pts must be in relative coordinates (relative to x0,y0)                
            </comment>
            <comment line="143">
                fullCurve is true iff the curve in pts has not been split.                
            </comment>
            <comment line="223">
                preconditions: curCurvepts must be an array of length at least 2 * type,                
            </comment>
            <comment line="224">
                that contains the curve we want to dash in the first type elements                
            </comment>
            <comment line="272">
                Objects of this class are used to iterate through curves. They return                
            </comment>
            <comment line="273">
                t values where the left side of the curve has a specified length.                
            </comment>
            <comment line="274">
                It does this by subdividing the input curve until a certain error                
            </comment>
            <comment line="275">
                condition has been met. A recursive subdivision procedure would                
            </comment>
            <comment line="276">
                return as many as 1&lt;&lt;limit curves, but this is an iterator and we                
            </comment>
            <comment line="277">
                don&apos;t need all the curves all at once, so what we carry out a                
            </comment>
            <comment line="278">
                lazy inorder traversal of the recursion tree (meaning we only move                
            </comment>
            <comment line="279">
                through the tree when we need the next subdivided curve). This saves                
            </comment>
            <comment line="280">
                us a lot of memory because at any one time we only need to store                
            </comment>
            <comment line="281">
                limit+1 curves - one for each level of the tree + 1.                
            </comment>
            <comment line="282">
                NOTE: the way we do things here is not enough to traverse a general                
            </comment>
            <comment line="283">
                tree; however, the trees we are interested in have the property that                
            </comment>
            <comment line="284">
                every non leaf node has exactly 2 children                
            </comment>
            <implements interface="sun.awt.geom.PathConsumer2D"/>
            <javadoc line="30">
                The &lt;code&gt;Dasher&lt;/code&gt; class takes a series of linear commands
                  (&lt;code&gt;moveTo&lt;/code&gt;, &lt;code&gt;lineTo&lt;/code&gt;, &lt;code&gt;close&lt;/code&gt; and
                  &lt;code&gt;end&lt;/code&gt;) and breaks them into smaller segments according to a
                  dash pattern array and a starting dash phase.
                  &lt;p&gt; Issues: in J2Se, a zero length dash segment as drawn as a very
                  short dash, whereas Pisces does not draw anything.  The PostScript
                  semantics are unclear.                
            </javadoc>
            <declaration name="out" type="PathConsumer2D" line="43"/>
            <declaration name="dash" type="float[]" line="44"/>
            <declaration name="startPhase" type="float" line="45"/>
            <declaration name="startDashOn" type="boolean" line="46"/>
            <declaration name="startIdx" type="int" line="47"/>
            <declaration name="starting" type="boolean" line="49"/>
            <declaration name="needsMoveTo" type="boolean" line="50"/>
            <declaration name="idx" type="int" line="52"/>
            <declaration name="dashOn" type="boolean" line="53"/>
            <declaration name="phase" type="float" line="54"/>
            <declaration name="sx" type="float" line="56"/>
            <declaration name="x0" type="float" line="57"/>
            <declaration name="curCurvepts" type="float[]" line="60"/>
            <javadoc line="62">
                Constructs a &lt;code&gt;Dasher&lt;/code&gt;.                
                <param>
                    out an output <code>PathConsumer2D</code>.                    
                </param>
                <param>
                    dash an array of <code>float</code>s containing the dash pattern                    
                </param>
                <param>
                    phase a <code>float</code> containing the dash phase                    
                </param>
            </javadoc>
            <method name="Dasher" type="constructor" line="69">
                <params>
                    <param name="out" type="PathConsumer2D"/>
                    <param name="dash" type="float[]"/>
                    <param name="phase" type="float"/>
                </params>
                <comment line="76">
                    Normalize so 0 &lt;= phase &lt; dash[0]                    
                </comment>
                <comment line="92">
                    we need curCurvepts to be able to contain 2 curves because when                    
                </comment>
                <comment line="93">
                    dashing curves, we need to subdivide it                    
                </comment>
                <scope line="70"/>
                <declaration name="idx" type="int" line="77"/>
                <declaration name="d" type="float" line="79"/>
                <scope line="80"/>
            </method>
            <method name="moveTo" type="void" line="97">
                <params>
                    <param name="x0" type="float"/>
                    <param name="y0" type="float"/>
                </params>
                <scope line="98"/>
            </method>
            <method name="emitSeg" type="void" line="111">
                <params>
                    <param name="buf" type="float[]"/>
                    <param name="off" type="int"/>
                    <param name="type" type="int"/>
                </params>
            </method>
            <method name="emitFirstSegments" type="void" line="127">
                <scope line="128"/>
            </method>
            <declaration name="firstSegmentsBuffer" type="float[]" line="139"/>
            <declaration name="firstSegidx" type="int" line="140"/>
            <method name="goTo" type="void" line="143">
                <params>
                    <param name="pts" type="float[]"/>
                    <param name="off" type="int"/>
                    <param name="type" type="int"/>
                </params>
                <declaration name="x" type="float" line="144"/>
                <declaration name="y" type="float" line="145"/>
                <scope line="146">
                    <scope line="147"/>
                    <scope line="153">
                        <scope line="154"/>
                    </scope>
                </scope>
                <scope line="160"/>
            </method>
            <method name="lineTo" type="void" line="168">
                <params>
                    <param name="x1" type="float"/>
                    <param name="y1" type="float"/>
                </params>
                <comment line="178">
                    The scaling factors needed to get the dx and dy of the                    
                </comment>
                <comment line="179">
                    transformed dash segments.                    
                </comment>
                <comment line="189">
                    Advance phase within current dash segment                    
                </comment>
                <comment line="213">
                    Advance to next dash segment                    
                </comment>
                <declaration name="dx" type="float" line="169"/>
                <declaration name="dy" type="float" line="170"/>
                <declaration name="len" type="float" line="172"/>
                <scope line="174"/>
                <declaration name="cx" type="float" line="180"/>
                <declaration name="cy" type="float" line="181"/>
                <scope line="183">
                    <declaration name="leftInThisDashSegment" type="float" line="184"/>
                    <scope line="185">
                        <scope line="191"/>
                    </scope>
                    <declaration name="dashdx" type="float" line="199"/>
                    <declaration name="dashdy" type="float" line="200"/>
                    <scope line="201"/>
                    <scope line="204">
                        <declaration name="p" type="float" line="205"/>
                    </scope>
                </scope>
            </method>
            <declaration name="li" type="LengthIterator" line="220"/>
            <method name="somethingTo" type="void" line="224">
                <params>
                    <param name="type" type="int"/>
                </params>
                <comment line="233">
                    initially the current curve is at curCurvepts[0...type]                    
                </comment>
                <comment line="247">
                    Advance to next dash segment                    
                </comment>
                <scope line="225"/>
                <scope line="228"/>
                <declaration name="curCurveoff" type="int" line="233"/>
                <declaration name="lastSplitT" type="float" line="234"/>
                <declaration name="t" type="float" line="235"/>
                <declaration name="leftInThisDashSegment" type="float" line="236"/>
                <scope line="237">
                    <scope line="238"/>
                </scope>
                <scope line="255"/>
            </method>
            <method name="pointCurve" type="boolean" line="262">
                <params>
                    <param name="curve" type="float[]"/>
                    <param name="type" type="int"/>
                </params>
                <scope line="263">
                    <scope line="264"/>
                </scope>
            </method>
            <class name="LengthIterator" line="284">
                <comment line="287">
                    Holds the curves at various levels of the recursion. The root                    
                </comment>
                <comment line="288">
                    (i.e. the original curve) is at recCurveStack[0] (but then it                    
                </comment>
                <comment line="289">
                    gets subdivided, the left half is put at 1, so most of the time                    
                </comment>
                <comment line="290">
                    only the right half of the original curve is at 0)                    
                </comment>
                <comment line="292">
                    sides[i] indicates whether the node at level i+1 in the path from                    
                </comment>
                <comment line="293">
                    the root to the current leaf is a left or right child of its parent.                    
                </comment>
                <comment line="299">
                    lastT and nextT delimit the current leaf.                    
                </comment>
                <comment line="306">
                    the current level in the recursion tree. 0 is the root. limit                    
                </comment>
                <comment line="307">
                    is the deepest possible leaf.                    
                </comment>
                <comment line="311">
                    the lengths of the lines of the control polygon. Only its first                    
                </comment>
                <comment line="312">
                    curveType/2 - 1 elements are valid. This is an optimization. See                    
                </comment>
                <comment line="313">
                    next(float) for more detail.                    
                </comment>
                <comment line="353">
                    0 == false, 1 == true, -1 == invalid cached value.                    
                </comment>
                <comment line="385">
                    we want to avoid allocations/gc so we keep this array so we                    
                </comment>
                <comment line="386">
                    can put roots in it,                    
                </comment>
                <comment line="389">
                    caches the coefficients of the current leaf in its flattened                    
                </comment>
                <comment line="390">
                    form (see inside next() for what that means). The cache is                    
                </comment>
                <comment line="391">
                    invalid when it&apos;s third element is negative, since in any                    
                </comment>
                <comment line="392">
                    valid flattened curve, this would be &gt;= 0.                    
                </comment>
                <comment line="394">
                    returns the t value where the remaining curve should be split in                    
                </comment>
                <comment line="395">
                    order for the left subdivided curve to have length len. If len                    
                </comment>
                <comment line="396">
                    is &gt;= than the length of the uniterated curve, it returns 1.                    
                </comment>
                <comment line="467">
                    go to the next leaf (in an inorder traversal) in the recursion tree                    
                </comment>
                <comment line="468">
                    preconditions: must be on a leaf, and that leaf must not be the root.                    
                </comment>
                <comment line="487">
                    go to the leftmost node from the current node. Return its length.                    
                </comment>
                <comment line="508">
                    this is a bit of a hack. It returns -1 if we&apos;re not on a leaf, and                    
                </comment>
                <comment line="509">
                    the length of the leaf if we are on a leaf.                    
                </comment>
                <declaration name="recCurveStack" type="float[][]" line="290"/>
                <declaration name="sides" type="Side[]" line="293"/>
                <declaration name="curveType" type="int" line="294"/>
                <declaration name="limit" type="int" line="295"/>
                <declaration name="ERR" type="float" line="296"/>
                <declaration name="minTincrement" type="float" line="297"/>
                <declaration name="nextT" type="float" line="299"/>
                <declaration name="lenAtNextT" type="float" line="300"/>
                <declaration name="lastT" type="float" line="301"/>
                <declaration name="lenAtLastT" type="float" line="302"/>
                <declaration name="lenAtLastSplit" type="float" line="303"/>
                <declaration name="lastSegLen" type="float" line="304"/>
                <declaration name="recLevel" type="int" line="307"/>
                <declaration name="done" type="boolean" line="308"/>
                <declaration name="curLeafCtrlPolyLengths" type="float[]" line="313"/>
                <method name="LengthIterator" type="constructor" line="315">
                    <params>
                        <param name="reclimit" type="int"/>
                        <param name="err" type="float"/>
                    </params>
                    <comment line="321">
                        if any methods are called without first initializing this object on                        
                    </comment>
                    <comment line="322">
                        a curve, we want it to fail ASAP.                        
                    </comment>
                </method>
                <method name="initializeIterationOnCurve" type="void" line="331">
                    <params>
                        <param name="pts" type="float[]"/>
                        <param name="type" type="int"/>
                    </params>
                    <comment line="339">
                        initializes nextT and lenAtNextT properly                        
                    </comment>
                    <comment line="345">
                        the root of the tree is a leaf so we&apos;re done.                        
                    </comment>
                    <scope line="341"/>
                    <scope line="344"/>
                </method>
                <declaration name="cachedHaveLowAcceleration" type="int" line="353"/>
                <method name="haveLowAcceleration" type="boolean" line="355">
                    <params>
                        <param name="err" type="float"/>
                    </params>
                    <comment line="359">
                        the test below is equivalent to !within(len1/len2, 1, err).                        
                    </comment>
                    <comment line="360">
                        It is using a multiplication instead of a division, so it                        
                    </comment>
                    <comment line="361">
                        should be a bit faster.                        
                    </comment>
                    <comment line="368">
                        if len1 is close to 2 and 2 is close to 3, that probably                        
                    </comment>
                    <comment line="369">
                        means 1 is close to 3 so the second part of this test might                        
                    </comment>
                    <comment line="370">
                        not be needed, but it doesn&apos;t hurt to include it.                        
                    </comment>
                    <scope line="356">
                        <declaration name="len1" type="float" line="357"/>
                        <declaration name="len2" type="float" line="358"/>
                        <scope line="362"/>
                        <scope line="366">
                            <declaration name="len3" type="float" line="367"/>
                            <scope line="372"/>
                        </scope>
                    </scope>
                </method>
                <declaration name="nextRoots" type="float[]" line="386"/>
                <declaration name="flatLeafCoefCache" type="float[]" line="392"/>
                <method name="next" type="float" line="396">
                    <params>
                        <param name="len" type="float"/>
                    </params>
                    <comment line="409">
                        cubicRootsInAB is a fairly expensive call, so we just don&apos;t do it                        
                    </comment>
                    <comment line="410">
                        if the acceleration in this section of the curve is small enough.                        
                    </comment>
                    <comment line="412">
                        We flatten the current leaf along the x axis, so that we&apos;re                        
                    </comment>
                    <comment line="413">
                        left with a, b, c which define a 1D Bezier curve. We then                        
                    </comment>
                    <comment line="414">
                        solve this to get the parameter of the original leaf that                        
                    </comment>
                    <comment line="415">
                        gives us the desired length.                        
                    </comment>
                    <comment line="438">
                        we use cubicRootsInAB here, because we want only roots in 0, 1,                        
                    </comment>
                    <comment line="439">
                        and our quadratic root finder doesn&apos;t filter, so it&apos;s just a                        
                    </comment>
                    <comment line="440">
                        matter of convenience.                        
                    </comment>
                    <comment line="446">
                        t is relative to the current leaf, so we must make it a valid parameter                        
                    </comment>
                    <comment line="447">
                        of the original curve.                        
                    </comment>
                    <comment line="453">
                        even if done = true, if we&apos;re here, that means targetLength                        
                    </comment>
                    <comment line="454">
                        is equal to, or very, very close to the total length of the                        
                    </comment>
                    <comment line="455">
                        curve, so lastSegLen won&apos;t be too high. In cases where len                        
                    </comment>
                    <comment line="456">
                        overshoots the curve, this method will exit in the while                        
                    </comment>
                    <comment line="457">
                        loop, and lastSegLen will still be set to the right value.                        
                    </comment>
                    <declaration name="targetLength" type="float" line="397"/>
                    <scope line="398">
                        <scope line="399"/>
                    </scope>
                    <declaration name="leaflen" type="float" line="406"/>
                    <declaration name="t" type="float" line="407"/>
                    <scope line="411">
                        <scope line="417">
                            <declaration name="x" type="float" line="418"/>
                            <scope line="420">
                                <declaration name="z" type="float" line="421"/>
                            </scope>
                            <scope line="426"/>
                        </scope>
                        <declaration name="a" type="float" line="433"/>
                        <declaration name="b" type="float" line="434"/>
                        <declaration name="c" type="float" line="435"/>
                        <declaration name="d" type="float" line="436"/>
                        <declaration name="n" type="int" line="441"/>
                        <scope line="442"/>
                    </scope>
                    <scope line="449"/>
                </method>
                <method name="lastSegLen" type="float" line="462"/>
                <method name="goToNextLeaf" type="void" line="468">
                    <comment line="469">
                        We must go to the first ancestor node that has an unvisited                        
                    </comment>
                    <comment line="470">
                        right child.                        
                    </comment>
                    <scope line="472">
                        <scope line="473"/>
                    </scope>
                </method>
                <method name="goLeft" type="void" line="487">
                    <comment line="494">
                        invalidate caches                        
                    </comment>
                    <declaration name="len" type="float" line="488"/>
                    <scope line="489"/>
                    <scope line="497"/>
                </method>
                <method name="onLeaf" type="float" line="509">
                    <declaration name="curve" type="float[]" line="510"/>
                    <declaration name="polyLen" type="float" line="511"/>
                    <declaration name="x0" type="float" line="513"/>
                    <scope line="514">
                        <declaration name="x1" type="float" line="515"/>
                        <declaration name="len" type="float" line="516"/>
                    </scope>
                    <declaration name="lineLen" type="float" line="523"/>
                    <scope line="524"/>
                </method>
            </class>
            <method name="curveTo" type="void" line="535">
                <params>
                    <param name="x1" type="float"/>
                    <param name="y1" type="float"/>
                    <param name="x2" type="float"/>
                    <param name="y2" type="float"/>
                    <param name="x3" type="float"/>
                    <param name="y3" type="float"/>
                </params>
            </method>
            <method name="quadTo" type="void" line="544">
                <params>
                    <param name="x1" type="float"/>
                    <param name="y1" type="float"/>
                    <param name="x2" type="float"/>
                    <param name="y2" type="float"/>
                </params>
            </method>
            <method name="closePath" type="void" line="551">
                <scope line="553">
                    <scope line="554"/>
                </scope>
            </method>
            <method name="pathDone" type="void" line="562">
                <scope line="563"/>
            </method>
            <method name="getNativeConsumer" type="long" line="571"/>
        </class>
    </source>