<?xml version="1.0" encoding="UTF-8"?>
    <source package="sun.java2d.pisces">
        <import package="java.util.Arrays"/>
        <class name="PiscesCache" line="30">
            <comment line="40">
                rowAARLE[i] holds the encoding of the pixel row with y = bboxY0+i.
                 The format of each of the inner arrays is: rowAARLE[i][0,1] = (x0, n)
                 where x0 is the first x in row i with nonzero alpha, and n is the
                 number of RLE entries in this row. rowAARLE[i][j,j+1] for j&gt;1 is
                 (val,runlen)                
            </comment>
            <comment line="47">
                RLE encodings are added in increasing y rows and then in increasing
                 x inside those rows. Therefore, at any one time there is a well
                 defined position (x,y) where a run length is about to be added (or
                 the row terminated). x0,y0 is this (x,y)-(bboxX0,bboxY0). They
                 are used to get indices into the current tile.                
            </comment>
            <comment line="54">
                touchedTile[i][j] is the sum of all the alphas in the tile with
                 y=i*TILE_SIZE+bboxY0 and x=j*TILE_SIZE+bboxX0.                
            </comment>
            <comment line="59">
                32                
            </comment>
            <comment line="60">
                enough for 3 run lengths                
            </comment>
            <javadoc line="30">
                An object used to cache pre-rendered complex paths.                
                <see>
                    PiscesRenderer#render                    
                </see>
            </javadoc>
            <declaration name="bboxX0" type="int" line="37"/>
            <declaration name="rowAARLE" type="int[][]" line="44"/>
            <declaration name="x0" type="int" line="51"/>
            <declaration name="touchedTile" type="int[][]" line="55"/>
            <declaration name="TILE_SIZE_LG" type="int" line="57"/>
            <declaration name="TILE_SIZE" type="int" line="58"/>
            <declaration name="INIT_ROW_SIZE" type="int" line="59"/>
            <method name="PiscesCache" type="constructor" line="61">
                <params>
                    <param name="minx" type="int"/>
                    <param name="miny" type="int"/>
                    <param name="maxx" type="int"/>
                    <param name="maxy" type="int"/>
                </params>
                <comment line="68">
                    we could just leave the inner arrays as null and allocate them
                     lazily (which would be beneficial for shapes with gaps), but we
                     assume there won&apos;t be too many of those so we allocate everything
                     up front (which is better for other cases)                    
                </comment>
                <comment line="74">
                    -1 makes the first assert in startRow succeed                    
                </comment>
                <comment line="75">
                    the ceiling of (maxy - miny + 1) / TILE_SIZE;                    
                </comment>
                <declaration name="nyTiles" type="int" line="75"/>
                <declaration name="nxTiles" type="int" line="76"/>
            </method>
            <method name="addRLERun" type="void" line="81">
                <params>
                    <param name="val" type="int"/>
                    <param name="runLen" type="int"/>
                </params>
                <comment line="86">
                    the x and y of the current row, minus bboxX0, bboxY0                    
                </comment>
                <comment line="90">
                    while we forbid rows from starting before bboxx0, our users
                     can still store rows that go beyond bboxx1 (although this
                     shouldn&apos;t happen), so it&apos;s a good idea to check that i
                     is not going out of bounds in touchedTile[ty]                    
                </comment>
                <comment line="106">
                    don&apos;t go all the way to tx1 - we need to handle the last
                     tile as a special case (just like we did with the first                    
                </comment>
                <comment line="109">
                    try {                    
                </comment>
                <comment line="111">
                    } catch (RuntimeException e) {
                                            System.out.println(&quot;x0, y0: &quot; + x0 + &quot;, &quot; + y0);
                                            System.out.printf(&quot;tx, ty, tx1: %d, %d, %d %n&quot;, tx, ty, tx1);
                                            System.out.printf(&quot;bboxX/Y0/1: %d, %d, %d, %d %n&quot;,
                                                    bboxX0, bboxY0, bboxX1, bboxY1);
                                            throw e;
                                        }                    
                </comment>
                <comment line="119">
                    they will be equal unless x0&gt;&gt;TILE_SIZE_LG == tx1                    
                </comment>
                <scope line="82">
                    <scope line="84">
                        <declaration name="tx" type="int" line="86"/>
                        <declaration name="ty" type="int" line="87"/>
                        <declaration name="tx1" type="int" line="88"/>
                        <scope line="93"/>
                        <scope line="96">
                            <declaration name="nextTileXCoord" type="int" line="97"/>
                            <scope line="98"/>
                            <scope line="100"/>
                        </scope>
                        <scope line="107"/>
                        <scope line="119">
                            <declaration name="lastXCoord" type="int" line="120"/>
                            <declaration name="txXCoord" type="int" line="121"/>
                        </scope>
                    </scope>
                </scope>
            </method>
            <method name="startRow" type="void" line="129">
                <params>
                    <param name="y" type="int"/>
                    <param name="x" type="int"/>
                </params>
                <comment line="131">
                    rows are supposed to be added by increasing y.                    
                </comment>
                <comment line="133">
                    perhaps this should be &lt; instead of &lt;=                    
                </comment>
                <comment line="136">
                    this should be a new, uninitialized row.                    
                </comment>
                <comment line="142">
                    the way addTupleToRow is implemented it would work for this but it&apos;s
                     not a good idea to use it because it is meant for adding
                     RLE tuples, not the first tuple (which is special).                    
                </comment>
            </method>
            <method name="alphaSumInTile" type="int" line="148">
                <params>
                    <param name="x" type="int"/>
                    <param name="y" type="int"/>
                </params>
            </method>
            <method name="minTouched" type="int" line="154">
                <params>
                    <param name="rowidx" type="int"/>
                </params>
            </method>
            <method name="rowLength" type="int" line="158">
                <params>
                    <param name="rowidx" type="int"/>
                </params>
            </method>
            <method name="addTupleToRow" type="void" line="162">
                <params>
                    <param name="row" type="int"/>
                    <param name="a" type="int"/>
                    <param name="b" type="int"/>
                </params>
                <declaration name="end" type="int" line="163"/>
            </method>
            <method name="toString" type="String" line="171">
                <declaration name="ret" type="String" line="172"/>
                <scope line="175">
                    <scope line="176"/>
                    <scope line="180"/>
                </scope>
            </method>
        </class>
    </source>