<?xml version="1.0" encoding="UTF-8"?>
    <source package="sun.misc">
        <import package="java.io.PushbackInputStream"/>
        <import package="java.io.OutputStream"/>
        <import package="java.io.PrintStream"/>
        <import package="java.io.IOException"/>
        <class name="UUDecoder" line="32">
            <extends class="CharacterDecoder"/>
            <javadoc line="32">
                This class implements a Berkeley uu character decoder. This decoder
                  was made famous by the uudecode program.
                  The basic character coding is algorithmic, taking 6 bits of binary
                  data and adding it to an ASCII &apos; &apos; (space) character. This converts
                  these six bits into a printable representation. Note that it depends
                  on the ASCII character encoding standard for english. Groups of three
                  bytes are converted into 4 characters by treating the three bytes
                  a four 6 bit groups, group 1 is byte 1&apos;s most significant six bits,
                  group 2 is byte 1&apos;s least significant two bits plus byte 2&apos;s four
                  most significant bits. etc.
                  In this encoding, the buffer prefix is:
                  &lt;pre&gt;
                  begin [mode] [filename]
                  &lt;/pre&gt;
                  This is followed by one or more lines of the form:
                  &lt;pre&gt;
                  (len)(data)(data)(data) ...
                  &lt;/pre&gt;
                  where (len) is the number of bytes on this line. Note that groupings
                  are always four characters, even if length is not a multiple of three
                  bytes. When less than three characters are encoded, the values of the
                  last remaining bytes is undefined and should be ignored.
                  The last line of data in a uuencoded buffer is represented by a single
                  space character. This is translated by the decoding engine to a line
                  length of zero. This is immediately followed by a line which contains
                  the word &apos;end[newline]&apos;
                  If an error is encountered during decoding this class throws a
                  CEFormatException. The specific detail messages are:
                  &lt;pre&gt;
                  &quot;UUDecoder: No begin line.&quot;
                  &quot;UUDecoder: Malformed begin line.&quot;
                  &quot;UUDecoder: Short Buffer.&quot;
                  &quot;UUDecoder: Bad Line Length.&quot;
                  &quot;UUDecoder: Missing &apos;end&apos; line.&quot;
                  &lt;/pre&gt;                
                <author>
                    Chuck McManis                    
                </author>
                <see>
                    CharacterDecoder                    
                </see>
                <see>
                    UUEncoder                    
                </see>
            </javadoc>
            <declaration name="bufferName" type="String" line="81"/>
            <javadoc line="81">
                This string contains the name that was in the buffer being decoded.                
            </javadoc>
            <declaration name="mode" type="int" line="86"/>
            <javadoc line="86">
                Represents UNIX(tm) mode bits. Generally three octal digits
                  representing read, write, and execute permission of the owner,
                  group owner, and  others. They should be interpreted as the bit groups:
                  &lt;pre&gt;
                  (owner) (group) (others)
                  rwx      rwx     rwx    (r = read, w = write, x = execute)
                  &lt;/pre&gt;                
            </javadoc>
            <javadoc line="99">
                UU encoding specifies 3 bytes per atom.                
            </javadoc>
            <method name="bytesPerAtom" type="int" line="102"/>
            <javadoc line="106">
                All UU lines have 45 bytes on them, for line length of 154+1 or 61
                  characters per line.                
            </javadoc>
            <method name="bytesPerLine" type="int" line="110"/>
            <declaration name="decoderBuffer" type="byte" line="114"/>
            <javadoc line="114">
                This is used to decode the atoms                
            </javadoc>
            <javadoc line="117">
                Decode a UU atom. Note that if l is less than 3 we don&apos;t write
                  the extra bits, however the encoder always encodes 4 character
                  groups even when they are not needed.                
            </javadoc>
            <method name="decodeAtom" type="void" line="123">
                <params>
                    <param name="inStream" type="PushbackInputStream"/>
                    <param name="outStream" type="OutputStream"/>
                    <param name="l" type="int"/>
                </params>
                <declaration name="i" type="int" line="124"/>
                <declaration name="a" type="int" line="125"/>
                <declaration name="x" type="StringBuffer" line="126"/>
                <scope line="128">
                    <scope line="130"/>
                </scope>
                <scope line="140"/>
                <scope line="143"/>
            </method>
            <javadoc line="148">
                For uuencoded buffers, the data begins with a line of the form:
                  begin MODE FILENAME
                  This line always starts in column 1.                
            </javadoc>
            <method name="decodeBufferPrefix" type="void" line="153">
                <params>
                    <param name="inStream" type="PushbackInputStream"/>
                    <param name="outStream" type="OutputStream"/>
                </params>
                <comment line="159">
                    This works by ripping through the buffer until it finds a &apos;begin&apos;
                     line or the end of the buffer.                    
                </comment>
                <comment line="178">
                    Now we think its begin, (we&apos;ve seen ^be) so verify it here.                    
                </comment>
                <comment line="196">
                    Check for \n after \r                    
                </comment>
                <declaration name="c" type="int" line="154"/>
                <declaration name="q" type="StringBuffer" line="155"/>
                <declaration name="r" type="String" line="156"/>
                <declaration name="sawNewLine" type="boolean" line="157"/>
                <scope line="164">
                    <scope line="166"/>
                    <scope line="169">
                        <scope line="171"/>
                    </scope>
                </scope>
                <scope line="181">
                    <scope line="183"/>
                    <scope line="186"/>
                </scope>
                <scope line="191"/>
                <scope line="199"/>
            </method>
            <javadoc line="206">
                In uuencoded buffers, encoded lines start with a character that
                  represents the number of bytes encoded in this line. The last
                  line of input is always a line that starts with a single space
                  character, which would be a zero length line.                
            </javadoc>
            <method name="decodeLinePrefix" type="int" line="212">
                <params>
                    <param name="inStream" type="PushbackInputStream"/>
                    <param name="outStream" type="OutputStream"/>
                </params>
                <comment line="217">
                                        
                </comment>
                <comment line="218">
                                        
                </comment>
                <declaration name="c" type="int" line="213"/>
                <scope line="216"/>
                <scope line="222"/>
                <scope line="227"/>
            </method>
            <javadoc line="234">
                Find the end of the line for the next operation.
                  The following sequences are recognized as end-of-line
                  CR, CR LF, or LF                
            </javadoc>
            <method name="decodeLineSuffix" type="void" line="239">
                <params>
                    <param name="inStream" type="PushbackInputStream"/>
                    <param name="outStream" type="OutputStream"/>
                </params>
                <declaration name="c" type="int" line="240"/>
                <scope line="241">
                    <scope line="243"/>
                    <scope line="246"/>
                    <scope line="249">
                        <scope line="251"/>
                    </scope>
                </scope>
            </method>
            <javadoc line="259">
                UUencoded files have a buffer suffix which consists of the word
                  end. This line should immediately follow the line with a single
                  space in it.                
            </javadoc>
            <method name="decodeBufferSuffix" type="void" line="264">
                <params>
                    <param name="inStream" type="PushbackInputStream"/>
                    <param name="outStream" type="OutputStream"/>
                </params>
                <declaration name="c" type="int" line="265"/>
                <scope line="269"/>
            </method>
        </class>
    </source>