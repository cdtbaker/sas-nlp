<?xml version="1.0" encoding="UTF-8"?>
    <source package="sun.misc">
        <import package="java.security"/>
        <import package="java.lang.reflect"/>
        <class name="Unsafe" line="32">
            <comment line="91">
                / peek and poke operations
                / (compilers should optimize these to memory ops)                
            </comment>
            <comment line="94">
                These work on object fields in the Java heap.
                 They will not work on elements of packed arrays.                
            </comment>
            <comment line="388">
                These work on values in the C heap.                
            </comment>
            <comment line="461">
                / wrappers for malloc, realloc, free:                
            </comment>
            <comment line="569">
                / random queries                
            </comment>
            <comment line="803">
                / random trusted operations from JNI:                
            </comment>
            <javadoc line="32">
                A collection of methods for performing low-level, unsafe operations.
                  Although the class and all methods are public, use of this class is
                  limited because only trusted code can obtain instances of it.                
                <author>
                    John R. Rose                    
                </author>
                <see>
                    #getUnsafe                    
                </see>
            </javadoc>
            <method name="registerNatives" type="void" line="43"/>
            <scope line="44"/>
            <method name="Unsafe" type="constructor" line="49"/>
            <declaration name="theUnsafe" type="Unsafe" line="51"/>
            <javadoc line="53">
                Provides the caller with the capability of performing unsafe
                  operations.
                  &lt;p&gt; The returned &lt;code&gt;Unsafe&lt;/code&gt; object should be carefully guarded
                  by the caller, since it can be used to read and write data at arbitrary
                  memory addresses.  It must never be passed to untrusted code.
                  &lt;p&gt; Most methods in this class are very low-level, and correspond to a
                  small number of hardware instructions (on typical machines).  Compilers
                  are encouraged to optimize these methods accordingly.
                  &lt;p&gt; Here is a suggested idiom for using unsafe operations:
                  &lt;blockquote&gt;&lt;pre&gt;
                  class MyTrustedClass {
                  private static final Unsafe unsafe = Unsafe.getUnsafe();
                  ...
                  private long myCountAddress = ...;
                  public int getCount() { return unsafe.getByte(myCountAddress); }
                  }
                  &lt;/pre&gt;&lt;/blockquote&gt;
                  (It may assist compilers to make the local variable be
                  &lt;code&gt;final&lt;/code&gt;.)                
                <exception>
                    SecurityException  if a security manager exists and its
                      <code>checkPropertiesAccess</code> method doesn't allow
                      access to the system properties.                    
                </exception>
            </javadoc>
            <method name="getUnsafe" type="Unsafe" line="83">
                <declaration name="cc" type="Class" line="84"/>
            </method>
            <method name="getInt" type="int" line="96"/>
            <javadoc line="96">
                Fetches a value from a given Java variable.
                  More specifically, fetches a field or array element within the given
                  object &lt;code&gt;o&lt;/code&gt; at the given offset, or (if &lt;code&gt;o&lt;/code&gt; is
                  null) from the memory address whose numerical value is the given
                  offset.
                  &lt;p&gt;
                  The results are undefined unless one of the following cases is true:
                  &lt;ul&gt;
                  &lt;li&gt;The offset was obtained from {@link #objectFieldOffset} on
                  the {@link java.lang.reflect.Field} of some Java field and the object
                  referred to by &lt;code&gt;o&lt;/code&gt; is of a class compatible with that
                  field&apos;s class.
                  &lt;li&gt;The offset and object reference &lt;code&gt;o&lt;/code&gt; (either null or
                  non-null) were both obtained via {@link #staticFieldOffset}and {@link #staticFieldBase} (respectively) from the
                  reflective {@link Field} representation of some Java field.
                  &lt;li&gt;The object referred to by &lt;code&gt;o&lt;/code&gt; is an array, and the offset
                  is an integer of the form &lt;code&gt;B+NS&lt;/code&gt;, where &lt;code&gt;N&lt;/code&gt; is
                  a valid index into the array, and &lt;code&gt;B&lt;/code&gt; and &lt;code&gt;S&lt;/code&gt; are
                  the values obtained by {@link #arrayBaseOffset} and {@link #arrayIndexScale} (respectively) from the array&apos;s class.  The value
                  referred to is the &lt;code&gt;N&lt;/code&gt;&lt;em&gt;th&lt;/em&gt; element of the array.
                  &lt;/ul&gt;
                  &lt;p&gt;
                  If one of the above cases is true, the call references a specific Java
                  variable (field or array element).  However, the results are undefined
                  if that variable is not in fact of the type returned by this method.
                  &lt;p&gt;
                  This method refers to a variable by means of two parameters, and so
                  it provides (in effect) a &lt;em&gt;double-register&lt;/em&gt; addressing mode
                  for Java variables.  When the object reference is null, this method
                  uses its offset as an absolute address.  This is similar in operation
                  to methods such as {@link #getInt(long)}, which provide (in effect) a
                  &lt;em&gt;single-register&lt;/em&gt; addressing mode for non-Java variables.
                  However, because Java variables may have a different layout in memory
                  from non-Java variables, programmers should not assume that these
                  two addressing modes are ever equivalent.  Also, programmers should
                  remember that offsets from the double-register addressing mode cannot
                  be portably confused with longs used in the single-register addressing
                  mode.                
                <param>
                    o Java heap object in which the variable resides, if any, else
                      null                    
                </param>
                <param>
                    offset indication of where the variable resides in a Java heap
                      object, if any, else a memory address locating the variable
                      statically                    
                </param>
                <return>
                    the value fetched from the indicated Java variable                    
                </return>
                <throws>
                    RuntimeException No defined exceptions are thrown, not even{@link NullPointerException}                    
                </throws>
            </javadoc>
            <method name="putInt" type="void" line="152"/>
            <javadoc line="152">
                Stores a value into a given Java variable.
                  &lt;p&gt;
                  The first two parameters are interpreted exactly as with{@link #getInt(Object,long)} to refer to a specific
                  Java variable (field or array element).  The given value
                  is stored into that variable.
                  &lt;p&gt;
                  The variable must be of the same type as the method
                  parameter &lt;code&gt;x&lt;/code&gt;.                
                <param>
                    o Java heap object in which the variable resides, if any, else
                      null                    
                </param>
                <param>
                    offset indication of where the variable resides in a Java heap
                      object, if any, else a memory address locating the variable
                      statically                    
                </param>
                <param>
                    x the value to store into the indicated Java variable                    
                </param>
                <throws>
                    RuntimeException No defined exceptions are thrown, not even{@link NullPointerException}                    
                </throws>
            </javadoc>
            <method name="getObject" type="Object" line="174"/>
            <javadoc line="174">
                Fetches a reference value from a given Java variable.                
                <see>
                    #getInt(Object,long)                    
                </see>
            </javadoc>
            <method name="putObject" type="void" line="180"/>
            <javadoc line="180">
                Stores a reference value into a given Java variable.
                  &lt;p&gt;
                  Unless the reference &lt;code&gt;x&lt;/code&gt; being stored is either null
                  or matches the field type, the results are undefined.
                  If the reference &lt;code&gt;o&lt;/code&gt; is non-null, car marks or
                  other store barriers for that object (if the VM requires them)
                  are updated.                
                <see>
                    #putInt(Object,int,int)                    
                </see>
            </javadoc>
            <method name="getBoolean" type="boolean" line="192"/>
            <javadoc line="192">
                @see #getInt(Object,long)                
            </javadoc>
            <method name="putBoolean" type="void" line="194"/>
            <javadoc line="194">
                @see #putInt(Object,int,int)                
            </javadoc>
            <method name="getByte" type="byte" line="196"/>
            <javadoc line="196">
                @see #getInt(Object,long)                
            </javadoc>
            <method name="putByte" type="void" line="198"/>
            <javadoc line="198">
                @see #putInt(Object,int,int)                
            </javadoc>
            <method name="getShort" type="short" line="200"/>
            <javadoc line="200">
                @see #getInt(Object,long)                
            </javadoc>
            <method name="putShort" type="void" line="202"/>
            <javadoc line="202">
                @see #putInt(Object,int,int)                
            </javadoc>
            <method name="getChar" type="char" line="204"/>
            <javadoc line="204">
                @see #getInt(Object,long)                
            </javadoc>
            <method name="putChar" type="void" line="206"/>
            <javadoc line="206">
                @see #putInt(Object,int,int)                
            </javadoc>
            <method name="getLong" type="long" line="208"/>
            <javadoc line="208">
                @see #getInt(Object,long)                
            </javadoc>
            <method name="putLong" type="void" line="210"/>
            <javadoc line="210">
                @see #putInt(Object,int,int)                
            </javadoc>
            <method name="getFloat" type="float" line="212"/>
            <javadoc line="212">
                @see #getInt(Object,long)                
            </javadoc>
            <method name="putFloat" type="void" line="214"/>
            <javadoc line="214">
                @see #putInt(Object,int,int)                
            </javadoc>
            <method name="getDouble" type="double" line="216"/>
            <javadoc line="216">
                @see #getInt(Object,long)                
            </javadoc>
            <method name="putDouble" type="void" line="218"/>
            <javadoc line="218">
                @see #putInt(Object,int,int)                
            </javadoc>
            <javadoc line="221">
                This method, like all others with 32-bit offsets, was native
                  in a previous release but is now a wrapper which simply casts
                  the offset to a long value.  It provides backward compatibility
                  with bytecodes compiled against 1.4.                
                <deprecated>
                    As of 1.4.1, cast the 32-bit offset argument to a long.
                      See {@link #staticFieldOffset}.                    
                </deprecated>
            </javadoc>
            <method name="getInt" type="int" line="230">
                <params>
                    <param name="o" type="Object"/>
                    <param name="offset" type="int"/>
                </params>
            </method>
            <javadoc line="234">
                @deprecated As of 1.4.1, cast the 32-bit offset argument to a long.
                  See {@link #staticFieldOffset}.                
            </javadoc>
            <method name="putInt" type="void" line="239">
                <params>
                    <param name="o" type="Object"/>
                    <param name="offset" type="int"/>
                    <param name="x" type="int"/>
                </params>
            </method>
            <javadoc line="243">
                @deprecated As of 1.4.1, cast the 32-bit offset argument to a long.
                  See {@link #staticFieldOffset}.                
            </javadoc>
            <method name="getObject" type="Object" line="248">
                <params>
                    <param name="o" type="Object"/>
                    <param name="offset" type="int"/>
                </params>
            </method>
            <javadoc line="252">
                @deprecated As of 1.4.1, cast the 32-bit offset argument to a long.
                  See {@link #staticFieldOffset}.                
            </javadoc>
            <method name="putObject" type="void" line="257">
                <params>
                    <param name="o" type="Object"/>
                    <param name="offset" type="int"/>
                    <param name="x" type="Object"/>
                </params>
            </method>
            <javadoc line="261">
                @deprecated As of 1.4.1, cast the 32-bit offset argument to a long.
                  See {@link #staticFieldOffset}.                
            </javadoc>
            <method name="getBoolean" type="boolean" line="266">
                <params>
                    <param name="o" type="Object"/>
                    <param name="offset" type="int"/>
                </params>
            </method>
            <javadoc line="270">
                @deprecated As of 1.4.1, cast the 32-bit offset argument to a long.
                  See {@link #staticFieldOffset}.                
            </javadoc>
            <method name="putBoolean" type="void" line="275">
                <params>
                    <param name="o" type="Object"/>
                    <param name="offset" type="int"/>
                    <param name="x" type="boolean"/>
                </params>
            </method>
            <javadoc line="279">
                @deprecated As of 1.4.1, cast the 32-bit offset argument to a long.
                  See {@link #staticFieldOffset}.                
            </javadoc>
            <method name="getByte" type="byte" line="284">
                <params>
                    <param name="o" type="Object"/>
                    <param name="offset" type="int"/>
                </params>
            </method>
            <javadoc line="288">
                @deprecated As of 1.4.1, cast the 32-bit offset argument to a long.
                  See {@link #staticFieldOffset}.                
            </javadoc>
            <method name="putByte" type="void" line="293">
                <params>
                    <param name="o" type="Object"/>
                    <param name="offset" type="int"/>
                    <param name="x" type="byte"/>
                </params>
            </method>
            <javadoc line="297">
                @deprecated As of 1.4.1, cast the 32-bit offset argument to a long.
                  See {@link #staticFieldOffset}.                
            </javadoc>
            <method name="getShort" type="short" line="302">
                <params>
                    <param name="o" type="Object"/>
                    <param name="offset" type="int"/>
                </params>
            </method>
            <javadoc line="306">
                @deprecated As of 1.4.1, cast the 32-bit offset argument to a long.
                  See {@link #staticFieldOffset}.                
            </javadoc>
            <method name="putShort" type="void" line="311">
                <params>
                    <param name="o" type="Object"/>
                    <param name="offset" type="int"/>
                    <param name="x" type="short"/>
                </params>
            </method>
            <javadoc line="315">
                @deprecated As of 1.4.1, cast the 32-bit offset argument to a long.
                  See {@link #staticFieldOffset}.                
            </javadoc>
            <method name="getChar" type="char" line="320">
                <params>
                    <param name="o" type="Object"/>
                    <param name="offset" type="int"/>
                </params>
            </method>
            <javadoc line="324">
                @deprecated As of 1.4.1, cast the 32-bit offset argument to a long.
                  See {@link #staticFieldOffset}.                
            </javadoc>
            <method name="putChar" type="void" line="329">
                <params>
                    <param name="o" type="Object"/>
                    <param name="offset" type="int"/>
                    <param name="x" type="char"/>
                </params>
            </method>
            <javadoc line="333">
                @deprecated As of 1.4.1, cast the 32-bit offset argument to a long.
                  See {@link #staticFieldOffset}.                
            </javadoc>
            <method name="getLong" type="long" line="338">
                <params>
                    <param name="o" type="Object"/>
                    <param name="offset" type="int"/>
                </params>
            </method>
            <javadoc line="342">
                @deprecated As of 1.4.1, cast the 32-bit offset argument to a long.
                  See {@link #staticFieldOffset}.                
            </javadoc>
            <method name="putLong" type="void" line="347">
                <params>
                    <param name="o" type="Object"/>
                    <param name="offset" type="int"/>
                    <param name="x" type="long"/>
                </params>
            </method>
            <javadoc line="351">
                @deprecated As of 1.4.1, cast the 32-bit offset argument to a long.
                  See {@link #staticFieldOffset}.                
            </javadoc>
            <method name="getFloat" type="float" line="356">
                <params>
                    <param name="o" type="Object"/>
                    <param name="offset" type="int"/>
                </params>
            </method>
            <javadoc line="360">
                @deprecated As of 1.4.1, cast the 32-bit offset argument to a long.
                  See {@link #staticFieldOffset}.                
            </javadoc>
            <method name="putFloat" type="void" line="365">
                <params>
                    <param name="o" type="Object"/>
                    <param name="offset" type="int"/>
                    <param name="x" type="float"/>
                </params>
            </method>
            <javadoc line="369">
                @deprecated As of 1.4.1, cast the 32-bit offset argument to a long.
                  See {@link #staticFieldOffset}.                
            </javadoc>
            <method name="getDouble" type="double" line="374">
                <params>
                    <param name="o" type="Object"/>
                    <param name="offset" type="int"/>
                </params>
            </method>
            <javadoc line="378">
                @deprecated As of 1.4.1, cast the 32-bit offset argument to a long.
                  See {@link #staticFieldOffset}.                
            </javadoc>
            <method name="putDouble" type="void" line="383">
                <params>
                    <param name="o" type="Object"/>
                    <param name="offset" type="int"/>
                    <param name="x" type="double"/>
                </params>
            </method>
            <method name="getByte" type="byte" line="389"/>
            <javadoc line="389">
                Fetches a value from a given memory address.  If the address is zero, or
                  does not point into a block obtained from {@link #allocateMemory}, the
                  results are undefined.                
                <see>
                    #allocateMemory                    
                </see>
            </javadoc>
            <method name="putByte" type="void" line="398"/>
            <javadoc line="398">
                Stores a value into a given memory address.  If the address is zero, or
                  does not point into a block obtained from {@link #allocateMemory}, the
                  results are undefined.                
                <see>
                    #getByte(long)                    
                </see>
            </javadoc>
            <method name="getShort" type="short" line="407"/>
            <javadoc line="407">
                @see #getByte(long)                
            </javadoc>
            <method name="putShort" type="void" line="409"/>
            <javadoc line="409">
                @see #putByte(long,byte)                
            </javadoc>
            <method name="getChar" type="char" line="411"/>
            <javadoc line="411">
                @see #getByte(long)                
            </javadoc>
            <method name="putChar" type="void" line="413"/>
            <javadoc line="413">
                @see #putByte(long,byte)                
            </javadoc>
            <method name="getInt" type="int" line="415"/>
            <javadoc line="415">
                @see #getByte(long)                
            </javadoc>
            <method name="putInt" type="void" line="417"/>
            <javadoc line="417">
                @see #putByte(long,byte)                
            </javadoc>
            <method name="getLong" type="long" line="419"/>
            <javadoc line="419">
                @see #getByte(long)                
            </javadoc>
            <method name="putLong" type="void" line="421"/>
            <javadoc line="421">
                @see #putByte(long,byte)                
            </javadoc>
            <method name="getFloat" type="float" line="423"/>
            <javadoc line="423">
                @see #getByte(long)                
            </javadoc>
            <method name="putFloat" type="void" line="425"/>
            <javadoc line="425">
                @see #putByte(long,byte)                
            </javadoc>
            <method name="getDouble" type="double" line="427"/>
            <javadoc line="427">
                @see #getByte(long)                
            </javadoc>
            <method name="putDouble" type="void" line="429"/>
            <javadoc line="429">
                @see #putByte(long,byte)                
            </javadoc>
            <method name="getAddress" type="long" line="432"/>
            <javadoc line="432">
                Fetches a native pointer from a given memory address.  If the address is
                  zero, or does not point into a block obtained from {@link #allocateMemory}, the results are undefined.
                  &lt;p&gt; If the native pointer is less than 64 bits wide, it is extended as
                  an unsigned number to a Java long.  The pointer may be indexed by any
                  given byte offset, simply by adding that offset (as a simple integer) to
                  the long representing the pointer.  The number of bytes actually read
                  from the target address maybe determined by consulting {@link #addressSize}.                
                <see>
                    #allocateMemory                    
                </see>
            </javadoc>
            <method name="putAddress" type="void" line="448"/>
            <javadoc line="448">
                Stores a native pointer into a given memory address.  If the address is
                  zero, or does not point into a block obtained from {@link #allocateMemory}, the results are undefined.
                  &lt;p&gt; The number of bytes actually written at the target address maybe
                  determined by consulting {@link #addressSize}.                
                <see>
                    #getAddress(long)                    
                </see>
            </javadoc>
            <method name="allocateMemory" type="long" line="462"/>
            <javadoc line="462">
                Allocates a new block of native memory, of the given size in bytes.  The
                  contents of the memory are uninitialized; they will generally be
                  garbage.  The resulting native pointer will never be zero, and will be
                  aligned for all value types.  Dispose of this memory by calling {@link #freeMemory}, or resize it with {@link #reallocateMemory}.                
                <throws>
                    IllegalArgumentException if the size is negative or too large
                      for the native size_t type                    
                </throws>
                <throws>
                    OutOfMemoryError if the allocation is refused by the system                    
                </throws>
                <see>
                    #getByte(long)                    
                </see>
                <see>
                    #putByte(long,byte)                    
                </see>
            </javadoc>
            <method name="reallocateMemory" type="long" line="479"/>
            <javadoc line="479">
                Resizes a new block of native memory, to the given size in bytes.  The
                  contents of the new block past the size of the old block are
                  uninitialized; they will generally be garbage.  The resulting native
                  pointer will be zero if and only if the requested size is zero.  The
                  resulting native pointer will be aligned for all value types.  Dispose
                  of this memory by calling {@link #freeMemory}, or resize it with {@link #reallocateMemory}.  The address passed to this method may be null, in
                  which case an allocation will be performed.                
                <throws>
                    IllegalArgumentException if the size is negative or too large
                      for the native size_t type                    
                </throws>
                <throws>
                    OutOfMemoryError if the allocation is refused by the system                    
                </throws>
                <see>
                    #allocateMemory                    
                </see>
            </javadoc>
            <method name="setMemory" type="void" line="498"/>
            <javadoc line="498">
                Sets all bytes in a given block of memory to a fixed value
                  (usually zero).
                  &lt;p&gt;This method determines a block&apos;s base address by means of two parameters,
                  and so it provides (in effect) a &lt;em&gt;double-register&lt;/em&gt; addressing mode,
                  as discussed in {@link #getInt(Object,long)}.  When the object reference is null,
                  the offset supplies an absolute base address.
                  &lt;p&gt;The stores are in coherent (atomic) units of a size determined
                  by the address and length parameters.  If the effective address and
                  length are all even modulo 8, the stores take place in &apos;long&apos; units.
                  If the effective address and length are (resp.) even modulo 4 or 2,
                  the stores take place in units of &apos;int&apos; or &apos;short&apos;.                
                <since>
                    1.7                    
                </since>
            </javadoc>
            <javadoc line="517">
                Sets all bytes in a given block of memory to a fixed value
                  (usually zero).  This provides a &lt;em&gt;single-register&lt;/em&gt; addressing mode,
                  as discussed in {@link #getInt(Object,long)}.
                  &lt;p&gt;Equivalent to &lt;code&gt;setMemory(null, address, bytes, value)&lt;/code&gt;.                
            </javadoc>
            <method name="setMemory" type="void" line="524">
                <params>
                    <param name="address" type="long"/>
                    <param name="bytes" type="long"/>
                    <param name="value" type="byte"/>
                </params>
            </method>
            <method name="copyMemory" type="void" line="528"/>
            <javadoc line="528">
                Sets all bytes in a given block of memory to a copy of another
                  block.
                  &lt;p&gt;This method determines each block&apos;s base address by means of two parameters,
                  and so it provides (in effect) a &lt;em&gt;double-register&lt;/em&gt; addressing mode,
                  as discussed in {@link #getInt(Object,long)}.  When the object reference is null,
                  the offset supplies an absolute base address.
                  &lt;p&gt;The transfers are in coherent (atomic) units of a size determined
                  by the address and length parameters.  If the effective addresses and
                  length are all even modulo 8, the transfer takes place in &apos;long&apos; units.
                  If the effective addresses and length are (resp.) even modulo 4 or 2,
                  the transfer takes place in units of &apos;int&apos; or &apos;short&apos;.                
                <since>
                    1.7                    
                </since>
            </javadoc>
            <javadoc line="548">
                Sets all bytes in a given block of memory to a copy of another
                  block.  This provides a &lt;em&gt;single-register&lt;/em&gt; addressing mode,
                  as discussed in {@link #getInt(Object,long)}.
                  Equivalent to &lt;code&gt;copyMemory(null, srcAddress, null, destAddress, bytes)&lt;/code&gt;.                
            </javadoc>
            <method name="copyMemory" type="void" line="555">
                <params>
                    <param name="srcAddress" type="long"/>
                    <param name="destAddress" type="long"/>
                    <param name="bytes" type="long"/>
                </params>
            </method>
            <method name="freeMemory" type="void" line="559"/>
            <javadoc line="559">
                Disposes of a block of native memory, as obtained from {@link #allocateMemory} or {@link #reallocateMemory}.  The address passed to
                  this method may be null, in which case no action is taken.                
                <see>
                    #allocateMemory                    
                </see>
            </javadoc>
            <declaration name="INVALID_FIELD_OFFSET" type="int" line="570"/>
            <javadoc line="570">
                This constant differs from all results that will ever be returned from{@link #staticFieldOffset}, {@link #objectFieldOffset},
                  or {@link #arrayBaseOffset}.                
            </javadoc>
            <javadoc line="577">
                Returns the offset of a field, truncated to 32 bits.
                  This method is implemented as follows:
                  &lt;blockquote&gt;&lt;pre&gt;
                  public int fieldOffset(Field f) {
                  if (Modifier.isStatic(f.getModifiers()))
                  return (int) staticFieldOffset(f);
                  else
                  return (int) objectFieldOffset(f);
                  }
                  &lt;/pre&gt;&lt;/blockquote&gt;                
                <deprecated>
                    As of 1.4.1, use {@link #staticFieldOffset} for static
                      fields and {@link #objectFieldOffset} for non-static fields.                    
                </deprecated>
            </javadoc>
            <method name="fieldOffset" type="int" line="592">
                <params>
                    <param name="f" type="Field"/>
                </params>
            </method>
            <javadoc line="599">
                Returns the base address for accessing some static field
                  in the given class.  This method is implemented as follows:
                  &lt;blockquote&gt;&lt;pre&gt;
                  public Object staticFieldBase(Class c) {
                  Field[] fields = c.getDeclaredFields();
                  for (int i = 0; i &lt; fields.length; i++) {
                  if (Modifier.isStatic(fields[i].getModifiers())) {
                  return staticFieldBase(fields[i]);
                  }
                  }
                  return null;
                  }
                  &lt;/pre&gt;&lt;/blockquote&gt;                
                <deprecated>
                    As of 1.4.1, use {@link #staticFieldBase(Field)}to obtain the base pertaining to a specific {@link Field}.
                      This method works only for JVMs which store all statics
                      for a given class in one place.                    
                </deprecated>
            </javadoc>
            <method name="staticFieldBase" type="Object" line="619">
                <params>
                    <param name="c" type="Class"/>
                </params>
                <declaration name="fields" type="Field[]" line="620"/>
                <scope line="621">
                    <scope line="622"/>
                </scope>
            </method>
            <method name="staticFieldOffset" type="long" line="629"/>
            <javadoc line="629">
                Report the location of a given field in the storage allocation of its
                  class.  Do not expect to perform any sort of arithmetic on this offset;
                  it is just a cookie which is passed to the unsafe heap memory accessors.
                  &lt;p&gt;Any given field will always have the same offset and base, and no
                  two distinct fields of the same class will ever have the same offset
                  and base.
                  &lt;p&gt;As of 1.4.1, offsets for fields are represented as long values,
                  although the Sun JVM does not use the most significant 32 bits.
                  However, JVM implementations which store static fields at absolute
                  addresses can use long offsets and null base pointers to express
                  the field locations in a form usable by {@link #getInt(Object,long)}.
                  Therefore, code which will be ported to such JVMs on 64-bit platforms
                  must preserve all bits of static field offsets.                
                <see>
                    #getInt(Object,long)                    
                </see>
            </javadoc>
            <method name="objectFieldOffset" type="long" line="649"/>
            <javadoc line="649">
                Report the location of a given static field, in conjunction with {@link #staticFieldBase}.
                  &lt;p&gt;Do not expect to perform any sort of arithmetic on this offset;
                  it is just a cookie which is passed to the unsafe heap memory accessors.
                  &lt;p&gt;Any given field will always have the same offset, and no two distinct
                  fields of the same class will ever have the same offset.
                  &lt;p&gt;As of 1.4.1, offsets for fields are represented as long values,
                  although the Sun JVM does not use the most significant 32 bits.
                  It is hard to imagine a JVM technology which needs more than
                  a few bits to encode an offset within a non-array object,
                  However, for consistency with other methods in this class,
                  this method reports its result as a long value.                
                <see>
                    #getInt(Object,long)                    
                </see>
            </javadoc>
            <method name="staticFieldBase" type="Object" line="668"/>
            <javadoc line="668">
                Report the location of a given static field, in conjunction with {@link #staticFieldOffset}.
                  &lt;p&gt;Fetch the base &quot;Object&quot;, if any, with which static fields of the
                  given class can be accessed via methods like {@link #getInt(Object,long)}.  This value may be null.  This value may refer to an object
                  which is a &quot;cookie&quot;, not guaranteed to be a real Object, and it should
                  not be used in any way except as argument to the get and put routines in
                  this class.                
            </javadoc>
            <method name="ensureClassInitialized" type="void" line="680"/>
            <javadoc line="680">
                Ensure the given class has been initialized. This is often
                  needed in conjunction with obtaining the static field base of a
                  class.                
            </javadoc>
            <method name="arrayBaseOffset" type="int" line="687"/>
            <javadoc line="687">
                Report the offset of the first element in the storage allocation of a
                  given array class.  If {@link #arrayIndexScale} returns a non-zero value
                  for the same class, you may use that scale factor, together with this
                  base offset, to form new offsets to access elements of arrays of the
                  given class.                
                <see>
                    #getInt(Object,long)                    
                </see>
                <see>
                    #putInt(Object,long,int)                    
                </see>
            </javadoc>
            <declaration name="ARRAY_BOOLEAN_BASE_OFFSET" type="int" line="699"/>
            <javadoc line="699">
                The value of {@code arrayBaseOffset(boolean[].class)}                
            </javadoc>
            <declaration name="ARRAY_BYTE_BASE_OFFSET" type="int" line="703"/>
            <javadoc line="703">
                The value of {@code arrayBaseOffset(byte[].class)}                
            </javadoc>
            <declaration name="ARRAY_SHORT_BASE_OFFSET" type="int" line="707"/>
            <javadoc line="707">
                The value of {@code arrayBaseOffset(short[].class)}                
            </javadoc>
            <declaration name="ARRAY_CHAR_BASE_OFFSET" type="int" line="711"/>
            <javadoc line="711">
                The value of {@code arrayBaseOffset(char[].class)}                
            </javadoc>
            <declaration name="ARRAY_INT_BASE_OFFSET" type="int" line="715"/>
            <javadoc line="715">
                The value of {@code arrayBaseOffset(int[].class)}                
            </javadoc>
            <declaration name="ARRAY_LONG_BASE_OFFSET" type="int" line="719"/>
            <javadoc line="719">
                The value of {@code arrayBaseOffset(long[].class)}                
            </javadoc>
            <declaration name="ARRAY_FLOAT_BASE_OFFSET" type="int" line="723"/>
            <javadoc line="723">
                The value of {@code arrayBaseOffset(float[].class)}                
            </javadoc>
            <declaration name="ARRAY_DOUBLE_BASE_OFFSET" type="int" line="727"/>
            <javadoc line="727">
                The value of {@code arrayBaseOffset(double[].class)}                
            </javadoc>
            <declaration name="ARRAY_OBJECT_BASE_OFFSET" type="int" line="731"/>
            <javadoc line="731">
                The value of {@code arrayBaseOffset(Object[].class)}                
            </javadoc>
            <method name="arrayIndexScale" type="int" line="735"/>
            <javadoc line="735">
                Report the scale factor for addressing elements in the storage
                  allocation of a given array class.  However, arrays of &quot;narrow&quot; types
                  will generally not work properly with accessors like {@link #getByte(Object,int)}, so the scale factor for such classes is reported
                  as zero.                
                <see>
                    #arrayBaseOffset                    
                </see>
                <see>
                    #getInt(Object,long)                    
                </see>
                <see>
                    #putInt(Object,long,int)                    
                </see>
            </javadoc>
            <declaration name="ARRAY_BOOLEAN_INDEX_SCALE" type="int" line="748"/>
            <javadoc line="748">
                The value of {@code arrayIndexScale(boolean[].class)}                
            </javadoc>
            <declaration name="ARRAY_BYTE_INDEX_SCALE" type="int" line="752"/>
            <javadoc line="752">
                The value of {@code arrayIndexScale(byte[].class)}                
            </javadoc>
            <declaration name="ARRAY_SHORT_INDEX_SCALE" type="int" line="756"/>
            <javadoc line="756">
                The value of {@code arrayIndexScale(short[].class)}                
            </javadoc>
            <declaration name="ARRAY_CHAR_INDEX_SCALE" type="int" line="760"/>
            <javadoc line="760">
                The value of {@code arrayIndexScale(char[].class)}                
            </javadoc>
            <declaration name="ARRAY_INT_INDEX_SCALE" type="int" line="764"/>
            <javadoc line="764">
                The value of {@code arrayIndexScale(int[].class)}                
            </javadoc>
            <declaration name="ARRAY_LONG_INDEX_SCALE" type="int" line="768"/>
            <javadoc line="768">
                The value of {@code arrayIndexScale(long[].class)}                
            </javadoc>
            <declaration name="ARRAY_FLOAT_INDEX_SCALE" type="int" line="772"/>
            <javadoc line="772">
                The value of {@code arrayIndexScale(float[].class)}                
            </javadoc>
            <declaration name="ARRAY_DOUBLE_INDEX_SCALE" type="int" line="776"/>
            <javadoc line="776">
                The value of {@code arrayIndexScale(double[].class)}                
            </javadoc>
            <declaration name="ARRAY_OBJECT_INDEX_SCALE" type="int" line="780"/>
            <javadoc line="780">
                The value of {@code arrayIndexScale(Object[].class)}                
            </javadoc>
            <method name="addressSize" type="int" line="784"/>
            <javadoc line="784">
                Report the size in bytes of a native pointer, as stored via {@link #putAddress}.  This value will be either 4 or 8.  Note that the sizes of
                  other primitive types (as stored in native memory blocks) is determined
                  fully by their information content.                
            </javadoc>
            <declaration name="ADDRESS_SIZE" type="int" line="792"/>
            <javadoc line="792">
                The value of {@code addressSize()}                
            </javadoc>
            <method name="pageSize" type="int" line="795"/>
            <javadoc line="795">
                Report the size in bytes of a native memory page (whatever that is).
                  This value will always be a power of two.                
            </javadoc>
            <method name="defineClass" type="Class" line="804"/>
            <javadoc line="804">
                Tell the VM to define a class, without security checks.  By default, the
                  class loader and protection domain come from the caller&apos;s class.                
            </javadoc>
            <method name="defineClass" type="Class" line="812"/>
            <method name="defineAnonymousClass" type="Class" line="814"/>
            <javadoc line="814">
                Define a class but do not make it known to the class loader or system dictionary.
                  &lt;p&gt;
                  For each CP entry, the corresponding CP patch must either be null or have
                  the a format that matches its tag:
                  &lt;ul&gt;
                  &lt;li&gt;Integer, Long, Float, Double: the corresponding wrapper object type from java.lang
                  &lt;li&gt;Utf8: a string (must have suitable syntax if used as signature or name)
                  &lt;li&gt;Class: any java.lang.Class object
                  &lt;li&gt;String: any object (not just a java.lang.String)
                  &lt;li&gt;InterfaceMethodRef: (NYI) a method handle to invoke on that call site&apos;s arguments
                  &lt;/ul&gt;                
                <params>
                    hostClass context for linkage, access control, protection domain, and class loader                    
                </params>
                <params>
                    data      bytes of a class file                    
                </params>
                <params>
                    cpPatches where non-null entries exist, they replace corresponding CP entries in data                    
                </params>
            </javadoc>
            <method name="allocateInstance" type="Object" line="833"/>
            <javadoc line="833">
                Allocate an instance but do not run any constructor.
                  Initializes the class if it has not yet been.                
            </javadoc>
            <method name="monitorEnter" type="void" line="838"/>
            <javadoc line="838">
                Lock the object.  It must get unlocked via {@link #monitorExit}.                
            </javadoc>
            <method name="monitorExit" type="void" line="841"/>
            <javadoc line="841">
                Unlock the object.  It must have been locked via {@link #monitorEnter}.                
            </javadoc>
            <method name="tryMonitorEnter" type="boolean" line="847"/>
            <javadoc line="847">
                Tries to lock the object.  Returns true or false to indicate
                  whether the lock succeeded.  If it did, the object must be
                  unlocked via {@link #monitorExit}.                
            </javadoc>
            <method name="throwException" type="void" line="854"/>
            <javadoc line="854">
                Throw the exception without telling the verifier.                
            </javadoc>
            <method name="compareAndSwapObject" type="boolean" line="858"/>
            <javadoc line="858">
                Atomically update Java variable to &lt;tt&gt;x&lt;/tt&gt; if it is currently
                  holding &lt;tt&gt;expected&lt;/tt&gt;.                
                <return>
                    <tt>true</tt> if successful                    
                </return>
            </javadoc>
            <method name="compareAndSwapInt" type="boolean" line="867"/>
            <javadoc line="867">
                Atomically update Java variable to &lt;tt&gt;x&lt;/tt&gt; if it is currently
                  holding &lt;tt&gt;expected&lt;/tt&gt;.                
                <return>
                    <tt>true</tt> if successful                    
                </return>
            </javadoc>
            <method name="compareAndSwapLong" type="boolean" line="876"/>
            <javadoc line="876">
                Atomically update Java variable to &lt;tt&gt;x&lt;/tt&gt; if it is currently
                  holding &lt;tt&gt;expected&lt;/tt&gt;.                
                <return>
                    <tt>true</tt> if successful                    
                </return>
            </javadoc>
            <method name="getObjectVolatile" type="Object" line="885"/>
            <javadoc line="885">
                Fetches a reference value from a given Java variable, with volatile
                  load semantics. Otherwise identical to {@link #getObject(Object,long)}                
            </javadoc>
            <method name="putObjectVolatile" type="void" line="891"/>
            <javadoc line="891">
                Stores a reference value into a given Java variable, with
                  volatile store semantics. Otherwise identical to {@link #putObject(Object,long,Object)}                
            </javadoc>
            <method name="getIntVolatile" type="int" line="897"/>
            <javadoc line="897">
                Volatile version of {@link #getInt(Object,long)}                
            </javadoc>
            <method name="putIntVolatile" type="void" line="900"/>
            <javadoc line="900">
                Volatile version of {@link #putInt(Object,long,int)}                
            </javadoc>
            <method name="getBooleanVolatile" type="boolean" line="903"/>
            <javadoc line="903">
                Volatile version of {@link #getBoolean(Object,long)}                
            </javadoc>
            <method name="putBooleanVolatile" type="void" line="906"/>
            <javadoc line="906">
                Volatile version of {@link #putBoolean(Object,long,boolean)}                
            </javadoc>
            <method name="getByteVolatile" type="byte" line="909"/>
            <javadoc line="909">
                Volatile version of {@link #getByte(Object,long)}                
            </javadoc>
            <method name="putByteVolatile" type="void" line="912"/>
            <javadoc line="912">
                Volatile version of {@link #putByte(Object,long,byte)}                
            </javadoc>
            <method name="getShortVolatile" type="short" line="915"/>
            <javadoc line="915">
                Volatile version of {@link #getShort(Object,long)}                
            </javadoc>
            <method name="putShortVolatile" type="void" line="918"/>
            <javadoc line="918">
                Volatile version of {@link #putShort(Object,long,short)}                
            </javadoc>
            <method name="getCharVolatile" type="char" line="921"/>
            <javadoc line="921">
                Volatile version of {@link #getChar(Object,long)}                
            </javadoc>
            <method name="putCharVolatile" type="void" line="924"/>
            <javadoc line="924">
                Volatile version of {@link #putChar(Object,long,char)}                
            </javadoc>
            <method name="getLongVolatile" type="long" line="927"/>
            <javadoc line="927">
                Volatile version of {@link #getLong(Object,long)}                
            </javadoc>
            <method name="putLongVolatile" type="void" line="930"/>
            <javadoc line="930">
                Volatile version of {@link #putLong(Object,long,long)}                
            </javadoc>
            <method name="getFloatVolatile" type="float" line="933"/>
            <javadoc line="933">
                Volatile version of {@link #getFloat(Object,long)}                
            </javadoc>
            <method name="putFloatVolatile" type="void" line="936"/>
            <javadoc line="936">
                Volatile version of {@link #putFloat(Object,long,float)}                
            </javadoc>
            <method name="getDoubleVolatile" type="double" line="939"/>
            <javadoc line="939">
                Volatile version of {@link #getDouble(Object,long)}                
            </javadoc>
            <method name="putDoubleVolatile" type="void" line="942"/>
            <javadoc line="942">
                Volatile version of {@link #putDouble(Object,long,double)}                
            </javadoc>
            <method name="putOrderedObject" type="void" line="945"/>
            <javadoc line="945">
                Version of {@link #putObjectVolatile(Object,long,Object)}that does not guarantee immediate visibility of the store to
                  other threads. This method is generally only useful if the
                  underlying field is a Java volatile (or if an array cell, one
                  that is otherwise only accessed using volatile accesses).                
            </javadoc>
            <method name="putOrderedInt" type="void" line="954"/>
            <javadoc line="954">
                Ordered/Lazy version of {@link #putIntVolatile(Object,long,int)}                
            </javadoc>
            <method name="putOrderedLong" type="void" line="957"/>
            <javadoc line="957">
                Ordered/Lazy version of {@link #putLongVolatile(Object,long,long)}                
            </javadoc>
            <method name="unpark" type="void" line="960"/>
            <javadoc line="960">
                Unblock the given thread blocked on &lt;tt&gt;park&lt;/tt&gt;, or, if it is
                  not blocked, cause the subsequent call to &lt;tt&gt;park&lt;/tt&gt; not to
                  block.  Note: this operation is &quot;unsafe&quot; solely because the
                  caller must somehow ensure that the thread has not been
                  destroyed. Nothing special is usually required to ensure this
                  when called from Java (in which there will ordinarily be a live
                  reference to the thread) but this is not nearly-automatically
                  so when calling from native code.                
                <param>
                    thread the thread to unpark.                    
                </param>
            </javadoc>
            <method name="park" type="void" line="974"/>
            <javadoc line="974">
                Block current thread, returning when a balancing
                  &lt;tt&gt;unpark&lt;/tt&gt; occurs, or a balancing &lt;tt&gt;unpark&lt;/tt&gt; has
                  already occurred, or the thread is interrupted, or, if not
                  absolute and time is not zero, the given time nanoseconds have
                  elapsed, or if absolute, the given deadline in milliseconds
                  since Epoch has passed, or spuriously (i.e., returning for no
                  &quot;reason&quot;). Note: This operation is in the Unsafe class only
                  because &lt;tt&gt;unpark&lt;/tt&gt; is, so it would be strange to place it
                  elsewhere.                
            </javadoc>
            <method name="getLoadAverage" type="int" line="987"/>
            <javadoc line="987">
                Gets the load average in the system run queue assigned
                  to the available processors averaged over various periods of time.
                  This method retrieves the given &lt;tt&gt;nelem&lt;/tt&gt; samples and
                  assigns to the elements of the given &lt;tt&gt;loadavg&lt;/tt&gt; array.
                  The system imposes a maximum of 3 samples, representing
                  averages over the last 1,  5,  and  15 minutes, respectively.                
                <params>
                    loadavg an array of double of size nelems                    
                </params>
                <params>
                    nelems the number of samples to be retrieved and
                      must be 1 to 3.                    
                </params>
                <return>
                    the number of samples actually retrieved; or -1
                      if the load average is unobtainable.                    
                </return>
            </javadoc>
        </class>
    </source>