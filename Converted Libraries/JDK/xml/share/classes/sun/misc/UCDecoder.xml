<?xml version="1.0" encoding="UTF-8"?>
    <source package="sun.misc">
        <import package="java.io.OutputStream"/>
        <import package="java.io.ByteArrayOutputStream"/>
        <import package="java.io.PushbackInputStream"/>
        <import package="java.io.PrintStream"/>
        <import package="java.io.IOException"/>
        <class name="UCDecoder" line="7">
            <extends class="CharacterDecoder"/>
            <javadoc line="7">
                This class implements a robust character decoder. The decoder will
                  converted encoded text into binary data.
                  The basic encoding unit is a 3 character atom. It encodes two bytes
                  of data. Bytes are encoded into a 64 character set, the characters
                  were chosen specifically because they appear in all codesets.
                  We don&apos;t care what their numerical equivalent is because
                  we use a character array to map them. This is like UUencoding
                  with the dependency on ASCII removed.
                  The three chars that make up an atom are encoded as follows:
                  &lt;pre&gt;
                  00xxxyyy 00axxxxx 00byyyyy
                  00 = leading zeros, all values are 0 - 63
                  xxxyyy - Top 3 bits of X, Top 3 bits of Y
                  axxxxx - a = X parity bit, xxxxx lower 5 bits of X
                  byyyyy - b = Y parity bit, yyyyy lower 5 bits of Y
                  &lt;/pre&gt;
                  The atoms are arranged into lines suitable for inclusion into an
                  email message or text file. The number of bytes that are encoded
                  per line is 48 which keeps the total line length  under 80 chars)
                  Each line has the form(
                  &lt;pre&gt;
                  (LLSS)(DDDD)(DDDD)(DDDD)...(CRC)
                  Where each (xxx) represents a three character atom.
                  (LLSS) - 8 bit length (high byte), and sequence number
                  modulo 256;
                  (DDDD) - Data byte atoms, if length is odd, last data
                  atom has (DD00) (high byte data, low byte 0)
                  (CRC)  - 16 bit CRC for the line, includes length,
                  sequence, and all data bytes. If there is a
                  zero pad byte (odd length) it is _NOT_
                  included in the CRC.
                  &lt;/pre&gt;
                  If an error is encountered during decoding this class throws a
                  CEFormatException. The specific detail messages are:
                  &lt;pre&gt;
                  &quot;UCDecoder: High byte parity error.&quot;
                  &quot;UCDecoder: Low byte parity error.&quot;
                  &quot;UCDecoder: Out of sequence line.&quot;
                  &quot;UCDecoder: CRC check failed.&quot;
                  &lt;/pre&gt;                
                <author>
                    Chuck McManis                    
                </author>
                <see>
                    CharacterEncoder                    
                </see>
                <see>
                    UCEncoder                    
                </see>
            </javadoc>
            <javadoc line="53">
                This class encodes two bytes per atom.                
            </javadoc>
            <method name="bytesPerAtom" type="int" line="56"/>
            <javadoc line="59">
                this class encodes 48 bytes per line                
            </javadoc>
            <method name="bytesPerLine" type="int" line="62"/>
            <declaration name="map_array" type="byte" line="65"/>
            <declaration name="sequence" type="int" line="66"/>
            <declaration name="tmp" type="byte" line="67"/>
            <declaration name="crc" type="CRC16" line="68"/>
            <javadoc line="69">
                Decode one atom - reads the characters from the input stream, decodes
                  them, and checks for valid parity.                
            </javadoc>
            <method name="decodeAtom" type="void" line="73">
                <params>
                    <param name="inStream" type="PushbackInputStream"/>
                    <param name="outStream" type="OutputStream"/>
                    <param name="l" type="int"/>
                </params>
                <declaration name="i" type="int" line="74"/>
                <declaration name="a" type="byte" line="75"/>
                <declaration name="high_byte" type="byte" line="76"/>
                <declaration name="tmp" type="byte" line="77"/>
                <scope line="79"/>
                <scope line="82">
                    <scope line="83"/>
                    <scope line="86"/>
                    <scope line="89"/>
                </scope>
                <scope line="97"/>
                <scope line="103"/>
                <scope line="106"/>
                <scope line="111"/>
            </method>
            <declaration name="lineAndSeq" type="ByteArrayOutputStream" line="116"/>
            <javadoc line="117">
                decodeBufferPrefix initializes the sequence number to zero.                
            </javadoc>
            <method name="decodeBufferPrefix" type="void" line="120">
                <params>
                    <param name="inStream" type="PushbackInputStream"/>
                    <param name="outStream" type="OutputStream"/>
                </params>
            </method>
            <javadoc line="123">
                decodeLinePrefix reads the sequence number and the number of
                  encoded bytes from the line. If the sequence number is not the
                  previous sequence number + 1 then an exception is thrown.
                  UCE lines are line terminator immune, they all start with 
                  so the other thing this method does is scan for the next line
                  by looking for the  character.                
                <exception>
                    CEFormatException out of sequence lines detected.                    
                </exception>
            </javadoc>
            <method name="decodeLinePrefix" type="int" line="132">
                <params>
                    <param name="inStream" type="PushbackInputStream"/>
                    <param name="outStream" type="OutputStream"/>
                </params>
                <declaration name="i" type="int" line="133"/>
                <declaration name="nLen" type="int" line="134"/>
                <declaration name="xtmp" type="byte" line="135"/>
                <declaration name="c" type="int" line="136"/>
                <scope line="138">
                    <scope line="140"/>
                    <scope line="143"/>
                </scope>
                <scope line="152"/>
            </method>
            <javadoc line="158">
                this method reads the CRC that is at the end of every line and
                  verifies that it matches the computed CRC.                
                <exception>
                    CEFormatException if CRC check fails.                    
                </exception>
            </javadoc>
            <method name="decodeLineSuffix" type="void" line="163">
                <params>
                    <param name="inStream" type="PushbackInputStream"/>
                    <param name="outStream" type="OutputStream"/>
                </params>
                <declaration name="i" type="int" line="164"/>
                <declaration name="lineCRC" type="int" line="165"/>
                <declaration name="readCRC" type="int" line="166"/>
                <declaration name="tmp" type="byte" line="167"/>
                <scope line="172"/>
            </method>
        </class>
    </source>