<?xml version="1.0" encoding="UTF-8"?>
    <source package="sun.misc">
        <import package="sun.misc.FpUtils"/>
        <import package="sun.misc.DoubleConsts"/>
        <import package="sun.misc.FloatConsts"/>
        <import package="java.util.regex"/>
        <class name="FloatingDecimal" line="33">
            <comment line="44">
                set by doubleValue                
            </comment>
            <comment line="55">
                Constants of the implementation
                 Most are IEEE-754 related.
                 (There are more really boring constants at the end.)                
            </comment>
            <comment line="65">
                assumed High-Order bit                
            </comment>
            <comment line="66">
                exponent of 1.0                
            </comment>
            <comment line="72">
                i.e. abs(minDecimalExponent)                
            </comment>
            <comment line="91">
                count number of bits from high-order 1 bit to low-order 1 bit,
                 inclusive.                
            </comment>
            <comment line="123">
                Keep big powers of 5 handy for future reference.                
            </comment>
            <comment line="168">
                a common operation                
            </comment>
            <comment line="186">
                another common operation                
            </comment>
            <comment line="198">
                Make a floating double into a FDBigInt.
                 This could also be structured as a FDBigInt
                 constructor, but we&apos;d have to build a lot of knowledge
                 about floating-point representation into it, and we don&apos;t want to.
                
                 AS A SIDE EFFECT, THIS METHOD WILL SET THE INSTANCE VARIABLES
                 bigIntExp and bigIntNBits                
            </comment>
            <comment line="237">
                Compute a number that is the ULP of the given value,
                 for purposes of additionsubtraction. Generally easy.
                 More difficult if subtracting and the argument
                 is a normalized a power of 2, as the ULP changes at these points.                
            </comment>
            <comment line="264">
                Round a double to a float.
                 In addition to the fraction bits of the double,
                 look at the class instance variable roundDir,
                 which should help us avoid double-rounding error.
                 roundDir was set in hardValueOf if the estimate was
                 close enough, but not exact. It tells us which direction
                 of rounding is preferred.                
            </comment>
            <comment line="287">
                This is the easy subcase --
                 all the significant bits, after scaling, are held in lvalue.
                 negSign and decExponent tell us what processing and scaling
                 has already been done. Exceptional cases have already been
                 stripped out.
                 In particular:
                 lvalue is a finite number (not Inf, nor NaN)
                 lvalue &gt; 0L (not zero, nor negative).
                
                 The only reason that we develop the digits here, rather than
                 calling on Long.toString() is that we can do it a little faster,
                 and besides want to treat trailing 0s specially. If Long.toString
                 changes, we should re-evaluate this strategy!                
            </comment>
            <comment line="376">
                add one to the least significant digit.
                 in the unlikely event there is a carry out,
                 deal with it.
                 assert that this will only happen where there
                 is only one digit, e.g. (float)1e-44 seems to do it.                
            </comment>
            <comment line="403">
                FIRST IMPORTANT CONSTRUCTOR: DOUBLE                
            </comment>
            <comment line="463">
                SECOND IMPORTANT CONSTRUCTOR: SINGLE                
            </comment>
            <comment line="982">
                Per-thread buffer for string/stringbuffer conversion                
            </comment>
            <comment line="1245">
                Take a FloatingDecimal, which we presumably just scanned in,
                 and find out what its value is, as a double.
                
                 AS A SIDE EFFECT, SET roundDir TO INDICATE PREFERRED
                 ROUNDING DIRECTION in case the result is really destined
                 for a single-precision float.                
            </comment>
            <comment line="1603">
                Take a FloatingDecimal, which we presumably just scanned in,
                 and find out what its value is, as a float.
                 This is distinct from doubleValue() to avoid the extremely
                 unlikely case of a double rounding error, wherein the conversion
                 to double has one rounding error, and the conversion of that double
                 to a float has another rounding error, IN THE WRONG DIRECTION,
                 ( because of the preference to a zero low-order bit ).                
            </comment>
            <comment line="1753">
                All the positive powers of 10 that can be
                 represented exactly in doublefloat.                
            </comment>
            <comment line="1828">
                approximately ceil( log2( long5pow[i] ) )                
            </comment>
            <comment line="1864">
                Grammar is compatible with hexadecimal floating-point constants
                 described in section 6.4.4.2 of the C99 specification.                
            </comment>
            <comment line="1879">
                Convert string s to a suitable floating decimal; uses the
                 double constructor and set the roundDir variable appropriately
                 in case the value is later converted to a float.                
            </comment>
            <comment line="2419">
                number of words used                
            </comment>
            <comment line="2420">
                value: data[0] is least significant                
            </comment>
            <comment line="2475">
                Left shift by c bits.
                 Shifts this in place.                
            </comment>
            <comment line="2520">
                normalize this number by shifting until
                 the MSB of the number is at 0x08000000.
                 This is in preparation for quoRemIteration, below.
                 The idea is that, to make division easier, we want the
                 divisor to be &quot;normalized&quot; -- usually this means shifting
                 the MSB into the high words sign bit. But because we know that
                 the quotient will be 0 &lt; q &lt; 10, we would like to arrange that
                 the dividend not span up into another word of precision.
                 (This needs to be explained more clearly!)                
            </comment>
            <comment line="2577">
                Multiply a FDBigInt by an int.
                 Result is a new FDBigInt.                
            </comment>
            <comment line="2603">
                Multiply a FDBigInt by an int and add another int.
                 Result is computed in place.
                 Hope it fits!                
            </comment>
            <comment line="2628">
                Multiply a FDBigInt by another FDBigInt.
                 Result is a new FDBigInt.                
            </comment>
            <comment line="2657">
                Add one FDBigInt to another. Return a FDBigInt                
            </comment>
            <comment line="2698">
                Subtract one FDBigInt from another. Return a FDBigInt
                 Assert that the result is positive.                
            </comment>
            <comment line="2733">
                Compare FDBigInt with another FDBigInt. Return an integer
                 &gt;0: this &gt; other
                  0: this == other
                 &lt;0: this &lt; other                
            </comment>
            <comment line="2782">
                Compute
                 q = (int)( this  S )
                 this = 10  ( this mod S )
                 Return q.
                 This is the iteration step of digit development for output.
                 We assume that S has been normalized, as above, and that
                 &quot;this&quot; has been lshift&apos;ed accordingly.
                 Also assume, of course, that the result, q, can be expressed
                 as an integer, 0 &lt;= q &lt; 10.                
            </comment>
            <declaration name="isExceptional" type="boolean" line="34"/>
            <declaration name="isNegative" type="boolean" line="35"/>
            <declaration name="decExponent" type="int" line="36"/>
            <declaration name="digits" type="char" line="37"/>
            <declaration name="nDigits" type="int" line="38"/>
            <declaration name="bigIntExp" type="int" line="39"/>
            <declaration name="bigIntNBits" type="int" line="40"/>
            <declaration name="mustSetRoundDir" type="boolean" line="41"/>
            <declaration name="fromHex" type="boolean" line="42"/>
            <declaration name="roundDir" type="int" line="43"/>
            <method name="FloatingDecimal" type="constructor" line="46">
                <params>
                    <param name="negSign" type="boolean"/>
                    <param name="decExponent" type="int"/>
                    <param name="digits" type="char[]"/>
                    <param name="n" type="int"/>
                    <param name="e" type="boolean"/>
                </params>
            </method>
            <declaration name="signMask" type="long" line="59"/>
            <declaration name="expMask" type="long" line="60"/>
            <declaration name="fractMask" type="long" line="61"/>
            <declaration name="expShift" type="int" line="62"/>
            <declaration name="expBias" type="int" line="63"/>
            <declaration name="fractHOB" type="long" line="64"/>
            <declaration name="expOne" type="long" line="65"/>
            <declaration name="maxSmallBinExp" type="int" line="66"/>
            <declaration name="minSmallBinExp" type="int" line="67"/>
            <declaration name="maxDecimalDigits" type="int" line="68"/>
            <declaration name="maxDecimalExponent" type="int" line="69"/>
            <declaration name="minDecimalExponent" type="int" line="70"/>
            <declaration name="bigDecimalExponent" type="int" line="71"/>
            <declaration name="highbyte" type="long" line="73"/>
            <declaration name="highbit" type="long" line="74"/>
            <declaration name="lowbytes" type="long" line="75"/>
            <declaration name="singleSignMask" type="int" line="77"/>
            <declaration name="singleExpMask" type="int" line="78"/>
            <declaration name="singleFractMask" type="int" line="79"/>
            <declaration name="singleExpShift" type="int" line="80"/>
            <declaration name="singleFractHOB" type="int" line="81"/>
            <declaration name="singleExpBias" type="int" line="82"/>
            <declaration name="singleMaxDecimalDigits" type="int" line="83"/>
            <declaration name="singleMaxDecimalExponent" type="int" line="84"/>
            <declaration name="singleMinDecimalExponent" type="int" line="85"/>
            <declaration name="intDecimalDigits" type="int" line="87"/>
            <method name="countBits" type="int" line="95">
                <params>
                    <param name="v" type="long"/>
                </params>
                <comment line="97">
                    the strategy is to shift until we get a non-zero sign bit
                     then shift until we have no bits left, counting the difference.
                     we do byte shifting as a hack. Hope it helps.                    
                </comment>
                <comment line="107">
                    i.e. while ((v&amp;highbit) == 0L )                    
                </comment>
                <scope line="103"/>
                <scope line="106"/>
                <declaration name="n" type="int" line="110"/>
                <scope line="111"/>
                <scope line="115"/>
            </method>
            <declaration name="b5p" type="FDBigInt" line="125"/>
            <method name="big5pow" type="FDBigInt" line="128">
                <params>
                    <param name="p" type="int"/>
                </params>
                <comment line="130">
                    negative power of 5                    
                </comment>
                <comment line="145">
                    construct the value.
                     recursively.                    
                </comment>
                <comment line="148">
                    in order to compute 5^p,
                     compute its square root, 5^(p/2) and square.
                     or, let q = p / 2, r = p -q, then
                     5^p = 5^(q+r) = 5^q * 5^r                    
                </comment>
                <scope line="130"/>
                <scope line="132">
                    <declaration name="t" type="FDBigInt" line="133"/>
                </scope>
                <scope line="143">
                    <declaration name="q" type="int" line="146"/>
                    <declaration name="bigq" type="FDBigInt" line="153"/>
                    <scope line="156"/>
                    <scope line="158">
                        <declaration name="bigr" type="FDBigInt" line="159"/>
                    </scope>
                </scope>
            </method>
            <method name="multPow52" type="FDBigInt" line="171">
                <params>
                    <param name="v" type="FDBigInt"/>
                    <param name="p5" type="int"/>
                    <param name="p2" type="int"/>
                </params>
                <scope line="172">
                    <scope line="173"/>
                    <scope line="175"/>
                </scope>
                <scope line="179"/>
            </method>
            <method name="constructPow52" type="FDBigInt" line="189">
                <params>
                    <param name="p5" type="int"/>
                    <param name="p2" type="int"/>
                </params>
                <declaration name="v" type="FDBigInt" line="190"/>
                <scope line="191"/>
            </method>
            <method name="doubleToBigInt" type="FDBigInt" line="208">
                <params>
                    <param name="dval" type="double"/>
                </params>
                <comment line="216">
                    doubleToBigInt(0.0)                    
                </comment>
                <comment line="225">
                    We now know where the high-order 1 bit is,
                     and we know how many there are.                    
                </comment>
                <declaration name="lbits" type="long" line="209"/>
                <declaration name="binexp" type="int" line="210"/>
                <scope line="212"/>
                <scope line="214">
                    <scope line="217"/>
                </scope>
                <declaration name="nbits" type="int" line="223"/>
                <declaration name="lowOrderZeros" type="int" line="228"/>
            </method>
            <method name="ulp" type="double" line="242">
                <params>
                    <param name="dval" type="double"/>
                    <param name="subtracting" type="boolean"/>
                </params>
                <comment line="248">
                    for subtraction from normalized, powers of 2,
                     use next-smaller exponent                    
                </comment>
                <declaration name="lbits" type="long" line="243"/>
                <declaration name="binexp" type="int" line="244"/>
                <declaration name="ulpval" type="double" line="245"/>
                <scope line="246"/>
                <scope line="251"/>
                <scope line="253"/>
                <scope line="255"/>
            </method>
            <method name="stickyRound" type="float" line="273">
                <params>
                    <param name="dval" type="double"/>
                </params>
                <comment line="278">
                    what we have here is special.
                     don&apos;t worry, the right thing will happen.                    
                </comment>
                <comment line="282">
                    hack-o-matic.                    
                </comment>
                <declaration name="lbits" type="long" line="274"/>
                <declaration name="binexp" type="long" line="275"/>
                <scope line="276"/>
            </method>
            <method name="developLongDigits" type="void" line="302">
                <params>
                    <param name="decExponent" type="int"/>
                    <param name="lvalue" type="long"/>
                    <param name="insignificant" type="long"/>
                </params>
                <comment line="308">
                    Discard non-significant low-order bits, while rounding,
                     up to insignificant value.                    
                </comment>
                <comment line="315">
                    10^i == 5^i * 2^i;                    
                </comment>
                <comment line="320">
                    round up based on the low-order bits we&apos;re discarding                    
                </comment>
                <comment line="325">
                    lvalue &lt;= 0                    
                </comment>
                <comment line="326">
                    even easier subcase!
                     can do int arithmetic rather than long!                    
                </comment>
                <comment line="347">
                    same algorithm as above (same bugs, too )
                     but using long arithmetic.                    
                </comment>
                <declaration name="digits" type="char" line="303"/>
                <declaration name="ndigits" type="int" line="304"/>
                <declaration name="digitno" type="int" line="305"/>
                <declaration name="c" type="int" line="306"/>
                <declaration name="i" type="int" line="310"/>
                <scope line="313">
                    <declaration name="pow10" type="long" line="314"/>
                    <declaration name="residue" type="long" line="315"/>
                    <scope line="318"/>
                </scope>
                <scope line="323">
                    <declaration name="ivalue" type="int" line="327"/>
                    <scope line="333"/>
                    <scope line="338"/>
                </scope>
                <scope line="345">
                    <scope line="353"/>
                    <scope line="358"/>
                </scope>
                <declaration name="result" type="char" line="366"/>
            </method>
            <method name="roundup" type="void" line="383">
                <comment line="393">
                    carryout! High-order 1, rest 0s, larger exp.                    
                </comment>
                <comment line="398">
                    else fall through.                    
                </comment>
                <declaration name="i" type="int" line="384"/>
                <declaration name="q" type="int" line="385"/>
                <scope line="386">
                    <scope line="387"/>
                    <scope line="391"/>
                </scope>
            </method>
            <method name="FloatingDecimal" type="constructor" line="406">
                <params>
                    <param name="d" type="double"/>
                </params>
                <comment line="413">
                    discover and delete sign                    
                </comment>
                <comment line="420">
                    Begin to unpack
                     Discover obvious special cases of NaN and Infinity.                    
                </comment>
                <comment line="430">
                    NaN has no sign!                    
                </comment>
                <comment line="436">
                    Finish unpacking
                     Normalize denormalized numbers.
                     Insert assumed high-order bit for normalized numbers.
                     Subtract exponent bias.                    
                </comment>
                <comment line="442">
                    not a denorm, just a 0!                    
                </comment>
                <comment line="452">
                    recall binExp is  - shift count.                    
                </comment>
                <comment line="459">
                    call the routine that actually does all the hard work.                    
                </comment>
                <declaration name="dBits" type="long" line="407"/>
                <declaration name="fractBits" type="long" line="408"/>
                <declaration name="binExp" type="int" line="409"/>
                <declaration name="nSignificantBits" type="int" line="410"/>
                <scope line="413"/>
                <scope line="416"/>
                <scope line="423">
                    <scope line="425"/>
                    <scope line="427"/>
                </scope>
                <scope line="439">
                    <scope line="440"/>
                    <scope line="447"/>
                </scope>
                <scope line="453"/>
            </method>
            <method name="FloatingDecimal" type="constructor" line="466">
                <params>
                    <param name="f" type="float"/>
                </params>
                <comment line="473">
                    discover and delete sign                    
                </comment>
                <comment line="480">
                    Begin to unpack
                     Discover obvious special cases of NaN and Infinity.                    
                </comment>
                <comment line="490">
                    NaN has no sign!                    
                </comment>
                <comment line="496">
                    Finish unpacking
                     Normalize denormalized numbers.
                     Insert assumed high-order bit for normalized numbers.
                     Subtract exponent bias.                    
                </comment>
                <comment line="502">
                    not a denorm, just a 0!                    
                </comment>
                <comment line="512">
                    recall binExp is  - shift count.                    
                </comment>
                <comment line="519">
                    call the routine that actually does all the hard work.                    
                </comment>
                <declaration name="fBits" type="int" line="467"/>
                <declaration name="fractBits" type="int" line="468"/>
                <declaration name="binExp" type="int" line="469"/>
                <declaration name="nSignificantBits" type="int" line="470"/>
                <scope line="473"/>
                <scope line="476"/>
                <scope line="483">
                    <scope line="485"/>
                    <scope line="487"/>
                </scope>
                <scope line="499">
                    <scope line="500"/>
                    <scope line="507"/>
                </scope>
                <scope line="513"/>
            </method>
            <method name="dtoa" type="void" line="524">
                <params>
                    <param name="binExp" type="int"/>
                    <param name="fractBits" type="long"/>
                    <param name="nSignificantBits" type="int"/>
                </params>
                <comment line="526">
                    number of significant bits of fractBits;                    
                </comment>
                <comment line="527">
                    number of these to the right of the point.                    
                </comment>
                <comment line="530">
                    Examine number. Determine if it is an easy case,
                     which we can do pretty trivially using float/long conversion,
                     or whether we must do real work.                    
                </comment>
                <comment line="536">
                    Look more closely at the number to decide if,
                     with scaling by 10^nTinyBits, the result will fit in
                     a long.                    
                </comment>
                <comment line="540">
                    We can do this:
                     take the fraction bits, which are normalized.
                     (a) nTinyBits == 0: Shift left or right appropriately
                         to align the binary point at the extreme right, i.e.
                         where a long int point is expected to be. The integer
                         result is easily converted to a string.
                     (b) nTinyBits &gt; 0: Shift right by expShift-nFractBits,
                         which effectively converts to long and scales by
                         2^nTinyBits. Then multiply by 5^nTinyBits to
                         complete the scaling. We know this won&apos;t overflow
                         because we just counted the number of bits necessary
                         in the result. The integer you get from this can
                         then be converted to a string pretty easily.                    
                </comment>
                <comment line="570">
                    The following causes excess digits to be printed
                     out in the single-float case. Our manipulation of
                     halfULP here is apparently not correct. If we
                     better understand how this works, perhaps we can
                     use this special case again. But for the time being,
                     we do not.
                     else {
                         fractBits &gt;&gt;&gt;= expShift+1-nFractBits;
                         fractBits = long5pow[ nTinyBits ];
                         halfULP = long5pow[ nTinyBits ] &gt;&gt; (1+nSignificantBits-nFractBits);
                         developLongDigits( -nTinyBits, fractBits, halfULP );
                         return;
                     }                    
                </comment>
                <comment line="587">
                    This is the hard case. We are going to compute large positive
                     integers B and S and integer decExp, s.t.
                          d = ( B  S )  10^decExp
                          1 &lt;= B  S &lt; 10
                     Obvious choices are:
                          decExp = floor( log10(d) )
                          B      = d  2^nTinyBits  10^max( 0, -decExp )
                          S      = 10^max( 0, decExp)  2^nTinyBits
                     (noting that nTinyBits has already been forced to non-negative)
                     I am also going to compute a large positive integer
                          M      = (12^nSignificantBits)  2^nTinyBits  10^max( 0, -decExp )
                     i.e. M is (12) of the ULP of d, scaled like B.
                     When we iterate through dividing BS and picking off the
                     quotient bits, we will know when to stop when the remainder
                     is &lt;= M.
                    
                     We keep track of powers of 2 and powers of 5.                    
                </comment>
                <comment line="607">
                    Estimate decimal exponent. (If it is small-ish,
                     we could double-check.)
                    
                     First, scale the mantissa bits such that 1 &lt;= d2 &lt; 2.
                     We are then going to estimate
                              log10(d2) ~=~  (d2-1.5)1.5 + log(1.5)
                     and so we can estimate
                          log10(d) ~=~ log10(d2) + binExp  log10(2)
                     take the floor and call it decExp.
                     FIXME -- use more precise constants here. It costs no more.                    
                </comment>
                <comment line="623">
                    powers of 2 and powers of 5, respectively, in B                    
                </comment>
                <comment line="624">
                    powers of 2 and powers of 5, respectively, in S                    
                </comment>
                <comment line="625">
                    powers of 2 and powers of 5, respectively, in M                    
                </comment>
                <comment line="626">
                    binary digits needed to represent B, approx.                    
                </comment>
                <comment line="627">
                    binary digits needed to represent 10*S, approx.                    
                </comment>
                <comment line="639">
                    the long integer fractBits contains the (nFractBits) interesting
                     bits from the mantissa of d ( hidden 1 added if necessary) followed
                     by (expShift+1-nFractBits) zeros. In the interest of compactness,
                     I will shift out those zeros before turning fractBits into a
                     FDBigInt. The resulting whole number will be
                          d  2^(nFractBits-1-binExp).                    
                </comment>
                <comment line="654">
                    HACK!! For exact powers of two, the next smallest number
                     is only half as far away as we think (because the meaning of
                     ULP changes at power-of-two bounds) for this reason, we
                     hack M2. Hope this works.                    
                </comment>
                <comment line="664">
                    oops.
                     since we cannot scale M down far enough,
                     we must scale the other values up.                    
                </comment>
                <comment line="671">
                    Construct, Scale, iterate.
                     Some day, we&apos;ll write a stopping test that takes
                     account of the asymmetry of the spacing of floating-point
                     numbers below perfect powers of 2
                     26 Sept 96 is not that day.
                     So we use a symmetric test.                    
                </comment>
                <comment line="685">
                    Detect the special cases where all the numbers we are about
                     to compute will fit in int or long integers.
                     In these cases, we will avoid doing FDBigInt arithmetic.
                     We use the same algorithms, except that we &quot;normalize&quot;
                     our FDBigInts before iterating. This is to make division easier,
                     as it makes our fist guess (quotient of high-order words)
                     more accurate!
                    
                     Some day, we&apos;ll write a stopping test that takes
                     account of the asymmetry of the spacing of floating-point
                     numbers below perfect powers of 2
                     26 Sept 96 is not that day.
                     So we use a symmetric test.                    
                </comment>
                <comment line="704">
                    wa-hoo! They&apos;re all ints!                    
                </comment>
                <comment line="709">
                    Unroll the first iteration. If our decExp estimate
                     was too high, our first quotient will be zero. In this
                     case, we discard it and decrement decExp.                    
                </comment>
                <comment line="720">
                    excessively large digit                    
                </comment>
                <comment line="722">
                    oops. Usually ignore leading zero.                    
                </comment>
                <comment line="727">
                    HACK! Java spec sez that we always have at least
                     one digit after the . in either F- or E-form output.
                     Thus we will need more than one digit if we&apos;re using
                     E-form                    
                </comment>
                <comment line="740">
                    excessively large digit                    
                </comment>
                <comment line="745">
                    hack -- m might overflow!
                     in this case, it is certainly &gt; b,
                     which won&apos;t
                     and b+m &gt; tens, too, since that has overflowed
                     either!                    
                </comment>
                <comment line="757">
                    still good! they&apos;re all longs!                    
                </comment>
                <comment line="762">
                    Unroll the first iteration. If our decExp estimate
                     was too high, our first quotient will be zero. In this
                     case, we discard it and decrement decExp.                    
                </comment>
                <comment line="773">
                    excessively large digit                    
                </comment>
                <comment line="775">
                    oops. Usually ignore leading zero.                    
                </comment>
                <comment line="780">
                    HACK! Java spec sez that we always have at least
                     one digit after the . in either F- or E-form output.
                     Thus we will need more than one digit if we&apos;re using
                     E-form                    
                </comment>
                <comment line="793">
                    excessively large digit                    
                </comment>
                <comment line="798">
                    hack -- m might overflow!
                     in this case, it is certainly &gt; b,
                     which won&apos;t
                     and b+m &gt; tens, too, since that has overflowed
                     either!                    
                </comment>
                <comment line="814">
                    We really must do FDBigInt arithmetic.
                     Fist, construct our FDBigInt initial values.                    
                </comment>
                <comment line="823">
                    normalize so that division works better                    
                </comment>
                <comment line="827">
                    Unroll the first iteration. If our decExp estimate
                     was too high, our first quotient will be zero. In this
                     case, we discard it and decrement decExp.                    
                </comment>
                <comment line="837">
                    excessively large digit                    
                </comment>
                <comment line="839">
                    oops. Usually ignore leading zero.                    
                </comment>
                <comment line="844">
                    HACK! Java spec sez that we always have at least
                     one digit after the . in either F- or E-form output.
                     Thus we will need more than one digit if we&apos;re using
                     E-form                    
                </comment>
                <comment line="856">
                    excessively large digit                    
                </comment>
                <comment line="865">
                    this here only for flow analysis!                    
                </comment>
                <comment line="870">
                    Last digit gets rounded based on stopping condition.                    
                </comment>
                <comment line="876">
                    it&apos;s a tie!
                     choose based on which digits we like.                    
                </comment>
                <declaration name="nFractBits" type="int" line="525"/>
                <declaration name="nTinyBits" type="int" line="526"/>
                <declaration name="decExp" type="int" line="527"/>
                <scope line="534">
                    <scope line="538">
                        <declaration name="halfULP" type="long" line="554"/>
                        <scope line="555">
                            <scope line="556"/>
                            <scope line="558"/>
                            <scope line="561"/>
                            <scope line="563"/>
                        </scope>
                    </scope>
                </scope>
                <declaration name="d2" type="double" line="618"/>
                <declaration name="B2" type="int" line="622"/>
                <declaration name="S2" type="int" line="623"/>
                <declaration name="M2" type="int" line="624"/>
                <declaration name="Bbits" type="int" line="625"/>
                <declaration name="tenSbits" type="int" line="626"/>
                <declaration name="Sval" type="FDBigInt" line="627"/>
                <declaration name="common2factor" type="int" line="648"/>
                <scope line="662"/>
                <declaration name="digits" type="char" line="678"/>
                <declaration name="ndigit" type="int" line="679"/>
                <declaration name="low" type="boolean" line="680"/>
                <declaration name="lowDigitDifference" type="long" line="681"/>
                <declaration name="q" type="int" line="682"/>
                <scope line="701">
                    <scope line="702">
                        <declaration name="b" type="int" line="704"/>
                        <declaration name="s" type="int" line="705"/>
                        <declaration name="m" type="int" line="706"/>
                        <declaration name="tens" type="int" line="707"/>
                        <scope line="720"/>
                        <scope line="723"/>
                        <scope line="732"/>
                        <scope line="735">
                            <scope line="740"/>
                            <scope line="743"/>
                        </scope>
                    </scope>
                    <scope line="755">
                        <declaration name="b" type="long" line="757"/>
                        <declaration name="s" type="long" line="758"/>
                        <declaration name="m" type="long" line="759"/>
                        <declaration name="tens" type="long" line="760"/>
                        <scope line="773"/>
                        <scope line="776"/>
                        <scope line="785"/>
                        <scope line="788">
                            <scope line="793"/>
                            <scope line="796"/>
                        </scope>
                    </scope>
                </scope>
                <scope line="809">
                    <declaration name="tenSval" type="FDBigInt" line="810"/>
                    <declaration name="shiftBias" type="int" line="811"/>
                    <scope line="837"/>
                    <scope line="840"/>
                    <scope line="849"/>
                    <scope line="852"/>
                    <scope line="860"/>
                </scope>
                <scope line="872">
                    <scope line="873">
                        <scope line="874"/>
                        <scope line="878"/>
                    </scope>
                    <scope line="881"/>
                </scope>
            </method>
            <method name="toString" type="String" line="888">
                <comment line="890">
                    most brain-dead version                    
                </comment>
                <declaration name="result" type="StringBuffer" line="890"/>
                <scope line="891"/>
                <scope line="892"/>
                <scope line="894"/>
            </method>
            <method name="toJavaFormatString" type="String" line="903">
                <declaration name="result" type="char" line="904"/>
                <declaration name="i" type="int" line="905"/>
            </method>
            <method name="getChars" type="int" line="909">
                <params>
                    <param name="result" type="char[]"/>
                </params>
                <comment line="911">
                    generous bound on size of nDigits                    
                </comment>
                <comment line="919">
                    print digits.digits.                    
                </comment>
                <comment line="965">
                    decExponent has 1, 2, or 3, digits                    
                </comment>
                <declaration name="i" type="int" line="911"/>
                <scope line="912"/>
                <scope line="913"/>
                <scope line="916">
                    <scope line="917">
                        <declaration name="charLength" type="int" line="919"/>
                        <scope line="922"/>
                        <scope line="928">
                            <scope line="930">
                                <declaration name="t" type="int" line="931"/>
                            </scope>
                            <scope line="934"/>
                        </scope>
                    </scope>
                    <scope line="938">
                        <scope line="941"/>
                    </scope>
                    <scope line="947">
                        <scope line="950"/>
                        <scope line="953"/>
                        <declaration name="e" type="int" line="957"/>
                        <scope line="958"/>
                        <scope line="961"/>
                        <scope line="965"/>
                        <scope line="967"/>
                        <scope line="970"/>
                    </scope>
                </scope>
            </method>
            <declaration name="perThreadBuffer" type="ThreadLocal" line="982"/>
            <anonymous_class line="982">
                <method name="initialValue" type="Object" line="983"/>
            </anonymous_class>
            <method name="appendTo" type="void" line="988">
                <params>
                    <param name="buf" type="Appendable"/>
                </params>
                <declaration name="result" type="char" line="989"/>
                <declaration name="i" type="int" line="990"/>
            </method>
            <method name="readJavaFormatString" type="FloatingDecimal" line="1000">
                <params>
                    <param name="in" type="String"/>
                </params>
                <comment line="1009">
                    don&apos;t fool around with white space.
                     throws NullPointerException if null                    
                </comment>
                <comment line="1017">
                    FALLTHROUGH                    
                </comment>
                <comment line="1023">
                    Check for NaN and Infinity strings                    
                </comment>
                <comment line="1025">
                    possible NaN or infinity                    
                </comment>
                <comment line="1027">
                    char array of &quot;NaN&quot; or &quot;Infinity&quot;                    
                </comment>
                <comment line="1036">
                    compare Input string to &quot;NaN&quot; or &quot;Infinity&quot;                    
                </comment>
                <comment line="1042">
                    something is amiss, throw exception                    
                </comment>
                <comment line="1046">
                    For the candidate string to be a NaN or infinity,
                     all characters in input string and target char[]
                     must be matched ==&gt; j must equal targetChars.length
                     and i must equal l                    
                </comment>
                <comment line="1050">
                    return NaN or infinity                    
                </comment>
                <comment line="1051">
                    NaN has no sign                    
                </comment>
                <comment line="1056">
                    something went wrong, throw exception                    
                </comment>
                <comment line="1060">
                    check for hexadecimal floating-point number                    
                </comment>
                <comment line="1063">
                    possible hex string                    
                </comment>
                <comment line="1066">
                    look for and process decimal floating-point string                    
                </comment>
                <comment line="1083">
                    out of switch.                    
                </comment>
                <comment line="1098">
                    out of switch.                    
                </comment>
                <comment line="1101">
                    already saw one ., this is the 2nd.                    
                </comment>
                <comment line="1109">
                    out of switch.                    
                </comment>
                <comment line="1115">
                    At this point, we&apos;ve scanned all the digits and decimal
                     point we&apos;re going to see. Trim off leading and trailing
                     zeros, which will just confuse us later, and adjust
                     our initial decimal exponent accordingly.
                     To review:
                     we have seen i total characters.
                     nLeadZero of them were zeros before any other digits.
                     nTrailZero of them were zeros after any other digits.
                     if ( decSeen ), then a . was seen after decPt characters
                     ( including leading zeros which have been discarded )
                     nDigits characters were neither lead nor trailing
                     zeros, nor point                    
                </comment>
                <comment line="1129">
                    special hack: if we saw no non-zero digits, then the
                     answer is zero!
                     Unfortunately, we feel honor-bound to keep parsing!                    
                </comment>
                <comment line="1138">
                    we saw NO DIGITS AT ALL,
                     not even a crummy 0!
                     this is not allowed.                    
                </comment>
                <comment line="1141">
                    go throw exception                    
                </comment>
                <comment line="1146">
                    Our initial exponent is decPt, adjusted by the number of
                     discarded zeros. Or, if there was no decPt,
                     then its just nDigits adjusted by discarded trailing zeros.                    
                </comment>
                <comment line="1156">
                    Look for &apos;e&apos; or &apos;E&apos; and an optionally signed integer.                    
                </comment>
                <comment line="1167">
                    FALLTHROUGH                    
                </comment>
                <comment line="1175">
                    the next character will cause integer
                     overflow.                    
                </comment>
                <comment line="1193">
                    back up.                    
                </comment>
                <comment line="1194">
                    stop parsing exponent.                    
                </comment>
                <comment line="1199">
                    The intent here is to end up with
                     infinity or zero, as appropriate.
                     The reason for yielding such a small decExponent,
                     rather than something intuitive such as
                     expSign*Integer.MAX_VALUE, is that this value
                     is subject to further manipulation in
                     doubleValue() and floatValue(), and I don&apos;t want
                     it to be able to cause overflow there!
                     (The only way we can get into trouble here is for
                     really outrageous nDigits+nTrailZero, such as 2 billion. )                    
                </comment>
                <comment line="1213">
                    this should not overflow, since we tested
                     for expVal &gt; (MAX+N), where N &gt;= abs(decExp)                    
                </comment>
                <comment line="1218">
                    if we saw something not a digit ( or end of string )
                     after the [Ee][+-], without seeing any digits at all
                     this is certainly an error. If we saw some digits,
                     but then some trailing garbage, that might be ok.
                     so we just fall through in that case.
                     HUMBUG                    
                </comment>
                <comment line="1225">
                    certainly bad                    
                </comment>
                <comment line="1227">
                    We parsed everything we could.
                     If there are leftovers, then this is not good input!                    
                </comment>
                <comment line="1237">
                    go throw exception                    
                </comment>
                <declaration name="isNegative" type="boolean" line="1001"/>
                <declaration name="signSeen" type="boolean" line="1002"/>
                <declaration name="decExp" type="int" line="1003"/>
                <declaration name="c" type="char" line="1004"/>
                <scope line="1007">
                    <declaration name="l" type="int" line="1010"/>
                    <declaration name="i" type="int" line="1012"/>
                    <scope line="1024">
                        <declaration name="potentialNaN" type="boolean" line="1025"/>
                        <declaration name="targetChars" type="char" line="1026"/>
                        <scope line="1028"/>
                        <scope line="1031"/>
                        <declaration name="j" type="int" line="1036"/>
                        <scope line="1037">
                            <scope line="1038"/>
                        </scope>
                        <scope line="1049"/>
                        <scope line="1055"/>
                    </scope>
                    <scope line="1059">
                        <scope line="1060">
                            <declaration name="ch" type="char" line="1061"/>
                        </scope>
                    </scope>
                    <declaration name="digits" type="char[]" line="1067"/>
                    <declaration name="nDigits" type="int" line="1068"/>
                    <declaration name="decSeen" type="boolean" line="1069"/>
                    <declaration name="decPt" type="int" line="1070"/>
                    <declaration name="nLeadZero" type="int" line="1071"/>
                    <declaration name="nTrailZero" type="int" line="1072"/>
                    <scope line="1074">
                        <scope line="1077"/>
                        <scope line="1079"/>
                        <scope line="1092"/>
                        <scope line="1099"/>
                        <scope line="1104"/>
                    </scope>
                    <scope line="1133">
                        <scope line="1136"/>
                    </scope>
                    <scope line="1149"/>
                    <scope line="1151"/>
                    <scope line="1158">
                        <declaration name="expSign" type="int" line="1159"/>
                        <declaration name="expVal" type="int" line="1160"/>
                        <declaration name="reallyBig" type="int" line="1161"/>
                        <declaration name="expOverflow" type="boolean" line="1162"/>
                        <declaration name="expAt" type="int" line="1170"/>
                        <scope line="1172">
                            <scope line="1173"/>
                        </scope>
                        <declaration name="expLimit" type="int" line="1196"/>
                        <scope line="1197"/>
                        <scope line="1211"/>
                    </scope>
                    <scope line="1235"/>
                </scope>
                <scope line="1240"/>
            </method>
            <method name="doubleValue" type="double" line="1253">
                <comment line="1260">
                    First, check for NaN and Infinity values                    
                </comment>
                <comment line="1271">
                    convert the lead kDigits to a long integer.                    
                </comment>
                <comment line="1274">
                    (special performance hack: start to do it using int)                    
                </comment>
                <comment line="1286">
                    lValue now contains a long integer with the value of
                     the first kDigits digits of the number.
                     dValue contains the (double) of the same.                    
                </comment>
                <comment line="1293">
                    possibly an easy case.
                     We know that the digits can be represented
                     exactly. And if the exponent isn&apos;t too outrageous,
                     the whole thing can be done with one operation,
                     thus one rounding error.
                     Note that all our constructors trim all leading and
                     trailing zeros, so simple values (including zero)
                     will always end up here                    
                </comment>
                <comment line="1304">
                    small floating integer                    
                </comment>
                <comment line="1307">
                    Can get the answer with one operation,
                     thus one roundoff.                    
                </comment>
                <comment line="1322">
                    We can multiply dValue by 10^(slop)
                     and it is still &quot;small&quot; and exact.
                     Then we can multiply by 10^(exp-slop)
                     with one rounding.                    
                </comment>
                <comment line="1339">
                    Else we have a hard case with a positive exp.                    
                </comment>
                <comment line="1344">
                    Can get the answer in one division.                    
                </comment>
                <comment line="1356">
                    Else we have a hard case with a negative exp.                    
                </comment>
                <comment line="1362">
                    Harder cases:
                     The sum of digits plus exponent is greater than
                     what we think we can do with one error.
                    
                     Start by approximating the right answer by,
                     naively, scaling by powers of 10.                    
                </comment>
                <comment line="1372">
                    Lets face it. This is going to be
                     Infinity. Cut to the chase.                    
                </comment>
                <comment line="1387">
                    The reason for the weird exp &gt; 1 condition
                     in the above loop was so that the last multiply
                     would get unrolled. We handle it here.
                     It could overflow.                    
                </comment>
                <comment line="1395">
                    It did overflow.
                     Look more closely at the result.
                     If the exponent is just one too large,
                     then use the maximum finite as our estimate
                     value. Else call the result infinity
                     and punt it.
                     ( I presume this could happen because
                     rounding forces the result here to be
                     an ULP or two larger than
                     Double.MAX_VALUE ).                    
                </comment>
                <comment line="1419">
                    Lets face it. This is going to be
                     zero. Cut to the chase.                    
                </comment>
                <comment line="1434">
                    The reason for the weird exp &gt; 1 condition
                     in the above loop was so that the last multiply
                     would get unrolled. We handle it here.
                     It could underflow.                    
                </comment>
                <comment line="1442">
                    It did underflow.
                     Look more closely at the result.
                     If the exponent is just one too small,
                     then use the minimum finite as our estimate
                     value. Else call the result 0.0
                     and punt it.
                     ( I presume this could happen because
                     rounding forces the result here to be
                     an ULP or two less than
                     Double.MIN_VALUE ).                    
                </comment>
                <comment line="1465">
                    dValue is now approximately the result.
                     The hard part is adjusting it, by comparison
                     with FDBigInt arithmetic.
                     Formulate the EXACT big-number result as
                     bigD0  10^exp                    
                </comment>
                <comment line="1477">
                    AS A SIDE EFFECT, THIS METHOD WILL SET THE INSTANCE VARIABLES
                     bigIntExp and bigIntNBits                    
                </comment>
                <comment line="1482">
                    Scale bigD, bigB appropriately for
                     big-integer operations.
                     Naively, we multiply by powers of ten
                     and powers of two. What we actually do
                     is keep track of the powers of 5 and
                     powers of 2 we would use, then factor out
                     common divisors before doing the work.                    
                </comment>
                <comment line="1491">
                    powers of 2, 5 in bigB                    
                </comment>
                <comment line="1492">
                    powers of 2, 5 in bigD                    
                </comment>
                <comment line="1493">
                    powers of 2 in halfUlp.                    
                </comment>
                <comment line="1507">
                    shift bigB and bigD left by a number s. t.
                     halfUlp is still an integer.                    
                </comment>
                <comment line="1511">
                    This is going to be a denormalized number
                     (if not actually zero).
                     half an ULP is at 2^-(expBias+expShift+1)                    
                </comment>
                <comment line="1520">
                    if there are common factors of 2, we might just as well
                     factor them out, as they add nothing useful.                    
                </comment>
                <comment line="1526">
                    do multiplications by powers of 5 and 2                    
                </comment>
                <comment line="1529">
                    to recap:
                     bigB is the scaled-big-int version of our floating-point
                     candidate.
                     bigD is the scaled-big-int version of the exact value
                     as we understand it.
                     halfUlp is 1/2 an ulp of bigB, except for special cases
                     of exact powers of 2
                    
                     the plan is to compare bigB with bigD, and if the difference
                     is less than halfUlp, then we&apos;re satisfied. Otherwise,
                     use the ratio of difference to halfUlp to calculate a fudge
                     factor to add to the floating value, then go &apos;round again.                    
                </comment>
                <comment line="1547">
                    our candidate is too big.                    
                </comment>
                <comment line="1550">
                    candidate is a normalized exact power of 2 and
                     is too big. We will be subtracting.
                     For our purposes, ulp is the ulp of the
                     next smaller range.                    
                </comment>
                <comment line="1556">
                    rats. Cannot de-scale ulp this far.
                     must scale diff in other direction.                    
                </comment>
                <comment line="1563">
                    our candidate is too small.                    
                </comment>
                <comment line="1566">
                    the candidate is exactly right!
                     this happens with surprising frequency                    
                </comment>
                <comment line="1572">
                    difference is small.
                     this is close enough                    
                </comment>
                <comment line="1579">
                    difference is exactly half an ULP
                     round to some other value maybe, then finish                    
                </comment>
                <comment line="1582">
                    should check for bigIntNBits == 1 here??                    
                </comment>
                <comment line="1588">
                    difference is non-trivial.
                     could scale addend by ratio of difference to
                     halfUlp here, if we bothered to compute that difference.
                     Most of the time ( I hope ) it is about 1 anyway.                    
                </comment>
                <comment line="1594">
                    oops. Fell off end of range.                    
                </comment>
                <comment line="1595">
                    try again.                    
                </comment>
                <declaration name="kDigits" type="int" line="1254"/>
                <declaration name="lValue" type="long" line="1255"/>
                <declaration name="dValue" type="double" line="1256"/>
                <declaration name="rValue" type="double" line="1257"/>
                <scope line="1260"/>
                <scope line="1266">
                    <scope line="1267"/>
                    <declaration name="iValue" type="int" line="1274"/>
                    <declaration name="iDigits" type="int" line="1275"/>
                    <scope line="1276"/>
                    <scope line="1280"/>
                    <declaration name="exp" type="int" line="1284"/>
                    <scope line="1291">
                        <scope line="1304">
                            <scope line="1305">
                                <scope line="1311"/>
                            </scope>
                            <declaration name="slop" type="int" line="1319"/>
                            <scope line="1320">
                                <scope line="1330"/>
                            </scope>
                        </scope>
                        <scope line="1341">
                            <scope line="1342">
                                <scope line="1348"/>
                            </scope>
                        </scope>
                    </scope>
                    <scope line="1369">
                        <scope line="1370"/>
                        <scope line="1377"/>
                        <scope line="1380">
                            <declaration name="j" type="int" line="1381"/>
                            <scope line="1382"/>
                            <declaration name="t" type="double" line="1392"/>
                            <scope line="1393">
                                <scope line="1408"/>
                            </scope>
                        </scope>
                    </scope>
                    <scope line="1415">
                        <scope line="1417"/>
                        <scope line="1424"/>
                        <scope line="1427">
                            <declaration name="j" type="int" line="1428"/>
                            <scope line="1429"/>
                            <declaration name="t" type="double" line="1439"/>
                            <scope line="1440">
                                <scope line="1455"/>
                            </scope>
                        </scope>
                    </scope>
                    <declaration name="bigD0" type="FDBigInt" line="1471"/>
                    <scope line="1475">
                        <declaration name="bigB" type="FDBigInt" line="1479"/>
                        <declaration name="B2" type="int" line="1490"/>
                        <declaration name="D2" type="int" line="1491"/>
                        <declaration name="Ulp2" type="int" line="1492"/>
                        <scope line="1493"/>
                        <scope line="1496"/>
                        <scope line="1500"/>
                        <scope line="1502"/>
                        <declaration name="hulpbias" type="int" line="1508"/>
                        <scope line="1509"/>
                        <scope line="1514"/>
                        <declaration name="common2" type="int" line="1521"/>
                        <declaration name="bigD" type="FDBigInt" line="1527"/>
                        <declaration name="diff" type="FDBigInt" line="1542"/>
                        <declaration name="cmpResult" type="int" line="1543"/>
                        <declaration name="overvalue" type="boolean" line="1544"/>
                        <scope line="1545">
                            <scope line="1548">
                                <scope line="1554"/>
                            </scope>
                        </scope>
                        <scope line="1561"/>
                        <scope line="1564"/>
                        <declaration name="halfUlp" type="FDBigInt" line="1569"/>
                        <scope line="1570">
                            <scope line="1573"/>
                        </scope>
                        <scope line="1577">
                            <scope line="1582"/>
                        </scope>
                        <scope line="1586"/>
                    </scope>
                </scope>
            </method>
            <method name="floatValue" type="float" line="1612">
                <comment line="1618">
                    First, check for NaN and Infinity values                    
                </comment>
                <comment line="1626">
                    convert the lead kDigits to an integer.                    
                </comment>
                <comment line="1635">
                    iValue now contains an integer with the value of
                     the first kDigits digits of the number.
                     fValue contains the (float) of the same.                    
                </comment>
                <comment line="1642">
                    possibly an easy case.
                     We know that the digits can be represented
                     exactly. And if the exponent isn&apos;t too outrageous,
                     the whole thing can be done with one operation,
                     thus one rounding error.
                     Note that all our constructors trim all leading and
                     trailing zeros, so simple values (including zero)
                     will always end up here.                    
                </comment>
                <comment line="1653">
                    small floating integer                    
                </comment>
                <comment line="1656">
                    Can get the answer with one operation,
                     thus one roundoff.                    
                </comment>
                <comment line="1665">
                    We can multiply dValue by 10^(slop)
                     and it is still &quot;small&quot; and exact.
                     Then we can multiply by 10^(exp-slop)
                     with one rounding.                    
                </comment>
                <comment line="1675">
                    Else we have a hard case with a positive exp.                    
                </comment>
                <comment line="1680">
                    Can get the answer in one division.                    
                </comment>
                <comment line="1686">
                    Else we have a hard case with a negative exp.                    
                </comment>
                <comment line="1691">
                    In double-precision, this is an exact floating integer.
                     So we can compute to double, then shorten to float
                     with one round, and get the right answer.
                    
                     First, finish accumulating digits.
                     Then convert that integer to a double, multiply
                     by the appropriate power of ten, and convert to float.                    
                </comment>
                <comment line="1711">
                    Harder cases:
                     The sum of digits plus exponent is greater than
                     what we think we can do with one error.
                    
                     Start by weeding out obviously out-of-range
                     results, then convert to double and go to
                     common hard-case code.                    
                </comment>
                <comment line="1721">
                    Lets face it. This is going to be
                     Infinity. Cut to the chase.                    
                </comment>
                <comment line="1727">
                    Lets face it. This is going to be
                     zero. Cut to the chase.                    
                </comment>
                <comment line="1734">
                    Here, we do &apos;way too much work, but throwing away
                     our partial results, and going and doing the whole
                     thing as double, then throwing away half the bits that computes
                     when we convert back to float.
                    
                     The alternative is to reproduce the whole multiple-precision
                     algorithm for float precision, or to try to parameterize it
                     for common usage. The former will take about 400 lines of code,
                     and the latter I tried without success. Thus the semi-hack
                     answer here.                    
                </comment>
                <declaration name="kDigits" type="int" line="1613"/>
                <declaration name="iValue" type="int" line="1614"/>
                <declaration name="fValue" type="float" line="1615"/>
                <scope line="1618"/>
                <scope line="1624">
                    <scope line="1629"/>
                    <declaration name="exp" type="int" line="1633"/>
                    <scope line="1640">
                        <scope line="1653">
                            <scope line="1654"/>
                            <declaration name="slop" type="int" line="1662"/>
                            <scope line="1663"/>
                        </scope>
                        <scope line="1677">
                            <scope line="1678"/>
                        </scope>
                    </scope>
                    <scope line="1689">
                        <declaration name="lValue" type="long" line="1699"/>
                        <scope line="1700"/>
                        <declaration name="dValue" type="double" line="1703"/>
                    </scope>
                    <scope line="1719"/>
                    <scope line="1725"/>
                    <declaration name="dValue" type="double" line="1746"/>
                </scope>
            </method>
            <declaration name="small10pow" type="double" line="1756"/>
            <declaration name="singleSmall10pow" type="float" line="1765"/>
            <declaration name="big10pow" type="double" line="1771"/>
            <declaration name="tiny10pow" type="double" line="1773"/>
            <declaration name="maxSmallTen" type="int" line="1776"/>
            <declaration name="singleMaxSmallTen" type="int" line="1777"/>
            <declaration name="small5pow" type="int" line="1779"/>
            <declaration name="long5pow" type="long" line="1797"/>
            <declaration name="n5bits" type="int" line="1828"/>
            <declaration name="infinity" type="char" line="1858"/>
            <declaration name="notANumber" type="char" line="1859"/>
            <declaration name="zero" type="char" line="1860"/>
            <declaration name="hexFloatPattern" type="Pattern" line="1867"/>
            <method name="getHexFloatPattern" type="Pattern" line="1868">
                <comment line="1872">
                    1           234                   56                7                   8      9                    
                </comment>
                <scope line="1869"/>
            </method>
            <method name="parseHexString" type="FloatingDecimal" line="1883">
                <params>
                    <param name="s" type="String"/>
                </params>
                <comment line="1885">
                    Verify string is a member of the hexadecimal floating-point
                     string language.                    
                </comment>
                <comment line="1891">
                    Input does not match pattern                    
                </comment>
                <comment line="1893">
                    validInput                    
                </comment>
                <comment line="1894">
                    We must isolate the sign, significand, and exponent
                     fields.  The sign value is straightforward.  Since
                     floating-point numbers are stored with a normalized
                     representation, the significand and exponent are
                     interrelated.
                    
                     After extracting the sign, we normalized the
                     significand as a hexadecimal value, calculating an
                     exponent adjust for any shifts made during
                     normalization.  If the significand is zero, the
                     exponent doesn&apos;t need to be examined since the output
                     will be zero.
                    
                     Next the exponent in the input string is extracted.
                     Afterwards, the significand is normalized as a binary
                     value and the input value&apos;s normalized exponent can be
                     computed.  The significand bits are copied into a
                     double significand; if the string has more logical bits
                     than can fit in a double, the extra bits affect the
                     round and sticky bits which are used to round the final
                     value.                    
                </comment>
                <comment line="1918">
                    Extract significand sign                    
                </comment>
                <comment line="1923">
                    Extract Significand magnitude                    
                </comment>
                <comment line="1924">
                    Based on the form of the significand, calculate how the
                     binary exponent needs to be adjusted to create a
                     normalized hexadecimal floating-point number; that
                     is, a number where there is one nonzero hex digit to
                     the left of the (hexa)decimal point.  Since we are
                     adjusting a binary, not hexadecimal exponent, the
                     exponent is adjusted by a multiple of 4.
                    
                     There are a number of significand scenarios to consider;
                     letters are used in indicate nonzero digits:
                    
                     1. 000xxxx       =&gt;      x.xxx   normalized
                        increase exponent by (number of x&apos;s - 1)4
                    
                     2. 000xxx.yyyy =&gt;        x.xxyyyy        normalized
                        increase exponent by (number of x&apos;s - 1)4
                    
                     3. .000yyy  =&gt;   y.yy    normalized
                        decrease exponent by (number of zeros + 1)4
                    
                     4. 000.00000yyy =&gt; y.yy normalized
                        decrease exponent by (number of zeros to right of point + 1)4
                    
                     If the significand is exactly zero, return a properly
                     signed zero.                    
                </comment>
                <comment line="1956">
                    number of meaningful digits to
                     left of &quot;decimal&quot; point
                     (leading zeros stripped)                    
                </comment>
                <comment line="1959">
                    number of digits to right of
                     &quot;decimal&quot; point; leading zeros
                     must always be accounted for                    
                </comment>
                <comment line="1962">
                    The significand is made up of either
                    
                     1. group 4 entirely (integer portion only)
                    
                     OR
                    
                     2. the fractional portion from group 7 plus any
                     (optional) integer portions from group 6.                    
                </comment>
                <comment line="1973">
                    Integer-only significand                    
                </comment>
                <comment line="1974">
                    Leading zeros never matter on the integer portion                    
                </comment>
                <comment line="1979">
                    Group 6 is the optional integer; leading zeros
                     never matter on the integer portion                    
                </comment>
                <comment line="1984">
                    fraction                    
                </comment>
                <comment line="1988">
                    Turn &quot;integer.fraction&quot; into &quot;integer&quot;+&quot;fraction&quot;                    
                </comment>
                <comment line="1990">
                    is the null                    
                </comment>
                <comment line="1991">
                    check necessary?                    
                </comment>
                <comment line="1998">
                    Adjust exponent as described above                    
                </comment>
                <comment line="2001">
                    Cases 1 and 2                    
                </comment>
                <comment line="2003">
                    Cases 3 and 4                    
                </comment>
                <comment line="2007">
                    If the significand is zero, the exponent doesn&apos;t
                     matter; return a properly signed zero.                    
                </comment>
                <comment line="2010">
                    Only zeros in input                    
                </comment>
                <comment line="2015">
                    Extract Exponent                    
                </comment>
                <comment line="2016">
                    Use an int to read in the exponent value; this should
                     provide more than sufficient range for non-contrived
                     inputs.  If reading the exponent in as an int does
                     overflow, examine the sign of the exponent and
                     significand to determine what to do.                    
                </comment>
                <comment line="2030">
                    At this point, we know the exponent is
                     syntactically well-formed as a sequence of
                     digits.  Therefore, if an NumberFormatException
                     is thrown, it must be due to overflowing int&apos;s
                     range.  Also, at this point, we have already
                     checked for a zero significand.  Thus the signs
                     of the exponent and significand determine the
                     final result:
                    
                                          significand
                                          +               -
                     exponent     +       +infinity       -infinity
                                  -       +0.0            -0.0                    
                </comment>
                <comment line="2048">
                    exponent sign                    
                </comment>
                <comment line="2049">
                    exponent magnitude                    
                </comment>
                <comment line="2051">
                    Calculate partially adjusted exponent                    
                </comment>
                <comment line="2054">
                    Starting copying non-zero bits into proper position in
                     a long; copy explicit bit too; this will be masked
                     later for normal values.                    
                </comment>
                <comment line="2063">
                    First iteration is different, since we only copy
                     from the leading significand bit; one more exponent
                     adjust will be needed...                    
                </comment>
                <comment line="2067">
                    IMPORTANT: make leadingDigit a long to avoid
                     surprising shift semantics!                    
                </comment>
                <comment line="2071">
                    Left shift the leading digit (53 - (bit position of
                     leading 1 in digit)); this sets the top bit of the
                     significand to 1.  The nextShift value is adjusted
                     to take into account the number of bit positions of
                     the leadingDigit actually used.  Finally, the
                     exponent is adjusted to normalize the significand
                     as a binary value, not just a hex value.                    
                </comment>
                <comment line="2083">
                                        
                </comment>
                <comment line="2084">
                    [2, 3]                    
                </comment>
                <comment line="2089">
                    [4, 7]                    
                </comment>
                <comment line="2094">
                    [8, f]                    
                </comment>
                <comment line="2101">
                    The preceding if-else could be replaced by a single
                     code block based on the high-order bit set in
                     leadingDigit.  Given leadingOnePosition,                    
                </comment>
                <comment line="2105">
                    significand |= leadingDigit &lt;&lt; (SIGNIFICAND_WIDTH - leadingOnePosition);
                     nextShift = 52 - (3 + leadingOnePosition);
                     exponent += (leadingOnePosition-1);                    
                </comment>
                <comment line="2110">
                    Now the exponent variable is equal to the normalized
                     binary exponent.  Code below will make representation
                     adjustments if the exponent is incremented after
                     rounding (includes overflows to infinity) or if the
                     result is subnormal.                    
                </comment>
                <comment line="2118">
                    Copy digit into significand until the significand can&apos;t
                     hold another full hex digit or there are no more input
                     hex digits.                    
                </comment>
                <comment line="2130">
                    After the above loop, the bulk of the string is copied.
                     Now, we must copy any partial hex digits into the
                     significand AND compute the round bit and start computing
                     sticky bit.                    
                </comment>
                <comment line="2135">
                    at least one hex input digit exists                    
                </comment>
                <comment line="2138">
                    from nextShift, figure out how many bits need
                     to be copied, if any                    
                </comment>
                <comment line="2140">
                    must be negative                    
                </comment>
                <comment line="2142">
                    three bits need to be copied in; can
                     set round bit                    
                </comment>
                <comment line="2149">
                    two bits need to be copied in; can
                     set round and start sticky                    
                </comment>
                <comment line="2157">
                    one bit needs to be copied in                    
                </comment>
                <comment line="2159">
                    Now set round and start sticky, if possible                    
                </comment>
                <comment line="2165">
                    all bits copied into significand; set
                     round and start sticky                    
                </comment>
                <comment line="2167">
                    is top bit set?                    
                </comment>
                <comment line="2168">
                    nonzeros in three low order bits?                    
                </comment>
                <comment line="2174">
                    break;                    
                </comment>
                <comment line="2177">
                    Round is set; sticky might be set.                    
                </comment>
                <comment line="2179">
                    For the sticky bit, it suffices to check the
                     current digit and test for any nonzero digits in
                     the remaining unprocessed input.                    
                </comment>
                <comment line="2190">
                    else all of string was seen, round and sticky are
                     correct as false.                    
                </comment>
                <comment line="2194">
                    Check for overflow and update exponent accordingly.                    
                </comment>
                <comment line="2196">
                    Infinite result                    
                </comment>
                <comment line="2197">
                    overflow to properly signed infinity                    
                </comment>
                <comment line="2199">
                    Finite return value                    
                </comment>
                <comment line="2200">
                    (Usually) normal result                    
                </comment>
                <comment line="2203">
                    The result returned in this block cannot be a
                     zero or subnormal; however after the
                     significand is adjusted from rounding, we could
                     still overflow in infinity.                    
                </comment>
                <comment line="2208">
                    AND exponent bits into significand; if the
                     significand is incremented and overflows from
                     rounding, this combination will update the
                     exponent correctly, even in the case of
                     Double.MAX_VALUE overflowing to infinity.                    
                </comment>
                <comment line="2220">
                    Subnormal or zero                    
                </comment>
                <comment line="2221">
                    (exponent &lt; DoubleConsts.MIN_EXPONENT)                    
                </comment>
                <comment line="2224">
                    No way to round back to nonzero value
                     regardless of significand if the exponent is
                     less than -1075.                    
                </comment>
                <comment line="2228">
                    -1075 &lt;= exponent &lt;= MIN_EXPONENT -1 = -1023                    
                </comment>
                <comment line="2229">
                    Find bit position to round to; recompute
                     round and sticky bits, and shift
                     significand right appropriately.                    
                </comment>
                <comment line="2238">
                    Number of bits of significand to preserve is
                     exponent - abs_min_exp +1
                     check:
                     -1075 +1074 + 1 = 0
                     -1023 +1074 + 1 = 52                    
                </comment>
                <comment line="2248">
                    What to do here:
                     First, isolate the new round bit                    
                </comment>
                <comment line="2252">
                    create mask to update sticky bits; low
                     order bitsDiscarded bits should be 1                    
                </comment>
                <comment line="2258">
                    Now, discard the bits                    
                </comment>
                <comment line="2261">
                    subnorm exp.                    
                </comment>
                <comment line="2269">
                    The significand variable now contains the currently
                     appropriate exponent bits too.                    
                </comment>
                <comment line="2272">
                    Determine if significand should be incremented;
                     making this determination depends on the least
                     significant bit and the round and sticky bits.
                    
                     Round to nearest even rounding table, adapted from
                     table 4.7 in &quot;Computer Arithmetic&quot; by IsraelKoren.
                     The digit to the left of the &quot;decimal&quot; point is the
                     least significant bit, the digits to the right of
                     the point are the round and sticky bits
                    
                     Number       Round(x)
                     x0.00        x0.
                     x0.01        x0.
                     x0.10        x0.
                     x0.11        x1. = x0. +1
                     x1.00        x1.
                     x1.01        x1.
                     x1.10        x1. + 1
                     x1.11        x1. + 1                    
                </comment>
                <comment line="2305">
                    Set roundingDir variable field of fd properly so
                     that the input string can be properly rounded to a
                     float value.  There are two cases to consider:
                    
                     1. rounding to double discards sticky bit
                     information that would change the result of a float
                     rounding (near halfway case between two floats)
                    
                     2. rounding to double rounds up when rounding up
                     would not occur when rounding to float.
                    
                     For former case only needs to be considered when
                     the bits rounded away when casting to float are all
                     zero; otherwise, float round bit is properly set
                     and sticky will already be true.
                    
                     The lower exponent bound for the code below is the
                     minimum (normalized) subnormal exponent - 1 since a
                     value with that exponent can round up to the
                     minimum subnormal value and the sticky bit
                     information must be preserved (i.e. case 1).                    
                </comment>
                <comment line="2330">
                    Outside above exponent range, the float value
                     will be zero or infinity.                    
                </comment>
                <comment line="2333">
                    If the low-order 28 bits of a rounded double
                     significand are 0, the double could be a
                     half-way case for a rounding to float.  If the
                     double value is a half-way case, the double
                     significand may have to be modified to round
                     the the right float value (see the stickyRound
                     method).  If the rounding to double has lost
                     what would be float sticky bit information, the
                     double significand must be incremented.  If the
                     double value&apos;s significand was itself
                     incremented, the float value may end up too
                     large so the increment should be undone.                    
                </comment>
                <comment line="2348">
                    For negative values, the sign of the
                     roundDir is the same as for positive values
                     since adding 1 increasing the significand&apos;s
                     magnitude and subtracting 1 decreases the
                     significand&apos;s magnitude.  If neither round
                     nor sticky is true, the double value is
                     exact and no adjustment is required for a
                     proper float rounding.                    
                </comment>
                <comment line="2357">
                    prerounding lsb is 0                    
                </comment>
                <comment line="2358">
                    If round and sticky were both true,
                     and the least significant
                     significand bit were 0, the rounded
                     significand would not have its
                     low-order bits be zero.  Therefore,
                     we only need to adjust the
                     significand if round XOR sticky is
                     true.                    
                </comment>
                <comment line="2370">
                    prerounding lsb is 1                    
                </comment>
                <comment line="2371">
                    If the prerounding lsb is 1 and the
                     resulting significand has its
                     low-order bits zero, the significand
                     was incremented.  Here, we undo the
                     increment, which will ensure the
                     right guard and sticky bits for the
                     float rounding.                    
                </comment>
                <declaration name="m" type="Matcher" line="1886"/>
                <declaration name="validInput" type="boolean" line="1887"/>
                <scope line="1889"/>
                <scope line="1892">
                    <declaration name="group1" type="String" line="1918"/>
                    <declaration name="sign" type="double" line="1919"/>
                    <declaration name="significandString" type="String" line="1951"/>
                    <declaration name="signifLength" type="int" line="1952"/>
                    <declaration name="exponentAdjust" type="int" line="1953"/>
                    <scope line="1954">
                        <declaration name="leftDigits" type="int" line="1955"/>
                        <declaration name="rightDigits" type="int" line="1958"/>
                        <declaration name="group4" type="String" line="1971"/>
                        <scope line="1972"/>
                        <scope line="1977">
                            <declaration name="group6" type="String" line="1980"/>
                            <declaration name="group7" type="String" line="1984"/>
                        </scope>
                        <scope line="2000"/>
                        <scope line="2002"/>
                        <scope line="2009"/>
                    </scope>
                    <declaration name="group8" type="String" line="2022"/>
                    <declaration name="positiveExponent" type="boolean" line="2023"/>
                    <declaration name="unsignedRawExponent" type="long" line="2024"/>
                    <scope line="2025"/>
                    <scope line="2028"/>
                    <declaration name="rawExponent" type="long" line="2046"/>
                    <declaration name="exponent" type="long" line="2051"/>
                    <declaration name="round" type="boolean" line="2057"/>
                    <declaration name="sticky" type="boolean" line="2058"/>
                    <declaration name="bitsCopied" type="int" line="2059"/>
                    <declaration name="nextShift" type="int" line="2060"/>
                    <declaration name="significand" type="long" line="2061"/>
                    <declaration name="leadingDigit" type="long" line="2068"/>
                    <scope line="2079"/>
                    <scope line="2083"/>
                    <scope line="2088"/>
                    <scope line="2093"/>
                    <scope line="2097"/>
                    <declaration name="i" type="int" line="2120"/>
                    <scope line="2123">
                        <declaration name="currentDigit" type="long" line="2124"/>
                    </scope>
                    <scope line="2134">
                        <declaration name="currentDigit" type="long" line="2135"/>
                        <scope line="2182"/>
                    </scope>
                    <scope line="2195"/>
                    <scope line="2198">
                        <scope line="2200"/>
                        <scope line="2219">
                            <scope line="2222"/>
                            <scope line="2227">
                                <declaration name="bitsDiscarded" type="int" line="2243"/>
                                <scope line="2250">
                                    <declaration name="mask" type="long" line="2253"/>
                                </scope>
                            </scope>
                        </scope>
                        <declaration name="incremented" type="boolean" line="2292"/>
                        <declaration name="leastZero" type="boolean" line="2293"/>
                        <scope line="2295"/>
                        <declaration name="fd" type="FloatingDecimal" line="2300"/>
                        <scope line="2328">
                            <scope line="2346">
                                <scope line="2355">
                                    <scope line="2356">
                                        <scope line="2365"/>
                                    </scope>
                                    <scope line="2369"/>
                                </scope>
                            </scope>
                        </scope>
                    </scope>
                </scope>
            </method>
            <javadoc line="2390">
                Return &lt;code&gt;s&lt;/code&gt; with any leading zeros removed.                
            </javadoc>
            <method name="stripLeadingZeros" type="String" line="2393">
                <params>
                    <param name="s" type="String"/>
                </params>
            </method>
            <javadoc line="2397">
                Extract a hexadecimal digit from position &lt;code&gt;position&lt;/code&gt;
                  of string &lt;code&gt;s&lt;/code&gt;.                
            </javadoc>
            <method name="getHexDigit" type="int" line="2401">
                <params>
                    <param name="s" type="String"/>
                    <param name="position" type="int"/>
                </params>
                <declaration name="value" type="int" line="2402"/>
                <scope line="2403"/>
            </method>
        </class>
        <class name="FDBigInt" line="2417">
            <comment line="44">
                set by doubleValue                
            </comment>
            <comment line="55">
                Constants of the implementation
                 Most are IEEE-754 related.
                 (There are more really boring constants at the end.)                
            </comment>
            <comment line="65">
                assumed High-Order bit                
            </comment>
            <comment line="66">
                exponent of 1.0                
            </comment>
            <comment line="72">
                i.e. abs(minDecimalExponent)                
            </comment>
            <comment line="91">
                count number of bits from high-order 1 bit to low-order 1 bit,
                 inclusive.                
            </comment>
            <comment line="123">
                Keep big powers of 5 handy for future reference.                
            </comment>
            <comment line="168">
                a common operation                
            </comment>
            <comment line="186">
                another common operation                
            </comment>
            <comment line="198">
                Make a floating double into a FDBigInt.
                 This could also be structured as a FDBigInt
                 constructor, but we&apos;d have to build a lot of knowledge
                 about floating-point representation into it, and we don&apos;t want to.
                
                 AS A SIDE EFFECT, THIS METHOD WILL SET THE INSTANCE VARIABLES
                 bigIntExp and bigIntNBits                
            </comment>
            <comment line="237">
                Compute a number that is the ULP of the given value,
                 for purposes of additionsubtraction. Generally easy.
                 More difficult if subtracting and the argument
                 is a normalized a power of 2, as the ULP changes at these points.                
            </comment>
            <comment line="264">
                Round a double to a float.
                 In addition to the fraction bits of the double,
                 look at the class instance variable roundDir,
                 which should help us avoid double-rounding error.
                 roundDir was set in hardValueOf if the estimate was
                 close enough, but not exact. It tells us which direction
                 of rounding is preferred.                
            </comment>
            <comment line="287">
                This is the easy subcase --
                 all the significant bits, after scaling, are held in lvalue.
                 negSign and decExponent tell us what processing and scaling
                 has already been done. Exceptional cases have already been
                 stripped out.
                 In particular:
                 lvalue is a finite number (not Inf, nor NaN)
                 lvalue &gt; 0L (not zero, nor negative).
                
                 The only reason that we develop the digits here, rather than
                 calling on Long.toString() is that we can do it a little faster,
                 and besides want to treat trailing 0s specially. If Long.toString
                 changes, we should re-evaluate this strategy!                
            </comment>
            <comment line="376">
                add one to the least significant digit.
                 in the unlikely event there is a carry out,
                 deal with it.
                 assert that this will only happen where there
                 is only one digit, e.g. (float)1e-44 seems to do it.                
            </comment>
            <comment line="403">
                FIRST IMPORTANT CONSTRUCTOR: DOUBLE                
            </comment>
            <comment line="463">
                SECOND IMPORTANT CONSTRUCTOR: SINGLE                
            </comment>
            <comment line="982">
                Per-thread buffer for string/stringbuffer conversion                
            </comment>
            <comment line="1245">
                Take a FloatingDecimal, which we presumably just scanned in,
                 and find out what its value is, as a double.
                
                 AS A SIDE EFFECT, SET roundDir TO INDICATE PREFERRED
                 ROUNDING DIRECTION in case the result is really destined
                 for a single-precision float.                
            </comment>
            <comment line="1603">
                Take a FloatingDecimal, which we presumably just scanned in,
                 and find out what its value is, as a float.
                 This is distinct from doubleValue() to avoid the extremely
                 unlikely case of a double rounding error, wherein the conversion
                 to double has one rounding error, and the conversion of that double
                 to a float has another rounding error, IN THE WRONG DIRECTION,
                 ( because of the preference to a zero low-order bit ).                
            </comment>
            <comment line="1753">
                All the positive powers of 10 that can be
                 represented exactly in doublefloat.                
            </comment>
            <comment line="1828">
                approximately ceil( log2( long5pow[i] ) )                
            </comment>
            <comment line="1864">
                Grammar is compatible with hexadecimal floating-point constants
                 described in section 6.4.4.2 of the C99 specification.                
            </comment>
            <comment line="1879">
                Convert string s to a suitable floating decimal; uses the
                 double constructor and set the roundDir variable appropriately
                 in case the value is later converted to a float.                
            </comment>
            <comment line="2419">
                number of words used                
            </comment>
            <comment line="2420">
                value: data[0] is least significant                
            </comment>
            <comment line="2475">
                Left shift by c bits.
                 Shifts this in place.                
            </comment>
            <comment line="2520">
                normalize this number by shifting until
                 the MSB of the number is at 0x08000000.
                 This is in preparation for quoRemIteration, below.
                 The idea is that, to make division easier, we want the
                 divisor to be &quot;normalized&quot; -- usually this means shifting
                 the MSB into the high words sign bit. But because we know that
                 the quotient will be 0 &lt; q &lt; 10, we would like to arrange that
                 the dividend not span up into another word of precision.
                 (This needs to be explained more clearly!)                
            </comment>
            <comment line="2577">
                Multiply a FDBigInt by an int.
                 Result is a new FDBigInt.                
            </comment>
            <comment line="2603">
                Multiply a FDBigInt by an int and add another int.
                 Result is computed in place.
                 Hope it fits!                
            </comment>
            <comment line="2628">
                Multiply a FDBigInt by another FDBigInt.
                 Result is a new FDBigInt.                
            </comment>
            <comment line="2657">
                Add one FDBigInt to another. Return a FDBigInt                
            </comment>
            <comment line="2698">
                Subtract one FDBigInt from another. Return a FDBigInt
                 Assert that the result is positive.                
            </comment>
            <comment line="2733">
                Compare FDBigInt with another FDBigInt. Return an integer
                 &gt;0: this &gt; other
                  0: this == other
                 &lt;0: this &lt; other                
            </comment>
            <comment line="2782">
                Compute
                 q = (int)( this  S )
                 this = 10  ( this mod S )
                 Return q.
                 This is the iteration step of digit development for output.
                 We assume that S has been normalized, as above, and that
                 &quot;this&quot; has been lshift&apos;ed accordingly.
                 Also assume, of course, that the result, q, can be expressed
                 as an integer, 0 &lt;= q &lt; 10.                
            </comment>
            <declaration name="nWords" type="int" line="2418"/>
            <declaration name="data" type="int" line="2419"/>
            <method name="FDBigInt" type="constructor" line="2422">
                <params>
                    <param name="v" type="int"/>
                </params>
            </method>
            <method name="FDBigInt" type="constructor" line="2428">
                <params>
                    <param name="v" type="long"/>
                </params>
            </method>
            <method name="FDBigInt" type="constructor" line="2435">
                <params>
                    <param name="other" type="FDBigInt"/>
                </params>
            </method>
            <method name="FDBigInt" type="constructor" line="2440">
                <params>
                    <param name="d" type="int[]"/>
                    <param name="n" type="int"/>
                </params>
            </method>
            <method name="FDBigInt" type="constructor" line="2445">
                <params>
                    <param name="seed" type="long"/>
                    <param name="digit" type="char"/>
                    <param name="nd0" type="int"/>
                    <param name="nd" type="int"/>
                </params>
                <comment line="2447">
                    estimate size needed.                    
                </comment>
                <comment line="2449">
                    allocate enough space                    
                </comment>
                <comment line="2450">
                    starting value                    
                </comment>
                <comment line="2454">
                    slurp digits 5 at a time.                    
                </comment>
                <comment line="2462">
                    ... where 100000 is 10^5.                    
                </comment>
                <declaration name="n" type="int" line="2446"/>
                <declaration name="i" type="int" line="2452"/>
                <declaration name="limit" type="int" line="2453"/>
                <declaration name="v" type="int" line="2454"/>
                <scope line="2455">
                    <declaration name="ilim" type="int" line="2456"/>
                    <scope line="2458"/>
                </scope>
                <declaration name="factor" type="int" line="2463"/>
                <scope line="2465"/>
                <scope line="2469"/>
            </method>
            <method name="lshiftMe" type="void" line="2479">
                <params>
                    <param name="c" type="int"/>
                </params>
                <comment line="2483">
                    silly.                    
                </comment>
                <comment line="2493">
                    reallocate.                    
                </comment>
                <comment line="2499">
                    special hack, since an anticount of 32 won&apos;t go!                    
                </comment>
                <comment line="2514">
                    may have constructed high-order word of 0.
                     if so, trim it                    
                </comment>
                <scope line="2480"/>
                <declaration name="wordcount" type="int" line="2486"/>
                <declaration name="bitcount" type="int" line="2487"/>
                <declaration name="anticount" type="int" line="2488"/>
                <declaration name="t" type="int" line="2489"/>
                <declaration name="s" type="int" line="2490"/>
                <scope line="2491"/>
                <declaration name="target" type="int" line="2495"/>
                <declaration name="src" type="int" line="2496"/>
                <scope line="2497"/>
                <scope line="2501">
                    <scope line="2503"/>
                </scope>
                <scope line="2508"/>
            </method>
            <method name="normalizeMe" type="int" line="2531">
                <comment line="2541">
                    oops. Value is zero. Cannot normalize it!                    
                </comment>
                <comment line="2544">
                    In most cases, we assume that wordcount is zero. This only
                     makes sense, as we try not to maintain any high-order
                     words full of zeros. In fact, if there are zeros, we will
                     simply SHORTEN our number at this point. Watch closely...                    
                </comment>
                <comment line="2551">
                    Compute how far left we have to shift v s.t. its highest-
                     order bit is in the right place. Then call lshiftMe to
                     do the work.                    
                </comment>
                <comment line="2557">
                    will have to shift up into the next word.
                     too bad.                    
                </comment>
                <comment line="2563">
                    hack: byte-at-a-time shifting                    
                </comment>
                <declaration name="src" type="int" line="2532"/>
                <declaration name="wordcount" type="int" line="2533"/>
                <declaration name="bitcount" type="int" line="2534"/>
                <declaration name="v" type="int" line="2535"/>
                <scope line="2536"/>
                <scope line="2539"/>
                <scope line="2555"/>
                <scope line="2560">
                    <scope line="2561"/>
                    <scope line="2566"/>
                </scope>
            </method>
            <method name="mult" type="FDBigInt" line="2581">
                <params>
                    <param name="iv" type="int"/>
                </params>
                <comment line="2587">
                    guess adequate size of r.                    
                </comment>
                <declaration name="v" type="long" line="2582"/>
                <declaration name="r" type="int" line="2583"/>
                <declaration name="p" type="long" line="2584"/>
                <scope line="2589"/>
                <scope line="2594"/>
                <scope line="2596"/>
            </method>
            <method name="multaddMe" type="void" line="2608">
                <params>
                    <param name="iv" type="int"/>
                    <param name="addend" type="int"/>
                </params>
                <comment line="2613">
                    unroll 0th iteration, doing addition.                    
                </comment>
                <comment line="2623">
                    will fail noisily if illegal!                    
                </comment>
                <declaration name="v" type="long" line="2609"/>
                <declaration name="p" type="long" line="2610"/>
                <scope line="2616"/>
                <scope line="2621"/>
            </method>
            <method name="mult" type="FDBigInt" line="2632">
                <params>
                    <param name="other" type="FDBigInt"/>
                </params>
                <comment line="2634">
                    crudely guess adequate size for r                    
                </comment>
                <comment line="2637">
                    I think I am promised zeros...                    
                </comment>
                <comment line="2640">
                    UNSIGNED CONVERSION                    
                </comment>
                <comment line="2644">
                    UNSIGNED CONVERSIONS ALL &apos;ROUND.                    
                </comment>
                <comment line="2650">
                    compute how much of r we actually needed for all that.                    
                </comment>
                <declaration name="r" type="int" line="2634"/>
                <declaration name="i" type="int" line="2635"/>
                <scope line="2638">
                    <declaration name="v" type="long" line="2639"/>
                    <declaration name="p" type="long" line="2640"/>
                    <declaration name="j" type="int" line="2641"/>
                    <scope line="2642"/>
                </scope>
            </method>
            <method name="add" type="FDBigInt" line="2660">
                <params>
                    <param name="other" type="FDBigInt"/>
                </params>
                <comment line="2666">
                    arrange such that a.nWords &gt;= b.nWords;
                     n = a.nWords, m = b.nWords                    
                </comment>
                <comment line="2686">
                    signed shift.                    
                </comment>
                <comment line="2689">
                    oops -- carry out -- need longer result.                    
                </comment>
                <declaration name="i" type="int" line="2661"/>
                <declaration name="a" type="int" line="2662"/>
                <declaration name="n" type="int" line="2663"/>
                <declaration name="c" type="long" line="2664"/>
                <scope line="2667"/>
                <scope line="2672"/>
                <declaration name="r" type="int" line="2678"/>
                <scope line="2679">
                    <scope line="2681"/>
                </scope>
                <scope line="2687">
                    <declaration name="s" type="int" line="2689"/>
                </scope>
            </method>
            <method name="sub" type="FDBigInt" line="2702">
                <params>
                    <param name="other" type="FDBigInt"/>
                </params>
                <comment line="2719">
                    signed shift                    
                </comment>
                <comment line="2721">
                    borrow out of subtract                    
                </comment>
                <comment line="2722">
                    negative result of subtract                    
                </comment>
                <declaration name="r" type="int" line="2703"/>
                <declaration name="i" type="int" line="2704"/>
                <declaration name="n" type="int" line="2705"/>
                <declaration name="m" type="int" line="2706"/>
                <declaration name="nzeros" type="int" line="2707"/>
                <declaration name="c" type="long" line="2708"/>
                <scope line="2709">
                    <scope line="2711"/>
                </scope>
            </method>
            <method name="dataInRangeIsZero" type="boolean" line="2725">
                <params>
                    <param name="i" type="int"/>
                    <param name="m" type="int"/>
                    <param name="other" type="FDBigInt"/>
                </params>
            </method>
            <method name="cmp" type="int" line="2739">
                <params>
                    <param name="other" type="FDBigInt"/>
                </params>
                <comment line="2743">
                    if any of my high-order words is non-zero,
                     then the answer is evident                    
                </comment>
                <comment line="2749">
                    if any of other&apos;s high-order words is non-zero,
                     then the answer is evident                    
                </comment>
                <comment line="2760">
                    careful! want unsigned compare!
                     use brute force here.                    
                </comment>
                <comment line="2765">
                    a is really big, unsigned                    
                </comment>
                <comment line="2767">
                    both big, negative                    
                </comment>
                <comment line="2769">
                    b not big, answer is obvious;                    
                </comment>
                <comment line="2772">
                    a is not really big                    
                </comment>
                <comment line="2774">
                    but b is really big                    
                </comment>
                <declaration name="i" type="int" line="2740"/>
                <scope line="2741">
                    <declaration name="j" type="int" line="2744"/>
                </scope>
                <scope line="2747">
                    <declaration name="j" type="int" line="2750"/>
                </scope>
                <scope line="2753"/>
                <declaration name="a" type="int" line="2761"/>
                <declaration name="b" type="int" line="2762"/>
                <scope line="2763">
                    <scope line="2765"/>
                    <scope line="2767"/>
                </scope>
                <scope line="2770">
                    <scope line="2772"/>
                    <scope line="2775"/>
                </scope>
            </method>
            <method name="quoRemIteration" type="int" line="2793">
                <params>
                    <param name="S" type="FDBigInt"/>
                </params>
                <comment line="2795">
                    ensure that this and S have the same number of
                     digits. If S is properly normalized and q &lt; 10 then
                     this must be so.                    
                </comment>
                <comment line="2801">
                    estimate q the obvious way. We will usually be
                     right. If not, then we&apos;re only off by a little and
                     will re-add.                    
                </comment>
                <comment line="2810">
                    N.B. SIGNED shift.                    
                </comment>
                <comment line="2813">
                    damn, damn, damn. q is too big.
                     add S back in until this turns +. This should
                     not be very many times!                    
                </comment>
                <comment line="2822">
                    Signed or unsigned, answer is 0 or 1                    
                </comment>
                <comment line="2824">
                    Originally the following line read
                     &quot;if ( sum !=0 &amp;&amp; sum != -1 )&quot;
                     but that would be wrong, because of the
                     treatment of the two values as entirely unsigned,
                     it would be impossible for a carry-out to be interpreted
                     as -1 -- it would have to be a single-bit carry-out, or
                     +1.                    
                </comment>
                <comment line="2833">
                    carry out of division correction                    
                </comment>
                <comment line="2837">
                    finally, we can multiply this by 10.
                     it cannot overflow, right, as the high-order word has
                     at least 4 high-order zeros!                    
                </comment>
                <comment line="2844">
                    SIGNED shift.                    
                </comment>
                <comment line="2846">
                    Carry out of *10                    
                </comment>
                <scope line="2797"/>
                <declaration name="n" type="int" line="2803"/>
                <declaration name="q" type="long" line="2804"/>
                <declaration name="diff" type="long" line="2805"/>
                <scope line="2806"/>
                <scope line="2811">
                    <declaration name="sum" type="long" line="2815"/>
                    <scope line="2816">
                        <scope line="2818"/>
                    </scope>
                </scope>
                <declaration name="p" type="long" line="2839"/>
                <scope line="2840"/>
            </method>
            <method name="longValue" type="long" line="2850">
                <comment line="2852">
                    if this can be represented as a long, return the value                    
                </comment>
                <comment line="2853">
                    longValue confused                    
                </comment>
                <comment line="2858">
                    value too big                    
                </comment>
                <comment line="2859">
                    value too big                    
                </comment>
            </method>
            <method name="toString" type="String" line="2863">
                <declaration name="r" type="StringBuffer" line="2864"/>
                <declaration name="i" type="int" line="2866"/>
                <scope line="2867"/>
                <scope line="2870"/>
            </method>
        </class>
    </source>