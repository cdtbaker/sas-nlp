<?xml version="1.0" encoding="UTF-8"?>
    <source package="sun.misc">
        <class name="Timer" line="28">
            <comment line="72">
                Synchronization issues:  there are two data structures that
                require locking.  A Timer object and the Timer queue
                (described in the TimerThread class).  To avoid deadlock,
                the timer queue monitor is always acquired before the timer
                object&apos;s monitor.  However, the timer queue monitor is acquired
                only if the timer operation will make use of the timer
                queue, e.g. stop().
                
                The class monitor on the class TimerThread severs as the monitor
                to the timer queue.
                
                Possible feature: perhaps a timer should have an associated
                thread priority.  The thread that makes the callback temporarily
                takes on that priority before calling the owner&apos;s tick() method.                
            </comment>
            <comment line="96">
                This is the interval of time in ms.                
            </comment>
            <comment line="101">
                This variable is used for two different purposes.
                 This is done in order to save space.
                 If &apos;stopped&apos; is true, this variable holds the time
                 that the timer was stopped; otherwise, this variable
                 is used by the TimerThread to determine when the timer
                 should tick.                
            </comment>
            <comment line="111">
                This is the time remaining before the timer ticks.  It
                 is only valid if &apos;stopped&apos; is true.  If the timer is
                 continued, the next tick will happen remaingTime
                 milliseconds later.                
            </comment>
            <comment line="119">
                True iff the timer is in regular mode.                
            </comment>
            <comment line="124">
                True iff the timer has been stopped.                
            </comment>
            <comment line="129">
                Timer queue-related variables                
            </comment>
            <comment line="133">
                A link to another timer object.  This is used while the
                 timer object is enqueued in the timer queue.                
            </comment>
            <comment line="139">
                Timer methods                
            </comment>
            <comment line="143">
                This variable holds a handle to the TimerThread class for
                 the purpose of getting at the class monitor.  The reason
                 why Class.forName(&quot;TimerThread&quot;) is not used is because it
                 doesn&apos;t appear to work when loaded via a net class loader.                
            </comment>
            <comment line="316">
                This method is used only for testing purposes.                
            </comment>
            <comment line="349">
                Set to true to get debugging output.                
            </comment>
            <comment line="354">
                This is a handle to the thread managing the thread queue.                
            </comment>
            <comment line="359">
                This flag is set if the timer thread has been notified
                 while it was in the timed wait.  This flag allows the
                 timer thread to tell whether or not the wait completed.                
            </comment>
            <comment line="410">
                Timer Queue                
            </comment>
            <comment line="414">
                The timer queue is a queue of timers waiting to tick.                
            </comment>
            <comment line="419">
                Uses timer.sleepUntil to determine where in the queue
                 to insert the timer object.
                 A new ticker thread is created only if the timer
                 is inserted at the beginning of the queue.
                 The timer must not already be in the queue.
                 Assumes the caller has the TimerThread monitor.                
            </comment>
            <comment line="461">
                If the timer is not in the queue, returns false;
                 otherwise removes the timer from the timer queue and returns true.
                 Assumes the caller has the TimerThread monitor.                
            </comment>
            <comment line="504">
                Inserts the timer back into the queue.  This method
                 is used by a callback thread after it has called the
                 timer owner&apos;s tick() method.  This method recomputes
                 the sleepUntil field.
                 Assumes the caller has the TimerThread and Timer monitor.                
            </comment>
            <comment line="542">
                Maximum size of the thread pool.                
            </comment>
            <comment line="547">
                Number of threads in the pool.                
            </comment>
            <comment line="552">
                The pool of timer threads.                
            </comment>
            <comment line="557">
                Is used when linked into the thread pool.                
            </comment>
            <comment line="562">
                This is the handle to the timer whose owner&apos;s
                 tick() method will be called.                
            </comment>
            <comment line="568">
                The value of a timer&apos;s sleepUntil value is captured here.
                 This is used to determine whether or not the timer should
                 be reinserted into the queue.  If the timer&apos;s sleepUntil
                 value has changed, the timer is not reinserted.                
            </comment>
            <comment line="576">
                Creates a new callback thread to call the timer owner&apos;s
                 tick() method.  A thread is taken from the pool if one
                 is available, otherwise, a new thread is created.
                 The thread handle is returned.                
            </comment>
            <comment line="603">
                Returns false if the thread should simply exit;
                 otherwise the thread is returned the pool, where
                 it waits to be notified.  (I did try to use the
                 class monitor but the time between the notify
                 and breaking out of the wait seemed to take
                 significantly longer; need to look into this later.)                
            </comment>
            <javadoc line="28">
                A Timer object is used by algorithms that require timed events.
                  For example, in an animation loop, a timer would help in
                  determining when to change frames.
                  A timer has an interval which determines when it &quot;ticks&quot;;
                  that is, a timer delays for the specified interval and then
                  it calls the owner&apos;s tick() method.
                  Here&apos;s an example of creating a timer with a 5 sec interval:
                  &lt;pre&gt;
                  class Main implements Timeable {
                  public void tick(Timer timer) {
                  System.out.println(&quot;tick&quot;);
                  }
                  public static void main(String args[]) {
                  (new Timer(this, 5000)).cont();
                  }
                  }
                  &lt;/pre&gt;
                  A timer can be stopped, continued, or reset at any time.
                  A timer&apos;s state is not stopped while it&apos;s calling the
                  owner&apos;s tick() method.
                  A timer can be regular or irregular.  If in regular mode,
                  a timer ticks at the specified interval, regardless of
                  how long the owner&apos;s tick() method takes.  While the timer
                  is running, no ticks are ever discarded.  That means that if
                  the owner&apos;s tick() method takes longer than the interval,
                  the ticks that would have occurred are delivered immediately.
                  In irregular mode, a timer starts delaying for exactly
                  the specified interval only after the tick() method returns.
                  Synchronization issues: do not hold the timer&apos;s monitor
                  while calling any of the Timer operations below otherwise
                  the Timer class will deadlock.                
                <author>
                    Patrick Chan                    
                </author>
            </javadoc>
            <declaration name="owner" type="Timeable" line="89"/>
            <javadoc line="89">
                This is the owner of the timer.  Its tick method is
                  called when the timer ticks.                
            </javadoc>
            <declaration name="interval" type="long" line="98"/>
            <declaration name="sleepUntil" type="long" line="108"/>
            <declaration name="remainingTime" type="long" line="116"/>
            <declaration name="regular" type="boolean" line="121"/>
            <declaration name="stopped" type="boolean" line="126"/>
            <declaration name="next" type="Timer" line="136"/>
            <declaration name="timerThread" type="TimerThread" line="148"/>
            <javadoc line="150">
                Creates a timer object that is owned by &apos;owner&apos; and
                  with the interval &apos;interval&apos; milliseconds.  The new timer
                  object is stopped and is regular.  getRemainingTime()
                  return &apos;interval&apos; at this point.  getStopTime() returns
                  the time this object was created.                
                <param>
                    owner    owner of the timer object                    
                </param>
                <param>
                    interval interval of the timer in milliseconds                    
                </param>
            </javadoc>
            <method name="Timer" type="constructor" line="159">
                <params>
                    <param name="owner" type="Timeable"/>
                    <param name="interval" type="long"/>
                </params>
                <scope line="166">
                    <scope line="167"/>
                </scope>
            </method>
            <javadoc line="173">
                Returns true if this timer is stopped.                
            </javadoc>
            <method name="isStopped" type="boolean" line="176"/>
            <javadoc line="180">
                Stops the timer.  The amount of time the timer has already
                  delayed is saved so if the timer is continued, it will only
                  delay for the amount of time remaining.
                  Note that even after stopping a timer, one more tick may
                  still occur.
                  This method is MT-safe; i.e. it is synchronized but for
                  implementation reasons, the synchronized modifier cannot
                  be included in the method declaration.                
            </javadoc>
            <method name="stop" type="void" line="190">
                <comment line="199">
                    stop time                    
                </comment>
                <declaration name="now" type="long" line="191"/>
                <scope line="193">
                    <scope line="194">
                        <scope line="195"/>
                    </scope>
                </scope>
            </method>
            <javadoc line="205">
                Continue the timer.  The next tick will come at getRemainingTime()
                  milliseconds later.  If the timer is not stopped, this
                  call will be a no-op.
                  This method is MT-safe; i.e. it is synchronized but for
                  implementation reasons, the synchronized modifier cannot
                  be included in the method declaration.                
            </javadoc>
            <method name="cont" type="void" line="213">
                <comment line="218">
                    The TimerTickThread avoids requeuing the
                     timer only if the sleepUntil value has changed.
                     The following guarantees that the sleepUntil
                     value will be different; without this guarantee,
                     it&apos;s theoretically possible for the timer to be
                     inserted twice.                    
                </comment>
                <scope line="214">
                    <scope line="215">
                        <scope line="216"/>
                    </scope>
                </scope>
            </method>
            <javadoc line="232">
                Resets the timer&apos;s remaining time to the timer&apos;s interval.
                  If the timer&apos;s running state is not altered.                
            </javadoc>
            <method name="reset" type="void" line="236">
                <scope line="237">
                    <scope line="238"/>
                </scope>
            </method>
            <javadoc line="244">
                Returns the time at which the timer was last stopped.  The
                  return value is valid only if the timer is stopped.                
            </javadoc>
            <method name="getStopTime" type="long" line="248"/>
            <javadoc line="252">
                Returns the timer&apos;s interval.                
            </javadoc>
            <method name="getInterval" type="long" line="255"/>
            <javadoc line="259">
                Changes the timer&apos;s interval.  The new interval setting
                  does not take effect until after the next tick.
                  This method does not alter the remaining time or the
                  running state of the timer.                
                <param>
                    interval new interval of the timer in milliseconds                    
                </param>
            </javadoc>
            <method name="setInterval" type="void" line="266">
                <params>
                    <param name="interval" type="long"/>
                </params>
            </method>
            <javadoc line="270">
                Returns the remaining time before the timer&apos;s next tick.
                  The return value is valid only if timer is stopped.                
            </javadoc>
            <method name="getRemainingTime" type="long" line="274"/>
            <javadoc line="278">
                Sets the remaining time before the timer&apos;s next tick.
                  This method does not alter the timer&apos;s running state.
                  This method is MT-safe; i.e. it is synchronized but for
                  implementation reasons, the synchronized modifier cannot
                  be included in the method declaration.                
                <param>
                    time new remaining time in milliseconds.                    
                </param>
            </javadoc>
            <method name="setRemainingTime" type="void" line="286">
                <params>
                    <param name="time" type="long"/>
                </params>
                <scope line="287">
                    <scope line="288">
                        <scope line="289"/>
                        <scope line="291"/>
                    </scope>
                </scope>
            </method>
            <javadoc line="300">
                In regular mode, a timer ticks at the specified interval,
                  regardless of how long the owner&apos;s tick() method takes.
                  While the timer is running, no ticks are ever discarded.
                  That means that if the owner&apos;s tick() method takes longer
                  than the interval, the ticks that would have occurred are
                  delivered immediately.
                  In irregular mode, a timer starts delaying for exactly
                  the specified interval only after the tick() method returns.                
            </javadoc>
            <method name="setRegular" type="void" line="311">
                <params>
                    <param name="regular" type="boolean"/>
                </params>
            </method>
            <method name="getTimerThread" type="Thread" line="318"/>
        </class>
        <class name="TimerThread" line="347">
            <extends class="Thread"/>
            <comment line="72">
                Synchronization issues:  there are two data structures that
                require locking.  A Timer object and the Timer queue
                (described in the TimerThread class).  To avoid deadlock,
                the timer queue monitor is always acquired before the timer
                object&apos;s monitor.  However, the timer queue monitor is acquired
                only if the timer operation will make use of the timer
                queue, e.g. stop().
                
                The class monitor on the class TimerThread severs as the monitor
                to the timer queue.
                
                Possible feature: perhaps a timer should have an associated
                thread priority.  The thread that makes the callback temporarily
                takes on that priority before calling the owner&apos;s tick() method.                
            </comment>
            <comment line="96">
                This is the interval of time in ms.                
            </comment>
            <comment line="101">
                This variable is used for two different purposes.
                 This is done in order to save space.
                 If &apos;stopped&apos; is true, this variable holds the time
                 that the timer was stopped; otherwise, this variable
                 is used by the TimerThread to determine when the timer
                 should tick.                
            </comment>
            <comment line="111">
                This is the time remaining before the timer ticks.  It
                 is only valid if &apos;stopped&apos; is true.  If the timer is
                 continued, the next tick will happen remaingTime
                 milliseconds later.                
            </comment>
            <comment line="119">
                True iff the timer is in regular mode.                
            </comment>
            <comment line="124">
                True iff the timer has been stopped.                
            </comment>
            <comment line="129">
                Timer queue-related variables                
            </comment>
            <comment line="133">
                A link to another timer object.  This is used while the
                 timer object is enqueued in the timer queue.                
            </comment>
            <comment line="139">
                Timer methods                
            </comment>
            <comment line="143">
                This variable holds a handle to the TimerThread class for
                 the purpose of getting at the class monitor.  The reason
                 why Class.forName(&quot;TimerThread&quot;) is not used is because it
                 doesn&apos;t appear to work when loaded via a net class loader.                
            </comment>
            <comment line="316">
                This method is used only for testing purposes.                
            </comment>
            <comment line="349">
                Set to true to get debugging output.                
            </comment>
            <comment line="354">
                This is a handle to the thread managing the thread queue.                
            </comment>
            <comment line="359">
                This flag is set if the timer thread has been notified
                 while it was in the timed wait.  This flag allows the
                 timer thread to tell whether or not the wait completed.                
            </comment>
            <comment line="410">
                Timer Queue                
            </comment>
            <comment line="414">
                The timer queue is a queue of timers waiting to tick.                
            </comment>
            <comment line="419">
                Uses timer.sleepUntil to determine where in the queue
                 to insert the timer object.
                 A new ticker thread is created only if the timer
                 is inserted at the beginning of the queue.
                 The timer must not already be in the queue.
                 Assumes the caller has the TimerThread monitor.                
            </comment>
            <comment line="461">
                If the timer is not in the queue, returns false;
                 otherwise removes the timer from the timer queue and returns true.
                 Assumes the caller has the TimerThread monitor.                
            </comment>
            <comment line="504">
                Inserts the timer back into the queue.  This method
                 is used by a callback thread after it has called the
                 timer owner&apos;s tick() method.  This method recomputes
                 the sleepUntil field.
                 Assumes the caller has the TimerThread and Timer monitor.                
            </comment>
            <comment line="542">
                Maximum size of the thread pool.                
            </comment>
            <comment line="547">
                Number of threads in the pool.                
            </comment>
            <comment line="552">
                The pool of timer threads.                
            </comment>
            <comment line="557">
                Is used when linked into the thread pool.                
            </comment>
            <comment line="562">
                This is the handle to the timer whose owner&apos;s
                 tick() method will be called.                
            </comment>
            <comment line="568">
                The value of a timer&apos;s sleepUntil value is captured here.
                 This is used to determine whether or not the timer should
                 be reinserted into the queue.  If the timer&apos;s sleepUntil
                 value has changed, the timer is not reinserted.                
            </comment>
            <comment line="576">
                Creates a new callback thread to call the timer owner&apos;s
                 tick() method.  A thread is taken from the pool if one
                 is available, otherwise, a new thread is created.
                 The thread handle is returned.                
            </comment>
            <comment line="603">
                Returns false if the thread should simply exit;
                 otherwise the thread is returned the pool, where
                 it waits to be notified.  (I did try to use the
                 class monitor but the time between the notify
                 and breaking out of the wait seemed to take
                 significantly longer; need to look into this later.)                
            </comment>
            <declaration name="debug" type="boolean" line="351"/>
            <declaration name="timerThread" type="TimerThread" line="356"/>
            <declaration name="notified" type="boolean" line="363"/>
            <method name="TimerThread" type="constructor" line="365"/>
            <method name="run" type="void" line="371">
                <comment line="380">
                    Just drop through and check timerQueue.                    
                </comment>
                <comment line="389">
                    Just drop through.                    
                </comment>
                <comment line="392">
                    remove from timer queue.                    
                </comment>
                <scope line="372">
                    <declaration name="delay" type="long" line="373"/>
                    <scope line="375">
                        <scope line="376"/>
                        <scope line="378"/>
                    </scope>
                    <scope line="384">
                        <scope line="385"/>
                        <scope line="387"/>
                    </scope>
                    <scope line="392">
                        <declaration name="timer" type="Timer" line="393"/>
                        <declaration name="thr" type="TimerTickThread" line="395"/>
                        <scope line="397">
                            <declaration name="delta" type="long" line="398"/>
                            <scope line="401"/>
                        </scope>
                    </scope>
                </scope>
            </method>
            <declaration name="timerQueue" type="Timer" line="416"/>
            <method name="enqueue" type="void" line="426">
                <params>
                    <param name="timer" type="Timer"/>
                </params>
                <comment line="432">
                    insert at front of queue                    
                </comment>
                <comment line="442">
                    insert or append to the timer queue                    
                </comment>
                <declaration name="prev" type="Timer" line="427"/>
                <declaration name="cur" type="Timer" line="428"/>
                <scope line="430"/>
                <scope line="436">
                    <scope line="437"/>
                </scope>
                <scope line="445">
                    <declaration name="now" type="long" line="446"/>
                    <scope line="451">
                        <declaration name="delta" type="long" line="452"/>
                    </scope>
                </scope>
            </method>
            <method name="dequeue" type="boolean" line="465">
                <params>
                    <param name="timer" type="Timer"/>
                </params>
                <declaration name="prev" type="Timer" line="466"/>
                <declaration name="cur" type="Timer" line="467"/>
                <scope line="469"/>
                <scope line="473">
                    <scope line="474"/>
                </scope>
                <scope line="479"/>
                <scope line="483"/>
                <scope line="487">
                    <declaration name="now" type="long" line="488"/>
                    <scope line="493">
                        <declaration name="delta" type="long" line="494"/>
                    </scope>
                </scope>
            </method>
            <method name="requeue" type="void" line="510">
                <params>
                    <param name="timer" type="Timer"/>
                </params>
                <scope line="511">
                    <declaration name="now" type="long" line="512"/>
                    <scope line="513"/>
                    <scope line="515"/>
                </scope>
                <scope line="519"/>
            </method>
        </class>
        <class name="TimerTickThread" line="540">
            <extends class="Thread"/>
            <comment line="72">
                Synchronization issues:  there are two data structures that
                require locking.  A Timer object and the Timer queue
                (described in the TimerThread class).  To avoid deadlock,
                the timer queue monitor is always acquired before the timer
                object&apos;s monitor.  However, the timer queue monitor is acquired
                only if the timer operation will make use of the timer
                queue, e.g. stop().
                
                The class monitor on the class TimerThread severs as the monitor
                to the timer queue.
                
                Possible feature: perhaps a timer should have an associated
                thread priority.  The thread that makes the callback temporarily
                takes on that priority before calling the owner&apos;s tick() method.                
            </comment>
            <comment line="96">
                This is the interval of time in ms.                
            </comment>
            <comment line="101">
                This variable is used for two different purposes.
                 This is done in order to save space.
                 If &apos;stopped&apos; is true, this variable holds the time
                 that the timer was stopped; otherwise, this variable
                 is used by the TimerThread to determine when the timer
                 should tick.                
            </comment>
            <comment line="111">
                This is the time remaining before the timer ticks.  It
                 is only valid if &apos;stopped&apos; is true.  If the timer is
                 continued, the next tick will happen remaingTime
                 milliseconds later.                
            </comment>
            <comment line="119">
                True iff the timer is in regular mode.                
            </comment>
            <comment line="124">
                True iff the timer has been stopped.                
            </comment>
            <comment line="129">
                Timer queue-related variables                
            </comment>
            <comment line="133">
                A link to another timer object.  This is used while the
                 timer object is enqueued in the timer queue.                
            </comment>
            <comment line="139">
                Timer methods                
            </comment>
            <comment line="143">
                This variable holds a handle to the TimerThread class for
                 the purpose of getting at the class monitor.  The reason
                 why Class.forName(&quot;TimerThread&quot;) is not used is because it
                 doesn&apos;t appear to work when loaded via a net class loader.                
            </comment>
            <comment line="316">
                This method is used only for testing purposes.                
            </comment>
            <comment line="349">
                Set to true to get debugging output.                
            </comment>
            <comment line="354">
                This is a handle to the thread managing the thread queue.                
            </comment>
            <comment line="359">
                This flag is set if the timer thread has been notified
                 while it was in the timed wait.  This flag allows the
                 timer thread to tell whether or not the wait completed.                
            </comment>
            <comment line="410">
                Timer Queue                
            </comment>
            <comment line="414">
                The timer queue is a queue of timers waiting to tick.                
            </comment>
            <comment line="419">
                Uses timer.sleepUntil to determine where in the queue
                 to insert the timer object.
                 A new ticker thread is created only if the timer
                 is inserted at the beginning of the queue.
                 The timer must not already be in the queue.
                 Assumes the caller has the TimerThread monitor.                
            </comment>
            <comment line="461">
                If the timer is not in the queue, returns false;
                 otherwise removes the timer from the timer queue and returns true.
                 Assumes the caller has the TimerThread monitor.                
            </comment>
            <comment line="504">
                Inserts the timer back into the queue.  This method
                 is used by a callback thread after it has called the
                 timer owner&apos;s tick() method.  This method recomputes
                 the sleepUntil field.
                 Assumes the caller has the TimerThread and Timer monitor.                
            </comment>
            <comment line="542">
                Maximum size of the thread pool.                
            </comment>
            <comment line="547">
                Number of threads in the pool.                
            </comment>
            <comment line="552">
                The pool of timer threads.                
            </comment>
            <comment line="557">
                Is used when linked into the thread pool.                
            </comment>
            <comment line="562">
                This is the handle to the timer whose owner&apos;s
                 tick() method will be called.                
            </comment>
            <comment line="568">
                The value of a timer&apos;s sleepUntil value is captured here.
                 This is used to determine whether or not the timer should
                 be reinserted into the queue.  If the timer&apos;s sleepUntil
                 value has changed, the timer is not reinserted.                
            </comment>
            <comment line="576">
                Creates a new callback thread to call the timer owner&apos;s
                 tick() method.  A thread is taken from the pool if one
                 is available, otherwise, a new thread is created.
                 The thread handle is returned.                
            </comment>
            <comment line="603">
                Returns false if the thread should simply exit;
                 otherwise the thread is returned the pool, where
                 it waits to be notified.  (I did try to use the
                 class monitor but the time between the notify
                 and breaking out of the wait seemed to take
                 significantly longer; need to look into this later.)                
            </comment>
            <declaration name="MAX_POOL_SIZE" type="int" line="544"/>
            <declaration name="curPoolSize" type="int" line="549"/>
            <declaration name="pool" type="TimerTickThread" line="554"/>
            <declaration name="next" type="TimerTickThread" line="559"/>
            <declaration name="timer" type="Timer" line="565"/>
            <declaration name="lastSleepUntil" type="long" line="573"/>
            <method name="call" type="TimerTickThread" line="582">
                <params>
                    <param name="timer" type="Timer"/>
                    <param name="sleepUntil" type="long"/>
                </params>
                <comment line="587">
                    create one.                    
                </comment>
                <declaration name="thread" type="TimerTickThread" line="583"/>
                <scope line="585"/>
                <scope line="591">
                    <scope line="595"/>
                </scope>
            </method>
            <method name="returnToPool" type="boolean" line="610">
                <comment line="626">
                    Just drop through and retest timer.                    
                </comment>
                <scope line="611">
                    <scope line="612"/>
                </scope>
                <scope line="620">
                    <scope line="621">
                        <scope line="622"/>
                        <scope line="624"/>
                    </scope>
                </scope>
                <scope line="629"/>
            </method>
            <method name="run" type="void" line="635">
                <scope line="636">
                    <scope line="638">
                        <scope line="639">
                            <scope line="640"/>
                        </scope>
                    </scope>
                </scope>
            </method>
        </class>
    </source>