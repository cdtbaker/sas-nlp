<?xml version="1.0" encoding="UTF-8"?>
    <source package="sun.misc">
        <import package="java.io.OutputStream"/>
        <import package="java.io.InputStream"/>
        <import package="java.io.PrintStream"/>
        <import package="java.io.IOException"/>
        <class name="UCEncoder" line="6">
            <extends class="CharacterEncoder"/>
            <javadoc line="6">
                This class implements a robust character encoder. The encoder is designed
                  to convert binary data into printable characters. The characters are
                  assumed to exist but they are not assumed to be ASCII, the complete set
                  is 0-9, A-Z, a-z, &quot;(&quot;, and &quot;)&quot;.
                  The basic encoding unit is a 3 character atom. It encodes two bytes
                  of data. Bytes are encoded into a 64 character set, the characters
                  were chosen specifically because they appear in all codesets.
                  We don&apos;t care what their numerical equivalent is because
                  we use a character array to map them. This is like UUencoding
                  with the dependency on ASCII removed.
                  The three chars that make up an atom are encoded as follows:
                  &lt;pre&gt;
                  00xxxyyy 00axxxxx 00byyyyy
                  00 = leading zeros, all values are 0 - 63
                  xxxyyy - Top 3 bits of X, Top 3 bits of Y
                  axxxxx - a = X parity bit, xxxxx lower 5 bits of X
                  byyyyy - b = Y parity bit, yyyyy lower 5 bits of Y
                  &lt;/pre&gt;
                  The atoms are arranged into lines suitable for inclusion into an
                  email message or text file. The number of bytes that are encoded
                  per line is 48 which keeps the total line length  under 80 chars)
                  Each line has the form(
                  &lt;pre&gt;
                  (LLSS)(DDDD)(DDDD)(DDDD)...(CRC)
                  Where each (xxx) represents a three character atom.
                  (LLSS) - 8 bit length (high byte), and sequence number
                  modulo 256;
                  (DDDD) - Data byte atoms, if length is odd, last data
                  atom has (DD00) (high byte data, low byte 0)
                  (CRC)  - 16 bit CRC for the line, includes length,
                  sequence, and all data bytes. If there is a
                  zero pad byte (odd length) it is _NOT_
                  included in the CRC.
                  &lt;/pre&gt;                
                <author>
                    Chuck McManis                    
                </author>
                <see>
                    CharacterEncoder                    
                </see>
                <see>
                    UCDecoder                    
                </see>
            </javadoc>
            <javadoc line="46">
                this clase encodes two bytes per atom                
            </javadoc>
            <method name="bytesPerAtom" type="int" line="49"/>
            <javadoc line="52">
                this class encodes 48 bytes per line                
            </javadoc>
            <method name="bytesPerLine" type="int" line="55"/>
            <declaration name="map_array" type="byte" line="58"/>
            <declaration name="sequence" type="int" line="59"/>
            <declaration name="tmp" type="byte" line="60"/>
            <declaration name="crc" type="CRC16" line="61"/>
            <javadoc line="62">
                encodeAtom - take two bytes and encode them into the correct
                  three characters. If only one byte is to be encoded, the other
                  must be zero. The padding byte is not included in the CRC computation.                
            </javadoc>
            <method name="encodeAtom" type="void" line="67">
                <params>
                    <param name="outStream" type="OutputStream"/>
                    <param name="data" type="byte"/>
                    <param name="offset" type="int"/>
                    <param name="len" type="int"/>
                </params>
                <declaration name="i" type="int" line="68"/>
                <declaration name="p1" type="int" line="69"/>
                <declaration name="a" type="byte" line="70"/>
                <scope line="72"/>
                <scope line="75"/>
                <scope line="79"/>
                <scope line="85">
                    <scope line="86"/>
                    <scope line="89"/>
                </scope>
            </method>
            <javadoc line="99">
                Each UCE encoded line starts with a prefix of &apos;[XXX]&apos;, where
                  the sequence number and the length are encoded in the first
                  atom.                
            </javadoc>
            <method name="encodeLinePrefix" type="void" line="104">
                <params>
                    <param name="outStream" type="OutputStream"/>
                    <param name="length" type="int"/>
                </params>
            </method>
            <javadoc line="112">
                each UCE encoded line ends with YYY and encoded version of the
                  16 bit checksum. The most significant byte of the check sum
                  is always encoded FIRST.                
            </javadoc>
            <method name="encodeLineSuffix" type="void" line="117">
                <params>
                    <param name="outStream" type="OutputStream"/>
                </params>
            </method>
            <javadoc line="123">
                The buffer prefix code is used to initialize the sequence number
                  to zero.                
            </javadoc>
            <method name="encodeBufferPrefix" type="void" line="127">
                <params>
                    <param name="a" type="OutputStream"/>
                </params>
            </method>
        </class>
    </source>