<?xml version="1.0" encoding="UTF-8"?>
    <source package="sun.misc">
        <import package="java.lang.ref"/>
        <import package="java.security.AccessController"/>
        <import package="java.security.PrivilegedAction"/>
        <class name="Cleaner" line="33">
            <extends class="PhantomReference"/>
            <comment line="64">
                Dummy reference queue, needed because the PhantomReference constructor
                 insists that we pass a queue.  Nothing will ever be placed on this queue
                 since the reference handler invokes cleaners explicitly.                
            </comment>
            <comment line="70">
                Doubly-linked list of live cleaners, which prevents the cleaners
                 themselves from being GC&apos;d before their referents                
            </comment>
            <javadoc line="33">
                General-purpose phantom-reference-based cleaners.
                  &lt;p&gt; Cleaners are a lightweight and more robust alternative to finalization.
                  They are lightweight because they are not created by the VM and thus do not
                  require a JNI upcall to be created, and because their cleanup code is
                  invoked directly by the reference-handler thread rather than by the
                  finalizer thread.  They are more robust because they use phantom references,
                  the weakest type of reference object, thereby avoiding the nasty ordering
                  problems inherent to finalization.
                  &lt;p&gt; A cleaner tracks a referent object and encapsulates a thunk of arbitrary
                  cleanup code.  Some time after the GC detects that a cleaner&apos;s referent has
                  become phantom-reachable, the reference-handler thread will run the cleaner.
                  Cleaners may also be invoked directly; they are thread safe and ensure that
                  they run their thunks at most once.
                  &lt;p&gt; Cleaners are not a replacement for finalization.  They should be used
                  only when the cleanup code is extremely simple and straightforward.
                  Nontrivial cleaners are inadvisable since they risk blocking the
                  reference-handler thread and delaying further cleanup and finalization.                
                <author>
                    Mark Reinhold                    
                </author>
            </javadoc>
            <declaration name="dummyQueue" type="ReferenceQueue" line="67"/>
            <declaration name="first" type="Cleaner" line="72"/>
            <declaration name="next" type="Cleaner" line="74"/>
            <method name="add" type="Cleaner" line="78">
                <params>
                    <param name="cl" type="Cleaner"/>
                </params>
                <scope line="79"/>
            </method>
            <method name="remove" type="boolean" line="87">
                <params>
                    <param name="cl" type="Cleaner"/>
                </params>
                <comment line="90">
                    If already removed, do nothing                    
                </comment>
                <comment line="94">
                    Update list                    
                </comment>
                <comment line="106">
                    Indicate removal by pointing the cleaner to itself                    
                </comment>
                <scope line="94"/>
            </method>
            <declaration name="thunk" type="Runnable" line="112"/>
            <method name="Cleaner" type="constructor" line="114">
                <params>
                    <param name="referent" type="Object"/>
                    <param name="thunk" type="Runnable"/>
                </params>
            </method>
            <javadoc line="119">
                Creates a new cleaner.                
                <param>
                    thunkThe cleanup code to be run when the cleaner is invoked.  The
                      cleanup code is run directly from the reference-handler thread,
                      so it should be as simple and straightforward as possible.                    
                </param>
                <return>
                    The new cleaner                    
                </return>
            </javadoc>
            <method name="create" type="Cleaner" line="129">
                <params>
                    <param name="ob" type="Object"/>
                    <param name="thunk" type="Runnable"/>
                </params>
            </method>
            <javadoc line="135">
                Runs this cleaner, if it has not been run before.                
            </javadoc>
            <method name="clean" type="void" line="138">
                <scope line="141"/>
                <scope line="143">
                    <anonymous_class line="144">
                        <method name="run" type="Void" line="145"/>
                    </anonymous_class>
                </scope>
            </method>
        </class>
    </source>