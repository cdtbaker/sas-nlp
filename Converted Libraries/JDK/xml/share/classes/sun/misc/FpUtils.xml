<?xml version="1.0" encoding="UTF-8"?>
    <source package="sun.misc">
        <import package="sun.misc.FloatConsts"/>
        <import package="sun.misc.DoubleConsts"/>
        <class name="FpUtils" line="31">
            <comment line="43">
                The methods in this class are reasonably implemented using
                 direct or indirect bit-level manipulation of floating-point
                 values.  However, having access to the IEEE 754 recommended
                 functions would obviate the need for most programmers to engage
                 in floating-point bit-twiddling.
                
                 An IEEE 754 number has three fields, from most significant bit
                 to to least significant, sign, exponent, and significand.
                
                  msb                                lsb
                 [sign|exponent|  fractional_significand]
                
                 Using some encoding cleverness, explained below, the high order
                 bit of the logical significand does not need to be explicitly
                 stored, thus &quot;fractional_significand&quot; instead of simply
                 &quot;significand&quot; in the figure above.
                
                 For finite normal numbers, the numerical value encoded is
                
                 (-1)^sign  2^(exponent)(1.fractional_significand)
                
                 Most finite floating-point numbers are normalized; the exponent
                 value is reduced until the leading significand bit is 1.
                 Therefore, the leading 1 is redundant and is not explicitly
                 stored.  If a numerical value is so small it cannot be
                 normalized, it has a subnormal representation. Subnormal
                 numbers don&apos;t have a leading 1 in their significand; subnormals
                 are encoding using a special exponent value.  In other words,
                 the high-order bit of the logical significand can be elided in
                 from the representation in either case since the bit&apos;s value is
                 implicit from the exponent value.
                
                 The exponent field uses a biased representation; if the bits of
                 the exponent are interpreted as a unsigned integer E, the
                 exponent represented is E - E_bias where E_bias depends on the
                 floating-point format.  E can range between E_min and E_max,
                 constants which depend on the floating-point format.  E_min and
                 E_max are -126 and +127 for float, -1022 and +1023 for double.
                
                 The 32-bit float format has 1 sign bit, 8 exponent bits, and 23
                 bits for the significand (which is logically 24 bits wide
                 because of the implicit bit).  The 64-bit double format has 1
                 sign bit, 11 exponent bits, and 52 bits for the significand
                 (logically 53 bits).
                
                 Subnormal numbers and zero have the special exponent value
                 E_min -1; the numerical value represented by a subnormal is:
                
                 (-1)^sign  2^(E_min)(0.fractional_significand)
                
                 Zero is represented by all zero bits in the exponent and all
                 zero bits in the significand; zero can have either sign.
                
                 Infinity and NaN are encoded using the exponent value E_max +
                 1.  Signed infinities have all significand bits zero; NaNs have
                 at least one non-zero significand bit.
                
                 The details of IEEE 754 floating-point encoding will be used in
                 the methods below without further comment.  For further
                 exposition on IEEE 754 numbers, see &quot;IEEE Standard for Binary
                 Floating-Point Arithmetic&quot; ANSIIEEE Std 754-1985 or William
                 Kahan&apos;s &quot;Lecture Notes on the Status of IEEE Standard 754 for
                 Binary Floating-Point Arithmetic&quot;,
                 http:www.cs.berkeley.edu~wkahanieee754statusieee754.ps.
                
                 Many of this class&apos;s methods are members of the set of IEEE 754
                 recommended functions or similar functions recommended or
                 required by IEEE 754R.  Discussion of various implementation
                 techniques for these functions have occurred in:
                
                 W.J. Cody and Jerome T. Coonen, &quot;Algorithm 772 Functions to
                 Support the IEEE Standard for Binary Floating-Point
                 Arithmetic,&quot; ACM Transactions on Mathematical Software,
                 vol. 19, no. 4, December 1993, pp. 443-451.
                
                 Joseph D. Darcy, &quot;Writing robust IEEE recommended functions in
                 ``100% Pure Java&apos;&apos;(TM),&quot; University of California, Berkeley
                 technical report UCBCSD-98-1009.                
            </comment>
            <comment line="129">
                Constants used in scalb                
            </comment>
            <comment line="133">
                Helper Methods                
            </comment>
            <comment line="135">
                The following helper methods are used in the implementation of                
            </comment>
            <comment line="136">
                the public recommended functions; they generally omit certain                
            </comment>
            <comment line="137">
                tests for exception cases.                
            </comment>
            <comment line="231">
                                
            </comment>
            <comment line="496">
                The scalb operation should be reasonably fast; however, there
                 are tradeoffs in writing a method to minimize the worst case
                 performance and writing a method to minimize the time for
                 expected common inputs.  Some processors operate very slowly on
                 subnormal operands, taking hundreds or thousands of cycles for
                 one floating-point add or multiply as opposed to, say, four
                 cycles for normal operands.  For processors with very slow
                 subnormal execution, scalb would be fastest if written entirely
                 with integer operations; in other words, scalb would need to
                 include the logic of performing correct rounding of subnormal
                 values.  This could be reasonably done in at most a few hundred
                 cycles.  However, this approach may penalize normal operations
                 since at least the exponent of the floating-point argument must
                 be examined.
                
                 The approach taken in this implementation is a compromise.
                 Floating-point multiplication is used to do most of the work;
                 but knowingly multiplying by a subnormal scaling factor is
                 avoided.  However, the floating-point argument is not examined
                 to see whether or not it is subnormal since subnormal inputs
                 are assumed to be rare.  At most three multiplies are needed to
                 scale from the largest to smallest exponent ranges (scaling
                 down, at most two multiplies are needed if subnormal scaling
                 factors are allowed).  However, in this implementation an
                 expensive integer remainder operation is avoided at the cost of
                 requiring five floating-point multiplies in the worst case,
                 which should still be a performance win.
                
                 If scaling of entire arrays is a concern, it would probably be
                 more efficient to provide a double[] scalb(double[], int)
                 version of scalb to avoid having to recompute the needed
                 scaling factors for each floating-point value.                
            </comment>
            <javadoc line="31">
                The class {@code FpUtils} contains static utility methods for
                  manipulating and inspecting {@code float} and{@code double} floating-point numbers.  These methods include
                  functionality recommended or required by the IEEE 754
                  floating-point standard.                
                <author>
                    Joseph D. Darcy                    
                </author>
            </javadoc>
            <javadoc line="123">
                Don&apos;t let anyone instantiate this class.                
            </javadoc>
            <method name="FpUtils" type="constructor" line="126"/>
            <declaration name="twoToTheDoubleScaleUp" type="double" line="129"/>
            <declaration name="twoToTheDoubleScaleDown" type="double" line="130"/>
            <javadoc line="138">
                Returns unbiased exponent of a {@code double}.                
            </javadoc>
            <method name="getExponent" type="int" line="141">
                <params>
                    <param name="d" type="double"/>
                </params>
                <comment line="142">
                    Bitwise convert d to long, mask out exponent bits, shift
                     to the right and then subtract out double&apos;s bias adjust to
                     get true exponent value.                    
                </comment>
            </method>
            <javadoc line="151">
                Returns unbiased exponent of a {@code float}.                
            </javadoc>
            <method name="getExponent" type="int" line="154">
                <params>
                    <param name="f" type="float"/>
                </params>
                <comment line="155">
                    Bitwise convert f to integer, mask out exponent bits, shift
                     to the right and then subtract out float&apos;s bias adjust to
                     get true exponent value                    
                </comment>
            </method>
            <javadoc line="164">
                Returns a floating-point power of two in the normal range.                
            </javadoc>
            <method name="powerOfTwoD" type="double" line="167">
                <params>
                    <param name="n" type="int"/>
                </params>
            </method>
            <javadoc line="174">
                Returns a floating-point power of two in the normal range.                
            </javadoc>
            <method name="powerOfTwoF" type="float" line="177">
                <params>
                    <param name="n" type="int"/>
                </params>
            </method>
            <javadoc line="184">
                Returns the first floating-point argument with the sign of the
                  second floating-point argument.  Note that unlike the {@link FpUtils#copySign(double,double) copySign} method, this method
                  does not require NaN {@code sign} arguments to be treated
                  as positive values; implementations are permitted to treat some
                  NaN arguments as positive and other NaN arguments as negative
                  to allow greater performance.                
                <param>
                    magnitude  the parameter providing the magnitude of the result                    
                </param>
                <param>
                    sign   the parameter providing the sign of the result                    
                </param>
                <return>
                    a value with the magnitude of {@code magnitude}and the sign of {@code sign}.                    
                </return>
                <author>
                    Joseph D. Darcy                    
                </author>
            </javadoc>
            <method name="rawCopySign" type="double" line="199">
                <params>
                    <param name="magnitude" type="double"/>
                    <param name="sign" type="double"/>
                </params>
            </method>
            <javadoc line="207">
                Returns the first floating-point argument with the sign of the
                  second floating-point argument.  Note that unlike the {@link FpUtils#copySign(float,float) copySign} method, this method
                  does not require NaN {@code sign} arguments to be treated
                  as positive values; implementations are permitted to treat some
                  NaN arguments as positive and other NaN arguments as negative
                  to allow greater performance.                
                <param>
                    magnitude  the parameter providing the magnitude of the result                    
                </param>
                <param>
                    sign   the parameter providing the sign of the result                    
                </param>
                <return>
                    a value with the magnitude of {@code magnitude}and the sign of {@code sign}.                    
                </return>
                <author>
                    Joseph D. Darcy                    
                </author>
            </javadoc>
            <method name="rawCopySign" type="float" line="222">
                <params>
                    <param name="magnitude" type="float"/>
                    <param name="sign" type="float"/>
                </params>
            </method>
            <javadoc line="232">
                Returns {@code true} if the argument is a finite
                  floating-point value; returns {@code false} otherwise (for
                  NaN and infinity arguments).                
                <param>
                    d the {@code double} value to be tested                    
                </param>
                <return>
                    {@code true} if the argument is a finite
                      floating-point value, {@code false} otherwise.                    
                </return>
            </javadoc>
            <method name="isFinite" type="boolean" line="241">
                <params>
                    <param name="d" type="double"/>
                </params>
            </method>
            <javadoc line="245">
                Returns {@code true} if the argument is a finite
                  floating-point value; returns {@code false} otherwise (for
                  NaN and infinity arguments).                
                <param>
                    f the {@code float} value to be tested                    
                </param>
                <return>
                    {@code true} if the argument is a finite
                      floating-point value, {@code false} otherwise.                    
                </return>
            </javadoc>
            <method name="isFinite" type="boolean" line="254">
                <params>
                    <param name="f" type="float"/>
                </params>
            </method>
            <javadoc line="258">
                Returns {@code true} if the specified number is infinitely
                  large in magnitude, {@code false} otherwise.
                  &lt;p&gt;Note that this method is equivalent to the {@link Double#isInfinite(double) Double.isInfinite} method; the
                  functionality is included in this class for convenience.                
                <param>
                    d   the value to be tested.                    
                </param>
                <return>
                    {@code true} if the value of the argument is positive
                      infinity or negative infinity; {@code false} otherwise.                    
                </return>
            </javadoc>
            <method name="isInfinite" type="boolean" line="270">
                <params>
                    <param name="d" type="double"/>
                </params>
            </method>
            <javadoc line="274">
                Returns {@code true} if the specified number is infinitely
                  large in magnitude, {@code false} otherwise.
                  &lt;p&gt;Note that this method is equivalent to the {@link Float#isInfinite(float) Float.isInfinite} method; the
                  functionality is included in this class for convenience.                
                <param>
                    f   the value to be tested.                    
                </param>
                <return>
                    {@code true} if the argument is positive infinity or
                      negative infinity; {@code false} otherwise.                    
                </return>
            </javadoc>
            <method name="isInfinite" type="boolean" line="286">
                <params>
                    <param name="f" type="float"/>
                </params>
            </method>
            <javadoc line="290">
                Returns {@code true} if the specified number is a
                  Not-a-Number (NaN) value, {@code false} otherwise.
                  &lt;p&gt;Note that this method is equivalent to the {@link Double#isNaN(double) Double.isNaN} method; the functionality is
                  included in this class for convenience.                
                <param>
                    d   the value to be tested.                    
                </param>
                <return>
                    {@code true} if the value of the argument is NaN;{@code false} otherwise.                    
                </return>
            </javadoc>
            <method name="isNaN" type="boolean" line="302">
                <params>
                    <param name="d" type="double"/>
                </params>
            </method>
            <javadoc line="306">
                Returns {@code true} if the specified number is a
                  Not-a-Number (NaN) value, {@code false} otherwise.
                  &lt;p&gt;Note that this method is equivalent to the {@link Float#isNaN(float) Float.isNaN} method; the functionality is
                  included in this class for convenience.                
                <param>
                    f   the value to be tested.                    
                </param>
                <return>
                    {@code true} if the argument is NaN;{@code false} otherwise.                    
                </return>
            </javadoc>
            <method name="isNaN" type="boolean" line="318">
                <params>
                    <param name="f" type="float"/>
                </params>
            </method>
            <javadoc line="322">
                Returns {@code true} if the unordered relation holds
                  between the two arguments.  When two floating-point values are
                  unordered, one value is neither less than, equal to, nor
                  greater than the other.  For the unordered relation to be true,
                  at least one argument must be a {@code NaN}.                
                <param>
                    arg1      the first argument                    
                </param>
                <param>
                    arg2      the second argument                    
                </param>
                <return>
                    {@code true} if at least one argument is a NaN,{@code false} otherwise.                    
                </return>
            </javadoc>
            <method name="isUnordered" type="boolean" line="334">
                <params>
                    <param name="arg1" type="double"/>
                    <param name="arg2" type="double"/>
                </params>
            </method>
            <javadoc line="338">
                Returns {@code true} if the unordered relation holds
                  between the two arguments.  When two floating-point values are
                  unordered, one value is neither less than, equal to, nor
                  greater than the other.  For the unordered relation to be true,
                  at least one argument must be a {@code NaN}.                
                <param>
                    arg1      the first argument                    
                </param>
                <param>
                    arg2      the second argument                    
                </param>
                <return>
                    {@code true} if at least one argument is a NaN,{@code false} otherwise.                    
                </return>
            </javadoc>
            <method name="isUnordered" type="boolean" line="350">
                <params>
                    <param name="arg1" type="float"/>
                    <param name="arg2" type="float"/>
                </params>
            </method>
            <javadoc line="354">
                Returns unbiased exponent of a {@code double}; for
                  subnormal values, the number is treated as if it were
                  normalized.  That is for all finite, non-zero, positive numbers
                  &lt;i&gt;x&lt;/i&gt;, &lt;code&gt;scalb(&lt;i&gt;x&lt;/i&gt;, -ilogb(&lt;i&gt;x&lt;/i&gt;))&lt;/code&gt; is
                  always in the range [1, 2).
                  &lt;p&gt;
                  Special cases:
                  &lt;ul&gt;
                  &lt;li&gt; If the argument is NaN, then the result is 2&lt;sup&gt;30&lt;/sup&gt;.
                  &lt;li&gt; If the argument is infinite, then the result is 2&lt;sup&gt;28&lt;/sup&gt;.
                  &lt;li&gt; If the argument is zero, then the result is -(2&lt;sup&gt;28&lt;/sup&gt;).
                  &lt;/ul&gt;                
                <param>
                    d floating-point number whose exponent is to be extracted                    
                </param>
                <return>
                    unbiased exponent of the argument.                    
                </return>
                <author>
                    Joseph D. Darcy                    
                </author>
            </javadoc>
            <method name="ilogb" type="int" line="372">
                <params>
                    <param name="d" type="double"/>
                </params>
                <comment line="376">
                    NaN or infinity                    
                </comment>
                <comment line="378">
                    2^30                    
                </comment>
                <comment line="379">
                    infinite value                    
                </comment>
                <comment line="380">
                    2^28                    
                </comment>
                <comment line="382">
                    zero or subnormal                    
                </comment>
                <comment line="384">
                    -(2^28)                    
                </comment>
                <comment line="389">
                    To avoid causing slow arithmetic on subnormals,
                     the scaling to determine when d&apos;s significand
                     is normalized is done in integer arithmetic.
                     (there must be at least one &quot;1&quot; bit in the
                     significand since zero has been screened out.                    
                </comment>
                <comment line="397">
                    isolate significand bits                    
                </comment>
                <comment line="401">
                    This loop is simple and functional. We might be                    
                </comment>
                <comment line="402">
                    able to do something more clever that was faster;                    
                </comment>
                <comment line="403">
                    e.g. number of leading zero detection on                    
                </comment>
                <comment line="404">
                    (transducer &lt;&lt; (# exponent and sign bits).                    
                </comment>
                <declaration name="exponent" type="int" line="373"/>
                <scope line="383"/>
                <scope line="386">
                    <declaration name="transducer" type="long" line="387"/>
                    <scope line="406"/>
                </scope>
            </method>
            <javadoc line="424">
                Returns unbiased exponent of a {@code float}; for
                  subnormal values, the number is treated as if it were
                  normalized.  That is for all finite, non-zero, positive numbers
                  &lt;i&gt;x&lt;/i&gt;, &lt;code&gt;scalb(&lt;i&gt;x&lt;/i&gt;, -ilogb(&lt;i&gt;x&lt;/i&gt;))&lt;/code&gt; is
                  always in the range [1, 2).
                  &lt;p&gt;
                  Special cases:
                  &lt;ul&gt;
                  &lt;li&gt; If the argument is NaN, then the result is 2&lt;sup&gt;30&lt;/sup&gt;.
                  &lt;li&gt; If the argument is infinite, then the result is 2&lt;sup&gt;28&lt;/sup&gt;.
                  &lt;li&gt; If the argument is zero, then the result is -(2&lt;sup&gt;28&lt;/sup&gt;).
                  &lt;/ul&gt;                
                <param>
                    f floating-point number whose exponent is to be extracted                    
                </param>
                <return>
                    unbiased exponent of the argument.                    
                </return>
                <author>
                    Joseph D. Darcy                    
                </author>
            </javadoc>
            <method name="ilogb" type="int" line="442">
                <params>
                    <param name="f" type="float"/>
                </params>
                <comment line="446">
                    NaN or infinity                    
                </comment>
                <comment line="448">
                    2^30                    
                </comment>
                <comment line="449">
                    infinite value                    
                </comment>
                <comment line="450">
                    2^28                    
                </comment>
                <comment line="452">
                    zero or subnormal                    
                </comment>
                <comment line="454">
                    -(2^28)                    
                </comment>
                <comment line="459">
                    To avoid causing slow arithmetic on subnormals,
                     the scaling to determine when f&apos;s significand
                     is normalized is done in integer arithmetic.
                     (there must be at least one &quot;1&quot; bit in the
                     significand since zero has been screened out.                    
                </comment>
                <comment line="467">
                    isolate significand bits                    
                </comment>
                <comment line="471">
                    This loop is simple and functional. We might be                    
                </comment>
                <comment line="472">
                    able to do something more clever that was faster;                    
                </comment>
                <comment line="473">
                    e.g. number of leading zero detection on                    
                </comment>
                <comment line="474">
                    (transducer &lt;&lt; (# exponent and sign bits).                    
                </comment>
                <declaration name="exponent" type="int" line="443"/>
                <scope line="453"/>
                <scope line="456">
                    <declaration name="transducer" type="int" line="457"/>
                    <scope line="476"/>
                </scope>
            </method>
            <javadoc line="530">
                Return {@code d} &amp;times;
                  2&lt;sup&gt;{@code scale_factor}&lt;/sup&gt; rounded as if performed
                  by a single correctly rounded floating-point multiply to a
                  member of the double value set.  See section 4.2.3 of
                  &lt;cite&gt;The Java&amp;trade; Language Specification&lt;/cite&gt;
                  for a discussion of floating-point
                  value sets.  If the exponent of the result is between the{@code double}&apos;s minimum exponent and maximum exponent,
                  the answer is calculated exactly.  If the exponent of the
                  result would be larger than {@code doubles}&apos;s maximum
                  exponent, an infinity is returned.  Note that if the result is
                  subnormal, precision may be lost; that is, when {@code scalb(x,
                  n)} is subnormal, {@code scalb(scalb(x, n), -n)} may
                  not equal &lt;i&gt;x&lt;/i&gt;.  When the result is non-NaN, the result has
                  the same sign as {@code d}.
                  &lt;p&gt;
                  Special cases:
                  &lt;ul&gt;
                  &lt;li&gt; If the first argument is NaN, NaN is returned.
                  &lt;li&gt; If the first argument is infinite, then an infinity of the
                  same sign is returned.
                  &lt;li&gt; If the first argument is zero, then a zero of the same
                  sign is returned.
                  &lt;/ul&gt;                
                <param>
                    d number to be scaled by a power of two.                    
                </param>
                <param>
                    scale_factor power of 2 used to scale {@code d}                    
                </param>
                <return>
                    {@code d  }2<sup>{@code scale_factor}</sup>                    
                </return>
                <author>
                    Joseph D. Darcy                    
                </author>
            </javadoc>
            <method name="scalb" type="double" line="562">
                <params>
                    <param name="d" type="double"/>
                    <param name="scale_factor" type="int"/>
                </params>
                <comment line="563">
                    This method does not need to be declared strictfp to
                     compute the same correct result on all platforms.  When
                     scaling up, it does not matter what order the
                     multiply-store operations are done; the result will be
                     finite or overflow regardless of the operation ordering.
                     However, to get the correct result when scaling down, a
                     particular ordering must be used.
                    
                     When scaling down, the multiply-store operations are
                     sequenced so that it is not possible for two consecutive
                     multiply-stores to return subnormal results.  If one
                     multiply-store result is subnormal, the next multiply will
                     round it away to zero.  This is done by first multiplying
                     by 2 ^ (scale_factor % n) and then multiplying several
                     times by by 2^n as needed where n is the exponent of number
                     that is a covenient power of two.  In this way, at most one
                     real rounding error occurs.  If the double value set is
                     being used exclusively, the rounding will occur on a
                     multiply.  If the double-extended-exponent value set is
                     being used, the products will (perhaps) be exact but the
                     stores to d are guaranteed to round to the double value
                     set.
                    
                     It is _not_ a valid implementation to first multiply d by
                     2^MIN_EXPONENT and then by 2 ^ (scale_factor %
                     MIN_EXPONENT) since even in a strictfp program double
                     rounding on underflow could occur; e.g. if the scale_factor
                     argument was (MIN_EXPONENT - n) and the exponent of d was a
                     little less than -(MIN_EXPONENT - n), meaning the final
                     result would be subnormal.
                    
                     Since exact reproducibility of this method can be achieved
                     without any undue performance burden, there is no
                     compelling reason to allow double rounding on underflow in
                     scalb.                    
                </comment>
                <comment line="601">
                    magnitude of a power of two so large that scaling a finite                    
                </comment>
                <comment line="602">
                    nonzero value by it would be guaranteed to over or                    
                </comment>
                <comment line="603">
                    underflow; due to rounding, scaling down takes takes an                    
                </comment>
                <comment line="604">
                    additional power of two which is reflected here                    
                </comment>
                <comment line="611">
                    Make sure scaling factor is in a reasonable range                    
                </comment>
                <comment line="624">
                    Calculate (scale_factor % +/-512), 512 = 2^9, using                    
                </comment>
                <comment line="625">
                    technique from &quot;Hacker&apos;s Delight&quot; section 10-2.                    
                </comment>
                <declaration name="MAX_SCALE" type="int" line="605"/>
                <declaration name="exp_adjust" type="int" line="607"/>
                <declaration name="scale_increment" type="int" line="608"/>
                <declaration name="exp_delta" type="double" line="609"/>
                <scope line="613"/>
                <scope line="618"/>
                <declaration name="t" type="int" line="626"/>
                <scope line="632"/>
            </method>
            <javadoc line="639">
                Return {@code f} &amp;times;
                  2&lt;sup&gt;{@code scale_factor}&lt;/sup&gt; rounded as if performed
                  by a single correctly rounded floating-point multiply to a
                  member of the float value set.  See section 4.2.3 of
                  &lt;cite&gt;The Java&amp;trade; Language Specification&lt;/cite&gt;
                  for a discussion of floating-point
                  value sets. If the exponent of the result is between the{@code float}&apos;s minimum exponent and maximum exponent, the
                  answer is calculated exactly.  If the exponent of the result
                  would be larger than {@code float}&apos;s maximum exponent, an
                  infinity is returned.  Note that if the result is subnormal,
                  precision may be lost; that is, when {@code scalb(x, n)}is subnormal, {@code scalb(scalb(x, n), -n)} may not equal
                  &lt;i&gt;x&lt;/i&gt;.  When the result is non-NaN, the result has the same
                  sign as {@code f}.
                  &lt;p&gt;
                  Special cases:
                  &lt;ul&gt;
                  &lt;li&gt; If the first argument is NaN, NaN is returned.
                  &lt;li&gt; If the first argument is infinite, then an infinity of the
                  same sign is returned.
                  &lt;li&gt; If the first argument is zero, then a zero of the same
                  sign is returned.
                  &lt;/ul&gt;                
                <param>
                    f number to be scaled by a power of two.                    
                </param>
                <param>
                    scale_factor power of 2 used to scale {@code f}                    
                </param>
                <return>
                    {@code f  }2<sup>{@code scale_factor}</sup>                    
                </return>
                <author>
                    Joseph D. Darcy                    
                </author>
            </javadoc>
            <method name="scalb" type="float" line="671">
                <params>
                    <param name="f" type="float"/>
                    <param name="scale_factor" type="int"/>
                </params>
                <comment line="672">
                    magnitude of a power of two so large that scaling a finite                    
                </comment>
                <comment line="673">
                    nonzero value by it would be guaranteed to over or                    
                </comment>
                <comment line="674">
                    underflow; due to rounding, scaling down takes takes an                    
                </comment>
                <comment line="675">
                    additional power of two which is reflected here                    
                </comment>
                <comment line="679">
                    Make sure scaling factor is in a reasonable range                    
                </comment>
                <comment line="682">
                    Since + MAX_SCALE for float fits well within the double
                     exponent range and + float -&gt; double conversion is exact
                     the multiplication below will be exact. Therefore, the
                     rounding that occurs when the double product is cast to
                     float will be the correctly rounded float result.  Since
                     all operations other than the final multiply will be exact,
                     it is not necessary to declare this method strictfp.                    
                </comment>
                <declaration name="MAX_SCALE" type="int" line="676"/>
            </method>
            <javadoc line="694">
                Returns the floating-point number adjacent to the first
                  argument in the direction of the second argument.  If both
                  arguments compare as equal the second argument is returned.
                  &lt;p&gt;
                  Special cases:
                  &lt;ul&gt;
                  &lt;li&gt; If either argument is a NaN, then NaN is returned.
                  &lt;li&gt; If both arguments are signed zeros, {@code direction}is returned unchanged (as implied by the requirement of
                  returning the second argument if the arguments compare as
                  equal).
                  &lt;li&gt; If {@code start} is
                  &amp;plusmn;{@code Double.MIN_VALUE} and {@code direction}has a value such that the result should have a smaller
                  magnitude, then a zero with the same sign as {@code start}is returned.
                  &lt;li&gt; If {@code start} is infinite and{@code direction} has a value such that the result should
                  have a smaller magnitude, {@code Double.MAX_VALUE} with the
                  same sign as {@code start} is returned.
                  &lt;li&gt; If {@code start} is equal to &amp;plusmn;{@code Double.MAX_VALUE} and {@code direction} has a
                  value such that the result should have a larger magnitude, an
                  infinity with same sign as {@code start} is returned.
                  &lt;/ul&gt;                
                <param>
                    start     starting floating-point value                    
                </param>
                <param>
                    direction value indicating which of{@code start}'s neighbors or {@code start} should
                      be returned                    
                </param>
                <return>
                    The floating-point number adjacent to {@code start} in the
                      direction of {@code direction}.                    
                </return>
                <author>
                    Joseph D. Darcy                    
                </author>
            </javadoc>
            <method name="nextAfter" type="double" line="734">
                <params>
                    <param name="start" type="double"/>
                    <param name="direction" type="double"/>
                </params>
                <comment line="735">
                    The cases:
                    
                     nextAfter(+infinity, 0)  == MAX_VALUE
                     nextAfter(+infinity, +infinity)  == +infinity
                     nextAfter(-infinity, 0)  == -MAX_VALUE
                     nextAfter(-infinity, -infinity)  == -infinity
                    
                     are naturally handled without any additional testing                    
                </comment>
                <comment line="746">
                    First check for NaN values                    
                </comment>
                <comment line="748">
                    return a NaN derived from the input NaN(s)                    
                </comment>
                <comment line="752">
                    start &gt; direction or start &lt; direction                    
                </comment>
                <comment line="753">
                    Add +0.0 to get rid of a -0.0 (+0.0 + -0.0 =&gt; +0.0)                    
                </comment>
                <comment line="754">
                    then bitwise convert start to integer.                    
                </comment>
                <comment line="757">
                    IEEE 754 floating-point numbers are lexicographically
                     ordered if treated as signed- magnitude integers .
                     Since Java&apos;s integers are two&apos;s complement,
                     incrementing&quot; the two&apos;s complement representation of a
                     logically negative floating-point value decrements
                     the signed-magnitude representation. Therefore, when
                     the integer representation of a floating-point values
                     is less than zero, the adjustment to the representation
                     is in the opposite direction than would be expected at
                     first .                    
                </comment>
                <comment line="769">
                    Calculate next greater value                    
                </comment>
                <comment line="771">
                    Calculate next lesser value                    
                </comment>
                <comment line="778">
                    transducer==0, the result is -MIN_VALUE
                    
                     The transition from zero (implicitly
                     positive) to the smallest negative
                     signed magnitude value must be done
                     explicitly.                    
                </comment>
                <scope line="747"/>
                <scope line="750"/>
                <scope line="752">
                    <declaration name="transducer" type="long" line="755"/>
                    <scope line="769"/>
                    <scope line="771"/>
                </scope>
            </method>
            <javadoc line="794">
                Returns the floating-point number adjacent to the first
                  argument in the direction of the second argument.  If both
                  arguments compare as equal, the second argument is returned.
                  &lt;p&gt;
                  Special cases:
                  &lt;ul&gt;
                  &lt;li&gt; If either argument is a NaN, then NaN is returned.
                  &lt;li&gt; If both arguments are signed zeros, a {@code float}zero with the same sign as {@code direction} is returned
                  (as implied by the requirement of returning the second argument
                  if the arguments compare as equal).
                  &lt;li&gt; If {@code start} is
                  &amp;plusmn;{@code Float.MIN_VALUE} and {@code direction}has a value such that the result should have a smaller
                  magnitude, then a zero with the same sign as {@code start}is returned.
                  &lt;li&gt; If {@code start} is infinite and{@code direction} has a value such that the result should
                  have a smaller magnitude, {@code Float.MAX_VALUE} with the
                  same sign as {@code start} is returned.
                  &lt;li&gt; If {@code start} is equal to &amp;plusmn;{@code Float.MAX_VALUE} and {@code direction} has a
                  value such that the result should have a larger magnitude, an
                  infinity with same sign as {@code start} is returned.
                  &lt;/ul&gt;                
                <param>
                    start     starting floating-point value                    
                </param>
                <param>
                    direction value indicating which of{@code start}'s neighbors or {@code start} should
                      be returned                    
                </param>
                <return>
                    The floating-point number adjacent to {@code start} in the
                      direction of {@code direction}.                    
                </return>
                <author>
                    Joseph D. Darcy                    
                </author>
            </javadoc>
            <method name="nextAfter" type="float" line="834">
                <params>
                    <param name="start" type="float"/>
                    <param name="direction" type="double"/>
                </params>
                <comment line="835">
                    The cases:
                    
                     nextAfter(+infinity, 0)  == MAX_VALUE
                     nextAfter(+infinity, +infinity)  == +infinity
                     nextAfter(-infinity, 0)  == -MAX_VALUE
                     nextAfter(-infinity, -infinity)  == -infinity
                    
                     are naturally handled without any additional testing                    
                </comment>
                <comment line="846">
                    First check for NaN values                    
                </comment>
                <comment line="848">
                    return a NaN derived from the input NaN(s)                    
                </comment>
                <comment line="852">
                    start &gt; direction or start &lt; direction                    
                </comment>
                <comment line="853">
                    Add +0.0 to get rid of a -0.0 (+0.0 + -0.0 =&gt; +0.0)                    
                </comment>
                <comment line="854">
                    then bitwise convert start to integer.                    
                </comment>
                <comment line="857">
                    IEEE 754 floating-point numbers are lexicographically
                     ordered if treated as signed- magnitude integers .
                     Since Java&apos;s integers are two&apos;s complement,
                     incrementing&quot; the two&apos;s complement representation of a
                     logically negative floating-point value decrements
                     the signed-magnitude representation. Therefore, when
                     the integer representation of a floating-point values
                     is less than zero, the adjustment to the representation
                     is in the opposite direction than would be expected at
                     first.                    
                </comment>
                <comment line="869">
                    Calculate next greater value                    
                </comment>
                <comment line="871">
                    Calculate next lesser value                    
                </comment>
                <comment line="878">
                    transducer==0, the result is -MIN_VALUE
                    
                     The transition from zero (implicitly
                     positive) to the smallest negative
                     signed magnitude value must be done
                     explicitly.                    
                </comment>
                <scope line="847"/>
                <scope line="850"/>
                <scope line="852">
                    <declaration name="transducer" type="int" line="855"/>
                    <scope line="869"/>
                    <scope line="871"/>
                </scope>
            </method>
            <javadoc line="894">
                Returns the floating-point value adjacent to {@code d} in
                  the direction of positive infinity.  This method is
                  semantically equivalent to {@code nextAfter(d,
                  Double.POSITIVE_INFINITY)}; however, a {@code nextUp}implementation may run faster than its equivalent{@code nextAfter} call.
                  &lt;p&gt;Special Cases:
                  &lt;ul&gt;
                  &lt;li&gt; If the argument is NaN, the result is NaN.
                  &lt;li&gt; If the argument is positive infinity, the result is
                  positive infinity.
                  &lt;li&gt; If the argument is zero, the result is{@code Double.MIN_VALUE}&lt;/ul&gt;                
                <param>
                    d  starting floating-point value                    
                </param>
                <return>
                    The adjacent floating-point value closer to positive
                      infinity.                    
                </return>
                <author>
                    Joseph D. Darcy                    
                </author>
            </javadoc>
            <method name="nextUp" type="double" line="919">
                <params>
                    <param name="d" type="double"/>
                </params>
                <scope line="922"/>
            </method>
            <javadoc line="929">
                Returns the floating-point value adjacent to {@code f} in
                  the direction of positive infinity.  This method is
                  semantically equivalent to {@code nextAfter(f,
                  Double.POSITIVE_INFINITY)}; however, a {@code nextUp}implementation may run faster than its equivalent{@code nextAfter} call.
                  &lt;p&gt;Special Cases:
                  &lt;ul&gt;
                  &lt;li&gt; If the argument is NaN, the result is NaN.
                  &lt;li&gt; If the argument is positive infinity, the result is
                  positive infinity.
                  &lt;li&gt; If the argument is zero, the result is{@code Float.MIN_VALUE}&lt;/ul&gt;                
                <param>
                    f  starting floating-point value                    
                </param>
                <return>
                    The adjacent floating-point value closer to positive
                      infinity.                    
                </return>
                <author>
                    Joseph D. Darcy                    
                </author>
            </javadoc>
            <method name="nextUp" type="float" line="954">
                <params>
                    <param name="f" type="float"/>
                </params>
                <scope line="957"/>
            </method>
            <javadoc line="964">
                Returns the floating-point value adjacent to {@code d} in
                  the direction of negative infinity.  This method is
                  semantically equivalent to {@code nextAfter(d,
                  Double.NEGATIVE_INFINITY)}; however, a{@code nextDown} implementation may run faster than its
                  equivalent {@code nextAfter} call.
                  &lt;p&gt;Special Cases:
                  &lt;ul&gt;
                  &lt;li&gt; If the argument is NaN, the result is NaN.
                  &lt;li&gt; If the argument is negative infinity, the result is
                  negative infinity.
                  &lt;li&gt; If the argument is zero, the result is{@code -Double.MIN_VALUE}&lt;/ul&gt;                
                <param>
                    d  starting floating-point value                    
                </param>
                <return>
                    The adjacent floating-point value closer to negative
                      infinity.                    
                </return>
                <author>
                    Joseph D. Darcy                    
                </author>
            </javadoc>
            <method name="nextDown" type="double" line="989">
                <params>
                    <param name="d" type="double"/>
                </params>
                <scope line="992"/>
            </method>
            <javadoc line="1001">
                Returns the floating-point value adjacent to {@code f} in
                  the direction of negative infinity.  This method is
                  semantically equivalent to {@code nextAfter(f,
                  Float.NEGATIVE_INFINITY)}; however, a{@code nextDown} implementation may run faster than its
                  equivalent {@code nextAfter} call.
                  &lt;p&gt;Special Cases:
                  &lt;ul&gt;
                  &lt;li&gt; If the argument is NaN, the result is NaN.
                  &lt;li&gt; If the argument is negative infinity, the result is
                  negative infinity.
                  &lt;li&gt; If the argument is zero, the result is{@code -Float.MIN_VALUE}&lt;/ul&gt;                
                <param>
                    f  starting floating-point value                    
                </param>
                <return>
                    The adjacent floating-point value closer to negative
                      infinity.                    
                </return>
                <author>
                    Joseph D. Darcy                    
                </author>
            </javadoc>
            <method name="nextDown" type="double" line="1026">
                <params>
                    <param name="f" type="float"/>
                </params>
                <scope line="1029"/>
            </method>
            <javadoc line="1038">
                Returns the first floating-point argument with the sign of the
                  second floating-point argument.  For this method, a NaN{@code sign} argument is always treated as if it were
                  positive.                
                <param>
                    magnitude  the parameter providing the magnitude of the result                    
                </param>
                <param>
                    sign   the parameter providing the sign of the result                    
                </param>
                <return>
                    a value with the magnitude of {@code magnitude}and the sign of {@code sign}.                    
                </return>
                <author>
                    Joseph D. Darcy                    
                </author>
                <since>
                    1.5                    
                </since>
            </javadoc>
            <method name="copySign" type="double" line="1051">
                <params>
                    <param name="magnitude" type="double"/>
                    <param name="sign" type="double"/>
                </params>
            </method>
            <javadoc line="1055">
                Returns the first floating-point argument with the sign of the
                  second floating-point argument.  For this method, a NaN{@code sign} argument is always treated as if it were
                  positive.                
                <param>
                    magnitude  the parameter providing the magnitude of the result                    
                </param>
                <param>
                    sign   the parameter providing the sign of the result                    
                </param>
                <return>
                    a value with the magnitude of {@code magnitude}and the sign of {@code sign}.                    
                </return>
                <author>
                    Joseph D. Darcy                    
                </author>
            </javadoc>
            <method name="copySign" type="float" line="1067">
                <params>
                    <param name="magnitude" type="float"/>
                    <param name="sign" type="float"/>
                </params>
            </method>
            <javadoc line="1071">
                Returns the size of an ulp of the argument.  An ulp of a{@code double} value is the positive distance between this
                  floating-point value and the {@code double} value next
                  larger in magnitude.  Note that for non-NaN &lt;i&gt;x&lt;/i&gt;,
                  &lt;code&gt;ulp(-&lt;i&gt;x&lt;/i&gt;) == ulp(&lt;i&gt;x&lt;/i&gt;)&lt;/code&gt;.
                  &lt;p&gt;Special Cases:
                  &lt;ul&gt;
                  &lt;li&gt; If the argument is NaN, then the result is NaN.
                  &lt;li&gt; If the argument is positive or negative infinity, then the
                  result is positive infinity.
                  &lt;li&gt; If the argument is positive or negative zero, then the result is{@code Double.MIN_VALUE}.
                  &lt;li&gt; If the argument is &amp;plusmn;{@code Double.MAX_VALUE}, then
                  the result is equal to 2&lt;sup&gt;971&lt;/sup&gt;.
                  &lt;/ul&gt;                
                <param>
                    d the floating-point value whose ulp is to be returned                    
                </param>
                <return>
                    the size of an ulp of the argument                    
                </return>
                <author>
                    Joseph D. Darcy                    
                </author>
                <since>
                    1.5                    
                </since>
            </javadoc>
            <method name="ulp" type="double" line="1094">
                <params>
                    <param name="d" type="double"/>
                </params>
                <comment line="1098">
                    NaN or infinity                    
                </comment>
                <comment line="1101">
                    zero or subnormal                    
                </comment>
                <comment line="1107">
                    ulp(x) is usually 2^(SIGNIFICAND_WIDTH-1)*(2^ilogb(x))                    
                </comment>
                <comment line="1113">
                    return a subnormal result; left shift integer                    
                </comment>
                <comment line="1114">
                    representation of Double.MIN_VALUE appropriate                    
                </comment>
                <comment line="1115">
                    number of positions                    
                </comment>
                <declaration name="exp" type="int" line="1095"/>
                <scope line="1109"/>
                <scope line="1112"/>
            </method>
            <javadoc line="1122">
                Returns the size of an ulp of the argument.  An ulp of a{@code float} value is the positive distance between this
                  floating-point value and the {@code float} value next
                  larger in magnitude.  Note that for non-NaN &lt;i&gt;x&lt;/i&gt;,
                  &lt;code&gt;ulp(-&lt;i&gt;x&lt;/i&gt;) == ulp(&lt;i&gt;x&lt;/i&gt;)&lt;/code&gt;.
                  &lt;p&gt;Special Cases:
                  &lt;ul&gt;
                  &lt;li&gt; If the argument is NaN, then the result is NaN.
                  &lt;li&gt; If the argument is positive or negative infinity, then the
                  result is positive infinity.
                  &lt;li&gt; If the argument is positive or negative zero, then the result is{@code Float.MIN_VALUE}.
                  &lt;li&gt; If the argument is &amp;plusmn;{@code Float.MAX_VALUE}, then
                  the result is equal to 2&lt;sup&gt;104&lt;/sup&gt;.
                  &lt;/ul&gt;                
                <param>
                    f the floating-point value whose ulp is to be returned                    
                </param>
                <return>
                    the size of an ulp of the argument                    
                </return>
                <author>
                    Joseph D. Darcy                    
                </author>
                <since>
                    1.5                    
                </since>
            </javadoc>
            <method name="ulp" type="float" line="1145">
                <params>
                    <param name="f" type="float"/>
                </params>
                <comment line="1149">
                    NaN or infinity                    
                </comment>
                <comment line="1152">
                    zero or subnormal                    
                </comment>
                <comment line="1158">
                    ulp(x) is usually 2^(SIGNIFICAND_WIDTH-1)*(2^ilogb(x))                    
                </comment>
                <comment line="1164">
                    return a subnormal result; left shift integer                    
                </comment>
                <comment line="1165">
                    representation of FloatConsts.MIN_VALUE appropriate                    
                </comment>
                <comment line="1166">
                    number of positions                    
                </comment>
                <declaration name="exp" type="int" line="1146"/>
                <scope line="1160"/>
                <scope line="1163"/>
            </method>
            <javadoc line="1173">
                Returns the signum function of the argument; zero if the argument
                  is zero, 1.0 if the argument is greater than zero, -1.0 if the
                  argument is less than zero.
                  &lt;p&gt;Special Cases:
                  &lt;ul&gt;
                  &lt;li&gt; If the argument is NaN, then the result is NaN.
                  &lt;li&gt; If the argument is positive zero or negative zero, then the
                  result is the same as the argument.
                  &lt;/ul&gt;                
                <param>
                    d the floating-point value whose signum is to be returned                    
                </param>
                <return>
                    the signum function of the argument                    
                </return>
                <author>
                    Joseph D. Darcy                    
                </author>
                <since>
                    1.5                    
                </since>
            </javadoc>
            <method name="signum" type="double" line="1190">
                <params>
                    <param name="d" type="double"/>
                </params>
            </method>
            <javadoc line="1194">
                Returns the signum function of the argument; zero if the argument
                  is zero, 1.0f if the argument is greater than zero, -1.0f if the
                  argument is less than zero.
                  &lt;p&gt;Special Cases:
                  &lt;ul&gt;
                  &lt;li&gt; If the argument is NaN, then the result is NaN.
                  &lt;li&gt; If the argument is positive zero or negative zero, then the
                  result is the same as the argument.
                  &lt;/ul&gt;                
                <param>
                    f the floating-point value whose signum is to be returned                    
                </param>
                <return>
                    the signum function of the argument                    
                </return>
                <author>
                    Joseph D. Darcy                    
                </author>
                <since>
                    1.5                    
                </since>
            </javadoc>
            <method name="signum" type="float" line="1211">
                <params>
                    <param name="f" type="float"/>
                </params>
            </method>
        </class>
    </source>