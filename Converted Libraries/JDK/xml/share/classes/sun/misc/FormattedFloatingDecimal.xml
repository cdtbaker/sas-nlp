<?xml version="1.0" encoding="UTF-8"?>
    <source package="sun.misc">
        <import package="sun.misc.FpUtils"/>
        <import package="sun.misc.DoubleConsts"/>
        <import package="sun.misc.FloatConsts"/>
        <import package="java.util.regex"/>
        <class name="FormattedFloatingDecimal" line="33">
            <comment line="37">
                value set at construction, then immutable                
            </comment>
            <comment line="45">
                set by doubleValue                
            </comment>
            <comment line="46">
                number of digits to the right of decimal                
            </comment>
            <comment line="63">
                Constants of the implementation
                 Most are IEEE-754 related.
                 (There are more really boring constants at the end.)                
            </comment>
            <comment line="73">
                assumed High-Order bit                
            </comment>
            <comment line="74">
                exponent of 1.0                
            </comment>
            <comment line="80">
                i.e. abs(minDecimalExponent)                
            </comment>
            <comment line="99">
                count number of bits from high-order 1 bit to low-order 1 bit,
                 inclusive.                
            </comment>
            <comment line="131">
                Keep big powers of 5 handy for future reference.                
            </comment>
            <comment line="176">
                                
            </comment>
            <comment line="177">
                a common operation                
            </comment>
            <comment line="178">
                                
            </comment>
            <comment line="194">
                                
            </comment>
            <comment line="195">
                another common operation                
            </comment>
            <comment line="196">
                                
            </comment>
            <comment line="206">
                Make a floating double into a FDBigInt.
                 This could also be structured as a FDBigInt
                 constructor, but we&apos;d have to build a lot of knowledge
                 about floating-point representation into it, and we don&apos;t want to.
                
                 AS A SIDE EFFECT, THIS METHOD WILL SET THE INSTANCE VARIABLES
                 bigIntExp and bigIntNBits                
            </comment>
            <comment line="245">
                Compute a number that is the ULP of the given value,
                 for purposes of additionsubtraction. Generally easy.
                 More difficult if subtracting and the argument
                 is a normalized a power of 2, as the ULP changes at these points.                
            </comment>
            <comment line="272">
                Round a double to a float.
                 In addition to the fraction bits of the double,
                 look at the class instance variable roundDir,
                 which should help us avoid double-rounding error.
                 roundDir was set in hardValueOf if the estimate was
                 close enough, but not exact. It tells us which direction
                 of rounding is preferred.                
            </comment>
            <comment line="295">
                This is the easy subcase --
                 all the significant bits, after scaling, are held in lvalue.
                 negSign and decExponent tell us what processing and scaling
                 has already been done. Exceptional cases have already been
                 stripped out.
                 In particular:
                 lvalue is a finite number (not Inf, nor NaN)
                 lvalue &gt; 0L (not zero, nor negative).
                
                 The only reason that we develop the digits here, rather than
                 calling on Long.toString() is that we can do it a little faster,
                 and besides want to treat trailing 0s specially. If Long.toString
                 changes, we should re-evaluate this strategy!                
            </comment>
            <comment line="384">
                                
            </comment>
            <comment line="385">
                add one to the least significant digit.                
            </comment>
            <comment line="386">
                in the unlikely event there is a carry out,                
            </comment>
            <comment line="387">
                deal with it.                
            </comment>
            <comment line="388">
                assert that this will only happen where there                
            </comment>
            <comment line="389">
                is only one digit, e.g. (float)1e-44 seems to do it.                
            </comment>
            <comment line="390">
                                
            </comment>
            <comment line="411">
                Given the desired number of digits predict the result&apos;s exponent.                
            </comment>
            <comment line="423">
                Unlike roundup(), this method does not modify digits.  It also                
            </comment>
            <comment line="424">
                rounds at a particular precision.                
            </comment>
            <comment line="465">
                FIRST IMPORTANT CONSTRUCTOR: DOUBLE                
            </comment>
            <comment line="533">
                SECOND IMPORTANT CONSTRUCTOR: SINGLE                
            </comment>
            <comment line="981">
                returns the exponent before rounding                
            </comment>
            <comment line="986">
                returns the exponent after rounding has been done by applyPrecision                
            </comment>
            <comment line="1144">
                Per-thread buffer for string/stringbuffer conversion                
            </comment>
            <comment line="1151">
                Take a FormattedFloatingDecimal, which we presumably just scanned in,
                 and find out what its value is, as a double.
                
                 AS A SIDE EFFECT, SET roundDir TO INDICATE PREFERRED
                 ROUNDING DIRECTION in case the result is really destined
                 for a single-precision float.                
            </comment>
            <comment line="1509">
                Take a FormattedFloatingDecimal, which we presumably just scanned in,
                 and find out what its value is, as a float.
                 This is distinct from doubleValue() to avoid the extremely
                 unlikely case of a double rounding error, wherein the converstion
                 to double has one rounding error, and the conversion of that double
                 to a float has another rounding error, IN THE WRONG DIRECTION,
                 ( because of the preference to a zero low-order bit ).                
            </comment>
            <comment line="1659">
                All the positive powers of 10 that can be
                 represented exactly in doublefloat.                
            </comment>
            <comment line="1734">
                approximately ceil( log2( long5pow[i] ) )                
            </comment>
            <declaration name="isExceptional" type="boolean" line="34"/>
            <declaration name="isNegative" type="boolean" line="35"/>
            <declaration name="decExponent" type="int" line="36"/>
            <declaration name="decExponentRounded" type="int" line="37"/>
            <declaration name="digits" type="char" line="38"/>
            <declaration name="nDigits" type="int" line="39"/>
            <declaration name="bigIntExp" type="int" line="40"/>
            <declaration name="bigIntNBits" type="int" line="41"/>
            <declaration name="mustSetRoundDir" type="boolean" line="42"/>
            <declaration name="fromHex" type="boolean" line="43"/>
            <declaration name="roundDir" type="int" line="44"/>
            <declaration name="precision" type="int" line="45"/>
            <declaration name="form" type="Form" line="49"/>
            <method name="FormattedFloatingDecimal" type="constructor" line="52">
                <params>
                    <param name="negSign" type="boolean"/>
                    <param name="decExponent" type="int"/>
                    <param name="digits" type="char[]"/>
                    <param name="n" type="int"/>
                    <param name="e" type="boolean"/>
                    <param name="precision" type="int"/>
                    <param name="form" type="Form"/>
                </params>
            </method>
            <declaration name="signMask" type="long" line="67"/>
            <declaration name="expMask" type="long" line="68"/>
            <declaration name="fractMask" type="long" line="69"/>
            <declaration name="expShift" type="int" line="70"/>
            <declaration name="expBias" type="int" line="71"/>
            <declaration name="fractHOB" type="long" line="72"/>
            <declaration name="expOne" type="long" line="73"/>
            <declaration name="maxSmallBinExp" type="int" line="74"/>
            <declaration name="minSmallBinExp" type="int" line="75"/>
            <declaration name="maxDecimalDigits" type="int" line="76"/>
            <declaration name="maxDecimalExponent" type="int" line="77"/>
            <declaration name="minDecimalExponent" type="int" line="78"/>
            <declaration name="bigDecimalExponent" type="int" line="79"/>
            <declaration name="highbyte" type="long" line="81"/>
            <declaration name="highbit" type="long" line="82"/>
            <declaration name="lowbytes" type="long" line="83"/>
            <declaration name="singleSignMask" type="int" line="85"/>
            <declaration name="singleExpMask" type="int" line="86"/>
            <declaration name="singleFractMask" type="int" line="87"/>
            <declaration name="singleExpShift" type="int" line="88"/>
            <declaration name="singleFractHOB" type="int" line="89"/>
            <declaration name="singleExpBias" type="int" line="90"/>
            <declaration name="singleMaxDecimalDigits" type="int" line="91"/>
            <declaration name="singleMaxDecimalExponent" type="int" line="92"/>
            <declaration name="singleMinDecimalExponent" type="int" line="93"/>
            <declaration name="intDecimalDigits" type="int" line="95"/>
            <method name="countBits" type="int" line="103">
                <params>
                    <param name="v" type="long"/>
                </params>
                <comment line="104">
                                        
                </comment>
                <comment line="105">
                    the strategy is to shift until we get a non-zero sign bit                    
                </comment>
                <comment line="106">
                    then shift until we have no bits left, counting the difference.                    
                </comment>
                <comment line="107">
                    we do byte shifting as a hack. Hope it helps.                    
                </comment>
                <comment line="108">
                                        
                </comment>
                <comment line="114">
                    i.e. while ((v&amp;highbit) == 0L )                    
                </comment>
                <scope line="111"/>
                <scope line="114"/>
                <declaration name="n" type="int" line="118"/>
                <scope line="119"/>
                <scope line="123"/>
            </method>
            <declaration name="b5p" type="FDBigInt" line="133"/>
            <method name="big5pow" type="FDBigInt" line="136">
                <params>
                    <param name="p" type="int"/>
                </params>
                <comment line="137">
                    negative power of 5                    
                </comment>
                <comment line="152">
                    construct the value.                    
                </comment>
                <comment line="153">
                    recursively.                    
                </comment>
                <comment line="155">
                    in order to compute 5^p,                    
                </comment>
                <comment line="156">
                    compute its square root, 5^(p/2) and square.                    
                </comment>
                <comment line="157">
                    or, let q = p / 2, r = p -q, then                    
                </comment>
                <comment line="158">
                    5^p = 5^(q+r) = 5^q * 5^r                    
                </comment>
                <scope line="138"/>
                <scope line="140">
                    <declaration name="t" type="FDBigInt" line="141"/>
                </scope>
                <scope line="151">
                    <declaration name="q" type="int" line="154"/>
                    <declaration name="bigq" type="FDBigInt" line="161"/>
                    <scope line="164"/>
                    <scope line="166">
                        <declaration name="bigr" type="FDBigInt" line="167"/>
                    </scope>
                </scope>
            </method>
            <method name="multPow52" type="FDBigInt" line="179">
                <params>
                    <param name="v" type="FDBigInt"/>
                    <param name="p5" type="int"/>
                    <param name="p2" type="int"/>
                </params>
                <scope line="180">
                    <scope line="181"/>
                    <scope line="183"/>
                </scope>
                <scope line="187"/>
            </method>
            <method name="constructPow52" type="FDBigInt" line="197">
                <params>
                    <param name="p5" type="int"/>
                    <param name="p2" type="int"/>
                </params>
                <declaration name="v" type="FDBigInt" line="198"/>
                <scope line="199"/>
            </method>
            <method name="doubleToBigInt" type="FDBigInt" line="216">
                <params>
                    <param name="dval" type="double"/>
                </params>
                <comment line="223">
                    doubleToBigInt(0.0)                    
                </comment>
                <comment line="232">
                    We now know where the high-order 1 bit is,
                     and we know how many there are.                    
                </comment>
                <declaration name="lbits" type="long" line="217"/>
                <declaration name="binexp" type="int" line="218"/>
                <scope line="220"/>
                <scope line="222">
                    <scope line="225"/>
                </scope>
                <declaration name="nbits" type="int" line="231"/>
                <declaration name="lowOrderZeros" type="int" line="236"/>
            </method>
            <method name="ulp" type="double" line="250">
                <params>
                    <param name="dval" type="double"/>
                    <param name="subtracting" type="boolean"/>
                </params>
                <comment line="255">
                    for subtraction from normalized, powers of 2,                    
                </comment>
                <comment line="256">
                    use next-smaller exponent                    
                </comment>
                <declaration name="lbits" type="long" line="251"/>
                <declaration name="binexp" type="int" line="252"/>
                <declaration name="ulpval" type="double" line="253"/>
                <scope line="254"/>
                <scope line="259"/>
                <scope line="261"/>
                <scope line="263"/>
            </method>
            <method name="stickyRound" type="float" line="281">
                <params>
                    <param name="dval" type="double"/>
                </params>
                <comment line="285">
                    what we have here is special.                    
                </comment>
                <comment line="286">
                    don&apos;t worry, the right thing will happen.                    
                </comment>
                <comment line="289">
                    hack-o-matic.                    
                </comment>
                <declaration name="lbits" type="long" line="282"/>
                <declaration name="binexp" type="long" line="283"/>
                <scope line="284"/>
            </method>
            <method name="developLongDigits" type="void" line="310">
                <params>
                    <param name="decExponent" type="int"/>
                    <param name="lvalue" type="long"/>
                    <param name="insignificant" type="long"/>
                </params>
                <comment line="315">
                                        
                </comment>
                <comment line="316">
                    Discard non-significant low-order bits, while rounding,                    
                </comment>
                <comment line="317">
                    up to insignificant value.                    
                </comment>
                <comment line="322">
                    10^i == 5^i * 2^i;                    
                </comment>
                <comment line="327">
                    round up based on the low-order bits we&apos;re discarding                    
                </comment>
                <comment line="332">
                    lvalue &lt;= 0                    
                </comment>
                <comment line="333">
                    even easier subcase!                    
                </comment>
                <comment line="334">
                    can do int arithmetic rather than long!                    
                </comment>
                <comment line="354">
                    same algorithm as above (same bugs, too )                    
                </comment>
                <comment line="355">
                    but using long arithmetic.                    
                </comment>
                <declaration name="digits" type="char" line="311"/>
                <declaration name="ndigits" type="int" line="312"/>
                <declaration name="digitno" type="int" line="313"/>
                <declaration name="c" type="int" line="314"/>
                <declaration name="i" type="int" line="318"/>
                <scope line="321">
                    <declaration name="pow10" type="long" line="322"/>
                    <declaration name="residue" type="long" line="323"/>
                    <scope line="326"/>
                </scope>
                <scope line="331">
                    <declaration name="ivalue" type="int" line="335"/>
                    <scope line="341"/>
                    <scope line="346"/>
                </scope>
                <scope line="353">
                    <scope line="361"/>
                    <scope line="366"/>
                </scope>
                <declaration name="result" type="char" line="374"/>
            </method>
            <method name="roundup" type="void" line="391">
                <comment line="400">
                    carryout! High-order 1, rest 0s, larger exp.                    
                </comment>
                <comment line="405">
                    else fall through.                    
                </comment>
                <declaration name="i" type="int" line="392"/>
                <declaration name="q" type="int" line="393"/>
                <scope line="394">
                    <scope line="395"/>
                    <scope line="399"/>
                </scope>
            </method>
            <method name="checkExponent" type="int" line="411">
                <params>
                    <param name="length" type="int"/>
                </params>
                <comment line="417">
                    a &apos;9&apos; anywhere in digits will absorb the round                    
                </comment>
            </method>
            <method name="applyPrecision" type="char[]" line="424">
                <params>
                    <param name="length" type="int"/>
                </params>
                <comment line="429">
                    no rounding necessary                    
                </comment>
                <comment line="434">
                    only one digit (0 or 1) is returned because the precision                    
                </comment>
                <comment line="435">
                    excludes all significant digits                    
                </comment>
                <comment line="451">
                    carryout! High-order 1, rest 0s, larger exp.                    
                </comment>
                <declaration name="result" type="char[]" line="425"/>
                <scope line="428"/>
                <scope line="433">
                    <scope line="436"/>
                </scope>
                <declaration name="i" type="int" line="442"/>
                <declaration name="q" type="int" line="443"/>
                <scope line="444">
                    <scope line="446">
                        <scope line="447"/>
                        <scope line="450"/>
                    </scope>
                </scope>
                <scope line="458"/>
            </method>
            <method name="FormattedFloatingDecimal" type="constructor" line="468">
                <params>
                    <param name="d" type="double"/>
                </params>
            </method>
            <method name="FormattedFloatingDecimal" type="constructor" line="473">
                <params>
                    <param name="d" type="double"/>
                    <param name="precision" type="int"/>
                    <param name="form" type="Form"/>
                </params>
                <comment line="482">
                    discover and delete sign                    
                </comment>
                <comment line="489">
                    Begin to unpack                    
                </comment>
                <comment line="490">
                    Discover obvious special cases of NaN and Infinity.                    
                </comment>
                <comment line="499">
                    NaN has no sign!                    
                </comment>
                <comment line="505">
                    Finish unpacking                    
                </comment>
                <comment line="506">
                    Normalize denormalized numbers.                    
                </comment>
                <comment line="507">
                    Insert assumed high-order bit for normalized numbers.                    
                </comment>
                <comment line="508">
                    Subtract exponent bias.                    
                </comment>
                <comment line="511">
                    not a denorm, just a 0!                    
                </comment>
                <comment line="521">
                    recall binExp is  - shift count.                    
                </comment>
                <comment line="528">
                    call the routine that actually does all the hard work.                    
                </comment>
                <declaration name="dBits" type="long" line="474"/>
                <declaration name="fractBits" type="long" line="475"/>
                <declaration name="binExp" type="int" line="476"/>
                <declaration name="nSignificantBits" type="int" line="477"/>
                <scope line="483"/>
                <scope line="486"/>
                <scope line="493">
                    <scope line="495"/>
                    <scope line="497"/>
                </scope>
                <scope line="509">
                    <scope line="510"/>
                    <scope line="517"/>
                </scope>
                <scope line="523"/>
            </method>
            <method name="FormattedFloatingDecimal" type="constructor" line="536">
                <params>
                    <param name="f" type="float"/>
                </params>
            </method>
            <method name="FormattedFloatingDecimal" type="constructor" line="540">
                <params>
                    <param name="f" type="float"/>
                    <param name="precision" type="int"/>
                    <param name="form" type="Form"/>
                </params>
                <comment line="549">
                    discover and delete sign                    
                </comment>
                <comment line="556">
                    Begin to unpack                    
                </comment>
                <comment line="557">
                    Discover obvious special cases of NaN and Infinity.                    
                </comment>
                <comment line="566">
                    NaN has no sign!                    
                </comment>
                <comment line="572">
                    Finish unpacking                    
                </comment>
                <comment line="573">
                    Normalize denormalized numbers.                    
                </comment>
                <comment line="574">
                    Insert assumed high-order bit for normalized numbers.                    
                </comment>
                <comment line="575">
                    Subtract exponent bias.                    
                </comment>
                <comment line="578">
                    not a denorm, just a 0!                    
                </comment>
                <comment line="588">
                    recall binExp is  - shift count.                    
                </comment>
                <comment line="595">
                    call the routine that actually does all the hard work.                    
                </comment>
                <declaration name="fBits" type="int" line="541"/>
                <declaration name="fractBits" type="int" line="542"/>
                <declaration name="binExp" type="int" line="543"/>
                <declaration name="nSignificantBits" type="int" line="544"/>
                <scope line="550"/>
                <scope line="553"/>
                <scope line="560">
                    <scope line="562"/>
                    <scope line="564"/>
                </scope>
                <scope line="576">
                    <scope line="577"/>
                    <scope line="584"/>
                </scope>
                <scope line="590"/>
            </method>
            <method name="dtoa" type="void" line="601">
                <params>
                    <param name="binExp" type="int"/>
                    <param name="fractBits" type="long"/>
                    <param name="nSignificantBits" type="int"/>
                </params>
                <comment line="602">
                    number of significant bits of fractBits;                    
                </comment>
                <comment line="603">
                    number of these to the right of the point.                    
                </comment>
                <comment line="606">
                    Examine number. Determine if it is an easy case,                    
                </comment>
                <comment line="607">
                    which we can do pretty trivially using float/long conversion,                    
                </comment>
                <comment line="608">
                    or whether we must do real work.                    
                </comment>
                <comment line="612">
                    Look more closely at the number to decide if,                    
                </comment>
                <comment line="613">
                    with scaling by 10^nTinyBits, the result will fit in                    
                </comment>
                <comment line="614">
                    a long.                    
                </comment>
                <comment line="616">
                    We can do this:
                     take the fraction bits, which are normalized.
                     (a) nTinyBits == 0: Shift left or right appropriately
                         to align the binary point at the extreme right, i.e.
                         where a long int point is expected to be. The integer
                         result is easily converted to a string.
                     (b) nTinyBits &gt; 0: Shift right by expShift-nFractBits,
                         which effectively converts to long and scales by
                         2^nTinyBits. Then multiply by 5^nTinyBits to
                         complete the scaling. We know this won&apos;t overflow
                         because we just counted the number of bits necessary
                         in the result. The integer you get from this can
                         then be converted to a string pretty easily.                    
                </comment>
                <comment line="646">
                    The following causes excess digits to be printed
                     out in the single-float case. Our manipulation of
                     halfULP here is apparently not correct. If we
                     better understand how this works, perhaps we can
                     use this special case again. But for the time being,
                     we do not.
                     else {
                         fractBits &gt;&gt;&gt;= expShift+1-nFractBits;
                         fractBits = long5pow[ nTinyBits ];
                         halfULP = long5pow[ nTinyBits ] &gt;&gt; (1+nSignificantBits-nFractBits);
                         developLongDigits( -nTinyBits, fractBits, halfULP );
                         return;
                     }                    
                </comment>
                <comment line="663">
                    This is the hard case. We are going to compute large positive
                     integers B and S and integer decExp, s.t.
                          d = ( B  S )  10^decExp
                          1 &lt;= B  S &lt; 10
                     Obvious choices are:
                          decExp = floor( log10(d) )
                          B      = d  2^nTinyBits  10^max( 0, -decExp )
                          S      = 10^max( 0, decExp)  2^nTinyBits
                     (noting that nTinyBits has already been forced to non-negative)
                     I am also going to compute a large positive integer
                          M      = (12^nSignificantBits)  2^nTinyBits  10^max( 0, -decExp )
                     i.e. M is (12) of the ULP of d, scaled like B.
                     When we iterate through dividing BS and picking off the
                     quotient bits, we will know when to stop when the remainder
                     is &lt;= M.
                    
                     We keep track of powers of 2 and powers of 5.                    
                </comment>
                <comment line="683">
                    Estimate decimal exponent. (If it is small-ish,
                     we could double-check.)
                    
                     First, scale the mantissa bits such that 1 &lt;= d2 &lt; 2.
                     We are then going to estimate
                              log10(d2) ~=~  (d2-1.5)1.5 + log(1.5)
                     and so we can estimate
                          log10(d) ~=~ log10(d2) + binExp  log10(2)
                     take the floor and call it decExp.
                     FIXME -- use more precise constants here. It costs no more.                    
                </comment>
                <comment line="699">
                    powers of 2 and powers of 5, respectively, in B                    
                </comment>
                <comment line="700">
                    powers of 2 and powers of 5, respectively, in S                    
                </comment>
                <comment line="701">
                    powers of 2 and powers of 5, respectively, in M                    
                </comment>
                <comment line="702">
                    binary digits needed to represent B, approx.                    
                </comment>
                <comment line="703">
                    binary digits needed to represent 10*S, approx.                    
                </comment>
                <comment line="715">
                    the long integer fractBits contains the (nFractBits) interesting
                     bits from the mantissa of d ( hidden 1 added if necessary) followed
                     by (expShift+1-nFractBits) zeros. In the interest of compactness,
                     I will shift out those zeros before turning fractBits into a
                     FDBigInt. The resulting whole number will be
                          d  2^(nFractBits-1-binExp).                    
                </comment>
                <comment line="730">
                    HACK!! For exact powers of two, the next smallest number
                     is only half as far away as we think (because the meaning of
                     ULP changes at power-of-two bounds) for this reason, we
                     hack M2. Hope this works.                    
                </comment>
                <comment line="740">
                    oops.                    
                </comment>
                <comment line="741">
                    since we cannot scale M down far enough,                    
                </comment>
                <comment line="742">
                    we must scale the other values up.                    
                </comment>
                <comment line="747">
                    Construct, Scale, iterate.
                     Some day, we&apos;ll write a stopping test that takes
                     account of the assymetry of the spacing of floating-point
                     numbers below perfect powers of 2
                     26 Sept 96 is not that day.
                     So we use a symmetric test.                    
                </comment>
                <comment line="761">
                    Detect the special cases where all the numbers we are about
                     to compute will fit in int or long integers.
                     In these cases, we will avoid doing FDBigInt arithmetic.
                     We use the same algorithms, except that we &quot;normalize&quot;
                     our FDBigInts before iterating. This is to make division easier,
                     as it makes our fist guess (quotient of high-order words)
                     more accurate!
                    
                     Some day, we&apos;ll write a stopping test that takes
                     account of the assymetry of the spacing of floating-point
                     numbers below perfect powers of 2
                     26 Sept 96 is not that day.
                     So we use a symmetric test.                    
                </comment>
                <comment line="780">
                    wa-hoo! They&apos;re all ints!                    
                </comment>
                <comment line="785">
                    Unroll the first iteration. If our decExp estimate
                     was too high, our first quotient will be zero. In this
                     case, we discard it and decrement decExp.                    
                </comment>
                <comment line="796">
                    excessively large digit                    
                </comment>
                <comment line="798">
                    oops. Usually ignore leading zero.                    
                </comment>
                <comment line="803">
                    HACK! Java spec sez that we always have at least
                     one digit after the . in either F- or E-form output.
                     Thus we will need more than one digit if we&apos;re using
                     E-form                    
                </comment>
                <comment line="816">
                    excessively large digit                    
                </comment>
                <comment line="821">
                    hack -- m might overflow!                    
                </comment>
                <comment line="822">
                    in this case, it is certainly &gt; b,                    
                </comment>
                <comment line="823">
                    which won&apos;t                    
                </comment>
                <comment line="824">
                    and b+m &gt; tens, too, since that has overflowed                    
                </comment>
                <comment line="825">
                    either!                    
                </comment>
                <comment line="833">
                    still good! they&apos;re all longs!                    
                </comment>
                <comment line="838">
                    Unroll the first iteration. If our decExp estimate
                     was too high, our first quotient will be zero. In this
                     case, we discard it and decrement decExp.                    
                </comment>
                <comment line="849">
                    excessively large digit                    
                </comment>
                <comment line="851">
                    oops. Usually ignore leading zero.                    
                </comment>
                <comment line="856">
                    HACK! Java spec sez that we always have at least
                     one digit after the . in either F- or E-form output.
                     Thus we will need more than one digit if we&apos;re using
                     E-form                    
                </comment>
                <comment line="869">
                    excessively large digit                    
                </comment>
                <comment line="874">
                    hack -- m might overflow!                    
                </comment>
                <comment line="875">
                    in this case, it is certainly &gt; b,                    
                </comment>
                <comment line="876">
                    which won&apos;t                    
                </comment>
                <comment line="877">
                    and b+m &gt; tens, too, since that has overflowed                    
                </comment>
                <comment line="878">
                    either!                    
                </comment>
                <comment line="890">
                    We really must do FDBigInt arithmetic.
                     Fist, construct our FDBigInt initial values.                    
                </comment>
                <comment line="899">
                    normalize so that division works better                    
                </comment>
                <comment line="903">
                    Unroll the first iteration. If our decExp estimate
                     was too high, our first quotient will be zero. In this
                     case, we discard it and decrement decExp.                    
                </comment>
                <comment line="913">
                    excessively large digit                    
                </comment>
                <comment line="915">
                    oops. Usually ignore leading zero.                    
                </comment>
                <comment line="920">
                    HACK! Java spec sez that we always have at least
                     one digit after the . in either F- or E-form output.
                     Thus we will need more than one digit if we&apos;re using
                     E-form                    
                </comment>
                <comment line="932">
                    excessively large digit                    
                </comment>
                <comment line="941">
                    this here only for flow analysis!                    
                </comment>
                <comment line="946">
                    Last digit gets rounded based on stopping condition.                    
                </comment>
                <comment line="952">
                    it&apos;s a tie!                    
                </comment>
                <comment line="953">
                    choose based on which digits we like.                    
                </comment>
                <declaration name="nFractBits" type="int" line="602"/>
                <declaration name="nTinyBits" type="int" line="603"/>
                <declaration name="decExp" type="int" line="604"/>
                <scope line="611">
                    <scope line="615">
                        <declaration name="halfULP" type="long" line="631"/>
                        <scope line="632">
                            <scope line="633"/>
                            <scope line="635"/>
                            <scope line="638"/>
                            <scope line="640"/>
                        </scope>
                    </scope>
                </scope>
                <declaration name="d2" type="double" line="695"/>
                <declaration name="B2" type="int" line="699"/>
                <declaration name="S2" type="int" line="700"/>
                <declaration name="M2" type="int" line="701"/>
                <declaration name="Bbits" type="int" line="702"/>
                <declaration name="tenSbits" type="int" line="703"/>
                <declaration name="Sval" type="FDBigInt" line="704"/>
                <declaration name="common2factor" type="int" line="725"/>
                <scope line="739"/>
                <declaration name="digits" type="char" line="755"/>
                <declaration name="ndigit" type="int" line="756"/>
                <declaration name="low" type="boolean" line="757"/>
                <declaration name="lowDigitDifference" type="long" line="758"/>
                <declaration name="q" type="int" line="759"/>
                <scope line="778">
                    <scope line="779">
                        <declaration name="b" type="int" line="781"/>
                        <declaration name="s" type="int" line="782"/>
                        <declaration name="m" type="int" line="783"/>
                        <declaration name="tens" type="int" line="784"/>
                        <scope line="797"/>
                        <scope line="800"/>
                        <scope line="809"/>
                        <scope line="812">
                            <scope line="817"/>
                            <scope line="820"/>
                        </scope>
                    </scope>
                    <scope line="832">
                        <declaration name="b" type="long" line="834"/>
                        <declaration name="s" type="long" line="835"/>
                        <declaration name="m" type="long" line="836"/>
                        <declaration name="tens" type="long" line="837"/>
                        <scope line="850"/>
                        <scope line="853"/>
                        <scope line="862"/>
                        <scope line="865">
                            <scope line="870"/>
                            <scope line="873"/>
                        </scope>
                    </scope>
                </scope>
                <scope line="886">
                    <declaration name="tenSval" type="FDBigInt" line="887"/>
                    <declaration name="shiftBias" type="int" line="888"/>
                    <scope line="914"/>
                    <scope line="917"/>
                    <scope line="926"/>
                    <scope line="929"/>
                    <scope line="937"/>
                </scope>
                <scope line="949">
                    <scope line="950">
                        <scope line="951"/>
                        <scope line="955"/>
                    </scope>
                    <scope line="958"/>
                </scope>
            </method>
            <method name="toString" type="String" line="965">
                <comment line="966">
                    most brain-dead version                    
                </comment>
                <declaration name="result" type="StringBuffer" line="967"/>
                <scope line="968"/>
                <scope line="969"/>
                <scope line="971"/>
            </method>
            <method name="getExponent" type="int" line="981"/>
            <method name="getExponentRounded" type="int" line="986"/>
            <method name="getChars" type="int" line="990">
                <params>
                    <param name="result" type="char[]"/>
                </params>
                <comment line="991">
                    generous bound on size of nDigits                    
                </comment>
                <comment line="1014">
                    adjust precision to be the number of digits to right of decimal                    
                </comment>
                <comment line="1015">
                    the real exponent to be output is actually exp - 1, not exp                    
                </comment>
                <comment line="1033">
                    print digits.digits.                    
                </comment>
                <comment line="1041">
                    Do not append &quot;.0&quot; for formatted floats since the user                    
                </comment>
                <comment line="1042">
                    may request that it be omitted. It is added as necessary                    
                </comment>
                <comment line="1043">
                    by the Formatter.                    
                </comment>
                <comment line="1049">
                    Do not append &quot;.0&quot; for formatted floats since the user                    
                </comment>
                <comment line="1050">
                    may request that it be omitted. It is added as necessary                    
                </comment>
                <comment line="1051">
                    by the Formatter.                    
                </comment>
                <comment line="1074">
                    print 0.0* digits                    
                </comment>
                <comment line="1077">
                    write &apos;0&apos; s before the significant digits                    
                </comment>
                <comment line="1089">
                    copy only when significant digits are within the precision                    
                </comment>
                <comment line="1124">
                    decExponent has 1, 2, or 3, digits                    
                </comment>
                <declaration name="i" type="int" line="992"/>
                <scope line="993"/>
                <scope line="994"/>
                <scope line="997">
                    <declaration name="digits" type="char" line="998"/>
                    <declaration name="exp" type="int" line="999"/>
                    <scope line="1016"/>
                    <scope line="1019"/>
                    <scope line="1032">
                        <declaration name="charLength" type="int" line="1034"/>
                        <scope line="1037">
                            <scope line="1044"/>
                        </scope>
                        <scope line="1048">
                            <scope line="1052">
                                <scope line="1054">
                                    <declaration name="t" type="int" line="1055"/>
                                </scope>
                                <scope line="1058"/>
                            </scope>
                            <scope line="1061">
                                <declaration name="t" type="int" line="1062"/>
                                <scope line="1063"/>
                            </scope>
                        </scope>
                    </scope>
                    <scope line="1073">
                        <scope line="1076">
                            <declaration name="t" type="int" line="1078"/>
                            <scope line="1079"/>
                        </scope>
                        <declaration name="t" type="int" line="1085"/>
                        <scope line="1086"/>
                    </scope>
                    <scope line="1093">
                        <scope line="1095">
                            <scope line="1097"/>
                            <scope line="1100"/>
                        </scope>
                        <scope line="1104">
                            <scope line="1105">
                                <declaration name="t" type="int" line="1106"/>
                                <scope line="1107"/>
                            </scope>
                        </scope>
                        <declaration name="e" type="int" line="1115"/>
                        <scope line="1116"/>
                        <scope line="1119"/>
                        <scope line="1125"/>
                        <scope line="1129"/>
                        <scope line="1132"/>
                    </scope>
                </scope>
            </method>
            <declaration name="perThreadBuffer" type="ThreadLocal" line="1144"/>
            <anonymous_class line="1144">
                <method name="initialValue" type="Object" line="1145"/>
            </anonymous_class>
            <method name="doubleValue" type="double" line="1159">
                <comment line="1165">
                    First, check for NaN and Infinity values                    
                </comment>
                <comment line="1176">
                    convert the lead kDigits to a long integer.                    
                </comment>
                <comment line="1179">
                    (special performance hack: start to do it using int)                    
                </comment>
                <comment line="1191">
                    lValue now contains a long integer with the value of
                     the first kDigits digits of the number.
                     dValue contains the (double) of the same.                    
                </comment>
                <comment line="1198">
                    possibly an easy case.
                     We know that the digits can be represented
                     exactly. And if the exponent isn&apos;t too outrageous,
                     the whole thing can be done with one operation,
                     thus one rounding error.
                     Note that all our constructors trim all leading and
                     trailing zeros, so simple values (including zero)
                     will always end up here                    
                </comment>
                <comment line="1209">
                    small floating integer                    
                </comment>
                <comment line="1212">
                    Can get the answer with one operation,
                     thus one roundoff.                    
                </comment>
                <comment line="1227">
                    We can multiply dValue by 10^(slop)
                     and it is still &quot;small&quot; and exact.
                     Then we can multiply by 10^(exp-slop)
                     with one rounding.                    
                </comment>
                <comment line="1244">
                    Else we have a hard case with a positive exp.                    
                </comment>
                <comment line="1249">
                    Can get the answer in one division.                    
                </comment>
                <comment line="1261">
                    Else we have a hard case with a negative exp.                    
                </comment>
                <comment line="1267">
                    Harder cases:
                     The sum of digits plus exponent is greater than
                     what we think we can do with one error.
                    
                     Start by approximating the right answer by,
                     naively, scaling by powers of 10.                    
                </comment>
                <comment line="1277">
                    Lets face it. This is going to be
                     Infinity. Cut to the chase.                    
                </comment>
                <comment line="1292">
                    The reason for the weird exp &gt; 1 condition
                     in the above loop was so that the last multiply
                     would get unrolled. We handle it here.
                     It could overflow.                    
                </comment>
                <comment line="1300">
                    It did overflow.
                     Look more closely at the result.
                     If the exponent is just one too large,
                     then use the maximum finite as our estimate
                     value. Else call the result infinity
                     and punt it.
                     ( I presume this could happen because
                     rounding forces the result here to be
                     an ULP or two larger than
                     Double.MAX_VALUE ).                    
                </comment>
                <comment line="1324">
                    Lets face it. This is going to be
                     zero. Cut to the chase.                    
                </comment>
                <comment line="1339">
                    The reason for the weird exp &gt; 1 condition
                     in the above loop was so that the last multiply
                     would get unrolled. We handle it here.
                     It could underflow.                    
                </comment>
                <comment line="1347">
                    It did underflow.
                     Look more closely at the result.
                     If the exponent is just one too small,
                     then use the minimum finite as our estimate
                     value. Else call the result 0.0
                     and punt it.
                     ( I presume this could happen because
                     rounding forces the result here to be
                     an ULP or two less than
                     Double.MIN_VALUE ).                    
                </comment>
                <comment line="1370">
                    dValue is now approximately the result.
                     The hard part is adjusting it, by comparison
                     with FDBigInt arithmetic.
                     Formulate the EXACT big-number result as
                     bigD0  10^exp                    
                </comment>
                <comment line="1382">
                    AS A SIDE EFFECT, THIS METHOD WILL SET THE INSTANCE VARIABLES
                     bigIntExp and bigIntNBits                    
                </comment>
                <comment line="1387">
                    Scale bigD, bigB appropriately for
                     big-integer operations.
                     Naively, we multipy by powers of ten
                     and powers of two. What we actually do
                     is keep track of the powers of 5 and
                     powers of 2 we would use, then factor out
                     common divisors before doing the work.                    
                </comment>
                <comment line="1396">
                    powers of 2, 5 in bigB                    
                </comment>
                <comment line="1397">
                    powers of 2, 5 in bigD                    
                </comment>
                <comment line="1398">
                    powers of 2 in halfUlp.                    
                </comment>
                <comment line="1412">
                    shift bigB and bigD left by a number s. t.                    
                </comment>
                <comment line="1413">
                    halfUlp is still an integer.                    
                </comment>
                <comment line="1416">
                    This is going to be a denormalized number                    
                </comment>
                <comment line="1417">
                    (if not actually zero).                    
                </comment>
                <comment line="1418">
                    half an ULP is at 2^-(expBias+expShift+1)                    
                </comment>
                <comment line="1425">
                    if there are common factors of 2, we might just as well                    
                </comment>
                <comment line="1426">
                    factor them out, as they add nothing useful.                    
                </comment>
                <comment line="1431">
                    do multiplications by powers of 5 and 2                    
                </comment>
                <comment line="1434">
                                        
                </comment>
                <comment line="1435">
                    to recap:                    
                </comment>
                <comment line="1436">
                    bigB is the scaled-big-int version of our floating-point                    
                </comment>
                <comment line="1437">
                    candidate.                    
                </comment>
                <comment line="1438">
                    bigD is the scaled-big-int version of the exact value                    
                </comment>
                <comment line="1439">
                    as we understand it.                    
                </comment>
                <comment line="1440">
                    halfUlp is 1/2 an ulp of bigB, except for special cases                    
                </comment>
                <comment line="1441">
                    of exact powers of 2                    
                </comment>
                <comment line="1442">
                                        
                </comment>
                <comment line="1443">
                    the plan is to compare bigB with bigD, and if the difference                    
                </comment>
                <comment line="1444">
                    is less than halfUlp, then we&apos;re satisfied. Otherwise,                    
                </comment>
                <comment line="1445">
                    use the ratio of difference to halfUlp to calculate a fudge                    
                </comment>
                <comment line="1446">
                    factor to add to the floating value, then go &apos;round again.                    
                </comment>
                <comment line="1447">
                                        
                </comment>
                <comment line="1452">
                    our candidate is too big.                    
                </comment>
                <comment line="1455">
                    candidate is a normalized exact power of 2 and                    
                </comment>
                <comment line="1456">
                    is too big. We will be subtracting.                    
                </comment>
                <comment line="1457">
                    For our purposes, ulp is the ulp of the                    
                </comment>
                <comment line="1458">
                    next smaller range.                    
                </comment>
                <comment line="1461">
                    rats. Cannot de-scale ulp this far.                    
                </comment>
                <comment line="1462">
                    must scale diff in other direction.                    
                </comment>
                <comment line="1468">
                    our candidate is too small.                    
                </comment>
                <comment line="1471">
                    the candidate is exactly right!                    
                </comment>
                <comment line="1472">
                    this happens with surprising fequency                    
                </comment>
                <comment line="1477">
                    difference is small.                    
                </comment>
                <comment line="1478">
                    this is close enough                    
                </comment>
                <comment line="1484">
                    difference is exactly half an ULP                    
                </comment>
                <comment line="1485">
                    round to some other value maybe, then finish                    
                </comment>
                <comment line="1487">
                    should check for bigIntNBits == 1 here??                    
                </comment>
                <comment line="1493">
                    difference is non-trivial.                    
                </comment>
                <comment line="1494">
                    could scale addend by ratio of difference to                    
                </comment>
                <comment line="1495">
                    halfUlp here, if we bothered to compute that difference.                    
                </comment>
                <comment line="1496">
                    Most of the time ( I hope ) it is about 1 anyway.                    
                </comment>
                <comment line="1499">
                    oops. Fell off end of range.                    
                </comment>
                <comment line="1500">
                    try again.                    
                </comment>
                <declaration name="kDigits" type="int" line="1160"/>
                <declaration name="lValue" type="long" line="1161"/>
                <declaration name="dValue" type="double" line="1162"/>
                <declaration name="rValue" type="double" line="1163"/>
                <scope line="1166"/>
                <scope line="1172">
                    <scope line="1173"/>
                    <declaration name="iValue" type="int" line="1180"/>
                    <declaration name="iDigits" type="int" line="1181"/>
                    <scope line="1182"/>
                    <scope line="1186"/>
                    <declaration name="exp" type="int" line="1190"/>
                    <scope line="1197">
                        <scope line="1210">
                            <scope line="1211">
                                <scope line="1217"/>
                            </scope>
                            <declaration name="slop" type="int" line="1225"/>
                            <scope line="1226">
                                <scope line="1236"/>
                            </scope>
                        </scope>
                        <scope line="1247">
                            <scope line="1248">
                                <scope line="1254"/>
                            </scope>
                        </scope>
                    </scope>
                    <scope line="1275">
                        <scope line="1276"/>
                        <scope line="1283"/>
                        <scope line="1286">
                            <declaration name="j" type="int" line="1287"/>
                            <scope line="1288"/>
                            <declaration name="t" type="double" line="1298"/>
                            <scope line="1299">
                                <scope line="1314"/>
                            </scope>
                        </scope>
                    </scope>
                    <scope line="1321">
                        <scope line="1323"/>
                        <scope line="1330"/>
                        <scope line="1333">
                            <declaration name="j" type="int" line="1334"/>
                            <scope line="1335"/>
                            <declaration name="t" type="double" line="1345"/>
                            <scope line="1346">
                                <scope line="1361"/>
                            </scope>
                        </scope>
                    </scope>
                    <declaration name="bigD0" type="FDBigInt" line="1377"/>
                    <scope line="1381">
                        <declaration name="bigB" type="FDBigInt" line="1385"/>
                        <declaration name="B2" type="int" line="1396"/>
                        <declaration name="D2" type="int" line="1397"/>
                        <declaration name="Ulp2" type="int" line="1398"/>
                        <scope line="1399"/>
                        <scope line="1402"/>
                        <scope line="1406"/>
                        <scope line="1408"/>
                        <declaration name="hulpbias" type="int" line="1414"/>
                        <scope line="1415"/>
                        <scope line="1420"/>
                        <declaration name="common2" type="int" line="1427"/>
                        <declaration name="bigD" type="FDBigInt" line="1433"/>
                        <declaration name="diff" type="FDBigInt" line="1448"/>
                        <declaration name="cmpResult" type="int" line="1449"/>
                        <declaration name="overvalue" type="boolean" line="1450"/>
                        <scope line="1451">
                            <scope line="1454">
                                <scope line="1460"/>
                            </scope>
                        </scope>
                        <scope line="1467"/>
                        <scope line="1470"/>
                        <declaration name="halfUlp" type="FDBigInt" line="1475"/>
                        <scope line="1476">
                            <scope line="1479"/>
                        </scope>
                        <scope line="1483">
                            <scope line="1488"/>
                        </scope>
                        <scope line="1492"/>
                    </scope>
                </scope>
            </method>
            <method name="floatValue" type="float" line="1518">
                <comment line="1523">
                    First, check for NaN and Infinity values                    
                </comment>
                <comment line="1531">
                    convert the lead kDigits to an integer.                    
                </comment>
                <comment line="1540">
                    iValue now contains an integer with the value of
                     the first kDigits digits of the number.
                     fValue contains the (float) of the same.                    
                </comment>
                <comment line="1547">
                    possibly an easy case.
                     We know that the digits can be represented
                     exactly. And if the exponent isn&apos;t too outrageous,
                     the whole thing can be done with one operation,
                     thus one rounding error.
                     Note that all our constructors trim all leading and
                     trailing zeros, so simple values (including zero)
                     will always end up here.                    
                </comment>
                <comment line="1558">
                    small floating integer                    
                </comment>
                <comment line="1561">
                    Can get the answer with one operation,
                     thus one roundoff.                    
                </comment>
                <comment line="1570">
                    We can multiply dValue by 10^(slop)
                     and it is still &quot;small&quot; and exact.
                     Then we can multiply by 10^(exp-slop)
                     with one rounding.                    
                </comment>
                <comment line="1580">
                    Else we have a hard case with a positive exp.                    
                </comment>
                <comment line="1585">
                    Can get the answer in one division.                    
                </comment>
                <comment line="1591">
                    Else we have a hard case with a negative exp.                    
                </comment>
                <comment line="1596">
                    In double-precision, this is an exact floating integer.
                     So we can compute to double, then shorten to float
                     with one round, and get the right answer.
                    
                     First, finish accumulating digits.
                     Then convert that integer to a double, multiply
                     by the appropriate power of ten, and convert to float.                    
                </comment>
                <comment line="1616">
                    Harder cases:
                     The sum of digits plus exponent is greater than
                     what we think we can do with one error.
                    
                     Start by weeding out obviously out-of-range
                     results, then convert to double and go to
                     common hard-case code.                    
                </comment>
                <comment line="1626">
                    Lets face it. This is going to be
                     Infinity. Cut to the chase.                    
                </comment>
                <comment line="1632">
                    Lets face it. This is going to be
                     zero. Cut to the chase.                    
                </comment>
                <comment line="1639">
                    Here, we do &apos;way too much work, but throwing away
                     our partial results, and going and doing the whole
                     thing as double, then throwing away half the bits that computes
                     when we convert back to float.
                    
                     The alternative is to reproduce the whole multiple-precision
                     algorythm for float precision, or to try to parameterize it
                     for common usage. The former will take about 400 lines of code,
                     and the latter I tried without success. Thus the semi-hack
                     answer here.                    
                </comment>
                <declaration name="kDigits" type="int" line="1519"/>
                <declaration name="iValue" type="int" line="1520"/>
                <declaration name="fValue" type="float" line="1521"/>
                <scope line="1524"/>
                <scope line="1530">
                    <scope line="1535"/>
                    <declaration name="exp" type="int" line="1539"/>
                    <scope line="1546">
                        <scope line="1559">
                            <scope line="1560"/>
                            <declaration name="slop" type="int" line="1568"/>
                            <scope line="1569"/>
                        </scope>
                        <scope line="1583">
                            <scope line="1584"/>
                        </scope>
                    </scope>
                    <scope line="1595">
                        <declaration name="lValue" type="long" line="1605"/>
                        <scope line="1606"/>
                        <declaration name="dValue" type="double" line="1609"/>
                    </scope>
                    <scope line="1625"/>
                    <scope line="1631"/>
                    <declaration name="dValue" type="double" line="1652"/>
                </scope>
            </method>
            <declaration name="small10pow" type="double" line="1662"/>
            <declaration name="singleSmall10pow" type="float" line="1671"/>
            <declaration name="big10pow" type="double" line="1677"/>
            <declaration name="tiny10pow" type="double" line="1679"/>
            <declaration name="maxSmallTen" type="int" line="1682"/>
            <declaration name="singleMaxSmallTen" type="int" line="1683"/>
            <declaration name="small5pow" type="int" line="1685"/>
            <declaration name="long5pow" type="long" line="1703"/>
            <declaration name="n5bits" type="int" line="1734"/>
            <declaration name="infinity" type="char" line="1764"/>
            <declaration name="notANumber" type="char" line="1765"/>
            <declaration name="zero" type="char" line="1766"/>
        </class>
    </source>