<?xml version="1.0" encoding="UTF-8"?>
    <source package="sun.awt.datatransfer">
        <import package="java.awt.AWTError"/>
        <import package="java.awt.EventQueue"/>
        <import package="java.awt.Image"/>
        <import package="java.awt.Graphics"/>
        <import package="java.awt.datatransfer.DataFlavor"/>
        <import package="java.awt.datatransfer.FlavorMap"/>
        <import package="java.awt.datatransfer.FlavorTable"/>
        <import package="java.awt.datatransfer.Transferable"/>
        <import package="java.awt.datatransfer.UnsupportedFlavorException"/>
        <import package="java.io.BufferedReader"/>
        <import package="java.io.ByteArrayInputStream"/>
        <import package="java.io.ByteArrayOutputStream"/>
        <import package="java.io.File"/>
        <import package="java.io.InputStream"/>
        <import package="java.io.InputStreamReader"/>
        <import package="java.io.IOException"/>
        <import package="java.io.ObjectInputStream"/>
        <import package="java.io.ObjectOutputStream"/>
        <import package="java.io.Reader"/>
        <import package="java.io.SequenceInputStream"/>
        <import package="java.io.StringReader"/>
        <import package="java.net.URI"/>
        <import package="java.net.URISyntaxException"/>
        <import package="java.nio.ByteBuffer"/>
        <import package="java.nio.CharBuffer"/>
        <import package="java.nio.charset.Charset"/>
        <import package="java.nio.charset.CharsetEncoder"/>
        <import package="java.nio.charset.IllegalCharsetNameException"/>
        <import package="java.nio.charset.UnsupportedCharsetException"/>
        <import package="java.lang.reflect.Constructor"/>
        <import package="java.lang.reflect.InvocationTargetException"/>
        <import package="java.lang.reflect.Method"/>
        <import package="java.lang.reflect.Modifier"/>
        <import package="java.security.AccessController"/>
        <import package="java.security.PrivilegedAction"/>
        <import package="java.security.PrivilegedActionException"/>
        <import package="java.security.PrivilegedExceptionAction"/>
        <import package="java.security.ProtectionDomain"/>
        <import package="java.util.ArrayList"/>
        <import package="java.util.Arrays"/>
        <import package="java.util.Collections"/>
        <import package="java.util.Comparator"/>
        <import package="java.util.HashMap"/>
        <import package="java.util.HashSet"/>
        <import package="java.util.Iterator"/>
        <import package="java.util.List"/>
        <import package="java.util.Map"/>
        <import package="java.util.SortedMap"/>
        <import package="java.util.SortedSet"/>
        <import package="java.util.Set"/>
        <import package="java.util.Stack"/>
        <import package="java.util.TreeMap"/>
        <import package="java.util.TreeSet"/>
        <import package="sun.util.logging.PlatformLogger"/>
        <import package="sun.awt.AppContext"/>
        <import package="sun.awt.SunToolkit"/>
        <import package="java.awt.image.BufferedImage"/>
        <import package="java.awt.image.ImageObserver"/>
        <import package="java.awt.image.RenderedImage"/>
        <import package="java.awt.image.WritableRaster"/>
        <import package="java.awt.image.ColorModel"/>
        <import package="javax.imageio.ImageIO"/>
        <import package="javax.imageio.ImageReader"/>
        <import package="javax.imageio.ImageReadParam"/>
        <import package="javax.imageio.ImageWriter"/>
        <import package="javax.imageio.ImageTypeSpecifier"/>
        <import package="javax.imageio.spi.ImageWriterSpi"/>
        <import package="javax.imageio.stream.ImageInputStream"/>
        <import package="javax.imageio.stream.ImageOutputStream"/>
        <import package="sun.awt.image.ImageRepresentation"/>
        <import package="sun.awt.image.ToolkitImage"/>
        <import package="java.io.FilePermission"/>
        <class name="DataTransferer" line="74">
            <javadoc line="74">
                Provides a set of functions to be shared among the DataFlavor class and
                  platform-specific data transfer implementations.
                  The concept of &quot;flavors&quot; and &quot;natives&quot; is extended to include &quot;formats&quot;,
                  which are the numeric values Win32 and X11 use to express particular data
                  types. Like FlavorMap, which provides getNativesForFlavors(DataFlavor[]) and
                  getFlavorsForNatives(String[]) functions, DataTransferer provides a set
                  of getFormatsFor(Transferable|Flavor|Flavors) and
                  getFlavorsFor(Format|Formats) functions.
                  Also provided are functions for translating a Transferable into a byte
                  array, given a source DataFlavor and a target format, and for translating
                  a byte array or InputStream into an Object, given a source format and
                  a target DataFlavor.                
                <author>
                    David Mendenhall                    
                </author>
                <author>
                    Danila Sinopalnikov                    
                </author>
                <since>
                    1.3.1                    
                </since>
            </javadoc>
            <declaration name="charArrayClass" type="Class" line="92"/>
            <javadoc line="92">
                Cached value of Class.forName(&quot;[C&quot;);                
            </javadoc>
            <declaration name="byteArrayClass" type="Class" line="96"/>
            <javadoc line="96">
                Cached value of Class.forName(&quot;[B&quot;);                
            </javadoc>
            <declaration name="plainTextStringFlavor" type="DataFlavor" line="100"/>
            <javadoc line="100">
                The &lt;code&gt;DataFlavor&lt;/code&gt; representing plain text with Unicode
                  encoding, where:
                  &lt;pre&gt;
                  representationClass = java.lang.String
                  mimeType            = &quot;text/plain; charset=Unicode&quot;
                  &lt;/pre&gt;                
            </javadoc>
            <declaration name="javaTextEncodingFlavor" type="DataFlavor" line="109"/>
            <javadoc line="109">
                The &lt;code&gt;DataFlavor&lt;/code&gt; representing a Java text encoding String
                  encoded in UTF-8, where
                  &lt;pre&gt;
                  representationClass = [B
                  mimeType            = &quot;application/x-java-text-encoding&quot;
                  &lt;/pre&gt;                
            </javadoc>
            <class name="StandardEncodingsHolder" line="118">
                <javadoc line="118">
                    Lazy initialization of Standard Encodings.                    
                </javadoc>
                <declaration name="standardEncodings" type="SortedSet" line="122"/>
                <method name="load" type="SortedSet" line="123">
                    <declaration name="comparator" type="Comparator" line="124"/>
                    <declaration name="tempSet" type="SortedSet" line="125"/>
                </method>
            </class>
            <declaration name="textMIMESubtypeCharsetSupport" type="Map" line="136"/>
            <javadoc line="136">
                Tracks whether a particular text/ MIME type supports the charset
                  parameter. The Map is initialized with all of the standard MIME types
                  listed in the DataFlavor.selectBestTextFlavor method comment. Additional
                  entries may be added during the life of the JRE for text/&lt;other&gt; types.                
            </javadoc>
            <declaration name="defaultEncoding" type="String" line="143"/>
            <javadoc line="143">
                Cache of the platform default encoding as specified in the
                  &quot;file.encoding&quot; system property.                
            </javadoc>
            <declaration name="textNatives" type="Set" line="148"/>
            <javadoc line="148">
                A collection of all natives listed in flavormap.properties with
                  a primary MIME type of &quot;text&quot;.                
            </javadoc>
            <declaration name="nativeCharsets" type="Map" line="153"/>
            <javadoc line="153">
                The native encodings/charsets for the Set of textNatives.                
            </javadoc>
            <declaration name="nativeEOLNs" type="Map" line="157"/>
            <javadoc line="157">
                The end-of-line markers for the Set of textNatives.                
            </javadoc>
            <declaration name="nativeTerminators" type="Map" line="161"/>
            <javadoc line="161">
                The number of terminating NUL bytes for the Set of textNatives.                
            </javadoc>
            <declaration name="DATA_CONVERTER_KEY" type="String" line="165"/>
            <javadoc line="165">
                The key used to store pending data conversion requests for an AppContext.                
            </javadoc>
            <declaration name="transferer" type="DataTransferer" line="169"/>
            <javadoc line="169">
                The singleton DataTransferer instance. It is created during MToolkit
                  or WToolkit initialization.                
            </javadoc>
            <declaration name="dtLog" type="PlatformLogger" line="174"/>
            <scope line="175">
                <declaration name="tCharArrayClass" type="Class" line="176"/>
                <scope line="177"/>
                <scope line="181"/>
                <declaration name="tPlainTextStringFlavor" type="DataFlavor" line="185"/>
                <scope line="186"/>
                <scope line="189"/>
                <declaration name="tJavaTextEncodingFlavor" type="DataFlavor" line="192"/>
                <scope line="193"/>
                <scope line="196"/>
                <declaration name="tempMap" type="Map" line="199"/>
            </scope>
            <javadoc line="217">
                The accessor method for the singleton DataTransferer instance. Note
                  that in a headless environment, there may be no DataTransferer instance;
                  instead, null will be returned.                
            </javadoc>
            <method name="getInstance" type="DataTransferer" line="222">
                <scope line="223">
                    <scope line="224">
                        <declaration name="name" type="String" line="225"/>
                        <scope line="226">
                            <anonymous_class line="227">
                                <method name="run" type="DataTransferer" line="228">
                                    <declaration name="cls" type="Class" line="229"/>
                                    <declaration name="method" type="Method" line="230"/>
                                    <declaration name="ret" type="DataTransferer" line="231"/>
                                    <scope line="232"/>
                                    <scope line="235">
                                        <declaration name="cl" type="ClassLoader" line="236"/>
                                        <scope line="237">
                                            <scope line="238"/>
                                            <scope line="241"/>
                                        </scope>
                                    </scope>
                                    <scope line="247">
                                        <scope line="248"/>
                                        <scope line="252"/>
                                        <scope line="256"/>
                                    </scope>
                                    <scope line="261">
                                        <scope line="262"/>
                                        <scope line="265"/>
                                        <scope line="269"/>
                                    </scope>
                                </method>
                            </anonymous_class>
                            <declaration name="action" type="PrivilegedAction&lt;DataTransferer&gt;" line="227"/>
                        </scope>
                    </scope>
                </scope>
            </method>
            <javadoc line="284">
                Converts an arbitrary text encoding to its canonical name.                
            </javadoc>
            <method name="canonicalName" type="String" line="287">
                <params>
                    <param name="encoding" type="String"/>
                </params>
                <scope line="288"/>
                <scope line="291"/>
                <scope line="294"/>
                <scope line="297"/>
            </method>
            <javadoc line="301">
                If the specified flavor is a text flavor which supports the &quot;charset&quot;
                  parameter, then this method returns that parameter, or the default
                  charset if no such parameter was specified at construction. For non-
                  text DataFlavors, and for non-charset text flavors, this method returns
                  null.                
            </javadoc>
            <method name="getTextCharset" type="String" line="308">
                <params>
                    <param name="flavor" type="DataFlavor"/>
                </params>
                <scope line="309"/>
                <declaration name="encoding" type="String" line="312"/>
            </method>
            <javadoc line="315">
                Returns the platform&apos;s default character encoding.                
            </javadoc>
            <method name="getDefaultTextCharset" type="String" line="318">
                <scope line="319"/>
            </method>
            <javadoc line="324">
                Tests only whether the flavor&apos;s MIME type supports the charset
                  parameter. Must only be called for flavors with a primary type of
                  &quot;text&quot;.                
            </javadoc>
            <method name="doesSubtypeSupportCharset" type="boolean" line="329">
                <params>
                    <param name="flavor" type="DataFlavor"/>
                </params>
                <scope line="330">
                    <scope line="331"/>
                </scope>
                <declaration name="subType" type="String" line="335"/>
                <scope line="336"/>
                <declaration name="support" type="Object" line="339"/>
                <scope line="340"/>
                <declaration name="ret_val" type="boolean" line="343"/>
            </method>
            <method name="doesSubtypeSupportCharset" type="boolean" line="347">
                <params>
                    <param name="subType" type="String"/>
                    <param name="charset" type="String"/>
                </params>
                <declaration name="support" type="Object" line="348"/>
                <scope line="349"/>
                <declaration name="ret_val" type="boolean" line="352"/>
            </method>
            <javadoc line="356">
                Returns whether this flavor is a text type which supports the
                  &apos;charset&apos; parameter.                
            </javadoc>
            <method name="isFlavorCharsetTextType" type="boolean" line="360">
                <params>
                    <param name="flavor" type="DataFlavor"/>
                </params>
                <scope line="361"/>
                <scope line="364"/>
                <declaration name="rep_class" type="Class" line="367"/>
                <scope line="368"/>
                <scope line="371"/>
                <declaration name="charset" type="String" line="374"/>
            </method>
            <javadoc line="377">
                Returns whether this flavor is a text type which does not support the
                  &apos;charset&apos; parameter.                
            </javadoc>
            <method name="isFlavorNoncharsetTextType" type="boolean" line="381">
                <params>
                    <param name="flavor" type="DataFlavor"/>
                </params>
                <scope line="382"/>
            </method>
            <javadoc line="387">
                Determines whether this JRE can both encode and decode text in the
                  specified encoding.                
            </javadoc>
            <method name="isEncodingSupported" type="boolean" line="391">
                <params>
                    <param name="encoding" type="String"/>
                </params>
                <scope line="392"/>
                <scope line="395"/>
                <scope line="398"/>
            </method>
            <javadoc line="402">
                Returns {@code true} if the given type is a java.rmi.Remote.                
            </javadoc>
            <method name="isRemote" type="boolean" line="405">
                <params>
                    <param name="type" type="Class<?>"/>
                </params>
            </method>
            <javadoc line="408">
                Returns an Iterator which traverses a SortedSet of Strings which are
                  a total order of the standard character sets supported by the JRE. The
                  ordering follows the same principles as DataFlavor.selectBestTextFlavor.
                  So as to avoid loading all available character converters, optional,
                  non-standard, character sets are not included.                
            </javadoc>
            <method name="standardEncodings" type="Iterator" line="415"/>
            <javadoc line="418">
                Converts a FlavorMap to a FlavorTable.                
            </javadoc>
            <method name="adaptFlavorMap" type="FlavorTable" line="421">
                <params>
                    <param name="map" type="FlavorMap"/>
                </params>
                <scope line="422"/>
                <anonymous_class line="425">
                    <method name="getNativesForFlavors" type="Map" line="426">
                        <params>
                            <param name="flavors" type="DataFlavor[]"/>
                        </params>
                    </method>
                    <method name="getFlavorsForNatives" type="Map" line="429">
                        <params>
                            <param name="natives" type="String[]"/>
                        </params>
                    </method>
                    <method name="getNativesForFlavor" type="List" line="432">
                        <params>
                            <param name="flav" type="DataFlavor"/>
                        </params>
                        <declaration name="natives" type="Map" line="433"/>
                        <declaration name="nat" type="String" line="434"/>
                        <scope line="435">
                            <declaration name="list" type="List" line="436"/>
                        </scope>
                        <scope line="440"/>
                    </method>
                    <method name="getFlavorsForNative" type="List" line="444">
                        <params>
                            <param name="nat" type="String"/>
                        </params>
                        <declaration name="flavors" type="Map" line="445"/>
                        <declaration name="flavor" type="DataFlavor" line="446"/>
                        <scope line="447">
                            <declaration name="list" type="List" line="448"/>
                        </scope>
                        <scope line="452"/>
                    </method>
                </anonymous_class>
            </method>
            <method name="getDefaultUnicodeEncoding" type="String" line="459"/>
            <javadoc line="459">
                Returns the default Unicode encoding for the platform. The encoding
                  need not be canonical. This method is only used by the archaic function
                  DataFlavor.getTextPlainUnicodeFlavor().                
            </javadoc>
            <javadoc line="465">
                This method is called for text flavor mappings established while parsing
                  the flavormap.properties file. It stores the &quot;eoln&quot; and &quot;terminators&quot;
                  parameters which are not officially part of the MIME type. They are
                  MIME parameters specific to the flavormap.properties file format.                
            </javadoc>
            <method name="registerTextFlavorProperties" type="void" line="471">
                <params>
                    <param name="nat" type="String"/>
                    <param name="charset" type="String"/>
                    <param name="eoln" type="String"/>
                    <param name="terminators" type="String"/>
                </params>
                <declaration name="format" type="Long" line="472"/>
                <scope line="475"/>
                <scope line="478">
                    <declaration name="iTerminators" type="Integer" line="479"/>
                    <scope line="480"/>
                </scope>
            </method>
            <javadoc line="485">
                Determines whether the native corresponding to the specified long format
                  was listed in the flavormap.properties file.                
            </javadoc>
            <method name="isTextFormat" type="boolean" line="489">
                <params>
                    <param name="format" type="long"/>
                </params>
            </method>
            <method name="getCharsetForTextFormat" type="String" line="492">
                <params>
                    <param name="lFormat" type="Long"/>
                </params>
            </method>
            <method name="isLocaleDependentTextFormat" type="boolean" line="495"/>
            <javadoc line="495">
                Specifies whether text imported from the native system in the specified
                  format is locale-dependent. If so, when decoding such text,
                  &apos;nativeCharsets&apos; should be ignored, and instead, the Transferable should
                  be queried for its javaTextEncodingFlavor data for the correct encoding.                
            </javadoc>
            <method name="isFileFormat" type="boolean" line="502"/>
            <javadoc line="502">
                Determines whether the DataFlavor corresponding to the specified long
                  format is DataFlavor.javaFileListFlavor.                
            </javadoc>
            <method name="isImageFormat" type="boolean" line="507"/>
            <javadoc line="507">
                Determines whether the DataFlavor corresponding to the specified long
                  format is DataFlavor.imageFlavor.                
            </javadoc>
            <javadoc line="512">
                Determines whether the format is a URI list we can convert to
                  a DataFlavor.javaFileListFlavor.                
            </javadoc>
            <method name="isURIListFormat" type="boolean" line="516">
                <params>
                    <param name="format" type="long"/>
                </params>
            </method>
            <javadoc line="519">
                Returns a Map whose keys are all of the possible formats into which the
                  Transferable&apos;s transfer data flavors can be translated. The value of
                  each key is the DataFlavor in which the Transferable&apos;s data should be
                  requested when converting to the format.
                  &lt;p&gt;
                  The map keys are sorted according to the native formats preference
                  order.                
            </javadoc>
            <method name="getFormatsForTransferable" type="SortedMap" line="528">
                <params>
                    <param name="contents" type="Transferable"/>
                    <param name="map" type="FlavorTable"/>
                </params>
                <declaration name="flavors" type="DataFlavor[]" line="529"/>
                <scope line="530"/>
            </method>
            <javadoc line="535">
                Returns a Map whose keys are all of the possible formats into which data
                  in the specified DataFlavor can be translated. The value of each key
                  is the DataFlavor in which a Transferable&apos;s data should be requested
                  when converting to the format.
                  &lt;p&gt;
                  The map keys are sorted according to the native formats preference
                  order.                
            </javadoc>
            <method name="getFormatsForFlavor" type="SortedMap" line="544">
                <params>
                    <param name="flavor" type="DataFlavor"/>
                    <param name="map" type="FlavorTable"/>
                </params>
            </method>
            <javadoc line="547">
                Returns a Map whose keys are all of the possible formats into which data
                  in the specified DataFlavors can be translated. The value of each key
                  is the DataFlavor in which the Transferable&apos;s data should be requested
                  when converting to the format.
                  &lt;p&gt;
                  The map keys are sorted according to the native formats preference
                  order.                
                <param>
                    flavors the data flavors                    
                </param>
                <param>
                    map the FlavorTable which contains mappings between
                      DataFlavors and data formats                    
                </param>
                <throws>
                    NullPointerException if flavors or map is <code>null</code>                    
                </throws>
            </javadoc>
            <method name="getFormatsForFlavors" type="SortedMap" line="560">
                <params>
                    <param name="flavors" type="DataFlavor[]"/>
                    <param name="map" type="FlavorTable"/>
                </params>
                <declaration name="formatMap" type="Map" line="561"/>
                <declaration name="textPlainMap" type="Map" line="562"/>
                <declaration name="indexMap" type="Map" line="563"/>
                <declaration name="textPlainIndexMap" type="Map" line="564"/>
                <declaration name="currentIndex" type="int" line="565"/>
                <scope line="566">
                    <declaration name="flavor" type="DataFlavor" line="567"/>
                    <scope line="569">
                        <declaration name="natives" type="List" line="570"/>
                        <scope line="572">
                            <declaration name="lFormat" type="Long" line="573"/>
                            <declaration name="index" type="Integer" line="574"/>
                            <scope line="577"/>
                        </scope>
                    </scope>
                </scope>
                <declaration name="comparator" type="Comparator" line="587"/>
                <declaration name="sortedMap" type="SortedMap" line="588"/>
            </method>
            <javadoc line="592">
                Reduces the Map output for the root function to an array of the
                  Map&apos;s keys.                
            </javadoc>
            <method name="getFormatsForTransferableAsArray" type="long[]" line="596">
                <params>
                    <param name="contents" type="Transferable"/>
                    <param name="map" type="FlavorTable"/>
                </params>
            </method>
            <method name="getFormatsForFlavorAsArray" type="long[]" line="599">
                <params>
                    <param name="flavor" type="DataFlavor"/>
                    <param name="map" type="FlavorTable"/>
                </params>
            </method>
            <method name="getFormatsForFlavorsAsArray" type="long[]" line="602">
                <params>
                    <param name="flavors" type="DataFlavor[]"/>
                    <param name="map" type="FlavorTable"/>
                </params>
            </method>
            <javadoc line="605">
                Returns a Map whose keys are all of the possible DataFlavors into which
                  data in the specified format can be translated. The value of each key
                  is the format in which the Clipboard or dropped data should be requested
                  when converting to the DataFlavor.                
            </javadoc>
            <method name="getFlavorsForFormat" type="Map" line="611">
                <params>
                    <param name="format" type="long"/>
                    <param name="map" type="FlavorTable"/>
                </params>
            </method>
            <javadoc line="614">
                Returns a Map whose keys are all of the possible DataFlavors into which
                  data in the specified formats can be translated. The value of each key
                  is the format in which the Clipboard or dropped data should be requested
                  when converting to the DataFlavor.                
            </javadoc>
            <method name="getFlavorsForFormats" type="Map" line="620">
                <params>
                    <param name="formats" type="long[]"/>
                    <param name="map" type="FlavorTable"/>
                </params>
                <declaration name="flavorMap" type="Map" line="621"/>
                <declaration name="mappingSet" type="Set" line="622"/>
                <declaration name="flavorSet" type="Set" line="623"/>
                <scope line="624">
                    <declaration name="format" type="long" line="625"/>
                    <declaration name="nat" type="String" line="626"/>
                    <declaration name="flavors" type="List" line="627"/>
                    <scope line="628">
                        <declaration name="flavor" type="DataFlavor" line="629"/>
                        <scope line="630">
                            <declaration name="lFormat" type="Long" line="631"/>
                            <declaration name="mapping" type="Object" line="632"/>
                        </scope>
                    </scope>
                </scope>
                <scope line="639">
                    <declaration name="flavor" type="DataFlavor" line="640"/>
                    <declaration name="natives" type="List" line="641"/>
                    <scope line="642">
                        <declaration name="lFormat" type="Long" line="643"/>
                        <declaration name="mapping" type="Object" line="644"/>
                        <scope line="645"/>
                    </scope>
                </scope>
            </method>
            <javadoc line="653">
                Returns a Set of all DataFlavors for which
                  1) a mapping from at least one of the specified formats exists in the
                  specified map and
                  2) the data translation for this mapping can be performed by the data
                  transfer subsystem.                
                <param>
                    formats the data formats                    
                </param>
                <param>
                    map the FlavorTable which contains mappings between
                      DataFlavors and data formats                    
                </param>
                <throws>
                    NullPointerException if formats or map is <code>null</code>                    
                </throws>
            </javadoc>
            <method name="getFlavorsForFormatsAsSet" type="Set" line="664">
                <params>
                    <param name="formats" type="long[]"/>
                    <param name="map" type="FlavorTable"/>
                </params>
                <declaration name="flavorSet" type="Set" line="665"/>
                <scope line="666">
                    <declaration name="nat" type="String" line="667"/>
                    <declaration name="flavors" type="List" line="668"/>
                    <scope line="669">
                        <declaration name="flavor" type="DataFlavor" line="670"/>
                        <scope line="671"/>
                    </scope>
                </scope>
            </method>
            <javadoc line="678">
                Returns an array of all DataFlavors for which
                  1) a mapping from the specified format exists in the specified map and
                  2) the data translation for this mapping can be performed by the data
                  transfer subsystem.
                  The array will be sorted according to a
                  &lt;code&gt;DataFlavorComparator&lt;/code&gt; created with the specified
                  map as an argument.                
                <param>
                    format the data format                    
                </param>
                <param>
                    map the FlavorTable which contains mappings between
                      DataFlavors and data formats                    
                </param>
                <throws>
                    NullPointerException if map is <code>null</code>                    
                </throws>
            </javadoc>
            <method name="getFlavorsForFormatAsArray" type="DataFlavor[]" line="691">
                <params>
                    <param name="format" type="long"/>
                    <param name="map" type="FlavorTable"/>
                </params>
            </method>
            <javadoc line="694">
                Returns an array of all DataFlavors for which
                  1) a mapping from at least one of the specified formats exists in the
                  specified map and
                  2) the data translation for this mapping can be performed by the data
                  transfer subsystem.
                  The array will be sorted according to a
                  &lt;code&gt;DataFlavorComparator&lt;/code&gt; created with the specified
                  map as an argument.                
                <param>
                    formats the data formats                    
                </param>
                <param>
                    map the FlavorTable which contains mappings between
                      DataFlavors and data formats                    
                </param>
                <throws>
                    NullPointerException if formats or map is <code>null</code>                    
                </throws>
            </javadoc>
            <method name="getFlavorsForFormatsAsArray" type="DataFlavor[]" line="708">
                <params>
                    <param name="formats" type="long[]"/>
                    <param name="map" type="FlavorTable"/>
                </params>
            </method>
            <javadoc line="711">
                Returns an object that represents a mapping between the specified
                  key and value. &lt;tt&gt;null&lt;/tt&gt; values and the &lt;tt&gt;null&lt;/tt&gt; keys are
                  permitted. The internal representation of the mapping object is
                  irrelevant. The only requrement is that the two mapping objects are equal
                  if and only if their keys are equal and their values are equal.
                  More formally, the two mapping objects are equal if and only if
                  &lt;tt&gt;(value1 == null ? value2 == null : value1.equals(value2))
                  &amp;&amp; (key1 == null ? key2 == null : key1.equals(key2))&lt;/tt&gt;.                
            </javadoc>
            <method name="createMapping" type="Object" line="721">
                <params>
                    <param name="key" type="Object"/>
                    <param name="value" type="Object"/>
                </params>
            </method>
            <method name="getFormatForNativeAsLong" type="Long" line="724"/>
            <javadoc line="724">
                Looks-up or registers the String native with the native data transfer
                  system and returns a long format corresponding to that native.                
            </javadoc>
            <method name="getNativeForFormat" type="String" line="729"/>
            <javadoc line="729">
                Looks-up the String native corresponding to the specified long format in
                  the native data transfer system.                
            </javadoc>
            <method name="getBestCharsetForTextFormat" type="String" line="734">
                <params>
                    <param name="lFormat" type="Long"/>
                    <param name="localeTransferable" type="Transferable"/>
                </params>
                <declaration name="charset" type="String" line="735"/>
                <scope line="736">
                    <scope line="737"/>
                    <scope line="740"/>
                </scope>
                <scope line="743"/>
                <scope line="746"/>
            </method>
            <javadoc line="751">
                Translation function for converting string into
                  a byte array. Search-and-replace EOLN. Encode into the
                  target format. Append terminating NUL bytes.
                  Java to Native string conversion                
            </javadoc>
            <method name="translateTransferableString" type="byte[]" line="757">
                <params>
                    <param name="str" type="String"/>
                    <param name="format" type="long"/>
                </params>
                <declaration name="lFormat" type="Long" line="758"/>
                <declaration name="charset" type="String" line="759"/>
                <declaration name="eoln" type="String" line="760"/>
                <scope line="761">
                    <declaration name="length" type="int" line="762"/>
                    <declaration name="buffer" type="StringBuffer" line="763"/>
                    <scope line="764">
                        <scope line="765"/>
                        <declaration name="c" type="char" line="770"/>
                        <scope line="771"/>
                        <scope line="774"/>
                    </scope>
                </scope>
                <declaration name="bytes" type="byte[]" line="780"/>
                <declaration name="terminators" type="Integer" line="781"/>
                <scope line="782">
                    <declaration name="numTerminators" type="int" line="783"/>
                    <declaration name="terminatedBytes" type="byte[]" line="784"/>
                    <scope line="786"/>
                </scope>
            </method>
            <javadoc line="793">
                Translating either a byte array or an InputStream into an String.
                  Strip terminators and search-and-replace EOLN.
                  Native to Java string conversion                
            </javadoc>
            <method name="translateBytesOrStreamToString" type="String" line="798">
                <params>
                    <param name="str" type="InputStream"/>
                    <param name="bytes" type="byte[]"/>
                    <param name="format" type="long"/>
                    <param name="localeTransferable" type="Transferable"/>
                </params>
                <scope line="799"/>
                <declaration name="lFormat" type="Long" line="803"/>
                <declaration name="charset" type="String" line="804"/>
                <declaration name="eoln" type="String" line="805"/>
                <declaration name="terminators" type="Integer" line="806"/>
                <declaration name="count" type="int" line="807"/>
                <scope line="808">
                    <declaration name="numTerminators" type="int" line="809"/>
                    <scope line="810">
                        <scope line="811">
                            <scope line="812"/>
                        </scope>
                    </scope>
                </scope>
                <scope line="819"/>
                <declaration name="converted" type="String" line="822"/>
                <scope line="823">
                    <declaration name="buf" type="char[]" line="824"/>
                    <declaration name="eoln_arr" type="char[]" line="825"/>
                    <declaration name="j" type="int" line="827"/>
                    <declaration name="match" type="boolean" line="828"/>
                    <scope line="829">
                        <scope line="830"/>
                        <scope line="835">
                            <scope line="836"/>
                        </scope>
                        <scope line="841"/>
                        <scope line="845"/>
                    </scope>
                </scope>
            </method>
            <javadoc line="853">
                Primary translation function for translating a Transferable into
                  a byte array, given a source DataFlavor and target format.                
            </javadoc>
            <method name="translateTransferable" type="byte[]" line="857">
                <params>
                    <param name="contents" type="Transferable"/>
                    <param name="flavor" type="DataFlavor"/>
                    <param name="format" type="long"/>
                </params>
                <declaration name="obj" type="Object" line="858"/>
                <declaration name="stringSelectionHack" type="boolean" line="859"/>
                <scope line="860">
                    <scope line="862"/>
                    <scope line="865">
                        <scope line="867"/>
                    </scope>
                    <scope line="872"/>
                </scope>
                <scope line="876"/>
                <scope line="879">
                    <declaration name="str" type="String" line="880"/>
                </scope>
                <scope line="883">
                    <scope line="884"/>
                    <declaration name="r" type="Reader" line="887"/>
                    <declaration name="buf" type="StringBuffer" line="888"/>
                    <declaration name="c" type="int" line="889"/>
                    <scope line="890"/>
                </scope>
                <scope line="896">
                    <scope line="897"/>
                    <declaration name="buffer" type="CharBuffer" line="900"/>
                    <declaration name="size" type="int" line="901"/>
                    <declaration name="chars" type="char[]" line="902"/>
                </scope>
                <scope line="906">
                    <scope line="907"/>
                </scope>
                <scope line="912">
                    <declaration name="buffer" type="ByteBuffer" line="913"/>
                    <declaration name="size" type="int" line="914"/>
                    <declaration name="bytes" type="byte[]" line="915"/>
                    <scope line="917">
                        <declaration name="sourceEncoding" type="String" line="918"/>
                    </scope>
                    <scope line="921"/>
                </scope>
                <scope line="925">
                    <declaration name="bytes" type="byte[]" line="926"/>
                    <scope line="927">
                        <declaration name="sourceEncoding" type="String" line="928"/>
                    </scope>
                    <scope line="931"/>
                </scope>
                <scope line="935">
                    <scope line="936"/>
                    <declaration name="image" type="Image" line="939"/>
                    <declaration name="bytes" type="byte[]" line="940"/>
                    <scope line="941"/>
                </scope>
                <declaration name="bos" type="ByteArrayOutputStream" line="946"/>
                <scope line="947">
                    <scope line="948"/>
                    <declaration name="list" type="List" line="951"/>
                    <declaration name="userProtectionDomain" type="ProtectionDomain" line="952"/>
                    <declaration name="fileList" type="ArrayList&lt;String&gt;" line="953"/>
                </scope>
                <scope line="956">
                    <scope line="957"/>
                    <declaration name="nat" type="String" line="960"/>
                    <declaration name="targetCharset" type="String" line="961"/>
                    <scope line="962">
                        <scope line="963"/>
                        <scope line="966"/>
                    </scope>
                    <scope line="970"/>
                    <declaration name="list" type="List" line="973"/>
                    <declaration name="userProtectionDomain" type="ProtectionDomain" line="974"/>
                    <declaration name="fileList" type="ArrayList&lt;String&gt;" line="975"/>
                    <declaration name="uriList" type="ArrayList&lt;String&gt;" line="976"/>
                    <scope line="977">
                        <declaration name="uri" type="URI" line="978"/>
                        <scope line="979"/>
                        <scope line="982"/>
                    </scope>
                    <declaration name="eoln" type="byte[]" line="986"/>
                    <scope line="987">
                        <declaration name="bytes" type="byte[]" line="988"/>
                    </scope>
                </scope>
                <scope line="993">
                    <declaration name="is" type="InputStream" line="994"/>
                    <declaration name="eof" type="boolean" line="995"/>
                    <declaration name="avail" type="int" line="996"/>
                    <declaration name="tmp" type="byte[]" line="997"/>
                    <scope line="998">
                        <declaration name="ret" type="int" line="999"/>
                        <scope line="1000"/>
                    </scope>
                    <scope line="1006">
                        <declaration name="bytes" type="byte[]" line="1007"/>
                        <declaration name="sourceEncoding" type="String" line="1009"/>
                    </scope>
                </scope>
                <scope line="1013">
                    <declaration name="mo" type="Object" line="1014"/>
                    <declaration name="oos" type="ObjectOutputStream" line="1015"/>
                </scope>
                <scope line="1019">
                    <declaration name="oos" type="ObjectOutputStream" line="1020"/>
                </scope>
                <scope line="1024"/>
                <declaration name="ret" type="byte[]" line="1027"/>
            </method>
            <method name="convertFileListToBytes" type="ByteArrayOutputStream" line="1031"/>
            <method name="removeSuspectedData" type="String" line="1032">
                <params>
                    <param name="flavor" type="DataFlavor"/>
                    <param name="contents" type="Transferable"/>
                    <param name="str" type="String"/>
                </params>
                <scope line="1033"/>
                <declaration name="ret_val" type="String" line="1036"/>
                <declaration name="userProtectionDomain" type="ProtectionDomain" line="1037"/>
                <scope line="1038">
                    <anonymous_class line="1039">
                        <method name="run" type="Object" line="1040">
                            <declaration name="allowedFiles" type="StringBuffer" line="1041"/>
                            <declaration name="uriArray" type="String[]" line="1042"/>
                            <scope line="1043">
                                <declaration name="file" type="File" line="1044"/>
                                <scope line="1045">
                                    <scope line="1046"/>
                                </scope>
                            </scope>
                        </method>
                    </anonymous_class>
                </scope>
                <scope line="1057"/>
            </method>
            <method name="getUserProtectionDomain" type="ProtectionDomain" line="1062">
                <params>
                    <param name="contents" type="Transferable"/>
                </params>
            </method>
            <method name="isForbiddenToRead" type="boolean" line="1065">
                <params>
                    <param name="file" type="File"/>
                    <param name="protectionDomain" type="ProtectionDomain"/>
                </params>
                <scope line="1066"/>
                <scope line="1069">
                    <declaration name="filePermission" type="FilePermission" line="1070"/>
                    <scope line="1071"/>
                </scope>
                <scope line="1075"/>
            </method>
            <method name="castToFiles" type="ArrayList<String>" line="1079">
                <params>
                    <param name="files" type="List"/>
                    <param name="userProtectionDomain" type="ProtectionDomain"/>
                </params>
                <declaration name="fileList" type="ArrayList&lt;String&gt;" line="1080"/>
                <scope line="1081">
                    <anonymous_class line="1082">
                        <method name="run" type="Object" line="1083">
                            <scope line="1084">
                                <declaration name="file" type="File" line="1085"/>
                                <scope line="1086"/>
                            </scope>
                        </method>
                    </anonymous_class>
                </scope>
                <scope line="1095"/>
            </method>
            <method name="castToFile" type="File" line="1100">
                <params>
                    <param name="fileObject" type="Object"/>
                </params>
                <declaration name="filePath" type="String" line="1101"/>
                <scope line="1102"/>
                <scope line="1105"/>
                <scope line="1108"/>
            </method>
            <declaration name="DEPLOYMENT_CACHE_PROPERTIES" type="String[]" line="1113"/>
            <declaration name="deploymentCacheDirectoryList" type="ArrayList&lt;File&gt;" line="1114"/>
            <method name="isFileInWebstartedCache" type="boolean" line="1115">
                <params>
                    <param name="f" type="File"/>
                </params>
                <scope line="1116">
                    <scope line="1117">
                        <declaration name="cacheDirectoryPath" type="String" line="1118"/>
                        <scope line="1119">
                            <scope line="1120">
                                <declaration name="cacheDirectory" type="File" line="1121"/>
                                <scope line="1122"/>
                            </scope>
                            <scope line="1126"/>
                        </scope>
                    </scope>
                </scope>
                <scope line="1131">
                    <scope line="1132">
                        <scope line="1133"/>
                    </scope>
                </scope>
            </method>
            <method name="translateBytes" type="Object" line="1140">
                <params>
                    <param name="bytes" type="byte[]"/>
                    <param name="flavor" type="DataFlavor"/>
                    <param name="format" type="long"/>
                    <param name="localeTransferable" type="Transferable"/>
                </params>
            </method>
            <method name="translateStream" type="Object" line="1143">
                <params>
                    <param name="str" type="InputStream"/>
                    <param name="flavor" type="DataFlavor"/>
                    <param name="format" type="long"/>
                    <param name="localeTransferable" type="Transferable"/>
                </params>
            </method>
            <javadoc line="1146">
                Primary translation function for translating either a byte array or
                  an InputStream into an Object, given a source format and a target
                  DataFlavor.
                  One of str/bytes is non-null; the other is null.
                  The conversion from byte[] to InputStream is cheap, so do that
                  immediately if necessary. The opposite conversion is expensive,
                  so avoid it if possible.                
            </javadoc>
            <method name="translateBytesOrStream" type="Object" line="1155">
                <params>
                    <param name="str" type="InputStream"/>
                    <param name="bytes" type="byte[]"/>
                    <param name="flavor" type="DataFlavor"/>
                    <param name="format" type="long"/>
                    <param name="localeTransferable" type="Transferable"/>
                </params>
                <scope line="1156"/>
                <scope line="1159">
                    <scope line="1160"/>
                    <scope line="1163"/>
                    <declaration name="filenames" type="String[]" line="1166"/>
                    <scope line="1167"/>
                    <declaration name="files" type="File[]" line="1171"/>
                    <scope line="1172"/>
                </scope>
                <scope line="1178">
                    <scope line="1179">
                        <declaration name="uris" type="URI" line="1180"/>
                        <scope line="1181"/>
                        <declaration name="files" type="ArrayList" line="1184"/>
                        <scope line="1185">
                            <scope line="1186"/>
                            <scope line="1189"/>
                        </scope>
                    </scope>
                    <scope line="1194"/>
                </scope>
                <scope line="1198"/>
                <scope line="1201"/>
                <scope line="1204"/>
                <scope line="1207">
                    <scope line="1208"/>
                    <declaration name="is" type="InputStream" line="1211"/>
                    <declaration name="unicode" type="String" line="1212"/>
                    <declaration name="reader" type="Reader" line="1213"/>
                </scope>
                <scope line="1216">
                    <scope line="1217"/>
                    <declaration name="buffer" type="CharBuffer" line="1220"/>
                </scope>
                <scope line="1223">
                    <scope line="1224"/>
                </scope>
                <scope line="1229">
                    <scope line="1230"/>
                    <scope line="1233">
                        <scope line="1234"/>
                    </scope>
                    <declaration name="buffer" type="ByteBuffer" line="1238"/>
                </scope>
                <scope line="1241">
                    <scope line="1242"/>
                    <scope line="1245"/>
                </scope>
                <scope line="1249">
                    <scope line="1250">
                        <declaration name="ba" type="byte[]" line="1251"/>
                        <declaration name="ois" type="ObjectInputStream" line="1252"/>
                        <declaration name="ret" type="Object" line="1253"/>
                    </scope>
                    <scope line="1258"/>
                </scope>
                <scope line="1262">
                    <scope line="1263">
                        <declaration name="ba" type="byte[]" line="1264"/>
                        <declaration name="ois" type="ObjectInputStream" line="1265"/>
                        <declaration name="ret" type="Object" line="1266"/>
                    </scope>
                    <scope line="1271"/>
                </scope>
                <scope line="1275">
                    <scope line="1276"/>
                    <declaration name="image" type="Image" line="1279"/>
                </scope>
            </method>
            <javadoc line="1285">
                For arbitrary flavors, just use the raw InputStream. For text flavors,
                  ReencodingInputStream will decode and reencode the InputStream on demand
                  so that we can strip terminators and search-and-replace EOLN.                
            </javadoc>
            <method name="translateBytesOrStreamToInputStream" type="Object" line="1290">
                <params>
                    <param name="str" type="InputStream"/>
                    <param name="flavor" type="DataFlavor"/>
                    <param name="format" type="long"/>
                    <param name="localeTransferable" type="Transferable"/>
                </params>
                <scope line="1291"/>
            </method>
            <javadoc line="1296">
                We support representations which are exactly of the specified Class,
                  and also arbitrary Objects which have a constructor which takes an
                  instance of the Class as its sole parameter.                
            </javadoc>
            <method name="constructFlavoredObject" type="Object" line="1301">
                <params>
                    <param name="arg" type="Object"/>
                    <param name="flavor" type="DataFlavor"/>
                    <param name="clazz" type="Class"/>
                </params>
                <declaration name="dfrc" type="Class" line="1302"/>
                <scope line="1303"/>
                <scope line="1306">
                    <declaration name="constructors" type="Constructor[]" line="1307"/>
                    <scope line="1308">
                        <anonymous_class line="1309">
                            <method name="run" type="Object" line="1310"/>
                        </anonymous_class>
                    </scope>
                    <scope line="1316"/>
                    <declaration name="constructor" type="Constructor" line="1319"/>
                    <scope line="1320">
                        <scope line="1321"/>
                        <declaration name="ptypes" type="Class[]" line="1324"/>
                        <scope line="1325"/>
                    </scope>
                    <scope line="1330"/>
                    <scope line="1333"/>
                    <scope line="1336"/>
                </scope>
            </method>
            <class name="ReencodingInputStream" line="1341">
                <extends class="InputStream"/>
                <javadoc line="1341">
                    Used for decoding and reencoding an InputStream on demand so that we
                      can strip NUL terminators and perform EOLN search-and-replace.                    
                </javadoc>
                <declaration name="wrapped" type="BufferedReader" line="1346"/>
                <declaration name="in" type="char[]" line="1347"/>
                <declaration name="out" type="byte[]" line="1348"/>
                <declaration name="encoder" type="CharsetEncoder" line="1349"/>
                <declaration name="inBuf" type="CharBuffer" line="1350"/>
                <declaration name="outBuf" type="ByteBuffer" line="1351"/>
                <declaration name="eoln" type="char[]" line="1352"/>
                <declaration name="numTerminators" type="int" line="1353"/>
                <declaration name="eos" type="boolean" line="1354"/>
                <declaration name="index" type="int" line="1355"/>
                <method name="ReencodingInputStream" type="constructor" line="1356">
                    <params>
                        <param name="bytestream" type="InputStream"/>
                        <param name="format" type="long"/>
                        <param name="targetEncoding" type="String"/>
                        <param name="localeTransferable" type="Transferable"/>
                    </params>
                    <declaration name="lFormat" type="Long" line="1357"/>
                    <declaration name="sourceEncoding" type="String" line="1358"/>
                    <scope line="1359">
                        <scope line="1360"/>
                        <scope line="1363"/>
                    </scope>
                    <scope line="1366"/>
                    <scope line="1369"/>
                    <scope line="1373"/>
                    <scope line="1376"/>
                    <scope line="1382"/>
                    <scope line="1385"/>
                    <scope line="1388"/>
                    <declaration name="sEoln" type="String" line="1391"/>
                    <scope line="1392"/>
                    <declaration name="terminators" type="Integer" line="1395"/>
                    <scope line="1396"/>
                </method>
                <method name="read" type="int" line="1400">
                    <scope line="1401"/>
                    <scope line="1404">
                        <declaration name="c" type="int" line="1405"/>
                        <scope line="1406"/>
                        <scope line="1410"/>
                        <scope line="1414"/>
                    </scope>
                    <scope line="1426"/>
                </method>
                <method name="available" type="int" line="1430"/>
                <method name="close" type="void" line="1433"/>
                <javadoc line="1436">
                    Checks to see if the next array.length characters in wrapped
                      match array. The first character is provided as c. Subsequent
                      characters are read from wrapped itself. When this method returns,
                      the wrapped index may be different from what it was when this
                      method was called.                    
                </javadoc>
                <method name="matchCharArray" type="boolean" line="1443">
                    <params>
                        <param name="array" type="char[]"/>
                        <param name="c" type="int"/>
                    </params>
                    <declaration name="count" type="int" line="1445"/>
                    <scope line="1446">
                        <scope line="1447">
                            <scope line="1449"/>
                        </scope>
                    </scope>
                    <scope line="1454"/>
                    <scope line="1457"/>
                </method>
            </class>
            <method name="dragQueryFile" type="String[]" line="1463"/>
            <javadoc line="1463">
                Decodes a byte array into a set of String filenames.                
            </javadoc>
            <javadoc line="1467">
                Decodes URIs from either a byte array or a stream.                
            </javadoc>
            <method name="dragQueryURIs" type="URI[]" line="1470">
                <params>
                    <param name="stream" type="InputStream"/>
                    <param name="bytes" type="byte[]"/>
                    <param name="format" type="long"/>
                    <param name="localeTransferable" type="Transferable"/>
                </params>
            </method>
            <method name="platformImageBytesOrStreamToImage" type="Image" line="1473"/>
            <javadoc line="1473">
                Translates either a byte array or an input stream which contain
                  platform-specific image data in the given format into an Image.                
            </javadoc>
            <javadoc line="1478">
                Translates either a byte array or an input stream which contain
                  an image data in the given standard format into an Image.                
                <param>
                    mimeType image MIME type, such as: image/png, image/jpeg, image/gif                    
                </param>
            </javadoc>
            <method name="standardImageBytesOrStreamToImage" type="Image" line="1483">
                <params>
                    <param name="inputStream" type="InputStream"/>
                    <param name="bytes" type="byte[]"/>
                    <param name="mimeType" type="String"/>
                </params>
                <scope line="1484"/>
                <declaration name="readerIterator" type="Iterator" line="1487"/>
                <scope line="1488"/>
                <declaration name="ioe" type="IOException" line="1491"/>
                <scope line="1492">
                    <declaration name="imageReader" type="ImageReader" line="1493"/>
                    <scope line="1494">
                        <declaration name="imageInputStream" type="ImageInputStream" line="1495"/>
                        <scope line="1496">
                            <declaration name="param" type="ImageReadParam" line="1497"/>
                            <declaration name="bufferedImage" type="BufferedImage" line="1499"/>
                            <scope line="1500"/>
                        </scope>
                        <scope line="1504"/>
                    </scope>
                    <scope line="1509"/>
                </scope>
                <scope line="1514"/>
            </method>
            <method name="imageToPlatformBytes" type="byte[]" line="1519"/>
            <javadoc line="1519">
                Translates a Java Image into a byte array which contains platform-
                  specific image data in the given format.                
            </javadoc>
            <javadoc line="1524">
                Translates a Java Image into a byte array which contains
                  an image data in the given standard format.                
                <param>
                    mimeType image MIME type, such as: image/png, image/jpeg                    
                </param>
            </javadoc>
            <method name="imageToStandardBytes" type="byte[]" line="1529">
                <params>
                    <param name="image" type="Image"/>
                    <param name="mimeType" type="String"/>
                </params>
                <declaration name="originalIOE" type="IOException" line="1530"/>
                <declaration name="writerIterator" type="Iterator" line="1531"/>
                <scope line="1532"/>
                <scope line="1535">
                    <scope line="1536"/>
                    <scope line="1539"/>
                </scope>
                <declaration name="width" type="int" line="1543"/>
                <declaration name="height" type="int" line="1544"/>
                <scope line="1545">
                    <declaration name="ir" type="ImageRepresentation" line="1546"/>
                </scope>
                <scope line="1551"/>
                <declaration name="model" type="ColorModel" line="1555"/>
                <declaration name="raster" type="WritableRaster" line="1556"/>
                <declaration name="bufferedImage" type="BufferedImage" line="1557"/>
                <declaration name="g" type="Graphics" line="1558"/>
                <scope line="1559"/>
                <scope line="1562"/>
                <scope line="1565"/>
                <scope line="1568">
                    <scope line="1569"/>
                    <scope line="1572"/>
                </scope>
            </method>
            <method name="imageToStandardBytesImpl" type="byte[]" line="1577">
                <params>
                    <param name="renderedImage" type="RenderedImage"/>
                    <param name="mimeType" type="String"/>
                </params>
                <declaration name="writerIterator" type="Iterator" line="1578"/>
                <declaration name="typeSpecifier" type="ImageTypeSpecifier" line="1579"/>
                <declaration name="baos" type="ByteArrayOutputStream" line="1580"/>
                <declaration name="ioe" type="IOException" line="1581"/>
                <scope line="1582">
                    <declaration name="imageWriter" type="ImageWriter" line="1583"/>
                    <declaration name="writerSpi" type="ImageWriterSpi" line="1584"/>
                    <scope line="1585"/>
                    <scope line="1588">
                        <declaration name="imageOutputStream" type="ImageOutputStream" line="1589"/>
                        <scope line="1590"/>
                        <scope line="1595"/>
                    </scope>
                    <scope line="1599"/>
                </scope>
                <scope line="1610"/>
            </method>
            <javadoc line="1615">
                Concatenates the data represented by two objects. Objects can be either
                  byte arrays or instances of &lt;code&gt;InputStream&lt;/code&gt;. If both arguments
                  are byte arrays byte array will be returned. Otherwise an
                  &lt;code&gt;InputStream&lt;/code&gt; will be returned.
                  &lt;p&gt;
                  Currently is only called from native code to prepend palette data to
                  platform-specific image data during image transfer on Win32.                
                <param>
                    obj1 the first object to be concatenated.                    
                </param>
                <param>
                    obj2 the second object to be concatenated.                    
                </param>
                <return>
                    a byte array or an <code>InputStream</code> which represents
                      a logical concatenation of the two arguments.                    
                </return>
                <throws>
                    NullPointerException is either of the arguments is
                      <code>null</code>                    
                </throws>
                <throws>
                    ClassCastException is either of the arguments is
                      neither byte array nor an instance of <code>InputStream</code>.                    
                </throws>
            </javadoc>
            <method name="concatData" type="Object" line="1632">
                <params>
                    <param name="obj1" type="Object"/>
                    <param name="obj2" type="Object"/>
                </params>
                <declaration name="str1" type="InputStream" line="1633"/>
                <declaration name="str2" type="InputStream" line="1634"/>
                <scope line="1635">
                    <declaration name="arr1" type="byte[]" line="1636"/>
                    <scope line="1637">
                        <declaration name="arr2" type="byte[]" line="1638"/>
                        <declaration name="ret" type="byte[]" line="1639"/>
                    </scope>
                    <scope line="1644"/>
                </scope>
                <scope line="1649">
                    <scope line="1651"/>
                    <scope line="1654"/>
                </scope>
            </method>
            <method name="convertData" type="byte[]" line="1660">
                <params>
                    <param name="source" type="Object"/>
                    <param name="contents" type="Transferable"/>
                    <param name="format" type="long"/>
                    <param name="formatMap" type="Map"/>
                    <param name="isToolkitThread" type="boolean"/>
                </params>
                <declaration name="ret" type="byte[]" line="1661"/>
                <scope line="1662">
                    <declaration name="stack" type="Stack" line="1663"/>
                    <anonymous_class line="1664">
                        <declaration name="done" type="boolean" line="1665"/>
                        <method name="run" type="void" line="1666">
                            <scope line="1667"/>
                            <declaration name="data" type="byte[]" line="1670"/>
                            <scope line="1671">
                                <declaration name="flavor" type="DataFlavor" line="1672"/>
                                <scope line="1673"/>
                            </scope>
                            <scope line="1677"/>
                            <scope line="1681"/>
                            <scope line="1686"/>
                        </method>
                    </anonymous_class>
                    <declaration name="dataConverter" type="Runnable" line="1664"/>
                    <declaration name="appContext" type="AppContext" line="1693"/>
                    <scope line="1695"/>
                    <scope line="1699"/>
                    <scope line="1702"/>
                </scope>
                <scope line="1707"/>
                <scope line="1710">
                    <declaration name="flavor" type="DataFlavor" line="1711"/>
                    <scope line="1712"/>
                </scope>
            </method>
            <method name="processDataConversionRequests" type="void" line="1718">
                <scope line="1719">
                    <declaration name="appContext" type="AppContext" line="1720"/>
                    <scope line="1722">
                        <declaration name="dataConverter" type="Runnable" line="1723"/>
                        <scope line="1724"/>
                    </scope>
                    <scope line="1729"/>
                </scope>
            </method>
            <method name="getToolkitThreadBlockedHandler" type="ToolkitThreadBlockedHandler" line="1734"/>
            <javadoc line="1735">
                Helper function to reduce a Map with Long keys to a long array.
                  &lt;p&gt;
                  The map keys are sorted according to the native formats preference
                  order.                
            </javadoc>
            <method name="keysToLongArray" type="long[]" line="1741">
                <params>
                    <param name="map" type="SortedMap"/>
                </params>
                <declaration name="keySet" type="Set" line="1742"/>
                <declaration name="retval" type="long[]" line="1743"/>
                <declaration name="i" type="int" line="1744"/>
                <scope line="1745"/>
            </method>
            <javadoc line="1750">
                Helper function to reduce a Map with DataFlavor keys to a DataFlavor
                  array. The array will be sorted according to
                  &lt;code&gt;DataFlavorComparator&lt;/code&gt;.                
            </javadoc>
            <method name="keysToDataFlavorArray" type="DataFlavor[]" line="1755">
                <params>
                    <param name="map" type="Map"/>
                </params>
            </method>
            <javadoc line="1758">
                Helper function to convert a Set of DataFlavors to a sorted array.
                  The array will be sorted according to &lt;code&gt;DataFlavorComparator&lt;/code&gt;.                
            </javadoc>
            <method name="setToSortedDataFlavorArray" type="DataFlavor[]" line="1762">
                <params>
                    <param name="flavorsSet" type="Set"/>
                </params>
                <declaration name="flavors" type="DataFlavor[]" line="1763"/>
                <declaration name="comparator" type="Comparator" line="1765"/>
            </method>
            <javadoc line="1769">
                Helper function to convert a Set of DataFlavors to a sorted array.
                  The array will be sorted according to a
                  &lt;code&gt;DataFlavorComparator&lt;/code&gt; created with the specified
                  flavor-to-native map as an argument.                
            </javadoc>
            <method name="setToSortedDataFlavorArray" type="DataFlavor[]" line="1775">
                <params>
                    <param name="flavorsSet" type="Set"/>
                    <param name="flavorToNativeMap" type="Map"/>
                </params>
                <declaration name="flavors" type="DataFlavor[]" line="1776"/>
                <declaration name="comparator" type="Comparator" line="1778"/>
            </method>
            <javadoc line="1782">
                Helper function to convert an InputStream to a byte[] array.                
            </javadoc>
            <method name="inputStreamToByteArray" type="byte[]" line="1785">
                <params>
                    <param name="str" type="InputStream"/>
                </params>
                <declaration name="baos" type="ByteArrayOutputStream" line="1786"/>
                <declaration name="len" type="int" line="1787"/>
                <declaration name="buf" type="byte[]" line="1788"/>
                <scope line="1789"/>
            </method>
            <javadoc line="1794">
                Returns platform-specific mappings for the specified native.
                  If there are no platform-specific mappings for this native, the method
                  returns an empty &lt;code&gt;List&lt;/code&gt;.                
            </javadoc>
            <method name="getPlatformMappingsForNative" type="List" line="1799">
                <params>
                    <param name="nat" type="String"/>
                </params>
            </method>
            <javadoc line="1802">
                Returns platform-specific mappings for the specified flavor.
                  If there are no platform-specific mappings for this flavor, the method
                  returns an empty &lt;code&gt;List&lt;/code&gt;.                
            </javadoc>
            <method name="getPlatformMappingsForFlavor" type="List" line="1807">
                <params>
                    <param name="df" type="DataFlavor"/>
                </params>
            </method>
            <class name="IndexedComparator" line="1810">
                <implements interface="Comparator"/>
                <javadoc line="1810">
                    A Comparator which includes a helper function for comparing two Objects
                      which are likely to be keys in the specified Map.                    
                </javadoc>
                <declaration name="SELECT_BEST" type="boolean" line="1815"/>
                <javadoc line="1815">
                    The best Object (e.g., DataFlavor) will be the last in sequence.                    
                </javadoc>
                <declaration name="SELECT_WORST" type="boolean" line="1819"/>
                <javadoc line="1819">
                    The best Object (e.g., DataFlavor) will be the first in sequence.                    
                </javadoc>
                <declaration name="order" type="boolean" line="1823"/>
                <method name="IndexedComparator" type="constructor" line="1824"/>
                <method name="IndexedComparator" type="constructor" line="1827">
                    <params>
                        <param name="order" type="boolean"/>
                    </params>
                </method>
                <javadoc line="1830">
                    Helper method to compare two objects by their Integer indices in the
                      given map. If the map doesn&apos;t contain an entry for either of the
                      objects, the fallback index will be used for the object instead.                    
                    <param>
                        indexMap the map which maps objects into Integer indexes.                        
                    </param>
                    <param>
                        obj1 the first object to be compared.                        
                    </param>
                    <param>
                        obj2 the second object to be compared.                        
                    </param>
                    <param>
                        fallbackIndex the Integer to be used as a fallback index.                        
                    </param>
                    <return>
                        a negative integer, zero, or a positive integer as the
                          first object is mapped to a less, equal to, or greater
                          index than the second.                        
                    </return>
                </javadoc>
                <method name="compareIndices" type="int" line="1842">
                    <params>
                        <param name="indexMap" type="Map"/>
                        <param name="obj1" type="Object"/>
                        <param name="obj2" type="Object"/>
                        <param name="fallbackIndex" type="Integer"/>
                    </params>
                    <declaration name="index1" type="Integer" line="1843"/>
                    <declaration name="index2" type="Integer" line="1844"/>
                    <scope line="1845"/>
                    <scope line="1848"/>
                </method>
                <javadoc line="1853">
                    Helper method to compare two objects by their Long indices in the
                      given map. If the map doesn&apos;t contain an entry for either of the
                      objects, the fallback index will be used for the object instead.                    
                    <param>
                        indexMap the map which maps objects into Long indexes.                        
                    </param>
                    <param>
                        obj1 the first object to be compared.                        
                    </param>
                    <param>
                        obj2 the second object to be compared.                        
                    </param>
                    <param>
                        fallbackIndex the Long to be used as a fallback index.                        
                    </param>
                    <return>
                        a negative integer, zero, or a positive integer as the
                          first object is mapped to a less, equal to, or greater
                          index than the second.                        
                    </return>
                </javadoc>
                <method name="compareLongs" type="int" line="1865">
                    <params>
                        <param name="indexMap" type="Map"/>
                        <param name="obj1" type="Object"/>
                        <param name="obj2" type="Object"/>
                        <param name="fallbackIndex" type="Long"/>
                    </params>
                    <declaration name="index1" type="Long" line="1866"/>
                    <declaration name="index2" type="Long" line="1867"/>
                    <scope line="1868"/>
                    <scope line="1871"/>
                </method>
            </class>
            <class name="CharsetComparator" line="1877">
                <extends class="IndexedComparator"/>
                <javadoc line="1877">
                    An IndexedComparator which compares two String charsets. The comparison
                      follows the rules outlined in DataFlavor.selectBestTextFlavor. In order
                      to ensure that non-Unicode, non-ASCII, non-default charsets are sorted
                      in alphabetical order, charsets are not automatically converted to their
                      canonical forms.                    
                </javadoc>
                <declaration name="charsets" type="Map" line="1885"/>
                <declaration name="defaultEncoding" type="String" line="1886"/>
                <declaration name="DEFAULT_CHARSET_INDEX" type="Integer" line="1887"/>
                <declaration name="OTHER_CHARSET_INDEX" type="Integer" line="1888"/>
                <declaration name="WORST_CHARSET_INDEX" type="Integer" line="1889"/>
                <declaration name="UNSUPPORTED_CHARSET_INDEX" type="Integer" line="1890"/>
                <declaration name="UNSUPPORTED_CHARSET" type="String" line="1891"/>
                <scope line="1892">
                    <declaration name="charsetsMap" type="HashMap" line="1893"/>
                    <declaration name="defEncoding" type="String" line="1899"/>
                    <scope line="1900"/>
                </scope>
                <method name="CharsetComparator" type="constructor" line="1906"/>
                <method name="CharsetComparator" type="constructor" line="1909">
                    <params>
                        <param name="order" type="boolean"/>
                    </params>
                </method>
                <javadoc line="1912">
                    Compares two String objects. Returns a negative integer, zero,
                      or a positive integer as the first charset is worse than, equal to,
                      or better than the second.                    
                    <param>
                        obj1 the first charset to be compared                        
                    </param>
                    <param>
                        obj2 the second charset to be compared                        
                    </param>
                    <return>
                        a negative integer, zero, or a positive integer as the
                          first argument is worse, equal to, or better than the
                          second.                        
                    </return>
                    <throws>
                        ClassCastException if either of the arguments is not
                          instance of String                        
                    </throws>
                    <throws>
                        NullPointerException if either of the arguments is
                          <code>null</code>.                        
                    </throws>
                </javadoc>
                <method name="compare" type="int" line="1926">
                    <params>
                        <param name="obj1" type="Object"/>
                        <param name="obj2" type="Object"/>
                    </params>
                    <declaration name="charset1" type="String" line="1927"/>
                    <declaration name="charset2" type="String" line="1928"/>
                    <scope line="1929"/>
                    <scope line="1933"/>
                </method>
                <javadoc line="1939">
                    Compares charsets. Returns a negative integer, zero, or a positive
                      integer as the first charset is worse than, equal to, or better than
                      the second.
                      &lt;p&gt;
                      Charsets are ordered according to the following rules:
                      &lt;ul&gt;
                      &lt;li&gt;All unsupported charsets are equal.
                      &lt;li&gt;Any unsupported charset is worse than any supported charset.
                      &lt;li&gt;Unicode charsets, such as &quot;UTF-16&quot;, &quot;UTF-8&quot;, &quot;UTF-16BE&quot; and
                      &quot;UTF-16LE&quot;, are considered best.
                      &lt;li&gt;After them, platform default charset is selected.
                      &lt;li&gt;&quot;US-ASCII&quot; is the worst of supported charsets.
                      &lt;li&gt;For all other supported charsets, the lexicographically less
                      one is considered the better.
                      &lt;/ul&gt;                    
                    <param>
                        charset1 the first charset to be compared                        
                    </param>
                    <param>
                        charset2 the second charset to be compared.                        
                    </param>
                    <return>
                        a negative integer, zero, or a positive integer as the
                          first argument is worse, equal to, or better than the
                          second.                        
                    </return>
                </javadoc>
                <method name="compareCharsets" type="int" line="1961">
                    <params>
                        <param name="charset1" type="String"/>
                        <param name="charset2" type="String"/>
                    </params>
                    <declaration name="comp" type="int" line="1964"/>
                    <scope line="1965"/>
                </method>
                <javadoc line="1970">
                    Returns encoding for the specified charset according to the
                      following rules:
                      &lt;ul&gt;
                      &lt;li&gt;If the charset is &lt;code&gt;null&lt;/code&gt;, then &lt;code&gt;null&lt;/code&gt; will
                      be returned.
                      &lt;li&gt;Iff the charset specifies an encoding unsupported by this JRE,
                      &lt;code&gt;UNSUPPORTED_CHARSET&lt;/code&gt; will be returned.
                      &lt;li&gt;If the charset specifies an alias name, the corresponding
                      canonical name will be returned iff the charset is a known
                      Unicode, ASCII, or default charset.
                      &lt;/ul&gt;                    
                    <param>
                        charset the charset.                        
                    </param>
                    <return>
                        an encoding for this charset.                        
                    </return>
                </javadoc>
                <method name="getEncoding" type="String" line="1985">
                    <params>
                        <param name="charset" type="String"/>
                    </params>
                    <scope line="1986"/>
                    <scope line="1989"/>
                    <scope line="1992">
                        <declaration name="canonicalName" type="String" line="1993"/>
                    </scope>
                </method>
            </class>
            <class name="DataFlavorComparator" line="1998">
                <extends class="IndexedComparator"/>
                <javadoc line="1998">
                    An IndexedComparator which compares two DataFlavors. For text flavors,
                      the comparison follows the rules outlined in
                      DataFlavor.selectBestTextFlavor. For non-text flavors, unknown
                      application MIME types are preferred, followed by known
                      application/x-java- MIME types. Unknown application types are preferred
                      because if the user provides his own data flavor, it will likely be the
                      most descriptive one. For flavors which are otherwise equal, the
                      flavors&apos; native formats are compared, with greater long values
                      taking precedence.                    
                </javadoc>
                <declaration name="flavorToFormatMap" type="Map" line="2010"/>
                <declaration name="charsetComparator" type="CharsetComparator" line="2011"/>
                <declaration name="exactTypes" type="Map" line="2012"/>
                <declaration name="primaryTypes" type="Map" line="2013"/>
                <declaration name="nonTextRepresentations" type="Map" line="2014"/>
                <declaration name="textTypes" type="Map" line="2015"/>
                <declaration name="decodedTextRepresentations" type="Map" line="2016"/>
                <declaration name="encodedTextRepresentations" type="Map" line="2017"/>
                <declaration name="UNKNOWN_OBJECT_LOSES" type="Integer" line="2018"/>
                <declaration name="UNKNOWN_OBJECT_WINS" type="Integer" line="2019"/>
                <declaration name="UNKNOWN_OBJECT_LOSES_L" type="Long" line="2020"/>
                <declaration name="UNKNOWN_OBJECT_WINS_L" type="Long" line="2021"/>
                <scope line="2022">
                    <scope line="2023">
                        <declaration name="exactTypesMap" type="HashMap" line="2024"/>
                    </scope>
                    <scope line="2031">
                        <declaration name="primaryTypesMap" type="HashMap" line="2032"/>
                    </scope>
                    <scope line="2036">
                        <declaration name="nonTextRepresentationsMap" type="HashMap" line="2037"/>
                        <declaration name="remoteClass" type="Class&lt;?&gt;" line="2040"/>
                        <scope line="2041"/>
                    </scope>
                    <scope line="2046">
                        <declaration name="textTypesMap" type="HashMap" line="2047"/>
                    </scope>
                    <scope line="2066">
                        <declaration name="decodedTextRepresentationsMap" type="HashMap" line="2067"/>
                    </scope>
                    <scope line="2074">
                        <declaration name="encodedTextRepresentationsMap" type="HashMap" line="2075"/>
                    </scope>
                </scope>
                <method name="DataFlavorComparator" type="constructor" line="2082"/>
                <method name="DataFlavorComparator" type="constructor" line="2085">
                    <params>
                        <param name="order" type="boolean"/>
                    </params>
                </method>
                <method name="DataFlavorComparator" type="constructor" line="2090">
                    <params>
                        <param name="map" type="Map"/>
                    </params>
                </method>
                <method name="DataFlavorComparator" type="constructor" line="2093">
                    <params>
                        <param name="map" type="Map"/>
                        <param name="order" type="boolean"/>
                    </params>
                    <declaration name="hashMap" type="HashMap" line="2096"/>
                </method>
                <method name="compare" type="int" line="2100">
                    <params>
                        <param name="obj1" type="Object"/>
                        <param name="obj2" type="Object"/>
                    </params>
                    <declaration name="flavor1" type="DataFlavor" line="2101"/>
                    <declaration name="flavor2" type="DataFlavor" line="2102"/>
                    <scope line="2103"/>
                    <scope line="2107"/>
                    <scope line="2111"/>
                    <declaration name="comp" type="int" line="2114"/>
                    <declaration name="primaryType1" type="String" line="2115"/>
                    <declaration name="subType1" type="String" line="2116"/>
                    <declaration name="mimeType1" type="String" line="2117"/>
                    <declaration name="class1" type="Class" line="2118"/>
                    <declaration name="primaryType2" type="String" line="2119"/>
                    <declaration name="subType2" type="String" line="2120"/>
                    <declaration name="mimeType2" type="String" line="2121"/>
                    <declaration name="class2" type="Class" line="2122"/>
                    <scope line="2123">
                        <scope line="2125"/>
                        <scope line="2128">
                            <scope line="2130"/>
                            <scope line="2134"/>
                        </scope>
                        <scope line="2139"/>
                    </scope>
                    <scope line="2143">
                        <scope line="2145"/>
                        <scope line="2149"/>
                        <scope line="2153"/>
                    </scope>
                </method>
            </class>
            <class name="IndexOrderComparator" line="2160">
                <extends class="IndexedComparator"/>
                <declaration name="indexMap" type="Map" line="2161"/>
                <declaration name="FALLBACK_INDEX" type="Integer" line="2162"/>
                <method name="IndexOrderComparator" type="constructor" line="2163">
                    <params>
                        <param name="indexMap" type="Map"/>
                    </params>
                </method>
                <method name="IndexOrderComparator" type="constructor" line="2167">
                    <params>
                        <param name="indexMap" type="Map"/>
                        <param name="order" type="boolean"/>
                    </params>
                </method>
                <method name="compare" type="int" line="2171">
                    <params>
                        <param name="obj1" type="Object"/>
                        <param name="obj2" type="Object"/>
                    </params>
                    <scope line="2172"/>
                    <scope line="2175"/>
                </method>
            </class>
            <class name="RMI" line="2180">
                <javadoc line="2180">
                    A class that provides access to java.rmi.Remote and java.rmi.MarshalledObject
                      without creating a static dependency.                    
                </javadoc>
                <declaration name="remoteClass" type="Class&lt;?&gt;" line="2185"/>
                <declaration name="marshallObjectClass" type="Class&lt;?&gt;" line="2186"/>
                <declaration name="marshallCtor" type="Constructor&lt;?&gt;" line="2187"/>
                <declaration name="marshallGet" type="Method" line="2188"/>
                <method name="getClass" type="Class<?>" line="2189">
                    <params>
                        <param name="name" type="String"/>
                    </params>
                    <scope line="2190"/>
                    <scope line="2193"/>
                </method>
                <method name="getConstructor" type="Constructor<?>" line="2197">
                    <params>
                        <param name="c" type="Class<?>"/>
                        <param name="types" type="Class<?>"/>
                    </params>
                    <scope line="2198"/>
                    <scope line="2201"/>
                </method>
                <method name="getMethod" type="Method" line="2205">
                    <params>
                        <param name="c" type="Class<?>"/>
                        <param name="name" type="String"/>
                        <param name="types" type="Class<?>"/>
                    </params>
                    <scope line="2206"/>
                    <scope line="2209"/>
                </method>
                <javadoc line="2213">
                    Returns {@code true} if the given class is java.rmi.Remote.                    
                </javadoc>
                <method name="isRemote" type="boolean" line="2216">
                    <params>
                        <param name="c" type="Class<?>"/>
                    </params>
                </method>
                <javadoc line="2219">
                    Returns java.rmi.Remote.class if RMI is present; otherwise {@code null}.                    
                </javadoc>
                <method name="remoteClass" type="Class<?>" line="2222"/>
                <javadoc line="2225">
                    Returns a new MarshalledObject containing the serialized representation
                      of the given object.                    
                </javadoc>
                <method name="newMarshalledObject" type="Object" line="2229">
                    <params>
                        <param name="obj" type="Object"/>
                    </params>
                    <scope line="2230"/>
                    <scope line="2233"/>
                    <scope line="2236"/>
                    <scope line="2239">
                        <declaration name="cause" type="Throwable" line="2240"/>
                    </scope>
                </method>
                <javadoc line="2245">
                    Returns a new copy of the contained marshalled object.                    
                </javadoc>
                <method name="getMarshalledObject" type="Object" line="2248">
                    <params>
                        <param name="obj" type="Object"/>
                    </params>
                    <scope line="2249"/>
                    <scope line="2252"/>
                    <scope line="2255">
                        <declaration name="cause" type="Throwable" line="2256"/>
                    </scope>
                </method>
            </class>
        </class>
    </source>