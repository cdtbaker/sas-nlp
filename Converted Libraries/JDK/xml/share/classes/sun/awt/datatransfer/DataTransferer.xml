<?xml version="1.0" encoding="UTF-8"?>
    <source package="sun.awt.datatransfer">
        <import package="java.awt.AWTError"/>
        <import package="java.awt.EventQueue"/>
        <import package="java.awt.Image"/>
        <import package="java.awt.Graphics"/>
        <import package="java.awt.datatransfer.DataFlavor"/>
        <import package="java.awt.datatransfer.FlavorMap"/>
        <import package="java.awt.datatransfer.FlavorTable"/>
        <import package="java.awt.datatransfer.Transferable"/>
        <import package="java.awt.datatransfer.UnsupportedFlavorException"/>
        <import package="java.io.BufferedReader"/>
        <import package="java.io.ByteArrayInputStream"/>
        <import package="java.io.ByteArrayOutputStream"/>
        <import package="java.io.File"/>
        <import package="java.io.InputStream"/>
        <import package="java.io.InputStreamReader"/>
        <import package="java.io.IOException"/>
        <import package="java.io.ObjectInputStream"/>
        <import package="java.io.ObjectOutputStream"/>
        <import package="java.io.Reader"/>
        <import package="java.io.SequenceInputStream"/>
        <import package="java.io.StringReader"/>
        <import package="java.net.URI"/>
        <import package="java.net.URISyntaxException"/>
        <import package="java.nio.ByteBuffer"/>
        <import package="java.nio.CharBuffer"/>
        <import package="java.nio.charset.Charset"/>
        <import package="java.nio.charset.CharsetEncoder"/>
        <import package="java.nio.charset.IllegalCharsetNameException"/>
        <import package="java.nio.charset.UnsupportedCharsetException"/>
        <import package="java.lang.reflect.Constructor"/>
        <import package="java.lang.reflect.InvocationTargetException"/>
        <import package="java.lang.reflect.Method"/>
        <import package="java.lang.reflect.Modifier"/>
        <import package="java.security.AccessController"/>
        <import package="java.security.PrivilegedAction"/>
        <import package="java.security.PrivilegedActionException"/>
        <import package="java.security.PrivilegedExceptionAction"/>
        <import package="java.security.ProtectionDomain"/>
        <import package="java.util.ArrayList"/>
        <import package="java.util.Arrays"/>
        <import package="java.util.Collections"/>
        <import package="java.util.Comparator"/>
        <import package="java.util.HashMap"/>
        <import package="java.util.HashSet"/>
        <import package="java.util.Iterator"/>
        <import package="java.util.List"/>
        <import package="java.util.Map"/>
        <import package="java.util.SortedMap"/>
        <import package="java.util.SortedSet"/>
        <import package="java.util.Set"/>
        <import package="java.util.Stack"/>
        <import package="java.util.TreeMap"/>
        <import package="java.util.TreeSet"/>
        <import package="sun.util.logging.PlatformLogger"/>
        <import package="sun.awt.AppContext"/>
        <import package="sun.awt.SunToolkit"/>
        <import package="java.awt.image.BufferedImage"/>
        <import package="java.awt.image.ImageObserver"/>
        <import package="java.awt.image.RenderedImage"/>
        <import package="java.awt.image.WritableRaster"/>
        <import package="java.awt.image.ColorModel"/>
        <import package="javax.imageio.ImageIO"/>
        <import package="javax.imageio.ImageReader"/>
        <import package="javax.imageio.ImageReadParam"/>
        <import package="javax.imageio.ImageWriter"/>
        <import package="javax.imageio.ImageTypeSpecifier"/>
        <import package="javax.imageio.spi.ImageWriterSpi"/>
        <import package="javax.imageio.stream.ImageInputStream"/>
        <import package="javax.imageio.stream.ImageOutputStream"/>
        <import package="sun.awt.image.ImageRepresentation"/>
        <import package="sun.awt.image.ToolkitImage"/>
        <import package="java.io.FilePermission"/>
        <class name="DataTransferer" line="117">
            <comment line="973">
                Contains common code for finding the best charset for
                 clipboard string encodingdecoding, basing on clipboard
                 format and localeTransferable(on decoding, if available)                
            </comment>
            <comment line="1508">
                It is important do not use user&apos;s successors
                 of File class.                
            </comment>
            <comment line="2964">
                Given the Map that maps objects to Integer indices and a boolean value,
                 this Comparator imposes a direct or reverse order on set of objects.
                 &lt;p&gt;
                 If the specified boolean value is SELECT_BEST, the Comparator imposes the
                 direct index-based order: an object A is greater than an object B if and
                 only if the index of A is greater than the index of B. An object that
                 doesn&apos;t have an associated index is less or equal than any other object.
                 &lt;p&gt;
                 If the specified boolean value is SELECT_WORST, the Comparator imposes the
                 reverse index-based order: an object A is greater than an object B if and
                 only if A is less than B with the direct index-based order.                
            </comment>
            <javadoc line="117">
                Provides a set of functions to be shared among the DataFlavor class and
                  platform-specific data transfer implementations.
                  The concept of &quot;flavors&quot; and &quot;natives&quot; is extended to include &quot;formats&quot;,
                  which are the numeric values Win32 and X11 use to express particular data
                  types. Like FlavorMap, which provides getNativesForFlavors(DataFlavor[]) and
                  getFlavorsForNatives(String[]) functions, DataTransferer provides a set
                  of getFormatsFor(Transferable|Flavor|Flavors) and
                  getFlavorsFor(Format|Formats) functions.
                  Also provided are functions for translating a Transferable into a byte
                  array, given a source DataFlavor and a target format, and for translating
                  a byte array or InputStream into an Object, given a source format and
                  a target DataFlavor.                
                <author>
                    David Mendenhall                    
                </author>
                <author>
                    Danila Sinopalnikov                    
                </author>
                <since>
                    1.3.1                    
                </since>
            </javadoc>
            <declaration name="charArrayClass" type="Class" line="140"/>
            <javadoc line="140">
                Cached value of Class.forName(&quot;[C&quot;);                
            </javadoc>
            <declaration name="byteArrayClass" type="Class" line="145"/>
            <javadoc line="145">
                Cached value of Class.forName(&quot;[B&quot;);                
            </javadoc>
            <declaration name="plainTextStringFlavor" type="DataFlavor" line="150"/>
            <javadoc line="150">
                The &lt;code&gt;DataFlavor&lt;/code&gt; representing plain text with Unicode
                  encoding, where:
                  &lt;pre&gt;
                  representationClass = java.lang.String
                  mimeType            = &quot;text/plain; charset=Unicode&quot;
                  &lt;/pre&gt;                
            </javadoc>
            <declaration name="javaTextEncodingFlavor" type="DataFlavor" line="160"/>
            <javadoc line="160">
                The &lt;code&gt;DataFlavor&lt;/code&gt; representing a Java text encoding String
                  encoded in UTF-8, where
                  &lt;pre&gt;
                  representationClass = [B
                  mimeType            = &quot;application/x-java-text-encoding&quot;
                  &lt;/pre&gt;                
            </javadoc>
            <class name="StandardEncodingsHolder" line="170">
                <javadoc line="170">
                    Lazy initialization of Standard Encodings.                    
                </javadoc>
                <declaration name="standardEncodings" type="SortedSet" line="174"/>
                <method name="load" type="SortedSet" line="176">
                    <declaration name="comparator" type="Comparator" line="177"/>
                    <declaration name="tempSet" type="SortedSet" line="179"/>
                </method>
            </class>
            <declaration name="textMIMESubtypeCharsetSupport" type="Map" line="191"/>
            <javadoc line="191">
                Tracks whether a particular text/ MIME type supports the charset
                  parameter. The Map is initialized with all of the standard MIME types
                  listed in the DataFlavor.selectBestTextFlavor method comment. Additional
                  entries may be added during the life of the JRE for text/&lt;other&gt; types.                
            </javadoc>
            <declaration name="defaultEncoding" type="String" line="199"/>
            <javadoc line="199">
                Cache of the platform default encoding as specified in the
                  &quot;file.encoding&quot; system property.                
            </javadoc>
            <declaration name="textNatives" type="Set" line="205"/>
            <javadoc line="205">
                A collection of all natives listed in flavormap.properties with
                  a primary MIME type of &quot;text&quot;.                
            </javadoc>
            <declaration name="nativeCharsets" type="Map" line="212"/>
            <javadoc line="212">
                The native encodings/charsets for the Set of textNatives.                
            </javadoc>
            <declaration name="nativeEOLNs" type="Map" line="218"/>
            <javadoc line="218">
                The end-of-line markers for the Set of textNatives.                
            </javadoc>
            <declaration name="nativeTerminators" type="Map" line="224"/>
            <javadoc line="224">
                The number of terminating NUL bytes for the Set of textNatives.                
            </javadoc>
            <declaration name="DATA_CONVERTER_KEY" type="String" line="230"/>
            <javadoc line="230">
                The key used to store pending data conversion requests for an AppContext.                
            </javadoc>
            <declaration name="transferer" type="DataTransferer" line="235"/>
            <javadoc line="235">
                The singleton DataTransferer instance. It is created during MToolkit
                  or WToolkit initialization.                
            </javadoc>
            <declaration name="dtLog" type="PlatformLogger" line="241"/>
            <scope line="243">
                <declaration name="tCharArrayClass" type="Class" line="244"/>
                <scope line="245"/>
                <scope line="248"/>
                <declaration name="tPlainTextStringFlavor" type="DataFlavor" line="253"/>
                <scope line="254"/>
                <scope line="257"/>
                <declaration name="tJavaTextEncodingFlavor" type="DataFlavor" line="261"/>
                <scope line="262"/>
                <scope line="265"/>
                <declaration name="tempMap" type="Map" line="269"/>
            </scope>
            <javadoc line="288">
                The accessor method for the singleton DataTransferer instance. Note
                  that in a headless environment, there may be no DataTransferer instance;
                  instead, null will be returned.                
            </javadoc>
            <method name="getInstance" type="DataTransferer" line="293">
                <scope line="294">
                    <scope line="295">
                        <declaration name="name" type="String" line="296"/>
                        <scope line="297">
                            <anonymous_class line="299">
                                <method name="run" type="DataTransferer" line="300">
                                    <declaration name="cls" type="Class" line="301"/>
                                    <declaration name="method" type="Method" line="302"/>
                                    <declaration name="ret" type="DataTransferer" line="303"/>
                                    <scope line="305"/>
                                    <scope line="307">
                                        <declaration name="cl" type="ClassLoader" line="308"/>
                                        <scope line="310">
                                            <scope line="311"/>
                                            <scope line="313"/>
                                        </scope>
                                    </scope>
                                    <scope line="319">
                                        <scope line="320"/>
                                        <scope line="323"/>
                                        <scope line="326"/>
                                    </scope>
                                    <scope line="331">
                                        <scope line="332"/>
                                        <scope line="334"/>
                                        <scope line="337"/>
                                    </scope>
                                </method>
                            </anonymous_class>
                            <declaration name="action" type="PrivilegedAction&lt;DataTransferer&gt;" line="298"/>
                        </scope>
                    </scope>
                </scope>
            </method>
            <javadoc line="352">
                Converts an arbitrary text encoding to its canonical name.                
            </javadoc>
            <method name="canonicalName" type="String" line="355">
                <params>
                    <param name="encoding" type="String"/>
                </params>
                <scope line="356"/>
                <scope line="359"/>
                <scope line="361"/>
                <scope line="363"/>
            </method>
            <javadoc line="368">
                If the specified flavor is a text flavor which supports the &quot;charset&quot;
                  parameter, then this method returns that parameter, or the default
                  charset if no such parameter was specified at construction. For non-
                  text DataFlavors, and for non-charset text flavors, this method returns
                  null.                
            </javadoc>
            <method name="getTextCharset" type="String" line="375">
                <params>
                    <param name="flavor" type="DataFlavor"/>
                </params>
                <scope line="376"/>
                <declaration name="encoding" type="String" line="380"/>
            </method>
            <javadoc line="385">
                Returns the platform&apos;s default character encoding.                
            </javadoc>
            <method name="getDefaultTextCharset" type="String" line="388">
                <scope line="389"/>
            </method>
            <javadoc line="395">
                Tests only whether the flavor&apos;s MIME type supports the charset
                  parameter. Must only be called for flavors with a primary type of
                  &quot;text&quot;.                
            </javadoc>
            <method name="doesSubtypeSupportCharset" type="boolean" line="400">
                <params>
                    <param name="flavor" type="DataFlavor"/>
                </params>
                <scope line="401">
                    <scope line="402"/>
                </scope>
                <declaration name="subType" type="String" line="407"/>
                <scope line="408"/>
                <declaration name="support" type="Object" line="412"/>
                <scope line="414"/>
                <declaration name="ret_val" type="boolean" line="418"/>
            </method>
            <method name="doesSubtypeSupportCharset" type="boolean" line="425">
                <params>
                    <param name="subType" type="String"/>
                    <param name="charset" type="String"/>
                </params>
                <declaration name="support" type="Object" line="426"/>
                <scope line="428"/>
                <declaration name="ret_val" type="boolean" line="432"/>
            </method>
            <javadoc line="438">
                Returns whether this flavor is a text type which supports the
                  &apos;charset&apos; parameter.                
            </javadoc>
            <method name="isFlavorCharsetTextType" type="boolean" line="442">
                <params>
                    <param name="flavor" type="DataFlavor"/>
                </params>
                <comment line="444">
                    Although stringFlavor doesn&apos;t actually support the charset
                     parameter (because its primary MIME type is not &quot;text&quot;), it should
                     be treated as though it does. stringFlavor is semantically
                     equivalent to &quot;text/plain&quot; data.                    
                </comment>
                <comment line="478">
                    null equals default encoding which is always supported                    
                </comment>
                <scope line="447"/>
                <scope line="453"/>
                <declaration name="rep_class" type="Class" line="457"/>
                <scope line="463"/>
                <scope line="469"/>
                <declaration name="charset" type="String" line="473"/>
            </method>
            <javadoc line="480">
                Returns whether this flavor is a text type which does not support the
                  &apos;charset&apos; parameter.                
            </javadoc>
            <method name="isFlavorNoncharsetTextType" type="boolean" line="484">
                <params>
                    <param name="flavor" type="DataFlavor"/>
                </params>
                <scope line="487"/>
            </method>
            <javadoc line="497">
                Determines whether this JRE can both encode and decode text in the
                  specified encoding.                
            </javadoc>
            <method name="isEncodingSupported" type="boolean" line="501">
                <params>
                    <param name="encoding" type="String"/>
                </params>
                <scope line="502"/>
                <scope line="505"/>
                <scope line="507"/>
            </method>
            <javadoc line="512">
                Returns {@code true} if the given type is a java.rmi.Remote.                
            </javadoc>
            <method name="isRemote" type="boolean" line="515">
                <params>
                    <param name="type" type="Class<?>"/>
                </params>
            </method>
            <javadoc line="519">
                Returns an Iterator which traverses a SortedSet of Strings which are
                  a total order of the standard character sets supported by the JRE. The
                  ordering follows the same principles as DataFlavor.selectBestTextFlavor.
                  So as to avoid loading all available character converters, optional,
                  non-standard, character sets are not included.                
            </javadoc>
            <method name="standardEncodings" type="Iterator" line="526"/>
            <javadoc line="530">
                Converts a FlavorMap to a FlavorTable.                
            </javadoc>
            <method name="adaptFlavorMap" type="FlavorTable" line="533">
                <params>
                    <param name="map" type="FlavorMap"/>
                </params>
                <scope line="534"/>
                <anonymous_class line="538">
                    <method name="getNativesForFlavors" type="Map" line="539">
                        <params>
                            <param name="flavors" type="DataFlavor[]"/>
                        </params>
                    </method>
                    <method name="getFlavorsForNatives" type="Map" line="542">
                        <params>
                            <param name="natives" type="String[]"/>
                        </params>
                    </method>
                    <method name="getNativesForFlavor" type="List" line="545">
                        <params>
                            <param name="flav" type="DataFlavor"/>
                        </params>
                        <declaration name="natives" type="Map" line="546"/>
                        <declaration name="nat" type="String" line="548"/>
                        <scope line="549">
                            <declaration name="list" type="List" line="550"/>
                        </scope>
                        <scope line="553"/>
                    </method>
                    <method name="getFlavorsForNative" type="List" line="557">
                        <params>
                            <param name="nat" type="String"/>
                        </params>
                        <declaration name="flavors" type="Map" line="558"/>
                        <declaration name="flavor" type="DataFlavor" line="560"/>
                        <scope line="561">
                            <declaration name="list" type="List" line="562"/>
                        </scope>
                        <scope line="565"/>
                    </method>
                </anonymous_class>
            </method>
            <method name="getDefaultUnicodeEncoding" type="String" line="572"/>
            <javadoc line="572">
                Returns the default Unicode encoding for the platform. The encoding
                  need not be canonical. This method is only used by the archaic function
                  DataFlavor.getTextPlainUnicodeFlavor().                
            </javadoc>
            <javadoc line="579">
                This method is called for text flavor mappings established while parsing
                  the flavormap.properties file. It stores the &quot;eoln&quot; and &quot;terminators&quot;
                  parameters which are not officially part of the MIME type. They are
                  MIME parameters specific to the flavormap.properties file format.                
            </javadoc>
            <method name="registerTextFlavorProperties" type="void" line="586">
                <params>
                    <param name="nat" type="String"/>
                    <param name="charset" type="String"/>
                    <param name="eoln" type="String"/>
                    <param name="terminators" type="String"/>
                </params>
                <declaration name="format" type="Long" line="587"/>
                <scope line="592"/>
                <scope line="595">
                    <declaration name="iTerminators" type="Integer" line="596"/>
                    <scope line="597"/>
                </scope>
            </method>
            <javadoc line="603">
                Determines whether the native corresponding to the specified long format
                  was listed in the flavormap.properties file.                
            </javadoc>
            <method name="isTextFormat" type="boolean" line="607">
                <params>
                    <param name="format" type="long"/>
                </params>
            </method>
            <method name="getCharsetForTextFormat" type="String" line="611">
                <params>
                    <param name="lFormat" type="Long"/>
                </params>
            </method>
            <method name="isLocaleDependentTextFormat" type="boolean" line="615"/>
            <javadoc line="615">
                Specifies whether text imported from the native system in the specified
                  format is locale-dependent. If so, when decoding such text,
                  &apos;nativeCharsets&apos; should be ignored, and instead, the Transferable should
                  be queried for its javaTextEncodingFlavor data for the correct encoding.                
            </javadoc>
            <method name="isFileFormat" type="boolean" line="623"/>
            <javadoc line="623">
                Determines whether the DataFlavor corresponding to the specified long
                  format is DataFlavor.javaFileListFlavor.                
            </javadoc>
            <method name="isImageFormat" type="boolean" line="629"/>
            <javadoc line="629">
                Determines whether the DataFlavor corresponding to the specified long
                  format is DataFlavor.imageFlavor.                
            </javadoc>
            <javadoc line="635">
                Determines whether the format is a URI list we can convert to
                  a DataFlavor.javaFileListFlavor.                
            </javadoc>
            <method name="isURIListFormat" type="boolean" line="639">
                <params>
                    <param name="format" type="long"/>
                </params>
            </method>
            <javadoc line="643">
                Returns a Map whose keys are all of the possible formats into which the
                  Transferable&apos;s transfer data flavors can be translated. The value of
                  each key is the DataFlavor in which the Transferable&apos;s data should be
                  requested when converting to the format.
                  &lt;p&gt;
                  The map keys are sorted according to the native formats preference
                  order.                
            </javadoc>
            <method name="getFormatsForTransferable" type="SortedMap" line="653">
                <params>
                    <param name="contents" type="Transferable"/>
                    <param name="map" type="FlavorTable"/>
                </params>
                <declaration name="flavors" type="DataFlavor[]" line="654"/>
                <scope line="655"/>
            </method>
            <javadoc line="661">
                Returns a Map whose keys are all of the possible formats into which data
                  in the specified DataFlavor can be translated. The value of each key
                  is the DataFlavor in which a Transferable&apos;s data should be requested
                  when converting to the format.
                  &lt;p&gt;
                  The map keys are sorted according to the native formats preference
                  order.                
            </javadoc>
            <method name="getFormatsForFlavor" type="SortedMap" line="670">
                <params>
                    <param name="flavor" type="DataFlavor"/>
                    <param name="map" type="FlavorTable"/>
                </params>
            </method>
            <javadoc line="675">
                Returns a Map whose keys are all of the possible formats into which data
                  in the specified DataFlavors can be translated. The value of each key
                  is the DataFlavor in which the Transferable&apos;s data should be requested
                  when converting to the format.
                  &lt;p&gt;
                  The map keys are sorted according to the native formats preference
                  order.                
                <param>
                    flavors the data flavors                    
                </param>
                <param>
                    map the FlavorTable which contains mappings between
                      DataFlavors and data formats                    
                </param>
                <throws>
                    NullPointerException if flavors or map is <code>null</code>                    
                </throws>
            </javadoc>
            <method name="getFormatsForFlavors" type="SortedMap" line="689">
                <params>
                    <param name="flavors" type="DataFlavor[]"/>
                    <param name="map" type="FlavorTable"/>
                </params>
                <comment line="693">
                    Maps formats to indices that will be used to sort the formats
                     according to the preference order.
                     Larger index value corresponds to the more preferable format.                    
                </comment>
                <comment line="701">
                    Iterate backwards so that preferred DataFlavors are used over
                     other DataFlavors. (See javadoc for
                     Transferable.getTransferDataFlavors.)                    
                </comment>
                <comment line="708">
                    Don&apos;t explicitly test for String, since it is just a special
                     case of Serializable                    
                </comment>
                <comment line="729">
                    SystemFlavorMap.getNativesForFlavor will return
                     text/plain natives for all text/*. While this is good
                     for a single text/* flavor, we would prefer that
                     text/plain native data come from a text/plain flavor.                    
                </comment>
                <comment line="749">
                    Sort the map keys according to the formats preference order.                    
                </comment>
                <declaration name="formatMap" type="Map" line="690"/>
                <declaration name="textPlainMap" type="Map" line="691"/>
                <declaration name="indexMap" type="Map" line="695"/>
                <declaration name="textPlainIndexMap" type="Map" line="696"/>
                <declaration name="currentIndex" type="int" line="698"/>
                <scope line="703">
                    <declaration name="flavor" type="DataFlavor" line="704"/>
                    <scope line="715">
                        <declaration name="natives" type="List" line="716"/>
                        <scope line="720">
                            <declaration name="lFormat" type="Long" line="721"/>
                            <declaration name="index" type="Integer" line="723"/>
                            <scope line="735"/>
                        </scope>
                    </scope>
                </scope>
                <declaration name="comparator" type="Comparator" line="749"/>
                <declaration name="sortedMap" type="SortedMap" line="751"/>
            </method>
            <javadoc line="757">
                Reduces the Map output for the root function to an array of the
                  Map&apos;s keys.                
            </javadoc>
            <method name="getFormatsForTransferableAsArray" type="long[]" line="762">
                <params>
                    <param name="contents" type="Transferable"/>
                    <param name="map" type="FlavorTable"/>
                </params>
            </method>
            <method name="getFormatsForFlavorAsArray" type="long[]" line="766">
                <params>
                    <param name="flavor" type="DataFlavor"/>
                    <param name="map" type="FlavorTable"/>
                </params>
            </method>
            <method name="getFormatsForFlavorsAsArray" type="long[]" line="770">
                <params>
                    <param name="flavors" type="DataFlavor[]"/>
                    <param name="map" type="FlavorTable"/>
                </params>
            </method>
            <javadoc line="774">
                Returns a Map whose keys are all of the possible DataFlavors into which
                  data in the specified format can be translated. The value of each key
                  is the format in which the Clipboard or dropped data should be requested
                  when converting to the DataFlavor.                
            </javadoc>
            <method name="getFlavorsForFormat" type="Map" line="780">
                <params>
                    <param name="format" type="long"/>
                    <param name="map" type="FlavorTable"/>
                </params>
            </method>
            <javadoc line="784">
                Returns a Map whose keys are all of the possible DataFlavors into which
                  data in the specified formats can be translated. The value of each key
                  is the format in which the Clipboard or dropped data should be requested
                  when converting to the DataFlavor.                
            </javadoc>
            <method name="getFlavorsForFormats" type="Map" line="790">
                <params>
                    <param name="formats" type="long[]"/>
                    <param name="map" type="FlavorTable"/>
                </params>
                <comment line="796">
                    First step: build flavorSet, mappingSet and initial flavorMap
                     flavorSet  - the set of all the DataFlavors into which
                                  data in the specified formats can be translated;
                     mappingSet - the set of all the mappings from the specified formats
                                  into any DataFlavor;
                     flavorMap  - after this step, this map maps each of the DataFlavors
                                  from flavorSet to any of the specified formats.                    
                </comment>
                <comment line="811">
                    Don&apos;t explicitly test for String, since it is just a special
                     case of Serializable                    
                </comment>
                <comment line="830">
                    Second step: for each DataFlavor try to figure out which of the
                     specified formats is the best to translate to this flavor.
                     Then map each flavor to the best format.
                     For the given flavor, FlavorTable indicates which native will
                     best reflect data in the specified flavor to the underlying native
                     platform. We assume that this native is the best to translate
                     to this flavor.
                     Note: FlavorTable allows one-way mappings, so we can occasionally
                     map a flavor to the format for which the corresponding
                     format-to-flavor mapping doesn&apos;t exist. For this reason we have built
                     a mappingSet of all format-to-flavor mappings for the specified formats
                     and check if the format-to-flavor mapping exists for the
                     (flavor,format) pair being added.                    
                </comment>
                <declaration name="flavorMap" type="Map" line="791"/>
                <declaration name="mappingSet" type="Set" line="792"/>
                <declaration name="flavorSet" type="Set" line="793"/>
                <scope line="802">
                    <declaration name="format" type="long" line="803"/>
                    <declaration name="nat" type="String" line="804"/>
                    <declaration name="flavors" type="List" line="805"/>
                    <scope line="807">
                        <declaration name="flavor" type="DataFlavor" line="808"/>
                        <scope line="818">
                            <declaration name="lFormat" type="Long" line="819"/>
                            <declaration name="mapping" type="Object" line="820"/>
                        </scope>
                    </scope>
                </scope>
                <scope line="843">
                    <declaration name="flavor" type="DataFlavor" line="844"/>
                    <declaration name="natives" type="List" line="846"/>
                    <scope line="849">
                        <declaration name="lFormat" type="Long" line="850"/>
                        <declaration name="mapping" type="Object" line="852"/>
                        <scope line="854"/>
                    </scope>
                </scope>
            </method>
            <javadoc line="864">
                Returns a Set of all DataFlavors for which
                  1) a mapping from at least one of the specified formats exists in the
                  specified map and
                  2) the data translation for this mapping can be performed by the data
                  transfer subsystem.                
                <param>
                    formats the data formats                    
                </param>
                <param>
                    map the FlavorTable which contains mappings between
                      DataFlavors and data formats                    
                </param>
                <throws>
                    NullPointerException if formats or map is <code>null</code>                    
                </throws>
            </javadoc>
            <method name="getFlavorsForFormatsAsSet" type="Set" line="876">
                <params>
                    <param name="formats" type="long[]"/>
                    <param name="map" type="FlavorTable"/>
                </params>
                <comment line="887">
                    Don&apos;t explicitly test for String, since it is just a special
                     case of Serializable                    
                </comment>
                <declaration name="flavorSet" type="Set" line="877"/>
                <scope line="879">
                    <declaration name="nat" type="String" line="880"/>
                    <declaration name="flavors" type="List" line="881"/>
                    <scope line="883">
                        <declaration name="flavor" type="DataFlavor" line="884"/>
                        <scope line="894"/>
                    </scope>
                </scope>
            </method>
            <javadoc line="903">
                Returns an array of all DataFlavors for which
                  1) a mapping from the specified format exists in the specified map and
                  2) the data translation for this mapping can be performed by the data
                  transfer subsystem.
                  The array will be sorted according to a
                  &lt;code&gt;DataFlavorComparator&lt;/code&gt; created with the specified
                  map as an argument.                
                <param>
                    format the data format                    
                </param>
                <param>
                    map the FlavorTable which contains mappings between
                      DataFlavors and data formats                    
                </param>
                <throws>
                    NullPointerException if map is <code>null</code>                    
                </throws>
            </javadoc>
            <method name="getFlavorsForFormatAsArray" type="DataFlavor[]" line="918">
                <params>
                    <param name="format" type="long"/>
                    <param name="map" type="FlavorTable"/>
                </params>
            </method>
            <javadoc line="922">
                Returns an array of all DataFlavors for which
                  1) a mapping from at least one of the specified formats exists in the
                  specified map and
                  2) the data translation for this mapping can be performed by the data
                  transfer subsystem.
                  The array will be sorted according to a
                  &lt;code&gt;DataFlavorComparator&lt;/code&gt; created with the specified
                  map as an argument.                
                <param>
                    formats the data formats                    
                </param>
                <param>
                    map the FlavorTable which contains mappings between
                      DataFlavors and data formats                    
                </param>
                <throws>
                    NullPointerException if formats or map is <code>null</code>                    
                </throws>
            </javadoc>
            <method name="getFlavorsForFormatsAsArray" type="DataFlavor[]" line="938">
                <params>
                    <param name="formats" type="long[]"/>
                    <param name="map" type="FlavorTable"/>
                </params>
                <comment line="940">
                    getFlavorsForFormatsAsSet() is less expensive than
                     getFlavorsForFormats().                    
                </comment>
            </method>
            <javadoc line="944">
                Returns an object that represents a mapping between the specified
                  key and value. &lt;tt&gt;null&lt;/tt&gt; values and the &lt;tt&gt;null&lt;/tt&gt; keys are
                  permitted. The internal representation of the mapping object is
                  irrelevant. The only requrement is that the two mapping objects are equal
                  if and only if their keys are equal and their values are equal.
                  More formally, the two mapping objects are equal if and only if
                  &lt;tt&gt;(value1 == null ? value2 == null : value1.equals(value2))
                  &amp;&amp; (key1 == null ? key2 == null : key1.equals(key2))&lt;/tt&gt;.                
            </javadoc>
            <method name="createMapping" type="Object" line="954">
                <params>
                    <param name="key" type="Object"/>
                    <param name="value" type="Object"/>
                </params>
                <comment line="956">
                    NOTE: Should be updated to use AbstractMap.SimpleEntry as
                     soon as it is made public.                    
                </comment>
            </method>
            <method name="getFormatForNativeAsLong" type="Long" line="960"/>
            <javadoc line="960">
                Looks-up or registers the String native with the native data transfer
                  system and returns a long format corresponding to that native.                
            </javadoc>
            <method name="getNativeForFormat" type="String" line="966"/>
            <javadoc line="966">
                Looks-up the String native corresponding to the specified long format in
                  the native data transfer system.                
            </javadoc>
            <method name="getBestCharsetForTextFormat" type="String" line="978">
                <params>
                    <param name="lFormat" type="Long"/>
                    <param name="localeTransferable" type="Transferable"/>
                </params>
                <comment line="996">
                    Only happens when we have a custom text type.                    
                </comment>
                <declaration name="charset" type="String" line="979"/>
                <scope line="983">
                    <scope line="984"/>
                    <scope line="989"/>
                </scope>
                <scope line="991"/>
                <scope line="994"/>
            </method>
            <javadoc line="1001">
                Translation function for converting string into
                  a byte array. Search-and-replace EOLN. Encode into the
                  target format. Append terminating NUL bytes.
                  Java to Native string conversion                
            </javadoc>
            <method name="translateTransferableString" type="byte[]" line="1010">
                <params>
                    <param name="str" type="String"/>
                    <param name="format" type="long"/>
                </params>
                <comment line="1014">
                    Search and replace EOLN. Note that if EOLN is &quot;\n&quot;, then we
                     never added an entry to nativeEOLNs anyway, so we&apos;ll skip this
                     code altogether.
                     windows: &quot;abc\nde&quot;-&gt;&quot;abc\r\nde&quot;                    
                </comment>
                <comment line="1022">
                    2 is a heuristic                    
                </comment>
                <comment line="1024">
                    Fix for 4914613 - skip native EOLN                    
                </comment>
                <comment line="1040">
                    Encode text in target format.                    
                </comment>
                <comment line="1043">
                    Append terminating NUL bytes. Note that if terminators is 0,
                     the we never added an entry to nativeTerminators anyway, so
                     we&apos;ll skip code altogether.
                     &quot;abcde&quot; -&gt; &quot;abcde\0&quot;                    
                </comment>
                <declaration name="lFormat" type="Long" line="1011"/>
                <declaration name="charset" type="String" line="1012"/>
                <declaration name="eoln" type="String" line="1017"/>
                <scope line="1018">
                    <declaration name="length" type="int" line="1019"/>
                    <declaration name="buffer" type="StringBuffer" line="1020"/>
                    <scope line="1022">
                        <scope line="1024"/>
                        <declaration name="c" type="char" line="1029"/>
                        <scope line="1030"/>
                        <scope line="1032"/>
                    </scope>
                </scope>
                <declaration name="bytes" type="byte[]" line="1040"/>
                <declaration name="terminators" type="Integer" line="1046"/>
                <scope line="1047">
                    <declaration name="numTerminators" type="int" line="1048"/>
                    <declaration name="terminatedBytes" type="byte[]" line="1049"/>
                    <scope line="1052"/>
                </scope>
            </method>
            <javadoc line="1060">
                Translating either a byte array or an InputStream into an String.
                  Strip terminators and search-and-replace EOLN.
                  Native to Java string conversion                
            </javadoc>
            <method name="translateBytesOrStreamToString" type="String" line="1070">
                <params>
                    <param name="str" type="InputStream"/>
                    <param name="bytes" type="byte[]"/>
                    <param name="format" type="long"/>
                    <param name="localeTransferable" type="Transferable"/>
                </params>
                <comment line="1072">
                    A String holds all of its data in memory at one time, so
                     we can&apos;t avoid reading the entire InputStream at this point.                    
                </comment>
                <comment line="1082">
                    Locate terminating NUL bytes. Note that if terminators is 0,
                     the we never added an entry to nativeTerminators anyway, so
                     we&apos;ll skip code altogether.                    
                </comment>
                <comment line="1086">
                    In other words: we are doing char alignment here basing on suggestion
                     that count of zero-&apos;terminators&apos; is a number of bytes in one symbol
                     for selected charset (clipboard format). It is not complitly true for
                     multibyte coding like UTF-8, but helps understand the procedure.
                     &quot;abcde\0&quot; -&gt; &quot;abcde&quot;                    
                </comment>
                <comment line="1104">
                    found terminators                    
                </comment>
                <comment line="1111">
                    Decode text to chars. Don&apos;t include any terminators.                    
                </comment>
                <comment line="1114">
                    Search and replace EOLN. Note that if EOLN is &quot;\n&quot;, then we
                     never added an entry to nativeEOLNs anyway, so we&apos;ll skip this
                     code altogether.
                     Count of NUL-terminators and EOLN coding are platform-specific and
                     loaded from flavormap.properties file
                     windows: &quot;abc\r\nde&quot; -&gt; &quot;abc\nde&quot;                    
                </comment>
                <comment line="1123">
                    Fix for 4463560: replace EOLNs symbol-by-symbol instead
                     of using buf.replace()                    
                </comment>
                <comment line="1134">
                    Catch last few bytes                    
                </comment>
                <scope line="1073"/>
                <declaration name="lFormat" type="Long" line="1078"/>
                <declaration name="charset" type="String" line="1079"/>
                <declaration name="eoln" type="String" line="1091"/>
                <declaration name="terminators" type="Integer" line="1092"/>
                <declaration name="count" type="int" line="1093"/>
                <scope line="1094">
                    <declaration name="numTerminators" type="int" line="1095"/>
                    <scope line="1097">
                        <scope line="1098">
                            <scope line="1099"/>
                        </scope>
                    </scope>
                </scope>
                <scope line="1106"/>
                <declaration name="converted" type="String" line="1111"/>
                <scope line="1120">
                    <declaration name="buf" type="char[]" line="1126"/>
                    <declaration name="eoln_arr" type="char[]" line="1127"/>
                    <declaration name="j" type="int" line="1129"/>
                    <declaration name="match" type="boolean" line="1130"/>
                    <scope line="1132">
                        <scope line="1134"/>
                        <scope line="1140">
                            <scope line="1141"/>
                        </scope>
                        <scope line="1146"/>
                        <scope line="1149"/>
                    </scope>
                </scope>
            </method>
            <javadoc line="1160">
                Primary translation function for translating a Transferable into
                  a byte array, given a source DataFlavor and target format.                
            </javadoc>
            <method name="translateTransferable" type="byte[]" line="1167">
                <params>
                    <param name="contents" type="Transferable"/>
                    <param name="flavor" type="DataFlavor"/>
                    <param name="format" type="long"/>
                </params>
                <comment line="1169">
                    Obtain the transfer data in the source DataFlavor.
                    
                     Note that we special case DataFlavor.plainTextFlavor because
                     StringSelection supports this flavor incorrectly -- instead of
                     returning an InputStream as the DataFlavor representation class
                     states, it returns a Reader. Instead of using this broken
                     functionality, we request the data in stringFlavor (the other
                     DataFlavor which StringSelection supports) and use the String
                     translator.                    
                </comment>
                <comment line="1200">
                    Source data is a String. Search-and-replace EOLN. Encode into the
                     target format. Append terminating NUL bytes.                    
                </comment>
                <comment line="1212">
                    Source data is a Reader. Convert to a String and recur. In the
                     future, we may want to rewrite this so that we encode on demand.                    
                </comment>
                <comment line="1232">
                    Source data is a CharBuffer. Convert to a String and recur.                    
                </comment>
                <comment line="1248">
                    Source data is a char array. Convert to a String and recur.                    
                </comment>
                <comment line="1259">
                    Source data is a ByteBuffer. For arbitrary flavors, simply return
                     the array. For text flavors, decode back to a String and recur to
                     reencode according to the requested format.                    
                </comment>
                <comment line="1277">
                    Source data is a byte array. For arbitrary flavors, simply return
                     the array. For text flavors, decode back to a String and recur to
                     reencode according to the requested format.                    
                </comment>
                <comment line="1291">
                    Source data is Image                    
                </comment>
                <comment line="1310">
                    Target data is a file list. Source data must be a
                     java.util.List which contains java.io.File or String instances.                    
                </comment>
                <comment line="1326">
                    Target data is a URI list. Source data must be a
                     java.util.List which contains java.io.File or String instances.                    
                </comment>
                <comment line="1350">
                    Some implementations are fussy about the number of slashes (file:///path/to/file is best)                    
                </comment>
                <comment line="1365">
                    Source data is an InputStream. For arbitrary flavors, just grab the
                     bytes and dump them into a byte array. For text flavors, decode back
                     to a String and recur to reencode according to the requested format.                    
                </comment>
                <comment line="1390">
                    Source data is an RMI object                    
                </comment>
                <comment line="1397">
                    Source data is Serializable                    
                </comment>
                <declaration name="obj" type="Object" line="1177"/>
                <declaration name="stringSelectionHack" type="boolean" line="1178"/>
                <scope line="1179">
                    <scope line="1181"/>
                    <scope line="1186">
                        <scope line="1188"/>
                    </scope>
                    <scope line="1192"/>
                </scope>
                <scope line="1195"/>
                <scope line="1203">
                    <declaration name="str" type="String" line="1205"/>
                </scope>
                <scope line="1213">
                    <scope line="1214"/>
                    <declaration name="r" type="Reader" line="1219"/>
                    <declaration name="buf" type="StringBuffer" line="1220"/>
                    <declaration name="c" type="int" line="1221"/>
                    <scope line="1222"/>
                </scope>
                <scope line="1232">
                    <scope line="1233"/>
                    <declaration name="buffer" type="CharBuffer" line="1238"/>
                    <declaration name="size" type="int" line="1239"/>
                    <declaration name="chars" type="char[]" line="1240"/>
                </scope>
                <scope line="1248">
                    <scope line="1249"/>
                </scope>
                <scope line="1261">
                    <declaration name="buffer" type="ByteBuffer" line="1262"/>
                    <declaration name="size" type="int" line="1263"/>
                    <declaration name="bytes" type="byte[]" line="1264"/>
                    <scope line="1267">
                        <declaration name="sourceEncoding" type="String" line="1268"/>
                    </scope>
                    <scope line="1272"/>
                </scope>
                <scope line="1279">
                    <declaration name="bytes" type="byte[]" line="1280"/>
                    <scope line="1282">
                        <declaration name="sourceEncoding" type="String" line="1283"/>
                    </scope>
                    <scope line="1287"/>
                </scope>
                <scope line="1291">
                    <scope line="1292"/>
                    <declaration name="image" type="Image" line="1297"/>
                    <declaration name="bytes" type="byte[]" line="1298"/>
                    <scope line="1300"/>
                </scope>
                <declaration name="bos" type="ByteArrayOutputStream" line="1307"/>
                <scope line="1311">
                    <scope line="1312"/>
                    <declaration name="list" type="List" line="1316"/>
                    <declaration name="userProtectionDomain" type="ProtectionDomain" line="1318"/>
                    <declaration name="fileList" type="ArrayList&lt;String&gt;" line="1320"/>
                </scope>
                <scope line="1327">
                    <scope line="1328"/>
                    <declaration name="nat" type="String" line="1331"/>
                    <declaration name="targetCharset" type="String" line="1332"/>
                    <scope line="1333">
                        <scope line="1334"/>
                        <scope line="1336"/>
                    </scope>
                    <scope line="1340"/>
                    <declaration name="list" type="List" line="1343"/>
                    <declaration name="userProtectionDomain" type="ProtectionDomain" line="1344"/>
                    <declaration name="fileList" type="ArrayList&lt;String&gt;" line="1345"/>
                    <declaration name="uriList" type="ArrayList&lt;String&gt;" line="1346"/>
                    <scope line="1347">
                        <declaration name="uri" type="URI" line="1348"/>
                        <scope line="1350"/>
                        <scope line="1352"/>
                    </scope>
                    <declaration name="eoln" type="byte[]" line="1357"/>
                    <scope line="1358">
                        <declaration name="bytes" type="byte[]" line="1359"/>
                    </scope>
                </scope>
                <scope line="1367">
                    <declaration name="is" type="InputStream" line="1368"/>
                    <declaration name="eof" type="boolean" line="1369"/>
                    <declaration name="avail" type="int" line="1370"/>
                    <declaration name="tmp" type="byte[]" line="1371"/>
                    <scope line="1372">
                        <declaration name="ret" type="int" line="1373"/>
                        <scope line="1374"/>
                    </scope>
                    <scope line="1380">
                        <declaration name="bytes" type="byte[]" line="1381"/>
                        <declaration name="sourceEncoding" type="String" line="1383"/>
                    </scope>
                </scope>
                <scope line="1390">
                    <declaration name="mo" type="Object" line="1391"/>
                    <declaration name="oos" type="ObjectOutputStream" line="1392"/>
                </scope>
                <scope line="1397">
                    <declaration name="oos" type="ObjectOutputStream" line="1398"/>
                </scope>
                <scope line="1402"/>
                <declaration name="ret" type="byte[]" line="1406"/>
            </method>
            <method name="convertFileListToBytes" type="ByteArrayOutputStream" line="1411"/>
            <method name="removeSuspectedData" type="String" line="1415">
                <params>
                    <param name="flavor" type="DataFlavor"/>
                    <param name="contents" type="Transferable"/>
                    <param name="str" type="String"/>
                </params>
                <scope line="1418"/>
                <declaration name="ret_val" type="String" line="1423"/>
                <declaration name="userProtectionDomain" type="ProtectionDomain" line="1424"/>
                <scope line="1426">
                    <anonymous_class line="1427">
                        <method name="run" type="Object" line="1428">
                            <declaration name="allowedFiles" type="StringBuffer" line="1430"/>
                            <declaration name="uriArray" type="String[]" line="1431"/>
                            <scope line="1434">
                                <declaration name="file" type="File" line="1435"/>
                                <scope line="1439">
                                    <scope line="1442"/>
                                </scope>
                            </scope>
                        </method>
                    </anonymous_class>
                </scope>
                <scope line="1453"/>
            </method>
            <method name="getUserProtectionDomain" type="ProtectionDomain" line="1460">
                <params>
                    <param name="contents" type="Transferable"/>
                </params>
            </method>
            <method name="isForbiddenToRead" type="boolean" line="1465">
                <params>
                    <param name="file" type="File"/>
                    <param name="protectionDomain" type="ProtectionDomain"/>
                </params>
                <scope line="1466"/>
                <scope line="1469">
                    <declaration name="filePermission" type="FilePermission" line="1470"/>
                    <scope line="1472"/>
                </scope>
                <scope line="1475"/>
            </method>
            <method name="castToFiles" type="ArrayList<String>" line="1482">
                <params>
                    <param name="files" type="List"/>
                    <param name="userProtectionDomain" type="ProtectionDomain"/>
                </params>
                <declaration name="fileList" type="ArrayList&lt;String&gt;" line="1483"/>
                <scope line="1484">
                    <anonymous_class line="1485">
                        <method name="run" type="Object" line="1486">
                            <scope line="1488">
                                <declaration name="file" type="File" line="1489"/>
                                <scope line="1494"/>
                            </scope>
                        </method>
                    </anonymous_class>
                </scope>
                <scope line="1501"/>
            </method>
            <method name="castToFile" type="File" line="1509">
                <params>
                    <param name="fileObject" type="Object"/>
                </params>
                <declaration name="filePath" type="String" line="1510"/>
                <scope line="1511"/>
                <scope line="1513"/>
                <scope line="1515"/>
            </method>
            <declaration name="DEPLOYMENT_CACHE_PROPERTIES" type="String[]" line="1521"/>
            <declaration name="deploymentCacheDirectoryList" type="ArrayList&lt;File&gt;" line="1528"/>
            <method name="isFileInWebstartedCache" type="boolean" line="1531">
                <params>
                    <param name="f" type="File"/>
                </params>
                <scope line="1533">
                    <scope line="1534">
                        <declaration name="cacheDirectoryPath" type="String" line="1535"/>
                        <scope line="1536">
                            <scope line="1537">
                                <declaration name="cacheDirectory" type="File" line="1538"/>
                                <scope line="1539"/>
                            </scope>
                            <scope line="1542"/>
                        </scope>
                    </scope>
                </scope>
                <scope line="1547">
                    <scope line="1548">
                        <scope line="1549"/>
                    </scope>
                </scope>
            </method>
            <method name="translateBytes" type="Object" line="1562">
                <params>
                    <param name="bytes" type="byte[]"/>
                    <param name="flavor" type="DataFlavor"/>
                    <param name="format" type="long"/>
                    <param name="localeTransferable" type="Transferable"/>
                </params>
            </method>
            <method name="translateStream" type="Object" line="1570">
                <params>
                    <param name="str" type="InputStream"/>
                    <param name="flavor" type="DataFlavor"/>
                    <param name="format" type="long"/>
                    <param name="localeTransferable" type="Transferable"/>
                </params>
            </method>
            <javadoc line="1576">
                Primary translation function for translating either a byte array or
                  an InputStream into an Object, given a source format and a target
                  DataFlavor.
                  One of str/bytes is non-null; the other is null.
                  The conversion from byte[] to InputStream is cheap, so do that
                  immediately if necessary. The opposite conversion is expensive,
                  so avoid it if possible.                
            </javadoc>
            <method name="translateBytesOrStream" type="Object" line="1590">
                <params>
                    <param name="str" type="InputStream"/>
                    <param name="bytes" type="byte[]"/>
                    <param name="flavor" type="DataFlavor"/>
                    <param name="format" type="long"/>
                    <param name="localeTransferable" type="Transferable"/>
                </params>
                <comment line="1597">
                    Source data is a file list. Use the dragQueryFile native function to
                     do most of the decoding. Then wrap File objects around the String
                     filenames and return a List.                    
                </comment>
                <comment line="1613">
                    Convert the strings to File objects                    
                </comment>
                <comment line="1620">
                    Turn the list of Files into a List and return                    
                </comment>
                <comment line="1623">
                    Source data is a URI list. Convert to DataFlavor.javaFileListFlavor
                     where possible.                    
                </comment>
                <comment line="1636">
                    When converting from URIs to less generic files,
                     common practice (Wine, SWT) seems to be to
                     silently drop the URIs that aren&apos;t local files.                    
                </comment>
                <comment line="1646">
                    Target data is a String. Strip terminating NUL bytes. Decode bytes
                     into characters. Search-and-replace EOLN.                    
                </comment>
                <comment line="1655">
                    Special hack to maintain backwards-compatibility with the brokenness
                     of StringSelection. Return a StringReader instead of an InputStream.
                     Recur to obtain String and encapsulate.                    
                </comment>
                <comment line="1663">
                    Target data is an InputStream. For arbitrary flavors, just return
                     the raw bytes. For text flavors, decode to strip terminators and
                     search-and-replace EOLN, then reencode according to the requested
                     flavor.                    
                </comment>
                <comment line="1671">
                    Target data is a Reader. Obtain data in InputStream format, encoded
                     as &quot;Unicode&quot; (utf-16be). Then use an InputStreamReader to decode
                     back to chars on demand.                    
                </comment>
                <comment line="1690">
                    Target data is a CharBuffer. Recur to obtain String and wrap.                    
                </comment>
                <comment line="1703">
                    Target data is a char array. Recur to obtain String and convert to
                     char array.                    
                </comment>
                <comment line="1715">
                    Target data is a ByteBuffer. For arbitrary flavors, just return
                     the raw bytes. For text flavors, convert to a String to strip
                     terminators and search-and-replace EOLN, then reencode according to
                     the requested flavor.                    
                </comment>
                <comment line="1736">
                    Target data is a byte array. For arbitrary flavors, just return
                     the raw bytes. For text flavors, convert to a String to strip
                     terminators and search-and-replace EOLN, then reencode according to
                     the requested flavor.                    
                </comment>
                <comment line="1752">
                    Target data is an RMI object                    
                </comment>
                <comment line="1765">
                    Target data is Serializable                    
                </comment>
                <comment line="1778">
                    Target data is Image                    
                </comment>
                <scope line="1592"/>
                <scope line="1599">
                    <scope line="1600"/>
                    <scope line="1603"/>
                    <declaration name="filenames" type="String[]" line="1606"/>
                    <scope line="1607"/>
                    <declaration name="files" type="File[]" line="1613"/>
                    <scope line="1614"/>
                </scope>
                <scope line="1624">
                    <scope line="1625">
                        <declaration name="uris" type="URI" line="1626"/>
                        <scope line="1627"/>
                        <declaration name="files" type="ArrayList" line="1630"/>
                        <scope line="1631">
                            <scope line="1632"/>
                            <scope line="1634"/>
                        </scope>
                    </scope>
                    <scope line="1641"/>
                </scope>
                <scope line="1648"/>
                <scope line="1657"/>
                <scope line="1666"/>
                <scope line="1673">
                    <scope line="1674"/>
                    <declaration name="is" type="InputStream" line="1679"/>
                    <declaration name="unicode" type="String" line="1683"/>
                    <declaration name="reader" type="Reader" line="1685"/>
                </scope>
                <scope line="1690">
                    <scope line="1691"/>
                    <declaration name="buffer" type="CharBuffer" line="1696"/>
                </scope>
                <scope line="1704">
                    <scope line="1705"/>
                </scope>
                <scope line="1718">
                    <scope line="1719"/>
                    <scope line="1726">
                        <scope line="1727"/>
                    </scope>
                    <declaration name="buffer" type="ByteBuffer" line="1732"/>
                </scope>
                <scope line="1739">
                    <scope line="1740"/>
                    <scope line="1747"/>
                </scope>
                <scope line="1752">
                    <scope line="1753">
                        <declaration name="ba" type="byte[]" line="1754"/>
                        <declaration name="ois" type="ObjectInputStream" line="1755"/>
                        <declaration name="ret" type="Object" line="1756"/>
                    </scope>
                    <scope line="1760"/>
                </scope>
                <scope line="1765">
                    <scope line="1766">
                        <declaration name="ba" type="byte[]" line="1767"/>
                        <declaration name="ois" type="ObjectInputStream" line="1768"/>
                        <declaration name="ret" type="Object" line="1769"/>
                    </scope>
                    <scope line="1773"/>
                </scope>
                <scope line="1778">
                    <scope line="1779"/>
                    <declaration name="image" type="Image" line="1783"/>
                </scope>
            </method>
            <javadoc line="1791">
                For arbitrary flavors, just use the raw InputStream. For text flavors,
                  ReencodingInputStream will decode and reencode the InputStream on demand
                  so that we can strip terminators and search-and-replace EOLN.                
            </javadoc>
            <method name="translateBytesOrStreamToInputStream" type="Object" line="1799">
                <params>
                    <param name="str" type="InputStream"/>
                    <param name="flavor" type="DataFlavor"/>
                    <param name="format" type="long"/>
                    <param name="localeTransferable" type="Transferable"/>
                </params>
                <scope line="1800"/>
            </method>
            <javadoc line="1809">
                We support representations which are exactly of the specified Class,
                  and also arbitrary Objects which have a constructor which takes an
                  instance of the Class as its sole parameter.                
            </javadoc>
            <method name="constructFlavoredObject" type="Object" line="1817">
                <params>
                    <param name="arg" type="Object"/>
                    <param name="flavor" type="DataFlavor"/>
                    <param name="clazz" type="Class"/>
                </params>
                <comment line="1822">
                    simple case                    
                </comment>
                <declaration name="dfrc" type="Class" line="1818"/>
                <scope line="1820"/>
                <scope line="1822">
                    <declaration name="constructors" type="Constructor[]" line="1823"/>
                    <scope line="1825">
                        <anonymous_class line="1827">
                            <method name="run" type="Object" line="1828"/>
                        </anonymous_class>
                    </scope>
                    <scope line="1832"/>
                    <declaration name="constructor" type="Constructor" line="1836"/>
                    <scope line="1838">
                        <scope line="1839"/>
                        <declaration name="ptypes" type="Class[]" line="1843"/>
                        <scope line="1846"/>
                    </scope>
                    <scope line="1852"/>
                    <scope line="1857"/>
                    <scope line="1859"/>
                </scope>
            </method>
            <class name="ReencodingInputStream" line="1865">
                <extends class="InputStream"/>
                <javadoc line="1865">
                    Used for decoding and reencoding an InputStream on demand so that we
                      can strip NUL terminators and perform EOLN search-and-replace.                    
                </javadoc>
                <declaration name="wrapped" type="BufferedReader" line="1870"/>
                <declaration name="in" type="char[]" line="1871"/>
                <declaration name="out" type="byte[]" line="1872"/>
                <declaration name="encoder" type="CharsetEncoder" line="1874"/>
                <declaration name="inBuf" type="CharBuffer" line="1875"/>
                <declaration name="outBuf" type="ByteBuffer" line="1876"/>
                <declaration name="eoln" type="char[]" line="1878"/>
                <declaration name="numTerminators" type="int" line="1879"/>
                <declaration name="eos" type="boolean" line="1881"/>
                <declaration name="index" type="int" line="1882"/>
                <method name="ReencodingInputStream" type="constructor" line="1888">
                    <params>
                        <param name="bytestream" type="InputStream"/>
                        <param name="format" type="long"/>
                        <param name="targetEncoding" type="String"/>
                        <param name="localeTransferable" type="Transferable"/>
                    </params>
                    <comment line="1909">
                        Only happens when we have a custom text type.                        
                    </comment>
                    <comment line="1916">
                        Throw NullPointerException for compatibility with the former
                         call to sun.io.CharToByteConverter.getConverter(null)
                         (Charset.forName(null) throws unspecified IllegalArgumentException
                         now; see 6228568)                        
                    </comment>
                    <comment line="1941">
                        A hope and a prayer that this works generically. This will
                         definitely work on Win32.                        
                    </comment>
                    <declaration name="lFormat" type="Long" line="1889"/>
                    <declaration name="sourceEncoding" type="String" line="1891"/>
                    <scope line="1896">
                        <scope line="1897"/>
                        <scope line="1901"/>
                    </scope>
                    <scope line="1903"/>
                    <scope line="1907"/>
                    <scope line="1914"/>
                    <scope line="1922"/>
                    <scope line="1927"/>
                    <scope line="1929"/>
                    <scope line="1931"/>
                    <declaration name="sEoln" type="String" line="1935"/>
                    <scope line="1936"/>
                    <declaration name="terminators" type="Integer" line="1942"/>
                    <scope line="1943"/>
                </method>
                <method name="read" type="int" line="1948">
                    <comment line="1957">
                        -1 is EOS                        
                    </comment>
                    <comment line="1962">
                        &quot;c == 0&quot; is not quite correct, but good enough on Windows.                        
                    </comment>
                    <scope line="1949"/>
                    <scope line="1953">
                        <declaration name="c" type="int" line="1954"/>
                        <scope line="1956"/>
                        <scope line="1962"/>
                        <scope line="1965"/>
                    </scope>
                    <scope line="1980"/>
                </method>
                <method name="available" type="int" line="1985"/>
                <method name="close" type="void" line="1989"/>
                <javadoc line="1993">
                    Checks to see if the next array.length characters in wrapped
                      match array. The first character is provided as c. Subsequent
                      characters are read from wrapped itself. When this method returns,
                      the wrapped index may be different from what it was when this
                      method was called.                    
                </javadoc>
                <method name="matchCharArray" type="boolean" line="2002">
                    <params>
                        <param name="array" type="char[]"/>
                        <param name="c" type="int"/>
                    </params>
                    <comment line="2004">
                        BufferedReader supports mark                        
                    </comment>
                    <declaration name="count" type="int" line="2005"/>
                    <scope line="2006">
                        <scope line="2007">
                            <scope line="2009"/>
                        </scope>
                    </scope>
                    <scope line="2015"/>
                    <scope line="2017"/>
                </method>
            </class>
            <method name="dragQueryFile" type="String[]" line="2024"/>
            <javadoc line="2024">
                Decodes a byte array into a set of String filenames.                
            </javadoc>
            <javadoc line="2029">
                Decodes URIs from either a byte array or a stream.                
            </javadoc>
            <method name="dragQueryURIs" type="URI[]" line="2037">
                <params>
                    <param name="stream" type="InputStream"/>
                    <param name="bytes" type="byte[]"/>
                    <param name="format" type="long"/>
                    <param name="localeTransferable" type="Transferable"/>
                </params>
            </method>
            <method name="platformImageBytesOrStreamToImage" type="Image" line="2042"/>
            <javadoc line="2042">
                Translates either a byte array or an input stream which contain
                  platform-specific image data in the given format into an Image.                
            </javadoc>
            <javadoc line="2051">
                Translates either a byte array or an input stream which contain
                  an image data in the given standard format into an Image.                
                <param>
                    mimeType image MIME type, such as: image/png, image/jpeg, image/gif                    
                </param>
            </javadoc>
            <method name="standardImageBytesOrStreamToImage" type="Image" line="2060">
                <params>
                    <param name="inputStream" type="InputStream"/>
                    <param name="bytes" type="byte[]"/>
                    <param name="mimeType" type="String"/>
                </params>
                <scope line="2061"/>
                <declaration name="readerIterator" type="Iterator" line="2065"/>
                <scope line="2067"/>
                <declaration name="ioe" type="IOException" line="2072"/>
                <scope line="2074">
                    <declaration name="imageReader" type="ImageReader" line="2075"/>
                    <scope line="2076">
                        <declaration name="imageInputStream" type="ImageInputStream" line="2077"/>
                        <scope line="2080">
                            <declaration name="param" type="ImageReadParam" line="2081"/>
                            <declaration name="bufferedImage" type="BufferedImage" line="2083"/>
                            <scope line="2085"/>
                        </scope>
                        <scope line="2088"/>
                    </scope>
                    <scope line="2092"/>
                </scope>
                <scope line="2098"/>
            </method>
            <method name="imageToPlatformBytes" type="byte[]" line="2106"/>
            <javadoc line="2106">
                Translates a Java Image into a byte array which contains platform-
                  specific image data in the given format.                
            </javadoc>
            <javadoc line="2113">
                Translates a Java Image into a byte array which contains
                  an image data in the given standard format.                
                <param>
                    mimeType image MIME type, such as: image/png, image/jpeg                    
                </param>
            </javadoc>
            <method name="imageToStandardBytes" type="byte[]" line="2120">
                <params>
                    <param name="image" type="Image"/>
                    <param name="mimeType" type="String"/>
                </params>
                <comment line="2132">
                    Try to encode the original image.                    
                </comment>
                <comment line="2140">
                    Retry with a BufferedImage.                    
                </comment>
                <declaration name="originalIOE" type="IOException" line="2121"/>
                <declaration name="writerIterator" type="Iterator" line="2123"/>
                <scope line="2125"/>
                <scope line="2130">
                    <scope line="2132"/>
                    <scope line="2134"/>
                </scope>
                <declaration name="width" type="int" line="2140"/>
                <declaration name="height" type="int" line="2141"/>
                <scope line="2142">
                    <declaration name="ir" type="ImageRepresentation" line="2143"/>
                </scope>
                <scope line="2147"/>
                <declaration name="model" type="ColorModel" line="2152"/>
                <declaration name="raster" type="WritableRaster" line="2153"/>
                <declaration name="bufferedImage" type="BufferedImage" line="2156"/>
                <declaration name="g" type="Graphics" line="2160"/>
                <scope line="2161"/>
                <scope line="2163"/>
                <scope line="2167"/>
                <scope line="2169">
                    <scope line="2170"/>
                    <scope line="2172"/>
                </scope>
            </method>
            <method name="imageToStandardBytesImpl" type="byte[]" line="2180">
                <params>
                    <param name="renderedImage" type="RenderedImage"/>
                    <param name="mimeType" type="String"/>
                </params>
                <declaration name="writerIterator" type="Iterator" line="2182"/>
                <declaration name="typeSpecifier" type="ImageTypeSpecifier" line="2184"/>
                <declaration name="baos" type="ByteArrayOutputStream" line="2187"/>
                <declaration name="ioe" type="IOException" line="2188"/>
                <scope line="2190">
                    <declaration name="imageWriter" type="ImageWriter" line="2191"/>
                    <declaration name="writerSpi" type="ImageWriterSpi" line="2192"/>
                    <scope line="2194"/>
                    <scope line="2198">
                        <declaration name="imageOutputStream" type="ImageOutputStream" line="2199"/>
                        <scope line="2201"/>
                        <scope line="2205"/>
                    </scope>
                    <scope line="2208"/>
                </scope>
                <scope line="2222"/>
            </method>
            <javadoc line="2230">
                Concatenates the data represented by two objects. Objects can be either
                  byte arrays or instances of &lt;code&gt;InputStream&lt;/code&gt;. If both arguments
                  are byte arrays byte array will be returned. Otherwise an
                  &lt;code&gt;InputStream&lt;/code&gt; will be returned.
                  &lt;p&gt;
                  Currently is only called from native code to prepend palette data to
                  platform-specific image data during image transfer on Win32.                
                <param>
                    obj1 the first object to be concatenated.                    
                </param>
                <param>
                    obj2 the second object to be concatenated.                    
                </param>
                <return>
                    a byte array or an <code>InputStream</code> which represents
                      a logical concatenation of the two arguments.                    
                </return>
                <throws>
                    NullPointerException is either of the arguments is
                      <code>null</code>                    
                </throws>
                <throws>
                    ClassCastException is either of the arguments is
                      neither byte array nor an instance of <code>InputStream</code>.                    
                </throws>
            </javadoc>
            <method name="concatData" type="Object" line="2248">
                <params>
                    <param name="obj1" type="Object"/>
                    <param name="obj2" type="Object"/>
                </params>
                <declaration name="str1" type="InputStream" line="2249"/>
                <declaration name="str2" type="InputStream" line="2250"/>
                <scope line="2252">
                    <declaration name="arr1" type="byte[]" line="2253"/>
                    <scope line="2254">
                        <declaration name="arr2" type="byte[]" line="2255"/>
                        <declaration name="ret" type="byte[]" line="2256"/>
                    </scope>
                    <scope line="2260"/>
                </scope>
                <scope line="2264">
                    <scope line="2266"/>
                    <scope line="2268"/>
                </scope>
            </method>
            <method name="convertData" type="byte[]" line="2282">
                <params>
                    <param name="source" type="Object"/>
                    <param name="contents" type="Transferable"/>
                    <param name="format" type="long"/>
                    <param name="formatMap" type="Map"/>
                    <param name="isToolkitThread" type="boolean"/>
                </params>
                <comment line="2286">
                    If the current thread is the Toolkit thread we should post a
                     Runnable to the event dispatch thread associated with source Object,
                     since translateTransferable() calls Transferable.getTransferData()
                     that may contain client code.                    
                </comment>
                <comment line="2295">
                    Guard against multiple executions.                    
                </comment>
                <declaration name="ret" type="byte[]" line="2283"/>
                <scope line="2291">
                    <declaration name="stack" type="Stack" line="2292"/>
                    <anonymous_class line="2293">
                        <declaration name="done" type="boolean" line="2295"/>
                        <method name="run" type="void" line="2296">
                            <scope line="2297"/>
                            <declaration name="data" type="byte[]" line="2300"/>
                            <scope line="2301">
                                <declaration name="flavor" type="DataFlavor" line="2302"/>
                                <scope line="2303"/>
                            </scope>
                            <scope line="2306"/>
                            <scope line="2310"/>
                            <scope line="2314"/>
                        </method>
                    </anonymous_class>
                    <declaration name="dataConverter" type="Runnable" line="2293"/>
                    <declaration name="appContext" type="AppContext" line="2321"/>
                    <scope line="2325"/>
                    <scope line="2331"/>
                    <scope line="2335"/>
                </scope>
                <scope line="2340"/>
                <scope line="2342">
                    <declaration name="flavor" type="DataFlavor" line="2343"/>
                    <scope line="2345"/>
                </scope>
            </method>
            <method name="processDataConversionRequests" type="void" line="2353">
                <scope line="2354">
                    <declaration name="appContext" type="AppContext" line="2355"/>
                    <scope line="2357">
                        <declaration name="dataConverter" type="Runnable" line="2358"/>
                        <scope line="2360"/>
                    </scope>
                    <scope line="2364"/>
                </scope>
            </method>
            <method name="getToolkitThreadBlockedHandler" type="ToolkitThreadBlockedHandler" line="2370"/>
            <javadoc line="2373">
                Helper function to reduce a Map with Long keys to a long array.
                  &lt;p&gt;
                  The map keys are sorted according to the native formats preference
                  order.                
            </javadoc>
            <method name="keysToLongArray" type="long[]" line="2379">
                <params>
                    <param name="map" type="SortedMap"/>
                </params>
                <declaration name="keySet" type="Set" line="2380"/>
                <declaration name="retval" type="long[]" line="2381"/>
                <declaration name="i" type="int" line="2382"/>
                <scope line="2383"/>
            </method>
            <javadoc line="2389">
                Helper function to reduce a Map with DataFlavor keys to a DataFlavor
                  array. The array will be sorted according to
                  &lt;code&gt;DataFlavorComparator&lt;/code&gt;.                
            </javadoc>
            <method name="keysToDataFlavorArray" type="DataFlavor[]" line="2394">
                <params>
                    <param name="map" type="Map"/>
                </params>
            </method>
            <javadoc line="2398">
                Helper function to convert a Set of DataFlavors to a sorted array.
                  The array will be sorted according to &lt;code&gt;DataFlavorComparator&lt;/code&gt;.                
            </javadoc>
            <method name="setToSortedDataFlavorArray" type="DataFlavor[]" line="2402">
                <params>
                    <param name="flavorsSet" type="Set"/>
                </params>
                <declaration name="flavors" type="DataFlavor[]" line="2403"/>
                <declaration name="comparator" type="Comparator" line="2405"/>
            </method>
            <javadoc line="2411">
                Helper function to convert a Set of DataFlavors to a sorted array.
                  The array will be sorted according to a
                  &lt;code&gt;DataFlavorComparator&lt;/code&gt; created with the specified
                  flavor-to-native map as an argument.                
            </javadoc>
            <method name="setToSortedDataFlavorArray" type="DataFlavor[]" line="2419">
                <params>
                    <param name="flavorsSet" type="Set"/>
                    <param name="flavorToNativeMap" type="Map"/>
                </params>
                <declaration name="flavors" type="DataFlavor[]" line="2420"/>
                <declaration name="comparator" type="Comparator" line="2422"/>
            </method>
            <javadoc line="2429">
                Helper function to convert an InputStream to a byte[] array.                
            </javadoc>
            <method name="inputStreamToByteArray" type="byte[]" line="2434">
                <params>
                    <param name="str" type="InputStream"/>
                </params>
                <declaration name="baos" type="ByteArrayOutputStream" line="2435"/>
                <declaration name="len" type="int" line="2436"/>
                <declaration name="buf" type="byte[]" line="2437"/>
                <scope line="2439"/>
            </method>
            <javadoc line="2446">
                Returns platform-specific mappings for the specified native.
                  If there are no platform-specific mappings for this native, the method
                  returns an empty &lt;code&gt;List&lt;/code&gt;.                
            </javadoc>
            <method name="getPlatformMappingsForNative" type="List" line="2451">
                <params>
                    <param name="nat" type="String"/>
                </params>
            </method>
            <javadoc line="2455">
                Returns platform-specific mappings for the specified flavor.
                  If there are no platform-specific mappings for this flavor, the method
                  returns an empty &lt;code&gt;List&lt;/code&gt;.                
            </javadoc>
            <method name="getPlatformMappingsForFlavor" type="List" line="2460">
                <params>
                    <param name="df" type="DataFlavor"/>
                </params>
            </method>
            <class name="IndexedComparator" line="2464">
                <implements interface="Comparator"/>
                <javadoc line="2464">
                    A Comparator which includes a helper function for comparing two Objects
                      which are likely to be keys in the specified Map.                    
                </javadoc>
                <declaration name="SELECT_BEST" type="boolean" line="2470"/>
                <javadoc line="2470">
                    The best Object (e.g., DataFlavor) will be the last in sequence.                    
                </javadoc>
                <declaration name="SELECT_WORST" type="boolean" line="2475"/>
                <javadoc line="2475">
                    The best Object (e.g., DataFlavor) will be the first in sequence.                    
                </javadoc>
                <declaration name="order" type="boolean" line="2480"/>
                <method name="IndexedComparator" type="constructor" line="2482"/>
                <method name="IndexedComparator" type="constructor" line="2486">
                    <params>
                        <param name="order" type="boolean"/>
                    </params>
                </method>
                <javadoc line="2490">
                    Helper method to compare two objects by their Integer indices in the
                      given map. If the map doesn&apos;t contain an entry for either of the
                      objects, the fallback index will be used for the object instead.                    
                    <param>
                        indexMap the map which maps objects into Integer indexes.                        
                    </param>
                    <param>
                        obj1 the first object to be compared.                        
                    </param>
                    <param>
                        obj2 the second object to be compared.                        
                    </param>
                    <param>
                        fallbackIndex the Integer to be used as a fallback index.                        
                    </param>
                    <return>
                        a negative integer, zero, or a positive integer as the
                          first object is mapped to a less, equal to, or greater
                          index than the second.                        
                    </return>
                </javadoc>
                <method name="compareIndices" type="int" line="2505">
                    <params>
                        <param name="indexMap" type="Map"/>
                        <param name="obj1" type="Object"/>
                        <param name="obj2" type="Object"/>
                        <param name="fallbackIndex" type="Integer"/>
                    </params>
                    <declaration name="index1" type="Integer" line="2506"/>
                    <declaration name="index2" type="Integer" line="2507"/>
                    <scope line="2509"/>
                    <scope line="2512"/>
                </method>
                <javadoc line="2519">
                    Helper method to compare two objects by their Long indices in the
                      given map. If the map doesn&apos;t contain an entry for either of the
                      objects, the fallback index will be used for the object instead.                    
                    <param>
                        indexMap the map which maps objects into Long indexes.                        
                    </param>
                    <param>
                        obj1 the first object to be compared.                        
                    </param>
                    <param>
                        obj2 the second object to be compared.                        
                    </param>
                    <param>
                        fallbackIndex the Long to be used as a fallback index.                        
                    </param>
                    <return>
                        a negative integer, zero, or a positive integer as the
                          first object is mapped to a less, equal to, or greater
                          index than the second.                        
                    </return>
                </javadoc>
                <method name="compareLongs" type="int" line="2534">
                    <params>
                        <param name="indexMap" type="Map"/>
                        <param name="obj1" type="Object"/>
                        <param name="obj2" type="Object"/>
                        <param name="fallbackIndex" type="Long"/>
                    </params>
                    <declaration name="index1" type="Long" line="2535"/>
                    <declaration name="index2" type="Long" line="2536"/>
                    <scope line="2538"/>
                    <scope line="2541"/>
                </method>
            </class>
            <class name="CharsetComparator" line="2549">
                <extends class="IndexedComparator"/>
                <javadoc line="2549">
                    An IndexedComparator which compares two String charsets. The comparison
                      follows the rules outlined in DataFlavor.selectBestTextFlavor. In order
                      to ensure that non-Unicode, non-ASCII, non-default charsets are sorted
                      in alphabetical order, charsets are not automatically converted to their
                      canonical forms.                    
                </javadoc>
                <declaration name="charsets" type="Map" line="2557"/>
                <declaration name="defaultEncoding" type="String" line="2558"/>
                <declaration name="DEFAULT_CHARSET_INDEX" type="Integer" line="2560"/>
                <declaration name="OTHER_CHARSET_INDEX" type="Integer" line="2561"/>
                <declaration name="WORST_CHARSET_INDEX" type="Integer" line="2562"/>
                <declaration name="UNSUPPORTED_CHARSET_INDEX" type="Integer" line="2563"/>
                <declaration name="UNSUPPORTED_CHARSET" type="String" line="2566"/>
                <scope line="2568">
                    <declaration name="charsetsMap" type="HashMap" line="2569"/>
                    <declaration name="defEncoding" type="String" line="2580"/>
                    <scope line="2583"/>
                </scope>
                <method name="CharsetComparator" type="constructor" line="2591"/>
                <method name="CharsetComparator" type="constructor" line="2595">
                    <params>
                        <param name="order" type="boolean"/>
                    </params>
                </method>
                <javadoc line="2599">
                    Compares two String objects. Returns a negative integer, zero,
                      or a positive integer as the first charset is worse than, equal to,
                      or better than the second.                    
                    <param>
                        obj1 the first charset to be compared                        
                    </param>
                    <param>
                        obj2 the second charset to be compared                        
                    </param>
                    <return>
                        a negative integer, zero, or a positive integer as the
                          first argument is worse, equal to, or better than the
                          second.                        
                    </return>
                    <throws>
                        ClassCastException if either of the arguments is not
                          instance of String                        
                    </throws>
                    <throws>
                        NullPointerException if either of the arguments is
                          <code>null</code>.                        
                    </throws>
                </javadoc>
                <method name="compare" type="int" line="2614">
                    <params>
                        <param name="obj1" type="Object"/>
                        <param name="obj2" type="Object"/>
                    </params>
                    <declaration name="charset1" type="String" line="2615"/>
                    <declaration name="charset2" type="String" line="2616"/>
                    <scope line="2617"/>
                    <scope line="2620"/>
                </method>
                <javadoc line="2628">
                    Compares charsets. Returns a negative integer, zero, or a positive
                      integer as the first charset is worse than, equal to, or better than
                      the second.
                      &lt;p&gt;
                      Charsets are ordered according to the following rules:
                      &lt;ul&gt;
                      &lt;li&gt;All unsupported charsets are equal.
                      &lt;li&gt;Any unsupported charset is worse than any supported charset.
                      &lt;li&gt;Unicode charsets, such as &quot;UTF-16&quot;, &quot;UTF-8&quot;, &quot;UTF-16BE&quot; and
                      &quot;UTF-16LE&quot;, are considered best.
                      &lt;li&gt;After them, platform default charset is selected.
                      &lt;li&gt;&quot;US-ASCII&quot; is the worst of supported charsets.
                      &lt;li&gt;For all other supported charsets, the lexicographically less
                      one is considered the better.
                      &lt;/ul&gt;                    
                    <param>
                        charset1 the first charset to be compared                        
                    </param>
                    <param>
                        charset2 the second charset to be compared.                        
                    </param>
                    <return>
                        a negative integer, zero, or a positive integer as the
                          first argument is worse, equal to, or better than the
                          second.                        
                    </return>
                </javadoc>
                <method name="compareCharsets" type="int" line="2651">
                    <params>
                        <param name="charset1" type="String"/>
                        <param name="charset2" type="String"/>
                    </params>
                    <declaration name="comp" type="int" line="2655"/>
                    <scope line="2658"/>
                </method>
                <javadoc line="2665">
                    Returns encoding for the specified charset according to the
                      following rules:
                      &lt;ul&gt;
                      &lt;li&gt;If the charset is &lt;code&gt;null&lt;/code&gt;, then &lt;code&gt;null&lt;/code&gt; will
                      be returned.
                      &lt;li&gt;Iff the charset specifies an encoding unsupported by this JRE,
                      &lt;code&gt;UNSUPPORTED_CHARSET&lt;/code&gt; will be returned.
                      &lt;li&gt;If the charset specifies an alias name, the corresponding
                      canonical name will be returned iff the charset is a known
                      Unicode, ASCII, or default charset.
                      &lt;/ul&gt;                    
                    <param>
                        charset the charset.                        
                    </param>
                    <return>
                        an encoding for this charset.                        
                    </return>
                </javadoc>
                <method name="getEncoding" type="String" line="2681">
                    <params>
                        <param name="charset" type="String"/>
                    </params>
                    <comment line="2688">
                        Only convert to canonical form if the charset is one
                         of the charsets explicitly listed in the known charsets
                         map. This will happen only for Unicode, ASCII, or default
                         charsets.                        
                    </comment>
                    <scope line="2682"/>
                    <scope line="2684"/>
                    <scope line="2686">
                        <declaration name="canonicalName" type="String" line="2691"/>
                    </scope>
                </method>
            </class>
            <class name="DataFlavorComparator" line="2699">
                <extends class="IndexedComparator"/>
                <javadoc line="2699">
                    An IndexedComparator which compares two DataFlavors. For text flavors,
                      the comparison follows the rules outlined in
                      DataFlavor.selectBestTextFlavor. For non-text flavors, unknown
                      application MIME types are preferred, followed by known
                      application/x-java- MIME types. Unknown application types are preferred
                      because if the user provides his own data flavor, it will likely be the
                      most descriptive one. For flavors which are otherwise equal, the
                      flavors&apos; native formats are compared, with greater long values
                      taking precedence.                    
                </javadoc>
                <declaration name="flavorToFormatMap" type="Map" line="2711"/>
                <declaration name="charsetComparator" type="CharsetComparator" line="2713"/>
                <declaration name="exactTypes" type="Map" line="2715"/>
                <declaration name="primaryTypes" type="Map" line="2716"/>
                <declaration name="nonTextRepresentations" type="Map" line="2717"/>
                <declaration name="textTypes" type="Map" line="2718"/>
                <declaration name="decodedTextRepresentations" type="Map" line="2719"/>
                <declaration name="encodedTextRepresentations" type="Map" line="2720"/>
                <declaration name="UNKNOWN_OBJECT_LOSES" type="Integer" line="2722"/>
                <declaration name="UNKNOWN_OBJECT_WINS" type="Integer" line="2724"/>
                <declaration name="UNKNOWN_OBJECT_LOSES_L" type="Long" line="2727"/>
                <declaration name="UNKNOWN_OBJECT_WINS_L" type="Long" line="2729"/>
                <scope line="2732">
                    <scope line="2733">
                        <declaration name="exactTypesMap" type="HashMap" line="2734"/>
                    </scope>
                    <scope line="2749">
                        <declaration name="primaryTypesMap" type="HashMap" line="2750"/>
                    </scope>
                    <scope line="2757">
                        <declaration name="nonTextRepresentationsMap" type="HashMap" line="2758"/>
                        <declaration name="remoteClass" type="Class&lt;?&gt;" line="2765"/>
                        <scope line="2766"/>
                    </scope>
                    <scope line="2775">
                        <declaration name="textTypesMap" type="HashMap" line="2776"/>
                    </scope>
                    <scope line="2808">
                        <declaration name="decodedTextRepresentationsMap" type="HashMap" line="2809"/>
                    </scope>
                    <scope line="2824">
                        <declaration name="encodedTextRepresentationsMap" type="HashMap" line="2825"/>
                    </scope>
                </scope>
                <method name="DataFlavorComparator" type="constructor" line="2839"/>
                <method name="DataFlavorComparator" type="constructor" line="2843">
                    <params>
                        <param name="order" type="boolean"/>
                    </params>
                </method>
                <method name="DataFlavorComparator" type="constructor" line="2850">
                    <params>
                        <param name="map" type="Map"/>
                    </params>
                </method>
                <method name="DataFlavorComparator" type="constructor" line="2854">
                    <params>
                        <param name="map" type="Map"/>
                        <param name="order" type="boolean"/>
                    </params>
                    <declaration name="hashMap" type="HashMap" line="2858"/>
                </method>
                <method name="compare" type="int" line="2863">
                    <params>
                        <param name="obj1" type="Object"/>
                        <param name="obj2" type="Object"/>
                    </params>
                    <comment line="2892">
                        First, compare MIME types                        
                    </comment>
                    <comment line="2899">
                        Only need to test one flavor because they both have the
                         same MIME type. Also don&apos;t need to worry about accidentally
                         passing stringFlavor because either
                           1. Both flavors are stringFlavor, in which case the
                              equality test at the top of the function succeeded.
                           2. Only one flavor is stringFlavor, in which case the MIME
                              type comparison returned a non-zero value.                        
                    </comment>
                    <comment line="2907">
                        Next, prefer the decoded text representations of Reader,
                         String, CharBuffer, and [C, in that order.                        
                    </comment>
                    <comment line="2915">
                        Next, compare charsets                        
                    </comment>
                    <comment line="2924">
                        Finally, prefer the encoded text representations of
                         InputStream, ByteBuffer, and [B, in that order.                        
                    </comment>
                    <comment line="2932">
                        First, prefer application types.                        
                    </comment>
                    <comment line="2939">
                        Next, look for application/x-java-* types. Prefer unknown
                         MIME types because if the user provides his own data flavor,
                         it will likely be the most descriptive one.                        
                    </comment>
                    <comment line="2948">
                        Finally, prefer the representation classes of Remote,
                         Serializable, and InputStream, in that order.                        
                    </comment>
                    <comment line="2957">
                        As a last resort, take the DataFlavor with the greater integer
                         format.                        
                    </comment>
                    <declaration name="flavor1" type="DataFlavor" line="2864"/>
                    <declaration name="flavor2" type="DataFlavor" line="2865"/>
                    <scope line="2866"/>
                    <scope line="2869"/>
                    <scope line="2874"/>
                    <declaration name="comp" type="int" line="2878"/>
                    <declaration name="primaryType1" type="String" line="2880"/>
                    <declaration name="subType1" type="String" line="2881"/>
                    <declaration name="mimeType1" type="String" line="2882"/>
                    <declaration name="class1" type="Class" line="2883"/>
                    <declaration name="primaryType2" type="String" line="2885"/>
                    <declaration name="subType2" type="String" line="2886"/>
                    <declaration name="mimeType2" type="String" line="2887"/>
                    <declaration name="class2" type="Class" line="2888"/>
                    <scope line="2890">
                        <scope line="2894"/>
                        <scope line="2905">
                            <scope line="2910"/>
                            <scope line="2918"/>
                        </scope>
                        <scope line="2927"/>
                    </scope>
                    <scope line="2930">
                        <scope line="2934"/>
                        <scope line="2943"/>
                        <scope line="2951"/>
                    </scope>
                </method>
            </class>
            <class name="IndexOrderComparator" line="2976">
                <extends class="IndexedComparator"/>
                <declaration name="indexMap" type="Map" line="2977"/>
                <declaration name="FALLBACK_INDEX" type="Integer" line="2978"/>
                <method name="IndexOrderComparator" type="constructor" line="2981">
                    <params>
                        <param name="indexMap" type="Map"/>
                    </params>
                </method>
                <method name="IndexOrderComparator" type="constructor" line="2986">
                    <params>
                        <param name="indexMap" type="Map"/>
                        <param name="order" type="boolean"/>
                    </params>
                </method>
                <method name="compare" type="int" line="2991">
                    <params>
                        <param name="obj1" type="Object"/>
                        <param name="obj2" type="Object"/>
                    </params>
                    <scope line="2992"/>
                    <scope line="2994"/>
                </method>
            </class>
            <class name="RMI" line="3000">
                <javadoc line="3000">
                    A class that provides access to java.rmi.Remote and java.rmi.MarshalledObject
                      without creating a static dependency.                    
                </javadoc>
                <declaration name="remoteClass" type="Class&lt;?&gt;" line="3005"/>
                <declaration name="marshallObjectClass" type="Class&lt;?&gt;" line="3006"/>
                <declaration name="marshallCtor" type="Constructor&lt;?&gt;" line="3008"/>
                <declaration name="marshallGet" type="Method" line="3010"/>
                <method name="getClass" type="Class<?>" line="3013">
                    <params>
                        <param name="name" type="String"/>
                    </params>
                    <scope line="3014"/>
                    <scope line="3016"/>
                </method>
                <method name="getConstructor" type="Constructor<?>" line="3021">
                    <params>
                        <param name="c" type="Class<?>"/>
                        <param name="types" type="Class<?>"/>
                    </params>
                    <scope line="3022"/>
                    <scope line="3024"/>
                </method>
                <method name="getMethod" type="Method" line="3029">
                    <params>
                        <param name="c" type="Class<?>"/>
                        <param name="name" type="String"/>
                        <param name="types" type="Class<?>"/>
                    </params>
                    <scope line="3030"/>
                    <scope line="3032"/>
                </method>
                <javadoc line="3037">
                    Returns {@code true} if the given class is java.rmi.Remote.                    
                </javadoc>
                <method name="isRemote" type="boolean" line="3040">
                    <params>
                        <param name="c" type="Class<?>"/>
                    </params>
                </method>
                <javadoc line="3044">
                    Returns java.rmi.Remote.class if RMI is present; otherwise {@code null}.                    
                </javadoc>
                <method name="remoteClass" type="Class<?>" line="3047"/>
                <javadoc line="3051">
                    Returns a new MarshalledObject containing the serialized representation
                      of the given object.                    
                </javadoc>
                <method name="newMarshalledObject" type="Object" line="3055">
                    <params>
                        <param name="obj" type="Object"/>
                    </params>
                    <scope line="3056"/>
                    <scope line="3058"/>
                    <scope line="3060"/>
                    <scope line="3062">
                        <declaration name="cause" type="Throwable" line="3063"/>
                    </scope>
                </method>
                <javadoc line="3070">
                    Returns a new copy of the contained marshalled object.                    
                </javadoc>
                <method name="getMarshalledObject" type="Object" line="3075">
                    <params>
                        <param name="obj" type="Object"/>
                    </params>
                    <scope line="3076"/>
                    <scope line="3078"/>
                    <scope line="3080">
                        <declaration name="cause" type="Throwable" line="3081"/>
                    </scope>
                </method>
            </class>
        </class>
    </source>