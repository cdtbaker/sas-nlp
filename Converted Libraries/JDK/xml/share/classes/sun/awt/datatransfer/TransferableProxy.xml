<?xml version="1.0" encoding="UTF-8"?>
    <source package="sun.awt.datatransfer">
        <import package="java.awt.datatransfer.DataFlavor"/>
        <import package="java.awt.datatransfer.Transferable"/>
        <import package="java.awt.datatransfer.UnsupportedFlavorException"/>
        <import package="java.io.ByteArrayInputStream"/>
        <import package="java.io.ByteArrayOutputStream"/>
        <import package="java.io.InputStream"/>
        <import package="java.io.IOException"/>
        <import package="java.io.ObjectInputStream"/>
        <import package="java.io.ObjectOutputStream"/>
        <import package="java.io.ObjectStreamClass"/>
        <import package="java.io.OutputStream"/>
        <import package="java.lang.reflect.Modifier"/>
        <import package="java.lang.reflect.Proxy"/>
        <import package="java.security.AccessController"/>
        <import package="java.security.PrivilegedAction"/>
        <import package="java.util.HashMap"/>
        <import package="java.util.HashSet"/>
        <import package="java.util.Map"/>
        <import package="java.util.Set"/>
        <class name="TransferableProxy" line="49">
            <implements interface="Transferable"/>
            <javadoc line="49">
                Proxies for another Transferable so that Serializable objects are never
                  returned directly by DnD or the Clipboard. Instead, a new instance of the
                  object is returned.                
                <author>
                    Lawrence P.G. Cable                    
                </author>
                <author>
                    David Mendenhall                    
                </author>
                <since>
                    1.4                    
                </since>
            </javadoc>
            <method name="TransferableProxy" type="constructor" line="60">
                <params>
                    <param name="t" type="Transferable"/>
                    <param name="local" type="boolean"/>
                </params>
            </method>
            <method name="getTransferDataFlavors" type="DataFlavor[]" line="64"/>
            <method name="isDataFlavorSupported" type="boolean" line="67">
                <params>
                    <param name="flavor" type="DataFlavor"/>
                </params>
            </method>
            <method name="getTransferData" type="Object" line="72">
                <params>
                    <param name="df" type="DataFlavor"/>
                </params>
                <comment line="75">
                    If the data is a Serializable object, then create a new instance                    
                </comment>
                <comment line="76">
                    before returning it. This insulates applications sharing DnD and                    
                </comment>
                <comment line="77">
                    Clipboard data from each other.                    
                </comment>
                <declaration name="data" type="Object" line="73"/>
                <scope line="78">
                    <declaration name="baos" type="ByteArrayOutputStream" line="79"/>
                    <declaration name="oos" type="ClassLoaderObjectOutputStream" line="81"/>
                    <declaration name="bais" type="ByteArrayInputStream" line="85"/>
                    <scope line="88">
                        <declaration name="ois" type="ClassLoaderObjectInputStream" line="89"/>
                    </scope>
                    <scope line="93"/>
                </scope>
            </method>
            <declaration name="transferable" type="Transferable" line="101"/>
            <declaration name="isLocal" type="boolean" line="102"/>
        </class>
        <class name="ClassLoaderObjectOutputStream" line="105">
            <extends class="ObjectOutputStream"/>
            <declaration name="map" type="Map&lt;Set&lt;String&gt;,ClassLoader&gt;" line="106"/>
            <method name="ClassLoaderObjectOutputStream" type="constructor" line="109">
                <params>
                    <param name="os" type="OutputStream"/>
                </params>
            </method>
            <method name="annotateClass" type="void" line="113">
                <params>
                    <param name="cl" type="Class<?>"/>
                </params>
                <anonymous_class line="115">
                    <method name="run" type="Object" line="116"/>
                </anonymous_class>
                <declaration name="classLoader" type="ClassLoader" line="114"/>
                <declaration name="s" type="Set&lt;String&gt;" line="121"/>
            </method>
            <method name="annotateProxyClass" type="void" line="126">
                <params>
                    <param name="cl" type="Class<?>"/>
                </params>
                <anonymous_class line="128">
                    <method name="run" type="Object" line="129"/>
                </anonymous_class>
                <declaration name="classLoader" type="ClassLoader" line="127"/>
                <declaration name="interfaces" type="Class[]" line="134"/>
                <declaration name="s" type="Set&lt;String&gt;" line="135"/>
                <scope line="136"/>
            </method>
            <method name="getClassLoaderMap" type="Map<Set<String>,ClassLoader>" line="143"/>
        </class>
        <class name="ClassLoaderObjectInputStream" line="148">
            <extends class="ObjectInputStream"/>
            <declaration name="map" type="Map&lt;Set&lt;String&gt;,ClassLoader&gt;" line="149"/>
            <method name="ClassLoaderObjectInputStream" type="constructor" line="153">
                <params>
                    <param name="is" type="InputStream"/>
                    <param name="map" type="Map<Set<String>,ClassLoader>"/>
                </params>
                <scope line="155"/>
            </method>
            <method name="resolveClass" type="Class<?>" line="162">
                <params>
                    <param name="classDesc" type="ObjectStreamClass"/>
                </params>
                <declaration name="className" type="String" line="163"/>
                <declaration name="s" type="Set&lt;String&gt;" line="165"/>
                <declaration name="classLoader" type="ClassLoader" line="168"/>
            </method>
            <method name="resolveProxyClass" type="Class<?>" line="174">
                <params>
                    <param name="interfaces" type="String[]"/>
                </params>
                <comment line="183">
                    The code below is mostly copied from the superclass.                    
                </comment>
                <comment line="187">
                    define proxy in class loader of non-public interface(s), if any                    
                </comment>
                <declaration name="s" type="Set&lt;String&gt;" line="176"/>
                <scope line="177"/>
                <declaration name="classLoader" type="ClassLoader" line="181"/>
                <declaration name="nonPublicLoader" type="ClassLoader" line="184"/>
                <declaration name="hasNonPublicInterface" type="boolean" line="185"/>
                <declaration name="classObjs" type="Class[]" line="188"/>
                <scope line="189">
                    <declaration name="cl" type="Class" line="190"/>
                    <scope line="191">
                        <scope line="192">
                            <scope line="193"/>
                        </scope>
                        <scope line="197"/>
                    </scope>
                </scope>
                <scope line="204"/>
                <scope line="208"/>
            </method>
        </class>
    </source>