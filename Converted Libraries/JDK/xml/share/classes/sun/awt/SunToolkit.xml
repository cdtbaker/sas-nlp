<?xml version="1.0" encoding="UTF-8"?>
    <source package="sun.awt">
        <import package="java.awt"/>
        <import package="java.awt.RenderingHints"/>
        <import package="java.awt.dnd"/>
        <import package="java.awt.dnd.peer.DragSourceContextPeer"/>
        <import package="java.awt.peer"/>
        <import package="java.awt.event.WindowEvent"/>
        <import package="java.awt.event.KeyEvent"/>
        <import package="java.awt.image"/>
        <import package="java.awt.TrayIcon"/>
        <import package="java.awt.SystemTray"/>
        <import package="java.net.URL"/>
        <import package="java.util"/>
        <import package="java.util.concurrent.TimeUnit"/>
        <import package="java.util.concurrent.locks.Condition"/>
        <import package="java.util.concurrent.locks.Lock"/>
        <import package="java.util.concurrent.locks.ReentrantLock"/>
        <import package="sun.util.logging.PlatformLogger"/>
        <import package="sun.misc.SoftCache"/>
        <import package="sun.font.FontDesignMetrics"/>
        <import package="sun.awt.im.InputContext"/>
        <import package="sun.awt.image"/>
        <import package="sun.security.action.GetPropertyAction"/>
        <import package="sun.security.action.GetBooleanAction"/>
        <import package="java.lang.reflect.Field"/>
        <import package="java.lang.reflect.Method"/>
        <import package="java.lang.reflect.Constructor"/>
        <import package="java.lang.reflect.InvocationTargetException"/>
        <import package="java.security.AccessController"/>
        <import package="java.security.PrivilegedAction"/>
        <import package="java.security.PrivilegedActionException"/>
        <import package="java.security.PrivilegedExceptionAction"/>
        <class name="SunToolkit" line="33">
            <extends class="Toolkit"/>
            <implements interface="WindowClosingSupport"/>
            <implements interface="WindowClosingListener"/>
            <implements interface="ComponentFactory"/>
            <implements interface="InputMethodSupport"/>
            <implements interface="KeyboardFocusManagerPeerProvider"/>
            <declaration name="log" type="PlatformLogger" line="34"/>
            <scope line="35">
                <scope line="36"/>
            </scope>
            <declaration name="GRAB_EVENT_MASK" type="int" line="40"/>
            <javadoc line="40">
                Special mask for the UngrabEvent events, in addition to the
                  public masks defined in AWTEvent.  Should be used as the mask
                  value for Toolkit.addAWTEventListener.                
            </javadoc>
            <declaration name="wakeupMethod" type="Method" line="46"/>
            <declaration name="POST_EVENT_QUEUE_KEY" type="String" line="47"/>
            <declaration name="numberOfButtons" type="int" line="48"/>
            <javadoc line="48">
                Number of buttons.
                  By default it&apos;s taken from the system. If system value does not
                  fit into int type range, use our own MAX_BUTTONS_SUPPORT value.                
            </javadoc>
            <declaration name="MAX_BUTTONS_SUPPORTED" type="int" line="54"/>
            <method name="SunToolkit" type="constructor" line="55">
                <anonymous_class line="56">
                    <method name="run" type="void" line="57">
                        <declaration name="eventQueue" type="EventQueue" line="58"/>
                        <declaration name="eqName" type="String" line="59"/>
                        <scope line="60"/>
                        <scope line="63"/>
                        <declaration name="appContext" type="AppContext" line="68"/>
                        <declaration name="postEventQueue" type="PostEventQueue" line="70"/>
                    </method>
                </anonymous_class>
                <declaration name="initEQ" type="Runnable" line="56"/>
            </method>
            <method name="useBufferPerWindow" type="boolean" line="77"/>
            <method name="createWindow" type="WindowPeer" line="80"/>
            <method name="createFrame" type="FramePeer" line="81"/>
            <method name="createDialog" type="DialogPeer" line="82"/>
            <method name="createButton" type="ButtonPeer" line="83"/>
            <method name="createTextField" type="TextFieldPeer" line="84"/>
            <method name="createChoice" type="ChoicePeer" line="85"/>
            <method name="createLabel" type="LabelPeer" line="86"/>
            <method name="createList" type="ListPeer" line="87"/>
            <method name="createCheckbox" type="CheckboxPeer" line="88"/>
            <method name="createScrollbar" type="ScrollbarPeer" line="89"/>
            <method name="createScrollPane" type="ScrollPanePeer" line="90"/>
            <method name="createTextArea" type="TextAreaPeer" line="91"/>
            <method name="createFileDialog" type="FileDialogPeer" line="92"/>
            <method name="createMenuBar" type="MenuBarPeer" line="93"/>
            <method name="createMenu" type="MenuPeer" line="94"/>
            <method name="createPopupMenu" type="PopupMenuPeer" line="95"/>
            <method name="createMenuItem" type="MenuItemPeer" line="96"/>
            <method name="createCheckboxMenuItem" type="CheckboxMenuItemPeer" line="97"/>
            <method name="createDragSourceContextPeer" type="DragSourceContextPeer" line="98"/>
            <method name="createTrayIcon" type="TrayIconPeer" line="99"/>
            <method name="createSystemTray" type="SystemTrayPeer" line="100"/>
            <method name="isTraySupported" type="boolean" line="101"/>
            <method name="getFontPeer" type="FontPeer" line="102"/>
            <method name="createRobot" type="RobotPeer" line="103"/>
            <method name="createKeyboardFocusManagerPeer" type="KeyboardFocusManagerPeer" line="104"/>
            <declaration name="AWT_LOCK" type="ReentrantLock" line="105"/>
            <javadoc line="105">
                The AWT lock is typically only used on Unix platforms to synchronize
                  access to Xlib, OpenGL, etc.  However, these methods are implemented
                  in SunToolkit so that they can be called from shared code (e.g.
                  from the OGL pipeline) or from the X11 pipeline regardless of whether
                  XToolkit or MToolkit is currently in use.  There are native macros
                  (such as AWT_LOCK) defined in awt.h, so if the implementation of these
                  methods is changed, make sure it is compatible with the native macros.
                  Note: The following methods (awtLock(), awtUnlock(), etc) should be
                  used in place of:
                  synchronized (getAWTLock()) {
                  ...
                  }
                  By factoring these methods out specially, we are able to change the
                  implementation of these methods (e.g. use more advanced locking
                  mechanisms) without impacting calling code.
                  Sample usage:
                  private void doStuffWithXlib() {
                  assert !SunToolkit.isAWTLockHeldByCurrentThread();
                  SunToolkit.awtLock();
                  try {
                  ...
                  XlibWrapper.XDoStuff();
                  } finally {
                  SunToolkit.awtUnlock();
                  }
                  }                
            </javadoc>
            <declaration name="AWT_LOCK_COND" type="Condition" line="134"/>
            <method name="awtLock" type="void" line="135"/>
            <method name="awtTryLock" type="boolean" line="138"/>
            <method name="awtUnlock" type="void" line="141"/>
            <method name="awtLockWait" type="void" line="144"/>
            <method name="awtLockWait" type="void" line="147">
                <params>
                    <param name="timeout" type="long"/>
                </params>
            </method>
            <method name="awtLockNotify" type="void" line="150"/>
            <method name="awtLockNotifyAll" type="void" line="153"/>
            <method name="isAWTLockHeldByCurrentThread" type="boolean" line="156"/>
            <method name="createNewAppContext" type="AppContext" line="159">
                <declaration name="threadGroup" type="ThreadGroup" line="160"/>
                <declaration name="appContext" type="AppContext" line="161"/>
                <declaration name="eventQueue" type="EventQueue" line="162"/>
                <declaration name="eqName" type="String" line="163"/>
                <scope line="164"/>
                <scope line="167"/>
                <declaration name="postEventQueue" type="PostEventQueue" line="172"/>
            </method>
            <method name="getField" type="Field" line="176">
                <params>
                    <param name="klass" type="Class"/>
                    <param name="fieldName" type="String"/>
                </params>
            </method>
            <method name="wakeupEventQueue" type="void" line="196">
                <params>
                    <param name="q" type="EventQueue"/>
                    <param name="isShutdown" type="boolean"/>
                </params>
            </method>
            <method name="targetToPeer" type="Object" line="230">
                <params>
                    <param name="target" type="Object"/>
                </params>
                <scope line="231"/>
            </method>
            <method name="targetCreatedPeer" type="void" line="236">
                <params>
                    <param name="target" type="Object"/>
                    <param name="peer" type="Object"/>
                </params>
                <scope line="237"/>
            </method>
            <method name="targetDisposedPeer" type="void" line="241">
                <params>
                    <param name="target" type="Object"/>
                    <param name="peer" type="Object"/>
                </params>
                <scope line="242"/>
            </method>
            <declaration name="appContextMap" type="Map" line="246"/>
            <javadoc line="247">
                Sets the appContext field of target. If target is not a Component or
                  MenuComponent, this returns false.                
            </javadoc>
            <method name="setAppContext" type="boolean" line="251">
                <params>
                    <param name="target" type="Object"/>
                    <param name="context" type="AppContext"/>
                </params>
                <scope line="252"/>
                <scope line="255"/>
                <scope line="258"/>
            </method>
            <javadoc line="263">
                Returns the appContext field for target. If target is not a
                  Component or MenuComponent this returns null.                
            </javadoc>
            <method name="getAppContext" type="AppContext" line="267">
                <params>
                    <param name="target" type="Object"/>
                </params>
                <scope line="268"/>
                <scope line="271"/>
                <scope line="274"/>
            </method>
            <method name="targetToAppContext" type="AppContext" line="278">
                <params>
                    <param name="target" type="Object"/>
                </params>
                <scope line="279"/>
                <declaration name="context" type="AppContext" line="282"/>
                <scope line="283"/>
            </method>
            <javadoc line="288">
                Sets the synchronous status of focus requests on lightweight
                  components in the specified window to the specified value.
                  If the boolean parameter is &lt;code&gt;true&lt;/code&gt; then the focus
                  requests on lightweight components will be performed
                  synchronously, if it is &lt;code&gt;false&lt;/code&gt;, then asynchronously.
                  By default, all windows have their lightweight request status
                  set to asynchronous.
                  &lt;p&gt;
                  The application can only set the status of lightweight focus
                  requests to synchronous for any of its windows if it doesn&apos;t
                  perform focus transfers between different heavyweight containers.
                  In this case the observable focus behaviour is the same as with
                  asynchronous status.
                  &lt;p&gt;
                  If the application performs focus transfer between different
                  heavyweight containers and sets the lightweight focus request
                  status to synchronous for any of its windows, then further focus
                  behaviour is unspecified.
                  &lt;p&gt;                
                <param>
                    w window for which the lightweight focus request status
                      should be set                    
                </param>
                <param>
                    status the value of lightweight focus request status                    
                </param>
            </javadoc>
            <method name="setLWRequestStatus" type="void" line="312">
                <params>
                    <param name="changed" type="Window"/>
                    <param name="status" type="boolean"/>
                </params>
            </method>
            <method name="checkAndSetPolicy" type="void" line="315">
                <params>
                    <param name="cont" type="Container"/>
                    <param name="isSwingCont" type="boolean"/>
                </params>
                <declaration name="defaultPolicy" type="FocusTraversalPolicy" line="316"/>
                <declaration name="toolkitName" type="String" line="317"/>
                <scope line="318"/>
                <declaration name="policyName" type="String" line="322"/>
                <scope line="323">
                    <scope line="324">
                        <scope line="325"/>
                        <scope line="328"/>
                    </scope>
                    <scope line="331">
                        <scope line="332"/>
                        <scope line="334"/>
                    </scope>
                </scope>
                <scope line="339">
                    <scope line="340"/>
                </scope>
            </method>
            <method name="createLayoutPolicy" type="FocusTraversalPolicy" line="346"/>
            <method name="insertTargetMapping" type="void" line="363">
                <params>
                    <param name="target" type="Object"/>
                    <param name="appContext" type="AppContext"/>
                </params>
                <scope line="364">
                    <scope line="365"/>
                </scope>
            </method>
            <method name="postEvent" type="void" line="370">
                <params>
                    <param name="appContext" type="AppContext"/>
                    <param name="event" type="AWTEvent"/>
                </params>
                <scope line="371"/>
                <declaration name="eventContext" type="AppContext" line="375"/>
                <scope line="376"/>
                <declaration name="postEventQueue" type="PostEventQueue" line="379"/>
                <scope line="380"/>
            </method>
            <method name="postPriorityEvent" type="void" line="384">
                <params>
                    <param name="e" type="AWTEvent"/>
                </params>
                <anonymous_class line="385">
                    <method name="run" type="void" line="386"/>
                </anonymous_class>
                <declaration name="pe" type="PeerEvent" line="385"/>
            </method>
            <declaration name="flushLock" type="Lock" line="394"/>
            <declaration name="isFlushingPendingEvents" type="boolean" line="395"/>
            <method name="flushPendingEvents" type="void" line="396">
                <scope line="398">
                    <scope line="399">
                        <declaration name="appContext" type="AppContext" line="401"/>
                        <declaration name="postEventQueue" type="PostEventQueue" line="402"/>
                        <scope line="403"/>
                    </scope>
                </scope>
                <scope line="408"/>
            </method>
            <method name="isPostEventQueueEmpty" type="boolean" line="413">
                <declaration name="appContext" type="AppContext" line="414"/>
                <declaration name="postEventQueue" type="PostEventQueue" line="415"/>
                <scope line="416"/>
                <scope line="419"/>
            </method>
            <method name="executeOnEventHandlerThread" type="void" line="423">
                <params>
                    <param name="target" type="Object"/>
                    <param name="runnable" type="Runnable"/>
                </params>
            </method>
            <method name="executeOnEventHandlerThread" type="void" line="426">
                <params>
                    <param name="target" type="Object"/>
                    <param name="runnable" type="Runnable"/>
                    <param name="when" type="long"/>
                </params>
                <anonymous_class line="427">
                    <method name="getWhen" type="long" line="428"/>
                </anonymous_class>
            </method>
            <method name="executeOnEventHandlerThread" type="void" line="434">
                <params>
                    <param name="peerEvent" type="PeerEvent"/>
                </params>
            </method>
            <method name="invokeLaterOnAppContext" type="void" line="437">
                <params>
                    <param name="appContext" type="AppContext"/>
                    <param name="dispatcher" type="Runnable"/>
                </params>
            </method>
            <method name="executeOnEDTAndWait" type="void" line="440">
                <params>
                    <param name="target" type="Object"/>
                    <param name="runnable" type="Runnable"/>
                </params>
                <scope line="441"/>
                <class name="AWTInvocationLock" line="444"/>
                <declaration name="lock" type="Object" line="446"/>
                <declaration name="event" type="PeerEvent" line="447"/>
                <scope line="448">
                    <scope line="450"/>
                </scope>
                <declaration name="eventThrowable" type="Throwable" line="454"/>
                <scope line="455"/>
            </method>
            <method name="isDispatchThreadForAppContext" type="boolean" line="459">
                <params>
                    <param name="target" type="Object"/>
                </params>
                <declaration name="appContext" type="AppContext" line="460"/>
                <declaration name="eq" type="EventQueue" line="461"/>
                <declaration name="accessor" type="AWTAccessor.EventQueueAccessor" line="462"/>
            </method>
            <method name="getScreenSize" type="Dimension" line="465"/>
            <method name="getScreenWidth" type="int" line="468"/>
            <method name="getScreenHeight" type="int" line="469"/>
            <method name="getFontMetrics" type="FontMetrics" line="470">
                <params>
                    <param name="font" type="Font"/>
                </params>
            </method>
            <method name="getFontList" type="String[]" line="473">
                <declaration name="hardwiredFontList" type="String[]" line="474"/>
            </method>
            <method name="createPanel" type="PanelPeer" line="477">
                <params>
                    <param name="target" type="Panel"/>
                </params>
            </method>
            <method name="createCanvas" type="CanvasPeer" line="480">
                <params>
                    <param name="target" type="Canvas"/>
                </params>
            </method>
            <javadoc line="483">
                Disables erasing of background on the canvas before painting if
                  this is supported by the current toolkit. It is recommended to
                  call this method early, before the Canvas becomes displayable,
                  because some Toolkit implementations do not support changing
                  this property once the Canvas becomes displayable.                
            </javadoc>
            <method name="disableBackgroundErase" type="void" line="490">
                <params>
                    <param name="canvas" type="Canvas"/>
                </params>
            </method>
            <javadoc line="493">
                Disables the native erasing of the background on the given
                  component before painting if this is supported by the current
                  toolkit. This only has an effect for certain components such as
                  Canvas, Panel and Window. It is recommended to call this method
                  early, before the Component becomes displayable, because some
                  Toolkit implementations do not support changing this property
                  once the Component becomes displayable.                
            </javadoc>
            <method name="disableBackgroundErase" type="void" line="502">
                <params>
                    <param name="component" type="Component"/>
                </params>
            </method>
            <method name="disableBackgroundEraseImpl" type="void" line="505">
                <params>
                    <param name="component" type="Component"/>
                </params>
            </method>
            <javadoc line="508">
                Returns the value of &quot;sun.awt.noerasebackground&quot; property. Default
                  value is {@code false}.                
            </javadoc>
            <method name="getSunAwtNoerasebackground" type="boolean" line="512"/>
            <javadoc line="515">
                Returns the value of &quot;sun.awt.erasebackgroundonresize&quot; property. Default
                  value is {@code false}.                
            </javadoc>
            <method name="getSunAwtErasebackgroundonresize" type="boolean" line="519"/>
            <declaration name="imgCache" type="SoftCache" line="522"/>
            <method name="getImageFromHash" type="Image" line="523">
                <params>
                    <param name="tk" type="Toolkit"/>
                    <param name="url" type="URL"/>
                </params>
                <declaration name="sm" type="SecurityManager" line="524"/>
                <scope line="525">
                    <scope line="526">
                        <declaration name="perm" type="java.security.Permission" line="527"/>
                        <scope line="528">
                            <scope line="529"/>
                            <scope line="532">
                                <scope line="533"/>
                                <scope line="536"/>
                                <scope line="539"/>
                            </scope>
                        </scope>
                    </scope>
                    <scope line="545"/>
                </scope>
                <scope line="549">
                    <declaration name="img" type="Image" line="550"/>
                    <scope line="551">
                        <scope line="552"/>
                        <scope line="556"/>
                    </scope>
                </scope>
            </method>
            <method name="getImageFromHash" type="Image" line="562">
                <params>
                    <param name="tk" type="Toolkit"/>
                    <param name="filename" type="String"/>
                </params>
                <declaration name="security" type="SecurityManager" line="563"/>
                <scope line="564"/>
                <scope line="567">
                    <declaration name="img" type="Image" line="568"/>
                    <scope line="569">
                        <scope line="570"/>
                        <scope line="574"/>
                    </scope>
                </scope>
            </method>
            <method name="getImage" type="Image" line="580">
                <params>
                    <param name="filename" type="String"/>
                </params>
            </method>
            <method name="getImage" type="Image" line="583">
                <params>
                    <param name="url" type="URL"/>
                </params>
            </method>
            <method name="createImage" type="Image" line="586">
                <params>
                    <param name="filename" type="String"/>
                </params>
                <declaration name="security" type="SecurityManager" line="587"/>
                <scope line="588"/>
            </method>
            <method name="createImage" type="Image" line="593">
                <params>
                    <param name="url" type="URL"/>
                </params>
                <declaration name="sm" type="SecurityManager" line="594"/>
                <scope line="595">
                    <scope line="596">
                        <declaration name="perm" type="java.security.Permission" line="597"/>
                        <scope line="598">
                            <scope line="599"/>
                            <scope line="602">
                                <scope line="603"/>
                                <scope line="606"/>
                                <scope line="609"/>
                            </scope>
                        </scope>
                    </scope>
                    <scope line="615"/>
                </scope>
            </method>
            <method name="createImage" type="Image" line="621">
                <params>
                    <param name="data" type="byte[]"/>
                    <param name="offset" type="int"/>
                    <param name="length" type="int"/>
                </params>
            </method>
            <method name="createImage" type="Image" line="624">
                <params>
                    <param name="producer" type="ImageProducer"/>
                </params>
            </method>
            <method name="checkImage" type="int" line="627">
                <params>
                    <param name="img" type="Image"/>
                    <param name="w" type="int"/>
                    <param name="h" type="int"/>
                    <param name="o" type="ImageObserver"/>
                </params>
                <scope line="628"/>
                <declaration name="tkimg" type="ToolkitImage" line="631"/>
                <declaration name="repbits" type="int" line="632"/>
                <scope line="633"/>
                <scope line="636"/>
            </method>
            <method name="prepareImage" type="boolean" line="641">
                <params>
                    <param name="img" type="Image"/>
                    <param name="w" type="int"/>
                    <param name="h" type="int"/>
                    <param name="o" type="ImageObserver"/>
                </params>
                <scope line="642"/>
                <scope line="645"/>
                <declaration name="tkimg" type="ToolkitImage" line="648"/>
                <scope line="649">
                    <scope line="650"/>
                </scope>
                <declaration name="ir" type="ImageRepresentation" line="655"/>
            </method>
            <javadoc line="658">
                Scans {@code imageList} for best-looking image of specified dimensions.
                  Image can be scaled and/or padded with transparency.                
            </javadoc>
            <method name="getScaledIconImage" type="BufferedImage" line="662">
                <params>
                    <param name="imageList" type="java.util.List<Image>"/>
                    <param name="width" type="int"/>
                    <param name="height" type="int"/>
                </params>
                <scope line="663"/>
                <declaration name="bestImage" type="Image" line="666"/>
                <declaration name="bestWidth" type="int" line="667"/>
                <declaration name="bestHeight" type="int" line="668"/>
                <declaration name="bestSimilarity" type="double" line="669"/>
                <declaration name="bestScaleFactor" type="double" line="670"/>
                <scope line="671">
                    <declaration name="im" type="Image" line="672"/>
                    <scope line="673">
                        <scope line="674"/>
                    </scope>
                    <scope line="679">
                        <declaration name="ir" type="ImageRepresentation" line="680"/>
                    </scope>
                    <declaration name="iw" type="int" line="683"/>
                    <declaration name="ih" type="int" line="684"/>
                    <scope line="685"/>
                    <scope line="689">
                        <scope line="690"/>
                    </scope>
                    <scope line="695">
                        <declaration name="scaleFactor" type="double" line="696"/>
                        <declaration name="adjw" type="int" line="697"/>
                        <declaration name="adjh" type="int" line="698"/>
                        <declaration name="scaleMeasure" type="double" line="699"/>
                        <scope line="700"/>
                        <scope line="706"/>
                        <scope line="712"/>
                        <scope line="718"/>
                        <scope line="724">
                            <declaration name="scaleDivider" type="double" line="725"/>
                        </scope>
                        <declaration name="similarity" type="double" line="731"/>
                        <scope line="732"/>
                    </scope>
                </scope>
                <scope line="742"/>
                <declaration name="bimage" type="BufferedImage" line="745"/>
                <declaration name="g" type="Graphics2D" line="746"/>
                <scope line="748">
                    <declaration name="x" type="int" line="749"/>
                    <declaration name="y" type="int" line="750"/>
                    <scope line="751"/>
                </scope>
                <scope line="756"/>
            </method>
            <method name="getScaledIconData" type="DataBufferInt" line="761">
                <params>
                    <param name="imageList" type="java.util.List<Image>"/>
                    <param name="width" type="int"/>
                    <param name="height" type="int"/>
                </params>
                <declaration name="bimage" type="BufferedImage" line="762"/>
                <scope line="763">
                    <scope line="764"/>
                </scope>
                <declaration name="raster" type="Raster" line="769"/>
                <declaration name="buffer" type="DataBuffer" line="770"/>
            </method>
            <method name="getSystemEventQueueImpl" type="EventQueue" line="773"/>
            <method name="getSystemEventQueueImplPP" type="EventQueue" line="776"/>
            <method name="getSystemEventQueueImplPP" type="EventQueue" line="779">
                <params>
                    <param name="appContext" type="AppContext"/>
                </params>
                <declaration name="theEventQueue" type="EventQueue" line="780"/>
            </method>
            <javadoc line="783">
                Give native peers the ability to query the native container
                  given a native component (eg the direct parent may be lightweight).                
            </javadoc>
            <method name="getNativeContainer" type="Container" line="787">
                <params>
                    <param name="c" type="Component"/>
                </params>
            </method>
            <javadoc line="790">
                Gives native peers the ability to query the closest HW component.
                  If the given component is heavyweight, then it returns this. Otherwise,
                  it goes one level up in the hierarchy and tests next component.                
            </javadoc>
            <method name="getHeavyweightComponent" type="Component" line="795">
                <params>
                    <param name="c" type="Component"/>
                </params>
                <scope line="796"/>
            </method>
            <javadoc line="801">
                Returns a new input method window, with behavior as specified in{@link java.awt.im.spi.InputMethodContext#createInputMethodWindow}.
                  If the inputContext is not null, the window should return it from its
                  getInputContext() method. The window needs to implement
                  sun.awt.im.InputMethodWindow.
                  &lt;p&gt;
                  SunToolkit subclasses can override this method to return better input
                  method windows.                
            </javadoc>
            <method name="createInputMethodWindow" type="Window" line="810">
                <params>
                    <param name="title" type="String"/>
                    <param name="context" type="InputContext"/>
                </params>
            </method>
            <javadoc line="813">
                Returns whether enableInputMethods should be set to true for peered
                  TextComponent instances on this platform. False by default.                
            </javadoc>
            <method name="enableInputMethodsForTextComponent" type="boolean" line="817"/>
            <declaration name="startupLocale" type="Locale" line="820"/>
            <javadoc line="821">
                Returns the locale in which the runtime was started.                
            </javadoc>
            <method name="getStartupLocale" type="Locale" line="824">
                <scope line="825">
                    <declaration name="language" type="String" line="826"/>
                    <scope line="829">
                        <declaration name="i" type="int" line="830"/>
                        <scope line="831"/>
                        <scope line="835"/>
                    </scope>
                    <scope line="840"/>
                </scope>
            </method>
            <javadoc line="848">
                Returns the default keyboard locale of the underlying operating system                
            </javadoc>
            <method name="getDefaultKeyboardLocale" type="Locale" line="851"/>
            <declaration name="dataTransfererClassName" type="String" line="854"/>
            <method name="setDataTransfererClassName" type="void" line="855">
                <params>
                    <param name="className" type="String"/>
                </params>
            </method>
            <method name="getDataTransfererClassName" type="String" line="858">
                <scope line="859"/>
            </method>
            <declaration name="windowClosingListener" type="WindowClosingListener" line="864"/>
            <javadoc line="865">
                @see sun.awt.WindowClosingSupport#getWindowClosingListener                
            </javadoc>
            <method name="getWindowClosingListener" type="WindowClosingListener" line="868"/>
            <javadoc line="871">
                @see sun.awt.WindowClosingSupport#setWindowClosingListener                
            </javadoc>
            <method name="setWindowClosingListener" type="void" line="874">
                <params>
                    <param name="wcl" type="WindowClosingListener"/>
                </params>
            </method>
            <javadoc line="877">
                @see sun.awt.WindowClosingListener#windowClosingNotify                
            </javadoc>
            <method name="windowClosingNotify" type="RuntimeException" line="880">
                <params>
                    <param name="event" type="WindowEvent"/>
                </params>
                <scope line="881"/>
                <scope line="884"/>
            </method>
            <javadoc line="888">
                @see sun.awt.WindowClosingListener#windowClosingDelivered                
            </javadoc>
            <method name="windowClosingDelivered" type="RuntimeException" line="891">
                <params>
                    <param name="event" type="WindowEvent"/>
                </params>
                <scope line="892"/>
                <scope line="895"/>
            </method>
            <declaration name="mPeer" type="DefaultMouseInfoPeer" line="899"/>
            <method name="getMouseInfoPeer" type="MouseInfoPeer" line="900">
                <scope line="901"/>
            </method>
            <javadoc line="906">
                Returns whether default toolkit needs the support of the xembed
                  from embedding host(if any).                
                <return>
                    <code>true</code>, if XEmbed is needed, <code>false</code> otherwise                    
                </return>
            </javadoc>
            <method name="needsXEmbed" type="boolean" line="911">
                <declaration name="noxembed" type="String" line="912"/>
                <scope line="913"/>
                <declaration name="tk" type="Toolkit" line="916"/>
                <scope line="917"/>
                <scope line="920"/>
            </method>
            <javadoc line="924">
                Returns whether this toolkit needs the support of the xembed
                  from embedding host(if any).                
                <return>
                    <code>true</code>, if XEmbed is needed, <code>false</code> otherwise                    
                </return>
            </javadoc>
            <method name="needsXEmbedImpl" type="boolean" line="929"/>
            <declaration name="DEFAULT_MODAL_EXCLUSION_TYPE" type="Dialog.ModalExclusionType" line="932"/>
            <javadoc line="933">
                Returns whether the XEmbed server feature is requested by
                  developer.  If true, Toolkit should return an
                  XEmbed-server-enabled CanvasPeer instead of the ordinary CanvasPeer.                
            </javadoc>
            <method name="isXEmbedServerRequested" type="boolean" line="938"/>
            <javadoc line="941">
                Returns whether the modal exclusion API is supported by the current toolkit.
                  When it isn&apos;t supported, calling &lt;code&gt;setModalExcluded&lt;/code&gt; has no
                  effect, and &lt;code&gt;isModalExcluded&lt;/code&gt; returns false for all windows.                
                <return>
                    true if modal exclusion is supported by the toolkit, false otherwise                    
                </return>
                <see>
                    sun.awt.SunToolkit#setModalExcluded(java.awt.Window)                    
                </see>
                <see>
                    sun.awt.SunToolkit#isModalExcluded(java.awt.Window)                    
                </see>
                <since>
                    1.5                    
                </since>
            </javadoc>
            <method name="isModalExcludedSupported" type="boolean" line="950">
                <declaration name="tk" type="Toolkit" line="951"/>
            </method>
            <method name="isModalExcludedSupportedImpl" type="boolean" line="954"/>
            <method name="setModalExcluded" type="void" line="957">
                <params>
                    <param name="window" type="Window"/>
                </params>
                <scope line="958"/>
            </method>
            <method name="isModalExcluded" type="boolean" line="963">
                <params>
                    <param name="window" type="Window"/>
                </params>
                <scope line="964"/>
            </method>
            <javadoc line="969">
                Overridden in XToolkit and WToolkit                
            </javadoc>
            <method name="isModalityTypeSupported" type="boolean" line="972">
                <params>
                    <param name="modalityType" type="Dialog.ModalityType"/>
                </params>
            </method>
            <javadoc line="975">
                Overridden in XToolkit and WToolkit                
            </javadoc>
            <method name="isModalExclusionTypeSupported" type="boolean" line="978">
                <params>
                    <param name="exclusionType" type="Dialog.ModalExclusionType"/>
                </params>
            </method>
            <declaration name="modalityListeners" type="ModalityListenerList" line="981"/>
            <method name="addModalityListener" type="void" line="982">
                <params>
                    <param name="listener" type="ModalityListener"/>
                </params>
            </method>
            <method name="removeModalityListener" type="void" line="985">
                <params>
                    <param name="listener" type="ModalityListener"/>
                </params>
            </method>
            <method name="notifyModalityPushed" type="void" line="988">
                <params>
                    <param name="dialog" type="Dialog"/>
                </params>
            </method>
            <method name="notifyModalityPopped" type="void" line="991">
                <params>
                    <param name="dialog" type="Dialog"/>
                </params>
            </method>
            <method name="notifyModalityChange" type="void" line="994">
                <params>
                    <param name="id" type="int"/>
                    <param name="source" type="Dialog"/>
                </params>
                <declaration name="ev" type="ModalityEvent" line="995"/>
            </method>
            <class name="ModalityListenerList" line="998">
                <implements interface="ModalityListener"/>
                <declaration name="listeners" type="Vector&lt;ModalityListener&gt;" line="999"/>
                <method name="add" type="void" line="1000">
                    <params>
                        <param name="listener" type="ModalityListener"/>
                    </params>
                </method>
                <method name="remove" type="void" line="1003">
                    <params>
                        <param name="listener" type="ModalityListener"/>
                    </params>
                </method>
                <method name="modalityPushed" type="void" line="1006">
                    <params>
                        <param name="ev" type="ModalityEvent"/>
                    </params>
                    <declaration name="it" type="Iterator&lt;ModalityListener&gt;" line="1007"/>
                    <scope line="1008"/>
                </method>
                <method name="modalityPopped" type="void" line="1012">
                    <params>
                        <param name="ev" type="ModalityEvent"/>
                    </params>
                    <declaration name="it" type="Iterator&lt;ModalityListener&gt;" line="1013"/>
                    <scope line="1014"/>
                </method>
            </class>
            <method name="isLightweightOrUnknown" type="boolean" line="1019">
                <params>
                    <param name="comp" type="Component"/>
                </params>
                <scope line="1020"/>
            </method>
            <method name="getMethod" type="Method" line="1025">
                <params>
                    <param name="clz" type="Class"/>
                    <param name="methodName" type="String"/>
                    <param name="params" type="Class[]"/>
                </params>
                <declaration name="res" type="Method" line="1026"/>
                <scope line="1027">
                    <anonymous_class line="1028">
                        <method name="run" type="Method" line="1029">
                            <declaration name="m" type="Method" line="1030"/>
                        </method>
                    </anonymous_class>
                </scope>
                <scope line="1037"/>
            </method>
            <class name="OperationTimedOut" line="1042">
                <extends class="RuntimeException"/>
                <method name="OperationTimedOut" type="constructor" line="1043">
                    <params>
                        <param name="msg" type="String"/>
                    </params>
                </method>
                <method name="OperationTimedOut" type="constructor" line="1046"/>
            </class>
            <class name="InfiniteLoop" line="1049">
                <extends class="RuntimeException"/>
            </class>
            <class name="IllegalThreadException" line="1051">
                <extends class="RuntimeException"/>
                <method name="IllegalThreadException" type="constructor" line="1052">
                    <params>
                        <param name="msg" type="String"/>
                    </params>
                </method>
                <method name="IllegalThreadException" type="constructor" line="1055"/>
            </class>
            <declaration name="DEFAULT_WAIT_TIME" type="int" line="1058"/>
            <declaration name="MAX_ITERS" type="int" line="1059"/>
            <declaration name="MIN_ITERS" type="int" line="1060"/>
            <declaration name="MINIMAL_EDELAY" type="int" line="1061"/>
            <javadoc line="1062">
                Parameterless version of realsync which uses default timout (see DEFAUL_WAIT_TIME).                
            </javadoc>
            <method name="realSync" type="void" line="1065"/>
            <javadoc line="1068">
                Forces toolkit to synchronize with the native windowing
                  sub-system, flushing all pending work and waiting for all the
                  events to be processed.  This method guarantees that after
                  return no additional Java events will be generated, unless
                  cause by user. Obviously, the method cannot be used on the
                  event dispatch thread (EDT). In case it nevertheless gets
                  invoked on this thread, the method throws the
                  IllegalThreadException runtime exception.
                  &lt;p&gt; This method allows to write tests without explicit timeouts
                  or wait for some event.  Example:
                  &lt;code&gt;
                  Frame f = ...;
                  f.setVisible(true);
                  ((SunToolkit)Toolkit.getDefaultToolkit()).realSync();
                  &lt;/code&gt;
                  &lt;p&gt; After realSync, &lt;code&gt;f&lt;/code&gt; will be completely visible
                  on the screen, its getLocationOnScreen will be returning the
                  right result and it will be the focus owner.
                  &lt;p&gt; Another example:
                  &lt;code&gt;
                  b.requestFocus();
                  ((SunToolkit)Toolkit.getDefaultToolkit()).realSync();
                  &lt;/code&gt;
                  &lt;p&gt; After realSync, &lt;code&gt;b&lt;/code&gt; will be focus owner.
                  &lt;p&gt; Notice that realSync isn&apos;t guaranteed to work if recurring
                  actions occur, such as if during processing of some event
                  another request which may generate some events occurs.  By
                  default, sync tries to perform as much as {@value MAX_ITERS}cycles of event processing, allowing for roughly {@value
                      MAX_ITERS} additional requests.
                  &lt;p&gt; For example, requestFocus() generates native request, which
                  generates one or two Java focus events, which then generate a
                  serie of paint events, a serie of Java focus events, which then
                  generate a serie of paint events which then are processed -
                  three cycles, minimum.                
                <param>
                    timeout the maximum time to wait in milliseconds, negative means "forever".                    
                </param>
            </javadoc>
            <method name="realSync" type="void" line="1105">
                <params>
                    <param name="timeout" type="long"/>
                </params>
                <scope line="1106"/>
                <declaration name="bigLoop" type="int" line="1109"/>
                <scope line="1110">
                    <declaration name="iters" type="int" line="1112"/>
                    <scope line="1113"/>
                    <scope line="1117"/>
                    <scope line="1120"/>
                    <scope line="1124"/>
                    <scope line="1128"/>
                    <scope line="1131"/>
                </scope>
            </method>
            <method name="syncNativeQueue" type="boolean" line="1138"/>
            <javadoc line="1138">
                Platform toolkits need to implement this method to perform the
                  sync of the native queue.  The method should wait until native
                  requests are processed, all native events are processed and
                  corresponding Java events are generated.  Should return
                  &lt;code&gt;true&lt;/code&gt; if some events were processed,
                  &lt;code&gt;false&lt;/code&gt; otherwise.                
            </javadoc>
            <declaration name="eventDispatched" type="boolean" line="1147"/>
            <declaration name="queueEmpty" type="boolean" line="1148"/>
            <declaration name="waitLock" type="Object" line="1149"/>
            <declaration name="eqNoEvents" type="Method" line="1150"/>
            <method name="isEQEmpty" type="boolean" line="1151">
                <declaration name="queue" type="EventQueue" line="1152"/>
                <scope line="1153">
                    <scope line="1154"/>
                </scope>
                <scope line="1158"/>
                <scope line="1161"/>
            </method>
            <javadoc line="1166">
                Waits for the Java event queue to empty.  Ensures that all
                  events are processed (including paint events), and that if
                  recursive events were generated, they are also processed.
                  Should return &lt;code&gt;true&lt;/code&gt; if more processing is
                  necessary, &lt;code&gt;false&lt;/code&gt; otherwise.                
            </javadoc>
            <method name="waitForIdle" type="boolean" line="1173">
                <params>
                    <param name="timeout" type="long"/>
                </params>
                <declaration name="queueWasEmpty" type="boolean" line="1175"/>
                <scope line="1178">
                    <anonymous_class line="1179">
                        <method name="dispatch" type="void" line="1180">
                            <declaration name="iters" type="int" line="1181"/>
                            <scope line="1182"/>
                            <scope line="1186"/>
                            <scope line="1190"/>
                        </method>
                    </anonymous_class>
                    <scope line="1198">
                        <scope line="1199"/>
                    </scope>
                    <scope line="1203"/>
                </scope>
                <scope line="1207"/>
                <scope line="1210"/>
                <scope line="1214"/>
            </method>
            <method name="grab" type="void" line="1218"/>
            <javadoc line="1218">
                Grabs the mouse input for the given window.  The window must be
                  visible.  The window or its children do not receive any
                  additional mouse events besides those targeted to them.  All
                  other events will be dispatched as before - to the respective
                  targets.  This Window will receive UngrabEvent when automatic
                  ungrab is about to happen.  The event can be listened to by
                  installing AWTEventListener with WINDOW_EVENT_MASK.  See
                  UngrabEvent class for the list of conditions when ungrab is
                  about to happen.                
                <see>
                    UngrabEvent                    
                </see>
            </javadoc>
            <method name="ungrab" type="void" line="1231"/>
            <javadoc line="1231">
                Forces ungrab.  No event will be sent.                
            </javadoc>
            <method name="closeSplashScreen" type="void" line="1235"/>
            <javadoc line="1235">
                Locates the splash screen library in a platform dependent way and closes
                  the splash screen. Should be invoked on first top-level frame display.                
                <see>
                    java.awt.SplashScreen                    
                </see>
                <since>
                    1.6                    
                </since>
            </javadoc>
            <method name="fireDesktopFontPropertyChanges" type="void" line="1242"/>
            <declaration name="checkedSystemAAFontSettings" type="boolean" line="1245"/>
            <declaration name="useSystemAAFontSettings" type="boolean" line="1246"/>
            <declaration name="lastExtraCondition" type="boolean" line="1247"/>
            <declaration name="desktopFontHints" type="RenderingHints" line="1248"/>
            <method name="setAAFontSettingsCondition" type="void" line="1249">
                <params>
                    <param name="extraCondition" type="boolean"/>
                </params>
                <scope line="1250">
                    <scope line="1252">
                        <declaration name="tk" type="Toolkit" line="1254"/>
                        <scope line="1255"/>
                    </scope>
                </scope>
            </method>
            <method name="getDesktopAAHintsByName" type="RenderingHints" line="1261">
                <params>
                    <param name="hintname" type="String"/>
                </params>
                <declaration name="aaHint" type="Object" line="1262"/>
                <scope line="1264"/>
                <scope line="1267"/>
                <scope line="1270"/>
                <scope line="1273"/>
                <scope line="1276"/>
                <scope line="1279"/>
                <scope line="1282">
                    <declaration name="map" type="RenderingHints" line="1283"/>
                </scope>
                <scope line="1287"/>
            </method>
            <method name="useSystemAAFontSettings" type="boolean" line="1291">
                <scope line="1292">
                    <declaration name="systemAAFonts" type="String" line="1294"/>
                    <declaration name="tk" type="Toolkit" line="1295"/>
                    <scope line="1296"/>
                    <scope line="1299">
                        <scope line="1301"/>
                    </scope>
                    <scope line="1305"/>
                </scope>
            </method>
            <declaration name="DESKTOPFONTHINTS" type="String" line="1312"/>
            <method name="getDesktopAAHints" type="RenderingHints" line="1313"/>
            <method name="getDesktopFontHints" type="RenderingHints" line="1316">
                <scope line="1317">
                    <declaration name="tk" type="Toolkit" line="1318"/>
                    <scope line="1319">
                        <declaration name="map" type="Object" line="1320"/>
                    </scope>
                    <scope line="1323"/>
                </scope>
                <scope line="1327"/>
                <scope line="1330"/>
            </method>
            <method name="isDesktopSupported" type="boolean" line="1334"/>
            <declaration name="consumeNextKeyTypedMethod" type="Method" line="1335"/>
            <method name="consumeNextKeyTyped" type="void" line="1336">
                <params>
                    <param name="keyEvent" type="KeyEvent"/>
                </params>
                <scope line="1337"/>
                <scope line="1340"/>
                <scope line="1343"/>
                <scope line="1346"/>
            </method>
            <method name="dumpPeers" type="void" line="1350">
                <params>
                    <param name="aLog" type="PlatformLogger"/>
                </params>
            </method>
            <javadoc line="1353">
                Returns the &lt;code&gt;Window&lt;/code&gt; ancestor of the component &lt;code&gt;comp&lt;/code&gt;.                
                <return>
                    Window ancestor of the component or component by itself if it is Window;
                      null, if component is not a part of window hierarchy                    
                </return>
            </javadoc>
            <method name="getContainingWindow" type="Window" line="1358">
                <params>
                    <param name="comp" type="Component"/>
                </params>
                <scope line="1359"/>
            </method>
            <javadoc line="1364">
                Returns the value of the system property indicated by the specified key.                
            </javadoc>
            <method name="getSystemProperty" type="String" line="1367">
                <params>
                    <param name="key" type="String"/>
                </params>
                <anonymous_class line="1368">
                    <method name="run" type="Object" line="1369"/>
                </anonymous_class>
            </method>
            <javadoc line="1375">
                Returns the boolean value of the system property indicated by the specified key.                
            </javadoc>
            <method name="getBooleanSystemProperty" type="Boolean" line="1378">
                <params>
                    <param name="key" type="String"/>
                </params>
            </method>
            <declaration name="sunAwtDisableMixing" type="Boolean" line="1381"/>
            <javadoc line="1382">
                Returns the value of &quot;sun.awt.disableMixing&quot; property. Default
                  value is {@code false}.                
            </javadoc>
            <method name="getSunAwtDisableMixing" type="boolean" line="1386">
                <scope line="1387"/>
            </method>
            <javadoc line="1392">
                Returns true if the native GTK libraries are available.  The
                  default implementation returns false, but UNIXToolkit overrides this
                  method to provide a more specific answer.                
            </javadoc>
            <method name="isNativeGTKAvailable" type="boolean" line="1397"/>
            <method name="isWindowOpacitySupported" type="boolean" line="1400"/>
            <method name="isWindowShapingSupported" type="boolean" line="1403"/>
            <method name="isWindowTranslucencySupported" type="boolean" line="1406"/>
            <method name="isTranslucencyCapable" type="boolean" line="1409">
                <params>
                    <param name="gc" type="GraphicsConfiguration"/>
                </params>
            </method>
            <javadoc line="1412">
                Returns whether or not a containing top level window for the passed
                  component is{@link GraphicsDevice.WindowTranslucency#PERPIXEL_TRANSLUCENT PERPIXEL_TRANSLUCENT}.                
                <param>
                    c a Component which toplevel's to check                    
                </param>
                <return>
                    {@code true}  if the passed component is not null and has a
                      containing toplevel window which is opaque (so per-pixel translucency
                      is not enabled), {@code false} otherwise                    
                </return>
                <see>
                    GraphicsDevice.WindowTranslucency#PERPIXEL_TRANSLUCENT                    
                </see>
            </javadoc>
            <method name="isContainingTopLevelOpaque" type="boolean" line="1421">
                <params>
                    <param name="c" type="Component"/>
                </params>
                <declaration name="w" type="Window" line="1422"/>
            </method>
            <javadoc line="1425">
                Returns whether or not a containing top level window for the passed
                  component is{@link GraphicsDevice.WindowTranslucency#TRANSLUCENT TRANSLUCENT}.                
                <param>
                    c a Component which toplevel's to check                    
                </param>
                <return>
                    {@code true} if the passed component is not null and has a
                      containing toplevel window which has opacity less than
                      1.0f (which means that it is translucent), {@code false} otherwise                    
                </return>
                <see>
                    GraphicsDevice.WindowTranslucency#TRANSLUCENT                    
                </see>
            </javadoc>
            <method name="isContainingTopLevelTranslucent" type="boolean" line="1434">
                <params>
                    <param name="c" type="Component"/>
                </params>
                <declaration name="w" type="Window" line="1435"/>
            </method>
            <javadoc line="1438">
                Returns whether the native system requires using the peer.updateWindow()
                  method to update the contents of a non-opaque window, or if usual
                  painting procedures are sufficient. The default return value covers
                  the X11 systems. On MS Windows this method is overriden in WToolkit
                  to return true.                
            </javadoc>
            <method name="needUpdateWindow" type="boolean" line="1445"/>
            <javadoc line="1448">
                Descendants of the SunToolkit should override and put their own logic here.                
            </javadoc>
            <method name="getNumberOfButtons" type="int" line="1451"/>
            <javadoc line="1454">
                Checks that the given object implements/extends the given
                  interface/class.
                  Note that using the instanceof operator causes a class to be loaded.
                  Using this method doesn&apos;t load a class and it can be used instead of
                  the instanceof operator for performance reasons.                
                <param>
                    obj Object to be checked                    
                </param>
                <param>
                    type The name of the interface/class. Must be
                      fully-qualified interface/class name.                    
                </param>
                <return>
                    true, if this object implements/extends the given
                      interface/class, false, otherwise, or if obj or type is null                    
                </return>
            </javadoc>
            <method name="isInstanceOf" type="boolean" line="1466">
                <params>
                    <param name="obj" type="Object"/>
                    <param name="type" type="String"/>
                </params>
            </method>
            <method name="isInstanceOf" type="boolean" line="1471">
                <params>
                    <param name="cls" type="Class"/>
                    <param name="type" type="String"/>
                </params>
                <scope line="1473"/>
                <scope line="1476">
                    <scope line="1477"/>
                </scope>
            </method>
            <method name="setSystemGenerated" type="void" line="1483">
                <params>
                    <param name="e" type="AWTEvent"/>
                </params>
            </method>
            <method name="isSystemGenerated" type="boolean" line="1486">
                <params>
                    <param name="e" type="AWTEvent"/>
                </params>
            </method>
        </class>
        <class name="PostEventQueue" line="1490">
            <declaration name="queueHead" type="EventQueueItem" line="1491"/>
            <declaration name="queueTail" type="EventQueueItem" line="1492"/>
            <declaration name="eventQueue" type="EventQueue" line="1493"/>
            <method name="PostEventQueue" type="constructor" line="1494">
                <params>
                    <param name="eq" type="EventQueue"/>
                </params>
            </method>
            <method name="noEvents" type="boolean" line="1497"/>
            <method name="flush" type="void" line="1500">
                <declaration name="tempQueue" type="EventQueueItem" line="1501"/>
                <scope line="1503"/>
            </method>
            <method name="postEvent" type="void" line="1508">
                <params>
                    <param name="event" type="AWTEvent"/>
                </params>
                <declaration name="item" type="EventQueueItem" line="1509"/>
                <scope line="1510">
                    <scope line="1511"/>
                    <scope line="1514"/>
                </scope>
            </method>
        </class>
    </source>