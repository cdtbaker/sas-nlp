<?xml version="1.0" encoding="UTF-8"?>
    <source package="sun.awt">
        <import package="java.awt"/>
        <import package="java.awt.RenderingHints"/>
        <import package="java.awt.dnd"/>
        <import package="java.awt.dnd.peer.DragSourceContextPeer"/>
        <import package="java.awt.peer"/>
        <import package="java.awt.event.WindowEvent"/>
        <import package="java.awt.event.KeyEvent"/>
        <import package="java.awt.image"/>
        <import package="java.awt.TrayIcon"/>
        <import package="java.awt.SystemTray"/>
        <import package="java.net.URL"/>
        <import package="java.util"/>
        <import package="java.util.concurrent.TimeUnit"/>
        <import package="java.util.concurrent.locks.Condition"/>
        <import package="java.util.concurrent.locks.Lock"/>
        <import package="java.util.concurrent.locks.ReentrantLock"/>
        <import package="sun.util.logging.PlatformLogger"/>
        <import package="sun.misc.SoftCache"/>
        <import package="sun.font.FontDesignMetrics"/>
        <import package="sun.awt.im.InputContext"/>
        <import package="sun.awt.image"/>
        <import package="sun.security.action.GetPropertyAction"/>
        <import package="sun.security.action.GetBooleanAction"/>
        <import package="java.lang.reflect.Field"/>
        <import package="java.lang.reflect.Method"/>
        <import package="java.lang.reflect.Constructor"/>
        <import package="java.lang.reflect.InvocationTargetException"/>
        <import package="java.security.AccessController"/>
        <import package="java.security.PrivilegedAction"/>
        <import package="java.security.PrivilegedActionException"/>
        <import package="java.security.PrivilegedExceptionAction"/>
        <class name="SunToolkit" line="60">
            <extends class="Toolkit"/>
            <comment line="67">
                                
            </comment>
            <comment line="82">
                The key to put()get() the PostEventQueue intofrom the AppContext.                
            </comment>
            <comment line="94">
                XFree standard mention 24 buttons as maximum:
                 http:www.xfree86.orgcurrentmouse.4.html
                 We workaround systems supporting more than 24 buttons.
                 Otherwise, we have to use long type values as masks
                 which leads to API change.
                 InputEvent.BUTTON_DOWN_MASK may contain only 21 masks due to
                 the 4-bytes limit for the int type. (CR 6799099)
                 One more bit is reserved for FIRST_HIGH_BIT.                
            </comment>
            <comment line="280">
                Create a new AppContext, along with its EventQueue, for a
                 new ThreadGroup.  Browser code, for example, would use this
                 method to create an AppContext &amp; EventQueue for an Applet.                
            </comment>
            <comment line="357">
                Fetch the peer associated with the given target (as specified
                 in the peer creation method).  This can be used to determine
                 things like what the parent peer is.  If the target is null
                 or the target can&apos;t be found (either because the a peer was
                 never created for it or the peer was disposed), a null will
                 be returned.                
            </comment>
            <comment line="388">
                Maps from non-Component/MenuComponent to AppContext.
                 WeakHashMap&lt;Component,AppContext&gt;                
            </comment>
            <comment line="427">
                Fetch the AppContext associated with the given target.
                 This can be used to determine things like which EventQueue
                 to use for posting events to a Component.  If the target is
                 null or the target can&apos;t be found, a null with be returned.                
            </comment>
            <comment line="540">
                Insert a mapping from target to AppContext, for later retrieval
                 via targetToAppContext() above.                
            </comment>
            <comment line="554">
                Post an AWTEvent to the Java EventQueue, using the PostEventQueue
                 to avoid possibly calling client code (EventQueueSubclass.postEvent())
                 on the toolkit (AWT-WindowsAWT-Motif) thread.  This function should
                 not be called under another lock since it locks the EventQueue.
                 See bugids 4632918, 4526597.                
            </comment>
            <comment line="582">
                Post AWTEvent of high priority.                
            </comment>
            <comment line="598">
                Flush any pending events which haven&apos;t been posted to the AWT
                 EventQueue yet.                
            </comment>
            <comment line="632">
                Execute a chunk of code on the Java event handler thread for the
                 given target.  Does not wait for the execution to occur before
                 returning to the caller.                
            </comment>
            <comment line="642">
                Fixed 5064013: the InvocationEvent time should be equals
                 the time of the ActionEvent                
            </comment>
            <comment line="656">
                Execute a chunk of code on the Java event handler thread for the
                 given target.  Does not wait for the execution to occur before
                 returning to the caller.                
            </comment>
            <comment line="665">
                Execute a chunk of code on the Java event handler thread. The
                 method takes into account provided AppContext and sets
                 &lt;code&gt;SunToolkit.getDefaultToolkit()&lt;code&gt; as a target of the
                 event. See 6451487 for detailes.
                 Does not wait for the execution to occur before returning to
                 the caller.                
            </comment>
            <comment line="681">
                Execute a chunk of code on the Java event handler thread for the
                 given target.  Waits for the execution to occur before returning
                 to the caller.                
            </comment>
            <comment line="711">
                Returns true if the calling thread is the event dispatch thread
                 contained within AppContext which associated with the given target.
                 Use this call to ensure that a given task is being executed
                 (or not being) on the event dispatch thread for the given target.                
            </comment>
            <comment line="1099">
                Package private implementation                
            </comment>
            <comment line="1206">
                Support for window closing event notifications                
            </comment>
            <comment line="1312">
                Default implementation for isModalExcludedSupportedImpl(), returns false.
                
                 @see sun.awt.windows.WToolkit#isModalExcludeSupportedImpl
                 @see sun.awt.X11.XToolkit#isModalExcludeSupportedImpl
                
                 @since 1.5                
            </comment>
            <comment line="1325">
                Sets this window to be excluded from being modally blocked. When the
                 toolkit supports modal exclusion and this method is called, input
                 events, focus transfer and z-order will continue to work for the
                 window, it&apos;s owned windows and child components, even in the
                 presence of a modal dialog.
                 For details on which &lt;code&gt;Window&lt;code&gt;s are normally blocked
                 by modal dialog, see {@link java.awt.Dialog}.
                 Invoking this method when the modal exclusion API is not supported by
                 the current toolkit has no effect.
                 @param window Window to be marked as not modally blocked
                 @see java.awt.Dialog
                 @see java.awt.Dialog#setModal(boolean)
                 @see sun.awt.SunToolkit#isModalExcludedSupported
                 @see sun.awt.SunToolkit#isModalExcluded(java.awt.Window)                
            </comment>
            <comment line="1349">
                Returns whether the specified window is blocked by modal dialogs.
                 If the modal exclusion API isn&apos;t supported by the current toolkit,
                 it returns false for all windows.
                
                 @param window Window to test for modal exclusion
                
                 @return true if the window is modal excluded, false otherwise. If
                 the modal exclusion isn&apos;t supported by the current Toolkit, false
                 is returned
                
                 @see sun.awt.SunToolkit#isModalExcludedSupported
                 @see sun.awt.SunToolkit#setModalExcluded(java.awt.Window)
                
                 @since 1.5                
            </comment>
            <comment line="1388">
                /////////////////////////////////////////////////////////////////////////
                
                 The following is used by the Java Plug-in to coordinate dialog modality
                 between containing applications (browsers, ActiveX containers etc) and
                 the AWT.
                
                /                
            </comment>
            <comment line="1444">
                end of class ModalityListenerList                
            </comment>
            <comment line="1446">
                /////////////////////////////////////////////////////////////////////////
                 End Plug-in code
                /                
            </comment>
            <comment line="1734">
                The following methods and variables are to support retrieving
                 desktop text anti-aliasing settings                
            </comment>
            <comment line="1738">
                                
            </comment>
            <comment line="1749">
                Since Swing is the reason for this &quot;extra condition&quot; logic its
                 worth documenting it in some detail.
                 First, a goal is for Swing and applications to both retrieve and
                 use the same desktop property value so that there is complete
                 consistency between the settings used by JDK&apos;s Swing implementation
                 and 3rd party custom Swing components, custom L&amp;Fs and any general
                 text rendering that wants to be consistent with these.
                 But by default on Solaris &amp; Linux Swing will not use AA text over
                 remote X11 display (unless Xrender can be used which is TBD and may not
                 always be available anyway) as that is a noticeable performance hit.
                 So there needs to be a way to express that extra condition so that
                 it is seen by all clients of the desktop property API.
                 If this were the only condition it could be handled here as it would
                 be the same for any L&amp;F and could reasonably be considered to be
                 a static behaviour of those systems.
                 But GTK currently has an additional test based on locale which is
                 not applied by Metal. So mixing GTK in a few locales with Metal
                 would mean the last one wins.
                 This could be stored per-app context which would work
                 for different applets, but wouldn&apos;t help for a single application
                 using GTK and some other L&amp;F concurrently.
                 But it is expected this will be addressed within GTK and the font
                 system so is a temporary and somewhat unlikely harmless corner case.                
            </comment>
            <comment line="1791">
                &quot;false&quot;, &quot;off&quot;, &quot;&quot;default&quot; aren&apos;t explicitly tested, they
                 just fall through to produce a null return which all are equated to
                 &quot;false&quot;.                
            </comment>
            <comment line="1820">
                This method determines whether to use the system font settings,
                 or ignore them if a L&amp;F has specified they should be ignored, or
                 to override both of these with a system property specified value.
                 If the toolkit isn&apos;t a SunToolkit, (eg may be headless) then that
                 system property isn&apos;t applied as desktop properties are considered
                 to be inapplicable in that case. In that headless case although
                 this method will return &quot;true&quot; the toolkit will return a null map.                
            </comment>
            <comment line="1857">
                                
            </comment>
            <comment line="1860">
                                
            </comment>
            <comment line="1865">
                Subclass desktop property loading methods call this which
                 in turn calls the appropriate subclass implementation of
                 getDesktopAAHints() when system settings are being used.
                 Its public rather than protected because subclasses may delegate
                 to a helper class.                
            </comment>
            <comment line="1893">
                consumeNextKeyTyped() method is not currently used,
                 however Swing could use it in the future.                
            </comment>
            <comment line="1971">
                Cosntant alpha                
            </comment>
            <comment line="1976">
                Shaping                
            </comment>
            <comment line="1981">
                Per-pixel alpha                
            </comment>
            <comment line="2076">
                /////////////////////////////////////////////////////////////////////////
                
                 The following methods help set and identify whether a particular
                 AWTEvent object was produced by the system or by user code. As of this
                 writing the only consumer is the Java Plug-In, although this information
                 could be useful to more clients and probably should be formalized in
                 the public API.
                
                /                
            </comment>
            <comment line="2119">
                Continually post pending AWTEvents to the Java EventQueue. The method
                 is synchronized to ensure the flush is completed before a new event
                 can be posted to this queue.                
            </comment>
            <comment line="2133">
                Enqueue an AWTEvent to be posted to the Java EventQueue.                
            </comment>
            <implements interface="WindowClosingSupport"/>
            <implements interface="WindowClosingListener"/>
            <implements interface="ComponentFactory"/>
            <implements interface="InputMethodSupport"/>
            <implements interface="KeyboardFocusManagerPeerProvider"/>
            <declaration name="log" type="PlatformLogger" line="64"/>
            <scope line="67">
                <scope line="68"/>
            </scope>
            <declaration name="GRAB_EVENT_MASK" type="int" line="73"/>
            <javadoc line="73">
                Special mask for the UngrabEvent events, in addition to the
                  public masks defined in AWTEvent.  Should be used as the mask
                  value for Toolkit.addAWTEventListener.                
            </javadoc>
            <declaration name="wakeupMethod" type="Method" line="80"/>
            <declaration name="POST_EVENT_QUEUE_KEY" type="String" line="83"/>
            <declaration name="numberOfButtons" type="int" line="85"/>
            <javadoc line="85">
                Number of buttons.
                  By default it&apos;s taken from the system. If system value does not
                  fit into int type range, use our own MAX_BUTTONS_SUPPORT value.                
            </javadoc>
            <declaration name="MAX_BUTTONS_SUPPORTED" type="int" line="102"/>
            <method name="SunToolkit" type="constructor" line="104">
                <anonymous_class line="105">
                    <method name="run" type="void" line="106">
                        <declaration name="eventQueue" type="EventQueue" line="107"/>
                        <declaration name="eqName" type="String" line="109"/>
                        <scope line="112"/>
                        <scope line="114"/>
                        <declaration name="appContext" type="AppContext" line="119"/>
                        <declaration name="postEventQueue" type="PostEventQueue" line="122"/>
                    </method>
                </anonymous_class>
                <declaration name="initEQ" type="Runnable" line="105"/>
            </method>
            <method name="useBufferPerWindow" type="boolean" line="130"/>
            <method name="createWindow" type="WindowPeer" line="134"/>
            <method name="createFrame" type="FramePeer" line="137"/>
            <method name="createDialog" type="DialogPeer" line="140"/>
            <method name="createButton" type="ButtonPeer" line="143"/>
            <method name="createTextField" type="TextFieldPeer" line="146"/>
            <method name="createChoice" type="ChoicePeer" line="149"/>
            <method name="createLabel" type="LabelPeer" line="152"/>
            <method name="createList" type="ListPeer" line="155"/>
            <method name="createCheckbox" type="CheckboxPeer" line="158"/>
            <method name="createScrollbar" type="ScrollbarPeer" line="161"/>
            <method name="createScrollPane" type="ScrollPanePeer" line="164"/>
            <method name="createTextArea" type="TextAreaPeer" line="167"/>
            <method name="createFileDialog" type="FileDialogPeer" line="170"/>
            <method name="createMenuBar" type="MenuBarPeer" line="173"/>
            <method name="createMenu" type="MenuPeer" line="176"/>
            <method name="createPopupMenu" type="PopupMenuPeer" line="179"/>
            <method name="createMenuItem" type="MenuItemPeer" line="182"/>
            <method name="createCheckboxMenuItem" type="CheckboxMenuItemPeer" line="185"/>
            <method name="createDragSourceContextPeer" type="DragSourceContextPeer" line="189"/>
            <method name="createTrayIcon" type="TrayIconPeer" line="193"/>
            <method name="createSystemTray" type="SystemTrayPeer" line="196"/>
            <method name="isTraySupported" type="boolean" line="198"/>
            <method name="getFontPeer" type="FontPeer" line="200"/>
            <method name="createRobot" type="RobotPeer" line="202"/>
            <method name="createKeyboardFocusManagerPeer" type="KeyboardFocusManagerPeer" line="205"/>
            <declaration name="AWT_LOCK" type="ReentrantLock" line="208"/>
            <javadoc line="208">
                The AWT lock is typically only used on Unix platforms to synchronize
                  access to Xlib, OpenGL, etc.  However, these methods are implemented
                  in SunToolkit so that they can be called from shared code (e.g.
                  from the OGL pipeline) or from the X11 pipeline regardless of whether
                  XToolkit or MToolkit is currently in use.  There are native macros
                  (such as AWT_LOCK) defined in awt.h, so if the implementation of these
                  methods is changed, make sure it is compatible with the native macros.
                  Note: The following methods (awtLock(), awtUnlock(), etc) should be
                  used in place of:
                  synchronized (getAWTLock()) {
                  ...
                  }
                  By factoring these methods out specially, we are able to change the
                  implementation of these methods (e.g. use more advanced locking
                  mechanisms) without impacting calling code.
                  Sample usage:
                  private void doStuffWithXlib() {
                  assert !SunToolkit.isAWTLockHeldByCurrentThread();
                  SunToolkit.awtLock();
                  try {
                  ...
                  XlibWrapper.XDoStuff();
                  } finally {
                  SunToolkit.awtUnlock();
                  }
                  }                
            </javadoc>
            <declaration name="AWT_LOCK_COND" type="Condition" line="241"/>
            <method name="awtLock" type="void" line="243"/>
            <method name="awtTryLock" type="boolean" line="247"/>
            <method name="awtUnlock" type="void" line="251"/>
            <method name="awtLockWait" type="void" line="257"/>
            <method name="awtLockWait" type="void" line="263">
                <params>
                    <param name="timeout" type="long"/>
                </params>
            </method>
            <method name="awtLockNotify" type="void" line="267"/>
            <method name="awtLockNotifyAll" type="void" line="271"/>
            <method name="isAWTLockHeldByCurrentThread" type="boolean" line="275"/>
            <method name="createNewAppContext" type="AppContext" line="284">
                <comment line="287">
                    Create appContext before initialization of EventQueue, so all
                     the calls to AppContext.getAppContext() from EventQueue ctor
                     return correct values                    
                </comment>
                <declaration name="threadGroup" type="ThreadGroup" line="285"/>
                <declaration name="appContext" type="AppContext" line="289"/>
                <declaration name="eventQueue" type="EventQueue" line="291"/>
                <declaration name="eqName" type="String" line="292"/>
                <scope line="294"/>
                <scope line="296"/>
                <declaration name="postEventQueue" type="PostEventQueue" line="302"/>
            </method>
            <method name="getField" type="Field" line="308">
                <params>
                    <param name="klass" type="Class"/>
                    <param name="fieldName" type="String"/>
                </params>
                <comment line="323">
                    run                    
                </comment>
                <anonymous_class line="309">
                    <method name="run" type="Field" line="310">
                        <scope line="311">
                            <declaration name="field" type="Field" line="312"/>
                        </scope>
                        <scope line="316"/>
                        <scope line="318"/>
                    </method>
                </anonymous_class>
            </method>
            <method name="wakeupEventQueue" type="void" line="326">
                <params>
                    <param name="q" type="EventQueue"/>
                    <param name="isShutdown" type="boolean"/>
                </params>
                <comment line="343">
                    run                    
                </comment>
                <scope line="327">
                    <anonymous_class line="328">
                        <method name="run" type="Object" line="329">
                            <scope line="330">
                                <declaration name="method" type="Method" line="331"/>
                                <scope line="332"/>
                            </scope>
                            <scope line="336"/>
                            <scope line="338"/>
                        </method>
                    </anonymous_class>
                </scope>
                <scope line="345">
                    <scope line="346"/>
                </scope>
                <scope line="349"/>
                <scope line="351"/>
            </method>
            <method name="targetToPeer" type="Object" line="364">
                <params>
                    <param name="target" type="Object"/>
                </params>
                <scope line="365"/>
            </method>
            <method name="targetCreatedPeer" type="void" line="371">
                <params>
                    <param name="target" type="Object"/>
                    <param name="peer" type="Object"/>
                </params>
                <scope line="374"/>
            </method>
            <method name="targetDisposedPeer" type="void" line="379">
                <params>
                    <param name="target" type="Object"/>
                    <param name="peer" type="Object"/>
                </params>
                <scope line="382"/>
            </method>
            <declaration name="appContextMap" type="Map" line="389"/>
            <javadoc line="392">
                Sets the appContext field of target. If target is not a Component or
                  MenuComponent, this returns false.                
            </javadoc>
            <method name="setAppContext" type="boolean" line="397">
                <params>
                    <param name="target" type="Object"/>
                    <param name="context" type="AppContext"/>
                </params>
                <scope line="398"/>
                <scope line="401"/>
                <scope line="404"/>
            </method>
            <javadoc line="410">
                Returns the appContext field for target. If target is not a
                  Component or MenuComponent this returns null.                
            </javadoc>
            <method name="getAppContext" type="AppContext" line="414">
                <params>
                    <param name="target" type="Object"/>
                </params>
                <scope line="415"/>
                <scope line="418"/>
                <scope line="421"/>
            </method>
            <method name="targetToAppContext" type="AppContext" line="432">
                <params>
                    <param name="target" type="Object"/>
                </params>
                <comment line="439">
                    target is not a Component/MenuComponent, try the
                     appContextMap.                    
                </comment>
                <scope line="433"/>
                <declaration name="context" type="AppContext" line="436"/>
                <scope line="437"/>
            </method>
            <javadoc line="445">
                Sets the synchronous status of focus requests on lightweight
                  components in the specified window to the specified value.
                  If the boolean parameter is &lt;code&gt;true&lt;/code&gt; then the focus
                  requests on lightweight components will be performed
                  synchronously, if it is &lt;code&gt;false&lt;/code&gt;, then asynchronously.
                  By default, all windows have their lightweight request status
                  set to asynchronous.
                  &lt;p&gt;
                  The application can only set the status of lightweight focus
                  requests to synchronous for any of its windows if it doesn&apos;t
                  perform focus transfers between different heavyweight containers.
                  In this case the observable focus behaviour is the same as with
                  asynchronous status.
                  &lt;p&gt;
                  If the application performs focus transfer between different
                  heavyweight containers and sets the lightweight focus request
                  status to synchronous for any of its windows, then further focus
                  behaviour is unspecified.
                  &lt;p&gt;                
                <param>
                    w window for which the lightweight focus request status
                      should be set                    
                </param>
                <param>
                    status the value of lightweight focus request status                    
                </param>
            </javadoc>
            <method name="setLWRequestStatus" type="void" line="470">
                <params>
                    <param name="changed" type="Window"/>
                    <param name="status" type="boolean"/>
                </params>
            </method>
            <method name="checkAndSetPolicy" type="void" line="475">
                <params>
                    <param name="cont" type="Container"/>
                    <param name="isSwingCont" type="boolean"/>
                </params>
                <comment line="481">
                    if this is not XAWT then use default policy
                     because Swing change it                    
                </comment>
                <comment line="491">
                    Policy was changed
                     Check if it is awt policy or swing policy
                     If it is Swing policy we shouldn&apos;t use it in AWT frames
                     If it is AWT policy  we shouldn&apos;t use it in Swing frames
                     Otherwise we should use this policy                    
                </comment>
                <comment line="497">
                    AWT                    
                </comment>
                <comment line="499">
                    Can&apos;t use AWT policy in Swing windows - should use Swing&apos;s one.                    
                </comment>
                <comment line="502">
                    New awt policy.                    
                </comment>
                <comment line="506">
                    New Swing&apos;s policy                    
                </comment>
                <comment line="512">
                    Policy is default, use different default policy for swing                    
                </comment>
                <declaration name="defaultPolicy" type="FocusTraversalPolicy" line="476"/>
                <declaration name="toolkitName" type="String" line="479"/>
                <scope line="482"/>
                <declaration name="policyName" type="String" line="487"/>
                <scope line="489">
                    <scope line="495">
                        <scope line="497"/>
                        <scope line="500"/>
                    </scope>
                    <scope line="503">
                        <scope line="504"/>
                        <scope line="506"/>
                    </scope>
                </scope>
                <scope line="510">
                    <scope line="512"/>
                </scope>
            </method>
            <method name="createLayoutPolicy" type="FocusTraversalPolicy" line="519">
                <declaration name="policy" type="FocusTraversalPolicy" line="520"/>
                <scope line="521">
                    <declaration name="layoutPolicyClass" type="Class" line="522"/>
                </scope>
                <scope line="526"/>
                <scope line="529"/>
                <scope line="532"/>
            </method>
            <method name="insertTargetMapping" type="void" line="543">
                <params>
                    <param name="target" type="Object"/>
                    <param name="appContext" type="AppContext"/>
                </params>
                <comment line="547">
                    Target is not a Component/MenuComponent, use the private Map
                     instead.                    
                </comment>
                <scope line="544">
                    <scope line="545"/>
                </scope>
            </method>
            <method name="postEvent" type="void" line="560">
                <params>
                    <param name="appContext" type="AppContext"/>
                    <param name="event" type="AWTEvent"/>
                </params>
                <comment line="565">
                    All events posted via this method are system-generated.
                     Placing the following call here reduces considerably the
                     number of places throughout the toolkit that would
                     otherwise have to be modified to precisely identify
                     system-generated events.                    
                </comment>
                <scope line="561"/>
                <declaration name="eventContext" type="AppContext" line="570"/>
                <scope line="571"/>
                <declaration name="postEventQueue" type="PostEventQueue" line="574"/>
                <scope line="576"/>
            </method>
            <method name="postPriorityEvent" type="void" line="584">
                <params>
                    <param name="e" type="AWTEvent"/>
                </params>
                <anonymous_class line="585">
                    <method name="run" type="void" line="586"/>
                </anonymous_class>
                <declaration name="pe" type="PeerEvent" line="585"/>
            </method>
            <declaration name="flushLock" type="Lock" line="594"/>
            <declaration name="isFlushingPendingEvents" type="boolean" line="595"/>
            <method name="flushPendingEvents" type="void" line="601">
                <comment line="605">
                    Don&apos;t call flushPendingEvents() recursively                    
                </comment>
                <scope line="603">
                    <scope line="605">
                        <declaration name="appContext" type="AppContext" line="607"/>
                        <declaration name="postEventQueue" type="PostEventQueue" line="608"/>
                        <scope line="610"/>
                    </scope>
                </scope>
                <scope line="614"/>
            </method>
            <method name="isPostEventQueueEmpty" type="boolean" line="620">
                <declaration name="appContext" type="AppContext" line="621"/>
                <declaration name="postEventQueue" type="PostEventQueue" line="622"/>
                <scope line="624"/>
                <scope line="626"/>
            </method>
            <method name="executeOnEventHandlerThread" type="void" line="637">
                <params>
                    <param name="target" type="Object"/>
                    <param name="runnable" type="Runnable"/>
                </params>
            </method>
            <method name="executeOnEventHandlerThread" type="void" line="647">
                <params>
                    <param name="target" type="Object"/>
                    <param name="runnable" type="Runnable"/>
                    <param name="when" type="long"/>
                </params>
                <anonymous_class line="648">
                    <method name="getWhen" type="long" line="649"/>
                </anonymous_class>
            </method>
            <method name="executeOnEventHandlerThread" type="void" line="660">
                <params>
                    <param name="peerEvent" type="PeerEvent"/>
                </params>
            </method>
            <method name="invokeLaterOnAppContext" type="void" line="674">
                <params>
                    <param name="appContext" type="AppContext"/>
                    <param name="dispatcher" type="Runnable"/>
                </params>
            </method>
            <method name="executeOnEDTAndWait" type="void" line="687">
                <params>
                    <param name="target" type="Object"/>
                    <param name="runnable" type="Runnable"/>
                </params>
                <scope line="688"/>
                <class name="AWTInvocationLock" line="692"/>
                <declaration name="lock" type="Object" line="693"/>
                <declaration name="event" type="PeerEvent" line="695"/>
                <scope line="697">
                    <scope line="699"/>
                </scope>
                <declaration name="eventThrowable" type="Throwable" line="704"/>
                <scope line="705"/>
            </method>
            <method name="isDispatchThreadForAppContext" type="boolean" line="716">
                <params>
                    <param name="target" type="Object"/>
                </params>
                <declaration name="appContext" type="AppContext" line="717"/>
                <declaration name="eq" type="EventQueue" line="718"/>
                <declaration name="accessor" type="AWTAccessor.EventQueueAccessor" line="720"/>
            </method>
            <method name="getScreenSize" type="Dimension" line="724"/>
            <method name="getScreenWidth" type="int" line="727"/>
            <method name="getScreenHeight" type="int" line="728"/>
            <method name="getFontMetrics" type="FontMetrics" line="730">
                <params>
                    <param name="font" type="Font"/>
                </params>
            </method>
            <method name="getFontList" type="String[]" line="734">
                <comment line="740">
                    -- Obsolete font names from 1.0.2.  It was decided that
                     -- getFontList should not return these old names:
                        &quot;Helvetica&quot;, &quot;TimesRoman&quot;, &quot;Courier&quot;, &quot;ZapfDingbats&quot;                    
                </comment>
                <declaration name="hardwiredFontList" type="String[]" line="735"/>
            </method>
            <method name="createPanel" type="PanelPeer" line="746">
                <params>
                    <param name="target" type="Panel"/>
                </params>
            </method>
            <method name="createCanvas" type="CanvasPeer" line="750">
                <params>
                    <param name="target" type="Canvas"/>
                </params>
            </method>
            <javadoc line="754">
                Disables erasing of background on the canvas before painting if
                  this is supported by the current toolkit. It is recommended to
                  call this method early, before the Canvas becomes displayable,
                  because some Toolkit implementations do not support changing
                  this property once the Canvas becomes displayable.                
            </javadoc>
            <method name="disableBackgroundErase" type="void" line="761">
                <params>
                    <param name="canvas" type="Canvas"/>
                </params>
            </method>
            <javadoc line="765">
                Disables the native erasing of the background on the given
                  component before painting if this is supported by the current
                  toolkit. This only has an effect for certain components such as
                  Canvas, Panel and Window. It is recommended to call this method
                  early, before the Component becomes displayable, because some
                  Toolkit implementations do not support changing this property
                  once the Component becomes displayable.                
            </javadoc>
            <method name="disableBackgroundErase" type="void" line="774">
                <params>
                    <param name="component" type="Component"/>
                </params>
            </method>
            <method name="disableBackgroundEraseImpl" type="void" line="778">
                <params>
                    <param name="component" type="Component"/>
                </params>
            </method>
            <javadoc line="782">
                Returns the value of &quot;sun.awt.noerasebackground&quot; property. Default
                  value is {@code false}.                
            </javadoc>
            <method name="getSunAwtNoerasebackground" type="boolean" line="786"/>
            <javadoc line="790">
                Returns the value of &quot;sun.awt.erasebackgroundonresize&quot; property. Default
                  value is {@code false}.                
            </javadoc>
            <method name="getSunAwtErasebackgroundonresize" type="boolean" line="794"/>
            <declaration name="imgCache" type="SoftCache" line="799"/>
            <method name="getImageFromHash" type="Image" line="801">
                <params>
                    <param name="tk" type="Toolkit"/>
                    <param name="url" type="URL"/>
                </params>
                <comment line="812">
                    fallback to checkRead/checkConnect for pre 1.2
                     security managers                    
                </comment>
                <declaration name="sm" type="SecurityManager" line="802"/>
                <scope line="803">
                    <scope line="804">
                        <declaration name="perm" type="java.security.Permission" line="805"/>
                        <scope line="807">
                            <scope line="808"/>
                            <scope line="810">
                                <scope line="814"/>
                                <scope line="818"/>
                                <scope line="820"/>
                            </scope>
                        </scope>
                    </scope>
                    <scope line="825"/>
                </scope>
                <scope line="829">
                    <declaration name="img" type="Image" line="830"/>
                    <scope line="831">
                        <scope line="832"/>
                        <scope line="835"/>
                    </scope>
                </scope>
            </method>
            <method name="getImageFromHash" type="Image" line="843">
                <params>
                    <param name="tk" type="Toolkit"/>
                    <param name="filename" type="String"/>
                </params>
                <declaration name="security" type="SecurityManager" line="844"/>
                <scope line="845"/>
                <scope line="848">
                    <declaration name="img" type="Image" line="849"/>
                    <scope line="850">
                        <scope line="851"/>
                        <scope line="854"/>
                    </scope>
                </scope>
            </method>
            <method name="getImage" type="Image" line="861">
                <params>
                    <param name="filename" type="String"/>
                </params>
            </method>
            <method name="getImage" type="Image" line="865">
                <params>
                    <param name="url" type="URL"/>
                </params>
            </method>
            <method name="createImage" type="Image" line="869">
                <params>
                    <param name="filename" type="String"/>
                </params>
                <declaration name="security" type="SecurityManager" line="870"/>
                <scope line="871"/>
            </method>
            <method name="createImage" type="Image" line="877">
                <params>
                    <param name="url" type="URL"/>
                </params>
                <comment line="888">
                    fallback to checkRead/checkConnect for pre 1.2
                     security managers                    
                </comment>
                <declaration name="sm" type="SecurityManager" line="878"/>
                <scope line="879">
                    <scope line="880">
                        <declaration name="perm" type="java.security.Permission" line="881"/>
                        <scope line="883">
                            <scope line="884"/>
                            <scope line="886">
                                <scope line="890"/>
                                <scope line="894"/>
                                <scope line="896"/>
                            </scope>
                        </scope>
                    </scope>
                    <scope line="901"/>
                </scope>
            </method>
            <method name="createImage" type="Image" line="908">
                <params>
                    <param name="data" type="byte[]"/>
                    <param name="offset" type="int"/>
                    <param name="length" type="int"/>
                </params>
            </method>
            <method name="createImage" type="Image" line="912">
                <params>
                    <param name="producer" type="ImageProducer"/>
                </params>
            </method>
            <method name="checkImage" type="int" line="916">
                <params>
                    <param name="img" type="Image"/>
                    <param name="w" type="int"/>
                    <param name="h" type="int"/>
                    <param name="o" type="ImageObserver"/>
                </params>
                <scope line="917"/>
                <declaration name="tkimg" type="ToolkitImage" line="921"/>
                <declaration name="repbits" type="int" line="922"/>
                <scope line="923"/>
                <scope line="925"/>
            </method>
            <method name="prepareImage" type="boolean" line="931">
                <params>
                    <param name="img" type="Image"/>
                    <param name="w" type="int"/>
                    <param name="h" type="int"/>
                    <param name="o" type="ImageObserver"/>
                </params>
                <comment line="937">
                    Must be a ToolkitImage                    
                </comment>
                <scope line="932"/>
                <scope line="937"/>
                <declaration name="tkimg" type="ToolkitImage" line="941"/>
                <scope line="942">
                    <scope line="943"/>
                </scope>
                <declaration name="ir" type="ImageRepresentation" line="949"/>
            </method>
            <javadoc line="953">
                Scans {@code imageList} for best-looking image of specified dimensions.
                  Image can be scaled and/or padded with transparency.                
            </javadoc>
            <method name="getScaledIconImage" type="BufferedImage" line="957">
                <params>
                    <param name="imageList" type="java.util.List<Image>"/>
                    <param name="width" type="int"/>
                    <param name="height" type="int"/>
                </params>
                <comment line="965">
                    Impossibly high value                    
                </comment>
                <comment line="968">
                    Iterate imageList looking for best matching image.
                    &apos;Similarity&apos; measure is defined as good scale factor and small insets.
                    best possible similarity is 0 (no scale, no insets).
                    It&apos;s found while the experiments that good-looking result is achieved
                    with scale factors x1, x3/4, x2/3, xN, x1/N.                    
                </comment>
                <comment line="998">
                    Calc scale factor                    
                </comment>
                <comment line="1001">
                    Calculate scaled image dimensions
                    adjusting scale factor to nearest &quot;good&quot; value                    
                </comment>
                <comment line="1005">
                    0 - best (no) scale, 1 - impossibly bad                    
                </comment>
                <comment line="1007">
                    Need to enlarge image more than twice
                    Round down scale factor to multiply by integer value                    
                </comment>
                <comment line="1014">
                    Don&apos;t scale                    
                </comment>
                <comment line="1020">
                    Multiply by 3/4                    
                </comment>
                <comment line="1026">
                    Multiply by 2/3                    
                </comment>
                <comment line="1032">
                    Multiply size by 1/scaleDivider
                    where scaleDivider is minimum possible integer
                    larger than 1/scaleFactor                    
                </comment>
                <comment line="1042">
                    Large padding is bad                    
                </comment>
                <comment line="1043">
                    Large rescale is bad                    
                </comment>
                <comment line="1055">
                    No images were found, possibly all are broken                    
                </comment>
                <scope line="958"/>
                <declaration name="bestImage" type="Image" line="961"/>
                <declaration name="bestWidth" type="int" line="962"/>
                <declaration name="bestHeight" type="int" line="963"/>
                <declaration name="bestSimilarity" type="double" line="964"/>
                <declaration name="bestScaleFactor" type="double" line="965"/>
                <scope line="966">
                    <declaration name="im" type="Image" line="972"/>
                    <scope line="973">
                        <scope line="974"/>
                    </scope>
                    <scope line="980">
                        <declaration name="ir" type="ImageRepresentation" line="981"/>
                    </scope>
                    <declaration name="iw" type="int" line="984"/>
                    <declaration name="ih" type="int" line="985"/>
                    <scope line="986"/>
                    <scope line="989">
                        <scope line="990"/>
                    </scope>
                    <scope line="996">
                        <declaration name="scaleFactor" type="double" line="998"/>
                        <declaration name="adjw" type="int" line="1002"/>
                        <declaration name="adjh" type="int" line="1003"/>
                        <declaration name="scaleMeasure" type="double" line="1004"/>
                        <scope line="1005"/>
                        <scope line="1012"/>
                        <scope line="1018"/>
                        <scope line="1024"/>
                        <scope line="1030">
                            <declaration name="scaleDivider" type="double" line="1034"/>
                        </scope>
                        <declaration name="similarity" type="double" line="1040"/>
                        <scope line="1043"/>
                    </scope>
                </scope>
                <scope line="1053"/>
                <declaration name="bimage" type="BufferedImage" line="1057"/>
                <declaration name="g" type="Graphics2D" line="1059"/>
                <scope line="1062">
                    <declaration name="x" type="int" line="1063"/>
                    <declaration name="y" type="int" line="1064"/>
                    <scope line="1065"/>
                </scope>
                <scope line="1074"/>
            </method>
            <method name="getScaledIconData" type="DataBufferInt" line="1080">
                <params>
                    <param name="imageList" type="java.util.List<Image>"/>
                    <param name="width" type="int"/>
                    <param name="height" type="int"/>
                </params>
                <declaration name="bimage" type="BufferedImage" line="1081"/>
                <scope line="1082">
                    <scope line="1083"/>
                </scope>
                <declaration name="raster" type="Raster" line="1089"/>
                <declaration name="buffer" type="DataBuffer" line="1090"/>
            </method>
            <method name="getSystemEventQueueImpl" type="EventQueue" line="1094"/>
            <method name="getSystemEventQueueImplPP" type="EventQueue" line="1099"/>
            <method name="getSystemEventQueueImplPP" type="EventQueue" line="1103">
                <params>
                    <param name="appContext" type="AppContext"/>
                </params>
                <declaration name="theEventQueue" type="EventQueue" line="1104"/>
            </method>
            <javadoc line="1109">
                Give native peers the ability to query the native container
                  given a native component (eg the direct parent may be lightweight).                
            </javadoc>
            <method name="getNativeContainer" type="Container" line="1113">
                <params>
                    <param name="c" type="Component"/>
                </params>
            </method>
            <javadoc line="1117">
                Gives native peers the ability to query the closest HW component.
                  If the given component is heavyweight, then it returns this. Otherwise,
                  it goes one level up in the hierarchy and tests next component.                
            </javadoc>
            <method name="getHeavyweightComponent" type="Component" line="1122">
                <params>
                    <param name="c" type="Component"/>
                </params>
                <scope line="1123"/>
            </method>
            <javadoc line="1129">
                Returns a new input method window, with behavior as specified in{@link java.awt.im.spi.InputMethodContext#createInputMethodWindow}.
                  If the inputContext is not null, the window should return it from its
                  getInputContext() method. The window needs to implement
                  sun.awt.im.InputMethodWindow.
                  &lt;p&gt;
                  SunToolkit subclasses can override this method to return better input
                  method windows.                
            </javadoc>
            <method name="createInputMethodWindow" type="Window" line="1139">
                <params>
                    <param name="title" type="String"/>
                    <param name="context" type="InputContext"/>
                </params>
            </method>
            <javadoc line="1143">
                Returns whether enableInputMethods should be set to true for peered
                  TextComponent instances on this platform. False by default.                
            </javadoc>
            <method name="enableInputMethodsForTextComponent" type="boolean" line="1147"/>
            <declaration name="startupLocale" type="Locale" line="1151"/>
            <javadoc line="1153">
                Returns the locale in which the runtime was started.                
            </javadoc>
            <method name="getStartupLocale" type="Locale" line="1156">
                <comment line="1162">
                    for compatibility, check for old user.region property                    
                </comment>
                <comment line="1166">
                    region can be of form country, country_variant, or _variant                    
                </comment>
                <scope line="1157">
                    <declaration name="language" type="String" line="1158"/>
                    <scope line="1164">
                        <declaration name="i" type="int" line="1166"/>
                        <scope line="1167"/>
                        <scope line="1170"/>
                    </scope>
                    <scope line="1174"/>
                </scope>
            </method>
            <javadoc line="1185">
                Returns the default keyboard locale of the underlying operating system                
            </javadoc>
            <method name="getDefaultKeyboardLocale" type="Locale" line="1188"/>
            <declaration name="dataTransfererClassName" type="String" line="1192"/>
            <method name="setDataTransfererClassName" type="void" line="1194">
                <params>
                    <param name="className" type="String"/>
                </params>
            </method>
            <method name="getDataTransfererClassName" type="String" line="1198">
                <comment line="1201">
                    transferer set during toolkit init                    
                </comment>
                <scope line="1199"/>
            </method>
            <declaration name="windowClosingListener" type="WindowClosingListener" line="1206"/>
            <javadoc line="1207">
                @see sun.awt.WindowClosingSupport#getWindowClosingListener                
            </javadoc>
            <method name="getWindowClosingListener" type="WindowClosingListener" line="1210"/>
            <javadoc line="1213">
                @see sun.awt.WindowClosingSupport#setWindowClosingListener                
            </javadoc>
            <method name="setWindowClosingListener" type="void" line="1216">
                <params>
                    <param name="wcl" type="WindowClosingListener"/>
                </params>
            </method>
            <javadoc line="1220">
                @see sun.awt.WindowClosingListener#windowClosingNotify                
            </javadoc>
            <method name="windowClosingNotify" type="RuntimeException" line="1223">
                <params>
                    <param name="event" type="WindowEvent"/>
                </params>
                <scope line="1224"/>
                <scope line="1226"/>
            </method>
            <javadoc line="1230">
                @see sun.awt.WindowClosingListener#windowClosingDelivered                
            </javadoc>
            <method name="windowClosingDelivered" type="RuntimeException" line="1233">
                <params>
                    <param name="event" type="WindowEvent"/>
                </params>
                <scope line="1234"/>
                <scope line="1236"/>
            </method>
            <declaration name="mPeer" type="DefaultMouseInfoPeer" line="1241"/>
            <method name="getMouseInfoPeer" type="MouseInfoPeer" line="1243">
                <scope line="1244"/>
            </method>
            <javadoc line="1251">
                Returns whether default toolkit needs the support of the xembed
                  from embedding host(if any).                
                <return>
                    <code>true</code>, if XEmbed is needed, <code>false</code> otherwise                    
                </return>
            </javadoc>
            <method name="needsXEmbed" type="boolean" line="1256">
                <comment line="1266">
                    SunToolkit descendants should override this method to specify
                     concrete behavior                    
                </comment>
                <comment line="1270">
                    Non-SunToolkit doubtly might support XEmbed                    
                </comment>
                <declaration name="noxembed" type="String" line="1257"/>
                <scope line="1259"/>
                <declaration name="tk" type="Toolkit" line="1263"/>
                <scope line="1264"/>
                <scope line="1268"/>
            </method>
            <javadoc line="1274">
                Returns whether this toolkit needs the support of the xembed
                  from embedding host(if any).                
                <return>
                    <code>true</code>, if XEmbed is needed, <code>false</code> otherwise                    
                </return>
            </javadoc>
            <method name="needsXEmbedImpl" type="boolean" line="1279"/>
            <declaration name="DEFAULT_MODAL_EXCLUSION_TYPE" type="Dialog.ModalExclusionType" line="1283"/>
            <javadoc line="1285">
                Returns whether the XEmbed server feature is requested by
                  developer.  If true, Toolkit should return an
                  XEmbed-server-enabled CanvasPeer instead of the ordinary CanvasPeer.                
            </javadoc>
            <method name="isXEmbedServerRequested" type="boolean" line="1290"/>
            <javadoc line="1294">
                Returns whether the modal exclusion API is supported by the current toolkit.
                  When it isn&apos;t supported, calling &lt;code&gt;setModalExcluded&lt;/code&gt; has no
                  effect, and &lt;code&gt;isModalExcluded&lt;/code&gt; returns false for all windows.                
                <return>
                    true if modal exclusion is supported by the toolkit, false otherwise                    
                </return>
                <see>
                    sun.awt.SunToolkit#setModalExcluded(java.awt.Window)                    
                </see>
                <see>
                    sun.awt.SunToolkit#isModalExcluded(java.awt.Window)                    
                </see>
                <since>
                    1.5                    
                </since>
            </javadoc>
            <method name="isModalExcludedSupported" type="boolean" line="1307">
                <declaration name="tk" type="Toolkit" line="1308"/>
            </method>
            <method name="isModalExcludedSupportedImpl" type="boolean" line="1320"/>
            <method name="setModalExcluded" type="void" line="1341">
                <params>
                    <param name="window" type="Window"/>
                </params>
                <scope line="1342"/>
            </method>
            <method name="isModalExcluded" type="boolean" line="1365">
                <params>
                    <param name="window" type="Window"/>
                </params>
                <scope line="1366"/>
            </method>
            <javadoc line="1372">
                Overridden in XToolkit and WToolkit                
            </javadoc>
            <method name="isModalityTypeSupported" type="boolean" line="1375">
                <params>
                    <param name="modalityType" type="Dialog.ModalityType"/>
                </params>
            </method>
            <javadoc line="1380">
                Overridden in XToolkit and WToolkit                
            </javadoc>
            <method name="isModalExclusionTypeSupported" type="boolean" line="1383">
                <params>
                    <param name="exclusionType" type="Dialog.ModalExclusionType"/>
                </params>
            </method>
            <declaration name="modalityListeners" type="ModalityListenerList" line="1395"/>
            <method name="addModalityListener" type="void" line="1397">
                <params>
                    <param name="listener" type="ModalityListener"/>
                </params>
            </method>
            <method name="removeModalityListener" type="void" line="1401">
                <params>
                    <param name="listener" type="ModalityListener"/>
                </params>
            </method>
            <method name="notifyModalityPushed" type="void" line="1405">
                <params>
                    <param name="dialog" type="Dialog"/>
                </params>
            </method>
            <method name="notifyModalityPopped" type="void" line="1409">
                <params>
                    <param name="dialog" type="Dialog"/>
                </params>
            </method>
            <method name="notifyModalityChange" type="void" line="1413">
                <params>
                    <param name="id" type="int"/>
                    <param name="source" type="Dialog"/>
                </params>
                <declaration name="ev" type="ModalityEvent" line="1414"/>
            </method>
            <class name="ModalityListenerList" line="1418">
                <implements interface="ModalityListener"/>
                <declaration name="listeners" type="Vector&lt;ModalityListener&gt;" line="1420"/>
                <method name="add" type="void" line="1422">
                    <params>
                        <param name="listener" type="ModalityListener"/>
                    </params>
                </method>
                <method name="remove" type="void" line="1426">
                    <params>
                        <param name="listener" type="ModalityListener"/>
                    </params>
                </method>
                <method name="modalityPushed" type="void" line="1430">
                    <params>
                        <param name="ev" type="ModalityEvent"/>
                    </params>
                    <declaration name="it" type="Iterator&lt;ModalityListener&gt;" line="1431"/>
                    <scope line="1432"/>
                </method>
                <method name="modalityPopped" type="void" line="1437">
                    <params>
                        <param name="ev" type="ModalityEvent"/>
                    </params>
                    <declaration name="it" type="Iterator&lt;ModalityListener&gt;" line="1438"/>
                    <scope line="1439"/>
                </method>
            </class>
            <method name="isLightweightOrUnknown" type="boolean" line="1449">
                <params>
                    <param name="comp" type="Component"/>
                </params>
                <scope line="1452"/>
            </method>
            <method name="getMethod" type="Method" line="1469">
                <params>
                    <param name="clz" type="Class"/>
                    <param name="methodName" type="String"/>
                    <param name="params" type="Class[]"/>
                </params>
                <declaration name="res" type="Method" line="1470"/>
                <scope line="1471">
                    <anonymous_class line="1472">
                        <method name="run" type="Method" line="1473">
                            <declaration name="m" type="Method" line="1474"/>
                        </method>
                    </anonymous_class>
                </scope>
                <scope line="1479"/>
            </method>
            <class name="OperationTimedOut" line="1485">
                <extends class="RuntimeException"/>
                <method name="OperationTimedOut" type="constructor" line="1486">
                    <params>
                        <param name="msg" type="String"/>
                    </params>
                </method>
                <method name="OperationTimedOut" type="constructor" line="1489"/>
            </class>
            <class name="InfiniteLoop" line="1492">
                <extends class="RuntimeException"/>
            </class>
            <class name="IllegalThreadException" line="1495">
                <extends class="RuntimeException"/>
                <method name="IllegalThreadException" type="constructor" line="1496">
                    <params>
                        <param name="msg" type="String"/>
                    </params>
                </method>
                <method name="IllegalThreadException" type="constructor" line="1499"/>
            </class>
            <declaration name="DEFAULT_WAIT_TIME" type="int" line="1503"/>
            <declaration name="MAX_ITERS" type="int" line="1504"/>
            <declaration name="MIN_ITERS" type="int" line="1505"/>
            <declaration name="MINIMAL_EDELAY" type="int" line="1506"/>
            <javadoc line="1508">
                Parameterless version of realsync which uses default timout (see DEFAUL_WAIT_TIME).                
            </javadoc>
            <method name="realSync" type="void" line="1511"/>
            <javadoc line="1515">
                Forces toolkit to synchronize with the native windowing
                  sub-system, flushing all pending work and waiting for all the
                  events to be processed.  This method guarantees that after
                  return no additional Java events will be generated, unless
                  cause by user. Obviously, the method cannot be used on the
                  event dispatch thread (EDT). In case it nevertheless gets
                  invoked on this thread, the method throws the
                  IllegalThreadException runtime exception.
                  &lt;p&gt; This method allows to write tests without explicit timeouts
                  or wait for some event.  Example:
                  &lt;code&gt;
                  Frame f = ...;
                  f.setVisible(true);
                  ((SunToolkit)Toolkit.getDefaultToolkit()).realSync();
                  &lt;/code&gt;
                  &lt;p&gt; After realSync, &lt;code&gt;f&lt;/code&gt; will be completely visible
                  on the screen, its getLocationOnScreen will be returning the
                  right result and it will be the focus owner.
                  &lt;p&gt; Another example:
                  &lt;code&gt;
                  b.requestFocus();
                  ((SunToolkit)Toolkit.getDefaultToolkit()).realSync();
                  &lt;/code&gt;
                  &lt;p&gt; After realSync, &lt;code&gt;b&lt;/code&gt; will be focus owner.
                  &lt;p&gt; Notice that realSync isn&apos;t guaranteed to work if recurring
                  actions occur, such as if during processing of some event
                  another request which may generate some events occurs.  By
                  default, sync tries to perform as much as {@value MAX_ITERS}cycles of event processing, allowing for roughly {@value
                      MAX_ITERS} additional requests.
                  &lt;p&gt; For example, requestFocus() generates native request, which
                  generates one or two Java focus events, which then generate a
                  serie of paint events, a serie of Java focus events, which then
                  generate a serie of paint events which then are processed -
                  three cycles, minimum.                
                <param>
                    timeout the maximum time to wait in milliseconds, negative means "forever".                    
                </param>
            </javadoc>
            <method name="realSync" type="void" line="1561">
                <params>
                    <param name="timeout" type="long"/>
                </params>
                <comment line="1568">
                    Let&apos;s do sync first                    
                </comment>
                <comment line="1571">
                    During the wait process, when we were processing incoming
                     events, we could have made some new request, which can
                     generate new events.  Example: MapNotify/XSetInputFocus.
                     Therefore, we dispatch them as long as there is something
                     to dispatch.                    
                </comment>
                <comment line="1588">
                    native requests were dispatched by X/Window Manager or Windows
                     Moreover, we processed them all on Toolkit thread
                     Now wait while EDT processes them.
                    
                     During processing of some events (focus, for example),
                     some other events could have been generated.  So, after
                     waitForIdle, we may end up with full EventQueue                    
                </comment>
                <comment line="1608">
                    Again, for Java events, it was simple to check for new Java
                     events by checking event queue, but what if Java events
                     resulted in native requests?  Therefor, check native events again.                    
                </comment>
                <scope line="1562"/>
                <declaration name="bigLoop" type="int" line="1565"/>
                <scope line="1566">
                    <declaration name="iters" type="int" line="1575"/>
                    <scope line="1576"/>
                    <scope line="1580"/>
                    <scope line="1583"/>
                    <scope line="1595"/>
                    <scope line="1599"/>
                    <scope line="1602"/>
                </scope>
            </method>
            <method name="syncNativeQueue" type="boolean" line="1613"/>
            <javadoc line="1613">
                Platform toolkits need to implement this method to perform the
                  sync of the native queue.  The method should wait until native
                  requests are processed, all native events are processed and
                  corresponding Java events are generated.  Should return
                  &lt;code&gt;true&lt;/code&gt; if some events were processed,
                  &lt;code&gt;false&lt;/code&gt; otherwise.                
            </javadoc>
            <declaration name="eventDispatched" type="boolean" line="1623"/>
            <declaration name="queueEmpty" type="boolean" line="1624"/>
            <declaration name="waitLock" type="Object" line="1625"/>
            <declaration name="eqNoEvents" type="Method" line="1627"/>
            <method name="isEQEmpty" type="boolean" line="1629">
                <declaration name="queue" type="EventQueue" line="1630"/>
                <scope line="1631">
                    <scope line="1632"/>
                </scope>
                <scope line="1636"/>
                <scope line="1638"/>
            </method>
            <javadoc line="1644">
                Waits for the Java event queue to empty.  Ensures that all
                  events are processed (including paint events), and that if
                  recursive events were generated, they are also processed.
                  Should return &lt;code&gt;true&lt;/code&gt; if more processing is
                  necessary, &lt;code&gt;false&lt;/code&gt; otherwise.                
            </javadoc>
            <method name="waitForIdle" type="boolean" line="1651">
                <params>
                    <param name="timeout" type="long"/>
                </params>
                <comment line="1661">
                    Here we block EDT.  It could have some
                     events, it should have dispatched them by
                     now.  So native requests could have been
                     generated.  First, dispatch them.  Then,
                     flush Java events again.                    
                </comment>
                <comment line="1700">
                    Lock to force write-cache flush for queueEmpty.                    
                </comment>
                <declaration name="queueWasEmpty" type="boolean" line="1653"/>
                <scope line="1656">
                    <anonymous_class line="1658">
                        <method name="dispatch" type="void" line="1659">
                            <comment line="1661">
                                Here we block EDT.  It could have some
                                 events, it should have dispatched them by
                                 now.  So native requests could have been
                                 generated.  First, dispatch them.  Then,
                                 flush Java events again.                                
                            </comment>
                            <declaration name="iters" type="int" line="1665"/>
                            <scope line="1666"/>
                            <scope line="1670"/>
                            <scope line="1675"/>
                        </method>
                    </anonymous_class>
                    <scope line="1682">
                        <scope line="1683"/>
                    </scope>
                    <scope line="1686"/>
                </scope>
                <scope line="1691"/>
                <scope line="1693"/>
                <scope line="1700"/>
            </method>
            <method name="grab" type="void" line="1705"/>
            <javadoc line="1705">
                Grabs the mouse input for the given window.  The window must be
                  visible.  The window or its children do not receive any
                  additional mouse events besides those targeted to them.  All
                  other events will be dispatched as before - to the respective
                  targets.  This Window will receive UngrabEvent when automatic
                  ungrab is about to happen.  The event can be listened to by
                  installing AWTEventListener with WINDOW_EVENT_MASK.  See
                  UngrabEvent class for the list of conditions when ungrab is
                  about to happen.                
                <see>
                    UngrabEvent                    
                </see>
            </javadoc>
            <method name="ungrab" type="void" line="1719"/>
            <javadoc line="1719">
                Forces ungrab.  No event will be sent.                
            </javadoc>
            <method name="closeSplashScreen" type="void" line="1725"/>
            <javadoc line="1725">
                Locates the splash screen library in a platform dependent way and closes
                  the splash screen. Should be invoked on first top-level frame display.                
                <see>
                    java.awt.SplashScreen                    
                </see>
                <since>
                    1.6                    
                </since>
            </javadoc>
            <method name="fireDesktopFontPropertyChanges" type="void" line="1738"/>
            <declaration name="checkedSystemAAFontSettings" type="boolean" line="1743"/>
            <declaration name="useSystemAAFontSettings" type="boolean" line="1744"/>
            <declaration name="lastExtraCondition" type="boolean" line="1745"/>
            <declaration name="desktopFontHints" type="RenderingHints" line="1746"/>
            <method name="setAAFontSettingsCondition" type="void" line="1772">
                <params>
                    <param name="extraCondition" type="boolean"/>
                </params>
                <comment line="1777">
                    Someone already asked for this info, under a different
                     condition.
                     We&apos;ll force re-evaluation instead of replicating the
                     logic, then notify any listeners of any change.                    
                </comment>
                <scope line="1773">
                    <scope line="1775">
                        <declaration name="tk" type="Toolkit" line="1782"/>
                        <scope line="1783"/>
                    </scope>
                </scope>
            </method>
            <method name="getDesktopAAHintsByName" type="RenderingHints" line="1794">
                <params>
                    <param name="hintname" type="String"/>
                </params>
                <declaration name="aaHint" type="Object" line="1795"/>
                <scope line="1797"/>
                <scope line="1799"/>
                <scope line="1801"/>
                <scope line="1803"/>
                <scope line="1805"/>
                <scope line="1807"/>
                <scope line="1810">
                    <declaration name="map" type="RenderingHints" line="1811"/>
                </scope>
                <scope line="1814"/>
            </method>
            <method name="useSystemAAFontSettings" type="boolean" line="1827">
                <comment line="1830">
                                        
                </comment>
                <comment line="1841">
                    If it is anything other than &quot;true&quot;, then it may be
                     a hint name , or it may be &quot;off, &quot;default&quot;, etc.                    
                </comment>
                <comment line="1848">
                                        
                </comment>
                <scope line="1828">
                    <declaration name="systemAAFonts" type="String" line="1830"/>
                    <declaration name="tk" type="Toolkit" line="1831"/>
                    <scope line="1832"/>
                    <scope line="1837">
                        <scope line="1843"/>
                    </scope>
                    <scope line="1848"/>
                </scope>
            </method>
            <declaration name="DESKTOPFONTHINTS" type="String" line="1857"/>
            <method name="getDesktopAAHints" type="RenderingHints" line="1860"/>
            <method name="getDesktopFontHints" type="RenderingHints" line="1870">
                <comment line="1877">
                                        
                </comment>
                <comment line="1881">
                    cloning not necessary as the return value is cloned later, but
                     its harmless.                    
                </comment>
                <scope line="1871">
                    <declaration name="tk" type="Toolkit" line="1872"/>
                    <scope line="1873">
                        <declaration name="map" type="Object" line="1874"/>
                    </scope>
                    <scope line="1876"/>
                </scope>
                <scope line="1879"/>
                <scope line="1884"/>
            </method>
            <method name="isDesktopSupported" type="boolean" line="1890"/>
            <declaration name="consumeNextKeyTypedMethod" type="Method" line="1896"/>
            <method name="consumeNextKeyTyped" type="void" line="1897">
                <params>
                    <param name="keyEvent" type="KeyEvent"/>
                </params>
                <scope line="1898"/>
                <scope line="1903"/>
                <scope line="1906"/>
                <scope line="1908"/>
            </method>
            <method name="dumpPeers" type="void" line="1913">
                <params>
                    <param name="aLog" type="PlatformLogger"/>
                </params>
            </method>
            <javadoc line="1917">
                Returns the &lt;code&gt;Window&lt;/code&gt; ancestor of the component &lt;code&gt;comp&lt;/code&gt;.                
                <return>
                    Window ancestor of the component or component by itself if it is Window;
                      null, if component is not a part of window hierarchy                    
                </return>
            </javadoc>
            <method name="getContainingWindow" type="Window" line="1922">
                <params>
                    <param name="comp" type="Component"/>
                </params>
                <scope line="1923"/>
            </method>
            <javadoc line="1929">
                Returns the value of the system property indicated by the specified key.                
            </javadoc>
            <method name="getSystemProperty" type="String" line="1932">
                <params>
                    <param name="key" type="String"/>
                </params>
                <anonymous_class line="1933">
                    <method name="run" type="Object" line="1934"/>
                </anonymous_class>
            </method>
            <javadoc line="1940">
                Returns the boolean value of the system property indicated by the specified key.                
            </javadoc>
            <method name="getBooleanSystemProperty" type="Boolean" line="1943">
                <params>
                    <param name="key" type="String"/>
                </params>
            </method>
            <declaration name="sunAwtDisableMixing" type="Boolean" line="1948"/>
            <javadoc line="1950">
                Returns the value of &quot;sun.awt.disableMixing&quot; property. Default
                  value is {@code false}.                
            </javadoc>
            <method name="getSunAwtDisableMixing" type="boolean" line="1954">
                <scope line="1955"/>
            </method>
            <javadoc line="1961">
                Returns true if the native GTK libraries are available.  The
                  default implementation returns false, but UNIXToolkit overrides this
                  method to provide a more specific answer.                
            </javadoc>
            <method name="isNativeGTKAvailable" type="boolean" line="1966"/>
            <method name="isWindowOpacitySupported" type="boolean" line="1971"/>
            <method name="isWindowShapingSupported" type="boolean" line="1976"/>
            <method name="isWindowTranslucencySupported" type="boolean" line="1981"/>
            <method name="isTranslucencyCapable" type="boolean" line="1985">
                <params>
                    <param name="gc" type="GraphicsConfiguration"/>
                </params>
            </method>
            <javadoc line="1989">
                Returns whether or not a containing top level window for the passed
                  component is{@link GraphicsDevice.WindowTranslucency#PERPIXEL_TRANSLUCENT PERPIXEL_TRANSLUCENT}.                
                <param>
                    c a Component which toplevel's to check                    
                </param>
                <return>
                    {@code true}  if the passed component is not null and has a
                      containing toplevel window which is opaque (so per-pixel translucency
                      is not enabled), {@code false} otherwise                    
                </return>
                <see>
                    GraphicsDevice.WindowTranslucency#PERPIXEL_TRANSLUCENT                    
                </see>
            </javadoc>
            <method name="isContainingTopLevelOpaque" type="boolean" line="2000">
                <params>
                    <param name="c" type="Component"/>
                </params>
                <declaration name="w" type="Window" line="2001"/>
            </method>
            <javadoc line="2005">
                Returns whether or not a containing top level window for the passed
                  component is{@link GraphicsDevice.WindowTranslucency#TRANSLUCENT TRANSLUCENT}.                
                <param>
                    c a Component which toplevel's to check                    
                </param>
                <return>
                    {@code true} if the passed component is not null and has a
                      containing toplevel window which has opacity less than
                      1.0f (which means that it is translucent), {@code false} otherwise                    
                </return>
                <see>
                    GraphicsDevice.WindowTranslucency#TRANSLUCENT                    
                </see>
            </javadoc>
            <method name="isContainingTopLevelTranslucent" type="boolean" line="2016">
                <params>
                    <param name="c" type="Component"/>
                </params>
                <declaration name="w" type="Window" line="2017"/>
            </method>
            <javadoc line="2021">
                Returns whether the native system requires using the peer.updateWindow()
                  method to update the contents of a non-opaque window, or if usual
                  painting procedures are sufficient. The default return value covers
                  the X11 systems. On MS Windows this method is overriden in WToolkit
                  to return true.                
            </javadoc>
            <method name="needUpdateWindow" type="boolean" line="2028"/>
            <javadoc line="2032">
                Descendants of the SunToolkit should override and put their own logic here.                
            </javadoc>
            <method name="getNumberOfButtons" type="int" line="2035"/>
            <javadoc line="2039">
                Checks that the given object implements/extends the given
                  interface/class.
                  Note that using the instanceof operator causes a class to be loaded.
                  Using this method doesn&apos;t load a class and it can be used instead of
                  the instanceof operator for performance reasons.                
                <param>
                    obj Object to be checked                    
                </param>
                <param>
                    type The name of the interface/class. Must be
                      fully-qualified interface/class name.                    
                </param>
                <return>
                    true, if this object implements/extends the given
                      interface/class, false, otherwise, or if obj or type is null                    
                </return>
            </javadoc>
            <method name="isInstanceOf" type="boolean" line="2053">
                <params>
                    <param name="obj" type="Object"/>
                    <param name="type" type="String"/>
                </params>
            </method>
            <method name="isInstanceOf" type="boolean" line="2060">
                <params>
                    <param name="cls" type="Class"/>
                    <param name="type" type="String"/>
                </params>
                <scope line="2063"/>
                <scope line="2067">
                    <scope line="2068"/>
                </scope>
            </method>
            <method name="setSystemGenerated" type="void" line="2085">
                <params>
                    <param name="e" type="AWTEvent"/>
                </params>
            </method>
            <method name="isSystemGenerated" type="boolean" line="2089">
                <params>
                    <param name="e" type="AWTEvent"/>
                </params>
            </method>
        </class>
        <class name="PostEventQueue" line="2105">
            <comment line="67">
                                
            </comment>
            <comment line="82">
                The key to put()get() the PostEventQueue intofrom the AppContext.                
            </comment>
            <comment line="94">
                XFree standard mention 24 buttons as maximum:
                 http:www.xfree86.orgcurrentmouse.4.html
                 We workaround systems supporting more than 24 buttons.
                 Otherwise, we have to use long type values as masks
                 which leads to API change.
                 InputEvent.BUTTON_DOWN_MASK may contain only 21 masks due to
                 the 4-bytes limit for the int type. (CR 6799099)
                 One more bit is reserved for FIRST_HIGH_BIT.                
            </comment>
            <comment line="280">
                Create a new AppContext, along with its EventQueue, for a
                 new ThreadGroup.  Browser code, for example, would use this
                 method to create an AppContext &amp; EventQueue for an Applet.                
            </comment>
            <comment line="357">
                Fetch the peer associated with the given target (as specified
                 in the peer creation method).  This can be used to determine
                 things like what the parent peer is.  If the target is null
                 or the target can&apos;t be found (either because the a peer was
                 never created for it or the peer was disposed), a null will
                 be returned.                
            </comment>
            <comment line="388">
                Maps from non-Component/MenuComponent to AppContext.
                 WeakHashMap&lt;Component,AppContext&gt;                
            </comment>
            <comment line="427">
                Fetch the AppContext associated with the given target.
                 This can be used to determine things like which EventQueue
                 to use for posting events to a Component.  If the target is
                 null or the target can&apos;t be found, a null with be returned.                
            </comment>
            <comment line="540">
                Insert a mapping from target to AppContext, for later retrieval
                 via targetToAppContext() above.                
            </comment>
            <comment line="554">
                Post an AWTEvent to the Java EventQueue, using the PostEventQueue
                 to avoid possibly calling client code (EventQueueSubclass.postEvent())
                 on the toolkit (AWT-WindowsAWT-Motif) thread.  This function should
                 not be called under another lock since it locks the EventQueue.
                 See bugids 4632918, 4526597.                
            </comment>
            <comment line="582">
                Post AWTEvent of high priority.                
            </comment>
            <comment line="598">
                Flush any pending events which haven&apos;t been posted to the AWT
                 EventQueue yet.                
            </comment>
            <comment line="632">
                Execute a chunk of code on the Java event handler thread for the
                 given target.  Does not wait for the execution to occur before
                 returning to the caller.                
            </comment>
            <comment line="642">
                Fixed 5064013: the InvocationEvent time should be equals
                 the time of the ActionEvent                
            </comment>
            <comment line="656">
                Execute a chunk of code on the Java event handler thread for the
                 given target.  Does not wait for the execution to occur before
                 returning to the caller.                
            </comment>
            <comment line="665">
                Execute a chunk of code on the Java event handler thread. The
                 method takes into account provided AppContext and sets
                 &lt;code&gt;SunToolkit.getDefaultToolkit()&lt;code&gt; as a target of the
                 event. See 6451487 for detailes.
                 Does not wait for the execution to occur before returning to
                 the caller.                
            </comment>
            <comment line="681">
                Execute a chunk of code on the Java event handler thread for the
                 given target.  Waits for the execution to occur before returning
                 to the caller.                
            </comment>
            <comment line="711">
                Returns true if the calling thread is the event dispatch thread
                 contained within AppContext which associated with the given target.
                 Use this call to ensure that a given task is being executed
                 (or not being) on the event dispatch thread for the given target.                
            </comment>
            <comment line="1099">
                Package private implementation                
            </comment>
            <comment line="1206">
                Support for window closing event notifications                
            </comment>
            <comment line="1312">
                Default implementation for isModalExcludedSupportedImpl(), returns false.
                
                 @see sun.awt.windows.WToolkit#isModalExcludeSupportedImpl
                 @see sun.awt.X11.XToolkit#isModalExcludeSupportedImpl
                
                 @since 1.5                
            </comment>
            <comment line="1325">
                Sets this window to be excluded from being modally blocked. When the
                 toolkit supports modal exclusion and this method is called, input
                 events, focus transfer and z-order will continue to work for the
                 window, it&apos;s owned windows and child components, even in the
                 presence of a modal dialog.
                 For details on which &lt;code&gt;Window&lt;code&gt;s are normally blocked
                 by modal dialog, see {@link java.awt.Dialog}.
                 Invoking this method when the modal exclusion API is not supported by
                 the current toolkit has no effect.
                 @param window Window to be marked as not modally blocked
                 @see java.awt.Dialog
                 @see java.awt.Dialog#setModal(boolean)
                 @see sun.awt.SunToolkit#isModalExcludedSupported
                 @see sun.awt.SunToolkit#isModalExcluded(java.awt.Window)                
            </comment>
            <comment line="1349">
                Returns whether the specified window is blocked by modal dialogs.
                 If the modal exclusion API isn&apos;t supported by the current toolkit,
                 it returns false for all windows.
                
                 @param window Window to test for modal exclusion
                
                 @return true if the window is modal excluded, false otherwise. If
                 the modal exclusion isn&apos;t supported by the current Toolkit, false
                 is returned
                
                 @see sun.awt.SunToolkit#isModalExcludedSupported
                 @see sun.awt.SunToolkit#setModalExcluded(java.awt.Window)
                
                 @since 1.5                
            </comment>
            <comment line="1388">
                /////////////////////////////////////////////////////////////////////////
                
                 The following is used by the Java Plug-in to coordinate dialog modality
                 between containing applications (browsers, ActiveX containers etc) and
                 the AWT.
                
                /                
            </comment>
            <comment line="1444">
                end of class ModalityListenerList                
            </comment>
            <comment line="1446">
                /////////////////////////////////////////////////////////////////////////
                 End Plug-in code
                /                
            </comment>
            <comment line="1734">
                The following methods and variables are to support retrieving
                 desktop text anti-aliasing settings                
            </comment>
            <comment line="1738">
                                
            </comment>
            <comment line="1749">
                Since Swing is the reason for this &quot;extra condition&quot; logic its
                 worth documenting it in some detail.
                 First, a goal is for Swing and applications to both retrieve and
                 use the same desktop property value so that there is complete
                 consistency between the settings used by JDK&apos;s Swing implementation
                 and 3rd party custom Swing components, custom L&amp;Fs and any general
                 text rendering that wants to be consistent with these.
                 But by default on Solaris &amp; Linux Swing will not use AA text over
                 remote X11 display (unless Xrender can be used which is TBD and may not
                 always be available anyway) as that is a noticeable performance hit.
                 So there needs to be a way to express that extra condition so that
                 it is seen by all clients of the desktop property API.
                 If this were the only condition it could be handled here as it would
                 be the same for any L&amp;F and could reasonably be considered to be
                 a static behaviour of those systems.
                 But GTK currently has an additional test based on locale which is
                 not applied by Metal. So mixing GTK in a few locales with Metal
                 would mean the last one wins.
                 This could be stored per-app context which would work
                 for different applets, but wouldn&apos;t help for a single application
                 using GTK and some other L&amp;F concurrently.
                 But it is expected this will be addressed within GTK and the font
                 system so is a temporary and somewhat unlikely harmless corner case.                
            </comment>
            <comment line="1791">
                &quot;false&quot;, &quot;off&quot;, &quot;&quot;default&quot; aren&apos;t explicitly tested, they
                 just fall through to produce a null return which all are equated to
                 &quot;false&quot;.                
            </comment>
            <comment line="1820">
                This method determines whether to use the system font settings,
                 or ignore them if a L&amp;F has specified they should be ignored, or
                 to override both of these with a system property specified value.
                 If the toolkit isn&apos;t a SunToolkit, (eg may be headless) then that
                 system property isn&apos;t applied as desktop properties are considered
                 to be inapplicable in that case. In that headless case although
                 this method will return &quot;true&quot; the toolkit will return a null map.                
            </comment>
            <comment line="1857">
                                
            </comment>
            <comment line="1860">
                                
            </comment>
            <comment line="1865">
                Subclass desktop property loading methods call this which
                 in turn calls the appropriate subclass implementation of
                 getDesktopAAHints() when system settings are being used.
                 Its public rather than protected because subclasses may delegate
                 to a helper class.                
            </comment>
            <comment line="1893">
                consumeNextKeyTyped() method is not currently used,
                 however Swing could use it in the future.                
            </comment>
            <comment line="1971">
                Cosntant alpha                
            </comment>
            <comment line="1976">
                Shaping                
            </comment>
            <comment line="1981">
                Per-pixel alpha                
            </comment>
            <comment line="2076">
                /////////////////////////////////////////////////////////////////////////
                
                 The following methods help set and identify whether a particular
                 AWTEvent object was produced by the system or by user code. As of this
                 writing the only consumer is the Java Plug-In, although this information
                 could be useful to more clients and probably should be formalized in
                 the public API.
                
                /                
            </comment>
            <comment line="2119">
                Continually post pending AWTEvents to the Java EventQueue. The method
                 is synchronized to ensure the flush is completed before a new event
                 can be posted to this queue.                
            </comment>
            <comment line="2133">
                Enqueue an AWTEvent to be posted to the Java EventQueue.                
            </comment>
            <declaration name="queueHead" type="EventQueueItem" line="2106"/>
            <declaration name="queueTail" type="EventQueueItem" line="2107"/>
            <declaration name="eventQueue" type="EventQueue" line="2108"/>
            <method name="PostEventQueue" type="constructor" line="2110">
                <params>
                    <param name="eq" type="EventQueue"/>
                </params>
            </method>
            <method name="noEvents" type="boolean" line="2114"/>
            <method name="flush" type="void" line="2123">
                <declaration name="tempQueue" type="EventQueueItem" line="2124"/>
                <scope line="2126"/>
            </method>
            <method name="postEvent" type="void" line="2135">
                <params>
                    <param name="event" type="AWTEvent"/>
                </params>
                <declaration name="item" type="EventQueueItem" line="2136"/>
                <scope line="2138">
                    <scope line="2139"/>
                    <scope line="2141"/>
                </scope>
            </method>
        </class>
    </source>