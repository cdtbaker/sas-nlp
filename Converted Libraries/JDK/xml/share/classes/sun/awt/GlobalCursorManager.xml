<?xml version="1.0" encoding="UTF-8"?>
    <source package="sun.awt">
        <import package="java.awt"/>
        <import package="java.awt.event.InputEvent"/>
        <import package="java.awt.event.InvocationEvent"/>
        <class name="GlobalCursorManager" line="32">
            <javadoc line="32">
                A stateless class which responds to native mouse moves, Component resizes,
                  Component moves, showing and hiding of Components, minimizing and
                  maximizing of top level Windows, addition and removal of Components,
                  and calls to setCursor().                
            </javadoc>
            <class name="NativeUpdater" line="40">
                <implements interface="Runnable"/>
                <declaration name="pending" type="boolean" line="41"/>
                <method name="run" type="void" line="43">
                    <declaration name="shouldUpdate" type="boolean" line="44"/>
                    <scope line="45">
                        <scope line="46"/>
                    </scope>
                    <scope line="51"/>
                </method>
                <method name="postIfNotPending" type="void" line="56">
                    <params>
                        <param name="heavy" type="Component"/>
                        <param name="in" type="InvocationEvent"/>
                    </params>
                    <declaration name="shouldPost" type="boolean" line="57"/>
                    <scope line="58">
                        <scope line="59"/>
                    </scope>
                    <scope line="63"/>
                </method>
            </class>
            <declaration name="nativeUpdater" type="NativeUpdater" line="69"/>
            <javadoc line="69">
                Use a singleton NativeUpdater for better performance. We cannot use
                  a singleton InvocationEvent because we want each event to have a fresh
                  timestamp.                
            </javadoc>
            <declaration name="lastUpdateMillis" type="long" line="76"/>
            <javadoc line="76">
                The last time the cursor was updated, in milliseconds.                
            </javadoc>
            <declaration name="lastUpdateLock" type="Object" line="81"/>
            <javadoc line="81">
                Locking object for synchronizing access to lastUpdateMillis. The VM
                  does not guarantee atomicity of longs.                
            </javadoc>
            <javadoc line="87">
                Should be called for any activity at the Java level which may affect
                  the global cursor, except for Java MOUSE_MOVED events.                
            </javadoc>
            <method name="updateCursorImmediately" type="void" line="91">
                <scope line="92"/>
            </method>
            <javadoc line="98">
                Should be called in response to Java MOUSE_MOVED events. The update
                  will be discarded if the InputEvent is outdated.                
                <param>
                    e the InputEvent which triggered the cursor update.                    
                </param>
            </javadoc>
            <method name="updateCursorImmediately" type="void" line="104">
                <params>
                    <param name="e" type="InputEvent"/>
                </params>
                <declaration name="shouldUpdate" type="boolean" line="105"/>
                <scope line="106"/>
                <scope line="109"/>
            </method>
            <javadoc line="114">
                Should be called in response to a native mouse enter or native mouse
                  button released message. Should not be called during a mouse drag.                
            </javadoc>
            <method name="updateCursorLater" type="void" line="118">
                <params>
                    <param name="heavy" type="Component"/>
                </params>
            </method>
            <method name="GlobalCursorManager" type="constructor" line="123"/>
            <method name="setCursor" type="void" line="125"/>
            <javadoc line="125">
                Set the global cursor to the specified cursor. The component over
                  which the Cursor current resides is provided as a convenience. Not
                  all platforms may require the Component.                
            </javadoc>
            <method name="getCursorPos" type="void" line="132"/>
            <javadoc line="132">
                Returns the global cursor position, in screen coordinates.                
            </javadoc>
            <method name="findComponentAt" type="Component" line="137"/>
            <method name="getLocationOnScreen" type="Point" line="138"/>
            <method name="findHeavyweightUnderCursor" type="Component" line="140"/>
            <javadoc line="140">
                Returns the most specific, visible, heavyweight Component
                  under the cursor. This method should return null iff the cursor is
                  not over any Java Window.                
                <param>
                    useCache If true, the implementation is free to use caching
                      mechanisms because the Z-order, visibility, and enabled state of the
                      Components has not changed. If false, the implementation should not
                      make these assumptions.                    
                </param>
            </javadoc>
            <javadoc line="152">
                Updates the global cursor. We apply a three-step scheme to cursor
                  updates:&lt;p&gt;
                  (1) InputEvent updates which are outdated are discarded by
                  &lt;code&gt;updateCursorImmediately(InputEvent)&lt;/code&gt;.&lt;p&gt;
                  (2) If &apos;useCache&apos; is true, the native code is free to use a cached
                  value to determine the most specific, visible, enabled heavyweight
                  because this update is occuring in response to a mouse move. If
                  &apos;useCache&apos; is false, the native code must perform a new search given
                  the current mouse coordinates.
                  (3) Once we have determined the most specific, visible, enabled
                  heavyweight, we use findComponentAt to find the most specific, visible,
                  enabled Component.                
            </javadoc>
            <method name="_updateCursor" type="void" line="169">
                <params>
                    <param name="useCache" type="boolean"/>
                </params>
                <comment line="196">
                    If findComponentAt returns null, then something bad has                    
                </comment>
                <comment line="197">
                    happened. For example, the heavyweight Component may                    
                </comment>
                <comment line="198">
                    have been hidden or disabled by another thread. In that                    
                </comment>
                <comment line="199">
                    case, we&apos;ll just use the originial heavyweight.                    
                </comment>
                <comment line="208">
                    Shouldn&apos;t happen, but if it does, abort.                    
                </comment>
                <scope line="171"/>
                <declaration name="queryPos" type="Point" line="175"/>
                <declaration name="comp" type="Component" line="176"/>
                <scope line="178">
                    <scope line="180"/>
                    <scope line="185"/>
                    <scope line="187"/>
                    <scope line="190">
                        <declaration name="c" type="Component" line="193"/>
                        <scope line="200"/>
                    </scope>
                </scope>
                <scope line="207"/>
            </method>
            <method name="updateCursorOutOfJava" type="void" line="212">
                <comment line="213">
                    Cursor is not over a Java Window. Do nothing...usually                    
                </comment>
                <comment line="214">
                    But we need to update it in case of grab on X.                    
                </comment>
            </method>
        </class>
    </source>