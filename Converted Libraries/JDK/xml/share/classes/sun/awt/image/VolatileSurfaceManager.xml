<?xml version="1.0" encoding="UTF-8"?>
    <source package="sun.awt.image">
        <import package="java.awt.Color"/>
        <import package="java.awt.Graphics"/>
        <import package="java.awt.GraphicsConfiguration"/>
        <import package="java.awt.GraphicsEnvironment"/>
        <import package="java.awt.ImageCapabilities"/>
        <import package="java.awt.image.BufferedImage"/>
        <import package="java.awt.image.VolatileImage"/>
        <import package="sun.awt.DisplayChangedListener"/>
        <import package="sun.awt.image.SunVolatileImage"/>
        <import package="sun.java2d.SunGraphicsEnvironment"/>
        <import package="sun.java2d.SurfaceData"/>
        <import package="sun.java2d.loops.CompositeType"/>
        <import package="sun.java2d.pipe.hw.AccelSurface"/>
        <class name="VolatileSurfaceManager" line="42">
            <extends class="SurfaceManager"/>
            <implements interface="DisplayChangedListener"/>
            <javadoc line="42">
                This SurfaceManager variant manages an accelerated volatile surface, if it
                  is possible to create that surface.  If there is limited accelerated
                  memory, or if the volatile surface disappears due to an operating system
                  event, the VolatileSurfaceManager will attempt to restore the
                  accelerated surface.  If that fails, a system memory surface will be
                  created in its place.                
            </javadoc>
            <declaration name="vImg" type="SunVolatileImage" line="54"/>
            <javadoc line="54">
                A reference to the VolatileImage whose contents are being managed.                
            </javadoc>
            <declaration name="sdAccel" type="SurfaceData" line="59"/>
            <javadoc line="59">
                The accelerated SurfaceData object.                
            </javadoc>
            <declaration name="sdBackup" type="SurfaceData" line="64"/>
            <javadoc line="64">
                The software-based SurfaceData object.  Only create when first asked
                  to (otherwise it is a waste of memory as it will only be used in
                  situations of surface loss).                
            </javadoc>
            <declaration name="sdCurrent" type="SurfaceData" line="71"/>
            <javadoc line="71">
                The current SurfaceData object.                
            </javadoc>
            <declaration name="sdPrevious" type="SurfaceData" line="76"/>
            <javadoc line="76">
                A record-keeping object.  This keeps track of which SurfaceData was
                  in use during the last call to validate().  This lets us see whether
                  the SurfaceData object has changed since then and allows us to return
                  the correct returnCode to the user in the validate() call.                
            </javadoc>
            <declaration name="lostSurface" type="boolean" line="84"/>
            <javadoc line="84">
                Tracks loss of surface contents; queriable by user to see whether
                  contents need to be restored.                
            </javadoc>
            <declaration name="context" type="Object" line="90"/>
            <javadoc line="90">
                Context for extra initialization parameters.                
            </javadoc>
            <method name="VolatileSurfaceManager" type="constructor" line="95">
                <params>
                    <param name="vImg" type="SunVolatileImage"/>
                    <param name="context" type="Object"/>
                </params>
                <comment line="102">
                    We could have a HeadlessGE at this point, so double-check before
                     assuming anything.                    
                </comment>
                <declaration name="ge" type="GraphicsEnvironment" line="99"/>
                <scope line="103"/>
            </method>
            <javadoc line="108">
                This init function is separate from the constructor because the
                  things we are doing here necessitate the object&apos;s existence.
                  Otherwise, we end up calling into a subclass&apos; overridden method
                  during construction, before that subclass is completely constructed.                
            </javadoc>
            <method name="initialize" type="void" line="114">
                <comment line="122">
                    only initialize the backup surface for images with unforced
                     acceleration type                    
                </comment>
                <scope line="115">
                    <scope line="117"/>
                </scope>
                <scope line="125"/>
            </method>
            <method name="getPrimarySurfaceData" type="SurfaceData" line="130"/>
            <method name="isAccelerationEnabled" type="boolean" line="134"/>
            <javadoc line="134">
                Returns true if acceleration is enabled.  If not, we simply use the
                  backup SurfaceData object and return quickly from most methods
                  in this class.                
            </javadoc>
            <javadoc line="141">
                Get the image ready for rendering.  This method is called to make
                  sure that the accelerated SurfaceData exists and is
                  ready to be used.  Users call this method prior to any set of
                  rendering to or from the image, to make sure the image is ready
                  and compatible with the given GraphicsConfiguration.
                  The image may not be &quot;ready&quot; if either we had problems creating
                  it in the first place (e.g., there was no space in vram) or if
                  the surface became lost (e.g., some other app or the OS caused
                  vram surfaces to be removed).
                  Note that we want to return RESTORED in any situation where the
                  SurfaceData is different than it was last time.  So whether it&apos;s
                  software or hardware, if we have a different SurfaceData object,
                  then the contents have been altered and we must reflect that
                  change to the user.                
            </javadoc>
            <method name="validate" type="int" line="159">
                <params>
                    <param name="gc" type="GraphicsConfiguration"/>
                </params>
                <comment line="167">
                    If we&apos;re asked to render to a different device than the
                     one we were created under, return INCOMPATIBLE error code.
                     Note that a null gc simply ignores the incompatibility
                     issue                    
                </comment>
                <comment line="173">
                    We either had problems creating the surface or the display
                     mode changed and we nullified the old one.  Try it again.                    
                </comment>
                <comment line="177">
                    set the current SurfaceData to accelerated version                    
                </comment>
                <comment line="179">
                    we don&apos;t need the system memory surface anymore, so
                     let&apos;s release it now (it can always be restored later)                    
                </comment>
                <comment line="189">
                    set the current SurfaceData to accelerated version                    
                </comment>
                <comment line="191">
                    restoration successful: accel surface no longer lost                    
                </comment>
                <comment line="193">
                    we don&apos;t need the system memory surface anymore, so
                     let&apos;s release it now (it can always be restored later)                    
                </comment>
                <comment line="198">
                    Set the current SurfaceData to software version so that
                     drawing can continue.  Note that we still have
                     the lostAccelSurface flag set so that we will continue
                     to attempt to restore the accelerated surface.                    
                </comment>
                <comment line="205">
                    Something else triggered this loss/restoration.  Could
                     be a palette change that didn&apos;t require a SurfaceData
                     recreation but merely a re-rendering of the pixels.                    
                </comment>
                <comment line="211">
                    if the &quot;acceleration enabled&quot; state changed to disabled,
                     switch to software surface                    
                </comment>
                <comment line="221">
                    contents have changed - return RESTORED to user                    
                </comment>
                <comment line="227">
                    clear the current surface with the background color,
                     only if the surface has been restored                    
                </comment>
                <declaration name="returnCode" type="int" line="160"/>
                <declaration name="lostSurfaceTmp" type="boolean" line="161"/>
                <scope line="164">
                    <scope line="165"/>
                    <scope line="171">
                        <scope line="175"/>
                        <scope line="182"/>
                    </scope>
                    <scope line="185">
                        <scope line="186"/>
                        <scope line="196"/>
                    </scope>
                    <scope line="203"/>
                </scope>
                <scope line="209"/>
                <scope line="219"/>
                <scope line="225"/>
            </method>
            <javadoc line="234">
                Returns true if rendering data was lost since the last validate call.                
                <see>
                    java.awt.image.VolatileImage#contentsLost                    
                </see>
            </javadoc>
            <method name="contentsLost" type="boolean" line="239"/>
            <method name="initAcceleratedSurface" type="SurfaceData" line="243"/>
            <javadoc line="243">
                Creates a new accelerated surface that is compatible with the
                  current GraphicsConfiguration.  Returns the new accelerated
                  SurfaceData object, or null if the surface creation was not successful.
                  Platform-specific subclasses should initialize an accelerated
                  surface (e.g. a DirectDraw surface on Windows, an OpenGL pbuffer,
                  or an X11 pixmap).                
            </javadoc>
            <javadoc line="254">
                Creates a software-based surface (of type BufImgSurfaceData).
                  The software representation is only created when needed, which
                  is only during some situation in which the hardware surface
                  cannot be allocated.  This allows apps to at least run,
                  albeit more slowly than they would otherwise.                
            </javadoc>
            <method name="getBackupSurface" type="SurfaceData" line="261">
                <comment line="265">
                    Sabotage the acceleration capabilities of the BufImg surface                    
                </comment>
                <scope line="262">
                    <declaration name="bImg" type="BufferedImage" line="263"/>
                </scope>
            </method>
            <javadoc line="273">
                Set contents of the current SurfaceData to default state (i.e. clear
                  the background).                
            </javadoc>
            <method name="initContents" type="void" line="277">
                <comment line="279">
                    images with forced acceleration type may have a null sdCurrent
                     because we do not create a backup surface for them                    
                </comment>
                <scope line="280">
                    <declaration name="g" type="Graphics" line="281"/>
                </scope>
            </method>
            <javadoc line="287">
                Called from a SurfaceData object, indicating that our
                  accelerated surface has been lost and should be restored (perhaps
                  using a backup system memory surface).  Returns the newly restored
                  primary SurfaceData object.                
            </javadoc>
            <method name="restoreContents" type="SurfaceData" line="293"/>
            <javadoc line="297">
                If the accelerated surface is the current SurfaceData for this manager,
                  sets the variable lostSurface to true, which indicates that something
                  happened to the image under management.  This variable is used in the
                  validate method to tell the caller that the surface contents need to
                  be restored.                
            </javadoc>
            <method name="acceleratedSurfaceLost" type="void" line="304">
                <scope line="305"/>
            </method>
            <javadoc line="310">
                Restore sdAccel in case it was lost.  Do nothing in this
                  default case; platform-specific implementations may do more in
                  this situation as appropriate.                
            </javadoc>
            <method name="restoreAcceleratedSurface" type="void" line="315"/>
            <javadoc line="318">
                Called from SunGraphicsEnv when there has been a display mode change.
                  Note that we simply invalidate hardware surfaces here; we do not
                  attempt to recreate or re-render them.  This is to avoid threading
                  conflicts with the native toolkit and associated threads.  Instead,
                  we just nullify the old surface data object and wait for a future
                  method in the rendering process to recreate the surface.                
            </javadoc>
            <method name="displayChanged" type="void" line="326">
                <comment line="333">
                    First, nullify the software surface.  This guards against
                     using a SurfaceData that was created in a different
                     display mode.                    
                </comment>
                <comment line="338">
                    Now, invalidate the old hardware-based SurfaceData                    
                </comment>
                <comment line="343">
                    Update graphicsConfig for the vImg in case it changed due to
                     this display change event                    
                </comment>
                <scope line="327"/>
                <scope line="331">
                    <declaration name="oldData" type="SurfaceData" line="338"/>
                </scope>
            </method>
            <javadoc line="347">
                When device palette changes, need to force a new copy
                  of the image into our hardware cache to update the
                  color indices of the pixels (indexed mode only).                
            </javadoc>
            <method name="paletteChanged" type="void" line="352"/>
            <javadoc line="356">
                Called by validate() to see whether the GC passed in is ok for
                  rendering to.  This generic implementation checks to see
                  whether the GC is either null or is from the same
                  device as the one that this image was created on.  Platform-
                  specific implementations may perform other checks as
                  appropriate.                
            </javadoc>
            <method name="isConfigValid" type="boolean" line="364">
                <params>
                    <param name="gc" type="GraphicsConfiguration"/>
                </params>
            </method>
            <method name="getCapabilities" type="ImageCapabilities" line="370">
                <params>
                    <param name="gc" type="GraphicsConfiguration"/>
                </params>
                <scope line="371"/>
            </method>
            <class name="AcceleratedImageCapabilities" line="379">
                <extends class="ImageCapabilities"/>
                <method name="AcceleratedImageCapabilities" type="constructor" line="382"/>
                <method name="isAccelerated" type="boolean" line="386"/>
                <method name="isTrueVolatile" type="boolean" line="390"/>
            </class>
            <javadoc line="395">
                Releases any associated hardware memory for this image by
                  calling flush on sdAccel.  This method forces a lostSurface
                  situation so any future operations on the image will need to
                  revalidate the image first.                
            </javadoc>
            <method name="flush" type="void" line="401">
                <declaration name="oldSD" type="SurfaceData" line="403"/>
                <scope line="405"/>
            </method>
        </class>
    </source>