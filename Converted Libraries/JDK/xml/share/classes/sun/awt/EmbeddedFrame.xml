<?xml version="1.0" encoding="UTF-8"?>
    <source package="sun.awt">
        <import package="java.awt"/>
        <import package="java.awt.event"/>
        <import package="java.awt.image"/>
        <import package="java.awt.peer"/>
        <import package="java.security.AccessController"/>
        <import package="java.security.PrivilegedAction"/>
        <import package="java.lang.reflect.Constructor"/>
        <import package="java.lang.reflect.InvocationTargetException"/>
        <import package="java.lang.reflect.Modifier"/>
        <import package="java.lang.reflect.Field"/>
        <import package="java.beans.PropertyChangeListener"/>
        <import package="java.beans.PropertyChangeEvent"/>
        <import package="java.util.Set"/>
        <import package="java.awt.AWTKeyStroke"/>
        <import package="java.applet.Applet"/>
        <import package="sun.applet.AppletPanel"/>
        <class name="EmbeddedFrame" line="45">
            <extends class="Frame"/>
            <comment line="71">
                JDK 1.1 compatibility                
            </comment>
            <comment line="74">
                The constants define focus traversal directions.
                 Use them in {@code traverseIn}, {@code traverseOut} methods.                
            </comment>
            <comment line="370">
                These three functions consitute RFE 4100710. Do not remove.                
            </comment>
            <comment line="410">
                setPeer method ends                
            </comment>
            <implements interface="KeyEventDispatcher"/>
            <implements interface="PropertyChangeListener"/>
            <javadoc line="45">
                A generic container used for embedding Java components, usually applets.
                  An EmbeddedFrame has two related uses:
                  . Within a Java-based application, an EmbeddedFrame serves as a sort of
                  firewall, preventing the contained components or applets from using
                  getParent() to find parent components, such as menubars.
                  . Within a C-based application, an EmbeddedFrame contains a window handle
                  which was created by the application, which serves as the top-level
                  Java window.  EmbeddedFrames created for this purpose are passed-in a
                  handle of an existing window created by the application.  The window
                  handle should be of the appropriate native type for a specific
                  platform, as stored in the pData field of the ComponentPeer.                
                <author>
                    Thomas Ball                    
                </author>
            </javadoc>
            <declaration name="isCursorAllowed" type="boolean" line="65"/>
            <declaration name="fieldPeer" type="Field" line="66"/>
            <declaration name="currentCycleRoot" type="Field" line="67"/>
            <declaration name="supportsXEmbed" type="boolean" line="68"/>
            <declaration name="appletKFM" type="KeyboardFocusManager" line="69"/>
            <declaration name="serialVersionUID" type="long" line="71"/>
            <declaration name="FORWARD" type="boolean" line="77"/>
            <declaration name="BACKWARD" type="boolean" line="78"/>
            <method name="supportsXEmbed" type="boolean" line="80"/>
            <method name="EmbeddedFrame" type="constructor" line="84">
                <params>
                    <param name="supportsXEmbed" type="boolean"/>
                </params>
            </method>
            <method name="EmbeddedFrame" type="constructor" line="89"/>
            <javadoc line="93">
                @deprecated This constructor will be removed in 1.5                
            </javadoc>
            <method name="EmbeddedFrame" type="constructor" line="97">
                <params>
                    <param name="handle" type="int"/>
                </params>
            </method>
            <method name="EmbeddedFrame" type="constructor" line="101">
                <params>
                    <param name="handle" type="long"/>
                </params>
            </method>
            <method name="EmbeddedFrame" type="constructor" line="105">
                <params>
                    <param name="handle" type="long"/>
                    <param name="supportsXEmbed" type="boolean"/>
                </params>
            </method>
            <javadoc line="110">
                Block introspection of a parent window by this child.                
            </javadoc>
            <method name="getParent" type="Container" line="113"/>
            <javadoc line="117">
                Needed to track which KeyboardFocusManager is current. We want to avoid memory
                  leaks, so when KFM stops being current, we remove ourselves as listeners.                
            </javadoc>
            <method name="propertyChange" type="void" line="121">
                <params>
                    <param name="evt" type="PropertyChangeEvent"/>
                </params>
                <comment line="123">
                    We don&apos;t handle any other properties. Skip it.                    
                </comment>
                <comment line="128">
                    We only do it if it stops being current. Technically, we should
                     never get an event about KFM starting being current.                    
                </comment>
                <comment line="134">
                    should be the same as appletKFM                    
                </comment>
                <scope line="123"/>
                <scope line="129"/>
                <scope line="137"/>
            </method>
            <javadoc line="142">
                Register us as KeyEventDispatcher and property &quot;managingFocus&quot; listeners.                
            </javadoc>
            <method name="addTraversingOutListeners" type="void" line="145">
                <params>
                    <param name="kfm" type="KeyboardFocusManager"/>
                </params>
            </method>
            <javadoc line="150">
                Deregister us as KeyEventDispatcher and property &quot;managingFocus&quot; listeners.                
            </javadoc>
            <method name="removeTraversingOutListeners" type="void" line="153">
                <params>
                    <param name="kfm" type="KeyboardFocusManager"/>
                </params>
            </method>
            <javadoc line="158">
                Because there may be many AppContexts, and we can&apos;t be sure where this
                  EmbeddedFrame is first created or shown, we can&apos;t automatically determine
                  the correct KeyboardFocusManager to attach to as KeyEventDispatcher.
                  Those who want to use the functionality of traversing out of the EmbeddedFrame
                  must call this method on the Applet&apos;s AppContext. After that, all the changes
                  can be handled automatically, including possible replacement of
                  KeyboardFocusManager.                
            </javadoc>
            <method name="registerListeners" type="void" line="167">
                <scope line="168"/>
                <scope line="172"/>
            </method>
            <javadoc line="177">
                Needed to avoid memory leak: we register this EmbeddedFrame as a listener with
                  KeyboardFocusManager of applet&apos;s AppContext. We don&apos;t want the KFM to keep
                  reference to our EmbeddedFrame forever if the Frame is no longer in use, so we
                  add listeners in show() and remove them in hide().                
            </javadoc>
            <method name="show" type="void" line="183">
                <scope line="184"/>
            </method>
            <javadoc line="190">
                Needed to avoid memory leak: we register this EmbeddedFrame as a listener with
                  KeyboardFocusManager of applet&apos;s AppContext. We don&apos;t want the KFM to keep
                  reference to our EmbeddedFrame forever if the Frame is no longer in use, so we
                  add listeners in show() and remove them in hide().                
            </javadoc>
            <method name="hide" type="void" line="196">
                <scope line="197"/>
            </method>
            <javadoc line="203">
                Need this method to detect when the focus may have chance to leave the
                  focus cycle root which is EmbeddedFrame. Mostly, the code here is copied
                  from DefaultKeyboardFocusManager.processKeyEvent with some minor
                  modifications.                
            </javadoc>
            <method name="dispatchKeyEvent" type="boolean" line="209">
                <params>
                    <param name="e" type="KeyEvent"/>
                </params>
                <comment line="212">
                    We can&apos;t guarantee that this is called on the same AppContext as EmbeddedFrame
                     belongs to. That&apos;s why we can&apos;t use public methods to find current focus cycle
                     root. Instead, we access KFM&apos;s private field directly.                    
                </comment>
                <comment line="238">
                    The field is static, so we can pass null to Field.get() as the argument.                    
                </comment>
                <comment line="241">
                    This is impossible: currentCycleRoot would be null if setAccessible failed.                    
                </comment>
                <comment line="246">
                    if we are not in EmbeddedFrame&apos;s cycle, we should not try to leave.                    
                </comment>
                <comment line="251">
                    KEY_TYPED events cannot be focus traversal keys                    
                </comment>
                <comment line="266">
                    6581899: performance improvement for SortingFocusTraversalPolicy                    
                </comment>
                <comment line="278">
                    6581899: performance improvement for SortingFocusTraversalPolicy                    
                </comment>
                <scope line="214">
                    <anonymous_class line="215">
                        <method name="run" type="Object" line="216">
                            <scope line="217">
                                <declaration name="unaccessibleRoot" type="Field" line="218"/>
                                <scope line="220"/>
                            </scope>
                            <scope line="224"/>
                            <scope line="226"/>
                        </method>
                    </anonymous_class>
                </scope>
                <declaration name="currentRoot" type="Container" line="234"/>
                <scope line="235">
                    <scope line="236"/>
                    <scope line="239"/>
                </scope>
                <scope line="246"/>
                <scope line="251"/>
                <scope line="255"/>
                <declaration name="stroke" type="AWTKeyStroke" line="259"/>
                <declaration name="toTest" type="Set" line="260"/>
                <declaration name="currentFocused" type="Component" line="261"/>
                <scope line="264">
                    <declaration name="last" type="Component" line="266"/>
                    <scope line="267">
                        <scope line="268"/>
                    </scope>
                </scope>
                <scope line="276">
                    <declaration name="first" type="Component" line="278"/>
                    <scope line="279">
                        <scope line="280"/>
                    </scope>
                </scope>
            </method>
            <javadoc line="289">
                This method is called by the embedder when we should receive focus as element
                  of the traversal chain.  The method requests focus on:
                  1. the first Component of this EmbeddedFrame if user moves focus forward
                  in the focus traversal cycle.
                  2. the last Component of this EmbeddedFrame if user moves focus backward
                  in the focus traversal cycle.
                  The direction parameter specifies which of the two mentioned cases is
                  happening. Use FORWARD and BACKWARD constants defined in the EmbeddedFrame class
                  to avoid confusing boolean values.
                  A concrete implementation of this method is defined in the platform-dependent
                  subclasses.                
                <param>
                    direction FORWARD or BACKWARD                    
                </param>
                <return>
                    true, if the EmbeddedFrame wants to get focus, false otherwise.                    
                </return>
            </javadoc>
            <method name="traverseIn" type="boolean" line="307">
                <params>
                    <param name="direction" type="boolean"/>
                </params>
                <comment line="317">
                    comp.requestFocus(); - Leads to a hung.                    
                </comment>
                <declaration name="comp" type="Component" line="308"/>
                <scope line="310"/>
                <scope line="312"/>
                <scope line="315"/>
            </method>
            <javadoc line="324">
                This method is called from dispatchKeyEvent in the following two cases:
                  1. The focus is on the first Component of this EmbeddedFrame and we are
                  about to transfer the focus backward.
                  2. The focus in on the last Component of this EmbeddedFrame and we are
                  about to transfer the focus forward.
                  This is needed to give the opportuity for keyboard focus to leave the
                  EmbeddedFrame. Override this method, initiate focus transfer in it and
                  return true if you want the focus to leave EmbeddedFrame&apos;s cycle.
                  The direction parameter specifies which of the two mentioned cases is
                  happening. Use FORWARD and BACKWARD constants defined in EmbeddedFrame
                  to avoid confusing boolean values.                
                <param>
                    direction FORWARD or BACKWARD                    
                </param>
                <return>
                    true, if EmbeddedFrame wants the focus to leave it,
                      false otherwise.                    
                </return>
            </javadoc>
            <method name="traverseOut" type="boolean" line="341">
                <params>
                    <param name="direction" type="boolean"/>
                </params>
            </method>
            <javadoc line="345">
                Block modifying any frame attributes, since they aren&apos;t applicable
                  for EmbeddedFrames.                
            </javadoc>
            <method name="setTitle" type="void" line="349">
                <params>
                    <param name="title" type="String"/>
                </params>
            </method>
            <method name="setIconImage" type="void" line="350">
                <params>
                    <param name="image" type="Image"/>
                </params>
            </method>
            <method name="setIconImages" type="void" line="351">
                <params>
                    <param name="icons" type="java.util.List<? extends Image>"/>
                </params>
            </method>
            <method name="setMenuBar" type="void" line="352">
                <params>
                    <param name="mb" type="MenuBar"/>
                </params>
            </method>
            <method name="setResizable" type="void" line="353">
                <params>
                    <param name="resizable" type="boolean"/>
                </params>
            </method>
            <method name="remove" type="void" line="354">
                <params>
                    <param name="m" type="MenuComponent"/>
                </params>
            </method>
            <method name="isResizable" type="boolean" line="356"/>
            <method name="addNotify" type="void" line="360">
                <scope line="361">
                    <scope line="362"/>
                </scope>
            </method>
            <method name="setCursorAllowed" type="void" line="370">
                <params>
                    <param name="isCursorAllowed" type="boolean"/>
                </params>
            </method>
            <method name="isCursorAllowed" type="boolean" line="374"/>
            <method name="getCursor" type="Cursor" line="377"/>
            <method name="setPeer" type="void" line="383">
                <params>
                    <param name="p" type="ComponentPeer"/>
                </params>
                <comment line="400">
                    run                    
                </comment>
                <scope line="384">
                    <anonymous_class line="385">
                        <method name="run" type="Object" line="386">
                            <scope line="387">
                                <declaration name="lnkPeer" type="Field" line="388"/>
                                <scope line="389"/>
                            </scope>
                            <scope line="393"/>
                            <scope line="395"/>
                        </method>
                    </anonymous_class>
                </scope>
                <scope line="402">
                    <scope line="403"/>
                </scope>
                <scope line="406"/>
            </method>
            <javadoc line="411">
                Synthesize native message to activate or deactivate EmbeddedFrame window
                  depending on the value of parameter &lt;code&gt;b&lt;/code&gt;.
                  Peers should override this method if they are to implement
                  this functionality.                
                <param>
                    doActivate  if &lt;code&gt;true&lt;/code&gt;, activates the window;
                      otherwise, deactivates the window                    
                </param>
            </javadoc>
            <method name="synthesizeWindowActivation" type="void" line="419">
                <params>
                    <param name="doActivate" type="boolean"/>
                </params>
            </method>
            <javadoc line="421">
                Moves this embedded frame to a new location. The top-left corner of
                  the new location is specified by the &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt;
                  parameters relative to the native parent component.
                  &lt;p&gt;
                  setLocation() and setBounds() for EmbeddedFrame really don&apos;t move it
                  within the native parent. These methods always put embedded frame to
                  (0, 0) for backward compatibility. To allow moving embedded frame
                  setLocationPrivate() and setBoundsPrivate() were introduced, and they
                  work just the same way as setLocation() and setBounds() for usual,
                  non-embedded components.
                  &lt;/p&gt;
                  &lt;p&gt;
                  Using usual get/setLocation() and get/setBounds() together with new
                  get/setLocationPrivate() and get/setBoundsPrivate() is not recommended.
                  For example, calling getBoundsPrivate() after setLocation() works fine,
                  but getBounds() after setBoundsPrivate() may return unpredictable value.
                  &lt;/p&gt;                
                <param>
                    x the new &lt;i&gt;x&lt;/i&gt;-coordinate relative to the parent component                    
                </param>
                <param>
                    y the new &lt;i&gt;y&lt;/i&gt;-coordinate relative to the parent component                    
                </param>
                <see>
                    java.awt.Component#setLocation                    
                </see>
                <see>
                    #getLocationPrivate                    
                </see>
                <see>
                    #setBoundsPrivate                    
                </see>
                <see>
                    #getBoundsPrivate                    
                </see>
                <since>
                    1.5                    
                </since>
            </javadoc>
            <method name="setLocationPrivate" type="void" line="447">
                <params>
                    <param name="x" type="int"/>
                    <param name="y" type="int"/>
                </params>
                <declaration name="size" type="Dimension" line="448"/>
            </method>
            <javadoc line="452">
                Gets the location of this embedded frame as a point specifying the
                  top-left corner relative to parent component.
                  &lt;p&gt;
                  setLocation() and setBounds() for EmbeddedFrame really don&apos;t move it
                  within the native parent. These methods always put embedded frame to
                  (0, 0) for backward compatibility. To allow getting location and size
                  of embedded frame getLocationPrivate() and getBoundsPrivate() were
                  introduced, and they work just the same way as getLocation() and getBounds()
                  for ususal, non-embedded components.
                  &lt;/p&gt;
                  &lt;p&gt;
                  Using usual get/setLocation() and get/setBounds() together with new
                  get/setLocationPrivate() and get/setBoundsPrivate() is not recommended.
                  For example, calling getBoundsPrivate() after setLocation() works fine,
                  but getBounds() after setBoundsPrivate() may return unpredictable value.
                  &lt;/p&gt;                
                <return>
                    a point indicating this embedded frame&apos;s top-left corner                    
                </return>
                <see>
                    java.awt.Component#getLocation                    
                </see>
                <see>
                    #setLocationPrivate                    
                </see>
                <see>
                    #setBoundsPrivate                    
                </see>
                <see>
                    #getBoundsPrivate                    
                </see>
                <since>
                    1.6                    
                </since>
            </javadoc>
            <method name="getLocationPrivate" type="Point" line="476">
                <declaration name="bounds" type="Rectangle" line="477"/>
            </method>
            <javadoc line="481">
                Moves and resizes this embedded frame. The new location of the top-left
                  corner is specified by &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt; parameters
                  relative to the native parent component. The new size is specified by
                  &lt;code&gt;width&lt;/code&gt; and &lt;code&gt;height&lt;/code&gt;.
                  &lt;p&gt;
                  setLocation() and setBounds() for EmbeddedFrame really don&apos;t move it
                  within the native parent. These methods always put embedded frame to
                  (0, 0) for backward compatibility. To allow moving embedded frames
                  setLocationPrivate() and setBoundsPrivate() were introduced, and they
                  work just the same way as setLocation() and setBounds() for usual,
                  non-embedded components.
                  &lt;/p&gt;
                  &lt;p&gt;
                  Using usual get/setLocation() and get/setBounds() together with new
                  get/setLocationPrivate() and get/setBoundsPrivate() is not recommended.
                  For example, calling getBoundsPrivate() after setLocation() works fine,
                  but getBounds() after setBoundsPrivate() may return unpredictable value.
                  &lt;/p&gt;                
                <param>
                    x the new &lt;i&gt;x&lt;/i&gt;-coordinate relative to the parent component                    
                </param>
                <param>
                    y the new &lt;i&gt;y&lt;/i&gt;-coordinate relative to the parent component                    
                </param>
                <param>
                    width the new &lt;code&gt;width&lt;/code&gt; of this embedded frame                    
                </param>
                <param>
                    height the new &lt;code&gt;height&lt;/code&gt; of this embedded frame                    
                </param>
                <see>
                    java.awt.Component#setBounds                    
                </see>
                <see>
                    #setLocationPrivate                    
                </see>
                <see>
                    #getLocationPrivate                    
                </see>
                <see>
                    #getBoundsPrivate                    
                </see>
                <since>
                    1.5                    
                </since>
            </javadoc>
            <method name="setBoundsPrivate" type="void" line="510">
                <params>
                    <param name="x" type="int"/>
                    <param name="y" type="int"/>
                    <param name="width" type="int"/>
                    <param name="height" type="int"/>
                </params>
                <declaration name="peer" type="FramePeer" line="511"/>
                <scope line="512"/>
            </method>
            <javadoc line="517">
                Gets the bounds of this embedded frame as a rectangle specifying the
                  width, height and location relative to the native parent component.
                  &lt;p&gt;
                  setLocation() and setBounds() for EmbeddedFrame really don&apos;t move it
                  within the native parent. These methods always put embedded frame to
                  (0, 0) for backward compatibility. To allow getting location and size
                  of embedded frames getLocationPrivate() and getBoundsPrivate() were
                  introduced, and they work just the same way as getLocation() and getBounds()
                  for ususal, non-embedded components.
                  &lt;/p&gt;
                  &lt;p&gt;
                  Using usual get/setLocation() and get/setBounds() together with new
                  get/setLocationPrivate() and get/setBoundsPrivate() is not recommended.
                  For example, calling getBoundsPrivate() after setLocation() works fine,
                  but getBounds() after setBoundsPrivate() may return unpredictable value.
                  &lt;/p&gt;                
                <return>
                    a rectangle indicating this embedded frame&apos;s bounds                    
                </return>
                <see>
                    java.awt.Component#getBounds                    
                </see>
                <see>
                    #setLocationPrivate                    
                </see>
                <see>
                    #getLocationPrivate                    
                </see>
                <see>
                    #setBoundsPrivate                    
                </see>
                <since>
                    1.6                    
                </since>
            </javadoc>
            <method name="getBoundsPrivate" type="Rectangle" line="541">
                <declaration name="peer" type="FramePeer" line="542"/>
                <scope line="543"/>
                <scope line="546"/>
            </method>
            <method name="toFront" type="void" line="551"/>
            <method name="toBack" type="void" line="552"/>
            <method name="registerAccelerator" type="void" line="554"/>
            <method name="unregisterAccelerator" type="void" line="555"/>
            <javadoc line="557">
                Checks if the component is in an EmbeddedFrame. If so,
                  returns the applet found in the hierarchy or null if
                  not found.                
                <return>
                    the parent applet or {@ null}                    
                </return>
                <since>
                    1.6                    
                </since>
            </javadoc>
            <method name="getAppletIfAncestorOf" type="Applet" line="564">
                <params>
                    <param name="comp" type="Component"/>
                </params>
                <declaration name="parent" type="Container" line="565"/>
                <declaration name="applet" type="Applet" line="566"/>
                <scope line="567">
                    <scope line="568"/>
                </scope>
            </method>
            <javadoc line="576">
                This method should be overriden in subclasses. It is
                  called when window this frame is within should be blocked
                  by some modal dialog.                
            </javadoc>
            <method name="notifyModalBlocked" type="void" line="581">
                <params>
                    <param name="blocker" type="Dialog"/>
                    <param name="blocked" type="boolean"/>
                </params>
            </method>
            <class name="NullEmbeddedFramePeer" line="584">
                <extends class="NullComponentPeer"/>
                <implements interface="FramePeer"/>
                <method name="setTitle" type="void" line="586">
                    <params>
                        <param name="title" type="String"/>
                    </params>
                </method>
                <method name="setIconImage" type="void" line="587">
                    <params>
                        <param name="im" type="Image"/>
                    </params>
                </method>
                <method name="updateIconImages" type="void" line="588"/>
                <method name="setMenuBar" type="void" line="589">
                    <params>
                        <param name="mb" type="MenuBar"/>
                    </params>
                </method>
                <method name="setResizable" type="void" line="590">
                    <params>
                        <param name="resizeable" type="boolean"/>
                    </params>
                </method>
                <method name="setState" type="void" line="591">
                    <params>
                        <param name="state" type="int"/>
                    </params>
                </method>
                <method name="getState" type="int" line="592"/>
                <method name="setMaximizedBounds" type="void" line="593">
                    <params>
                        <param name="b" type="Rectangle"/>
                    </params>
                </method>
                <method name="toFront" type="void" line="594"/>
                <method name="toBack" type="void" line="595"/>
                <method name="updateFocusableWindowState" type="void" line="596"/>
                <method name="updateAlwaysOnTop" type="void" line="597"/>
                <method name="setAlwaysOnTop" type="void" line="598">
                    <params>
                        <param name="alwaysOnTop" type="boolean"/>
                    </params>
                </method>
                <method name="getGlobalHeavyweightFocusOwner" type="Component" line="599"/>
                <method name="setBoundsPrivate" type="void" line="600">
                    <params>
                        <param name="x" type="int"/>
                        <param name="y" type="int"/>
                        <param name="width" type="int"/>
                        <param name="height" type="int"/>
                    </params>
                </method>
                <method name="getBoundsPrivate" type="Rectangle" line="603"/>
                <method name="setModalBlocked" type="void" line="606">
                    <params>
                        <param name="blocker" type="Dialog"/>
                        <param name="blocked" type="boolean"/>
                    </params>
                </method>
                <javadoc line="608">
                    @see java.awt.peer.ContainerPeer#restack                    
                </javadoc>
                <method name="restack" type="void" line="611"/>
                <javadoc line="615">
                    @see java.awt.peer.ContainerPeer#isRestackSupported                    
                </javadoc>
                <method name="isRestackSupported" type="boolean" line="618"/>
                <method name="requestWindowFocus" type="boolean" line="621"/>
                <method name="updateMinimumSize" type="void" line="624"/>
                <method name="setOpacity" type="void" line="627">
                    <params>
                        <param name="opacity" type="float"/>
                    </params>
                </method>
                <method name="setOpaque" type="void" line="630">
                    <params>
                        <param name="isOpaque" type="boolean"/>
                    </params>
                </method>
                <method name="updateWindow" type="void" line="633"/>
                <method name="repositionSecurityWarning" type="void" line="636"/>
            </class>
        </class>
    </source>