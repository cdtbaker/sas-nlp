<?xml version="1.0" encoding="UTF-8"?>
    <source package="sun.tracing">
        <import package="java.lang.reflect.InvocationHandler"/>
        <import package="java.lang.reflect.Method"/>
        <import package="java.lang.reflect.Proxy"/>
        <import package="java.lang.reflect.InvocationTargetException"/>
        <import package="java.lang.reflect.AnnotatedElement"/>
        <import package="java.lang.annotation.Annotation"/>
        <import package="java.util.HashMap"/>
        <import package="java.security.AccessController"/>
        <import package="java.security.PrivilegedAction"/>
        <import package="com.sun.tracing.Provider"/>
        <import package="com.sun.tracing.Probe"/>
        <import package="com.sun.tracing.ProviderName"/>
        <class name="ProviderSkeleton" line="42">
            <comment line="71">
                set to false after dispose() is called                
            </comment>
            <comment line="72">
                user&apos;s interface                
            </comment>
            <comment line="73">
                methods to probes                
            </comment>
            <implements interface="InvocationHandler"/>
            <implements interface="Provider"/>
            <javadoc line="42">
                Provides a common code for implementation of {@code Provider} classes.
                  Each tracing subsystem needs to provide three classes, a factory
                  (derived from {@code ProviderFactory}, a provider (a subclass of{@code Provider}, and a probe type (subclass of {@code ProbeSkeleton}).
                  The factory object takes a user-defined interface and provides an
                  implementation of it whose method calls will trigger probes in the
                  tracing framework.
                  The framework&apos;s provider class, and its instances, are not seen by the
                  user at all -- they usually sit in the background and receive and dispatch
                  the calls to the user&apos;s provider interface.  The {@code ProviderSkeleton}class provides almost all of the implementation needed by a framework
                  provider.  Framework providers must only provide a constructor and
                  disposal method, and implement the {@code createProbe} method to create
                  an appropriate {@code ProbeSkeleton} subclass.
                  The framework&apos;s probe class provides the implementation of the two
                  probe methods, {@code isEnabled()} and {@code uncheckedTrigger()}.  Both are
                  framework-dependent implementations.                
                <since>
                    1.7                    
                </since>
            </javadoc>
            <declaration name="active" type="boolean" line="70"/>
            <declaration name="providerType" type="Class&lt;? extends Provider&gt;" line="71"/>
            <declaration name="probes" type="HashMap&lt;Method,ProbeSkeleton&gt;" line="72"/>
            <method name="createProbe" type="ProbeSkeleton" line="75"/>
            <javadoc line="75">
                Creates a framework-specific probe subtype.
                  This method is implemented by the framework&apos;s provider and returns
                  framework-specific probes for a method.                
                <param>
                    method A method in the user's interface                    
                </param>
                <return>
                    a subclass of ProbeSkeleton for the particular framework.                    
                </return>
            </javadoc>
            <javadoc line="86">
                Initializes the provider.                
                <param>
                    type the user's interface                    
                </param>
            </javadoc>
            <method name="ProviderSkeleton" type="constructor" line="91">
                <params>
                    <param name="type" type="Class<? extends Provider>"/>
                </params>
                <comment line="92">
                    in case of some error during initialization                    
                </comment>
            </method>
            <javadoc line="97">
                Post-constructor initialization routine.
                  Subclass instances must be initialized before they can create probes.
                  It is up to the factory implementations to call this after construction.                
            </javadoc>
            <method name="init" type="void" line="103">
                <anonymous_class line="104">
                    <method name="run" type="Method[]" line="105"/>
                </anonymous_class>
                <declaration name="methods" type="Method[]" line="104"/>
                <scope line="110">
                    <scope line="111"/>
                    <scope line="114"/>
                </scope>
            </method>
            <javadoc line="121">
                Magic routine which creates an implementation of the user&apos;s interface.
                  This method creates the instance of the user&apos;s interface which is
                  passed back to the user.  Every call upon that interface will be
                  redirected to the {@code invoke()} method of this class (until
                  overridden by the VM).                
                <return>
                    an implementation of the user's interface                    
                </return>
            </javadoc>
            <method name="newProxyInstance" type="T" line="132"/>
            <javadoc line="137">
                Triggers a framework probe when a user interface method is called.
                  This method dispatches a user interface method call to the appropriate
                  probe associated with this framework.
                  If the invoked method is not a user-defined member of the interface,
                  then it is a member of {@code Provider} or {@code Object} and we
                  invoke the method directly.                
                <param>
                    proxy the instance whose method was invoked                    
                </param>
                <param>
                    method the method that was called                    
                </param>
                <param>
                    args the arguments passed in the call.                    
                </param>
                <return>
                    always null, if the method is a user-defined probe                    
                </return>
            </javadoc>
            <method name="invoke" type="Object" line="152">
                <params>
                    <param name="proxy" type="Object"/>
                    <param name="method" type="Method"/>
                    <param name="args" type="Object[]"/>
                </params>
                <comment line="164">
                    Skips argument check -- already done by javac                    
                </comment>
                <scope line="153">
                    <scope line="154"/>
                    <scope line="156"/>
                    <scope line="158"/>
                </scope>
                <scope line="161">
                    <declaration name="p" type="ProbeSkeleton" line="162"/>
                    <scope line="163"/>
                </scope>
            </method>
            <javadoc line="171">
                Direct accessor for {@code Probe} objects.                
                <param>
                    m the method corresponding to a probe                    
                </param>
                <return>
                    the method associated probe object, or null                    
                </return>
            </javadoc>
            <method name="getProbe" type="Probe" line="177">
                <params>
                    <param name="m" type="Method"/>
                </params>
            </method>
            <javadoc line="181">
                Default provider disposal method.
                  This is overridden in subclasses as needed.                
            </javadoc>
            <method name="dispose" type="void" line="186"/>
            <javadoc line="191">
                Gets the user-specified provider name for the user&apos;s interface.
                  If the user&apos;s interface has a {@ProviderName} annotation, that value
                  is used.  Otherwise we use the simple name of the user interface&apos;s class.                
                <return>
                    the provider name                    
                </return>
            </javadoc>
            <method name="getProviderName" type="String" line="198"/>
            <javadoc line="203">
                Utility method for getting a string value from an annotation.
                  Used for getting a string value from an annotation with a &apos;value&apos; method.                
                <param>
                    element the element that was annotated, either a class or method                    
                </param>
                <param>
                    annotation the class of the annotation we're interested in                    
                </param>
                <param>
                    defaultValue the value to return if the annotation doesn't
                      exist, doesn't have a "value", or the value is empty.                    
                </param>
            </javadoc>
            <method name="getAnnotationString" type="String" line="215">
                <params>
                    <param name="element" type="AnnotatedElement"/>
                    <param name="annotation" type="Class<? extends Annotation>"/>
                    <param name="defaultValue" type="String"/>
                </params>
                <declaration name="ret" type="String" line="216"/>
            </method>
            <javadoc line="221">
                Utility method for calling an arbitrary method in an annotation.                
                <param>
                    element the element that was annotated, either a class or method                    
                </param>
                <param>
                    annotation the class of the annotation we're interested in                    
                </param>
                <param>
                    methodName the name of the method in the annotation we wish
                      to call.                    
                </param>
                <param>
                    defaultValue the value to return if the annotation doesn't
                      exist, or we couldn't invoke the method for some reason.                    
                </param>
                <return>
                    the result of calling the annotation method, or the default.                    
                </return>
            </javadoc>
            <method name="getAnnotationValue" type="Object" line="234">
                <params>
                    <param name="element" type="AnnotatedElement"/>
                    <param name="annotation" type="Class<? extends Annotation>"/>
                    <param name="methodName" type="String"/>
                    <param name="defaultValue" type="Object"/>
                </params>
                <declaration name="ret" type="Object" line="235"/>
                <scope line="236">
                    <declaration name="m" type="Method" line="237"/>
                    <declaration name="a" type="Annotation" line="238"/>
                </scope>
                <scope line="240"/>
                <scope line="242"/>
                <scope line="244"/>
                <scope line="246"/>
            </method>
        </class>
    </source>