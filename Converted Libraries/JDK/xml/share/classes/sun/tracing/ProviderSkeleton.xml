<?xml version="1.0" encoding="UTF-8"?>
    <source package="sun.tracing">
        <import package="java.lang.reflect.InvocationHandler"/>
        <import package="java.lang.reflect.Method"/>
        <import package="java.lang.reflect.Proxy"/>
        <import package="java.lang.reflect.InvocationTargetException"/>
        <import package="java.lang.reflect.AnnotatedElement"/>
        <import package="java.lang.annotation.Annotation"/>
        <import package="java.util.HashMap"/>
        <import package="java.security.AccessController"/>
        <import package="java.security.PrivilegedAction"/>
        <import package="com.sun.tracing.Provider"/>
        <import package="com.sun.tracing.Probe"/>
        <import package="com.sun.tracing.ProviderName"/>
        <class name="ProviderSkeleton" line="14">
            <implements interface="InvocationHandler"/>
            <implements interface="Provider"/>
            <javadoc line="14">
                Provides a common code for implementation of {@code Provider} classes.
                  Each tracing subsystem needs to provide three classes, a factory
                  (derived from {@code ProviderFactory}, a provider (a subclass of{@code Provider}, and a probe type (subclass of {@code ProbeSkeleton}).
                  The factory object takes a user-defined interface and provides an
                  implementation of it whose method calls will trigger probes in the
                  tracing framework.
                  The framework&apos;s provider class, and its instances, are not seen by the
                  user at all -- they usually sit in the background and receive and dispatch
                  the calls to the user&apos;s provider interface.  The {@code ProviderSkeleton}class provides almost all of the implementation needed by a framework
                  provider.  Framework providers must only provide a constructor and
                  disposal method, and implement the {@code createProbe} method to create
                  an appropriate {@code ProbeSkeleton} subclass.
                  The framework&apos;s probe class provides the implementation of the two
                  probe methods, {@code isEnabled()} and {@code uncheckedTrigger()}.  Both are
                  framework-dependent implementations.                
                <since>
                    1.7                    
                </since>
            </javadoc>
            <declaration name="active" type="boolean" line="33"/>
            <declaration name="providerType" type="Class&amp;lt;? extends Provider&amp;gt;" line="34"/>
            <declaration name="probes" type="HashMap&amp;lt;Method,ProbeSkeleton&amp;gt;" line="35"/>
            <method name="createProbe" type="ProbeSkeleton" line="36"/>
            <javadoc line="36">
                Creates a framework-specific probe subtype.
                  This method is implemented by the framework&apos;s provider and returns
                  framework-specific probes for a method.                
                <param>
                    method A method in the user&apos;s interface                    
                </param>
                <return>
                    a subclass of ProbeSkeleton for the particular framework.                    
                </return>
            </javadoc>
            <javadoc line="44">
                Initializes the provider.                
                <param>
                    type the user&apos;s interface                    
                </param>
            </javadoc>
            <method name="ProviderSkeleton" type="constructor" line="48">
                <params>
                    <param name="type" type="Class&lt;? extends Provider&gt;"/>
                </params>
            </method>
            <javadoc line="53">
                Post-constructor initialization routine.
                  Subclass instances must be initialized before they can create probes.
                  It is up to the factory implementations to call this after construction.                
            </javadoc>
            <method name="init" type="void" line="58">
                <anonymous_class line="59">
                    <method name="run" type="Method[]" line="60"/>
                </anonymous_class>
                <declaration name="methods" type="Method[]" line="59"/>
                <scope line="65">
                    <scope line="66"/>
                    <scope line="69"/>
                </scope>
            </method>
            <javadoc line="75">
                Magic routine which creates an implementation of the user&apos;s interface.
                  This method creates the instance of the user&apos;s interface which is
                  passed back to the user.  Every call upon that interface will be
                  redirected to the {@code invoke()} method of this class (until
                  overridden by the VM).                
                <return>
                    an implementation of the user&apos;s interface                    
                </return>
            </javadoc>
            <method name="newProxyInstance" type="T" line="83"/>
            <javadoc line="86">
                Triggers a framework probe when a user interface method is called.
                  This method dispatches a user interface method call to the appropriate
                  probe associated with this framework.
                  If the invoked method is not a user-defined member of the interface,
                  then it is a member of {@code Provider} or {@code Object} and we
                  invoke the method directly.                
                <param>
                    proxy the instance whose method was invoked                    
                </param>
                <param>
                    method the method that was called                    
                </param>
                <param>
                    args the arguments passed in the call.                    
                </param>
                <return>
                    always null, if the method is a user-defined probe                    
                </return>
            </javadoc>
            <method name="invoke" type="Object" line="98">
                <params>
                    <param name="proxy" type="Object"/>
                    <param name="method" type="Method"/>
                    <param name="args" type="Object[]"/>
                </params>
            </method>
            <javadoc line="118">
                Direct accessor for {@code Probe} objects.                
                <param>
                    m the method corresponding to a probe                    
                </param>
                <return>
                    the method associated probe object, or null                    
                </return>
            </javadoc>
            <method name="getProbe" type="Probe" line="123">
                <params>
                    <param name="m" type="Method"/>
                </params>
            </method>
            <javadoc line="126">
                Default provider disposal method.
                  This is overridden in subclasses as needed.                
            </javadoc>
            <method name="dispose" type="void" line="130"/>
            <javadoc line="134">
                Gets the user-specified provider name for the user&apos;s interface.
                  If the user&apos;s interface has a {@ProviderName} annotation, that value
                  is used.  Otherwise we use the simple name of the user interface&apos;s class.                
                <return>
                    the provider name                    
                </return>
            </javadoc>
            <method name="getProviderName" type="String" line="140"/>
            <javadoc line="143">
                Utility method for getting a string value from an annotation.
                  Used for getting a string value from an annotation with a &apos;value&apos; method.                
                <param>
                    element the element that was annotated, either a class or method                    
                </param>
                <param>
                    annotation the class of the annotation we&apos;re interested in                    
                </param>
                <param>
                    defaultValue the value to return if the annotation doesn&apos;t
                      exist, doesn&apos;t have a &quot;value&quot;, or the value is empty.                    
                </param>
            </javadoc>
            <method name="getAnnotationString" type="String" line="151">
                <params>
                    <param name="element" type="AnnotatedElement"/>
                    <param name="annotation" type="Class&lt;? extends Annotation&gt;"/>
                    <param name="defaultValue" type="String"/>
                </params>
                <declaration name="ret" type="String" line="152"/>
            </method>
            <javadoc line="155">
                Utility method for calling an arbitrary method in an annotation.                
                <param>
                    element the element that was annotated, either a class or method                    
                </param>
                <param>
                    annotation the class of the annotation we&apos;re interested in                    
                </param>
                <param>
                    methodName the name of the method in the annotation we wish
                      to call.                    
                </param>
                <param>
                    defaultValue the value to return if the annotation doesn&apos;t
                      exist, or we couldn&apos;t invoke the method for some reason.                    
                </param>
                <return>
                    the result of calling the annotation method, or the default.                    
                </return>
            </javadoc>
            <method name="getAnnotationValue" type="Object" line="165">
                <params>
                    <param name="element" type="AnnotatedElement"/>
                    <param name="annotation" type="Class&lt;? extends Annotation&gt;"/>
                    <param name="methodName" type="String"/>
                    <param name="defaultValue" type="Object"/>
                </params>
            </method>
        </class>
    </source>