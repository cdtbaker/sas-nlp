<?xml version="1.0" encoding="UTF-8"?>
    <source package="sun.tracing.dtrace">
        <import package="java.lang.reflect.Method"/>
        <import package="java.lang.reflect.InvocationTargetException"/>
        <import package="java.lang.reflect.Modifier"/>
        <import package="java.lang.reflect.Constructor"/>
        <import package="java.lang.reflect.InvocationHandler"/>
        <import package="java.lang.reflect.InvocationTargetException"/>
        <import package="java.lang.annotation.Annotation"/>
        <import package="java.util.HashMap"/>
        <import package="sun.tracing.ProviderSkeleton"/>
        <import package="sun.tracing.ProbeSkeleton"/>
        <import package="com.sun.tracing.Provider"/>
        <import package="com.sun.tracing.ProviderName"/>
        <import package="com.sun.tracing.ProbeName"/>
        <import package="com.sun.tracing.dtrace.Attributes"/>
        <import package="com.sun.tracing.dtrace.ModuleName"/>
        <import package="com.sun.tracing.dtrace.FunctionName"/>
        <import package="com.sun.tracing.dtrace.StabilityLevel"/>
        <import package="com.sun.tracing.dtrace.DependencyClass"/>
        <import package="sun.misc.ProxyGenerator"/>
        <class name="DTraceProvider" line="50">
            <extends class="ProviderSkeleton"/>
            <comment line="56">
                For proxy generation                
            </comment>
            <comment line="155">
                In the normal case, the proxy object&apos;s method implementations will call
                 this method (it usually calls the ProviderSkeleton&apos;s version).  That
                 method uses the passed &apos;method&apos; object to lookup the associated
                 &apos;ProbeSkeleton&apos; and calls uncheckedTrigger() on that probe to cause the
                 probe to fire.  DTrace probes are different in that the proxy class&apos;s
                 methods are immediately overridden with native code to fire the probe
                 directly.  So this method should never get invoked.  We also wire up the
                 DTraceProbe.uncheckedTrigger() method to call the proxy method instead
                 of doing the work itself.                
            </comment>
            <declaration name="activation" type="Activation" line="52"/>
            <declaration name="proxy" type="Object" line="53"/>
            <declaration name="constructorParams" type="Class[]" line="56"/>
            <declaration name="proxyClassNamePrefix" type="String" line="57"/>
            <declaration name="DEFAULT_MODULE" type="String" line="59"/>
            <declaration name="DEFAULT_FUNCTION" type="String" line="60"/>
            <declaration name="nextUniqueNumber" type="long" line="62"/>
            <method name="getUniqueNumber" type="long" line="63"/>
            <method name="createProbe" type="ProbeSkeleton" line="67">
                <params>
                    <param name="m" type="Method"/>
                </params>
            </method>
            <method name="DTraceProvider" type="constructor" line="71">
                <params>
                    <param name="type" type="Class<? extends Provider>"/>
                </params>
            </method>
            <method name="setProxy" type="void" line="75">
                <params>
                    <param name="p" type="Object"/>
                </params>
            </method>
            <method name="setActivation" type="void" line="79">
                <params>
                    <param name="a" type="Activation"/>
                </params>
            </method>
            <method name="dispose" type="void" line="83">
                <scope line="84"/>
            </method>
            <javadoc line="91">
                Magic routine which creates an implementation of the user&apos;s interface.
                  This method uses the ProxyGenerator directly to bypass the
                  java.lang.reflect.proxy cache so that we get a unique class each
                  time it&apos;s called and can&apos;t accidently reuse a $Proxy class.                
                <return>
                    an implementation of the user's interface                    
                </return>
            </javadoc>
            <method name="newProxyInstance" type="T" line="101">
                <comment line="103">
                    Choose a name for the proxy class to generate.                    
                </comment>
                <comment line="117">
                    Generate the specified proxy class.                    
                </comment>
                <comment line="128">
                    A ClassFormatError here means that (barring bugs in the
                     proxy class generation code) there was some other
                     invalid aspect of the arguments supplied to the proxy
                     class creation (such as virtual machine limitations
                     exceeded).                    
                </comment>
                <comment line="138">
                    Invoke its constructor with the designated invocation handler.                    
                </comment>
                <declaration name="num" type="long" line="105"/>
                <declaration name="proxyPkg" type="String" line="107"/>
                <scope line="108">
                    <declaration name="name" type="String" line="109"/>
                    <declaration name="n" type="int" line="110"/>
                </scope>
                <declaration name="proxyName" type="String" line="114"/>
                <declaration name="proxyClass" type="Class&lt;?&gt;" line="119"/>
                <declaration name="proxyClassFile" type="byte[]" line="120"/>
                <scope line="122"/>
                <scope line="126"/>
                <scope line="140">
                    <declaration name="cons" type="Constructor" line="141"/>
                </scope>
                <scope line="143"/>
                <scope line="145"/>
                <scope line="147"/>
                <scope line="149"/>
            </method>
            <method name="invoke" type="Object" line="163">
                <params>
                    <param name="proxy" type="Object"/>
                    <param name="method" type="Method"/>
                    <param name="args" type="Object[]"/>
                </params>
                <scope line="164">
                    <scope line="165"/>
                    <scope line="167"/>
                    <scope line="169"/>
                </scope>
                <scope line="172"/>
            </method>
            <method name="getProviderName" type="String" line="178"/>
            <method name="getModuleName" type="String" line="182"/>
            <method name="getProbeName" type="String" line="187">
                <params>
                    <param name="method" type="Method"/>
                </params>
            </method>
            <method name="getFunctionName" type="String" line="192">
                <params>
                    <param name="method" type="Method"/>
                </params>
            </method>
            <method name="getProbes" type="DTraceProbe[]" line="197"/>
            <method name="getNameStabilityFor" type="StabilityLevel" line="201">
                <params>
                    <param name="type" type="Class<? extends Annotation>"/>
                </params>
                <declaration name="attrs" type="Attributes" line="202"/>
                <scope line="204"/>
                <scope line="206"/>
            </method>
            <method name="getDataStabilityFor" type="StabilityLevel" line="211">
                <params>
                    <param name="type" type="Class<? extends Annotation>"/>
                </params>
                <declaration name="attrs" type="Attributes" line="212"/>
                <scope line="214"/>
                <scope line="216"/>
            </method>
            <method name="getDependencyClassFor" type="DependencyClass" line="221">
                <params>
                    <param name="type" type="Class<? extends Annotation>"/>
                </params>
                <declaration name="attrs" type="Attributes" line="222"/>
                <scope line="224"/>
                <scope line="226"/>
            </method>
        </class>
    </source>