<?xml version="1.0" encoding="UTF-8"?>
    <source package="sun.security.jgss.krb5">
        <import package="org.ietf.jgss"/>
        <import package="java.io.InputStream"/>
        <import package="java.io.OutputStream"/>
        <import package="java.io.IOException"/>
        <import package="java.io.ByteArrayInputStream"/>
        <import package="java.io.ByteArrayOutputStream"/>
        <import package="java.security.MessageDigest"/>
        <import package="java.util.Arrays"/>
        <class name="MessageToken_v2" line="10">
            <extends class="Krb5Token"/>
            <javadoc line="10">
                This class is a base class for new GSS token definitions, as defined
                  in RFC 4121, that pertain to per-message GSS-API calls. Conceptually
                  GSS-API has two types of per-message tokens: WrapToken and MicToken.
                  They differ in the respect that a WrapToken carries additional plaintext
                  or ciphertext application data besides just the sequence number and
                  checksum. This class encapsulates the commonality in the structure of
                  the WrapToken and the MicToken. This structure can be represented as:
                  &lt;p&gt;
                  &lt;pre&gt;
                  Wrap Tokens
                  Octet no   Name        Description
                  ---------------------------------------------------------------
                  0..1     TOK_ID     Identification field.  Tokens emitted by
                  GSS_Wrap() contain the hex value 05 04
                  expressed in big-endian order in this field.
                  2        Flags      Attributes field, as described in section
                  4.2.2.
                  3        Filler     Contains the hex value FF.
                  4..5     EC         Contains the &quot;extra count&quot; field, in big-
                  endian order as described in section 4.2.3.
                  6..7     RRC        Contains the &quot;right rotation count&quot; in big
                  endian order, as described in section 4.2.5.
                  8..15    SND_SEQ    Sequence number field in clear text,
                  expressed in big-endian order.
                  16..last Data       Encrypted data for Wrap tokens with
                  confidentiality, or plaintext data followed
                  by the checksum for Wrap tokens without
                  confidentiality, as described in section
                  4.2.4.
                  MIC Tokens
                  Octet no   Name        Description
                  -----------------------------------------------------------------
                  0..1     TOK_ID     Identification field.  Tokens emitted by
                  GSS_GetMIC() contain the hex value 04 04
                  expressed in big-endian order in this field.
                  2        Flags      Attributes field, as described in section
                  4.2.2.
                  3..7     Filler     Contains five octets of hex value FF.
                  8..15    SND_SEQ    Sequence number field in clear text,
                  expressed in big-endian order.
                  16..last SGN_CKSUM  Checksum of the &quot;to-be-signed&quot; data and
                  octet 0..15, as described in section 4.2.4.
                  &lt;/pre&gt;
                  &lt;p&gt;
                  This class is the super class of WrapToken_v2 and MicToken_v2. The token&apos;s
                  header (bytes[0..15]) and data (byte[16..]) are saved in tokenHeader and
                  tokenData fields. Since there is no easy way to find out the exact length
                  of a WrapToken_v2 token from any header info, in the case of reading from
                  stream, we read all available() bytes into the token.
                  &lt;p&gt;
                  All read actions are performed in this super class. On the write part, the
                  super class only write the tokenHeader, and the content writing is inside
                  child classes.                
                <author>
                    Seema Malkani                    
                </author>
            </javadoc>
            <declaration name="TOKEN_HEADER_SIZE" type="int" line="67"/>
            <declaration name="TOKEN_ID_POS" type="int" line="68"/>
            <declaration name="TOKEN_FLAG_POS" type="int" line="69"/>
            <declaration name="TOKEN_EC_POS" type="int" line="70"/>
            <declaration name="TOKEN_RRC_POS" type="int" line="71"/>
            <declaration name="CONFOUNDER_SIZE" type="int" line="72"/>
            <javadoc line="72">
                The size of the random confounder used in a WrapToken.                
            </javadoc>
            <declaration name="KG_USAGE_ACCEPTOR_SEAL" type="int" line="76"/>
            <declaration name="KG_USAGE_ACCEPTOR_SIGN" type="int" line="77"/>
            <declaration name="KG_USAGE_INITIATOR_SEAL" type="int" line="78"/>
            <declaration name="KG_USAGE_INITIATOR_SIGN" type="int" line="79"/>
            <declaration name="FLAG_SENDER_IS_ACCEPTOR" type="int" line="80"/>
            <declaration name="FLAG_WRAP_CONFIDENTIAL" type="int" line="81"/>
            <declaration name="FLAG_ACCEPTOR_SUBKEY" type="int" line="82"/>
            <declaration name="FILLER" type="int" line="83"/>
            <declaration name="tokenHeader" type="MessageTokenHeader" line="84"/>
            <declaration name="tokenId" type="int" line="85"/>
            <declaration name="seqNumber" type="int" line="86"/>
            <declaration name="tokenData" type="byte[]" line="87"/>
            <declaration name="tokenDataLen" type="int" line="88"/>
            <declaration name="key_usage" type="int" line="89"/>
            <declaration name="ec" type="int" line="90"/>
            <declaration name="rrc" type="int" line="91"/>
            <declaration name="checksum" type="byte[]" line="92"/>
            <declaration name="confState" type="boolean" line="93"/>
            <declaration name="initiator" type="boolean" line="94"/>
            <declaration name="cipherHelper" type="CipherHelper" line="95"/>
            <javadoc line="96">
                Constructs a MessageToken from a byte array.                
                <param>
                    tokenId the token id that should be contained in this token as
                      it is read.                    
                </param>
                <param>
                    context the Kerberos context associated with this token                    
                </param>
                <param>
                    tokenBytes the byte array containing the token                    
                </param>
                <param>
                    tokenOffset the offset where the token begins                    
                </param>
                <param>
                    tokenLen the length of the token                    
                </param>
                <param>
                    prop the MessageProp structure in which the properties of the
                      token should be stored.                    
                </param>
                <throws>
                    GSSException if there is a problem parsing the token                    
                </throws>
            </javadoc>
            <method name="MessageToken_v2" type="constructor" line="108">
                <params>
                    <param name="tokenId" type="int"/>
                    <param name="context" type="Krb5Context"/>
                    <param name="tokenBytes" type="byte[]"/>
                    <param name="tokenOffset" type="int"/>
                    <param name="tokenLen" type="int"/>
                    <param name="prop" type="MessageProp"/>
                </params>
            </method>
            <javadoc line="111">
                Constructs a MessageToken from an InputStream. Bytes will be read on
                  demand and the thread might block if there are not enough bytes to
                  complete the token. Please note there is no accurate way to find out
                  the size of a token, but we try our best to make sure there is
                  enough bytes to construct one.                
                <param>
                    tokenId the token id that should be contained in this token as
                      it is read.                    
                </param>
                <param>
                    context the Kerberos context associated with this token                    
                </param>
                <param>
                    is the InputStream from which to read                    
                </param>
                <param>
                    prop the MessageProp structure in which the properties of the
                      token should be stored.                    
                </param>
                <throws>
                    GSSException if there is a problem reading from the
                      InputStream or parsing the token                    
                </throws>
            </javadoc>
            <method name="MessageToken_v2" type="constructor" line="126">
                <params>
                    <param name="tokenId" type="int"/>
                    <param name="context" type="Krb5Context"/>
                    <param name="is" type="InputStream"/>
                    <param name="prop" type="MessageProp"/>
                </params>
                <scope line="128">
                    <scope line="129"/>
                    <scope line="133"/>
                    <scope line="136"/>
                    <declaration name="minSize" type="int" line="139"/>
                    <scope line="140"/>
                    <scope line="143"/>
                    <scope line="146"/>
                    <scope line="151">
                        <scope line="153"/>
                        <scope line="157">
                            <declaration name="tmp" type="byte[]" line="158"/>
                            <declaration name="more" type="int" line="160"/>
                        </scope>
                    </scope>
                    <scope line="166"/>
                    <scope line="169">
                        <declaration name="chkLen" type="int" line="170"/>
                        <scope line="173">
                            <scope line="174"/>
                        </scope>
                    </scope>
                </scope>
                <scope line="180"/>
            </method>
            <javadoc line="184">
                Used to obtain the token id that was contained in this token.                
                <return>
                    the token id in the token                    
                </return>
            </javadoc>
            <method name="getTokenId" type="int" line="188"/>
            <javadoc line="191">
                Used to obtain the key_usage type for this token.                
                <return>
                    the key_usage for the token                    
                </return>
            </javadoc>
            <method name="getKeyUsage" type="int" line="195"/>
            <javadoc line="198">
                Used to determine if this token contains any encrypted data.                
                <return>
                    true if it contains any encrypted data, false if there is only
                      plaintext data or if there is no data.                    
                </return>
            </javadoc>
            <method name="getConfState" type="boolean" line="203"/>
            <javadoc line="206">
                Generates the checksum field and the sequence number field.                
                <param>
                    prop the MessageProp structure                    
                </param>
                <param>
                    data the application data to checksum                    
                </param>
                <param>
                    offset the offset where the data starts                    
                </param>
                <param>
                    len the length of the data                    
                </param>
                <throws>
                    GSSException if an error occurs in the checksum calculation or
                      sequence number calculation.                    
                </throws>
            </javadoc>
            <method name="genSignAndSeqNumber" type="void" line="215">
                <params>
                    <param name="prop" type="MessageProp"/>
                    <param name="data" type="byte[]"/>
                    <param name="offset" type="int"/>
                    <param name="len" type="int"/>
                </params>
                <declaration name="qop" type="int" line="216"/>
                <scope line="217"/>
                <scope line="221"/>
                <scope line="225"/>
                <scope line="228"/>
                <scope line="231"/>
                <scope line="234">
                    <declaration name="tok_header" type="byte[]" line="235"/>
                </scope>
            </method>
            <javadoc line="240">
                Verifies the validity of checksum field                
                <param>
                    data the application data                    
                </param>
                <param>
                    offset the offset where the data begins                    
                </param>
                <param>
                    len the length of the application data                    
                </param>
                <throws>
                    GSSException if an error occurs in the checksum calculation                    
                </throws>
            </javadoc>
            <method name="verifySign" type="boolean" line="247">
                <params>
                    <param name="data" type="byte[]"/>
                    <param name="offset" type="int"/>
                    <param name="len" type="int"/>
                </params>
                <declaration name="myChecksum" type="byte[]" line="248"/>
                <scope line="249"/>
            </method>
            <javadoc line="254">
                Rotate bytes as per the &quot;RRC&quot; (Right Rotation Count) received.
                  Our implementation does not do any rotates when sending, only
                  when receiving, we rotate left as per the RRC count, to revert it.                
            </javadoc>
            <method name="rotate" type="void" line="259">
                <scope line="260">
                    <declaration name="newBytes" type="byte[]" line="262"/>
                </scope>
            </method>
            <method name="getSequenceNumber" type="int" line="268"/>
            <javadoc line="271">
                Computes the checksum based on the algorithm stored in the
                  tokenHeader.                
                <param>
                    data the application data                    
                </param>
                <param>
                    offset the offset where the data begins                    
                </param>
                <param>
                    len the length of the application data                    
                </param>
                <throws>
                    GSSException if an error occurs in the checksum calculation.                    
                </throws>
            </javadoc>
            <method name="getChecksum" type="byte[]" line="279">
                <params>
                    <param name="data" type="byte[]"/>
                    <param name="offset" type="int"/>
                    <param name="len" type="int"/>
                </params>
                <declaration name="tokenHeaderBytes" type="byte[]" line="280"/>
                <declaration name="conf_flag" type="int" line="281"/>
                <scope line="282"/>
            </method>
            <javadoc line="288">
                Constructs an empty MessageToken for the local context to send to
                  the peer. It also increments the local sequence number in the
                  Krb5Context instance it uses after obtaining the object lock for
                  it.                
                <param>
                    tokenId the token id that should be contained in this token                    
                </param>
                <param>
                    context the Kerberos context associated with this token                    
                </param>
            </javadoc>
            <method name="MessageToken_v2" type="constructor" line="296">
                <params>
                    <param name="tokenId" type="int"/>
                    <param name="context" type="Krb5Context"/>
                </params>
            </method>
            <method name="init" type="void" line="300">
                <params>
                    <param name="tokenId" type="int"/>
                    <param name="context" type="Krb5Context"/>
                </params>
            </method>
            <javadoc line="306">
                Encodes a MessageTokenHeader onto an OutputStream.                
                <param>
                    os the OutputStream to which this should be written                    
                </param>
                <throws>
                    IOException is an error occurs while writing to the OutputStream                    
                </throws>
            </javadoc>
            <method name="encodeHeader" type="void" line="311">
                <params>
                    <param name="os" type="OutputStream"/>
                </params>
            </method>
            <method name="encode" type="void" line="314"/>
            <javadoc line="314">
                Encodes a MessageToken_v2 onto an OutputStream.                
                <param>
                    os the OutputStream to which this should be written                    
                </param>
                <throws>
                    IOException is an error occurs while encoding the token                    
                </throws>
            </javadoc>
            <method name="getTokenHeader" type="byte[]" line="320"/>
            <class name="MessageTokenHeader" line="323">
                <javadoc line="323">
                    This inner class represents the initial portion of the message token.
                      It constitutes the first 16 bytes of the message token.                    
                </javadoc>
                <declaration name="tokenId" type="int" line="328"/>
                <declaration name="bytes" type="byte[]" line="329"/>
                <method name="MessageTokenHeader" type="constructor" line="330">
                    <params>
                        <param name="tokenId" type="int"/>
                        <param name="conf" type="boolean"/>
                        <param name="have_acceptor_subkey" type="boolean"/>
                    </params>
                    <declaration name="flags" type="int" line="334"/>
                    <scope line="338"/>
                    <scope line="344">
                        <scope line="345"/>
                    </scope>
                </method>
                <javadoc line="351">
                    Reads a MessageTokenHeader from an InputStream and sets the
                      appropriate confidentiality and quality of protection
                      values in a MessageProp structure.                    
                    <param>
                        is the InputStream to read from                        
                    </param>
                    <param>
                        prop the MessageProp to populate                        
                    </param>
                    <throws>
                        IOException is an error occurs while reading from the
                          InputStream                        
                    </throws>
                </javadoc>
                <method name="MessageTokenHeader" type="constructor" line="360">
                    <params>
                        <param name="is" type="InputStream"/>
                        <param name="prop" type="MessageProp"/>
                        <param name="tokId" type="int"/>
                    </params>
                    <scope line="363"/>
                    <declaration name="acceptor_flag" type="int" line="366"/>
                    <declaration name="flag" type="int" line="367"/>
                    <scope line="368"/>
                    <declaration name="conf_flag" type="int" line="371"/>
                    <scope line="372"/>
                    <scope line="375"/>
                    <scope line="378">
                        <scope line="379"/>
                    </scope>
                    <scope line="385">
                        <scope line="386">
                            <scope line="387"/>
                        </scope>
                    </scope>
                </method>
                <javadoc line="395">
                    Encodes this MessageTokenHeader onto an OutputStream                    
                    <param>
                        os the OutputStream to write to                        
                    </param>
                    <throws>
                        IOException is an error occurs while writing                        
                    </throws>
                </javadoc>
                <method name="encode" type="void" line="400">
                    <params>
                        <param name="os" type="OutputStream"/>
                    </params>
                </method>
                <javadoc line="403">
                    Returns the token id for the message token.                    
                    <return>
                        the token id                        
                    </return>
                    <see>
                        sun.security.jgss.krb5.Krb5Token#MIC_ID_v2                        
                    </see>
                    <see>
                        sun.security.jgss.krb5.Krb5Token#WRAP_ID_v2                        
                    </see>
                </javadoc>
                <method name="getTokenId" type="int" line="409"/>
                <javadoc line="412">
                    Returns the bytes of this header.                    
                    <return>
                        8 bytes that form this header                        
                    </return>
                </javadoc>
                <method name="getBytes" type="byte[]" line="416"/>
            </class>
        </class>
    </source>