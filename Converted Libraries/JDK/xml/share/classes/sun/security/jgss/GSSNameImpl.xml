<?xml version="1.0" encoding="UTF-8"?>
    <source package="sun.security.jgss">
        <import package="org.ietf.jgss"/>
        <import package="sun.security.jgss.spi"/>
        <import package="java.util.Set"/>
        <import package="java.util.HashMap"/>
        <import package="java.util.HashSet"/>
        <import package="java.util.Arrays"/>
        <import package="java.io.IOException"/>
        <import package="java.io.UnsupportedEncodingException"/>
        <import package="sun.security.util.ObjectIdentifier"/>
        <import package="sun.security.util.DerInputStream"/>
        <import package="sun.security.util.DerOutputStream"/>
        <class name="GSSNameImpl" line="40">
            <comment line="110">
                Store whatever the application passed in. We will use this to
                 get individual mechanisms to create name elements as and when
                 needed.
                 Store both the String and the byte[]. Leave I18N to the
                 mechanism by allowing it to extract bytes from the String!                
            </comment>
            <comment line="122">
                When we figure out what the printable name would be, we store
                 both the name and its type.                
            </comment>
            <implements interface="GSSName"/>
            <javadoc line="40">
                This is the implementation class for GSSName. Conceptually the
                  GSSName is a container with mechanism specific name elements. Each
                  name element is a representation of how that particular mechanism
                  would canonicalize this principal.
                  Generally a GSSName is created by an application when it supplies
                  a sequence of bytes and a nametype that helps each mechanism
                  decide how to interpret those bytes.
                  It is not necessary to create name elements for each available
                  mechanism at the time the application creates the GSSName. This
                  implementation does this lazily, as and when name elements for
                  mechanisms are required to be handed out. (Generally, other GSS
                  classes like GSSContext and GSSCredential request specific
                  elements depending on the mechanisms that they are dealing with.)
                  Assume that getting a mechanism to parse the applciation specified
                  bytes is an expensive call.
                  When a GSSName is canonicalized wrt some mechanism, it is supposed
                  to discard all elements of other mechanisms and retain only the
                  element for this mechanism. In GSS terminology this is called a
                  Mechanism Name or MN. This implementation tries to retain the
                  application provided bytes and name type just in case the MN is
                  asked to produce an element for a mechanism that is different.
                  When a GSSName is to be exported, the name element for the desired
                  mechanism is converted to a byte representation and written
                  out. It might happen that a name element for that mechanism cannot
                  be obtained. This happens when the mechanism is just not supported
                  in this GSS-API or when the mechanism is supported but bytes
                  corresponding to the nametypes that it understands are not
                  available in this GSSName.
                  This class is safe for sharing. Each retrieval of a name element
                  from getElement() might potentially add a new element to the
                  hashmap of elements, but getElement() is synchronized.                
                <author>
                    Mayank Upadhyay                    
                </author>
                <since>
                    1.4                    
                </since>
            </javadoc>
            <declaration name="oldHostbasedServiceName" type="Oid" line="84"/>
            <javadoc line="84">
                The old Oid used in RFC 2853. Now supported as
                  input parameters in:
                  1. The four overloaded GSSManager.createName() methods
                  2. GSSManager.getMechsForName(Oid)
                  Note that even if a GSSName is created with this old Oid,
                  its internal name type and getStringNameType() output are
                  always the new value.                
            </javadoc>
            <scope line="97">
                <declaration name="tmp" type="Oid" line="98"/>
                <scope line="99"/>
                <scope line="101"/>
            </scope>
            <declaration name="gssManager" type="GSSManagerImpl" line="107"/>
            <declaration name="appNameStr" type="String" line="117"/>
            <declaration name="appNameBytes" type="byte[]" line="118"/>
            <declaration name="appNameType" type="Oid" line="119"/>
            <declaration name="printableName" type="String" line="126"/>
            <declaration name="printableNameType" type="Oid" line="127"/>
            <declaration name="elements" type="HashMap&lt;Oid,GSSNameSpi&gt;" line="129"/>
            <declaration name="mechElement" type="GSSNameSpi" line="130"/>
            <method name="wrapElement" type="GSSNameImpl" line="133">
                <params>
                    <param name="gssManager" type="GSSManagerImpl"/>
                    <param name="mechElement" type="GSSNameSpi"/>
                </params>
            </method>
            <method name="GSSNameImpl" type="constructor" line="138">
                <params>
                    <param name="gssManager" type="GSSManagerImpl"/>
                    <param name="mechElement" type="GSSNameSpi"/>
                </params>
            </method>
            <method name="GSSNameImpl" type="constructor" line="150">
                <params>
                    <param name="gssManager" type="GSSManagerImpl"/>
                    <param name="appName" type="Object"/>
                    <param name="appNameType" type="Oid"/>
                </params>
            </method>
            <method name="GSSNameImpl" type="constructor" line="158">
                <params>
                    <param name="gssManager" type="GSSManagerImpl"/>
                    <param name="appName" type="Object"/>
                    <param name="appNameType" type="Oid"/>
                    <param name="mech" type="Oid"/>
                </params>
                <scope line="160"/>
                <scope line="167"/>
                <scope line="169"/>
            </method>
            <method name="init" type="void" line="177">
                <params>
                    <param name="gssManager" type="GSSManagerImpl"/>
                    <param name="appName" type="Object"/>
                    <param name="appNameType" type="Oid"/>
                    <param name="mech" type="Oid"/>
                </params>
                <comment line="185">
                    If appNameType is null, then the nametype for this printable
                     string is determined only by interrogating the
                     mechanism. Thus, defer the setting of printableName and
                     printableNameType till later.                    
                </comment>
                <comment line="203">
                    printableName will be null if appName was in a byte[] or if
                     appName was in a String but appNameType was null.                    
                </comment>
                <comment line="212">
                    At this point the GSSNameImpl has the following set:
                       appNameStr or appNameBytes
                       appNameType (could be null)
                       printableName
                       printableNameType
                       mechElement (which also exists in the hashmap of elements)                    
                </comment>
                <scope line="183">
                    <scope line="191"/>
                </scope>
                <scope line="195"/>
                <scope line="207"/>
            </method>
            <method name="importName" type="void" line="224">
                <params>
                    <param name="gssManager" type="GSSManagerImpl"/>
                    <param name="appName" type="Object"/>
                </params>
                <comment line="233">
                    Won&apos;t happen                    
                </comment>
                <declaration name="pos" type="int" line="226"/>
                <declaration name="bytes" type="byte[]" line="227"/>
                <scope line="229">
                    <scope line="230"/>
                    <scope line="232"/>
                </scope>
                <declaration name="oidLen" type="int" line="243"/>
                <declaration name="temp" type="ObjectIdentifier" line="245"/>
                <scope line="246">
                    <declaration name="din" type="DerInputStream" line="247"/>
                </scope>
                <scope line="250"/>
                <declaration name="oid" type="Oid" line="254"/>
                <declaration name="mechPortionLen" type="int" line="256"/>
                <declaration name="mechPortion" type="byte[]" line="260"/>
            </method>
            <method name="canonicalize" type="GSSName" line="266">
                <params>
                    <param name="mech" type="Oid"/>
                </params>
            </method>
            <javadoc line="272">
                This method may return false negatives. But if it says two
                  names are equals, then there is some mechanism that
                  authenticates them as the same principal.                
            </javadoc>
            <method name="equals" type="boolean" line="277">
                <params>
                    <param name="other" type="GSSName"/>
                </params>
                <comment line="289">
                    XXX Do a comparison of the appNameStrappNameBytes if
                     available. If that fails, then proceed with this test.                    
                </comment>
                <comment line="299">
                    XXX If they are not of the same mechanism type, convert both to
                     Kerberos since it is guaranteed to be present.                    
                </comment>
                <comment line="330">
                    Won&apos;t happen                    
                </comment>
                <declaration name="that" type="GSSNameImpl" line="294"/>
                <declaration name="myElement" type="GSSNameSpi" line="296"/>
                <declaration name="element" type="GSSNameSpi" line="297"/>
                <scope line="303"/>
                <scope line="305"/>
                <scope line="309"/>
                <scope line="314">
                    <scope line="315"/>
                    <declaration name="myBytes" type="byte[]" line="318"/>
                    <declaration name="bytes" type="byte[]" line="319"/>
                    <scope line="320"/>
                    <scope line="329"/>
                </scope>
            </method>
            <javadoc line="340">
                Returns a hashcode value for this GSSName.                
                <return>
                    a hashCode value                    
                </return>
            </javadoc>
            <method name="hashCode" type="int" line="345">
                <comment line="346">
                    XXX
                     In order to get this to work reliably and properly(!), obtain a
                     Kerberos name element for the name and then call hashCode on its
                     string representation. But this cannot be done if the nametype
                     is not one of those supported by the Kerberos provider and hence
                     this name cannot be imported by Kerberos. In that case return a
                     constant value!                    
                </comment>
            </method>
            <method name="equals" type="boolean" line="359">
                <params>
                    <param name="another" type="Object"/>
                </params>
                <comment line="362">
                    XXX This can lead to an infinite loop. Extract info                    
                </comment>
                <comment line="363">
                    and create a GSSNameImpl with it.                    
                </comment>
                <comment line="368">
                    Squelch it and return false                    
                </comment>
                <scope line="361"/>
                <scope line="367"/>
            </method>
            <javadoc line="374">
                Returns a flat name representation for this object. The name
                  format is defined in RFC 2743:
                  &lt;pre&gt;
                  Length           Name          Description
                  2               TOK_ID          Token Identifier
                  For exported name objects, this
                  must be hex 04 01.
                  2               MECH_OID_LEN    Length of the Mechanism OID
                  MECH_OID_LEN    MECH_OID        Mechanism OID, in DER
                  4               NAME_LEN        Length of name
                  NAME_LEN        NAME            Exported name; format defined in
                  applicable mechanism draft.
                  &lt;/pre&gt;
                  Note that it is not required to canonicalize a name before
                  calling export(). i.e., the name need not be an MN. If it is
                  not an MN, an implementation defined algorithm can be used for
                  choosing the mechanism which should export this name.                
                <return>
                    the flat name representation for this object                    
                </return>
                <exception>
                    GSSException with major codes NAME_NOT_MN, BAD_NAME,
                      BAD_NAME, FAILURE.                    
                </exception>
            </javadoc>
            <method name="export" type="byte[]" line="398">
                <comment line="401">
                                        
                </comment>
                <scope line="400"/>
                <declaration name="mechPortion" type="byte[]" line="405"/>
                <declaration name="oidBytes" type="byte[]" line="406"/>
                <declaration name="oid" type="ObjectIdentifier" line="407"/>
                <scope line="409"/>
                <scope line="412"/>
                <declaration name="dout" type="DerOutputStream" line="416"/>
                <scope line="417"/>
                <scope line="419"/>
                <declaration name="retVal" type="byte[]" line="426"/>
                <declaration name="pos" type="int" line="429"/>
            </method>
            <method name="toString" type="String" line="444"/>
            <method name="getStringNameType" type="Oid" line="449"/>
            <method name="isAnonymous" type="boolean" line="453">
                <scope line="454"/>
                <scope line="456"/>
            </method>
            <method name="isMN" type="boolean" line="461">
                <comment line="462">
                    Since always canonicalized for some mech                    
                </comment>
            </method>
            <method name="getElement" type="GSSNameSpi" line="466">
                <params>
                    <param name="mechOid" type="Oid"/>
                </params>
                <declaration name="retVal" type="GSSNameSpi" line="468"/>
                <scope line="470">
                    <scope line="471"/>
                    <scope line="474"/>
                </scope>
            </method>
            <method name="getElements" type="Set<GSSNameSpi>" line="483"/>
            <method name="getNameTypeStr" type="String" line="487">
                <params>
                    <param name="nameTypeOid" type="Oid"/>
                </params>
            </method>
        </class>
    </source>