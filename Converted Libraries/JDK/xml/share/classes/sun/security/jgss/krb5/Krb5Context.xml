<?xml version="1.0" encoding="UTF-8"?>
    <source package="sun.security.jgss.krb5">
        <import package="com.sun.security.jgss.InquireType"/>
        <import package="org.ietf.jgss"/>
        <import package="sun.misc.HexDumpEncoder"/>
        <import package="sun.security.jgss.GSSUtil"/>
        <import package="sun.security.jgss.GSSCaller"/>
        <import package="sun.security.jgss.spi"/>
        <import package="sun.security.jgss.TokenTracker"/>
        <import package="sun.security.krb5"/>
        <import package="java.io.InputStream"/>
        <import package="java.io.OutputStream"/>
        <import package="java.io.IOException"/>
        <import package="java.security.Provider"/>
        <import package="java.security.AccessController"/>
        <import package="java.security.AccessControlContext"/>
        <import package="java.security.Key"/>
        <import package="java.security.PrivilegedExceptionAction"/>
        <import package="java.security.PrivilegedActionException"/>
        <import package="javax.crypto.Cipher"/>
        <import package="javax.security.auth.Subject"/>
        <import package="javax.security.auth.kerberos"/>
        <class name="Krb5Context" line="49">
            <comment line="60">
                The different states that this context can be in.                
            </comment>
            <comment line="71">
                Optional features that the application can set and their default
                 values.                
            </comment>
            <comment line="90">
                Separate locks for the sequence numbers allow the application to
                 receive tokens at the same time that it is sending tokens. Note
                 that the application must synchronize the generation and
                 transmission of tokens such that tokens are processed in the same
                 order that they are generated. This is important when sequence
                 checking of per-message tokens is enabled.                
            </comment>
            <comment line="110">
                Set only on acceptor side                
            </comment>
            <comment line="112">
                                
            </comment>
            <comment line="115">
                XXX See if the required info from these can be extracted and
                 stored elsewhere                
            </comment>
            <comment line="176">
                Methods that may be invoked by the GSS framework in response
                 to an application request for settinggetting these
                 properties.
                
                 These can only be called on the initiator side.
                
                 Notice that an application can only request these
                 properties. The mechanism may or may not support them. The
                 application must make getXXX calls after context establishment
                 to see if the mechanism implementations on both sides support
                 these features. requestAnonymity is an exception where the
                 application will want to call getAnonymityState prior to sending any
                 GSS token during context establishment.
                
                 Also note that the requests can only be placed before context
                 establishment starts. i.e. when state is STATE_NEW                
            </comment>
            <comment line="319">
                Anonymity is a little different in that after an application
                 requests anonymity it will want to know whether the mechanism
                 can support it or not, prior to sending any tokens across for
                 context establishment. Since this is from the initiator&apos;s
                 perspective, it essentially requests that the initiator be
                 anonymous.                
            </comment>
            <comment line="333">
                RFC 2853 actually calls for this to be called after context
                 establishment to get the right answer, but that is
                 incorrect. The application may not want to send over any
                 tokens if anonymity is not available.                
            </comment>
            <comment line="341">
                Package private methods invoked by other Krb5 plugin classes.                
            </comment>
            <comment line="406">
                While the application can only request the following features,
                 other classes in the package can call the actual set methods
                 for them. They are called as context establishment tokens are
                 received on an acceptor side and the context feature list that
                 the initiator wants becomes known.                
            </comment>
            <comment line="414">
                This method is also called by InitialToken.OverloadedChecksum if the
                 TGT is not forwardable and the user requested delegation.                
            </comment>
            <comment line="826">
                Per-message calls depend on the sequence number. The sequence number
                 synchronization is at a finer granularity because wrap and getMIC
                 care about the local sequence number (mySeqNumber) where are unwrap
                 and verifyMIC care about the remote sequence number (peerSeqNumber).                
            </comment>
            <comment line="1120">
                Checksum calculation requires a byte[]. Hence might as well pass
                 a byte[] into the MicToken constructor. However, writing the
                 token can be optimized for cases where the application passed in
                 an OutputStream.                
            </comment>
            <comment line="1370">
                Helpers for inquireSecContext                
            </comment>
            <implements interface="GSSContextSpi"/>
            <javadoc line="49">
                Implements the mechanism specific context class for the Kerberos v5
                  GSS-API mechanism.                
                <author>
                    Mayank Upadhyay                    
                </author>
                <author>
                    Ram Marti                    
                </author>
                <since>
                    1.4                    
                </since>
            </javadoc>
            <declaration name="STATE_NEW" type="int" line="63"/>
            <declaration name="STATE_IN_PROCESS" type="int" line="64"/>
            <declaration name="STATE_DONE" type="int" line="65"/>
            <declaration name="STATE_DELETED" type="int" line="66"/>
            <declaration name="state" type="int" line="68"/>
            <declaration name="credDelegState" type="boolean" line="75"/>
            <declaration name="mutualAuthState" type="boolean" line="76"/>
            <declaration name="replayDetState" type="boolean" line="77"/>
            <declaration name="sequenceDetState" type="boolean" line="78"/>
            <declaration name="confState" type="boolean" line="79"/>
            <declaration name="integState" type="boolean" line="80"/>
            <declaration name="delegPolicyState" type="boolean" line="81"/>
            <declaration name="mySeqNumber" type="int" line="83"/>
            <declaration name="peerSeqNumber" type="int" line="84"/>
            <declaration name="peerTokenTracker" type="TokenTracker" line="85"/>
            <declaration name="cipherHelper" type="CipherHelper" line="87"/>
            <declaration name="mySeqNumberLock" type="Object" line="98"/>
            <declaration name="peerSeqNumberLock" type="Object" line="99"/>
            <declaration name="key" type="EncryptionKey" line="101"/>
            <declaration name="myName" type="Krb5NameElement" line="102"/>
            <declaration name="peerName" type="Krb5NameElement" line="103"/>
            <declaration name="lifetime" type="int" line="104"/>
            <declaration name="initiator" type="boolean" line="105"/>
            <declaration name="channelBinding" type="ChannelBinding" line="106"/>
            <declaration name="myCred" type="Krb5CredElement" line="108"/>
            <declaration name="delegatedCred" type="Krb5CredElement" line="109"/>
            <declaration name="desCipher" type="Cipher" line="112"/>
            <declaration name="serviceCreds" type="Credentials" line="116"/>
            <declaration name="apReq" type="KrbApReq" line="117"/>
            <declaration name="caller" type="GSSCaller" line="118"/>
            <declaration name="DEBUG" type="boolean" line="119"/>
            <javadoc line="121">
                Constructor for Krb5Context to be called on the context initiator&apos;s
                  side.                
            </javadoc>
            <method name="Krb5Context" type="constructor" line="127">
                <params>
                    <param name="caller" type="GSSCaller"/>
                    <param name="peerName" type="Krb5NameElement"/>
                    <param name="myCred" type="Krb5CredElement"/>
                    <param name="lifetime" type="int"/>
                </params>
            </method>
            <javadoc line="139">
                Constructor for Krb5Context to be called on the context acceptor&apos;s
                  side.                
            </javadoc>
            <method name="Krb5Context" type="constructor" line="144">
                <params>
                    <param name="caller" type="GSSCaller"/>
                    <param name="myCred" type="Krb5CredElement"/>
                </params>
            </method>
            <javadoc line="150">
                Constructor for Krb5Context to import a previously exported context.                
            </javadoc>
            <method name="Krb5Context" type="constructor" line="154">
                <params>
                    <param name="caller" type="GSSCaller"/>
                    <param name="interProcessToken" type="byte[]"/>
                </params>
            </method>
            <javadoc line="159">
                Method to determine if the context can be exported and then
                  re-imported.                
            </javadoc>
            <method name="isTransferable" type="boolean" line="163"/>
            <javadoc line="167">
                The lifetime remaining for this context.                
            </javadoc>
            <method name="getLifetime" type="int" line="170">
                <comment line="172">
                    XXX Return service ticket lifetime                    
                </comment>
            </method>
            <javadoc line="194">
                Requests the desired lifetime. Can only be used on the context
                  initiator&apos;s side.                
            </javadoc>
            <method name="requestLifetime" type="void" line="198">
                <params>
                    <param name="lifetime" type="int"/>
                </params>
            </method>
            <javadoc line="203">
                Requests that confidentiality be available.                
            </javadoc>
            <method name="requestConf" type="void" line="206">
                <params>
                    <param name="value" type="boolean"/>
                </params>
            </method>
            <javadoc line="211">
                Is confidentiality available?                
            </javadoc>
            <method name="getConfState" type="boolean" line="214"/>
            <javadoc line="218">
                Requests that integrity be available.                
            </javadoc>
            <method name="requestInteg" type="void" line="221">
                <params>
                    <param name="value" type="boolean"/>
                </params>
            </method>
            <javadoc line="226">
                Is integrity available?                
            </javadoc>
            <method name="getIntegState" type="boolean" line="229"/>
            <javadoc line="233">
                Requests that credential delegation be done during context
                  establishment.                
            </javadoc>
            <method name="requestCredDeleg" type="void" line="237">
                <params>
                    <param name="value" type="boolean"/>
                </params>
            </method>
            <javadoc line="242">
                Is credential delegation enabled?                
            </javadoc>
            <method name="getCredDelegState" type="boolean" line="245"/>
            <javadoc line="249">
                Requests that mutual authentication be done during context
                  establishment. Since this is fromm the client&apos;s perspective, it
                  essentially requests that the server be authenticated.                
            </javadoc>
            <method name="requestMutualAuth" type="void" line="254">
                <params>
                    <param name="value" type="boolean"/>
                </params>
                <scope line="255"/>
            </method>
            <javadoc line="260">
                Is mutual authentication enabled? Since this is from the client&apos;s
                  perspective, it essentially meas that the server is being
                  authenticated.                
            </javadoc>
            <method name="getMutualAuthState" type="boolean" line="265"/>
            <javadoc line="269">
                Requests that replay detection be done on the GSS wrap and MIC
                  tokens.                
            </javadoc>
            <method name="requestReplayDet" type="void" line="273">
                <params>
                    <param name="value" type="boolean"/>
                </params>
            </method>
            <javadoc line="278">
                Is replay detection enabled on the GSS wrap and MIC tokens?
                  We enable replay detection if sequence checking is enabled.                
            </javadoc>
            <method name="getReplayDetState" type="boolean" line="282"/>
            <javadoc line="286">
                Requests that sequence checking be done on the GSS wrap and MIC
                  tokens.                
            </javadoc>
            <method name="requestSequenceDet" type="void" line="290">
                <params>
                    <param name="value" type="boolean"/>
                </params>
            </method>
            <javadoc line="295">
                Is sequence checking enabled on the GSS Wrap and MIC tokens?
                  We enable sequence checking if replay detection is enabled.                
            </javadoc>
            <method name="getSequenceDetState" type="boolean" line="299"/>
            <javadoc line="303">
                Requests that the deleg policy be respected.                
            </javadoc>
            <method name="requestDelegPolicy" type="void" line="306">
                <params>
                    <param name="value" type="boolean"/>
                </params>
            </method>
            <javadoc line="311">
                Is deleg policy respected?                
            </javadoc>
            <method name="getDelegPolicyState" type="boolean" line="314"/>
            <method name="requestAnonymity" type="void" line="327">
                <params>
                    <param name="value" type="boolean"/>
                </params>
                <comment line="329">
                    Ignore silently. Application will check back with
                     getAnonymityState.                    
                </comment>
            </method>
            <method name="getAnonymityState" type="boolean" line="336"/>
            <javadoc line="344">
                Get the context specific DESCipher instance, invoked in
                  MessageToken.init()                
            </javadoc>
            <method name="getCipherHelper" type="CipherHelper" line="348">
                <params>
                    <param name="ckey" type="EncryptionKey"/>
                </params>
                <declaration name="cipherKey" type="EncryptionKey" line="349"/>
                <scope line="350"/>
            </method>
            <method name="incrementMySequenceNumber" type="int" line="357">
                <declaration name="retVal" type="int" line="358"/>
                <scope line="359"/>
            </method>
            <method name="resetMySequenceNumber" type="void" line="366">
                <params>
                    <param name="seqNumber" type="int"/>
                </params>
                <scope line="367"/>
                <scope line="371"/>
            </method>
            <method name="resetPeerSequenceNumber" type="void" line="376">
                <params>
                    <param name="seqNumber" type="int"/>
                </params>
                <scope line="377"/>
                <scope line="381"/>
            </method>
            <method name="setKey" type="void" line="387">
                <params>
                    <param name="key" type="EncryptionKey"/>
                </params>
                <comment line="390">
                    %%% to do: should clear old cipherHelper first                    
                </comment>
                <comment line="391">
                    Need to use new key                    
                </comment>
            </method>
            <method name="getKey" type="EncryptionKey" line="393"/>
            <javadoc line="397">
                Called on the acceptor side to store the delegated credentials
                  received in the AcceptSecContextToken.                
            </javadoc>
            <method name="setDelegCred" type="void" line="401">
                <params>
                    <param name="delegatedCred" type="Krb5CredElement"/>
                </params>
            </method>
            <method name="setCredDelegState" type="void" line="417">
                <params>
                    <param name="state" type="boolean"/>
                </params>
            </method>
            <method name="setMutualAuthState" type="void" line="421">
                <params>
                    <param name="state" type="boolean"/>
                </params>
            </method>
            <method name="setReplayDetState" type="void" line="425">
                <params>
                    <param name="state" type="boolean"/>
                </params>
            </method>
            <method name="setSequenceDetState" type="void" line="429">
                <params>
                    <param name="state" type="boolean"/>
                </params>
            </method>
            <method name="setConfState" type="void" line="433">
                <params>
                    <param name="state" type="boolean"/>
                </params>
            </method>
            <method name="setIntegState" type="void" line="437">
                <params>
                    <param name="state" type="boolean"/>
                </params>
            </method>
            <method name="setDelegPolicyState" type="void" line="441">
                <params>
                    <param name="state" type="boolean"/>
                </params>
            </method>
            <javadoc line="445">
                Sets the channel bindings to be used during context
                  establishment.                
            </javadoc>
            <method name="setChannelBinding" type="void" line="450">
                <params>
                    <param name="channelBinding" type="ChannelBinding"/>
                </params>
            </method>
            <method name="getChannelBinding" type="ChannelBinding" line="454"/>
            <javadoc line="458">
                Returns the mechanism oid.                
                <return>
                    the Oid of this context                    
                </return>
            </javadoc>
            <method name="getMech" type="Oid" line="463"/>
            <javadoc line="467">
                Returns the context initiator name.                
                <return>
                    initiator name                    
                </return>
                <exception>
                    GSSException                    
                </exception>
            </javadoc>
            <method name="getSrcName" type="GSSNameSpi" line="473"/>
            <javadoc line="477">
                Returns the context acceptor.                
                <return>
                    context acceptor(target) name                    
                </return>
                <exception>
                    GSSException                    
                </exception>
            </javadoc>
            <method name="getTargName" type="GSSNameSpi" line="483"/>
            <javadoc line="487">
                Returns the delegated credential for the context. This
                  is an optional feature of contexts which not all
                  mechanisms will support. A context can be requested to
                  support credential delegation by using the &lt;b&gt;CRED_DELEG&lt;/b&gt;.
                  This is only valid on the acceptor side of the context.                
                <return>
                    GSSCredentialSpi object for the delegated credential                    
                </return>
                <exception>
                    GSSException                    
                </exception>
                <see>
                    GSSContext#getDelegCredState                    
                </see>
            </javadoc>
            <method name="getDelegCred" type="GSSCredentialSpi" line="497"/>
            <javadoc line="505">
                Tests if this is the initiator side of the context.                
                <return>
                    boolean indicating if this is initiator (true)
                      or target (false)                    
                </return>
            </javadoc>
            <method name="isInitiator" type="boolean" line="511"/>
            <javadoc line="515">
                Tests if the context can be used for per-message service.
                  Context may allow the calls to the per-message service
                  functions before being fully established.                
                <return>
                    boolean indicating if per-message methods can
                      be called.                    
                </return>
            </javadoc>
            <method name="isProtReady" type="boolean" line="523"/>
            <javadoc line="527">
                Initiator context establishment call. This method may be
                  required to be called several times. A CONTINUE_NEEDED return
                  call indicates that more calls are needed after the next token
                  is received from the peer.                
                <param>
                    is contains the token received from the peer. On the
                      first call it will be ignored.                    
                </param>
                <return>
                    any token required to be sent to the peer
                      It is responsibility of the caller
                      to send the token to its peer for processing.                    
                </return>
                <exception>
                    GSSException                    
                </exception>
            </javadoc>
            <method name="initSecContext" type="byte[]" line="541">
                <params>
                    <param name="is" type="InputStream"/>
                    <param name="mechTokenSize" type="int"/>
                </params>
                <comment line="576">
                    If useSubjectCredsonly is true then
                     we check whether we already have the ticket
                     for this service in the Subject and reuse it                    
                </comment>
                <comment line="588">
                    get service ticket from caller&apos;s subject                    
                </comment>
                <comment line="592">
                    XXX to be cleaned
                     highly consider just calling:
                     Subject.getSubject
                     SubjectComber.find
                     instead of Krb5Util.getTicket                    
                </comment>
                <comment line="599">
                    since it&apos;s useSubjectCredsOnly here,
                     don&apos;t worry about the null                    
                </comment>
                <comment line="618">
                    convert Ticket to serviceCreds
                     XXX Should merge these two object types
                     avoid converting back and forth                    
                </comment>
                <comment line="625">
                    either we did not find the serviceCreds in the
                     Subject or useSubjectCreds is false                    
                </comment>
                <comment line="631">
                    Get Service ticket using the Kerberos protocols                    
                </comment>
                <comment line="645">
                    Store the service credentials as
                     javax.security.auth.kerberos.KerberosTicket in
                     the Subject. We could wait till the context is
                     succesfully established; however it is easier
                     to do here and there is no harm indoing it here.                    
                </comment>
                <comment line="662">
                    log it for debugging purpose                    
                </comment>
                <comment line="685">
                    No need to write anything;
                     just validate the incoming token                    
                </comment>
                <comment line="692">
                    XXX Use logging API?                    
                </comment>
                <declaration name="retVal" type="byte[]" line="543"/>
                <declaration name="token" type="InitialToken" line="544"/>
                <declaration name="errorCode" type="int" line="545"/>
                <scope line="546"/>
                <scope line="550"/>
                <scope line="556">
                    <scope line="557">
                        <scope line="562"/>
                        <scope line="565"/>
                        <declaration name="tgt" type="Credentials" line="570"/>
                        <declaration name="acc" type="AccessControlContext" line="581"/>
                        <scope line="584">
                            <declaration name="kerbTicket" type="KerberosTicket" line="585"/>
                            <scope line="586">
                                <anonymous_class line="589">
                                    <method name="run" type="KerberosTicket" line="590">
                                        <comment line="592">
                                            XXX to be cleaned
                                             highly consider just calling:
                                             Subject.getSubject
                                             SubjectComber.find
                                             instead of Krb5Util.getTicket                                            
                                        </comment>
                                        <comment line="599">
                                            since it&apos;s useSubjectCredsOnly here,
                                             don&apos;t worry about the null                                            
                                        </comment>
                                    </method>
                                </anonymous_class>
                            </scope>
                            <scope line="604">
                                <scope line="605"/>
                            </scope>
                            <scope line="610">
                                <scope line="611"/>
                            </scope>
                        </scope>
                        <scope line="623">
                            <scope line="626"/>
                            <scope line="634">
                                <anonymous_class line="637">
                                    <method name="run" type="Subject" line="638"/>
                                </anonymous_class>
                                <declaration name="subject" type="Subject" line="635"/>
                                <scope line="643">
                                    <declaration name="kt" type="KerberosTicket" line="651"/>
                                    <anonymous_class line="654">
                                        <method name="run" type="Void" line="655"/>
                                    </anonymous_class>
                                </scope>
                                <scope line="660">
                                    <scope line="662"/>
                                </scope>
                            </scope>
                        </scope>
                        <scope line="676"/>
                        <scope line="679"/>
                    </scope>
                    <scope line="683"/>
                    <scope line="690">
                        <scope line="692"/>
                    </scope>
                </scope>
                <scope line="696">
                    <scope line="697"/>
                    <declaration name="gssException" type="GSSException" line="700"/>
                </scope>
                <scope line="704">
                    <declaration name="gssException" type="GSSException" line="705"/>
                </scope>
            </method>
            <method name="isEstablished" type="boolean" line="713"/>
            <javadoc line="717">
                Acceptor&apos;s context establishment call. This method may be
                  required to be called several times. A CONTINUE_NEEDED return
                  call indicates that more calls are needed after the next token
                  is received from the peer.                
                <param>
                    is contains the token received from the peer.                    
                </param>
                <return>
                    any token required to be sent to the peer
                      It is responsibility of the caller
                      to send the token to its peer for processing.                    
                </return>
                <exception>
                    GSSException                    
                </exception>
            </javadoc>
            <method name="acceptSecContext" type="byte[]" line="730">
                <params>
                    <param name="is" type="InputStream"/>
                    <param name="mechTokenSize" type="int"/>
                </params>
                <comment line="773">
                    XXX Use logging API?                    
                </comment>
                <declaration name="retVal" type="byte[]" line="732"/>
                <scope line="734"/>
                <scope line="739"/>
                <scope line="744">
                    <scope line="745">
                        <scope line="747"/>
                        <scope line="749"/>
                        <declaration name="secretKeys" type="EncryptionKey[]" line="758"/>
                        <declaration name="token" type="InitSecContextToken" line="761"/>
                        <declaration name="clientName" type="PrincipalName" line="763"/>
                        <scope line="765"/>
                    </scope>
                    <scope line="771">
                        <scope line="773"/>
                    </scope>
                </scope>
                <scope line="777">
                    <declaration name="gssException" type="GSSException" line="778"/>
                </scope>
                <scope line="782">
                    <scope line="783"/>
                    <declaration name="gssException" type="GSSException" line="786"/>
                </scope>
            </method>
            <javadoc line="797">
                Queries the context for largest data size to accomodate
                  the specified protection and be &lt;= maxTokSize.                
                <param>
                    qop the quality of protection that the context will be
                      asked to provide.                    
                </param>
                <param>
                    confReq a flag indicating whether confidentiality will be
                      requested or not                    
                </param>
                <param>
                    outputSize the maximum size of the output token                    
                </param>
                <return>
                    the maximum size for the input message that can be
                      provided to the wrap() method in order to guarantee that these
                      requirements are met.                    
                </return>
                <throws>
                    GSSException                    
                </throws>
            </javadoc>
            <method name="getWrapSizeLimit" type="int" line="812">
                <params>
                    <param name="qop" type="int"/>
                    <param name="confReq" type="boolean"/>
                    <param name="maxTokSize" type="int"/>
                </params>
                <declaration name="retVal" type="int" line="814"/>
                <scope line="815"/>
                <scope line="818"/>
            </method>
            <method name="wrap" type="byte[]" line="833">
                <params>
                    <param name="inBuf" type="byte"/>
                    <param name="offset" type="int"/>
                    <param name="len" type="int"/>
                    <param name="msgProp" type="MessageProp"/>
                </params>
                <scope line="834"/>
                <declaration name="encToken" type="byte[]" line="844"/>
                <scope line="845">
                    <scope line="846">
                        <declaration name="token" type="WrapToken" line="847"/>
                    </scope>
                    <scope line="850">
                        <declaration name="token" type="WrapToken_v2" line="851"/>
                    </scope>
                    <scope line="855"/>
                </scope>
                <scope line="861">
                    <declaration name="gssException" type="GSSException" line="863"/>
                </scope>
            </method>
            <method name="wrap" type="int" line="872">
                <params>
                    <param name="inBuf" type="byte"/>
                    <param name="inOffset" type="int"/>
                    <param name="len" type="int"/>
                    <param name="outBuf" type="byte[]"/>
                    <param name="outOffset" type="int"/>
                    <param name="msgProp" type="MessageProp"/>
                </params>
                <declaration name="retVal" type="int" line="878"/>
                <scope line="879">
                    <scope line="880">
                        <declaration name="token" type="WrapToken" line="881"/>
                    </scope>
                    <scope line="884">
                        <declaration name="token" type="WrapToken_v2" line="885"/>
                    </scope>
                    <scope line="889"/>
                </scope>
                <scope line="895">
                    <declaration name="gssException" type="GSSException" line="897"/>
                </scope>
            </method>
            <method name="wrap" type="void" line="906">
                <params>
                    <param name="inBuf" type="byte"/>
                    <param name="offset" type="int"/>
                    <param name="len" type="int"/>
                    <param name="os" type="OutputStream"/>
                    <param name="msgProp" type="MessageProp"/>
                </params>
                <declaration name="encToken" type="byte[]" line="912"/>
                <scope line="913">
                    <scope line="914">
                        <declaration name="token" type="WrapToken" line="915"/>
                        <scope line="918"/>
                    </scope>
                    <scope line="921">
                        <declaration name="token" type="WrapToken_v2" line="922"/>
                        <scope line="925"/>
                    </scope>
                </scope>
                <scope line="929">
                    <declaration name="gssException" type="GSSException" line="930"/>
                </scope>
                <scope line="936"/>
            </method>
            <method name="wrap" type="void" line="944">
                <params>
                    <param name="is" type="InputStream"/>
                    <param name="os" type="OutputStream"/>
                    <param name="msgProp" type="MessageProp"/>
                </params>
                <declaration name="data" type="byte[]" line="946"/>
                <scope line="947"/>
                <scope line="950">
                    <declaration name="gssException" type="GSSException" line="951"/>
                </scope>
            </method>
            <method name="unwrap" type="byte[]" line="961">
                <params>
                    <param name="inBuf" type="byte"/>
                    <param name="offset" type="int"/>
                    <param name="len" type="int"/>
                    <param name="msgProp" type="MessageProp"/>
                </params>
                <scope line="963"/>
                <scope line="969"/>
                <declaration name="data" type="byte[]" line="974"/>
                <scope line="975">
                    <declaration name="token" type="WrapToken" line="976"/>
                </scope>
                <scope line="980">
                    <declaration name="token" type="WrapToken_v2" line="981"/>
                </scope>
                <scope line="987"/>
            </method>
            <method name="unwrap" type="int" line="998">
                <params>
                    <param name="inBuf" type="byte"/>
                    <param name="inOffset" type="int"/>
                    <param name="len" type="int"/>
                    <param name="outBuf" type="byte[]"/>
                    <param name="outOffset" type="int"/>
                    <param name="msgProp" type="MessageProp"/>
                </params>
                <scope line="1004">
                    <declaration name="token" type="WrapToken" line="1005"/>
                </scope>
                <scope line="1009">
                    <declaration name="token" type="WrapToken_v2" line="1010"/>
                </scope>
            </method>
            <method name="unwrap" type="int" line="1020">
                <params>
                    <param name="is" type="InputStream"/>
                    <param name="outBuf" type="byte[]"/>
                    <param name="outOffset" type="int"/>
                    <param name="msgProp" type="MessageProp"/>
                </params>
                <declaration name="len" type="int" line="1026"/>
                <scope line="1027">
                    <declaration name="token" type="WrapToken" line="1028"/>
                </scope>
                <scope line="1031">
                    <declaration name="token" type="WrapToken_v2" line="1032"/>
                </scope>
            </method>
            <method name="unwrap" type="void" line="1041">
                <params>
                    <param name="is" type="InputStream"/>
                    <param name="os" type="OutputStream"/>
                    <param name="msgProp" type="MessageProp"/>
                </params>
                <declaration name="data" type="byte[]" line="1047"/>
                <scope line="1048">
                    <declaration name="token" type="WrapToken" line="1049"/>
                </scope>
                <scope line="1052">
                    <declaration name="token" type="WrapToken_v2" line="1053"/>
                </scope>
                <scope line="1058"/>
                <scope line="1060">
                    <declaration name="gssException" type="GSSException" line="1061"/>
                </scope>
            </method>
            <method name="getMIC" type="byte[]" line="1070">
                <params>
                    <param name="inMsg" type="byte[]"/>
                    <param name="offset" type="int"/>
                    <param name="len" type="int"/>
                    <param name="msgProp" type="MessageProp"/>
                </params>
                <declaration name="micToken" type="byte[]" line="1072"/>
                <scope line="1073">
                    <scope line="1074">
                        <declaration name="token" type="MicToken" line="1075"/>
                    </scope>
                    <scope line="1078">
                        <declaration name="token" type="MicToken_v2" line="1079"/>
                    </scope>
                </scope>
                <scope line="1084">
                    <declaration name="gssException" type="GSSException" line="1086"/>
                </scope>
            </method>
            <method name="getMIC" type="int" line="1096">
                <params>
                    <param name="inMsg" type="byte[]"/>
                    <param name="offset" type="int"/>
                    <param name="len" type="int"/>
                    <param name="outBuf" type="byte[]"/>
                    <param name="outOffset" type="int"/>
                    <param name="msgProp" type="MessageProp"/>
                </params>
                <declaration name="retVal" type="int" line="1098"/>
                <scope line="1099">
                    <scope line="1100">
                        <declaration name="token" type="MicToken" line="1101"/>
                    </scope>
                    <scope line="1104">
                        <declaration name="token" type="MicToken_v2" line="1105"/>
                    </scope>
                </scope>
                <scope line="1110">
                    <declaration name="gssException" type="GSSException" line="1112"/>
                </scope>
            </method>
            <method name="getMIC" type="void" line="1128">
                <params>
                    <param name="inMsg" type="byte[]"/>
                    <param name="offset" type="int"/>
                    <param name="len" type="int"/>
                    <param name="os" type="OutputStream"/>
                    <param name="msgProp" type="MessageProp"/>
                </params>
                <scope line="1130">
                    <scope line="1131">
                        <declaration name="token" type="MicToken" line="1132"/>
                    </scope>
                    <scope line="1135">
                        <declaration name="token" type="MicToken_v2" line="1136"/>
                    </scope>
                </scope>
                <scope line="1140">
                    <declaration name="gssException" type="GSSException" line="1141"/>
                </scope>
            </method>
            <method name="getMIC" type="void" line="1149">
                <params>
                    <param name="is" type="InputStream"/>
                    <param name="os" type="OutputStream"/>
                    <param name="msgProp" type="MessageProp"/>
                </params>
                <declaration name="data" type="byte[]" line="1150"/>
                <scope line="1151"/>
                <scope line="1154">
                    <declaration name="gssException" type="GSSException" line="1155"/>
                </scope>
            </method>
            <method name="verifyMIC" type="void" line="1166">
                <params>
                    <param name="inTok" type="byte[]"/>
                    <param name="tokOffset" type="int"/>
                    <param name="tokLen" type="int"/>
                    <param name="inMsg" type="byte[]"/>
                    <param name="msgOffset" type="int"/>
                    <param name="msgLen" type="int"/>
                    <param name="msgProp" type="MessageProp"/>
                </params>
                <scope line="1168">
                    <declaration name="token" type="MicToken" line="1169"/>
                </scope>
                <scope line="1173">
                    <declaration name="token" type="MicToken_v2" line="1174"/>
                </scope>
            </method>
            <method name="verifyMIC" type="void" line="1184">
                <params>
                    <param name="is" type="InputStream"/>
                    <param name="inMsg" type="byte[]"/>
                    <param name="msgOffset" type="int"/>
                    <param name="msgLen" type="int"/>
                    <param name="msgProp" type="MessageProp"/>
                </params>
                <scope line="1186">
                    <declaration name="token" type="MicToken" line="1187"/>
                </scope>
                <scope line="1190">
                    <declaration name="token" type="MicToken_v2" line="1191"/>
                </scope>
            </method>
            <method name="verifyMIC" type="void" line="1198">
                <params>
                    <param name="is" type="InputStream"/>
                    <param name="msgStr" type="InputStream"/>
                    <param name="mProp" type="MessageProp"/>
                </params>
                <declaration name="msg" type="byte[]" line="1199"/>
                <scope line="1200"/>
                <scope line="1203">
                    <declaration name="gssException" type="GSSException" line="1204"/>
                </scope>
            </method>
            <javadoc line="1212">
                Produces a token representing this context. After this call
                  the context will no longer be usable until an import is
                  performed on the returned token.                
                <param>
                    os the output token will be written to this stream                    
                </param>
                <exception>
                    GSSException                    
                </exception>
            </javadoc>
            <method name="export" type="byte[]" line="1220"/>
            <javadoc line="1225">
                Releases context resources and terminates the
                  context between 2 peer.                
                <exception>
                    GSSException with major codes NO_CONTEXT, FAILURE.                    
                </exception>
            </javadoc>
            <method name="dispose" type="void" line="1232"/>
            <method name="getProvider" type="Provider" line="1237"/>
            <javadoc line="1241">
                Sets replay and sequencing information for a message token received
                  form the peer.                
            </javadoc>
            <method name="setSequencingAndReplayProps" type="void" line="1246">
                <params>
                    <param name="token" type="MessageToken"/>
                    <param name="prop" type="MessageProp"/>
                </params>
                <scope line="1247">
                    <declaration name="seqNum" type="int" line="1248"/>
                </scope>
            </method>
            <javadoc line="1253">
                Sets replay and sequencing information for a message token received
                  form the peer.                
            </javadoc>
            <method name="setSequencingAndReplayProps" type="void" line="1258">
                <params>
                    <param name="token" type="MessageToken_v2"/>
                    <param name="prop" type="MessageProp"/>
                </params>
                <scope line="1259">
                    <declaration name="seqNum" type="int" line="1260"/>
                </scope>
            </method>
            <method name="checkPermission" type="void" line="1265">
                <params>
                    <param name="principal" type="String"/>
                    <param name="action" type="String"/>
                </params>
                <declaration name="sm" type="SecurityManager" line="1266"/>
                <scope line="1267">
                    <declaration name="perm" type="ServicePermission" line="1268"/>
                </scope>
            </method>
            <method name="getHexBytes" type="String" line="1274">
                <params>
                    <param name="bytes" type="byte[]"/>
                    <param name="pos" type="int"/>
                    <param name="len" type="int"/>
                </params>
                <declaration name="sb" type="StringBuffer" line="1276"/>
                <scope line="1277">
                    <declaration name="b1" type="int" line="1279"/>
                    <declaration name="b2" type="int" line="1280"/>
                </scope>
            </method>
            <method name="printState" type="String" line="1289">
                <params>
                    <param name="state" type="int"/>
                </params>
            </method>
            <method name="getCaller" type="GSSCaller" line="1304">
                <comment line="1306">
                    Currently used by InitialToken only                    
                </comment>
            </method>
            <class name="KerberosSessionKey" line="1309">
                <implements interface="Key"/>
                <javadoc line="1309">
                    The session key returned by inquireSecContext(KRB5_INQ_SSPI_SESSION_KEY)                    
                </javadoc>
                <declaration name="key" type="EncryptionKey" line="1313"/>
                <method name="KerberosSessionKey" type="constructor" line="1315">
                    <params>
                        <param name="key" type="EncryptionKey"/>
                    </params>
                </method>
                <method name="getAlgorithm" type="String" line="1320"/>
                <method name="getFormat" type="String" line="1325"/>
                <method name="getEncoded" type="byte[]" line="1330"/>
                <method name="toString" type="String" line="1335"/>
            </class>
            <javadoc line="1341">
                Return the mechanism-specific attribute associated with {@code type}.                
            </javadoc>
            <method name="inquireSecContext" type="Object" line="1345">
                <params>
                    <param name="type" type="InquireType"/>
                </params>
                <scope line="1346"/>
                <scope line="1356"/>
                <scope line="1359"/>
            </method>
            <declaration name="tktFlags" type="boolean[]" line="1370"/>
            <declaration name="authTime" type="String" line="1371"/>
            <declaration name="authzData" type="com.sun.security.jgss.AuthorizationDataEntry[]" line="1372"/>
            <method name="setTktFlags" type="void" line="1374">
                <params>
                    <param name="tktFlags" type="boolean[]"/>
                </params>
            </method>
            <method name="setAuthTime" type="void" line="1378">
                <params>
                    <param name="authTime" type="String"/>
                </params>
            </method>
            <method name="setAuthzData" type="void" line="1382">
                <params>
                    <param name="authzData" type="com.sun.security.jgss.AuthorizationDataEntry[]"/>
                </params>
            </method>
        </class>
    </source>