<?xml version="1.0" encoding="UTF-8"?>
    <source package="sun.security.jgss.krb5">
        <import package="org.ietf.jgss"/>
        <import package="sun.security.jgss"/>
        <import package="java.io.InputStream"/>
        <import package="java.io.OutputStream"/>
        <import package="java.io.IOException"/>
        <import package="java.io.ByteArrayOutputStream"/>
        <import package="sun.security.krb5.Confounder"/>
        <class name="WrapToken" line="36">
            <extends class="MessageToken"/>
            <comment line="56">
                The padding used with a WrapToken. All data is padded to the
                 next multiple of 8 bytes, even if its length is already
                 multiple of 8.
                 Use this table as a quick way to obtain padding bytes by
                 indexing it with the number of padding bytes required.                
            </comment>
            <comment line="75">
                A token may come in either in an InputStream or as a
                 byte[]. Store a reference to it in either case and process
                 it&apos;s data only later when getData() is called and
                 decryptioncopying is needed to be done. Note that JCE can
                 decrypt both from a byte[] and from an InputStream.                
            </comment>
            <comment line="88">
                Application data may come from an InputStream or from a
                 byte[]. However, it will always be stored and processed as a
                 byte[] since
                 (a) the MessageDigest class only accepts a byte[] as input and
                 (b) It allows writing to an OuputStream via a CipherOutputStream.                
            </comment>
            <comment line="99">
                the len of the token data: (confounder || data || padding)                
            </comment>
            <comment line="102">
                Accessed by CipherHelper                
            </comment>
            <comment line="525">
                This implementation is way too conservative. And it certainly                
            </comment>
            <comment line="526">
                doesn&apos;t return the maximum limit.                
            </comment>
            <javadoc line="36">
                This class represents a token emitted by the GSSContext.wrap()
                  call. It is a MessageToken except that it also contains plaintext
                  or encrypted data at the end. A wrapToken has certain other rules
                  that are peculiar to it and different from a MICToken, which is
                  another type of MessageToken. All data in a WrapToken is prepended
                  by a random counfounder of 8 bytes. All data in a WrapToken is
                  also padded with one to eight bytes where all bytes are equal in
                  value to the number of bytes being padded. Thus, all application
                  data is replaced by (confounder || data || padding).                
                <author>
                    Mayank Upadhyay                    
                </author>
            </javadoc>
            <declaration name="CONFOUNDER_SIZE" type="int" line="50"/>
            <javadoc line="50">
                The size of the random confounder used in a WrapToken.                
            </javadoc>
            <declaration name="pads" type="byte[][]" line="62"/>
            <declaration name="readTokenFromInputStream" type="boolean" line="81"/>
            <declaration name="is" type="InputStream" line="82"/>
            <declaration name="tokenBytes" type="byte[]" line="83"/>
            <declaration name="tokenOffset" type="int" line="84"/>
            <declaration name="tokenLen" type="int" line="85"/>
            <declaration name="dataBytes" type="byte[]" line="94"/>
            <declaration name="dataOffset" type="int" line="95"/>
            <declaration name="dataLen" type="int" line="96"/>
            <declaration name="dataSize" type="int" line="99"/>
            <declaration name="confounder" type="byte[]" line="102"/>
            <declaration name="padding" type="byte[]" line="103"/>
            <declaration name="privacy" type="boolean" line="105"/>
            <javadoc line="107">
                Constructs a WrapToken from token bytes obtained from the
                  peer.                
                <param>
                    context the mechanism context associated with this
                      token                    
                </param>
                <param>
                    tokenBytes the bytes of the token                    
                </param>
                <param>
                    tokenOffset the offset of the token                    
                </param>
                <param>
                    tokenLen the length of the token                    
                </param>
                <param>
                    prop the MessageProp into which characteristics of the
                      parsed token will be stored.                    
                </param>
                <throws>
                    GSSException if the token is defective                    
                </throws>
            </javadoc>
            <method name="WrapToken" type="constructor" line="121">
                <params>
                    <param name="context" type="Krb5Context"/>
                    <param name="tokenBytes" type="byte[]"/>
                    <param name="tokenOffset" type="int"/>
                    <param name="tokenLen" type="int"/>
                    <param name="prop" type="MessageProp"/>
                </params>
                <comment line="123">
                    Just parse the MessageToken part first                    
                </comment>
                <comment line="129">
                    Will need the token bytes again when extracting data                    
                </comment>
            </method>
            <javadoc line="138">
                Constructs a WrapToken from token bytes read on the fly from
                  an InputStream.                
                <param>
                    context the mechanism context associated with this
                      token                    
                </param>
                <param>
                    is the InputStream containing the token bytes                    
                </param>
                <param>
                    prop the MessageProp into which characteristics of the
                      parsed token will be stored.                    
                </param>
                <throws>
                    GSSException if the token is defective or if there is
                      a problem reading from the InputStream                    
                </throws>
            </javadoc>
            <method name="WrapToken" type="constructor" line="151">
                <params>
                    <param name="context" type="Krb5Context"/>
                    <param name="is" type="InputStream"/>
                    <param name="prop" type="MessageProp"/>
                </params>
                <comment line="153">
                    Just parse the MessageToken part first                    
                </comment>
                <comment line="156">
                    Will need the token bytes again when extracting data                    
                </comment>
                <comment line="159">
                    debug(&quot;WrapToken Cons: gssHeader.getMechTokenLength=&quot; +
                    getGSSHeader().getMechTokenLength());
                    debug(&quot;\n                token size=&quot;
                    + getTokenSize());                    
                </comment>
                <comment line="168">
                    debug(&quot;\n                dataSize=&quot; + dataSize);                    
                </comment>
                <comment line="169">
                    debug(&quot;\n&quot;);                    
                </comment>
            </method>
            <javadoc line="172">
                Obtains the application data that was transmitted in this
                  WrapToken.                
                <return>
                    a byte array containing the application data                    
                </return>
                <throws>
                    GSSException if an error occurs while decrypting any
                      cipher text and checking for validity                    
                </throws>
            </javadoc>
            <method name="getData" type="byte[]" line="179">
                <comment line="184">
                    Remove the confounder and the padding                    
                </comment>
                <declaration name="temp" type="byte[]" line="181"/>
                <declaration name="retVal" type="byte[]" line="185"/>
            </method>
            <javadoc line="192">
                Obtains the application data that was transmitted in this
                  WrapToken, writing it into an application provided output
                  array.                
                <param>
                    dataBuf the output buffer into which the data must be
                      written                    
                </param>
                <param>
                    dataBufOffset the offset at which to write the data                    
                </param>
                <return>
                    the size of the data written                    
                </return>
                <throws>
                    GSSException if an error occurs while decrypting any
                      cipher text and checking for validity                    
                </throws>
            </javadoc>
            <method name="getData" type="int" line="204">
                <params>
                    <param name="dataBuf" type="byte[]"/>
                    <param name="dataBufOffset" type="int"/>
                </params>
            </method>
            <javadoc line="214">
                Helper routine to obtain the application data transmitted in
                  this WrapToken. It is called if the WrapToken was constructed
                  with a byte array as input.                
                <param>
                    dataBuf the output buffer into which the data must be
                      written                    
                </param>
                <param>
                    dataBufOffset the offset at which to write the data                    
                </param>
                <throws>
                    GSSException if an error occurs while decrypting any
                      cipher text and checking for validity                    
                </throws>
            </javadoc>
            <method name="getDataFromBuffer" type="void" line="225">
                <params>
                    <param name="dataBuf" type="byte[]"/>
                    <param name="dataBufOffset" type="int"/>
                </params>
                <comment line="236">
                    debug(&quot;WrapToken cons: data is token is [&quot; +                    
                </comment>
                <comment line="237">
                    getHexBytes(tokenBytes, tokenOffset, tokenLen) + &quot;]\n&quot;);                    
                </comment>
                <comment line="241">
                    Do decryption if this token was privacy protected.                    
                </comment>
                <comment line="246">
                    debug(&quot;\t\tDecrypted data is [&quot; +
                    getHexBytes(confounder) + &quot; &quot; +
                    getHexBytes(dataBuf, dataBufOffset,
                    dataSize - CONFOUNDER_SIZE - padding.length) +
                    getHexBytes(padding) +
                    &quot;]\n&quot;);                    
                </comment>
                <comment line="257">
                    Token data is in cleartext                    
                </comment>
                <comment line="258">
                    debug(&quot;\t\tNo encryption was performed by peer.\n&quot;);                    
                </comment>
                <comment line="268">
                    debug(&quot;\t\tPadding applied was: &quot; + padSize + &quot;\n&quot;);                    
                </comment>
                <comment line="274">
                    byte[] debugbuf = new byte[dataSize - CONFOUNDER_SIZE - padSize];                    
                </comment>
                <comment line="275">
                    System.arraycopy(tokenBytes, dataPos + CONFOUNDER_SIZE,                    
                </comment>
                <comment line="276">
                    debugbuf, 0, debugbuf.length);                    
                </comment>
                <comment line="277">
                    debug(&quot;\t\tData is: &quot; + getHexBytes(debugbuf, debugbuf.length));                    
                </comment>
                <comment line="280">
                    Make sure sign and sequence number are not corrupt                    
                </comment>
                <declaration name="gssHeader" type="GSSHeader" line="227"/>
                <declaration name="dataPos" type="int" line="228"/>
                <scope line="243"/>
                <scope line="255">
                    <declaration name="padSize" type="int" line="261"/>
                </scope>
            </method>
            <javadoc line="293">
                Helper routine to obtain the application data transmitted in
                  this WrapToken. It is called if the WrapToken was constructed
                  with an Inputstream.                
                <param>
                    dataBuf the output buffer into which the data must be
                      written                    
                </param>
                <param>
                    dataBufOffset the offset at which to write the data                    
                </param>
                <throws>
                    GSSException if an error occurs while decrypting any
                      cipher text and checking for validity                    
                </throws>
            </javadoc>
            <method name="getDataFromStream" type="void" line="304">
                <params>
                    <param name="dataBuf" type="byte[]"/>
                    <param name="dataBufOffset" type="int"/>
                </params>
                <comment line="308">
                    Don&apos;t check the token length. Data will be read on demand from                    
                </comment>
                <comment line="309">
                    the InputStream.                    
                </comment>
                <comment line="311">
                    debug(&quot;WrapToken cons: data will be read from InputStream.\n&quot;);                    
                </comment>
                <comment line="317">
                    Do decryption if this token was privacy protected.                    
                </comment>
                <comment line="323">
                    debug(&quot;\t\tDecrypted data is [&quot; +                    
                </comment>
                <comment line="324">
                    getHexBytes(confounder) + &quot; &quot; +                    
                </comment>
                <comment line="325">
                    getHexBytes(dataBuf, dataBufOffset,                    
                </comment>
                <comment line="326">
                    dataSize - CONFOUNDER_SIZE - padding.length) +                    
                </comment>
                <comment line="327">
                    getHexBytes(padding) +                    
                </comment>
                <comment line="328">
                    &quot;]\n&quot;);                    
                </comment>
                <comment line="332">
                    Token data is in cleartext                    
                </comment>
                <comment line="333">
                    debug(&quot;\t\tNo encryption was performed by peer.\n&quot;);                    
                </comment>
                <comment line="340">
                    Data is always a multiple of 8 with this GSS Mech                    
                </comment>
                <comment line="341">
                    Copy all but last block as they are                    
                </comment>
                <comment line="355">
                    debug(&quot;\t\tPadding applied was: &quot; + padSize + &quot;\n&quot;);                    
                </comment>
                <comment line="366">
                    Make sure sign and sequence number are not corrupt                    
                </comment>
                <declaration name="gssHeader" type="GSSHeader" line="306"/>
                <scope line="315">
                    <scope line="319"/>
                    <scope line="330">
                        <scope line="336"/>
                        <scope line="339">
                            <declaration name="numBlocks" type="int" line="342"/>
                            <declaration name="offset" type="int" line="343"/>
                            <scope line="344"/>
                            <declaration name="finalBlock" type="byte[]" line="349"/>
                            <declaration name="padSize" type="int" line="352"/>
                        </scope>
                    </scope>
                </scope>
                <scope line="360"/>
            </method>
            <javadoc line="380">
                Helper routine to pick the right padding for a certain length
                  of application data. Every application message has some
                  padding between 1 and 8 bytes.                
                <param>
                    len the length of the application data                    
                </param>
                <return>
                    the padding to be applied                    
                </return>
            </javadoc>
            <method name="getPadding" type="byte[]" line="387">
                <params>
                    <param name="len" type="int"/>
                </params>
                <comment line="389">
                    For RC4-HMAC, all padding is rounded up to 1 byte.                    
                </comment>
                <comment line="390">
                    One byte is needed to say that there is 1 byte of padding.                    
                </comment>
                <declaration name="padSize" type="int" line="388"/>
                <scope line="391"/>
                <scope line="393"/>
            </method>
            <method name="WrapToken" type="constructor" line="402">
                <params>
                    <param name="context" type="Krb5Context"/>
                    <param name="prop" type="MessageProp"/>
                    <param name="dataBytes" type="byte[]"/>
                    <param name="dataOffset" type="int"/>
                    <param name="dataLen" type="int"/>
                </params>
                <comment line="414">
                    debug(&quot;\nWrapToken cons: data to wrap is [&quot; +
                    getHexBytes(confounder) + &quot; &quot; +
                    getHexBytes(dataBytes, dataOffset, dataLen) + &quot; &quot; +
                     padding is never null for Wrap
                    getHexBytes(padding) + &quot;]\n&quot;);                    
                </comment>
                <comment line="427">
                    If the application decides to ask for privacy when the context
                     did not negotiate for it, do not provide it. The peer might not
                     have support for it. The app will realize this with a call to
                     pop.getPrivacy() after wrap().                    
                </comment>
            </method>
            <method name="encode" type="void" line="439">
                <params>
                    <param name="os" type="OutputStream"/>
                </params>
                <comment line="443">
                    debug(&quot;Writing data: [&quot;);                    
                </comment>
                <comment line="446">
                    debug(getHexBytes(confounder, confounder.length));                    
                </comment>
                <comment line="449">
                    debug(&quot; &quot; + getHexBytes(dataBytes, dataOffset, dataLen));                    
                </comment>
                <comment line="452">
                    debug(&quot; &quot; + getHexBytes(padding, padding.length));                    
                </comment>
                <comment line="460">
                    debug(&quot;]\n&quot;);                    
                </comment>
                <scope line="444"/>
                <scope line="455"/>
            </method>
            <method name="encode" type="byte[]" line="463">
                <comment line="464">
                    XXX Fine tune this initial size                    
                </comment>
                <declaration name="bos" type="ByteArrayOutputStream" line="465"/>
            </method>
            <method name="encode" type="int" line="471">
                <params>
                    <param name="outToken" type="byte[]"/>
                    <param name="offset" type="int"/>
                </params>
                <comment line="473">
                    Token header is small                    
                </comment>
                <comment line="480">
                    debug(&quot;WrapToken.encode: Writing data: [&quot;);                    
                </comment>
                <comment line="483">
                    debug(getHexBytes(confounder, confounder.length));                    
                </comment>
                <comment line="488">
                    debug(&quot; &quot; + getHexBytes(dataBytes, dataOffset, dataLen));                    
                </comment>
                <comment line="493">
                    debug(&quot; &quot; + getHexBytes(padding, padding.length));                    
                </comment>
                <comment line="501">
                    debug(getHexBytes(outToken, offset, dataSize));                    
                </comment>
                <comment line="504">
                    debug(&quot;]\n&quot;);                    
                </comment>
                <comment line="506">
                    %%% assume that plaintext length == ciphertext len                    
                </comment>
                <declaration name="bos" type="ByteArrayOutputStream" line="474"/>
                <declaration name="header" type="byte[]" line="476"/>
                <scope line="481"/>
                <scope line="496"/>
            </method>
            <method name="getKrb5TokenSize" type="int" line="511"/>
            <method name="getSealAlg" type="int" line="515">
                <params>
                    <param name="conf" type="boolean"/>
                    <param name="qop" type="int"/>
                </params>
                <comment line="520">
                    ignore QOP                    
                </comment>
                <scope line="516"/>
            </method>
            <method name="getSizeLimit" type="int" line="527">
                <params>
                    <param name="qop" type="int"/>
                    <param name="confReq" type="boolean"/>
                    <param name="maxTokenSize" type="int"/>
                    <param name="ch" type="CipherHelper"/>
                </params>
                <comment line="529">
                                        
                </comment>
            </method>
        </class>
    </source>