<?xml version="1.0" encoding="UTF-8"?>
    <source package="sun.security.ec">
        <import package="java.io.IOException"/>
        <import package="java.math.BigInteger"/>
        <import package="java.security"/>
        <import package="java.security.spec"/>
        <import package="sun.security.util"/>
        <class name="ECParameters" line="36">
            <extends class="AlgorithmParametersSpi"/>
            <comment line="85">
                Used by SunPKCS11 and SunJSSE.                
            </comment>
            <comment line="102">
                Used by SunPKCS11 and SunJSSE.                
            </comment>
            <comment line="119">
                Copied from the SunPKCS11 code - should be moved to a common location.
                 trim leading (most significant) zeroes from the result                
            </comment>
            <comment line="134">
                Convert the given ECParameterSpec object to a NamedCurve object.
                 If params does not represent a known named curve, return null.
                 Used by SunPKCS11.                
            </comment>
            <comment line="176">
                Used by SunJSSE.                
            </comment>
            <comment line="182">
                Used by SunPKCS11.                
            </comment>
            <comment line="191">
                Used by SunPKCS11.                
            </comment>
            <comment line="244">
                private static final ObjectIdentifier fieldTypePrime =
                ObjectIdentifier.newInternal(new int[] {1, 2, 840, 10045, 1, 1});
                
                private static final ObjectIdentifier fieldTypeChar2 =
                ObjectIdentifier.newInternal(new int[] {1, 2, 840, 10045, 1, 2});
                
                private static ECField parseField(DerInputStream in) throws IOException {
                DerValue v = in.getDerValue();
                ObjectIdentifier oid = v.data.getOID();
                if (oid.equals(fieldTypePrime) == false) {
                throw new IOException(&quot;Only prime fields supported: &quot; + oid);
                }
                BigInteger fieldSize = v.data.getBigInteger();
                return new ECFieldFp(fieldSize);
                }
                
                private static EllipticCurve parseCurve(DerInputStream in, ECField field)
                throws IOException {
                DerValue v = in.getDerValue();
                byte[] ab = v.data.getOctetString();
                byte[] bb = v.data.getOctetString();
                return new EllipticCurve(field, new BigInteger(1, ab), new BigInteger(1, bb));
                }
                
                private static ECPoint parsePoint(DerInputStream in, EllipticCurve curve)
                throws IOException {
                byte[] data = in.getOctetString();
                return decodePoint(data, curve);
                }                
            </comment>
            <comment line="276">
                used by ECPublicKeyImpl and ECPrivateKeyImpl                
            </comment>
            <comment line="289">
                AlgorithmParameterSpi methods                
            </comment>
            <comment line="291">
                The parameters these AlgorithmParameters object represents.
                 Currently, it is always an instance of NamedCurve.                
            </comment>
            <javadoc line="36">
                This class implements encoding and decoding of Elliptic Curve parameters
                  as specified in RFC 3279.
                  However, only named curves are currently supported.
                  ASN.1 from RFC 3279 follows. Note that X9.62 (2005) has added some additional
                  options.
                  &lt;pre&gt;
                  EcpkParameters ::= CHOICE {
                  ecParameters  ECParameters,
                  namedCurve    OBJECT IDENTIFIER,
                  implicitlyCA  NULL }
                  ECParameters ::= SEQUENCE {
                  version   ECPVer,          -- version is always 1
                  fieldID   FieldID,         -- identifies the finite field over
                  -- which the curve is defined
                  curve     Curve,           -- coefficients a and b of the
                  -- elliptic curve
                  base      ECPoint,         -- specifies the base point P
                  -- on the elliptic curve
                  order     INTEGER,         -- the order n of the base point
                  cofactor  INTEGER OPTIONAL -- The integer h = #E(Fq)/n
                  }
                  ECPVer ::= INTEGER {ecpVer1(1)}
                  Curve ::= SEQUENCE {
                  a         FieldElement,
                  b         FieldElement,
                  seed      BIT STRING OPTIONAL }
                  FieldElement ::= OCTET STRING
                  ECPoint ::= OCTET STRING
                  &lt;/pre&gt;                
                <since>
                    1.6                    
                </since>
                <author>
                    Andreas Sterbenz                    
                </author>
            </javadoc>
            <method name="ECParameters" type="constructor" line="80">
                <comment line="82">
                    empty                    
                </comment>
            </method>
            <method name="decodePoint" type="ECPoint" line="86">
                <params>
                    <param name="data" type="byte[]"/>
                    <param name="curve" type="EllipticCurve"/>
                </params>
                <scope line="87"/>
                <declaration name="n" type="int" line="90"/>
                <scope line="91"/>
                <declaration name="xb" type="byte[]" line="94"/>
                <declaration name="yb" type="byte[]" line="95"/>
            </method>
            <method name="encodePoint" type="byte[]" line="102">
                <params>
                    <param name="point" type="ECPoint"/>
                    <param name="curve" type="EllipticCurve"/>
                </params>
                <comment line="104">
                    get field size in bytes (rounding up)                    
                </comment>
                <comment line="113">
                    uncompressed                    
                </comment>
                <declaration name="n" type="int" line="104"/>
                <declaration name="xb" type="byte[]" line="105"/>
                <declaration name="yb" type="byte[]" line="106"/>
                <scope line="107"/>
                <declaration name="b" type="byte[]" line="111"/>
            </method>
            <method name="trimZeroes" type="byte[]" line="120">
                <params>
                    <param name="b" type="byte[]"/>
                </params>
                <declaration name="i" type="int" line="121"/>
                <scope line="122"/>
                <scope line="125"/>
                <declaration name="t" type="byte[]" line="128"/>
            </method>
            <method name="getNamedCurve" type="NamedCurve" line="136">
                <params>
                    <param name="params" type="ECParameterSpec"/>
                </params>
                <comment line="141">
                    This is a hack to allow SunJSSE to work with 3rd party crypto
                     providers for ECC and not just SunPKCS11.
                     This can go away once we decide how to expose curve names in the
                     public API.
                     Note that it assumes that the 3rd party provider encodes named
                     curves using the short form, not explicitly. If it did that, then
                     the SunJSSE TLS ECC extensions are wrong, which could lead to
                     interoperability problems.                    
                </comment>
                <comment line="151">
                    ECParameterSpec does not define equals, so check all the
                     components ourselves.
                     Quick field size check first                    
                </comment>
                <comment line="169">
                    everything matches our named curve, return it                    
                </comment>
                <comment line="172">
                    no match found                    
                </comment>
                <scope line="137"/>
                <declaration name="fieldSize" type="int" line="148"/>
                <scope line="149">
                    <scope line="153"/>
                    <scope line="156"/>
                    <scope line="159"/>
                    <scope line="162"/>
                    <scope line="165"/>
                </scope>
            </method>
            <method name="getCurveName" type="String" line="176">
                <params>
                    <param name="params" type="ECParameterSpec"/>
                </params>
                <declaration name="curve" type="NamedCurve" line="177"/>
            </method>
            <method name="encodeParameters" type="byte[]" line="182">
                <params>
                    <param name="params" type="ECParameterSpec"/>
                </params>
                <declaration name="curve" type="NamedCurve" line="183"/>
                <scope line="184"/>
            </method>
            <method name="decodeParameters" type="ECParameterSpec" line="191">
                <params>
                    <param name="params" type="byte[]"/>
                </params>
                <comment line="205">
                    The code below is incomplete.
                     It is left as a starting point for a complete parsing implementation.                    
                </comment>
                <comment line="208">
                    if (encodedParams.tag != DerValue.tag_Sequence) {
                    throw new IOException(&quot;Unsupported EC parameters, tag: &quot; + encodedParams.tag);
                    }
                    
                    encodedParams.data.reset();
                    
                    DerInputStream in = encodedParams.data;
                    
                    int version = in.getInteger();
                    if (version != 1) {
                    throw new IOException(&quot;Unsupported EC parameters version: &quot; + version);
                    }
                    ECField field = parseField(in);
                    EllipticCurve curve = parseCurve(in, field);
                    ECPoint point = parsePoint(in, curve);
                    
                    BigInteger order = in.getBigInteger();
                    int cofactor = 0;
                    
                    if (in.available() != 0) {
                    cofactor = in.getInteger();
                    }
                    
                     XXX HashAlgorithm optional
                    
                    if (encodedParams.data.available() != 0) {
                    throw new IOException(&quot;encoded params have &quot; +
                    encodedParams.data.available() +
                    &quot; extra bytes&quot;);
                    }
                    
                    return new ECParameterSpec(curve, point, order, cofactor);                    
                </comment>
                <declaration name="encodedParams" type="DerValue" line="192"/>
                <scope line="193">
                    <declaration name="oid" type="ObjectIdentifier" line="194"/>
                    <declaration name="spec" type="ECParameterSpec" line="195"/>
                    <scope line="196"/>
                </scope>
            </method>
            <method name="getAlgorithmParameters" type="AlgorithmParameters" line="277">
                <params>
                    <param name="spec" type="ECParameterSpec"/>
                </params>
                <scope line="278">
                    <declaration name="params" type="AlgorithmParameters" line="279"/>
                </scope>
                <scope line="283"/>
            </method>
            <declaration name="paramSpec" type="ECParameterSpec" line="292"/>
            <method name="engineInit" type="void" line="295">
                <params>
                    <param name="paramSpec" type="AlgorithmParameterSpec"/>
                </params>
                <scope line="296">
                    <scope line="298"/>
                </scope>
                <scope line="302">
                    <declaration name="name" type="String" line="303"/>
                    <declaration name="spec" type="ECParameterSpec" line="304"/>
                    <scope line="305"/>
                </scope>
                <scope line="309"/>
                <scope line="312"/>
            </method>
            <method name="engineInit" type="void" line="318">
                <params>
                    <param name="params" type="byte[]"/>
                </params>
            </method>
            <method name="engineInit" type="void" line="322">
                <params>
                    <param name="params" type="byte[]"/>
                    <param name="decodingMethod" type="String"/>
                </params>
            </method>
            <method name="engineGetParameterSpec" type="T" line="327">
                <params>
                    <param name="spec" type="Class<T>"/>
                </params>
                <scope line="328"/>
                <scope line="330"/>
                <scope line="332"/>
            </method>
            <method name="engineGetEncoded" type="byte[]" line="338"/>
            <method name="engineGetEncoded" type="byte[]" line="342">
                <params>
                    <param name="encodingMethod" type="String"/>
                </params>
            </method>
            <method name="engineToString" type="String" line="346"/>
        </class>
    </source>