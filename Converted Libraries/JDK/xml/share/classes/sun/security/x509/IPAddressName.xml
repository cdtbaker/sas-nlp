<?xml version="1.0" encoding="UTF-8"?>
    <source package="sun.security.x509">
        <import package="java.io.IOException"/>
        <import package="java.lang.Integer"/>
        <import package="java.net.InetAddress"/>
        <import package="java.util.Arrays"/>
        <import package="sun.misc.HexDumpEncoder"/>
        <import package="sun.security.util.BitArray"/>
        <import package="sun.security.util.DerOutputStream"/>
        <import package="sun.security.util.DerValue"/>
        <class name="IPAddressName" line="37">
            <implements interface="GeneralNameInterface"/>
            <javadoc line="37">
                This class implements the IPAddressName as required by the GeneralNames
                  ASN.1 object.  Both IPv4 and IPv6 addresses are supported using the
                  formats specified in IETF PKIX RFC2459.
                  &lt;p&gt;
                  [RFC2459 4.2.1.7 Subject Alternative Name]
                  When the subjectAltName extension contains a iPAddress, the address
                  MUST be stored in the octet string in &quot;network byte order,&quot; as
                  specified in RFC 791. The least significant bit (LSB) of
                  each octet is the LSB of the corresponding byte in the network
                  address. For IP Version 4, as specified in RFC 791, the octet string
                  MUST contain exactly four octets.  For IP Version 6, as specified in
                  RFC 1883, the octet string MUST contain exactly sixteen octets.
                  &lt;p&gt;
                  [RFC2459 4.2.1.11 Name Constraints]
                  The syntax of iPAddress MUST be as described in section 4.2.1.7 with
                  the following additions specifically for Name Constraints.  For IPv4
                  addresses, the ipAddress field of generalName MUST contain eight (8)
                  octets, encoded in the style of RFC 1519 (CIDR) to represent an
                  address range.[RFC 1519]  For IPv6 addresses, the ipAddress field
                  MUST contain 32 octets similarly encoded.  For example, a name
                  constraint for &quot;class C&quot; subnet 10.9.8.0 shall be represented as the
                  octets 0A 09 08 00 FF FF FF 00, representing the CIDR notation
                  10.9.8.0/255.255.255.0.
                  &lt;p&gt;                
                <see>
                    GeneralName                    
                </see>
                <see>
                    GeneralNameInterface                    
                </see>
                <see>
                    GeneralNames                    
                </see>
                <author>
                    Amit Kapoor                    
                </author>
                <author>
                    Hemma Prafullchandra                    
                </author>
            </javadoc>
            <declaration name="address" type="byte[]" line="71"/>
            <declaration name="isIPv4" type="boolean" line="72"/>
            <declaration name="name" type="String" line="73"/>
            <javadoc line="75">
                Create the IPAddressName object from the passed encoded Der value.                
                <params>
                    derValue the encoded DER IPAddressName.                    
                </params>
                <exception>
                    IOException on error.                    
                </exception>
            </javadoc>
            <method name="IPAddressName" type="constructor" line="81">
                <params>
                    <param name="derValue" type="DerValue"/>
                </params>
            </method>
            <javadoc line="85">
                Create the IPAddressName object with the specified octets.                
                <params>
                    address the IP address                    
                </params>
                <throws>
                    IOException if address is not a valid IPv4 or IPv6 address                    
                </throws>
            </javadoc>
            <method name="IPAddressName" type="constructor" line="91">
                <params>
                    <param name="address" type="byte[]"/>
                </params>
                <comment line="93">
                    A valid address must consist of 4 bytes of address and
                     optional 4 bytes of 4 bytes of mask, or 16 bytes of address
                     and optional 16 bytes of mask.                    
                </comment>
                <scope line="97"/>
                <scope line="99"/>
                <scope line="101"/>
            </method>
            <javadoc line="107">
                Create an IPAddressName from a String.
                  [IETF RFC1338 Supernetting &amp; IETF RFC1519 Classless Inter-Domain
                  Routing (CIDR)] For IPv4 addresses, the forms are
                  &quot;b1.b2.b3.b4&quot; or &quot;b1.b2.b3.b4/m1.m2.m3.m4&quot;, where b1 - b4 are decimal
                  byte values 0-255 and m1 - m4 are decimal mask values
                  0 - 255.
                  &lt;p&gt;
                  [IETF RFC2373 IP Version 6 Addressing Architecture]
                  For IPv6 addresses, the forms are &quot;a1:a2:...:a8&quot; or &quot;a1:a2:...:a8/n&quot;,
                  where a1-a8 are hexadecimal values representing the eight 16-bit pieces
                  of the address. If /n is used, n is a decimal number indicating how many
                  of the leftmost contiguous bits of the address comprise the prefix for
                  this subnet. Internally, a mask value is created using the prefix length.
                  &lt;p&gt;                
                <param>
                    name String form of IPAddressName                    
                </param>
                <throws>
                    IOException if name can not be converted to a valid IPv4 or IPv6
                      address                    
                </throws>
            </javadoc>
            <method name="IPAddressName" type="constructor" line="126">
                <params>
                    <param name="name" type="String"/>
                </params>
                <comment line="137">
                    name is IPv6: uses colons as value separators
                     Parse name into byte-value address components and optional
                     prefix                    
                </comment>
                <comment line="143">
                    name is IPv4: uses dots as value separators                    
                </comment>
                <scope line="128"/>
                <scope line="131"/>
                <scope line="135"/>
                <scope line="141"/>
                <scope line="145"/>
            </method>
            <javadoc line="150">
                Parse an IPv4 address.                
                <param>
                    name IPv4 address with optional mask values                    
                </param>
                <throws>
                    IOException on error                    
                </throws>
            </javadoc>
            <method name="parseIPv4" type="void" line="156">
                <params>
                    <param name="name" type="String"/>
                </params>
                <comment line="159">
                    Parse name into byte-value address components                    
                </comment>
                <comment line="166">
                    parse mask                    
                </comment>
                <comment line="170">
                    parse base address                    
                </comment>
                <declaration name="slashNdx" type="int" line="159"/>
                <scope line="160"/>
                <scope line="162">
                    <declaration name="mask" type="byte[]" line="166"/>
                    <declaration name="host" type="byte[]" line="170"/>
                </scope>
            </method>
            <declaration name="MASKSIZE" type="int" line="178"/>
            <javadoc line="178">
                Parse an IPv6 address.                
                <param>
                    name String IPv6 address with optional /&lt;prefix length&gt;
                      If /&lt;prefix length&gt; is present, address[] array will
                      be 32 bytes long, otherwise 16.                    
                </param>
                <throws>
                    IOException on error                    
                </throws>
            </javadoc>
            <method name="parseIPv6" type="void" line="187">
                <params>
                    <param name="name" type="String"/>
                </params>
                <comment line="199">
                    append a mask corresponding to the num of prefix bits specified                    
                </comment>
                <comment line="204">
                    create new bit array initialized to zeros                    
                </comment>
                <comment line="207">
                    set all most significant bits up to prefix length                    
                </comment>
                <comment line="212">
                    copy mask bytes into mask portion of address                    
                </comment>
                <declaration name="slashNdx" type="int" line="189"/>
                <scope line="190"/>
                <scope line="192">
                    <declaration name="base" type="byte[]" line="194"/>
                    <declaration name="prefixLen" type="int" line="199"/>
                    <declaration name="bitArray" type="BitArray" line="204"/>
                    <declaration name="maskArray" type="byte[]" line="209"/>
                </scope>
            </method>
            <javadoc line="217">
                Return the type of the GeneralName.                
            </javadoc>
            <method name="getType" type="int" line="220"/>
            <javadoc line="224">
                Encode the IPAddress name into the DerOutputStream.                
                <params>
                    out the DER stream to encode the IPAddressName to.                    
                </params>
                <exception>
                    IOException on encoding errors.                    
                </exception>
            </javadoc>
            <method name="encode" type="void" line="230">
                <params>
                    <param name="out" type="DerOutputStream"/>
                </params>
            </method>
            <javadoc line="234">
                Return a printable string of IPaddress                
            </javadoc>
            <method name="toString" type="String" line="237">
                <comment line="242">
                    dump out hex rep for debugging purposes                    
                </comment>
                <scope line="238"/>
                <scope line="240">
                    <declaration name="enc" type="HexDumpEncoder" line="242"/>
                </scope>
            </method>
            <javadoc line="247">
                Return a standard String representation of IPAddress.
                  See IPAddressName(String) for the formats used for IPv4
                  and IPv6 addresses.                
                <throws>
                    IOException if the IPAddress cannot be converted to a String                    
                </throws>
            </javadoc>
            <method name="getName" type="String" line="254">
                <comment line="260">
                    IPv4 address or subdomain                    
                </comment>
                <comment line="271">
                    IPv6 address or subdomain                    
                </comment>
                <comment line="276">
                    IPv6 subdomain: display prefix length                    
                </comment>
                <comment line="278">
                    copy subdomain into new array and convert to BitArray                    
                </comment>
                <comment line="283">
                    Find first zero bit                    
                </comment>
                <comment line="290">
                    Verify remaining bits 0                    
                </comment>
                <scope line="258">
                    <declaration name="host" type="byte[]" line="260"/>
                    <scope line="263">
                        <declaration name="mask" type="byte[]" line="264"/>
                    </scope>
                </scope>
                <scope line="269">
                    <declaration name="host" type="byte[]" line="271"/>
                    <scope line="274">
                        <declaration name="maskBytes" type="byte[]" line="278"/>
                        <declaration name="ba" type="BitArray" line="281"/>
                        <declaration name="i" type="int" line="283"/>
                        <scope line="284"/>
                        <scope line="290">
                            <scope line="291"/>
                        </scope>
                    </scope>
                </scope>
            </method>
            <javadoc line="301">
                Returns this IPAddress name as a byte array.                
            </javadoc>
            <method name="getBytes" type="byte[]" line="304"/>
            <javadoc line="308">
                Compares this name with another, for equality.                
                <return>
                    true iff the names are identical.                    
                </return>
            </javadoc>
            <method name="equals" type="boolean" line="313">
                <params>
                    <param name="obj" type="Object"/>
                </params>
                <comment line="327">
                    Two subnet addresses
                     Mask each and compare masked values                    
                </comment>
                <comment line="339">
                    Now compare masks                    
                </comment>
                <comment line="345">
                    Two IPv4 host addresses or two IPv6 host addresses
                     Compare bytes                    
                </comment>
                <declaration name="other" type="byte[]" line="320"/>
                <scope line="325">
                    <declaration name="maskLen" type="int" line="328"/>
                    <declaration name="maskedThis" type="byte[]" line="329"/>
                    <declaration name="maskedOther" type="byte[]" line="330"/>
                    <scope line="331">
                        <scope line="334"/>
                    </scope>
                </scope>
                <scope line="343"/>
            </method>
            <javadoc line="350">
                Returns the hash code value for this object.                
                <return>
                    a hash code value for this object.                    
                </return>
            </javadoc>
            <method name="hashCode" type="int" line="355">
                <declaration name="retval" type="int" line="356"/>
            </method>
            <javadoc line="364">
                Return type of constraint inputName places on this name:&lt;ul&gt;
                  &lt;li&gt;NAME_DIFF_TYPE = -1: input name is different type from name
                  (i.e. does not constrain).
                  &lt;li&gt;NAME_MATCH = 0: input name matches name.
                  &lt;li&gt;NAME_NARROWS = 1: input name narrows name (is lower in the naming
                  subtree)
                  &lt;li&gt;NAME_WIDENS = 2: input name widens name (is higher in the naming
                  subtree)
                  &lt;li&gt;NAME_SAME_TYPE = 3: input name does not match or narrow name, but
                  is same type.
                  &lt;/ul&gt;.  These results are used in checking NameConstraints during
                  certification path verification.
                  &lt;p&gt;
                  [RFC2459] The syntax of iPAddress MUST be as described in section
                  4.2.1.7 with the following additions specifically for Name Constraints.
                  For IPv4 addresses, the ipAddress field of generalName MUST contain
                  eight (8) octets, encoded in the style of RFC 1519 (CIDR) to represent an
                  address range.[RFC 1519]  For IPv6 addresses, the ipAddress field
                  MUST contain 32 octets similarly encoded.  For example, a name
                  constraint for &quot;class C&quot; subnet 10.9.8.0 shall be represented as the
                  octets 0A 09 08 00 FF FF FF 00, representing the CIDR notation
                  10.9.8.0/255.255.255.0.
                  &lt;p&gt;                
                <param>
                    inputName to be checked for being constrained                    
                </param>
                <returns>
                    constraint type above                    
                </returns>
                <throws>
                    UnsupportedOperationException if name is not exact match, but
                      narrowing and widening are not supported for this name type.                    
                </throws>
            </javadoc>
            <method name="constrains" type="int" line="394">
                <params>
                    <param name="inputName" type="GeneralNameInterface"/>
                </params>
                <comment line="406">
                    Two host addresses                    
                </comment>
                <comment line="410">
                    Two subnet addresses
                     See if one address fully encloses the other address                    
                </comment>
                <comment line="445">
                    Other is a subnet, this is a host address                    
                </comment>
                <comment line="449">
                    Mask this address by other address mask and compare to other address
                     If all match, then this address is in other address subnet                    
                </comment>
                <comment line="459">
                    This is a subnet, other is a host address                    
                </comment>
                <comment line="463">
                    Mask other address by this address mask and compare to this address                    
                </comment>
                <declaration name="constraintType" type="int" line="395"/>
                <scope line="402">
                    <declaration name="otherAddress" type="byte[]" line="403"/>
                    <scope line="408">
                        <declaration name="otherSubsetOfThis" type="boolean" line="411"/>
                        <declaration name="thisSubsetOfOther" type="boolean" line="412"/>
                        <declaration name="thisEmpty" type="boolean" line="413"/>
                        <declaration name="otherEmpty" type="boolean" line="414"/>
                        <declaration name="maskOffset" type="int" line="415"/>
                        <scope line="416">
                            <scope line="422"/>
                            <scope line="426"/>
                        </scope>
                        <scope line="430"/>
                    </scope>
                    <scope line="443">
                        <declaration name="i" type="int" line="445"/>
                        <declaration name="maskOffset" type="int" line="446"/>
                        <scope line="447"/>
                    </scope>
                    <scope line="457">
                        <declaration name="i" type="int" line="459"/>
                        <declaration name="maskOffset" type="int" line="460"/>
                        <scope line="461"/>
                    </scope>
                    <scope line="470"/>
                </scope>
            </method>
            <javadoc line="477">
                Return subtree depth of this name for purposes of determining
                  NameConstraints minimum and maximum bounds and for calculating
                  path lengths in name subtrees.                
                <returns>
                    distance of name from root                    
                </returns>
                <throws>
                    UnsupportedOperationException if not supported for this name type                    
                </throws>
            </javadoc>
            <method name="subtreeDepth" type="int" line="485"/>
        </class>
    </source>