<?xml version="1.0" encoding="UTF-8"?>
    <source package="sun.security.x509">
        <import package="java.lang.reflect"/>
        <import package="java.io.IOException"/>
        <import package="java.io.StringReader"/>
        <import package="java.security.PrivilegedExceptionAction"/>
        <import package="java.security.AccessController"/>
        <import package="java.security.Principal"/>
        <import package="java.util"/>
        <import package="sun.security.util"/>
        <import package="sun.security.pkcs.PKCS9Attribute"/>
        <import package="javax.security.auth.x500.X500Principal"/>
        <class name="X500Name" line="40">
            <comment line="133">
                roughly RFC 1779 DN, or null                
            </comment>
            <comment line="134">
                RFC 1779 compliant DN, or null                
            </comment>
            <comment line="135">
                RFC 2253 DN, or null                
            </comment>
            <comment line="136">
                canonical RFC 2253 DN or null                
            </comment>
            <comment line="137">
                RDNs (never null)                
            </comment>
            <comment line="141">
                cached immutable list of the RDNs and all the AVAs                
            </comment>
            <comment line="423">
                Returns the name component as a Java string, regardless of its
                 encoding restrictions.                
            </comment>
            <comment line="861">
                Parses a Distinguished Name (DN) in printable representation.
                
                 According to RFC 1779, RDNs in a DN are separated by comma.
                 The following examples show both methods of quoting a comma, so that it
                 is not considered a separator:
                
                     O=&quot;Sue, Grabbit and Runn&quot; or
                     O=Sue\, Grabbit and Runn
                
                 This method can parse 1779 or 2253 DNs and non-standard 3280 keywords.
                 Additional keywords can be specified in the keywordOID map.                
            </comment>
            <comment line="999">
                Counts double quotes in string.
                 Escaped quotes are ignored.                
            </comment>
            <comment line="1057">
                Dump the printable form of a distinguished name.  Each relative
                 name is separated from the next by a &quot;,&quot;, and assertions in the
                 relative names have &quot;label=value&quot; syntax.
                
                 Uses RFC 1779 syntax (i.e. little-endian, comma separators)                
            </comment>
            <comment line="1082">
                Dump the printable form of a distinguished name.  Each relative
                 name is separated from the next by a &quot;,&quot;, and assertions in the
                 relative names have &quot;label=value&quot; syntax.
                
                 Uses RFC 1779 syntax (i.e. little-endian, comma separators)
                 Valid keywords from RFC 1779 are used. Additional keywords can be
                 specified in the OIDkeyword map.                
            </comment>
            <comment line="1126">
                Selected OIDs from X.520
                 Includes all those specified in RFC 3280 as MUST or SHOULD
                 be recognized                
            </comment>
            <implements interface="GeneralNameInterface"/>
            <implements interface="Principal"/>
            <javadoc line="40">
                Note:  As of 1.4, the public class,
                  javax.security.auth.x500.X500Principal,
                  should be used when parsing, generating, and comparing X.500 DNs.
                  This class contains other useful methods for checking name constraints
                  and retrieving DNs by keyword.
                  &lt;p&gt; X.500 names are used to identify entities, such as those which are
                  identified by X.509 certificates.  They are world-wide, hierarchical,
                  and descriptive.  Entities can be identified by attributes, and in
                  some systems can be searched for according to those attributes.
                  &lt;p&gt;
                  The ASN.1 for this is:
                  &lt;pre&gt;
                  GeneralName ::= CHOICE {
                  ....
                  directoryName                   [4]     Name,
                  ....
                  Name ::= CHOICE {
                  RDNSequence }
                  RDNSequence ::= SEQUENCE OF RelativeDistinguishedName
                  RelativeDistinguishedName ::=
                  SET OF AttributeTypeAndValue
                  AttributeTypeAndValue ::= SEQUENCE {
                  type     AttributeType,
                  value    AttributeValue }
                  AttributeType ::= OBJECT IDENTIFIER
                  AttributeValue ::= ANY DEFINED BY AttributeType
                  ....
                  DirectoryString ::= CHOICE {
                  teletexString           TeletexString (SIZE (1..MAX)),
                  printableString         PrintableString (SIZE (1..MAX)),
                  universalString         UniversalString (SIZE (1..MAX)),
                  utf8String              UTF8String (SIZE (1.. MAX)),
                  bmpString               BMPString (SIZE (1..MAX)) }
                  &lt;/pre&gt;
                  &lt;p&gt;
                  This specification requires only a subset of the name comparison
                  functionality specified in the X.500 series of specifications.  The
                  requirements for conforming implementations are as follows:
                  &lt;ol TYPE=a&gt;
                  &lt;li&gt;attribute values encoded in different types (e.g.,
                  PrintableString and BMPString) may be assumed to represent
                  different strings;
                  &lt;p&gt;
                  &lt;li&gt;attribute values in types other than PrintableString are case
                  sensitive (this permits matching of attribute values as binary
                  objects);
                  &lt;p&gt;
                  &lt;li&gt;attribute values in PrintableString are not case sensitive
                  (e.g., &quot;Marianne Swanson&quot; is the same as &quot;MARIANNE SWANSON&quot;); and
                  &lt;p&gt;
                  &lt;li&gt;attribute values in PrintableString are compared after
                  removing leading and trailing white space and converting internal
                  substrings of one or more consecutive white space characters to a
                  single space.
                  &lt;/ol&gt;
                  &lt;p&gt;
                  These name comparison rules permit a certificate user to validate
                  certificates issued using languages or encodings unfamiliar to the
                  certificate user.
                  &lt;p&gt;
                  In addition, implementations of this specification MAY use these
                  comparison rules to process unfamiliar attribute types for name
                  chaining. This allows implementations to process certificates with
                  unfamiliar attributes in the issuer name.
                  &lt;p&gt;
                  Note that the comparison rules defined in the X.500 series of
                  specifications indicate that the character sets used to encode data
                  in distinguished names are irrelevant.  The characters themselves are
                  compared without regard to encoding. Implementations of the profile
                  are permitted to use the comparison algorithm defined in the X.500
                  series.  Such an implementation will recognize a superset of name
                  matches recognized by the algorithm specified above.
                  &lt;p&gt;
                  Note that instances of this class are immutable.                
                <author>
                    David Brownell                    
                </author>
                <author>
                    Amit Kapoor                    
                </author>
                <author>
                    Hemma Prafullchandra                    
                </author>
                <see>
                    GeneralName                    
                </see>
                <see>
                    GeneralNames                    
                </see>
                <see>
                    GeneralNameInterface                    
                </see>
            </javadoc>
            <declaration name="dn" type="String" line="132"/>
            <declaration name="rfc1779Dn" type="String" line="133"/>
            <declaration name="rfc2253Dn" type="String" line="134"/>
            <declaration name="canonicalDn" type="String" line="135"/>
            <declaration name="names" type="RDN[]" line="136"/>
            <declaration name="x500Principal" type="X500Principal" line="137"/>
            <declaration name="encoded" type="byte[]" line="138"/>
            <declaration name="rdnList" type="List&lt;RDN&gt;" line="141"/>
            <declaration name="allAvaList" type="List&lt;AVA&gt;" line="142"/>
            <javadoc line="144">
                Constructs a name from a conventionally formatted string, such
                  as &quot;CN=Dave, OU=JavaSoft, O=Sun Microsystems, C=US&quot;.
                  (RFC 1779 or RFC 2253 style).                
                <param>
                    DN X.500 Distinguished Name                    
                </param>
            </javadoc>
            <method name="X500Name" type="constructor" line="151">
                <params>
                    <param name="dname" type="String"/>
                </params>
            </method>
            <javadoc line="155">
                Constructs a name from a conventionally formatted string, such
                  as &quot;CN=Dave, OU=JavaSoft, O=Sun Microsystems, C=US&quot;.
                  (RFC 1779 or RFC 2253 style).                
                <param>
                    DN X.500 Distinguished Name                    
                </param>
                <param>
                    keywordMap an additional keyword/OID map                    
                </param>
            </javadoc>
            <method name="X500Name" type="constructor" line="164">
                <params>
                    <param name="dname" type="String"/>
                    <param name="keywordMap" type="Map<String,String>"/>
                </params>
            </method>
            <javadoc line="168">
                Constructs a name from a string formatted according to format.
                  Currently, the formats DEFAULT and RFC2253 are supported.
                  DEFAULT is the default format used by the X500Name(String)
                  constructor. RFC2253 is format strictly according to RFC2253
                  without extensions.                
                <param>
                    DN X.500 Distinguished Name                    
                </param>
            </javadoc>
            <method name="X500Name" type="constructor" line="177">
                <params>
                    <param name="dname" type="String"/>
                    <param name="format" type="String"/>
                </params>
                <scope line="178"/>
                <scope line="181"/>
                <scope line="183"/>
                <scope line="185"/>
            </method>
            <javadoc line="190">
                Constructs a name from fields common in enterprise application
                  environments.
                  &lt;P&gt;&lt;EM&gt;&lt;STRONG&gt;NOTE:&lt;/STRONG&gt;  The behaviour when any of
                  these strings contain characters outside the ASCII range
                  is unspecified in currently relevant standards.&lt;/EM&gt;                
                <param>
                    commonName common name of a person, e.g. "Vivette Davis"                    
                </param>
                <param>
                    organizationUnit small organization name, e.g. "Purchasing"                    
                </param>
                <param>
                    organizationName large organization name, e.g. "Onizuka, Inc."                    
                </param>
                <param>
                    country two letter country code, e.g. "CH"                    
                </param>
            </javadoc>
            <method name="X500Name" type="constructor" line="205">
                <params>
                    <param name="commonName" type="String"/>
                    <param name="organizationUnit" type="String"/>
                    <param name="organizationName" type="String"/>
                    <param name="country" type="String"/>
                </params>
                <comment line="208">
                    NOTE:  it&apos;s only on output that little-endian
                     ordering is used.                    
                </comment>
            </method>
            <javadoc line="225">
                Constructs a name from fields common in Internet application
                  environments.
                  &lt;P&gt;&lt;EM&gt;&lt;STRONG&gt;NOTE:&lt;/STRONG&gt;  The behaviour when any of
                  these strings contain characters outside the ASCII range
                  is unspecified in currently relevant standards.&lt;/EM&gt;                
                <param>
                    commonName common name of a person, e.g. "Vivette Davis"                    
                </param>
                <param>
                    organizationUnit small organization name, e.g. "Purchasing"                    
                </param>
                <param>
                    organizationName large organization name, e.g. "Onizuka, Inc."                    
                </param>
                <param>
                    localityName locality (city) name, e.g. "Palo Alto"                    
                </param>
                <param>
                    stateName state name, e.g. "California"                    
                </param>
                <param>
                    country two letter country code, e.g. "CH"                    
                </param>
            </javadoc>
            <method name="X500Name" type="constructor" line="243">
                <params>
                    <param name="commonName" type="String"/>
                    <param name="organizationUnit" type="String"/>
                    <param name="organizationName" type="String"/>
                    <param name="localityName" type="String"/>
                    <param name="stateName" type="String"/>
                    <param name="country" type="String"/>
                </params>
                <comment line="246">
                    NOTE:  it&apos;s only on output that little-endian
                     ordering is used.                    
                </comment>
            </method>
            <javadoc line="269">
                Constructs a name from an array of relative distinguished names                
                <param>
                    rdnArray array of relative distinguished names                    
                </param>
                <throws>
                    IOException on error                    
                </throws>
            </javadoc>
            <method name="X500Name" type="constructor" line="275">
                <params>
                    <param name="rdnArray" type="RDN[]"/>
                </params>
                <scope line="276"/>
                <scope line="278">
                    <scope line="280">
                        <scope line="281"/>
                    </scope>
                </scope>
            </method>
            <javadoc line="288">
                Constructs a name from an ASN.1 encoded value.  The encoding
                  of the name in the stream uses DER (a BER/1 subset).                
                <param>
                    value a DER-encoded value holding an X.500 name.                    
                </param>
            </javadoc>
            <method name="X500Name" type="constructor" line="294">
                <params>
                    <param name="value" type="DerValue"/>
                </params>
                <comment line="296">
                    Note that toDerInputStream uses only the buffer (data) and not
                    the tag, so an empty SEQUENCE (OF) will yield an empty DerInputStream                    
                </comment>
            </method>
            <javadoc line="300">
                Constructs a name from an ASN.1 encoded input stream.  The encoding
                  of the name in the stream uses DER (a BER/1 subset).                
                <param>
                    in DER-encoded data holding an X.500 name.                    
                </param>
            </javadoc>
            <method name="X500Name" type="constructor" line="306">
                <params>
                    <param name="in" type="DerInputStream"/>
                </params>
            </method>
            <javadoc line="310">
                Constructs a name from an ASN.1 encoded byte array.                
                <param>
                    name DER-encoded byte array holding an X.500 name.                    
                </param>
            </javadoc>
            <method name="X500Name" type="constructor" line="315">
                <params>
                    <param name="name" type="byte[]"/>
                </params>
                <declaration name="in" type="DerInputStream" line="316"/>
            </method>
            <javadoc line="320">
                Return an immutable List of all RDNs in this X500Name.                
            </javadoc>
            <method name="rdns" type="List<RDN>" line="323">
                <declaration name="list" type="List&lt;RDN&gt;" line="324"/>
                <scope line="325"/>
            </method>
            <javadoc line="332">
                Return the number of RDNs in this X500Name.                
            </javadoc>
            <method name="size" type="int" line="335"/>
            <javadoc line="339">
                Return an immutable List of the the AVAs contained in all the
                  RDNs of this X500Name.                
            </javadoc>
            <method name="allAvas" type="List<AVA>" line="343">
                <declaration name="list" type="List&lt;AVA&gt;" line="344"/>
                <scope line="345">
                    <scope line="347"/>
                </scope>
            </method>
            <javadoc line="354">
                Return the total number of AVAs contained in all the RDNs of
                  this X500Name.                
            </javadoc>
            <method name="avaSize" type="int" line="358"/>
            <javadoc line="362">
                Return whether this X500Name is empty. An X500Name is not empty
                  if it has at least one RDN containing at least one AVA.                
            </javadoc>
            <method name="isEmpty" type="boolean" line="366">
                <declaration name="n" type="int" line="367"/>
                <scope line="368"/>
                <scope line="371">
                    <scope line="372"/>
                </scope>
            </method>
            <javadoc line="379">
                Calculates a hash code value for the object.  Objects
                  which are equal will also have the same hashcode.                
            </javadoc>
            <method name="hashCode" type="int" line="383"/>
            <javadoc line="387">
                Compares this name with another, for equality.                
                <return>
                    true iff the names are identical.                    
                </return>
            </javadoc>
            <method name="equals" type="boolean" line="392">
                <params>
                    <param name="obj" type="Object"/>
                </params>
                <comment line="401">
                    if we already have the canonical forms, compare now                    
                </comment>
                <comment line="405">
                    quick check that number of RDNs and AVAs match before canonicalizing                    
                </comment>
                <comment line="417">
                    definite check via canonical form                    
                </comment>
                <scope line="393"/>
                <scope line="396"/>
                <declaration name="other" type="X500Name" line="399"/>
                <scope line="401"/>
                <declaration name="n" type="int" line="405"/>
                <scope line="406"/>
                <scope line="409">
                    <declaration name="r1" type="RDN" line="410"/>
                    <declaration name="r2" type="RDN" line="411"/>
                    <scope line="412"/>
                </scope>
                <declaration name="thisCanonical" type="String" line="417"/>
                <declaration name="otherCanonical" type="String" line="418"/>
            </method>
            <method name="getString" type="String" line="426">
                <params>
                    <param name="attribute" type="DerValue"/>
                </params>
                <declaration name="value" type="String" line="429"/>
            </method>
            <javadoc line="438">
                Return type of GeneralName.                
            </javadoc>
            <method name="getType" type="int" line="441"/>
            <javadoc line="445">
                Returns a &quot;Country&quot; name component.  If more than one
                  such attribute exists, the topmost one is returned.                
                <return>
                    "C=" component of the name, if any.                    
                </return>
            </javadoc>
            <method name="getCountry" type="String" line="451">
                <declaration name="attr" type="DerValue" line="452"/>
            </method>
            <javadoc line="458">
                Returns an &quot;Organization&quot; name component.  If more than
                  one such attribute exists, the topmost one is returned.                
                <return>
                    "O=" component of the name, if any.                    
                </return>
            </javadoc>
            <method name="getOrganization" type="String" line="464">
                <declaration name="attr" type="DerValue" line="465"/>
            </method>
            <javadoc line="471">
                Returns an &quot;Organizational Unit&quot; name component.  If more
                  than one such attribute exists, the topmost one is returned.                
                <return>
                    "OU=" component of the name, if any.                    
                </return>
            </javadoc>
            <method name="getOrganizationalUnit" type="String" line="477">
                <declaration name="attr" type="DerValue" line="478"/>
            </method>
            <javadoc line="484">
                Returns a &quot;Common Name&quot; component.  If more than one such
                  attribute exists, the topmost one is returned.                
                <return>
                    "CN=" component of the name, if any.                    
                </return>
            </javadoc>
            <method name="getCommonName" type="String" line="490">
                <declaration name="attr" type="DerValue" line="491"/>
            </method>
            <javadoc line="497">
                Returns a &quot;Locality&quot; name component.  If more than one
                  such component exists, the topmost one is returned.                
                <return>
                    "L=" component of the name, if any.                    
                </return>
            </javadoc>
            <method name="getLocality" type="String" line="503">
                <declaration name="attr" type="DerValue" line="504"/>
            </method>
            <javadoc line="509">
                Returns a &quot;State&quot; name component.  If more than one
                  such component exists, the topmost one is returned.                
                <return>
                    "S=" component of the name, if any.                    
                </return>
            </javadoc>
            <method name="getState" type="String" line="515">
                <declaration name="attr" type="DerValue" line="516"/>
            </method>
            <javadoc line="521">
                Returns a &quot;Domain&quot; name component.  If more than one
                  such component exists, the topmost one is returned.                
                <return>
                    "DC=" component of the name, if any.                    
                </return>
            </javadoc>
            <method name="getDomain" type="String" line="527">
                <declaration name="attr" type="DerValue" line="528"/>
            </method>
            <javadoc line="533">
                Returns a &quot;DN Qualifier&quot; name component.  If more than one
                  such component exists, the topmost one is returned.                
                <return>
                    "DNQ=" component of the name, if any.                    
                </return>
            </javadoc>
            <method name="getDNQualifier" type="String" line="539">
                <declaration name="attr" type="DerValue" line="540"/>
            </method>
            <javadoc line="545">
                Returns a &quot;Surname&quot; name component.  If more than one
                  such component exists, the topmost one is returned.                
                <return>
                    "SURNAME=" component of the name, if any.                    
                </return>
            </javadoc>
            <method name="getSurname" type="String" line="551">
                <declaration name="attr" type="DerValue" line="552"/>
            </method>
            <javadoc line="557">
                Returns a &quot;Given Name&quot; name component.  If more than one
                  such component exists, the topmost one is returned.                
                <return>
                    "GIVENNAME=" component of the name, if any.                    
                </return>
            </javadoc>
            <method name="getGivenName" type="String" line="563">
                <declaration name="attr" type="DerValue" line="564"/>
            </method>
            <javadoc line="569">
                Returns an &quot;Initials&quot; name component.  If more than one
                  such component exists, the topmost one is returned.                
                <return>
                    "INITIALS=" component of the name, if any.                    
                </return>
            </javadoc>
            <method name="getInitials" type="String" line="575">
                <declaration name="attr" type="DerValue" line="576"/>
            </method>
            <javadoc line="581">
                Returns a &quot;Generation Qualifier&quot; name component.  If more than one
                  such component exists, the topmost one is returned.                
                <return>
                    "GENERATION=" component of the name, if any.                    
                </return>
            </javadoc>
            <method name="getGeneration" type="String" line="587">
                <declaration name="attr" type="DerValue" line="588"/>
            </method>
            <javadoc line="593">
                Returns an &quot;IP address&quot; name component.  If more than one
                  such component exists, the topmost one is returned.                
                <return>
                    "IP=" component of the name, if any.                    
                </return>
            </javadoc>
            <method name="getIP" type="String" line="599">
                <declaration name="attr" type="DerValue" line="600"/>
            </method>
            <javadoc line="605">
                Returns a string form of the X.500 distinguished name.
                  The format of the string is from RFC 1779. The returned string
                  may contain non-standardised keywords for more readability
                  (keywords from RFCs 1779, 2253, and 3280).                
            </javadoc>
            <method name="toString" type="String" line="611">
                <scope line="612"/>
            </method>
            <javadoc line="618">
                Returns a string form of the X.500 distinguished name
                  using the algorithm defined in RFC 1779. Only standard attribute type
                  keywords defined in RFC 1779 are emitted.                
            </javadoc>
            <method name="getRFC1779Name" type="String" line="623"/>
            <javadoc line="627">
                Returns a string form of the X.500 distinguished name
                  using the algorithm defined in RFC 1779. Attribute type
                  keywords defined in RFC 1779 are emitted, as well as additional
                  keywords contained in the OID/keyword map.                
            </javadoc>
            <method name="getRFC1779Name" type="String" line="634">
                <params>
                    <param name="oidMap" type="Map<String,String>"/>
                </params>
                <comment line="637">
                    return cached result                    
                </comment>
                <scope line="635">
                    <scope line="637"/>
                    <scope line="639"/>
                </scope>
            </method>
            <javadoc line="647">
                Returns a string form of the X.500 distinguished name
                  using the algorithm defined in RFC 2253. Only standard attribute type
                  keywords defined in RFC 2253 are emitted.                
            </javadoc>
            <method name="getRFC2253Name" type="String" line="652"/>
            <javadoc line="656">
                Returns a string form of the X.500 distinguished name
                  using the algorithm defined in RFC 2253. Attribute type
                  keywords defined in RFC 2253 are emitted, as well as additional
                  keywords contained in the OID/keyword map.                
            </javadoc>
            <method name="getRFC2253Name" type="String" line="662">
                <params>
                    <param name="oidMap" type="Map<String,String>"/>
                </params>
                <comment line="664">
                                        
                </comment>
                <scope line="664">
                    <scope line="665"/>
                    <scope line="667"/>
                </scope>
            </method>
            <method name="generateRFC2253DN" type="String" line="675">
                <params>
                    <param name="oidMap" type="Map<String,String>"/>
                </params>
                <comment line="677">
                    Section 2.1 : if the RDNSequence is an empty sequence
                     the result is the empty or zero length string.                    
                </comment>
                <comment line="685">
                    2.1 (continued) : Otherwise, the output consists of the string
                     encodings of each RelativeDistinguishedName in the RDNSequence
                     (according to 2.2), starting with the last element of the sequence
                     and moving backwards toward the first.
                    
                     The encodings of adjoining RelativeDistinguishedNames are separated
                     by a comma character (&apos;,&apos; ASCII 44).                    
                </comment>
                <scope line="680"/>
                <declaration name="fullname" type="StringBuilder" line="693"/>
                <scope line="694">
                    <scope line="695"/>
                </scope>
            </method>
            <method name="getRFC2253CanonicalName" type="String" line="703">
                <comment line="705">
                                        
                </comment>
                <comment line="709">
                    Section 2.1 : if the RDNSequence is an empty sequence
                     the result is the empty or zero length string.                    
                </comment>
                <comment line="718">
                    2.1 (continued) : Otherwise, the output consists of the string
                     encodings of each RelativeDistinguishedName in the RDNSequence
                     (according to 2.2), starting with the last element of the sequence
                     and moving backwards toward the first.
                    
                     The encodings of adjoining RelativeDistinguishedNames are separated
                     by a comma character (&apos;,&apos; ASCII 44).                    
                </comment>
                <scope line="705"/>
                <scope line="712"/>
                <declaration name="fullname" type="StringBuilder" line="726"/>
                <scope line="727">
                    <scope line="728"/>
                </scope>
            </method>
            <javadoc line="737">
                Returns the value of toString().  This call is needed to
                  implement the java.security.Principal interface.                
            </javadoc>
            <method name="getName" type="String" line="741"/>
            <javadoc line="743">
                Find the first instance of this attribute in a &quot;top down&quot;
                  search of all the attributes in the name.                
            </javadoc>
            <method name="findAttribute" type="DerValue" line="747">
                <params>
                    <param name="attribute" type="ObjectIdentifier"/>
                </params>
                <scope line="748">
                    <scope line="749">
                        <declaration name="value" type="DerValue" line="750"/>
                        <scope line="751"/>
                    </scope>
                </scope>
            </method>
            <javadoc line="759">
                Find the most specific (&quot;last&quot;) attribute of the given
                  type.                
            </javadoc>
            <method name="findMostSpecificAttribute" type="DerValue" line="763">
                <params>
                    <param name="attribute" type="ObjectIdentifier"/>
                </params>
                <scope line="764">
                    <scope line="765">
                        <declaration name="value" type="DerValue" line="766"/>
                        <scope line="767"/>
                    </scope>
                </scope>
            </method>
            <javadoc line="775">
                                
            </javadoc>
            <method name="parseDER" type="void" line="777">
                <params>
                    <param name="in" type="DerInputStream"/>
                </params>
                <comment line="779">
                    X.500 names are a &quot;SEQUENCE OF&quot; RDNs, which means zero or
                     more and order matters.  We scan them in order, which
                     conventionally is big-endian.                    
                </comment>
                <declaration name="nameseq" type="DerValue[]" line="783"/>
                <declaration name="derBytes" type="byte[]" line="784"/>
                <scope line="786"/>
                <scope line="788">
                    <scope line="789"/>
                    <scope line="791">
                        <declaration name="derVal" type="DerValue" line="792"/>
                    </scope>
                </scope>
                <scope line="799"/>
                <scope line="801">
                    <scope line="803"/>
                </scope>
            </method>
            <javadoc line="809">
                Encodes the name in DER-encoded form.                
                <deprecated>
                    Use encode() instead                    
                </deprecated>
                <param>
                    out where to put the DER-encoded X.500 name                    
                </param>
            </javadoc>
            <method name="emit" type="void" line="816">
                <params>
                    <param name="out" type="DerOutputStream"/>
                </params>
            </method>
            <javadoc line="820">
                Encodes the name in DER-encoded form.                
                <param>
                    out where to put the DER-encoded X.500 name                    
                </param>
            </javadoc>
            <method name="encode" type="void" line="825">
                <params>
                    <param name="out" type="DerOutputStream"/>
                </params>
                <declaration name="tmp" type="DerOutputStream" line="826"/>
                <scope line="827"/>
            </method>
            <javadoc line="833">
                Returned the encoding as an uncloned byte array. Callers must
                  guarantee that they neither modify it not expose it to untrusted
                  code.                
            </javadoc>
            <method name="getEncodedInternal" type="byte[]" line="838">
                <scope line="839">
                    <declaration name="out" type="DerOutputStream" line="840"/>
                    <declaration name="tmp" type="DerOutputStream" line="841"/>
                    <scope line="842"/>
                </scope>
            </method>
            <javadoc line="851">
                Gets the name in DER-encoded form.                
                <return>
                    the DER encoded byte array of this name.                    
                </return>
            </javadoc>
            <method name="getEncoded" type="byte[]" line="856"/>
            <method name="parseDN" type="void" line="874">
                <params>
                    <param name="input" type="String"/>
                    <param name="keywordMap" type="Map<String,String>"/>
                </params>
                <comment line="903">
                    We have encountered an RDN delimiter (comma or a semicolon).
                     If the comma or semicolon in the RDN under consideration is
                     preceded by a backslash (escape), or by a double quote, it
                     is part of the RDN. Otherwise, it is used as a separator, to
                     delimit the RDN under consideration from any subsequent RDNs.                    
                </comment>
                <comment line="913">
                    Commasemicolon is a separator                    
                </comment>
                <comment line="918">
                    Parse RDN, and store it in vector                    
                </comment>
                <comment line="922">
                    Increase the offset                    
                </comment>
                <comment line="925">
                    Set quote counter back to zero                    
                </comment>
                <comment line="934">
                    Parse last or only RDN, and store it in vector                    
                </comment>
                <comment line="939">
                    Store the vector elements as an array of RDNs
                     NOTE: It&apos;s only on output that little-endian ordering is used.                    
                </comment>
                <scope line="875"/>
                <declaration name="dnVector" type="List&lt;RDN&gt;" line="880"/>
                <declaration name="dnOffset" type="int" line="881"/>
                <declaration name="rdnEnd" type="int" line="882"/>
                <declaration name="rdnString" type="String" line="883"/>
                <declaration name="quoteCount" type="int" line="884"/>
                <declaration name="dnString" type="String" line="886"/>
                <declaration name="searchOffset" type="int" line="888"/>
                <declaration name="nextComma" type="int" line="889"/>
                <declaration name="nextSemiColon" type="int" line="890"/>
                <scope line="891">
                    <scope line="893"/>
                    <scope line="895"/>
                    <scope line="897"/>
                    <scope line="910">
                        <declaration name="rdn" type="RDN" line="918"/>
                    </scope>
                </scope>
                <declaration name="rdn" type="RDN" line="935"/>
            </method>
            <method name="parseRFC2253DN" type="void" line="946">
                <params>
                    <param name="dnString" type="String"/>
                </params>
                <comment line="960">
                    We have encountered an RDN delimiter (comma).
                     If the comma in the RDN under consideration is
                     preceded by a backslash (escape), it
                     is part of the RDN. Otherwise, it is used as a separator, to
                     delimit the RDN under consideration from any subsequent RDNs.                    
                </comment>
                <comment line="969">
                    Comma is a separator                    
                </comment>
                <comment line="974">
                    Parse RDN, and store it in vector                    
                </comment>
                <comment line="978">
                    Increase the offset                    
                </comment>
                <comment line="986">
                    Parse last or only RDN, and store it in vector                    
                </comment>
                <comment line="991">
                    Store the vector elements as an array of RDNs
                     NOTE: It&apos;s only on output that little-endian ordering is used.                    
                </comment>
                <scope line="947"/>
                <declaration name="dnVector" type="List&lt;RDN&gt;" line="952"/>
                <declaration name="dnOffset" type="int" line="953"/>
                <declaration name="rdnString" type="String" line="954"/>
                <declaration name="searchOffset" type="int" line="956"/>
                <declaration name="rdnEnd" type="int" line="957"/>
                <scope line="958">
                    <scope line="966">
                        <declaration name="rdn" type="RDN" line="974"/>
                    </scope>
                </scope>
                <declaration name="rdn" type="RDN" line="987"/>
            </method>
            <method name="countQuotes" type="int" line="1002">
                <params>
                    <param name="string" type="String"/>
                    <param name="from" type="int"/>
                    <param name="to" type="int"/>
                </params>
                <declaration name="count" type="int" line="1003"/>
                <scope line="1005">
                    <scope line="1007"/>
                </scope>
            </method>
            <method name="escaped" type="boolean" line="1016">
                <params>
                    <param name="rdnEnd" type="int"/>
                    <param name="searchOffset" type="int"/>
                    <param name="dnString" type="String"/>
                </params>
                <comment line="1021">
                    case 1:
                      \,                    
                </comment>
                <comment line="1029">
                    case 2:
                      foo\,                    
                </comment>
                <comment line="1037">
                    case 3:
                      foo\\\\\,                    
                </comment>
                <comment line="1041">
                    back up to last backSlash                    
                </comment>
                <comment line="1044">
                    count consecutive backslashes                    
                </comment>
                <comment line="1049">
                    if count is odd, then rdnEnd is escaped                    
                </comment>
                <scope line="1018"/>
                <scope line="1026"/>
                <scope line="1034">
                    <declaration name="count" type="int" line="1039"/>
                    <scope line="1041">
                        <scope line="1042"/>
                    </scope>
                </scope>
                <scope line="1051"/>
            </method>
            <method name="generateDN" type="void" line="1063">
                <scope line="1064"/>
                <declaration name="sb" type="StringBuilder" line="1069"/>
                <scope line="1070">
                    <scope line="1071">
                        <scope line="1072"/>
                    </scope>
                </scope>
            </method>
            <method name="generateRFC1779DN" type="String" line="1090">
                <params>
                    <param name="oidMap" type="Map<String,String>"/>
                </params>
                <scope line="1091"/>
                <declaration name="sb" type="StringBuilder" line="1095"/>
                <scope line="1096">
                    <scope line="1097">
                        <scope line="1098"/>
                    </scope>
                </scope>
            </method>
            <javadoc line="1107">
                                
            </javadoc>
            <method name="intern" type="ObjectIdentifier" line="1113">
                <params>
                    <param name="oid" type="ObjectIdentifier"/>
                </params>
                <comment line="1110">
                    Maybe return a preallocated OID, to reduce storage costs
                     and speed recognition of common X.500 attributes.                    
                </comment>
                <declaration name="interned" type="ObjectIdentifier" line="1114"/>
                <scope line="1115"/>
            </method>
            <declaration name="internedOIDs" type="Map&lt;ObjectIdentifier,ObjectIdentifier&gt;" line="1122"/>
            <declaration name="commonName_data" type="int" line="1130"/>
            <declaration name="SURNAME_DATA" type="int" line="1131"/>
            <declaration name="SERIALNUMBER_DATA" type="int" line="1132"/>
            <declaration name="countryName_data" type="int" line="1133"/>
            <declaration name="localityName_data" type="int" line="1134"/>
            <declaration name="stateName_data" type="int" line="1135"/>
            <declaration name="streetAddress_data" type="int" line="1136"/>
            <declaration name="orgName_data" type="int" line="1137"/>
            <declaration name="orgUnitName_data" type="int" line="1138"/>
            <declaration name="title_data" type="int" line="1139"/>
            <declaration name="GIVENNAME_DATA" type="int" line="1140"/>
            <declaration name="INITIALS_DATA" type="int" line="1141"/>
            <declaration name="GENERATIONQUALIFIER_DATA" type="int" line="1142"/>
            <declaration name="DNQUALIFIER_DATA" type="int" line="1143"/>
            <declaration name="ipAddress_data" type="int" line="1145"/>
            <declaration name="DOMAIN_COMPONENT_DATA" type="int" line="1146"/>
            <declaration name="userid_data" type="int" line="1148"/>
            <declaration name="commonName_oid" type="ObjectIdentifier" line="1152"/>
            <declaration name="countryName_oid" type="ObjectIdentifier" line="1153"/>
            <declaration name="localityName_oid" type="ObjectIdentifier" line="1154"/>
            <declaration name="orgName_oid" type="ObjectIdentifier" line="1155"/>
            <declaration name="orgUnitName_oid" type="ObjectIdentifier" line="1156"/>
            <declaration name="stateName_oid" type="ObjectIdentifier" line="1157"/>
            <declaration name="streetAddress_oid" type="ObjectIdentifier" line="1158"/>
            <declaration name="title_oid" type="ObjectIdentifier" line="1159"/>
            <declaration name="DNQUALIFIER_OID" type="ObjectIdentifier" line="1160"/>
            <declaration name="SURNAME_OID" type="ObjectIdentifier" line="1161"/>
            <declaration name="GIVENNAME_OID" type="ObjectIdentifier" line="1162"/>
            <declaration name="INITIALS_OID" type="ObjectIdentifier" line="1163"/>
            <declaration name="GENERATIONQUALIFIER_OID" type="ObjectIdentifier" line="1164"/>
            <declaration name="ipAddress_oid" type="ObjectIdentifier" line="1165"/>
            <declaration name="DOMAIN_COMPONENT_OID" type="ObjectIdentifier" line="1166"/>
            <declaration name="userid_oid" type="ObjectIdentifier" line="1167"/>
            <declaration name="SERIALNUMBER_OID" type="ObjectIdentifier" line="1168"/>
            <scope line="1170"/>
            <javadoc line="1239">
                Return constraint type:&lt;ul&gt;
                  &lt;li&gt;NAME_DIFF_TYPE = -1: input name is different type from this name
                  (i.e. does not constrain)
                  &lt;li&gt;NAME_MATCH = 0: input name matches this name
                  &lt;li&gt;NAME_NARROWS = 1: input name narrows this name
                  &lt;li&gt;NAME_WIDENS = 2: input name widens this name
                  &lt;li&gt;NAME_SAME_TYPE = 3: input name does not match or narrow this name,
                  &amp;       but is same type
                  &lt;/ul&gt;.  These results are used in checking NameConstraints during
                  certification path verification.                
                <param>
                    inputName to be checked for being constrained                    
                </param>
                <returns>
                    constraint type above                    
                </returns>
                <throws>
                    UnsupportedOperationException if name is not exact match, but
                      narrowing and widening are not supported for this name type.                    
                </throws>
            </javadoc>
            <method name="constrains" type="int" line="1257">
                <params>
                    <param name="inputName" type="GeneralNameInterface"/>
                </params>
                <comment line="1264">
                    type == NAME_DIRECTORY                    
                </comment>
                <declaration name="constraintType" type="int" line="1258"/>
                <scope line="1259"/>
                <scope line="1261"/>
                <scope line="1263">
                    <declaration name="inputX500" type="X500Name" line="1264"/>
                    <scope line="1265"/>
                    <scope line="1267"/>
                    <scope line="1269"/>
                    <scope line="1271"/>
                    <scope line="1273"/>
                    <scope line="1275"/>
                </scope>
            </method>
            <javadoc line="1282">
                Compares this name with another and determines if
                  it is within the subtree of the other. Useful for
                  checking against the name constraints extension.                
                <return>
                    true iff this name is within the subtree of other.                    
                </return>
            </javadoc>
            <method name="isWithinSubtree" type="boolean" line="1289">
                <params>
                    <param name="other" type="X500Name"/>
                </params>
                <scope line="1290"/>
                <scope line="1293"/>
                <scope line="1296"/>
                <scope line="1299"/>
                <scope line="1302"/>
                <scope line="1305">
                    <scope line="1306"/>
                </scope>
            </method>
            <javadoc line="1313">
                Return subtree depth of this name for purposes of determining
                  NameConstraints minimum and maximum bounds and for calculating
                  path lengths in name subtrees.                
                <returns>
                    distance of name from root                    
                </returns>
                <throws>
                    UnsupportedOperationException if not supported for this name type                    
                </throws>
            </javadoc>
            <method name="subtreeDepth" type="int" line="1321"/>
            <javadoc line="1325">
                Return lowest common ancestor of this name and other name                
                <param>
                    other another X500Name                    
                </param>
                <return>
                    X500Name of lowest common ancestor; null if none                    
                </return>
            </javadoc>
            <method name="commonAncestor" type="X500Name" line="1331">
                <params>
                    <param name="other" type="X500Name"/>
                </params>
                <comment line="1344">
                    Compare names from highest RDN down the naming tree
                    Note that these are stored in RDN[0]...                    
                </comment>
                <comment line="1357">
                    Copy matching RDNs into new RDN array                    
                </comment>
                <scope line="1333"/>
                <declaration name="otherLen" type="int" line="1336"/>
                <declaration name="thisLen" type="int" line="1337"/>
                <scope line="1338"/>
                <declaration name="minLen" type="int" line="1341"/>
                <declaration name="i" type="int" line="1345"/>
                <scope line="1346">
                    <scope line="1347">
                        <scope line="1348"/>
                        <scope line="1350"/>
                    </scope>
                </scope>
                <declaration name="ancestor" type="RDN[]" line="1357"/>
                <scope line="1358"/>
                <declaration name="commonAncestor" type="X500Name" line="1362"/>
                <scope line="1363"/>
                <scope line="1365"/>
            </method>
            <declaration name="principalConstructor" type="Constructor" line="1371"/>
            <javadoc line="1371">
                Constructor object for use by asX500Principal().                
            </javadoc>
            <declaration name="principalField" type="Field" line="1376"/>
            <javadoc line="1376">
                Field object for use by asX500Name().                
            </javadoc>
            <javadoc line="1381">
                Retrieve the Constructor and Field we need for reflective access
                  and make them accessible.                
            </javadoc>
            <scope line="1385">
                <anonymous_class line="1387">
                    <method name="run" type="Object[]" line="1388">
                        <declaration name="pClass" type="Class" line="1389"/>
                        <declaration name="args" type="Class[]" line="1390"/>
                        <declaration name="cons" type="Constructor" line="1391"/>
                        <declaration name="field" type="Field" line="1393"/>
                    </method>
                </anonymous_class>
                <declaration name="pa" type="PrivilegedExceptionAction&lt;Object[]&gt;" line="1386"/>
                <scope line="1398">
                    <declaration name="result" type="Object[]" line="1399"/>
                </scope>
                <scope line="1402"/>
            </scope>
            <javadoc line="1408">
                Get an X500Principal backed by this X500Name.
                  Note that we are using privileged reflection to access the hidden
                  package private constructor in X500Principal.                
            </javadoc>
            <method name="asX500Principal" type="X500Principal" line="1414">
                <scope line="1415">
                    <scope line="1416">
                        <declaration name="args" type="Object[]" line="1417"/>
                    </scope>
                    <scope line="1420"/>
                </scope>
            </method>
            <javadoc line="1427">
                Get the X500Name contained in the given X500Principal.
                  Note that the X500Name is retrieved using reflection.                
            </javadoc>
            <method name="asX500Name" type="X500Name" line="1432">
                <params>
                    <param name="p" type="X500Principal"/>
                </params>
                <scope line="1433">
                    <declaration name="name" type="X500Name" line="1434"/>
                </scope>
                <scope line="1437"/>
            </method>
        </class>
    </source>