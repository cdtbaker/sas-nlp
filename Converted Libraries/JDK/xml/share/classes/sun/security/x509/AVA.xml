<?xml version="1.0" encoding="UTF-8"?>
    <source package="sun.security.x509">
        <import package="java.io.ByteArrayOutputStream"/>
        <import package="java.io.IOException"/>
        <import package="java.io.OutputStream"/>
        <import package="java.io.Reader"/>
        <import package="java.security.AccessController"/>
        <import package="java.text.Normalizer"/>
        <import package="java.util"/>
        <import package="sun.security.action.GetBooleanAction"/>
        <import package="sun.security.util"/>
        <import package="sun.security.pkcs.PKCS9Attribute"/>
        <class name="AVA" line="41">
            <comment line="65">
                See CR 6391482: if enabled this flag preserves the old but incorrect                
            </comment>
            <comment line="66">
                PrintableString encoding for DomainComponent. It may need to be set to                
            </comment>
            <comment line="67">
                avoid breaking preexisting certificates generated with sun.security APIs.                
            </comment>
            <comment line="86">
                currently not private, accessed directly from RDN                
            </comment>
            <comment line="90">
                If the value has any of these characters in it, it must be quoted.
                 Backslash and quote characters must also be individually escaped.
                 Leading and trailing spaces, also multiple internal spaces, also
                 call for quoting the whole string.                
            </comment>
            <comment line="98">
                In RFC2253, if the value has any of these characters in it, it
                 must be quoted by a preceding \.                
            </comment>
            <comment line="104">
                includes special chars from RFC1779 and RFC2253, as well as &apos; &apos;                
            </comment>
            <comment line="109">
                Values that aren&apos;t printable strings are emitted as BER-encoded
                 hex data.                
            </comment>
            <comment line="646">
                AVAs are encoded as a SEQUENCE of two elements.                
            </comment>
            <comment line="1012">
                Return true if DerValue can be represented as a String.                
            </comment>
            <implements interface="DerEncoder"/>
            <javadoc line="41">
                X.500 Attribute-Value-Assertion (AVA):  an attribute, as identified by
                  some attribute ID, has some particular value.  Values are as a rule ASN.1
                  printable strings.  A conventional set of type IDs is recognized when
                  parsing (and generating) RFC 1779 or RFC 2253 syntax strings.
                  &lt;P&gt;AVAs are components of X.500 relative names.  Think of them as being
                  individual fields of a database record.  The attribute ID is how you
                  identify the field, and the value is part of a particular record.
                  &lt;p&gt;
                  Note that instances of this class are immutable.                
                <see>
                    X500Name                    
                </see>
                <see>
                    RDN                    
                </see>
                <author>
                    David Brownell                    
                </author>
                <author>
                    Amit Kapoor                    
                </author>
                <author>
                    Hemma Prafullchandra                    
                </author>
            </javadoc>
            <declaration name="debug" type="Debug" line="63"/>
            <declaration name="PRESERVE_OLD_DC_ENCODING" type="boolean" line="67"/>
            <declaration name="DEFAULT" type="int" line="71"/>
            <javadoc line="71">
                DEFAULT format allows both RFC1779 and RFC2253 syntax and
                  additional keywords.                
            </javadoc>
            <declaration name="RFC1779" type="int" line="76"/>
            <javadoc line="76">
                RFC1779 specifies format according to RFC1779.                
            </javadoc>
            <declaration name="RFC2253" type="int" line="80"/>
            <javadoc line="80">
                RFC2253 specifies format according to RFC2253.                
            </javadoc>
            <declaration name="oid" type="ObjectIdentifier" line="86"/>
            <declaration name="value" type="DerValue" line="87"/>
            <declaration name="specialChars" type="String" line="95"/>
            <declaration name="specialChars2253" type="String" line="101"/>
            <declaration name="specialCharsAll" type="String" line="106"/>
            <declaration name="hexDigits" type="String" line="112"/>
            <method name="AVA" type="constructor" line="114">
                <params>
                    <param name="type" type="ObjectIdentifier"/>
                    <param name="val" type="DerValue"/>
                </params>
                <scope line="115"/>
            </method>
            <javadoc line="122">
                Parse an RFC 1779 or RFC 2253 style AVA string:  CN=fee fie foe fum
                  or perhaps with quotes.  Not all defined AVA tags are supported;
                  of current note are X.400 related ones (PRMD, ADMD, etc).
                  This terminates at unescaped AVA separators (&quot;+&quot;) or RDN
                  separators (&quot;,&quot;, &quot;;&quot;), or DN terminators (&quot;&gt;&quot;), and removes
                  cosmetic whitespace at the end of values.                
            </javadoc>
            <method name="AVA" type="constructor" line="131">
                <params>
                    <param name="in" type="Reader"/>
                </params>
            </method>
            <javadoc line="135">
                Parse an RFC 1779 or RFC 2253 style AVA string:  CN=fee fie foe fum
                  or perhaps with quotes. Additional keywords can be specified in the
                  keyword/OID map.
                  This terminates at unescaped AVA separators (&quot;+&quot;) or RDN
                  separators (&quot;,&quot;, &quot;;&quot;), or DN terminators (&quot;&gt;&quot;), and removes
                  cosmetic whitespace at the end of values.                
            </javadoc>
            <method name="AVA" type="constructor" line="144">
                <params>
                    <param name="in" type="Reader"/>
                    <param name="keywordMap" type="Map<String,String>"/>
                </params>
            </method>
            <javadoc line="148">
                Parse an AVA string formatted according to format.
                  XXX format RFC1779 should only allow RFC1779 syntax but is
                  actually DEFAULT with RFC1779 keywords.                
            </javadoc>
            <method name="AVA" type="constructor" line="154">
                <params>
                    <param name="in" type="Reader"/>
                    <param name="format" type="int"/>
                </params>
            </method>
            <javadoc line="158">
                Parse an AVA string formatted according to format.
                  XXX format RFC1779 should only allow RFC1779 syntax but is
                  actually DEFAULT with RFC1779 keywords.                
                <param>
                    in Reader containing AVA String                    
                </param>
                <param>
                    format parsing format                    
                </param>
                <param>
                    keywordMap a Map where a keyword String maps to a corresponding
                      OID String. Each AVA keyword will be mapped to the corresponding OID.
                      If an entry does not exist, it will fallback to the builtin
                      keyword/OID mapping.                    
                </param>
                <throws>
                    IOException if the AVA String is not valid in the specified
                      standard or an OID String from the keywordMap is improperly formatted                    
                </throws>
            </javadoc>
            <method name="AVA" type="constructor" line="174">
                <params>
                    <param name="in" type="Reader"/>
                    <param name="format" type="int"/>
                    <param name="keywordMap" type="Map<String,String>"/>
                </params>
                <comment line="175">
                    assume format is one of DEFAULT, RFC1779, RFC2253                    
                </comment>
                <comment line="180">
                    First get the keyword indicating the attribute&apos;s type,
                     and map it to the appropriate OID.                    
                </comment>
                <comment line="194">
                    Now parse the value.  &quot;#hex&quot;, a quoted string, or a string
                     terminated by &quot;+&quot;, &quot;,&quot;, &quot;;&quot;, &quot;&gt;&quot;.  Whitespace before or after
                     the value is stripped away unless format is RFC2253.                    
                </comment>
                <comment line="201">
                    read next character                    
                </comment>
                <comment line="208">
                    read next character skipping whitespace                    
                </comment>
                <comment line="214">
                    empty value                    
                </comment>
                <declaration name="temp" type="StringBuilder" line="177"/>
                <declaration name="c" type="int" line="178"/>
                <scope line="184">
                    <scope line="186"/>
                </scope>
                <scope line="200">
                    <scope line="203"/>
                </scope>
                <scope line="207">
                    <scope line="209"/>
                </scope>
                <scope line="213"/>
                <scope line="219"/>
                <scope line="221"/>
                <scope line="223"/>
            </method>
            <javadoc line="228">
                Get the ObjectIdentifier of this AVA.                
            </javadoc>
            <method name="getObjectIdentifier" type="ObjectIdentifier" line="231"/>
            <javadoc line="235">
                Get the value of this AVA as a DerValue.                
            </javadoc>
            <method name="getDerValue" type="DerValue" line="238"/>
            <javadoc line="242">
                Get the value of this AVA as a String.                
                <exception>
                    RuntimeException if we could not obtain the string form
                      (should not occur)                    
                </exception>
            </javadoc>
            <method name="getValueString" type="String" line="248">
                <comment line="256">
                    should not occur                    
                </comment>
                <scope line="249">
                    <declaration name="s" type="String" line="250"/>
                    <scope line="251"/>
                </scope>
                <scope line="255"/>
            </method>
            <method name="parseHexString" type="DerValue" line="262">
                <params>
                    <param name="in" type="Reader"/>
                    <param name="format" type="int"/>
                </params>
                <comment line="291">
                    throw exception if no hex digits                    
                </comment>
                <comment line="296">
                    throw exception if odd number of hex digits                    
                </comment>
                <declaration name="c" type="int" line="264"/>
                <declaration name="baos" type="ByteArrayOutputStream" line="265"/>
                <declaration name="b" type="byte" line="266"/>
                <declaration name="cNdx" type="int" line="267"/>
                <scope line="268">
                    <scope line="271"/>
                    <declaration name="cVal" type="int" line="275"/>
                    <scope line="277"/>
                    <scope line="282"/>
                    <scope line="285"/>
                </scope>
                <scope line="292"/>
                <scope line="297"/>
            </method>
            <method name="parseQuotedString" type="DerValue" line="305">
                <params>
                    <param name="in" type="Reader"/>
                    <param name="temp" type="StringBuilder"/>
                </params>
                <comment line="307">
                    RFC1779 specifies that an entire RDN may be enclosed in double                    
                </comment>
                <comment line="308">
                    quotes. In this case the syntax is any sequence of                    
                </comment>
                <comment line="309">
                    backslash-specialChar, backslash-backslash,                    
                </comment>
                <comment line="310">
                    backslash-doublequote, or character other than backslash or                    
                </comment>
                <comment line="311">
                    doublequote.                    
                </comment>
                <comment line="320">
                    check for embedded hex pairs                    
                </comment>
                <comment line="324">
                    always encode AVAs with embedded hex as UTF8                    
                </comment>
                <comment line="327">
                    append consecutive embedded hex                    
                </comment>
                <comment line="328">
                    as single string later                    
                </comment>
                <comment line="342">
                    add embedded hex bytes before next char                    
                </comment>
                <comment line="349">
                    check for non-PrintableString chars                    
                </comment>
                <comment line="355">
                    add trailing embedded hex bytes                    
                </comment>
                <comment line="370">
                    encode as PrintableString unless value contains                    
                </comment>
                <comment line="371">
                    non-PrintableString chars                    
                </comment>
                <comment line="375">
                    EmailAddress and DomainComponent must be IA5String                    
                </comment>
                <declaration name="c" type="int" line="312"/>
                <declaration name="embeddedHex" type="List&lt;Byte&gt;" line="314"/>
                <declaration name="isPrintableString" type="boolean" line="315"/>
                <scope line="316">
                    <scope line="317">
                        <declaration name="hexByte" type="Byte" line="321"/>
                        <scope line="322"/>
                        <scope line="335"/>
                    </scope>
                    <scope line="343">
                        <declaration name="hexString" type="String" line="344"/>
                    </scope>
                </scope>
                <scope line="356">
                    <declaration name="hexString" type="String" line="357"/>
                </scope>
                <scope line="362"/>
                <scope line="365"/>
                <scope line="374"/>
                <scope line="378"/>
                <scope line="380"/>
            </method>
            <method name="parseString" type="DerValue" line="387">
                <params>
                    <param name="in" type="Reader"/>
                    <param name="c" type="int"/>
                    <param name="format" type="int"/>
                    <param name="temp" type="StringBuilder"/>
                </params>
                <comment line="400">
                    check for embedded hex pairs                    
                </comment>
                <comment line="404">
                    always encode AVAs with embedded hex as UTF8                    
                </comment>
                <comment line="407">
                    append consecutive embedded hex                    
                </comment>
                <comment line="408">
                    as single string later                    
                </comment>
                <comment line="415">
                    check if character was improperly escaped                    
                </comment>
                <comment line="428">
                    only leading/trailing space can be escaped                    
                </comment>
                <comment line="436">
                    only leading &apos;#&apos; can be escaped                    
                </comment>
                <comment line="451">
                    check if character should have been escaped                    
                </comment>
                <comment line="461">
                    add embedded hex bytes before next char                    
                </comment>
                <comment line="463">
                    add space(s) before embedded hex bytes                    
                </comment>
                <comment line="474">
                    check for non-PrintableString chars                    
                </comment>
                <comment line="477">
                    do not add non-escaped spaces yet                    
                </comment>
                <comment line="478">
                    (non-escaped trailing spaces are ignored)                    
                </comment>
                <comment line="481">
                    add space(s)                    
                </comment>
                <comment line="497">
                    add trailing embedded hex bytes                    
                </comment>
                <comment line="504">
                    encode as PrintableString unless value contains                    
                </comment>
                <comment line="505">
                    non-PrintableString chars                    
                </comment>
                <comment line="509">
                    EmailAddress and DomainComponent must be IA5String                    
                </comment>
                <declaration name="embeddedHex" type="List&lt;Byte&gt;" line="389"/>
                <declaration name="isPrintableString" type="boolean" line="390"/>
                <declaration name="escape" type="boolean" line="391"/>
                <declaration name="leadingChar" type="boolean" line="392"/>
                <declaration name="spaceCount" type="int" line="393"/>
                <scope line="394">
                    <scope line="396">
                        <declaration name="hexByte" type="Byte" line="401"/>
                        <scope line="402"/>
                        <scope line="420"/>
                        <scope line="426">
                            <scope line="427">
                                <scope line="429"/>
                            </scope>
                            <scope line="435">
                                <scope line="437"/>
                            </scope>
                            <scope line="442"/>
                        </scope>
                    </scope>
                    <scope line="450">
                        <scope line="452">
                            <scope line="453"/>
                        </scope>
                    </scope>
                    <scope line="462">
                        <scope line="464"/>
                        <declaration name="hexString" type="String" line="469"/>
                    </scope>
                    <scope line="476"/>
                    <scope line="480">
                        <scope line="482"/>
                    </scope>
                </scope>
                <scope line="492"/>
                <scope line="498">
                    <declaration name="hexString" type="String" line="499"/>
                </scope>
                <scope line="508"/>
                <scope line="511"/>
                <scope line="513"/>
            </method>
            <method name="getEmbeddedHexPair" type="Byte" line="519">
                <params>
                    <param name="c1" type="int"/>
                    <param name="in" type="Reader"/>
                </params>
                <scope line="521">
                    <declaration name="c2" type="int" line="522"/>
                    <scope line="525">
                        <declaration name="hi" type="int" line="526"/>
                        <declaration name="lo" type="int" line="527"/>
                    </scope>
                    <scope line="529"/>
                </scope>
            </method>
            <method name="getEmbeddedHexString" type="String" line="538">
                <params>
                    <param name="hexList" type="List<Byte>"/>
                </params>
                <declaration name="n" type="int" line="539"/>
                <declaration name="hexBytes" type="byte[]" line="540"/>
                <scope line="541"/>
            </method>
            <method name="isTerminator" type="boolean" line="547">
                <params>
                    <param name="ch" type="int"/>
                    <param name="format" type="int"/>
                </params>
            </method>
            <method name="readChar" type="int" line="561">
                <params>
                    <param name="in" type="Reader"/>
                    <param name="errMsg" type="String"/>
                </params>
                <declaration name="c" type="int" line="562"/>
                <scope line="563"/>
            </method>
            <method name="trailingSpace" type="boolean" line="569">
                <params>
                    <param name="in" type="Reader"/>
                </params>
                <comment line="574">
                    oh well                    
                </comment>
                <comment line="577">
                    make readAheadLimit huge -                    
                </comment>
                <comment line="578">
                    in practice, AVA was passed a StringReader from X500Name,                    
                </comment>
                <comment line="579">
                    and StringReader ignores readAheadLimit anyways                    
                </comment>
                <declaration name="trailing" type="boolean" line="571"/>
                <scope line="573"/>
                <scope line="576">
                    <scope line="581">
                        <declaration name="nextChar" type="int" line="582"/>
                        <scope line="583"/>
                        <scope line="586"/>
                        <scope line="588">
                            <declaration name="followingChar" type="int" line="589"/>
                            <scope line="590"/>
                        </scope>
                        <scope line="594"/>
                    </scope>
                </scope>
            </method>
            <method name="AVA" type="constructor" line="605">
                <params>
                    <param name="derval" type="DerValue"/>
                </params>
                <comment line="606">
                    Individual attribute value assertions are SEQUENCE of two values.                    
                </comment>
                <comment line="607">
                    That&apos;d be a &quot;struct&quot; outside of ASN.1.                    
                </comment>
                <scope line="608"/>
                <scope line="614"/>
            </method>
            <method name="AVA" type="constructor" line="620">
                <params>
                    <param name="in" type="DerInputStream"/>
                </params>
            </method>
            <method name="equals" type="boolean" line="624">
                <params>
                    <param name="obj" type="Object"/>
                </params>
                <scope line="625"/>
                <scope line="628"/>
                <declaration name="other" type="AVA" line="631"/>
            </method>
            <javadoc line="636">
                Returns a hashcode for this AVA.                
                <return>
                    a hashcode for this AVA.                    
                </return>
            </javadoc>
            <method name="hashCode" type="int" line="641"/>
            <method name="encode" type="void" line="648">
                <params>
                    <param name="out" type="DerOutputStream"/>
                </params>
            </method>
            <javadoc line="652">
                DER encode this object onto an output stream.
                  Implements the &lt;code&gt;DerEncoder&lt;/code&gt; interface.                
                <param>
                    outthe output stream on which to write the DER encoding.                    
                </param>
                <exception>
                    IOException on encoding error.                    
                </exception>
            </javadoc>
            <method name="derEncode" type="void" line="661">
                <params>
                    <param name="out" type="OutputStream"/>
                </params>
                <declaration name="tmp" type="DerOutputStream" line="662"/>
                <declaration name="tmp2" type="DerOutputStream" line="663"/>
            </method>
            <method name="toKeyword" type="String" line="671">
                <params>
                    <param name="format" type="int"/>
                    <param name="oidMap" type="Map<String,String>"/>
                </params>
            </method>
            <javadoc line="675">
                Returns a printable form of this attribute, using RFC 1779
                  syntax for individual attribute/value assertions.                
            </javadoc>
            <method name="toString" type="String" line="679"/>
            <javadoc line="684">
                Returns a printable form of this attribute, using RFC 1779
                  syntax for individual attribute/value assertions. It only
                  emits standardised keywords.                
            </javadoc>
            <method name="toRFC1779String" type="String" line="689"/>
            <javadoc line="693">
                Returns a printable form of this attribute, using RFC 1779
                  syntax for individual attribute/value assertions. It
                  emits standardised keywords, as well as keywords contained in the
                  OID/keyword map.                
            </javadoc>
            <method name="toRFC1779String" type="String" line="699">
                <params>
                    <param name="oidMap" type="Map<String,String>"/>
                </params>
            </method>
            <javadoc line="703">
                Returns a printable form of this attribute, using RFC 2253
                  syntax for individual attribute/value assertions. It only
                  emits standardised keywords.                
            </javadoc>
            <method name="toRFC2253String" type="String" line="708"/>
            <javadoc line="712">
                Returns a printable form of this attribute, using RFC 2253
                  syntax for individual attribute/value assertions. It
                  emits standardised keywords, as well as keywords contained in the
                  OID/keyword map.                
            </javadoc>
            <method name="toRFC2253String" type="String" line="718">
                <params>
                    <param name="oidMap" type="Map<String,String>"/>
                </params>
                <comment line="719">
                    Section 2.3: The AttributeTypeAndValue is encoded as the string
                     representation of the AttributeType, followed by an equals character
                     (&apos;=&apos; ASCII 61), followed by the string representation of the
                     AttributeValue. The encoding of the AttributeValue is given in
                     section 2.4.                    
                </comment>
                <comment line="730">
                    Section 2.4: Converting an AttributeValue from ASN.1 to a String.
                     If the AttributeValue is of a type which does not have a string
                     representation defined for it, then it is simply encoded as an
                     octothorpe character (&apos;#&apos; ASCII 35) followed by the hexadecimal
                     representation of each of the bytes of the BER encoding of the X.500
                     AttributeValue.  This form SHOULD be used if the AttributeType is of
                     the dotted-decimal form.                    
                </comment>
                <comment line="755">
                    2.4 (cont): Otherwise, if the AttributeValue is of a type which
                     has a string representation, the value is converted first to a
                     UTF-8 string according to its syntax specification.
                    
                     NOTE: this implementation only emits DirectoryStrings of the
                     types returned by isDerString().                    
                </comment>
                <comment line="770">
                    2.4 (cont): If the UTF-8 string does not have any of the
                     following characters which need escaping, then that string can be
                     used as the string representation of the value.
                    
                       o   a space or &quot;#&quot; character occurring at the beginning of the
                           string
                       o   a space character occurring at the end of the string
                       o   one of the characters &quot;,&quot;, &quot;+&quot;, &quot;&quot;&quot;, &quot;\&quot;, &quot;&lt;&quot;, &quot;&gt;&quot; or &quot;;&quot;
                    
                     Implementations MAY escape other characters.
                    
                     NOTE: this implementation also recognizes &quot;=&quot; and &quot;#&quot; as
                     characters which need escaping, and null which is escaped as
                     &apos;\00&apos; (see RFC 4514).
                    
                     If a character to be escaped is one of the list shown above, then
                     it is prefixed by a backslash (&apos;\&apos; ASCII 92).
                    
                     Otherwise the character to be escaped is replaced by a backslash
                     and two hex digits, which form a single byte in the code of the
                     character.                    
                </comment>
                <comment line="801">
                    escape escapees                    
                </comment>
                <comment line="806">
                    append printable/escaped char                    
                </comment>
                <comment line="810">
                    escape null character                    
                </comment>
                <comment line="815">
                    embed non-printable/non-escaped char                    
                </comment>
                <comment line="816">
                    as escaped hex pairs for debugging                    
                </comment>
                <comment line="835">
                    append non-printable/non-escaped char                    
                </comment>
                <comment line="843">
                    Find leading and trailing whitespace.                    
                </comment>
                <comment line="844">
                    index of first char that is not leading whitespace                    
                </comment>
                <comment line="850">
                    index of last char that is not trailing whitespace                    
                </comment>
                <comment line="857">
                    escape leading and trailing whitespace                    
                </comment>
                <declaration name="typeAndValue" type="StringBuilder" line="726"/>
                <scope line="741">
                    <declaration name="data" type="byte[]" line="742"/>
                    <scope line="743"/>
                    <scope line="745"/>
                    <scope line="749">
                        <declaration name="b" type="byte" line="750"/>
                    </scope>
                </scope>
                <scope line="754">
                    <declaration name="valStr" type="String" line="763"/>
                    <scope line="764"/>
                    <scope line="766"/>
                    <declaration name="escapees" type="String" line="793"/>
                    <declaration name="sbuffer" type="StringBuilder" line="794"/>
                    <scope line="796">
                        <declaration name="c" type="char" line="797"/>
                        <scope line="799">
                            <scope line="802"/>
                        </scope>
                        <scope line="809"/>
                        <scope line="813">
                            <declaration name="valueBytes" type="byte[]" line="817"/>
                            <scope line="818"/>
                            <scope line="820"/>
                            <scope line="824">
                                <declaration name="hexChar" type="char" line="826"/>
                            </scope>
                        </scope>
                        <scope line="833"/>
                    </scope>
                    <declaration name="chars" type="char[]" line="840"/>
                    <declaration name="lead" type="int" line="844"/>
                    <scope line="845">
                        <scope line="846"/>
                    </scope>
                    <declaration name="trail" type="int" line="850"/>
                    <scope line="851">
                        <scope line="852"/>
                    </scope>
                    <scope line="858">
                        <declaration name="c" type="char" line="859"/>
                        <scope line="860"/>
                    </scope>
                </scope>
            </method>
            <method name="toRFC2253CanonicalString" type="String" line="870">
                <comment line="871">
                    Section 2.3: The AttributeTypeAndValue is encoded as the string
                     representation of the AttributeType, followed by an equals character
                     (&apos;=&apos; ASCII 61), followed by the string representation of the
                     AttributeValue. The encoding of the AttributeValue is given in
                     section 2.4.                    
                </comment>
                <comment line="883">
                    Section 2.4: Converting an AttributeValue from ASN.1 to a String.
                     If the AttributeValue is of a type which does not have a string
                     representation defined for it, then it is simply encoded as an
                     octothorpe character (&apos;#&apos; ASCII 35) followed by the hexadecimal
                     representation of each of the bytes of the BER encoding of the X.500
                     AttributeValue.  This form SHOULD be used if the AttributeType is of
                     the dotted-decimal form.                    
                </comment>
                <comment line="908">
                    2.4 (cont): Otherwise, if the AttributeValue is of a type which
                     has a string representation, the value is converted first to a
                     UTF-8 string according to its syntax specification.
                    
                     NOTE: this implementation only emits DirectoryStrings of the
                     types returned by isDerString().                    
                </comment>
                <comment line="923">
                    2.4 (cont): If the UTF-8 string does not have any of the
                     following characters which need escaping, then that string can be
                     used as the string representation of the value.
                    
                       o   a space or &quot;#&quot; character occurring at the beginning of the
                           string
                       o   a space character occurring at the end of the string
                    
                       o   one of the characters &quot;,&quot;, &quot;+&quot;, &quot;&quot;&quot;, &quot;\&quot;, &quot;&lt;&quot;, &quot;&gt;&quot; or &quot;;&quot;
                    
                     If a character to be escaped is one of the list shown above, then
                     it is prefixed by a backslash (&apos;\&apos; ASCII 92).
                    
                     Otherwise the character to be escaped is replaced by a backslash
                     and two hex digits, which form a single byte in the code of the
                     character.                    
                </comment>
                <comment line="952">
                    escape leading &apos;#&apos; and escapees                    
                </comment>
                <comment line="957">
                    convert multiple whitespace to single whitespace                    
                </comment>
                <comment line="963">
                    add single whitespace                    
                </comment>
                <comment line="967">
                    ignore subsequent consecutive whitespace                    
                </comment>
                <comment line="974">
                    embed non-printable/non-escaped char                    
                </comment>
                <comment line="975">
                    as escaped hex pairs for debugging                    
                </comment>
                <comment line="995">
                    append non-printable/non-escaped char                    
                </comment>
                <comment line="1002">
                    remove leading and trailing whitespace from value                    
                </comment>
                <declaration name="typeAndValue" type="StringBuilder" line="878"/>
                <scope line="894">
                    <declaration name="data" type="byte[]" line="895"/>
                    <scope line="896"/>
                    <scope line="898"/>
                    <scope line="902">
                        <declaration name="b" type="byte" line="903"/>
                    </scope>
                </scope>
                <scope line="907">
                    <declaration name="valStr" type="String" line="916"/>
                    <scope line="917"/>
                    <scope line="919"/>
                    <declaration name="escapees" type="String" line="941"/>
                    <declaration name="sbuffer" type="StringBuilder" line="942"/>
                    <declaration name="previousWhite" type="boolean" line="943"/>
                    <scope line="945">
                        <declaration name="c" type="char" line="946"/>
                        <scope line="950">
                            <scope line="953"/>
                            <scope line="958"/>
                            <scope line="961">
                                <scope line="962"/>
                                <scope line="966"/>
                            </scope>
                        </scope>
                        <scope line="972">
                            <declaration name="valueBytes" type="byte" line="979"/>
                            <scope line="980"/>
                            <scope line="982"/>
                            <scope line="986"/>
                        </scope>
                        <scope line="993"/>
                    </scope>
                </scope>
                <declaration name="canon" type="String" line="1006"/>
            </method>
            <method name="isDerString" type="boolean" line="1014">
                <params>
                    <param name="value" type="DerValue"/>
                    <param name="canonical" type="boolean"/>
                </params>
                <scope line="1015"/>
                <scope line="1023"/>
            </method>
            <method name="hasRFC2253Keyword" type="boolean" line="1038"/>
            <method name="toKeywordValueString" type="String" line="1042">
                <params>
                    <param name="keyword" type="String"/>
                </params>
                <comment line="1043">
                    Construct the value with as little copying and garbage
                     production as practical.  First the keyword (mandatory),
                     then the equals sign, finally the value.                    
                </comment>
                <comment line="1058">
                    rfc1779 specifies that attribute values associated                    
                </comment>
                <comment line="1059">
                    with non-standard keyword attributes may be represented                    
                </comment>
                <comment line="1060">
                    using the hex format below.  This will be used only                    
                </comment>
                <comment line="1061">
                    when the value is not a string type                    
                </comment>
                <comment line="1078">
                    Special characters (e.g. AVA list separators) cause strings
                     to need quoting, or at least escaping.  So do leading or
                     trailing spaces, and multiple internal spaces.                    
                </comment>
                <comment line="1088">
                    quote if leading whitespace or special chars                    
                </comment>
                <comment line="1095">
                    quote if multiple internal whitespace                    
                </comment>
                <comment line="1097">
                    escape &apos;&quot;&apos; and &apos;\&apos;                    
                </comment>
                <comment line="1113">
                    embed non-printable/non-escaped char                    
                </comment>
                <comment line="1114">
                    as escaped hex pairs for debugging                    
                </comment>
                <comment line="1118">
                    embed escaped hex pairs                    
                </comment>
                <comment line="1132">
                    append non-printable/non-escaped char                    
                </comment>
                <comment line="1139">
                    quote if trailing whitespace                    
                </comment>
                <comment line="1147">
                    Emit the string ... quote it if needed                    
                </comment>
                <declaration name="retval" type="StringBuilder" line="1048"/>
                <scope line="1053">
                    <declaration name="valStr" type="String" line="1054"/>
                    <scope line="1056">
                        <declaration name="data" type="byte" line="1063"/>
                        <scope line="1066"/>
                    </scope>
                    <scope line="1071">
                        <declaration name="quoteNeeded" type="boolean" line="1073"/>
                        <declaration name="sbuffer" type="StringBuilder" line="1074"/>
                        <declaration name="previousWhite" type="boolean" line="1075"/>
                        <declaration name="escapees" type="String" line="1076"/>
                        <scope line="1083">
                            <declaration name="c" type="char" line="1084"/>
                            <scope line="1086">
                                <scope line="1091"/>
                                <scope line="1096">
                                    <scope line="1098"/>
                                </scope>
                                <scope line="1102">
                                    <scope line="1103"/>
                                </scope>
                            </scope>
                            <scope line="1111">
                                <declaration name="valueBytes" type="byte[]" line="1119"/>
                                <scope line="1121">
                                    <declaration name="hexChar" type="char" line="1123"/>
                                </scope>
                            </scope>
                            <scope line="1130"/>
                        </scope>
                        <scope line="1140">
                            <declaration name="trailChar" type="char" line="1141"/>
                            <scope line="1142"/>
                        </scope>
                        <scope line="1148"/>
                        <scope line="1150"/>
                    </scope>
                </scope>
                <scope line="1154"/>
            </method>
        </class>
        <class name="AVAKeyword" line="1163">
            <comment line="65">
                See CR 6391482: if enabled this flag preserves the old but incorrect                
            </comment>
            <comment line="66">
                PrintableString encoding for DomainComponent. It may need to be set to                
            </comment>
            <comment line="67">
                avoid breaking preexisting certificates generated with sun.security APIs.                
            </comment>
            <comment line="86">
                currently not private, accessed directly from RDN                
            </comment>
            <comment line="90">
                If the value has any of these characters in it, it must be quoted.
                 Backslash and quote characters must also be individually escaped.
                 Leading and trailing spaces, also multiple internal spaces, also
                 call for quoting the whole string.                
            </comment>
            <comment line="98">
                In RFC2253, if the value has any of these characters in it, it
                 must be quoted by a preceding \.                
            </comment>
            <comment line="104">
                includes special chars from RFC1779 and RFC2253, as well as &apos; &apos;                
            </comment>
            <comment line="109">
                Values that aren&apos;t printable strings are emitted as BER-encoded
                 hex data.                
            </comment>
            <comment line="646">
                AVAs are encoded as a SEQUENCE of two elements.                
            </comment>
            <comment line="1012">
                Return true if DerValue can be represented as a String.                
            </comment>
            <javadoc line="1163">
                Helper class that allows conversion from String to ObjectIdentifier and
                  vice versa according to RFC1779, RFC2253, and an augmented version of
                  those standards.                
            </javadoc>
            <declaration name="oidMap" type="Map&lt;ObjectIdentifier,AVAKeyword&gt;" line="1170"/>
            <declaration name="keywordMap" type="Map&lt;String,AVAKeyword&gt;" line="1171"/>
            <declaration name="keyword" type="String" line="1173"/>
            <declaration name="oid" type="ObjectIdentifier" line="1174"/>
            <declaration name="rfc1779Compliant" type="boolean" line="1175"/>
            <method name="AVAKeyword" type="constructor" line="1178">
                <params>
                    <param name="keyword" type="String"/>
                    <param name="oid" type="ObjectIdentifier"/>
                    <param name="rfc1779Compliant" type="boolean"/>
                    <param name="rfc2253Compliant" type="boolean"/>
                </params>
                <comment line="1184">
                    register it                    
                </comment>
            </method>
            <method name="isCompliant" type="boolean" line="1189">
                <params>
                    <param name="standard" type="int"/>
                </params>
                <comment line="1198">
                    should not occur, internal error                    
                </comment>
            </method>
            <javadoc line="1203">
                Get an object identifier representing the specified keyword (or
                  string encoded object identifier) in the given standard.                
                <throws>
                    IOException If the keyword is not valid in the specified standard                    
                </throws>
            </javadoc>
            <method name="getOID" type="ObjectIdentifier" line="1210">
                <params>
                    <param name="keyword" type="String"/>
                    <param name="standard" type="int"/>
                </params>
            </method>
            <javadoc line="1215">
                Get an object identifier representing the specified keyword (or
                  string encoded object identifier) in the given standard.                
                <param>
                    keywordMap a Map where a keyword String maps to a corresponding
                      OID String. Each AVA keyword will be mapped to the corresponding OID.
                      If an entry does not exist, it will fallback to the builtin
                      keyword/OID mapping.                    
                </param>
                <throws>
                    IOException If the keyword is not valid in the specified standard
                      or the OID String to which a keyword maps to is improperly formatted.                    
                </throws>
            </javadoc>
            <method name="getOID" type="ObjectIdentifier" line="1228">
                <params>
                    <param name="keyword" type="String"/>
                    <param name="standard" type="int"/>
                    <param name="extraKeywordMap" type="Map<String,String>"/>
                </params>
                <comment line="1240">
                    check user-specified keyword map first, then fallback to built-in                    
                </comment>
                <comment line="1241">
                    map                    
                </comment>
                <comment line="1252">
                    no keyword found or not standard compliant, check if OID string                    
                </comment>
                <comment line="1254">
                    RFC1779 requires, DEFAULT allows OID. prefix                    
                </comment>
                <scope line="1231">
                    <scope line="1232"/>
                </scope>
                <scope line="1236"/>
                <declaration name="oidString" type="String" line="1242"/>
                <scope line="1243">
                    <declaration name="ak" type="AVAKeyword" line="1244"/>
                    <scope line="1245"/>
                </scope>
                <scope line="1248"/>
                <scope line="1255">
                    <scope line="1256"/>
                </scope>
                <scope line="1260">
                    <scope line="1261"/>
                </scope>
                <declaration name="number" type="boolean" line="1265"/>
                <scope line="1266">
                    <declaration name="ch" type="char" line="1267"/>
                    <scope line="1268"/>
                </scope>
                <scope line="1272"/>
            </method>
            <javadoc line="1278">
                Get a keyword for the given ObjectIdentifier according to standard.
                  If no keyword is available, the ObjectIdentifier is encoded as a
                  String.                
            </javadoc>
            <method name="getKeyword" type="String" line="1283">
                <params>
                    <param name="oid" type="ObjectIdentifier"/>
                    <param name="standard" type="int"/>
                </params>
            </method>
            <javadoc line="1288">
                Get a keyword for the given ObjectIdentifier according to standard.
                  Checks the extraOidMap for a keyword first, then falls back to the
                  builtin/default set. If no keyword is available, the ObjectIdentifier
                  is encoded as a String.                
            </javadoc>
            <method name="getKeyword" type="String" line="1295">
                <params>
                    <param name="oid" type="ObjectIdentifier"/>
                    <param name="standard" type="int"/>
                    <param name="extraOidMap" type="Map<String,String>"/>
                </params>
                <comment line="1297">
                    check extraOidMap first, then fallback to built-in map                    
                </comment>
                <comment line="1325">
                    no compliant keyword, use OID                    
                </comment>
                <declaration name="oidString" type="String" line="1298"/>
                <declaration name="keywordString" type="String" line="1299"/>
                <scope line="1300">
                    <declaration name="ak" type="AVAKeyword" line="1301"/>
                    <scope line="1302"/>
                </scope>
                <scope line="1305">
                    <scope line="1306"/>
                    <declaration name="c" type="char" line="1310"/>
                    <scope line="1311"/>
                    <scope line="1315">
                        <scope line="1318"/>
                    </scope>
                </scope>
                <scope line="1326"/>
                <scope line="1328"/>
            </method>
            <javadoc line="1333">
                Test if oid has an associated keyword in standard.                
            </javadoc>
            <method name="hasKeyword" type="boolean" line="1336">
                <params>
                    <param name="oid" type="ObjectIdentifier"/>
                    <param name="standard" type="int"/>
                </params>
                <declaration name="ak" type="AVAKeyword" line="1337"/>
                <scope line="1338"/>
            </method>
            <scope line="1344"/>
        </class>
    </source>