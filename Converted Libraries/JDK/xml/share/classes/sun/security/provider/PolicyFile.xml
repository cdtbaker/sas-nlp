<?xml version="1.0" encoding="UTF-8"?>
    <source package="sun.security.provider">
        <import package="java.io"/>
        <import package="java.lang.RuntimePermission"/>
        <import package="java.lang.reflect"/>
        <import package="java.lang.ref"/>
        <import package="java.net.MalformedURLException"/>
        <import package="java.net.URL"/>
        <import package="java.net.URI"/>
        <import package="java.util"/>
        <import package="java.util.Enumeration"/>
        <import package="java.util.Hashtable"/>
        <import package="java.util.List"/>
        <import package="java.util.StringTokenizer"/>
        <import package="java.util.PropertyPermission"/>
        <import package="java.util.ArrayList"/>
        <import package="java.util.ListIterator"/>
        <import package="java.util.WeakHashMap"/>
        <import package="java.text.MessageFormat"/>
        <import package="com.sun.security.auth.PrincipalComparator"/>
        <import package="java.security"/>
        <import package="java.security.cert.Certificate"/>
        <import package="java.security.cert.X509Certificate"/>
        <import package="javax.security.auth.PrivateCredentialPermission"/>
        <import package="javax.security.auth.Subject"/>
        <import package="javax.security.auth.x500.X500Principal"/>
        <import package="java.io.FilePermission"/>
        <import package="java.net.SocketPermission"/>
        <import package="java.net.NetPermission"/>
        <import package="java.util.PropertyPermission"/>
        <import package="java.util.concurrent.atomic.AtomicReference"/>
        <import package="sun.misc.JavaSecurityProtectionDomainAccess"/>
        <import package="sun.misc.JavaSecurityProtectionDomainAccess.ProtectionDomainCache"/>
        <import package="sun.misc.SharedSecrets"/>
        <import package="sun.security.util.Password"/>
        <import package="sun.security.util.PolicyUtil"/>
        <import package="sun.security.util.PropertyExpander"/>
        <import package="sun.security.util.Debug"/>
        <import package="sun.security.util.ResourcesMgr"/>
        <import package="sun.security.util.SecurityConstants"/>
        <import package="sun.net.www.ParseUtil"/>
        <class name="PolicyFile" line="79">
            <extends class="java.security.Policy"/>
            <comment line="302">
                contains the policy grant entries, PD cache, and alias mapping                
            </comment>
            <comment line="312">
                for use with the reflection API                
            </comment>
            <comment line="1732">
                Returns the signer certificates from the list of certificates
                 associated with the given code source.
                
                 The signer certificates are those certificates that were used
                 to verifysigned code originating from the codesource location.
                
                 This method assumes that in the given code source, each signer
                 certificate is followed by its supporting certificate chain
                 (which may be empty), and that the signer certificate and its
                 supporting certificate chain are ordered bottom-to-top
                 (i.e., with the signer certificate first and the (root) certificate
                 authority last).                
            </comment>
            <comment line="1851">
                Wrapper to return a canonical path that avoids calling getCanonicalPath()
                 with paths that are intended to match all entries in the directory                
            </comment>
            <javadoc line="79">
                This class represents a default implementation for
                  &lt;code&gt;java.security.Policy&lt;/code&gt;.
                  Note:
                  For backward compatibility with JAAS 1.0 it loads
                  both java.auth.policy and java.policy. However it
                  is recommended that java.auth.policy be not used
                  and the java.policy contain all grant entries including
                  that contain principal-based entries.
                  &lt;p&gt; This object stores the policy for entire Java runtime,
                  and is the amalgamation of multiple static policy
                  configurations that resides in files.
                  The algorithm for locating the policy file(s) and reading their
                  information into this &lt;code&gt;Policy&lt;/code&gt; object is:
                  &lt;ol&gt;
                  &lt;li&gt;
                  Loop through the &lt;code&gt;java.security.Security&lt;/code&gt; properties,
                  &lt;i&gt;policy.url.1&lt;/i&gt;, &lt;i&gt;policy.url.2&lt;/i&gt;, ...,
                  &lt;i&gt;policy.url.X&lt;/i&gt;&quot; and
                  &lt;i&gt;auth.policy.url.1&lt;/i&gt;, &lt;i&gt;auth.policy.url.2&lt;/i&gt;, ...,
                  &lt;i&gt;auth.policy.url.X&lt;/i&gt;&quot;.  These properties are set
                  in the Java security properties file, which is located in the file named
                  &amp;lt;JAVA_HOME&amp;gt;/lib/security/java.security.
                  &amp;lt;JAVA_HOME&amp;gt; refers to the value of the java.home system property,
                  and specifies the directory where the JRE is installed.
                  Each property value specifies a &lt;code&gt;URL&lt;/code&gt; pointing to a
                  policy file to be loaded.  Read in and load each policy.
                  &lt;i&gt;auth.policy.url&lt;/i&gt; is supported only for backward compatibility.
                  &lt;li&gt;
                  The &lt;code&gt;java.lang.System&lt;/code&gt; property &lt;i&gt;java.security.policy&lt;/i&gt;
                  may also be set to a &lt;code&gt;URL&lt;/code&gt; pointing to another policy file
                  (which is the case when a user uses the -D switch at runtime).
                  If this property is defined, and its use is allowed by the
                  security property file (the Security property,
                  &lt;i&gt;policy.allowSystemProperty&lt;/i&gt; is set to &lt;i&gt;true&lt;/i&gt;),
                  also load that policy.
                  &lt;li&gt;
                  The &lt;code&gt;java.lang.System&lt;/code&gt; property
                  &lt;i&gt;java.security.auth.policy&lt;/i&gt; may also be set to a
                  &lt;code&gt;URL&lt;/code&gt; pointing to another policy file
                  (which is the case when a user uses the -D switch at runtime).
                  If this property is defined, and its use is allowed by the
                  security property file (the Security property,
                  &lt;i&gt;policy.allowSystemProperty&lt;/i&gt; is set to &lt;i&gt;true&lt;/i&gt;),
                  also load that policy.
                  &lt;i&gt;java.security.auth.policy&lt;/i&gt; is supported only for backward
                  compatibility.
                  If the  &lt;i&gt;java.security.policy&lt;/i&gt; or
                  &lt;i&gt;java.security.auth.policy&lt;/i&gt; property is defined using
                  &quot;==&quot; (rather than &quot;=&quot;), then ignore all other specified
                  policies and only load this policy.
                  &lt;/ol&gt;
                  Each policy file consists of one or more grant entries, each of
                  which consists of a number of permission entries.
                  &lt;pre&gt;
                  grant signedBy &quot;&lt;b&gt;alias&lt;/b&gt;&quot;, codeBase &quot;&lt;b&gt;URL&lt;/b&gt;&quot;,
                  principal &lt;b&gt;principalClass&lt;/b&gt; &quot;&lt;b&gt;principalName&lt;/b&gt;&quot;,
                  principal &lt;b&gt;principalClass&lt;/b&gt; &quot;&lt;b&gt;principalName&lt;/b&gt;&quot;,
                  ... {
                  permission &lt;b&gt;Type&lt;/b&gt; &quot;&lt;b&gt;name&lt;/b&gt; &quot;&lt;b&gt;action&lt;/b&gt;&quot;,
                  signedBy &quot;&lt;b&gt;alias&lt;/b&gt;&quot;;
                  permission &lt;b&gt;Type&lt;/b&gt; &quot;&lt;b&gt;name&lt;/b&gt; &quot;&lt;b&gt;action&lt;/b&gt;&quot;,
                  signedBy &quot;&lt;b&gt;alias&lt;/b&gt;&quot;;
                  ....
                  };
                  &lt;/pre&gt;
                  All non-bold items above must appear as is (although case
                  doesn&apos;t matter and some are optional, as noted below).
                  principal entries are optional and need not be present.
                  Italicized items represent variable values.
                  &lt;p&gt; A grant entry must begin with the word &lt;code&gt;grant&lt;/code&gt;.
                  The &lt;code&gt;signedBy&lt;/code&gt;,&lt;code&gt;codeBase&lt;/code&gt; and &lt;code&gt;principal&lt;/code&gt;
                  name/value pairs are optional.
                  If they are not present, then any signer (including unsigned code)
                  will match, and any codeBase will match.
                  Note that the &lt;i&gt;principalClass&lt;/i&gt;
                  may be set to the wildcard value, , which allows it to match
                  any &lt;code&gt;Principal&lt;/code&gt; class.  In addition, the &lt;i&gt;principalName&lt;/i&gt;
                  may also be set to the wildcard value, , allowing it to match
                  any &lt;code&gt;Principal&lt;/code&gt; name.  When setting the &lt;i&gt;principalName&lt;/i&gt;
                  to the , do not surround the  with quotes.
                  &lt;p&gt; A permission entry must begin with the word &lt;code&gt;permission&lt;/code&gt;.
                  The word &lt;code&gt;&lt;i&gt;Type&lt;/i&gt;&lt;/code&gt; in the template above is
                  a specific permission type, such as &lt;code&gt;java.io.FilePermission&lt;/code&gt;
                  or &lt;code&gt;java.lang.RuntimePermission&lt;/code&gt;.
                  &lt;p&gt; The &quot;&lt;i&gt;action&lt;/i&gt;&quot; is required for
                  many permission types, such as &lt;code&gt;java.io.FilePermission&lt;/code&gt;
                  (where it specifies what type of file access that is permitted).
                  It is not required for categories such as
                  &lt;code&gt;java.lang.RuntimePermission&lt;/code&gt;
                  where it is not necessary - you either have the
                  permission specified by the &lt;code&gt;&quot;&lt;i&gt;name&lt;/i&gt;&quot;&lt;/code&gt;
                  value following the type name or you don&apos;t.
                  &lt;p&gt; The &lt;code&gt;signedBy&lt;/code&gt; name/value pair for a permission entry
                  is optional. If present, it indicates a signed permission. That is,
                  the permission class itself must be signed by the given alias in
                  order for it to be granted. For example,
                  suppose you have the following grant entry:
                  &lt;pre&gt;
                  grant principal foo.com.Principal &quot;Duke&quot; {
                  permission Foo &quot;foobar&quot;, signedBy &quot;FooSoft&quot;;
                  }
                  &lt;/pre&gt;
                  &lt;p&gt; Then this permission of type &lt;i&gt;Foo&lt;/i&gt; is granted if the
                  &lt;code&gt;Foo.class&lt;/code&gt; permission has been signed by the
                  &quot;FooSoft&quot; alias, or if XXX &lt;code&gt;Foo.class&lt;/code&gt; is a
                  system class (i.e., is found on the CLASSPATH).
                  &lt;p&gt; Items that appear in an entry must appear in the specified order
                  (&lt;code&gt;permission&lt;/code&gt;, &lt;i&gt;Type&lt;/i&gt;, &quot;&lt;i&gt;name&lt;/i&gt;&quot;, and
                  &quot;&lt;i&gt;action&lt;/i&gt;&quot;). An entry is terminated with a semicolon.
                  &lt;p&gt; Case is unimportant for the identifiers (&lt;code&gt;permission&lt;/code&gt;,
                  &lt;code&gt;signedBy&lt;/code&gt;, &lt;code&gt;codeBase&lt;/code&gt;, etc.) but is
                  significant for the &lt;i&gt;Type&lt;/i&gt;
                  or for any string that is passed in as a value. &lt;p&gt;
                  &lt;p&gt; An example of two entries in a policy configuration file is
                  &lt;pre&gt;
                  // if the code is comes from &quot;foo.com&quot; and is running as &quot;Duke&quot;,
                  // grant it read/write to all files in /tmp.
                  grant codeBase &quot;foo.com&quot;, principal foo.com.Principal &quot;Duke&quot; {
                  permission java.io.FilePermission &quot;/tmp/&quot;, &quot;read,write&quot;;
                  };
                  // grant any code running as &quot;Duke&quot; permission to read
                  // the &quot;java.vendor&quot; Property.
                  grant principal foo.com.Principal &quot;Duke&quot; {
                  permission java.util.PropertyPermission &quot;java.vendor&quot;;
                  &lt;/pre&gt;
                  This Policy implementation supports special handling of any
                  permission that contains the string, &quot;&lt;b&gt;${{self}}&lt;/b&gt;&quot;, as part of
                  its target name.  When such a permission is evaluated
                  (such as during a security check), &lt;b&gt;${{self}}&lt;/b&gt; is replaced
                  with one or more Principal class/name pairs.  The exact
                  replacement performed depends upon the contents of the
                  grant clause to which the permission belongs.
                  &lt;p&gt;
                  If the grant clause does not contain any principal information,
                  the permission will be ignored (permissions containing
                  &lt;b&gt;${{self}}&lt;/b&gt; in their target names are only valid in the context
                  of a principal-based grant clause).  For example, BarPermission
                  will always be ignored in the following grant clause:
                  &lt;pre&gt;
                  grant codebase &quot;www.foo.com&quot;, signedby &quot;duke&quot; {
                  permission BarPermission &quot;... ${{self}} ...&quot;;
                  };
                  &lt;/pre&gt;
                  If the grant clause contains principal information, &lt;b&gt;${{self}}&lt;/b&gt;
                  will be replaced with that same principal information.
                  For example, &lt;b&gt;${{self}}&lt;/b&gt; in BarPermission will be replaced by
                  &lt;b&gt;javax.security.auth.x500.X500Principal &quot;cn=Duke&quot;&lt;/b&gt;
                  in the following grant clause:
                  &lt;pre&gt;
                  grant principal javax.security.auth.x500.X500Principal &quot;cn=Duke&quot; {
                  permission BarPermission &quot;... ${{self}} ...&quot;;
                  };
                  &lt;/pre&gt;
                  If there is a comma-separated list of principals in the grant
                  clause, then &lt;b&gt;${{self}}&lt;/b&gt; will be replaced by the same
                  comma-separated list or principals.
                  In the case where both the principal class and name are
                  wildcarded in the grant clause, &lt;b&gt;${{self}}&lt;/b&gt; is replaced
                  with all the principals associated with the &lt;code&gt;Subject&lt;/code&gt;
                  in the current &lt;code&gt;AccessControlContext&lt;/code&gt;.
                  &lt;p&gt; For PrivateCredentialPermissions, you can also use &quot;&lt;b&gt;self&lt;/b&gt;&quot;
                  instead of &quot;&lt;b&gt;${{self}}&lt;/b&gt;&quot;. However the use of &quot;&lt;b&gt;self&lt;/b&gt;&quot; is
                  deprecated in favour of &quot;&lt;b&gt;${{self}}&lt;/b&gt;&quot;.                
                <see>
                    java.security.CodeSource                    
                </see>
                <see>
                    java.security.Permissions                    
                </see>
                <see>
                    java.security.ProtectionDomain                    
                </see>
            </javadoc>
            <declaration name="debug" type="Debug" line="285"/>
            <declaration name="NONE" type="String" line="287"/>
            <declaration name="P11KEYSTORE" type="String" line="288"/>
            <declaration name="SELF" type="String" line="290"/>
            <declaration name="X500PRINCIPAL" type="String" line="291"/>
            <declaration name="POLICY" type="String" line="293"/>
            <declaration name="SECURITY_MANAGER" type="String" line="294"/>
            <declaration name="POLICY_URL" type="String" line="295"/>
            <declaration name="AUTH_POLICY" type="String" line="296"/>
            <declaration name="AUTH_POLICY_URL" type="String" line="297"/>
            <declaration name="DEFAULT_CACHE_SIZE" type="int" line="299"/>
            <declaration name="policyInfo" type="AtomicReference&lt;PolicyInfo&gt;" line="302"/>
            <declaration name="constructed" type="boolean" line="303"/>
            <declaration name="expandProperties" type="boolean" line="305"/>
            <declaration name="ignoreIdentityScope" type="boolean" line="306"/>
            <declaration name="allowSystemProperties" type="boolean" line="307"/>
            <declaration name="notUtf8" type="boolean" line="308"/>
            <declaration name="url" type="URL" line="309"/>
            <declaration name="PARAMS0" type="Class[]" line="313"/>
            <declaration name="PARAMS1" type="Class[]" line="314"/>
            <declaration name="PARAMS2" type="Class[]" line="315"/>
            <javadoc line="317">
                Initializes the Policy object and reads the default policy
                  configuration file(s) into the Policy object.                
            </javadoc>
            <method name="PolicyFile" type="constructor" line="321"/>
            <javadoc line="325">
                Initializes the Policy object and reads the default policy
                  from the specified URL only.                
            </javadoc>
            <method name="PolicyFile" type="constructor" line="329">
                <params>
                    <param name="url" type="URL"/>
                </params>
            </method>
            <javadoc line="334">
                Initializes the Policy object and reads the default policy
                  configuration file(s) into the Policy object.
                  The algorithm for locating the policy file(s) and reading their
                  information into the Policy object is:
                  &lt;pre&gt;
                  loop through the Security Properties named &quot;policy.url.1&quot;,
                  &quot;&quot;policy.url.2&quot;, &quot;auth.policy.url.1&quot;,  &quot;auth.policy.url.2&quot; etc, until
                  you don&apos;t find one. Each of these specify a policy file.
                  if none of these could be loaded, use a builtin static policy
                  equivalent to the default lib/security/java.policy file.
                  if the system property &quot;java.policy&quot; or &quot;java.auth.policy&quot; is defined
                  (which is the
                  case when the user uses the -D switch at runtime), and
                  its use is allowed by the security property file,
                  also load it.
                  &lt;/pre&gt;
                  Each policy file consists of one or more grant entries, each of
                  which consists of a number of permission entries.
                  &lt;pre&gt;
                  grant signedBy &quot;&lt;i&gt;alias&lt;/i&gt;&quot;, codeBase &quot;&lt;i&gt;URL&lt;/i&gt;&quot; {
                  permission &lt;i&gt;Type&lt;/i&gt; &quot;&lt;i&gt;name&lt;/i&gt;&quot;, &quot;&lt;i&gt;action&lt;/i&gt;&quot;,
                  signedBy &quot;&lt;i&gt;alias&lt;/i&gt;&quot;;
                  ....
                  permission &lt;i&gt;Type&lt;/i&gt; &quot;&lt;i&gt;name&lt;/i&gt;&quot;, &quot;&lt;i&gt;action&lt;/i&gt;&quot;,
                  signedBy &quot;&lt;i&gt;alias&lt;/i&gt;&quot;;
                  };
                  &lt;/pre&gt;
                  All non-italicized items above must appear as is (although case
                  doesn&apos;t matter and some are optional, as noted below).
                  Italicized items represent variable values.
                  &lt;p&gt; A grant entry must begin with the word &lt;code&gt;grant&lt;/code&gt;.
                  The &lt;code&gt;signedBy&lt;/code&gt; and &lt;code&gt;codeBase&lt;/code&gt; name/value
                  pairs are optional.
                  If they are not present, then any signer (including unsigned code)
                  will match, and any codeBase will match.
                  &lt;p&gt; A permission entry must begin with the word &lt;code&gt;permission&lt;/code&gt;.
                  The word &lt;code&gt;&lt;i&gt;Type&lt;/i&gt;&lt;/code&gt; in the template above would actually
                  be a specific permission type, such as
                  &lt;code&gt;java.io.FilePermission&lt;/code&gt; or
                  &lt;code&gt;java.lang.RuntimePermission&lt;/code&gt;.
                  &lt;p&gt;The &quot;&lt;i&gt;action&lt;/i&gt;&quot; is required for
                  many permission types, such as &lt;code&gt;java.io.FilePermission&lt;/code&gt;
                  (where it specifies what type of file access is permitted).
                  It is not required for categories such as
                  &lt;code&gt;java.lang.RuntimePermission&lt;/code&gt;
                  where it is not necessary - you either have the
                  permission specified by the &lt;code&gt;&quot;&lt;i&gt;name&lt;/i&gt;&quot;&lt;/code&gt;
                  value following the type name or you don&apos;t.
                  &lt;p&gt;The &lt;code&gt;signedBy&lt;/code&gt; name/value pair for a permission entry
                  is optional. If present, it indicates a signed permission. That is,
                  the permission class itself must be signed by the given alias in
                  order for it to be granted. For example,
                  suppose you have the following grant entry:
                  &lt;pre&gt;
                  grant {
                  permission Foo &quot;foobar&quot;, signedBy &quot;FooSoft&quot;;
                  }
                  &lt;/pre&gt;
                  &lt;p&gt;Then this permission of type &lt;i&gt;Foo&lt;/i&gt; is granted if the
                  &lt;code&gt;Foo.class&lt;/code&gt; permission has been signed by the
                  &quot;FooSoft&quot; alias, or if &lt;code&gt;Foo.class&lt;/code&gt; is a
                  system class (i.e., is found on the CLASSPATH).
                  &lt;p&gt;Items that appear in an entry must appear in the specified order
                  (&lt;code&gt;permission&lt;/code&gt;, &lt;i&gt;Type&lt;/i&gt;, &quot;&lt;i&gt;name&lt;/i&gt;&quot;, and
                  &quot;&lt;i&gt;action&lt;/i&gt;&quot;). An entry is terminated with a semicolon.
                  &lt;p&gt;Case is unimportant for the identifiers (&lt;code&gt;permission&lt;/code&gt;,
                  &lt;code&gt;signedBy&lt;/code&gt;, &lt;code&gt;codeBase&lt;/code&gt;, etc.) but is
                  significant for the &lt;i&gt;Type&lt;/i&gt;
                  or for any string that is passed in as a value. &lt;p&gt;
                  &lt;p&gt;An example of two entries in a policy configuration file is
                  &lt;pre&gt;
                  //  if the code is signed by &quot;Duke&quot;, grant it read/write to all
                  // files in /tmp.
                  grant signedBy &quot;Duke&quot; {
                  permission java.io.FilePermission &quot;/tmp/&quot;, &quot;read,write&quot;;
                  };
                  &lt;p&gt;
                  // grant everyone the following permission
                  grant {
                  permission java.util.PropertyPermission &quot;java.vendor&quot;;
                  };
                  &lt;/pre&gt;                
            </javadoc>
            <method name="init" type="void" line="435">
                <params>
                    <param name="url" type="URL"/>
                </params>
                <comment line="437">
                    Properties are set once for each init(); ignore changes between
                     between diff invocations of initPolicyFile(policy, url, info).                    
                </comment>
                <comment line="463">
                    System.out.println(&quot;number caches=&quot; + numCaches);                    
                </comment>
                <anonymous_class line="439">
                    <method name="run" type="String" line="440"/>
                </anonymous_class>
                <declaration name="numCacheStr" type="String" line="438"/>
                <declaration name="numCaches" type="int" line="452"/>
                <scope line="453">
                    <scope line="454"/>
                    <scope line="456"/>
                </scope>
                <scope line="459"/>
                <declaration name="newInfo" type="PolicyInfo" line="463"/>
            </method>
            <method name="initPolicyFile" type="void" line="468">
                <params>
                    <param name="newInfo" type="PolicyInfo"/>
                    <param name="url" type="URL"/>
                </params>
                <comment line="473">
                    If the caller specified a URL via Policy.getInstance,
                     we only read from that URL                    
                </comment>
                <comment line="484">
                    use static policy if all else fails                    
                </comment>
                <comment line="493">
                    Caller did not specify URL via Policy.getInstance.
                     Read from URLs listed in the java.security properties file.
                    
                     We call initPolicyFile with POLICY , POLICY_URL and then
                     call it with AUTH_POLICY and AUTH_POLICY_URL
                     So first we will process the JAVA standard policy
                     and then process the JAVA AUTH Policy.
                     This is for backward compatibility as well as to handle
                     cases where the user has a single unified policyfile
                     with both java policy entries and auth entries                    
                </comment>
                <comment line="507">
                    To maintain strict backward compatibility
                     we load the static policy only if POLICY load failed                    
                </comment>
                <comment line="510">
                    use static policy if all else fails                    
                </comment>
                <scope line="470">
                    <scope line="477"/>
                    <anonymous_class line="480">
                        <method name="run" type="Void" line="481">
                            <comment line="484">
                                use static policy if all else fails                                
                            </comment>
                            <scope line="482"/>
                        </method>
                    </anonymous_class>
                </scope>
                <scope line="490">
                    <declaration name="loaded_one" type="boolean" line="505"/>
                    <scope line="508"/>
                </scope>
            </method>
            <method name="initPolicyFile" type="boolean" line="518">
                <params>
                    <param name="propname" type="String"/>
                    <param name="urlname" type="String"/>
                    <param name="newInfo" type="PolicyInfo"/>
                </params>
                <comment line="550">
                    ignore.                    
                </comment>
                <comment line="576">
                    this special case accommodates
                     the situation java.home/user.home
                     expand to a single slash, resulting in
                     a file:foo URI                    
                </comment>
                <comment line="595">
                    ignore that policy                    
                </comment>
                <anonymous_class line="520">
                    <method name="run" type="Boolean" line="521">
                        <comment line="550">
                            ignore.                            
                        </comment>
                        <comment line="576">
                            this special case accommodates
                             the situation java.home/user.home
                             expand to a single slash, resulting in
                             a file:foo URI                            
                        </comment>
                        <comment line="595">
                            ignore that policy                            
                        </comment>
                        <declaration name="loaded_policy" type="boolean" line="522"/>
                        <scope line="524">
                            <declaration name="extra_policy" type="String" line="525"/>
                            <scope line="526">
                                <declaration name="overrideAll" type="boolean" line="527"/>
                                <scope line="528"/>
                                <scope line="532">
                                    <declaration name="policyURL" type="URL" line="535"/>
                                    <declaration name="policyFile" type="File" line="537"/>
                                    <scope line="538"/>
                                    <scope line="541"/>
                                </scope>
                                <scope line="548">
                                    <scope line="550"/>
                                </scope>
                                <scope line="554">
                                    <scope line="555"/>
                                </scope>
                            </scope>
                        </scope>
                        <declaration name="n" type="int" line="563"/>
                        <declaration name="policy_uri" type="String" line="564"/>
                        <scope line="566">
                            <scope line="567">
                                <declaration name="policy_url" type="URL" line="568"/>
                                <declaration name="expanded_uri" type="String" line="569"/>
                                <scope line="573"/>
                                <scope line="581"/>
                            </scope>
                            <scope line="589">
                                <scope line="590"/>
                            </scope>
                        </scope>
                    </method>
                </anonymous_class>
                <declaration name="loadedPolicy" type="Boolean" line="519"/>
            </method>
            <javadoc line="605">
                Reads a policy configuration into the Policy object using a
                  Reader object.                
                <param>
                    policyFile the policy Reader object.                    
                </param>
            </javadoc>
            <method name="init" type="boolean" line="611">
                <params>
                    <param name="policy" type="URL"/>
                    <param name="newInfo" type="PolicyInfo"/>
                </params>
                <comment line="618">
                    read in policy using UTF-8 by default
                    
                     check non-standard system property to see if
                     the default encoding should be used instead                    
                </comment>
                <comment line="643">
                    ignore, treat it like we have no keystore                    
                </comment>
                <comment line="674">
                    ignore the exception                    
                </comment>
                <declaration name="success" type="boolean" line="612"/>
                <declaration name="pp" type="PolicyParser" line="613"/>
                <declaration name="isr" type="InputStreamReader" line="614"/>
                <scope line="615">
                    <scope line="622"/>
                    <scope line="625"/>
                    <declaration name="keyStore" type="KeyStore" line="632"/>
                    <scope line="633"/>
                    <scope line="641">
                        <scope line="643"/>
                    </scope>
                    <declaration name="enum_" type="Enumeration&lt;PolicyParser.GrantEntry&gt;" line="648"/>
                    <scope line="649">
                        <declaration name="ge" type="PolicyParser.GrantEntry" line="650"/>
                    </scope>
                </scope>
                <scope line="653">
                    <declaration name="form" type="MessageFormat" line="654"/>
                    <declaration name="source" type="Object[]" line="656"/>
                </scope>
                <scope line="661">
                    <scope line="662"/>
                </scope>
                <scope line="667">
                    <scope line="668">
                        <scope line="669"/>
                        <scope line="672"/>
                    </scope>
                    <scope line="675"/>
                </scope>
            </method>
            <method name="initStaticPolicy" type="void" line="683">
                <params>
                    <param name="newInfo" type="PolicyInfo"/>
                </params>
                <comment line="735">
                    No need to sync because noone has access to newInfo yet                    
                </comment>
                <comment line="738">
                    Add AllPermissions for standard extensions                    
                </comment>
                <comment line="749">
                    No need to sync because noone has access to
                     newInfo yet                    
                </comment>
                <comment line="753">
                    this is probably bad (though not dangerous).
                     What should we do?                    
                </comment>
                <anonymous_class line="684">
                    <method name="run" type="Void" line="685">
                        <comment line="735">
                            No need to sync because noone has access to newInfo yet                            
                        </comment>
                        <comment line="738">
                            Add AllPermissions for standard extensions                            
                        </comment>
                        <comment line="749">
                            No need to sync because noone has access to
                             newInfo yet                            
                        </comment>
                        <comment line="753">
                            this is probably bad (though not dangerous).
                             What should we do?                            
                        </comment>
                        <declaration name="pe" type="PolicyEntry" line="686"/>
                        <declaration name="extCodebases" type="String[]" line="738"/>
                        <scope line="740">
                            <scope line="741">
                                <scope line="742"/>
                                <scope line="751"/>
                            </scope>
                        </scope>
                    </method>
                </anonymous_class>
            </method>
            <javadoc line="762">
                Given a GrantEntry, create a codeSource.                
                <return>
                    null if signedBy alias is not recognized                    
                </return>
            </javadoc>
            <method name="getCodeSource" type="CodeSource" line="769">
                <params>
                    <param name="ge" type="PolicyParser.GrantEntry"/>
                    <param name="keyStore" type="KeyStore"/>
                    <param name="newInfo" type="PolicyInfo"/>
                </params>
                <comment line="775">
                    we don&apos;t have a key for this alias,
                     just return                    
                </comment>
                <declaration name="certs" type="Certificate[]" line="770"/>
                <scope line="771">
                    <scope line="773">
                        <scope line="776"/>
                    </scope>
                </scope>
                <declaration name="location" type="URL" line="784"/>
            </method>
            <javadoc line="794">
                Add one policy entry to the list.                
            </javadoc>
            <method name="addGrantEntry" type="void" line="798">
                <params>
                    <param name="ge" type="PolicyParser.GrantEntry"/>
                    <param name="keyStore" type="KeyStore"/>
                    <param name="newInfo" type="PolicyInfo"/>
                </params>
                <comment line="817">
                    skip if signedBy alias was unknown...                    
                </comment>
                <comment line="820">
                    perform keystore alias principal replacement.
                     for example, if alias resolves to X509 certificate,
                     replace principal with:  &lt;X500Principal class&gt;  &lt;SubjectDN&gt;
                     -- skip if alias is unknown                    
                </comment>
                <comment line="833">
                    perform ${{ ... }} expansions within permission name                    
                </comment>
                <comment line="836">
                    XXX special case PrivateCredentialPermission-SELF                    
                </comment>
                <comment line="844">
                    check for self                    
                </comment>
                <comment line="846">
                    Create a &quot;SelfPermission&quot; , it could be an
                     an unresolved permission which will be resolved
                     when implies is called
                     Add it to entry                    
                </comment>
                <comment line="881">
                    only add if we had no signer or we had a
                     a signer and found the keys for it.                    
                </comment>
                <comment line="913">
                    No need to sync because noone has access to newInfo yet                    
                </comment>
                <scope line="800">
                    <scope line="804">
                        <declaration name="li" type="ListIterator&lt;PolicyParser.PrincipalEntry&gt;" line="805"/>
                        <scope line="807">
                            <declaration name="pppe" type="PolicyParser.PrincipalEntry" line="808"/>
                        </scope>
                    </scope>
                </scope>
                <scope line="814">
                    <declaration name="codesource" type="CodeSource" line="815"/>
                    <declaration name="entry" type="PolicyEntry" line="825"/>
                    <declaration name="enum_" type="Enumeration&lt;PolicyParser.PermissionEntry&gt;" line="826"/>
                    <scope line="828">
                        <declaration name="pe" type="PolicyParser.PermissionEntry" line="829"/>
                        <scope line="831">
                            <declaration name="perm" type="Permission" line="836"/>
                            <scope line="839"/>
                            <scope line="844">
                                <declaration name="certs" type="Certificate" line="849"/>
                                <scope line="850"/>
                                <scope line="854"/>
                            </scope>
                            <scope line="861"/>
                            <scope line="867"/>
                        </scope>
                        <scope line="870">
                            <declaration name="certs" type="Certificate" line="871"/>
                            <scope line="872"/>
                            <scope line="876"/>
                            <scope line="882">
                                <declaration name="perm" type="Permission" line="883"/>
                                <scope line="889"/>
                            </scope>
                        </scope>
                        <scope line="893">
                            <declaration name="form" type="MessageFormat" line="894"/>
                            <declaration name="source" type="Object[]" line="898"/>
                        </scope>
                        <scope line="901">
                            <declaration name="form" type="MessageFormat" line="902"/>
                            <declaration name="source" type="Object[]" line="906"/>
                        </scope>
                    </scope>
                </scope>
                <scope line="914">
                    <declaration name="form" type="MessageFormat" line="915"/>
                    <declaration name="source" type="Object[]" line="918"/>
                </scope>
            </method>
            <javadoc line="925">
                Returns a new Permission object of the given Type. The Permission is
                  created by getting the
                  Class object using the &lt;code&gt;Class.forName&lt;/code&gt; method, and using
                  the reflection API to invoke the (String name, String actions)
                  constructor on the
                  object.                
                <param>
                    type the type of Permission being created.                    
                </param>
                <param>
                    name the name of the Permission being created.                    
                </param>
                <param>
                    actions the actions of the Permission being created.                    
                </param>
                <exception>
                    ClassNotFoundException  if the particular Permission
                      class could not be found.                    
                </exception>
                <exception>
                    IllegalAccessException  if the class or initializer is
                      not accessible.                    
                </exception>
                <exception>
                    InstantiationException  if getInstance tries to
                      instantiate an abstract class or an interface, or if the
                      instantiation fails for some other reason.                    
                </exception>
                <exception>
                    NoSuchMethodException if the (String, String) constructor
                      is not found.                    
                </exception>
                <exception>
                    InvocationTargetException if the underlying Permission
                      constructor throws an exception.                    
                </exception>
            </javadoc>
            <method name="getInstance" type="Permission" line="963">
                <params>
                    <param name="type" type="String"/>
                    <param name="name" type="String"/>
                    <param name="actions" type="String"/>
                </params>
                <comment line="965">
                    XXX we might want to keep a hash of created factories...                    
                </comment>
                <declaration name="pc" type="Class&lt;?&gt;" line="965"/>
                <declaration name="answer" type="Permission" line="966"/>
                <scope line="967"/>
                <scope line="971">
                    <scope line="972">
                        <declaration name="c" type="Constructor&lt;?&gt;" line="973"/>
                    </scope>
                    <scope line="975">
                        <scope line="976">
                            <declaration name="c" type="Constructor&lt;?&gt;" line="977"/>
                        </scope>
                        <scope line="980">
                            <declaration name="c" type="Constructor&lt;?&gt;" line="981"/>
                        </scope>
                    </scope>
                </scope>
                <scope line="986">
                    <scope line="987">
                        <scope line="988">
                            <declaration name="c" type="Constructor&lt;?&gt;" line="989"/>
                        </scope>
                        <scope line="991">
                            <declaration name="c" type="Constructor&lt;?&gt;" line="992"/>
                        </scope>
                    </scope>
                    <scope line="996">
                        <declaration name="c" type="Constructor&lt;?&gt;" line="997"/>
                    </scope>
                </scope>
            </method>
            <javadoc line="1004">
                Creates one of the well-known permissions directly instead of
                  via reflection. Keep list short to not penalize non-JDK-defined
                  permissions.                
            </javadoc>
            <method name="getKnownInstance" type="Permission" line="1010">
                <params>
                    <param name="claz" type="Class"/>
                    <param name="name" type="String"/>
                    <param name="actions" type="String"/>
                </params>
                <comment line="1012">
                    XXX shorten list to most popular ones?                    
                </comment>
                <comment line="1025">
                    } else if (claz.equals(ReflectPermission.class)) {
                    return new ReflectPermission(name, actions);
                    } else if (claz.equals(SecurityPermission.class)) {
                    return new SecurityPermission(name, actions);
                    } else if (claz.equals(PrivateCredentialPermission.class)) {
                    return new PrivateCredentialPermission(name, actions);
                    } else if (claz.equals(AuthPermission.class)) {
                    return new AuthPermission(name, actions);
                    } else if (claz.equals(ServicePermission.class)) {
                    return new ServicePermission(name, actions);
                    } else if (claz.equals(DelegationPermission.class)) {
                    return new DelegationPermission(name, actions);
                    } else if (claz.equals(SerializablePermission.class)) {
                    return new SerializablePermission(name, actions);
                    } else if (claz.equals(AudioPermission.class)) {
                    return new AudioPermission(name, actions);
                    } else if (claz.equals(SSLPermission.class)) {
                    return new SSLPermission(name, actions);
                    } else if (claz.equals(LoggingPermission.class)) {
                    return new LoggingPermission(name, actions);
                    } else if (claz.equals(SQLPermission.class)) {
                    return new SQLPermission(name, actions);                    
                </comment>
                <scope line="1012"/>
                <scope line="1014"/>
                <scope line="1016"/>
                <scope line="1018"/>
                <scope line="1020"/>
                <scope line="1022"/>
                <scope line="1048"/>
            </method>
            <javadoc line="1053">
                Fetch all certs associated with this alias.                
            </javadoc>
            <method name="getCertificates" type="Certificate[]" line="1057">
                <params>
                    <param name="keyStore" type="KeyStore"/>
                    <param name="aliases" type="String"/>
                    <param name="newInfo" type="PolicyInfo"/>
                </params>
                <comment line="1069">
                    See if this alias&apos;s cert has already been cached                    
                </comment>
                <comment line="1078">
                    never happens, because keystore has already been loaded
                     when we call this                    
                </comment>
                <comment line="1095">
                    make sure n == vcerts.size, since we are doing a logical *and*                    
                </comment>
                <declaration name="vcerts" type="List&lt;Certificate&gt;" line="1059"/>
                <declaration name="st" type="StringTokenizer" line="1061"/>
                <declaration name="n" type="int" line="1062"/>
                <scope line="1064">
                    <declaration name="alias" type="String" line="1065"/>
                    <declaration name="cert" type="Certificate" line="1067"/>
                    <scope line="1069">
                        <scope line="1072">
                            <scope line="1074"/>
                            <scope line="1076"/>
                            <scope line="1080"/>
                        </scope>
                    </scope>
                    <scope line="1087"/>
                </scope>
                <scope line="1095">
                    <declaration name="certs" type="Certificate[]" line="1096"/>
                </scope>
                <scope line="1099"/>
            </method>
            <javadoc line="1104">
                Refreshes the policy object by re-reading all the policy files.                
            </javadoc>
            <method name="refresh" type="void" line="1107"/>
            <javadoc line="1111">
                Evaluates the the global policy for the permissions granted to
                  the ProtectionDomain and tests whether the permission is
                  granted.                
                <param>
                    domain the ProtectionDomain to test                    
                </param>
                <param>
                    permission the Permission object to be tested for implication.                    
                </param>
                <return>
                    true if &quot;permission&quot; is a proper subset of a permission
                      granted to this ProtectionDomain.                    
                </return>
                <see>
                    java.security.ProtectionDomain                    
                </see>
            </javadoc>
            <method name="implies" type="boolean" line="1125">
                <params>
                    <param name="pd" type="ProtectionDomain"/>
                    <param name="p" type="Permission"/>
                </params>
                <comment line="1141">
                    cache mapping of protection domain to its PermissionCollection                    
                </comment>
                <declaration name="pi" type="PolicyInfo" line="1126"/>
                <declaration name="pdMap" type="ProtectionDomainCache" line="1127"/>
                <declaration name="pc" type="PermissionCollection" line="1129"/>
                <scope line="1131"/>
                <scope line="1136"/>
            </method>
            <javadoc line="1145">
                Examines this &lt;code&gt;Policy&lt;/code&gt; and returns the permissions granted
                  to the specified &lt;code&gt;ProtectionDomain&lt;/code&gt;.  This includes
                  the permissions currently associated with the domain as well
                  as the policy permissions granted to the domain&apos;s
                  CodeSource, ClassLoader, and Principals.
                  &lt;p&gt; Note that this &lt;code&gt;Policy&lt;/code&gt; implementation has
                  special handling for PrivateCredentialPermissions.
                  When this method encounters a &lt;code&gt;PrivateCredentialPermission&lt;/code&gt;
                  which specifies &quot;self&quot; as the &lt;code&gt;Principal&lt;/code&gt; class and name,
                  it does not add that &lt;code&gt;Permission&lt;/code&gt; to the returned
                  &lt;code&gt;PermissionCollection&lt;/code&gt;.  Instead, it builds
                  a new &lt;code&gt;PrivateCredentialPermission&lt;/code&gt;
                  for each &lt;code&gt;Principal&lt;/code&gt; associated with the provided
                  &lt;code&gt;Subject&lt;/code&gt;.  Each new &lt;code&gt;PrivateCredentialPermission&lt;/code&gt;
                  contains the same Credential class as specified in the
                  originally granted permission, as well as the Class and name
                  for the respective &lt;code&gt;Principal&lt;/code&gt;.
                  &lt;p&gt;                
                <param>
                    domain the Permissions granted to this
                      &lt;code&gt;ProtectionDomain&lt;/code&gt; are returned.                    
                </param>
                <return>
                    the Permissions granted to the provided
                      &lt;code&gt;ProtectionDomain&lt;/code&gt;.                    
                </return>
            </javadoc>
            <method name="getPermissions" type="PermissionCollection" line="1174">
                <params>
                    <param name="domain" type="ProtectionDomain"/>
                </params>
                <comment line="1181">
                    first get policy perms                    
                </comment>
                <comment line="1184">
                    add static perms
                          - adding static perms after policy perms is necessary
                            to avoid a regression for 4301064                    
                </comment>
                <declaration name="perms" type="Permissions" line="1175"/>
                <declaration name="pc" type="PermissionCollection" line="1186"/>
                <scope line="1187">
                    <scope line="1188">
                        <declaration name="e" type="Enumeration&lt;Permission&gt;" line="1189"/>
                        <scope line="1190"/>
                    </scope>
                </scope>
            </method>
            <javadoc line="1199">
                Examines this Policy and creates a PermissionCollection object with
                  the set of permissions for the specified CodeSource.                
                <param>
                    CodeSource the codesource associated with the caller.
                      This encapsulates the original location of the code (where the code
                      came from) and the public key(s) of its signer.                    
                </param>
                <return>
                    the set of permissions according to the policy.                    
                </return>
            </javadoc>
            <method name="getPermissions" type="PermissionCollection" line="1210">
                <params>
                    <param name="codesource" type="CodeSource"/>
                </params>
            </method>
            <javadoc line="1214">
                Examines the global policy and returns the provided Permissions
                  object with additional permissions granted to the specified
                  ProtectionDomain.                
                <param>
                    perm the Permissions to populate                    
                </param>
                <param>
                    pd the ProtectionDomain associated with the caller.                    
                </param>
                <return>
                    the set of Permissions according to the policy.                    
                </return>
            </javadoc>
            <method name="getPermissions" type="PermissionCollection" line="1225">
                <params>
                    <param name="perms" type="Permissions"/>
                    <param name="pd" type="ProtectionDomain"/>
                </params>
                <scope line="1226"/>
                <declaration name="cs" type="CodeSource" line="1230"/>
                <anonymous_class line="1235">
                    <method name="run" type="CodeSource" line="1236"/>
                </anonymous_class>
                <declaration name="canonCodeSource" type="CodeSource" line="1234"/>
            </method>
            <javadoc line="1243">
                Examines the global policy and returns the provided Permissions
                  object with additional permissions granted to the specified
                  CodeSource.                
                <param>
                    permissions the permissions to populate                    
                </param>
                <param>
                    codesource the codesource associated with the caller.
                      This encapsulates the original location of the code (where the code
                      came from) and the public key(s) of its signer.                    
                </param>
                <return>
                    the set of permissions according to the policy.                    
                </return>
            </javadoc>
            <method name="getPermissions" type="PermissionCollection" line="1256">
                <params>
                    <param name="perms" type="Permissions"/>
                    <param name="cs" type="CodeSource"/>
                </params>
                <anonymous_class line="1259">
                    <method name="run" type="CodeSource" line="1260"/>
                </anonymous_class>
                <declaration name="canonCodeSource" type="CodeSource" line="1258"/>
            </method>
            <method name="getPermissions" type="Permissions" line="1270">
                <params>
                    <param name="perms" type="Permissions"/>
                    <param name="cs" type="CodeSource"/>
                    <param name="principals" type="Principal[]"/>
                </params>
                <comment line="1278">
                    Go through policyEntries gotten from identity db; sync required
                     because checkForTrustedIdentity (below) might update list                    
                </comment>
                <comment line="1286">
                    now see if any of the keys are trusted ids.                    
                </comment>
                <comment line="1294">
                    checkForTrustedIdentity added it
                     to the policy for us. next time
                     around we&apos;ll find it. This time
                     around we need to add it.                    
                </comment>
                <declaration name="pi" type="PolicyInfo" line="1271"/>
                <scope line="1273"/>
                <scope line="1279">
                    <scope line="1280"/>
                </scope>
                <scope line="1286">
                    <declaration name="certs" type="Certificate" line="1287"/>
                    <scope line="1288">
                        <scope line="1289">
                            <declaration name="idMap" type="Object" line="1290"/>
                            <scope line="1292"/>
                        </scope>
                    </scope>
                </scope>
            </method>
            <method name="addPermissions" type="void" line="1308">
                <params>
                    <param name="perms" type="Permissions"/>
                    <param name="cs" type="CodeSource"/>
                    <param name="principals" type="Principal[]"/>
                    <param name="entry" type="PolicyEntry"/>
                </params>
                <comment line="1317">
                    check to see if the CodeSource implies                    
                </comment>
                <comment line="1329">
                    CodeSource does not imply - return and try next policy entry                    
                </comment>
                <comment line="1333">
                    check to see if the Principals imply                    
                </comment>
                <comment line="1352">
                    policy entry has no principals -
                     add perms regardless of principals in current ACC                    
                </comment>
                <comment line="1363">
                    current thread has no principals but this policy entry
                     has principals - perms are not added                    
                </comment>
                <comment line="1372">
                    current thread has principals and this policy entry
                     has principals.  see if policy entry principals match
                     principals in current ACC                    
                </comment>
                <comment line="1379">
                    see if principal entry is a PrincipalComparator                    
                </comment>
                <comment line="1389">
                    common case - dealing with regular Principal class.
                     see if policy entry principal is in current ACC                    
                </comment>
                <comment line="1397">
                    policy entry principal not in current ACC -
                     immediately return and go to next policy entry                    
                </comment>
                <comment line="1404">
                    dealing with a PrincipalComparator                    
                </comment>
                <comment line="1415">
                    check if the PrincipalComparator
                     implies the current thread&apos;s principals                    
                </comment>
                <comment line="1433">
                    policy principal does not imply the current Subject -
                     immediately return and go to next policy entry                    
                </comment>
                <comment line="1439">
                    fall back to regular principal comparison.
                     see if policy entry principal is in current ACC                    
                </comment>
                <comment line="1451">
                    policy entry principal not in current ACC -
                     immediately return and go to next policy entry                    
                </comment>
                <comment line="1457">
                    either the principal information matched,
                     or the PrincipalComparator.implies succeeded.
                     continue loop and test the next policy principal                    
                </comment>
                <comment line="1462">
                    all policy entry principals were found in the current ACC -
                     grant the policy permissions                    
                </comment>
                <scope line="1310"/>
                <anonymous_class line="1318">
                    <method name="run" type="Boolean" line="1319"/>
                </anonymous_class>
                <declaration name="imp" type="Boolean" line="1317"/>
                <scope line="1323">
                    <scope line="1324"/>
                </scope>
                <declaration name="entryPs" type="List&lt;PolicyParser.PrincipalEntry&gt;" line="1334"/>
                <scope line="1335">
                    <declaration name="accPs" type="ArrayList&lt;PolicyParser.PrincipalEntry&gt;" line="1336"/>
                    <scope line="1337">
                        <scope line="1338"/>
                    </scope>
                </scope>
                <scope line="1349">
                    <scope line="1355"/>
                </scope>
                <scope line="1360">
                    <scope line="1365"/>
                </scope>
                <scope line="1375">
                    <declaration name="pppe" type="PolicyParser.PrincipalEntry" line="1376"/>
                    <scope line="1380">
                        <declaration name="pClass" type="Class&lt;?&gt;" line="1381"/>
                        <scope line="1386">
                            <scope line="1391">
                                <scope line="1392"/>
                            </scope>
                        </scope>
                        <scope line="1401">
                            <declaration name="c" type="Constructor&lt;?&gt;" line="1405"/>
                            <declaration name="pc" type="PrincipalComparator" line="1406"/>
                            <scope line="1409"/>
                            <declaration name="pSet" type="Set&lt;Principal&gt;" line="1417"/>
                            <scope line="1418"/>
                            <declaration name="subject" type="Subject" line="1421"/>
                            <scope line="1426">
                                <scope line="1427"/>
                            </scope>
                        </scope>
                    </scope>
                    <scope line="1437">
                        <scope line="1441"/>
                        <scope line="1445">
                            <scope line="1446"/>
                        </scope>
                    </scope>
                </scope>
                <scope line="1464"/>
            </method>
            <method name="addPerms" type="void" line="1472">
                <params>
                    <param name="perms" type="Permissions"/>
                    <param name="accPs" type="Principal[]"/>
                    <param name="entry" type="PolicyEntry"/>
                </params>
                <comment line="1481">
                    handle &quot;SELF&quot; permissions                    
                </comment>
                <scope line="1473">
                    <declaration name="p" type="Permission" line="1474"/>
                    <scope line="1475"/>
                    <scope line="1479"/>
                    <scope line="1485"/>
                </scope>
            </method>
            <javadoc line="1491">
                This method returns, true, if the principal in the policy entry,
                  pppe, is part of the current thread&apos;s principal array, pList.
                  This method also returns, true, if the policy entry&apos;s principal
                  is appropriately wildcarded.
                  Note that the provided &lt;i&gt;pppe&lt;/i&gt; argument may have
                  wildcards () for both the &lt;code&gt;Principal&lt;/code&gt; class and name.                
                <param>
                    pList an array of principals from the current thread&apos;s
                      AccessControlContext.                    
                </param>
                <param>
                    pppe a Principal specified in a policy grant entry.                    
                </param>
                <return>
                    true if the current thread&apos;s pList &quot;contains&quot; the
                      principal in the policy entry, pppe.  This method
                      also returns true if the policy entry&apos;s principal
                      appropriately wildcarded.                    
                </return>
            </javadoc>
            <method name="checkEntryPs" type="boolean" line="1511">
                <params>
                    <param name="pList" type="Principal[]"/>
                    <param name="pppe" type="PolicyParser.PrincipalEntry"/>
                </params>
                <scope line="1513">
                    <scope line="1518">
                        <scope line="1523"/>
                    </scope>
                </scope>
            </method>
            <javadoc line="1532">
                &lt;p&gt;                
                <param>
                    sp the SelfPermission that needs to be expanded &lt;p&gt;                    
                </param>
                <param>
                    entryPs list of principals for the Policy entry.                    
                </param>
                <param>
                    pdp Principal array from the current ProtectionDomain.                    
                </param>
                <param>
                    perms the PermissionCollection where the individual
                      Permissions will be added after expansion.                    
                </param>
            </javadoc>
            <method name="expandSelf" type="void" line="1548">
                <params>
                    <param name="sp" type="SelfPermission"/>
                    <param name="entryPs" type="List<PolicyParser.PrincipalEntry>"/>
                    <param name="pdp" type="Principal[]"/>
                    <param name="perms" type="Permissions"/>
                </params>
                <comment line="1552">
                    No principals in the grant to substitute                    
                </comment>
                <comment line="1572">
                    add non-SELF string                    
                </comment>
                <comment line="1575">
                    expand SELF                    
                </comment>
                <comment line="1594">
                    add remaining string (might be the entire string)                    
                </comment>
                <comment line="1602">
                    first try to instantiate the permission                    
                </comment>
                <comment line="1607">
                    ok, the permission is not in the bootclasspath.
                     before we add an UnresolvedPermission, check to see
                     whether this perm already belongs to the collection.
                     if so, use that perm&apos;s ClassLoader to create a new
                     one.                    
                </comment>
                <comment line="1624">
                    create an UnresolvedPermission                    
                </comment>
                <comment line="1631">
                    we found an instantiated permission.
                     use its class loader to instantiate a new permission.                    
                </comment>
                <comment line="1634">
                    name parameter can not be null                    
                </comment>
                <scope line="1550">
                    <scope line="1552"/>
                </scope>
                <declaration name="startIndex" type="int" line="1566"/>
                <declaration name="v" type="int" line="1567"/>
                <declaration name="sb" type="StringBuilder" line="1568"/>
                <scope line="1569">
                    <declaration name="pli" type="ListIterator&lt;PolicyParser.PrincipalEntry&gt;" line="1575"/>
                    <scope line="1577">
                        <declaration name="pppe" type="PolicyParser.PrincipalEntry" line="1578"/>
                        <declaration name="principalInfo" type="String[][]" line="1579"/>
                        <scope line="1580">
                            <scope line="1581"/>
                        </scope>
                        <scope line="1587"/>
                    </scope>
                </scope>
                <scope line="1596"/>
                <scope line="1600"/>
                <scope line="1605">
                    <declaration name="pc" type="Class&lt;?&gt;" line="1611"/>
                    <scope line="1612">
                        <declaration name="e" type="Enumeration&lt;Permission&gt;" line="1613"/>
                        <scope line="1614">
                            <declaration name="pElement" type="Permission" line="1615"/>
                            <scope line="1616"/>
                        </scope>
                    </scope>
                    <scope line="1622"/>
                    <scope line="1628">
                        <scope line="1629">
                            <declaration name="c" type="Constructor&lt;?&gt;" line="1632"/>
                            <scope line="1634">
                                <scope line="1635"/>
                                <scope line="1639"/>
                            </scope>
                            <scope line="1645"/>
                        </scope>
                        <scope line="1651">
                            <scope line="1652"/>
                        </scope>
                    </scope>
                </scope>
                <scope line="1659">
                    <scope line="1660"/>
                </scope>
            </method>
            <javadoc line="1666">
                return the principal class/name pair in the 2D array.
                  array[x][y]:     x corresponds to the array length.
                  if (y == 0), it&apos;s the principal class.
                  if (y == 1), it&apos;s the principal name.                
            </javadoc>
            <method name="getPrincipalInfo" type="String[][]" line="1673">
                <params>
                    <param name="pe" type="PolicyParser.PrincipalEntry"/>
                    <param name="pdp" type="Principal[]"/>
                </params>
                <comment line="1676">
                    there are 3 possibilities:
                     1) the entry&apos;s Principal class and name are not wildcarded
                     2) the entry&apos;s Principal name is wildcarded only
                     3) the entry&apos;s Principal class and name are wildcarded                    
                </comment>
                <comment line="1686">
                    build an info array for the principal
                     from the Policy entry                    
                </comment>
                <comment line="1698">
                    build an info array for every principal
                     in the current domain which has a principal class
                     that is equal to policy entry principal class name                    
                </comment>
                <comment line="1719">
                    build an info array for every
                     one of the current Domain&apos;s principals                    
                </comment>
                <scope line="1683">
                    <declaration name="info" type="String[][]" line="1687"/>
                </scope>
                <scope line="1695">
                    <declaration name="plist" type="List&lt;Principal&gt;" line="1700"/>
                    <scope line="1701"/>
                    <declaration name="info" type="String[][]" line="1705"/>
                    <declaration name="i" type="int" line="1706"/>
                    <declaration name="pIterator" type="java.util.Iterator&lt;Principal&gt;" line="1707"/>
                    <scope line="1708">
                        <declaration name="p" type="Principal" line="1709"/>
                    </scope>
                </scope>
                <scope line="1716">
                    <declaration name="info" type="String[][]" line="1721"/>
                    <scope line="1723"/>
                </scope>
            </method>
            <method name="getSignerCertificates" type="Certificate[]" line="1745">
                <params>
                    <param name="cs" type="CodeSource"/>
                </params>
                <comment line="1755">
                    Do we have to do anything?                    
                </comment>
                <comment line="1768">
                    Done                    
                </comment>
                <declaration name="certs" type="Certificate[]" line="1746"/>
                <scope line="1749"/>
                <declaration name="i" type="int" line="1755"/>
                <declaration name="count" type="int" line="1756"/>
                <scope line="1757">
                    <scope line="1761"/>
                </scope>
                <declaration name="userCertList" type="ArrayList&lt;Certificate&gt;" line="1770"/>
                <scope line="1772">
                    <scope line="1776"/>
                </scope>
                <declaration name="userCerts" type="Certificate[]" line="1781"/>
            </method>
            <method name="canonicalizeCodebase" type="CodeSource" line="1787">
                <params>
                    <param name="cs" type="CodeSource"/>
                    <param name="extractSignerCerts" type="boolean"/>
                </params>
                <comment line="1796">
                    unwrap url embedded inside jar url                    
                </comment>
                <comment line="1803">
                    Fail silently. In this case, url stays what
                     it was above                    
                </comment>
                <comment line="1835">
                    leave codesource as it is, unless we have to extract its
                     signer certificates                    
                </comment>
                <declaration name="path" type="String" line="1789"/>
                <declaration name="canonCs" type="CodeSource" line="1791"/>
                <declaration name="u" type="URL" line="1792"/>
                <scope line="1793">
                    <scope line="1794">
                        <declaration name="spec" type="String" line="1796"/>
                        <declaration name="separator" type="int" line="1797"/>
                        <scope line="1798">
                            <scope line="1799"/>
                            <scope line="1801"/>
                        </scope>
                    </scope>
                    <scope line="1807">
                        <declaration name="isLocalFile" type="boolean" line="1808"/>
                        <declaration name="host" type="String" line="1809"/>
                        <scope line="1813"/>
                    </scope>
                </scope>
                <scope line="1820">
                    <scope line="1821">
                        <declaration name="csUrl" type="URL" line="1822"/>
                        <scope line="1826"/>
                        <scope line="1829"/>
                    </scope>
                    <scope line="1833">
                        <scope line="1836"/>
                    </scope>
                </scope>
                <scope line="1841">
                    <scope line="1842"/>
                </scope>
            </method>
            <method name="canonPath" type="String" line="1852">
                <params>
                    <param name="path" type="String"/>
                </params>
                <scope line="1853"/>
                <scope line="1857"/>
            </method>
            <method name="printPD" type="String" line="1862">
                <params>
                    <param name="pd" type="ProtectionDomain"/>
                </params>
                <declaration name="principals" type="Principal[]" line="1863"/>
                <declaration name="pals" type="String" line="1864"/>
                <scope line="1865">
                    <declaration name="palBuf" type="StringBuilder" line="1866"/>
                    <scope line="1867"/>
                </scope>
            </method>
            <javadoc line="1886">
                return true if no replacement was performed,
                  or if replacement succeeded.                
            </javadoc>
            <method name="replacePrincipals" type="boolean" line="1891">
                <params>
                    <param name="principals" type="List<PolicyParser.PrincipalEntry>"/>
                    <param name="keystore" type="KeyStore"/>
                </params>
                <comment line="1902">
                    perform replacement
                     (only X509 replacement is possible now)                    
                </comment>
                <comment line="1922">
                    return true if no replacement was performed,
                     or if replacement succeeded                    
                </comment>
                <declaration name="i" type="ListIterator&lt;PolicyParser.PrincipalEntry&gt;" line="1896"/>
                <scope line="1897">
                    <declaration name="pppe" type="PolicyParser.PrincipalEntry" line="1898"/>
                    <scope line="1899">
                        <declaration name="name" type="String" line="1903"/>
                        <scope line="1904"/>
                        <scope line="1908"/>
                    </scope>
                </scope>
            </method>
            <method name="expandPermissionName" type="void" line="1927">
                <params>
                    <param name="pe" type="PolicyParser.PermissionEntry"/>
                    <param name="keystore" type="KeyStore"/>
                </params>
                <comment line="1929">
                    short cut the common case                    
                </comment>
                <comment line="1944">
                    get the value in ${{...}}                    
                </comment>
                <comment line="1947">
                    parse up to the first &apos;:&apos;                    
                </comment>
                <comment line="1955">
                    handle different prefix possibilities                    
                </comment>
                <comment line="1957">
                    do nothing - handled later                    
                </comment>
                <comment line="1962">
                    get the suffix and perform keystore alias replacement                    
                </comment>
                <comment line="1990">
                    copy the rest of the value                    
                </comment>
                <comment line="1993">
                    replace the name with expanded value                    
                </comment>
                <scope line="1929"/>
                <declaration name="startIndex" type="int" line="1933"/>
                <declaration name="b" type="int" line="1934"/>
                <declaration name="sb" type="StringBuilder" line="1935"/>
                <scope line="1936">
                    <scope line="1938"/>
                    <declaration name="value" type="String" line="1944"/>
                    <declaration name="colonIndex" type="int" line="1947"/>
                    <declaration name="prefix" type="String" line="1948"/>
                    <declaration name="suffix" type="String" line="1949"/>
                    <scope line="1950"/>
                    <scope line="1955"/>
                    <scope line="1960">
                        <scope line="1962">
                            <declaration name="form" type="MessageFormat" line="1963"/>
                            <declaration name="source" type="Object[]" line="1966"/>
                        </scope>
                        <scope line="1970">
                            <declaration name="form" type="MessageFormat" line="1971"/>
                            <declaration name="source" type="Object[]" line="1974"/>
                        </scope>
                    </scope>
                    <scope line="1980">
                        <declaration name="form" type="MessageFormat" line="1981"/>
                        <declaration name="source" type="Object[]" line="1984"/>
                    </scope>
                </scope>
                <scope line="1993"/>
            </method>
            <method name="getDN" type="String" line="2000">
                <params>
                    <param name="alias" type="String"/>
                    <param name="keystore" type="KeyStore"/>
                </params>
                <comment line="2025">
                    4702543:  X500 names with an EmailAddress
                     were encoded incorrectly.  create new
                     X500Principal name with correct encoding                    
                </comment>
                <declaration name="cert" type="Certificate" line="2001"/>
                <scope line="2002"/>
                <scope line="2004">
                    <scope line="2005"/>
                </scope>
                <scope line="2014">
                    <scope line="2015"/>
                </scope>
                <scope line="2021">
                    <declaration name="x509Cert" type="X509Certificate" line="2022"/>
                    <declaration name="p" type="X500Principal" line="2028"/>
                </scope>
            </method>
            <javadoc line="2034">
                Checks public key. If it is marked as trusted in
                  the identity database, add it to the policy
                  with the AllPermission.                
            </javadoc>
            <method name="checkForTrustedIdentity" type="boolean" line="2041">
                <params>
                    <param name="cert" type="Certificate"/>
                    <param name="myInfo" type="PolicyInfo"/>
                </params>
            </method>
            <class name="PolicyEntry" line="2045">
                <comment line="2399">
                    Stores grant entries in the policy                    
                </comment>
                <comment line="2402">
                    Stores grant entries gotten from identity database
                     Use separate lists to avoid sync on policyEntries                    
                </comment>
                <comment line="2406">
                    Maps aliases to certs                    
                </comment>
                <comment line="2409">
                    Maps ProtectionDomain to PermissionCollection                    
                </comment>
                <javadoc line="2045">
                    Each entry in the policy configuration file is represented by a
                      PolicyEntry object.  &lt;p&gt;
                      A PolicyEntry is a (CodeSource,Permission) pair.  The
                      CodeSource contains the (URL, PublicKey) that together identify
                      where the Java bytecodes come from and who (if anyone) signed
                      them.  The URL could refer to localhost.  The URL could also be
                      null, meaning that this policy entry is given to all comers, as
                      long as they match the signer field.  The signer could be null,
                      meaning the code is not signed. &lt;p&gt;
                      The Permission contains the (Type, Name, Action) triplet. &lt;p&gt;
                      For now, the Policy object retrieves the public key from the
                      X.509 certificate on disk that corresponds to the signedBy
                      alias specified in the Policy config file.  For reasons of
                      efficiency, the Policy object keeps a hashtable of certs already
                      read in.  This could be replaced by a secure internal key
                      store.
                      &lt;p&gt;
                      For example, the entry
                      &lt;pre&gt;
                      permission java.io.File &quot;/tmp&quot;, &quot;read,write&quot;,
                      signedBy &quot;Duke&quot;;
                      &lt;/pre&gt;
                      is represented internally
                      &lt;pre&gt;
                      FilePermission f = new FilePermission(&quot;/tmp&quot;, &quot;read,write&quot;);
                      PublicKey p = publickeys.get(&quot;Duke&quot;);
                      URL u = InetAddress.getLocalHost();
                      CodeBase c = new CodeBase( p, u );
                      pe = new PolicyEntry(f, c);
                      &lt;/pre&gt;                    
                    <author>
                        Marianne Mueller                        
                    </author>
                    <author>
                        Roland Schemers                        
                    </author>
                    <see>
                        java.security.CodeSource                        
                    </see>
                    <see>
                        java.security.Policy                        
                    </see>
                    <see>
                        java.security.Permissions                        
                    </see>
                    <see>
                        java.security.ProtectionDomain                        
                    </see>
                </javadoc>
                <declaration name="codesource" type="CodeSource" line="2091"/>
                <declaration name="permissions" type="List&lt;Permission&gt;" line="2092"/>
                <declaration name="principals" type="List&lt;PolicyParser.PrincipalEntry&gt;" line="2093"/>
                <javadoc line="2095">
                    Given a Permission and a CodeSource, create a policy entry.
                      XXX Decide if/how to add validity fields and &quot;purpose&quot; fields to
                      XXX policy entries                    
                    <param>
                        cs the CodeSource, which encapsulates the URL and the
                          public key
                          attributes from the policy config file. Validity checks
                          are performed on the public key before PolicyEntry is
                          called.                        
                    </param>
                </javadoc>
                <method name="PolicyEntry" type="constructor" line="2109">
                    <params>
                        <param name="cs" type="CodeSource"/>
                        <param name="principals" type="List<PolicyParser.PrincipalEntry>"/>
                    </params>
                    <comment line="2113">
                        can be null                        
                    </comment>
                </method>
                <method name="PolicyEntry" type="constructor" line="2116">
                    <params>
                        <param name="cs" type="CodeSource"/>
                    </params>
                </method>
                <method name="getPrincipals" type="List<PolicyParser.PrincipalEntry>" line="2120">
                    <comment line="2122">
                        can be null                        
                    </comment>
                </method>
                <javadoc line="2124">
                    add a Permission object to this entry.
                      No need to sync add op because perms are added to entry only
                      while entry is being initialized                    
                </javadoc>
                <method name="add" type="void" line="2129">
                    <params>
                        <param name="p" type="Permission"/>
                    </params>
                </method>
                <javadoc line="2133">
                    Return the CodeSource for this policy entry                    
                </javadoc>
                <method name="getCodeSource" type="CodeSource" line="2136"/>
                <method name="toString" type="String" line="2140">
                    <declaration name="sb" type="StringBuilder" line="2141"/>
                    <scope line="2145">
                        <declaration name="p" type="Permission" line="2146"/>
                    </scope>
                </method>
            </class>
            <class name="SelfPermission" line="2158">
                <extends class="Permission"/>
                <comment line="2399">
                    Stores grant entries in the policy                    
                </comment>
                <comment line="2402">
                    Stores grant entries gotten from identity database
                     Use separate lists to avoid sync on policyEntries                    
                </comment>
                <comment line="2406">
                    Maps aliases to certs                    
                </comment>
                <comment line="2409">
                    Maps ProtectionDomain to PermissionCollection                    
                </comment>
                <declaration name="serialVersionUID" type="long" line="2160"/>
                <declaration name="type" type="String" line="2162"/>
                <javadoc line="2162">
                    The class name of the Permission class that will be
                      created when this self permission is expanded .                    
                    <serial>
                                                
                    </serial>
                </javadoc>
                <declaration name="name" type="String" line="2170"/>
                <javadoc line="2170">
                    The permission name.                    
                    <serial>
                                                
                    </serial>
                </javadoc>
                <declaration name="actions" type="String" line="2177"/>
                <javadoc line="2177">
                    The actions of the permission.                    
                    <serial>
                                                
                    </serial>
                </javadoc>
                <declaration name="certs" type="Certificate" line="2184"/>
                <javadoc line="2184">
                    The certs of the permission.                    
                    <serial>
                                                
                    </serial>
                </javadoc>
                <javadoc line="2191">
                    Creates a new SelfPermission containing the permission
                      information needed later to expand the self                    
                    <param>
                        type the class name of the Permission class that will be
                          created when this permission is expanded and if necessary resolved.                        
                    </param>
                    <param>
                        name the name of the permission.                        
                    </param>
                    <param>
                        actions the actions of the permission.                        
                    </param>
                    <param>
                        certs the certificates the permission&apos;s class was signed with.
                          This is a list of certificate chains, where each chain is composed of
                          a signer certificate and optionally its supporting certificate chain.
                          Each chain is ordered bottom-to-top (i.e., with the signer
                          certificate first and the (root) certificate authority last).                        
                    </param>
                </javadoc>
                <method name="SelfPermission" type="constructor" line="2206">
                    <params>
                        <param name="type" type="String"/>
                        <param name="name" type="String"/>
                        <param name="actions" type="String"/>
                        <param name="certs" type="Certificate"/>
                    </params>
                    <comment line="2217">
                        Extract the signer certs from the list of certificates.                        
                    </comment>
                    <comment line="2220">
                        there is no concept of signer certs, so we store the
                         entire cert array                        
                    </comment>
                    <comment line="2228">
                        Go through the list of certs and see if all the certs are
                         signer certs.                        
                    </comment>
                    <comment line="2242">
                        All the certs are signer certs, so we store the
                         entire array                        
                    </comment>
                    <comment line="2248">
                        extract the signer certs                        
                    </comment>
                    <scope line="2208"/>
                    <scope line="2215">
                        <scope line="2217">
                            <scope line="2218"/>
                        </scope>
                        <scope line="2226">
                            <declaration name="i" type="int" line="2229"/>
                            <declaration name="count" type="int" line="2230"/>
                            <scope line="2231">
                                <scope line="2235"/>
                            </scope>
                            <scope line="2240"/>
                            <scope line="2246">
                                <declaration name="signerCerts" type="ArrayList&lt;Certificate&gt;" line="2248"/>
                                <scope line="2251">
                                    <scope line="2255"/>
                                </scope>
                            </scope>
                        </scope>
                    </scope>
                </method>
                <javadoc line="2267">
                    This method always returns false for SelfPermission permissions.
                      That is, an SelfPermission never considered to
                      imply another permission.                    
                    <param>
                        p the permission to check against.                        
                    </param>
                    <return>
                        false.                        
                    </return>
                </javadoc>
                <method name="implies" type="boolean" line="2276">
                    <params>
                        <param name="p" type="Permission"/>
                    </params>
                </method>
                <javadoc line="2280">
                    Checks two SelfPermission objects for equality.
                      Checks that &lt;i&gt;obj&lt;/i&gt; is an SelfPermission, and has
                      the same type (class) name, permission name, actions, and
                      certificates as this object.                    
                    <param>
                        obj the object we are testing for equality with this object.                        
                    </param>
                    <return>
                        true if obj is an SelfPermission, and has the same
                          type (class) name, permission name, actions, and
                          certificates as this object.                        
                    </return>
                </javadoc>
                <method name="equals" type="boolean" line="2293">
                    <params>
                        <param name="obj" type="Object"/>
                    </params>
                    <declaration name="that" type="SelfPermission" line="2299"/>
                    <declaration name="i" type="int" line="2309"/>
                    <declaration name="match" type="boolean" line="2310"/>
                    <scope line="2312">
                        <scope line="2314">
                            <scope line="2315"/>
                        </scope>
                    </scope>
                    <scope line="2323">
                        <scope line="2325">
                            <scope line="2326"/>
                        </scope>
                    </scope>
                </method>
                <javadoc line="2336">
                    Returns the hash code value for this object.                    
                    <return>
                        a hash code value for this object.                        
                    </return>
                </javadoc>
                <method name="hashCode" type="int" line="2341">
                    <declaration name="hash" type="int" line="2342"/>
                </method>
                <javadoc line="2350">
                    Returns the canonical string representation of the actions,
                      which currently is the empty string &quot;&quot;, since there are no actions
                      for an SelfPermission. That is, the actions for the
                      permission that will be created when this SelfPermission
                      is resolved may be non-null, but an SelfPermission
                      itself is never considered to have any actions.                    
                    <return>
                        the empty string &quot;&quot;.                        
                    </return>
                </javadoc>
                <method name="getActions" type="String" line="2360"/>
                <method name="getSelfType" type="String" line="2364"/>
                <method name="getSelfName" type="String" line="2368"/>
                <method name="getSelfActions" type="String" line="2372"/>
                <method name="getCerts" type="Certificate[]" line="2376"/>
                <javadoc line="2380">
                    Returns a string describing this SelfPermission.  The convention
                      is to specify the class name, the permission name, and the actions,
                      in the following format: &apos;(unresolved &quot;ClassName&quot; &quot;name&quot; &quot;actions&quot;)&apos;.                    
                    <return>
                        information about this SelfPermission.                        
                    </return>
                </javadoc>
                <method name="toString" type="String" line="2387"/>
            </class>
            <class name="PolicyInfo" line="2392">
                <comment line="2399">
                    Stores grant entries in the policy                    
                </comment>
                <comment line="2402">
                    Stores grant entries gotten from identity database
                     Use separate lists to avoid sync on policyEntries                    
                </comment>
                <comment line="2406">
                    Maps aliases to certs                    
                </comment>
                <comment line="2409">
                    Maps ProtectionDomain to PermissionCollection                    
                </comment>
                <javadoc line="2392">
                    holds policy information that we need to synch on                    
                </javadoc>
                <declaration name="verbose" type="boolean" line="2396"/>
                <declaration name="policyEntries" type="List&lt;PolicyEntry&gt;" line="2399"/>
                <declaration name="identityPolicyEntries" type="List&lt;PolicyEntry&gt;" line="2403"/>
                <declaration name="aliasMapping" type="Map" line="2406"/>
                <declaration name="pdMapping" type="ProtectionDomainCache[]" line="2409"/>
                <declaration name="random" type="java.util.Random" line="2410"/>
                <method name="PolicyInfo" type="constructor" line="2412">
                    <params>
                        <param name="numCaches" type="int"/>
                    </params>
                    <declaration name="jspda" type="JavaSecurityProtectionDomainAccess" line="2419"/>
                    <scope line="2421"/>
                    <scope line="2424"/>
                </method>
                <method name="getPdMapping" type="ProtectionDomainCache" line="2428">
                    <scope line="2429"/>
                    <scope line="2431">
                        <declaration name="i" type="int" line="2432"/>
                    </scope>
                </method>
            </class>
        </class>
    </source>