<?xml version="1.0" encoding="UTF-8"?>
    <source package="sun.security.provider">
        <import package="java.io.IOException"/>
        <import package="java.io.UnsupportedEncodingException"/>
        <import package="java.security.Key"/>
        <import package="java.security.KeyStoreException"/>
        <import package="java.security.MessageDigest"/>
        <import package="java.security.NoSuchAlgorithmException"/>
        <import package="java.security.SecureRandom"/>
        <import package="java.security.UnrecoverableKeyException"/>
        <import package="java.util"/>
        <import package="sun.security.pkcs.PKCS8Key"/>
        <import package="sun.security.pkcs.EncryptedPrivateKeyInfo"/>
        <import package="sun.security.x509.AlgorithmId"/>
        <import package="sun.security.util.ObjectIdentifier"/>
        <import package="sun.security.util.DerValue"/>
        <class name="KeyProtector" line="44">
            <comment line="106">
                the salt length                
            </comment>
            <comment line="110">
                defined by JavaSoft                
            </comment>
            <comment line="113">
                The password used for protecting/recovering keys passed through this
                 key protector. We store it as a byte array, so that we can digest it.                
            </comment>
            <comment line="158">
                Protects the given plaintext key, using the password provided at
                 construction time.                
            </comment>
            <comment line="249">
                Recovers the plaintext version of the given key (in protected format),
                 using the password provided at construction time.                
            </comment>
            <javadoc line="44">
                This is an implementation of a Sun proprietary, exportable algorithm
                  intended for use when protecting (or recovering the cleartext version of)
                  sensitive keys.
                  This algorithm is not intended as a general purpose cipher.
                  This is how the algorithm works for key protection:
                  p - user password
                  s - random salt
                  X - xor key
                  P - to-be-protected key
                  Y - protected key
                  R - what gets stored in the keystore
                  Step 1:
                  Take the user&apos;s password, append a random salt (of fixed size) to it,
                  and hash it: d1 = digest(p, s)
                  Store d1 in X.
                  Step 2:
                  Take the user&apos;s password, append the digest result from the previous step,
                  and hash it: dn = digest(p, dn-1).
                  Store dn in X (append it to the previously stored digests).
                  Repeat this step until the length of X matches the length of the private key
                  P.
                  Step 3:
                  XOR X and P, and store the result in Y: Y = X XOR P.
                  Step 4:
                  Store s, Y, and digest(p, P) in the result buffer R:
                  R = s + Y + digest(p, P), where &quot;+&quot; denotes concatenation.
                  (NOTE: digest(p, P) is stored in the result buffer, so that when the key is
                  recovered, we can check if the recovered key indeed matches the original
                  key.) R is stored in the keystore.
                  The protected key is recovered as follows:
                  Step1 and Step2 are the same as above, except that the salt is not randomly
                  generated, but taken from the result R of step 4 (the first length(s)
                  bytes).
                  Step 3 (XOR operation) yields the plaintext key.
                  Then concatenate the password with the recovered key, and compare with the
                  last length(digest(p, P)) bytes of R. If they match, the recovered key is
                  indeed the same key as the original key.                
                <author>
                    Jan Luehe                    
                </author>
                <see>
                    java.security.KeyStore                    
                </see>
                <see>
                    JavaKeyStore                    
                </see>
                <see>
                    KeyTool                    
                </see>
                <since>
                    1.2                    
                </since>
            </javadoc>
            <declaration name="SALT_LEN" type="int" line="105"/>
            <declaration name="DIGEST_ALG" type="String" line="106"/>
            <declaration name="DIGEST_LEN" type="int" line="107"/>
            <declaration name="KEY_PROTECTOR_OID" type="String" line="110"/>
            <declaration name="passwdBytes" type="byte[]" line="114"/>
            <declaration name="md" type="MessageDigest" line="116"/>
            <javadoc line="119">
                Creates an instance of this class, and initializes it with the given
                  password.
                  &lt;p&gt;The password is expected to be in printable ASCII.
                  Normal rules for good password selection apply: at least
                  seven characters, mixed case, with punctuation encouraged.
                  Phrases or words which are easily guessed, for example by
                  being found in dictionaries, are bad.                
            </javadoc>
            <method name="KeyProtector" type="constructor" line="131">
                <params>
                    <param name="password" type="char[]"/>
                </params>
                <comment line="139">
                    Convert password to byte array, so that it can be digested                    
                </comment>
                <declaration name="i" type="int" line="132"/>
                <scope line="134"/>
                <scope line="140"/>
            </method>
            <javadoc line="146">
                Ensures that the password bytes of this key protector are
                  set to zero when there are no more references to it.                
            </javadoc>
            <method name="finalize" type="void" line="150">
                <scope line="151"/>
            </method>
            <method name="protect" type="byte[]" line="162">
                <params>
                    <param name="key" type="Key"/>
                </params>
                <comment line="167">
                    offset in xorKey where next digest will be stored                    
                </comment>
                <comment line="185">
                    Determine the number of digest rounds                    
                </comment>
                <comment line="190">
                    Create a random salt                    
                </comment>
                <comment line="195">
                    Set up the byte array which will be XORed with &quot;plainKey&quot;                    
                </comment>
                <comment line="198">
                    Compute the digests, and store them in &quot;xorKey&quot;                    
                </comment>
                <comment line="206">
                    Copy the digest into &quot;xorKey&quot;                    
                </comment>
                <comment line="216">
                    XOR &quot;plainKey&quot; with &quot;xorKey&quot;, and store the result in &quot;tmpKey&quot;                    
                </comment>
                <comment line="222">
                    Store salt and &quot;tmpKey&quot; in &quot;encrKey&quot;                    
                </comment>
                <comment line="229">
                    Append digest(password, plainKey) as an integrity check to &quot;encrKey&quot;                    
                </comment>
                <comment line="238">
                    wrap the protected private key in a PKCS#8-style
                     EncryptedPrivateKeyInfo, and returns its encoding                    
                </comment>
                <declaration name="i" type="int" line="163"/>
                <declaration name="numRounds" type="int" line="164"/>
                <declaration name="digest" type="byte[]" line="165"/>
                <declaration name="xorOffset" type="int" line="166"/>
                <declaration name="encrKeyOffset" type="int" line="167"/>
                <scope line="169"/>
                <scope line="173"/>
                <declaration name="plainKey" type="byte[]" line="178"/>
                <scope line="179"/>
                <declaration name="salt" type="byte[]" line="190"/>
                <declaration name="random" type="SecureRandom" line="191"/>
                <declaration name="xorKey" type="byte[]" line="195"/>
                <scope line="200">
                    <scope line="206"/>
                    <scope line="209"/>
                </scope>
                <declaration name="tmpKey" type="byte[]" line="216"/>
                <scope line="217"/>
                <declaration name="encrKey" type="byte[]" line="222"/>
                <declaration name="encrAlg" type="AlgorithmId" line="239"/>
                <scope line="240"/>
                <scope line="243"/>
            </method>
            <method name="recover" type="Key" line="254">
                <params>
                    <param name="encrInfo" type="EncryptedPrivateKeyInfo"/>
                </params>
                <comment line="259">
                    offset in xorKey where next digest will be stored                    
                </comment>
                <comment line="260">
                    the length of the encrpyted key                    
                </comment>
                <comment line="262">
                    do we support the algorithm?                    
                </comment>
                <comment line="271">
                    Get the salt associated with this key (the first SALT_LEN bytes of
                     &lt;code&gt;protectedKey&lt;code&gt;)                    
                </comment>
                <comment line="278">
                    Determine the number of digest rounds                    
                </comment>
                <comment line="283">
                    Get the encrypted key portion and store it in &quot;encrKey&quot;                    
                </comment>
                <comment line="287">
                    Set up the byte array which will be XORed with &quot;encrKey&quot;                    
                </comment>
                <comment line="290">
                    Compute the digests, and store them in &quot;xorKey&quot;                    
                </comment>
                <comment line="298">
                    Copy the digest into &quot;xorKey&quot;                    
                </comment>
                <comment line="308">
                    XOR &quot;encrKey&quot; with &quot;xorKey&quot;, and store the result in &quot;plainKey&quot;                    
                </comment>
                <comment line="314">
                    Check the integrity of the recovered key by concatenating it with
                     the password, digesting the concatenation, and comparing the
                     result of the digest operation with the digest provided at the end
                     of &lt;code&gt;protectedKey&lt;code&gt;. If the two digest values are
                     different, throw an exception.                    
                </comment>
                <comment line="333">
                    The parseKey() method of PKCS8Key parses the key
                     algorithm and instantiates the appropriate key factory,
                     which in turn parses the key material.                    
                </comment>
                <declaration name="i" type="int" line="255"/>
                <declaration name="digest" type="byte[]" line="256"/>
                <declaration name="numRounds" type="int" line="257"/>
                <declaration name="xorOffset" type="int" line="258"/>
                <declaration name="encrKeyLen" type="int" line="259"/>
                <declaration name="encrAlg" type="AlgorithmId" line="262"/>
                <scope line="263"/>
                <declaration name="protectedKey" type="byte[]" line="268"/>
                <declaration name="salt" type="byte[]" line="274"/>
                <declaration name="encrKey" type="byte[]" line="283"/>
                <declaration name="xorKey" type="byte[]" line="287"/>
                <scope line="292">
                    <scope line="298"/>
                    <scope line="301"/>
                </scope>
                <declaration name="plainKey" type="byte[]" line="308"/>
                <scope line="309"/>
                <scope line="326">
                    <scope line="327"/>
                </scope>
                <scope line="335"/>
                <scope line="337"/>
            </method>
        </class>
    </source>