<?xml version="1.0" encoding="UTF-8"?>
    <source package="sun.security.provider">
        <import package="java.lang.Integer.reverseBytes"/>
        <import package="java.lang.Long.reverseBytes"/>
        <import package="java.nio.ByteOrder"/>
        <import package="sun.misc.Unsafe"/>
        <class name="ByteArrayAccess" line="35">
            <comment line="67">
                whether to use the optimized path for little endian platforms that
                 support full speed unaligned memory access.                
            </comment>
            <comment line="71">
                whether to use the optimzied path for big endian platforms that
                 support only correctly aligned full speed memory access.
                 (Note that on SPARC unaligned memory access is possible, but it is
                 implemented using a software trap and therefore very slow)                
            </comment>
            <comment line="92">
                Return whether this platform supports full speed int/long memory access
                 at unaligned addresses.
                 This code was copied from java.nio.Bits because there is no equivalent
                 public API.                
            </comment>
            <comment line="132">
                Special optimization of b2iLittle(in, inOfs, out, 0, 64)                
            </comment>
            <comment line="205">
                Store one 32-bit value into out[outOfs..outOfs+3] in little endian order.                
            </comment>
            <comment line="249">
                Special optimization of b2iBig(in, inOfs, out, 0, 64)                
            </comment>
            <comment line="322">
                Store one 32-bit value into out[outOfs..outOfs+3] in big endian order.                
            </comment>
            <comment line="379">
                Special optimization of b2lBig(in, inOfs, out, 0, 128)                
            </comment>
            <javadoc line="35">
                Optimized methods for converting between byte[] and int[]/long[], both for
                  big endian and little endian byte orders.
                  Currently, it includes a default code path plus two optimized code paths.
                  One is for little endian architectures that support full speed int/long
                  access at unaligned addresses (i.e. x86/amd64). The second is for big endian
                  architectures (that only support correctly aligned access), such as SPARC.
                  These are the only platforms we currently support, but other optimized
                  variants could be added as needed.
                  NOTE that because this code performs unchecked direct memory access, it
                  MUST be restricted to trusted code. It is imperative that the caller protects
                  against out of bounds memory access by performing the necessary bounds
                  checks before calling methods in this class.
                  This class may also be helpful in improving the performance of the
                  crypto code in the SunJCE provider. However, for now it is only accessible by
                  the message digest implementation in the SUN provider.                
                <since>
                    1.6                    
                </since>
                <author>
                    Andreas Sterbenz                    
                </author>
            </javadoc>
            <method name="ByteArrayAccess" type="constructor" line="60">
                <comment line="62">
                    empty                    
                </comment>
            </method>
            <declaration name="unsafe" type="Unsafe" line="64"/>
            <declaration name="littleEndianUnaligned" type="boolean" line="68"/>
            <declaration name="bigEndian" type="boolean" line="74"/>
            <declaration name="byteArrayOfs" type="int" line="76"/>
            <scope line="78">
                <declaration name="scaleOK" type="boolean" line="79"/>
                <declaration name="byteOrder" type="ByteOrder" line="84"/>
            </scope>
            <method name="unaligned" type="boolean" line="95">
                <declaration name="arch" type="String" line="96"/>
            </method>
            <javadoc line="101">
                byte[] to int[] conversion, little endian byte order.                
            </javadoc>
            <method name="b2iLittle" type="void" line="104">
                <params>
                    <param name="in" type="byte[]"/>
                    <param name="inOfs" type="int"/>
                    <param name="out" type="int[]"/>
                    <param name="outOfs" type="int"/>
                    <param name="len" type="int"/>
                </params>
                <scope line="105">
                    <scope line="108"/>
                </scope>
                <scope line="112">
                    <scope line="115"/>
                </scope>
                <scope line="119">
                    <scope line="121"/>
                </scope>
            </method>
            <method name="b2iLittle64" type="void" line="132">
                <params>
                    <param name="in" type="byte[]"/>
                    <param name="inOfs" type="int"/>
                    <param name="out" type="int[]"/>
                </params>
                <scope line="133"/>
                <scope line="151"/>
                <scope line="169"/>
            </method>
            <javadoc line="174">
                int[] to byte[] conversion, little endian byte order.                
            </javadoc>
            <method name="i2bLittle" type="void" line="177">
                <params>
                    <param name="in" type="int[]"/>
                    <param name="inOfs" type="int"/>
                    <param name="out" type="byte[]"/>
                    <param name="outOfs" type="int"/>
                    <param name="len" type="int"/>
                </params>
                <scope line="178">
                    <scope line="181"/>
                </scope>
                <scope line="185">
                    <scope line="188"/>
                </scope>
                <scope line="192">
                    <scope line="194">
                        <declaration name="i" type="int" line="195"/>
                    </scope>
                </scope>
            </method>
            <method name="i2bLittle4" type="void" line="205">
                <params>
                    <param name="val" type="int"/>
                    <param name="out" type="byte[]"/>
                    <param name="outOfs" type="int"/>
                </params>
                <scope line="206"/>
                <scope line="208"/>
                <scope line="210"/>
            </method>
            <javadoc line="218">
                byte[] to int[] conversion, big endian byte order.                
            </javadoc>
            <method name="b2iBig" type="void" line="221">
                <params>
                    <param name="in" type="byte[]"/>
                    <param name="inOfs" type="int"/>
                    <param name="out" type="int[]"/>
                    <param name="outOfs" type="int"/>
                    <param name="len" type="int"/>
                </params>
                <scope line="222">
                    <scope line="225"/>
                </scope>
                <scope line="229">
                    <scope line="232"/>
                </scope>
                <scope line="236">
                    <scope line="238"/>
                </scope>
            </method>
            <method name="b2iBig64" type="void" line="249">
                <params>
                    <param name="in" type="byte[]"/>
                    <param name="inOfs" type="int"/>
                    <param name="out" type="int[]"/>
                </params>
                <scope line="250"/>
                <scope line="268"/>
                <scope line="286"/>
            </method>
            <javadoc line="291">
                int[] to byte[] conversion, big endian byte order.                
            </javadoc>
            <method name="i2bBig" type="void" line="294">
                <params>
                    <param name="in" type="int[]"/>
                    <param name="inOfs" type="int"/>
                    <param name="out" type="byte[]"/>
                    <param name="outOfs" type="int"/>
                    <param name="len" type="int"/>
                </params>
                <scope line="295">
                    <scope line="298"/>
                </scope>
                <scope line="302">
                    <scope line="305"/>
                </scope>
                <scope line="309">
                    <scope line="311">
                        <declaration name="i" type="int" line="312"/>
                    </scope>
                </scope>
            </method>
            <method name="i2bBig4" type="void" line="322">
                <params>
                    <param name="val" type="int"/>
                    <param name="out" type="byte[]"/>
                    <param name="outOfs" type="int"/>
                </params>
                <scope line="323"/>
                <scope line="325"/>
                <scope line="327"/>
            </method>
            <javadoc line="335">
                byte[] to long[] conversion, big endian byte order.                
            </javadoc>
            <method name="b2lBig" type="void" line="338">
                <params>
                    <param name="in" type="byte[]"/>
                    <param name="inOfs" type="int"/>
                    <param name="out" type="long[]"/>
                    <param name="outOfs" type="int"/>
                    <param name="len" type="int"/>
                </params>
                <comment line="348">
                    In the current HotSpot memory layout, the first element of a
                     byte[] is only 32-bit aligned, not 64-bit.
                     That means we could use getLong() only for offset 4, 12, etc.,
                     which would rarely occur in practice. Instead, we use an
                     optimization that uses getInt() so that it works for offset 0.                    
                </comment>
                <scope line="339">
                    <scope line="342"/>
                </scope>
                <scope line="346">
                    <scope line="354"/>
                </scope>
                <scope line="360">
                    <scope line="362">
                        <declaration name="i1" type="int" line="363"/>
                        <declaration name="i2" type="int" line="368"/>
                    </scope>
                </scope>
            </method>
            <method name="b2lBig128" type="void" line="379">
                <params>
                    <param name="in" type="byte[]"/>
                    <param name="inOfs" type="int"/>
                    <param name="out" type="long[]"/>
                </params>
                <comment line="400">
                    no optimization for big endian, see comments in b2lBig                    
                </comment>
                <scope line="380"/>
                <scope line="398"/>
            </method>
            <javadoc line="404">
                long[] to byte[] conversion, big endian byte order.                
            </javadoc>
            <method name="l2bBig" type="void" line="407">
                <params>
                    <param name="in" type="long[]"/>
                    <param name="inOfs" type="int"/>
                    <param name="out" type="byte[]"/>
                    <param name="outOfs" type="int"/>
                    <param name="len" type="int"/>
                </params>
                <scope line="409">
                    <declaration name="i" type="long" line="410"/>
                </scope>
            </method>
        </class>
    </source>