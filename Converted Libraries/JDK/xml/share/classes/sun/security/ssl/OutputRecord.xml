<?xml version="1.0" encoding="UTF-8"?>
    <source package="sun.security.ssl">
        <import package="java.io"/>
        <import package="java.nio"/>
        <import package="javax.net.ssl.SSLException"/>
        <import package="sun.misc.HexDumpEncoder"/>
        <class name="OutputRecord" line="36">
            <extends class="ByteArrayOutputStream"/>
            <comment line="58">
                current protocol version, sent as record version                
            </comment>
            <comment line="61">
                version for the ClientHello message. Only relevant if this is a                
            </comment>
            <comment line="62">
                client handshake record. If set to ProtocolVersion.SSL20Hello,                
            </comment>
            <comment line="63">
                the V3 client hello is converted to V2 format.                
            </comment>
            <comment line="66">
                                
            </comment>
            <comment line="69">
                Default constructor makes a record supporting the maximum
                 SSL record size.  It allocates the header bytes directly.
                
                 @param type the content type for the record                
            </comment>
            <comment line="101">
                Updates the SSL version of this record.                
            </comment>
            <comment line="108">
                Updates helloVersion of this record.                
            </comment>
            <comment line="115">
                Reset the record so that it can be refilled, starting
                 immediately after the header.                
            </comment>
            <comment line="125">
                For handshaking, we need to be able to hash every byte above the
                 record marking layer.  This is where we&apos;re guaranteed to see those
                 bytes, so this is where we can hash them.                
            </comment>
            <comment line="135">
                We hash (the plaintext) on demand.  There is one place where
                 we want to access the hash in the middle of a record:  client
                 cert message gets hashed, and part of the same record is the
                 client cert verify message which uses that hash.  So we track
                 how much of each record we&apos;ve hashed so far.                
            </comment>
            <comment line="151">
                Need a helper function so we can hash the V2 hello correctly                
            </comment>
            <comment line="170">
                Return true iff the record is empty -- to avoid doing the work
                 of sending empty records over the network.                
            </comment>
            <comment line="178">
                Return true if the record is of a given alert.                
            </comment>
            <comment line="191">
                Compute the MAC and append it to this record.  In case we
                 are automatically flushing a handshake stream, make sure we
                 have hashed the message first.                
            </comment>
            <comment line="212">
                Encrypt ... length may grow due to block cipher padding                
            </comment>
            <comment line="221">
                Tell how full the buffer is ... for filling it with application or
                 handshake data.                
            </comment>
            <comment line="230">
                Return the type of SSL record that&apos;s buffered here.                
            </comment>
            <comment line="237">
                Write the record out on the stream.  Note that you must have (in
                 order) compressed the data, appended the MAC, and encrypted it in
                 order for the record to be understood by the other end.  (Some of
                 those steps will be null early in handshaking.)
                
                 Note that this does no locking for the connection, it&apos;s required
                 that synchronization be done elsewhere.  Also, this does its work
                 in a single low level write, for efficiency.                
            </comment>
            <comment line="308">
                Actually do the write here.  For SSLEngine&apos;s HS data,
                 we&apos;ll override this method and let it take the appropriate
                 action.                
            </comment>
            <comment line="330">
                Return whether the buffer contains a ClientHello message that should
                 be converted to V2 format.                
            </comment>
            <comment line="342">
                Detect &quot;old&quot; servers which are capable of SSL V2.0 protocol ... for
                 example, Netscape Commerce 1.0 servers.  The V3 message is in the
                 header and the bytes passed as parameter.  This routine translates
                 the V3 message into an equivalent V2 one.
                
                 Note that the translation will strip off all hello extensions as
                 SSL V2.0 does not support hello extension.                
            </comment>
            <comment line="415">
                Mappings from V3 cipher suite encodings to their pure V2 equivalents.
                 This is taken from the SSL V3 specification, Appendix E.                
            </comment>
            <comment line="424">
                See which matching pure-V2 cipher specs we need to include.
                 We are including these not because we are actually prepared
                 to talk V2 but because the Oracle Web Server insists on receiving
                 at least 1 &quot;pure V2&quot; cipher suite that it supports and returns an
                 illegal_parameter alert unless one is present. Rather than mindlessly
                 claiming to implement all documented pure V2 cipher suites the code below
                 just claims to implement the V2 cipher suite that is &quot;equivalent&quot;
                 in terms of cipher algorithm &amp; exportability with the actual V3 cipher
                 suite that we do support.                
            </comment>
            <implements interface="Record"/>
            <javadoc line="36">
                SSL 3.0 records, as written to a TCP stream.
                  Each record has a message area that starts out with data supplied by the
                  application.  It may grow/shrink due to compression and will be modified
                  in place for mac-ing and encryption.
                  Handshake records have additional needs, notably accumulation of a set
                  of hashes which are used to establish that handshaking was done right.
                  Handshake records usually have several handshake messages each, and we
                  need message-level control over what&apos;s hashed.                
                <author>
                    David Brownell                    
                </author>
            </javadoc>
            <declaration name="handshakeHash" type="HandshakeHash" line="52"/>
            <declaration name="lastHashed" type="int" line="53"/>
            <declaration name="firstMessage" type="boolean" line="54"/>
            <declaration name="contentType" type="byte" line="55"/>
            <declaration name="protocolVersion" type="ProtocolVersion" line="58"/>
            <declaration name="helloVersion" type="ProtocolVersion" line="63"/>
            <declaration name="debug" type="Debug" line="66"/>
            <method name="OutputRecord" type="constructor" line="74">
                <params>
                    <param name="type" type="byte"/>
                    <param name="size" type="int"/>
                </params>
            </method>
            <method name="OutputRecord" type="constructor" line="84">
                <params>
                    <param name="type" type="byte"/>
                </params>
            </method>
            <javadoc line="88">
                Get the size of the buffer we need for records of the specified
                  type.                
            </javadoc>
            <method name="recordSize" type="int" line="92">
                <params>
                    <param name="type" type="byte"/>
                </params>
                <scope line="93"/>
                <scope line="95"/>
            </method>
            <method name="setVersion" type="void" line="103">
                <params>
                    <param name="protocolVersion" type="ProtocolVersion"/>
                </params>
            </method>
            <method name="setHelloVersion" type="void" line="110">
                <params>
                    <param name="helloVersion" type="ProtocolVersion"/>
                </params>
            </method>
            <method name="reset" type="void" line="118"/>
            <method name="setHandshakeHash" type="void" line="129">
                <params>
                    <param name="handshakeHash" type="HandshakeHash"/>
                </params>
            </method>
            <method name="doHashes" type="void" line="141">
                <declaration name="len" type="int" line="142"/>
                <scope line="144"/>
            </method>
            <method name="hashInternal" type="void" line="153">
                <params>
                    <param name="buf" type="byte"/>
                    <param name="offset" type="int"/>
                    <param name="len" type="int"/>
                </params>
                <scope line="154">
                    <scope line="155">
                        <declaration name="hd" type="HexDumpEncoder" line="156"/>
                    </scope>
                    <scope line="162"/>
                </scope>
            </method>
            <method name="isEmpty" type="boolean" line="173"/>
            <method name="isAlert" type="boolean" line="180">
                <params>
                    <param name="description" type="byte"/>
                </params>
                <comment line="181">
                    An alert is defined with a two bytes struct,                    
                </comment>
                <comment line="182">
                    {byte level, byte description}, following after the header bytes.                    
                </comment>
                <scope line="183"/>
            </method>
            <method name="addMAC" type="void" line="195">
                <params>
                    <param name="signer" type="MAC"/>
                </params>
                <comment line="196">
                                        
                </comment>
                <comment line="197">
                    when we support compression, hashing can&apos;t go here                    
                </comment>
                <comment line="198">
                    since it&apos;ll need to be done on the uncompressed data,                    
                </comment>
                <comment line="199">
                    and the MAC applies to the compressed data.                    
                </comment>
                <comment line="200">
                                        
                </comment>
                <scope line="201"/>
                <scope line="204">
                    <declaration name="hash" type="byte[]" line="205"/>
                </scope>
            </method>
            <method name="encrypt" type="void" line="214">
                <params>
                    <param name="box" type="CipherBox"/>
                </params>
                <declaration name="len" type="int" line="215"/>
            </method>
            <method name="availableDataBytes" type="int" line="224">
                <declaration name="dataSize" type="int" line="225"/>
            </method>
            <method name="contentType" type="byte" line="232"/>
            <method name="write" type="void" line="246">
                <params>
                    <param name="s" type="OutputStream"/>
                </params>
                <comment line="247">
                    Don&apos;t emit content-free records.  (Even change cipher spec
                     messages have a byte of data!)                    
                </comment>
                <comment line="256">
                    &quot;should&quot; really never write more than about 14 Kb...                    
                </comment>
                <comment line="267">
                    v3.0/v3.1 ...                    
                </comment>
                <comment line="273">
                    If this is the initial ClientHello on this connection and
                     we&apos;re not trying to resume a (V3) session then send a V2
                     ClientHello instead so we can detect V2 servers cleanly.                    
                </comment>
                <comment line="289">
                    2 byte SSLv2 header                    
                </comment>
                <comment line="292">
                    Fill out the header, write it and the message.                    
                </comment>
                <scope line="251"/>
                <declaration name="length" type="int" line="255"/>
                <scope line="257"/>
                <scope line="263"/>
                <scope line="278">
                    <declaration name="v3Msg" type="byte[]" line="279"/>
                    <scope line="285"/>
                </scope>
                <scope line="291"/>
            </method>
            <method name="writeBuffer" type="void" line="313">
                <params>
                    <param name="s" type="OutputStream"/>
                    <param name="buf" type="byte[]"/>
                    <param name="off" type="int"/>
                    <param name="len" type="int"/>
                </params>
                <scope line="317">
                    <scope line="318">
                        <declaration name="hd" type="HexDumpEncoder" line="319"/>
                        <declaration name="bb" type="ByteBuffer" line="320"/>
                    </scope>
                    <scope line="325"/>
                </scope>
            </method>
            <method name="useV2Hello" type="boolean" line="333">
                <comment line="338">
                    V3 session ID is empty                    
                </comment>
            </method>
            <method name="V3toV2ClientHello" type="void" line="350">
                <params>
                    <param name="v3Msg" type="byte"/>
                </params>
                <comment line="351">
                    version + nonce                    
                </comment>
                <comment line="356">
                    2 bytes each in V3                    
                </comment>
                <comment line="358">
                    Copy over the cipher specs. We don&apos;t care about actually translating
                     them for use with an actual V2 server since we only talk V3.
                     Therefore, just copy over the V3 cipher spec values with a leading
                     0.                    
                </comment>
                <comment line="364">
                    skip length                    
                </comment>
                <comment line="384">
                    Build the first part of the V3 record header from the V2 one
                     that&apos;s now buffered up.  (Lengths are fixed up later).                    
                </comment>
                <comment line="389">
                    major version                    
                </comment>
                <comment line="390">
                    minor version                    
                </comment>
                <comment line="394">
                    always no session                    
                </comment>
                <comment line="396">
                    nonce length (always 32 in V3)                    
                </comment>
                <comment line="398">
                    Copy in the nonce.                    
                </comment>
                <comment line="404">
                    Set the length of the message.                    
                </comment>
                <comment line="407">
                    don&apos;t include length field itself                    
                </comment>
                <declaration name="v3SessionIdLenOffset" type="int" line="351"/>
                <declaration name="v3SessionIdLen" type="int" line="352"/>
                <declaration name="v3CipherSpecLenOffset" type="int" line="353"/>
                <declaration name="v3CipherSpecLen" type="int" line="354"/>
                <declaration name="cipherSpecs" type="int" line="356"/>
                <declaration name="v3CipherSpecOffset" type="int" line="364"/>
                <declaration name="v2CipherSpecLen" type="int" line="365"/>
                <declaration name="containsRenegoInfoSCSV" type="boolean" line="367"/>
                <scope line="368">
                    <declaration name="byte1" type="byte" line="369"/>
                    <scope line="375"/>
                </scope>
                <scope line="380"/>
            </method>
            <declaration name="V3toV2CipherMap1" type="int[]" line="418"/>
            <declaration name="V3toV2CipherMap3" type="int[]" line="420"/>
            <method name="V3toV2CipherSuite" type="int" line="434">
                <params>
                    <param name="byte1" type="byte"/>
                    <param name="byte2" type="byte"/>
                </params>
                <scope line="440"/>
            </method>
        </class>
    </source>