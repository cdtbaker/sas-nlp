<?xml version="1.0" encoding="UTF-8"?>
    <source package="sun.security.ssl">
        <import package="java.io"/>
        <class name="AppInputStream" line="31">
            <extends class="InputStream"/>
            <comment line="41">
                static dummy array we use to implement skip()                
            </comment>
            <comment line="47">
                One element array used to implement the single byte read() method                
            </comment>
            <comment line="142">
                Socket close is already synchronized, no need to block here.                
            </comment>
            <comment line="149">
                inherit default mark/reset behavior (throw Exceptions) from InputStream                
            </comment>
            <javadoc line="31">
                InputStream for application data as returned by SSLSocket.getInputStream().
                  It uses an InputRecord as internal buffer that is refilled on demand
                  whenever it runs out of data.                
                <author>
                    David Brownell                    
                </author>
            </javadoc>
            <declaration name="SKIP_ARRAY" type="byte[]" line="41"/>
            <declaration name="c" type="SSLSocketImpl" line="43"/>
            <declaration name="r" type="InputRecord" line="44"/>
            <declaration name="oneByte" type="byte[]" line="47"/>
            <method name="AppInputStream" type="constructor" line="49">
                <params>
                    <param name="conn" type="SSLSocketImpl"/>
                </params>
            </method>
            <javadoc line="54">
                Return the minimum number of bytes that can be read without blocking.
                  Currently not synchronized.                
            </javadoc>
            <method name="available" type="int" line="58">
                <scope line="59"/>
            </method>
            <javadoc line="65">
                Read a single byte, returning -1 on non-fault EOF status.                
            </javadoc>
            <method name="read" type="int" line="68">
                <comment line="71">
                    EOF                    
                </comment>
                <declaration name="n" type="int" line="69"/>
                <scope line="70"/>
            </method>
            <javadoc line="76">
                Read up to &quot;len&quot; bytes into this buffer, starting at &quot;off&quot;.
                  If the layer above needs more data, it asks for more, so we
                  are responsible only for blocking to fill at most one buffer,
                  and returning &quot;-1&quot; on non-fault EOF status.                
            </javadoc>
            <method name="read" type="int" line="83">
                <params>
                    <param name="b" type="byte"/>
                    <param name="off" type="int"/>
                    <param name="len" type="int"/>
                </params>
                <comment line="97">
                    Read data if needed ... notice that the connection guarantees
                     that handshake, alert, and change cipher spec data streams are
                     handled as they arrive, so we never see them here.                    
                </comment>
                <comment line="113">
                    shutdown and rethrow (wrapped) exception as appropriate                    
                </comment>
                <comment line="115">
                    dummy for compiler                    
                </comment>
                <scope line="84"/>
                <scope line="86"/>
                <scope line="88"/>
                <scope line="92"/>
                <scope line="95">
                    <scope line="101">
                        <scope line="103"/>
                    </scope>
                    <declaration name="howmany" type="int" line="108"/>
                </scope>
                <scope line="111"/>
            </method>
            <javadoc line="120">
                Skip n bytes. This implementation is somewhat less efficient
                  than possible, but not badly so (redundant copy). We reuse
                  the read() code to keep things simpler. Note that SKIP_ARRAY
                  is static and may garbled by concurrent use, but we are not interested
                  in the data anyway.                
            </javadoc>
            <method name="skip" type="long" line="127">
                <params>
                    <param name="n" type="long"/>
                </params>
                <declaration name="skipped" type="long" line="128"/>
                <scope line="129">
                    <declaration name="len" type="int" line="130"/>
                    <declaration name="r" type="int" line="131"/>
                    <scope line="132"/>
                </scope>
            </method>
            <method name="close" type="void" line="144"/>
        </class>
    </source>