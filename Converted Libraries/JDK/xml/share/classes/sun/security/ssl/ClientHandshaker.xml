<?xml version="1.0" encoding="UTF-8"?>
    <source package="sun.security.ssl">
        <import package="java.io"/>
        <import package="java.math.BigInteger"/>
        <import package="java.security"/>
        <import package="java.util"/>
        <import package="java.security.interfaces.ECPublicKey"/>
        <import package="java.security.interfaces.RSAPublicKey"/>
        <import package="java.security.spec.ECParameterSpec"/>
        <import package="java.security.cert.X509Certificate"/>
        <import package="java.security.cert.CertificateException"/>
        <import package="javax.crypto.SecretKey"/>
        <import package="javax.crypto.spec.SecretKeySpec"/>
        <import package="javax.net.ssl"/>
        <import package="javax.security.auth.Subject"/>
        <import package="sun.security.ssl.HandshakeMessage"/>
        <import package="sun.security.ssl.CipherSuite"/>
        <import package="sun.security.ssl.CipherSuite.KeyExchange"/>
        <import package="sun.net.util.IPAddressUtil"/>
        <class name="ClientHandshaker" line="53">
            <extends class="Handshaker"/>
            <comment line="64">
                the server&apos;s public key from its certificate.                
            </comment>
            <comment line="67">
                the server&apos;s ephemeral public key from the server key exchange message                
            </comment>
            <comment line="68">
                for ECDHE/ECDH_anon and RSA_EXPORT.                
            </comment>
            <comment line="71">
                server&apos;s ephemeral public value for DHE/DH_anon key exchanges                
            </comment>
            <comment line="82">
                The RSA PreMasterSecret needs to know the version of
                 ClientHello that was used on this handshake.  This represents
                 the &quot;max version&quot; this client is supporting.  In the
                 case of an initial handshake, it&apos;s the max version enabled,
                 but in the case of a resumption attempt, it&apos;s the version
                 of the session we&apos;re trying to resume.                
            </comment>
            <comment line="92">
                To switch off the SNI extension.                
            </comment>
            <comment line="96">
                Constructors                
            </comment>
            <comment line="121">
                This routine handles all the client side handshake messages, one at
                 a time.  Given the message type (and in some cases the pending cipher
                 spec) it parses the type-specific message.  Then it calls a function
                 that handles that specific message.
                
                 It updates the state machine (need to verify it) as each message
                 is processed, and writes responses as needed using the connection
                 in the constructor.                
            </comment>
            <comment line="305">
                Used by the server to kickstart negotiations -- this requests a
                 &quot;client hello&quot; to renegotiate current cipher specs (e.g. maybe lots
                 of data has been encrypted with the same keys, or the server needs
                 the client to present a certificate).                
            </comment>
            <comment line="360">
                Server chooses session parameters given options created by the
                 client -- basically, cipher options, session id, and someday a
                 set of compression options.
                
                 There are two branches of the state machine, decided by the
                 details of this message.  One is the &quot;fast&quot; handshake, where we
                 can resume the pre-existing session we asked resume.  The other
                 is a more expensive &quot;full&quot; handshake, with key exchange and
                 probably authentication getting done.                
            </comment>
            <comment line="589">
                Server&apos;s own key was either a signing-only key, or was too
                 large for export rules ... this message holds an ephemeral
                 RSA key to use for key exchange.                
            </comment>
            <comment line="608">
                Diffie-Hellman key exchange.  We save the server public key and
                 our own D-H algorithm object so we can defer key calculations
                 until after we&apos;ve sent the client key exchange message (which
                 gives client and server some useful parallelism).                
            </comment>
            <comment line="634">
                The server&apos;s &quot;Hello Done&quot; message is the client&apos;s sign that
                 it&apos;s time to do all the hard work.                
            </comment>
            <comment line="1007">
                &quot;Finished&quot; is the last handshake message sent.  If we got this
                 far, the MAC has been validated post-decryption.  We validate
                 the two hashes here as an additional sanity check, protecting
                 the handshake against various active attacks.                
            </comment>
            <comment line="1067">
                Send my change-cipher-spec and Finished message ... done as the
                 last handshake act in either the short or long sequences.  In
                 the short one, we&apos;ve already seen the server&apos;s Finished; in the
                 long one, we wait for it now.                
            </comment>
            <comment line="1102">
                Returns a ClientHello message to kickstart renegotiations                
            </comment>
            <comment line="1280">
                Fault detected during handshake.                
            </comment>
            <comment line="1292">
                Unless we are using an anonymous ciphersuite, the server always
                 sends a certificate message (for the CipherSuites we currently
                 support). The trust manager verifies the chain for us.                
            </comment>
            <javadoc line="53">
                ClientHandshaker does the protocol handshaking from the point
                  of view of a client.  It is driven asychronously by handshake messages
                  as delivered by the parent Handshaker class, and also uses
                  common functionality (e.g. key generation) that is provided there.                
                <author>
                    David Brownell                    
                </author>
            </javadoc>
            <declaration name="serverKey" type="PublicKey" line="64"/>
            <declaration name="ephemeralServerKey" type="PublicKey" line="68"/>
            <declaration name="serverDH" type="BigInteger" line="71"/>
            <declaration name="dh" type="DHCrypt" line="73"/>
            <declaration name="ecdh" type="ECDHCrypt" line="75"/>
            <declaration name="certRequest" type="CertificateRequest" line="77"/>
            <declaration name="serverKeyExchangeReceived" type="boolean" line="79"/>
            <declaration name="maxProtocolVersion" type="ProtocolVersion" line="89"/>
            <declaration name="enableSNIExtension" type="boolean" line="92"/>
            <method name="ClientHandshaker" type="constructor" line="102">
                <params>
                    <param name="socket" type="SSLSocketImpl"/>
                    <param name="context" type="SSLContextImpl"/>
                    <param name="enabledProtocols" type="ProtocolList"/>
                    <param name="activeProtocolVersion" type="ProtocolVersion"/>
                    <param name="isInitialHandshake" type="boolean"/>
                    <param name="secureRenegotiation" type="boolean"/>
                    <param name="clientVerifyData" type="byte[]"/>
                    <param name="serverVerifyData" type="byte[]"/>
                </params>
            </method>
            <method name="ClientHandshaker" type="constructor" line="113">
                <params>
                    <param name="engine" type="SSLEngineImpl"/>
                    <param name="context" type="SSLContextImpl"/>
                    <param name="enabledProtocols" type="ProtocolList"/>
                    <param name="activeProtocolVersion" type="ProtocolVersion"/>
                    <param name="isInitialHandshake" type="boolean"/>
                    <param name="secureRenegotiation" type="boolean"/>
                    <param name="clientVerifyData" type="byte[]"/>
                    <param name="serverVerifyData" type="byte[]"/>
                </params>
            </method>
            <method name="processMessage" type="void" line="130">
                <params>
                    <param name="type" type="byte"/>
                    <param name="messageLen" type="int"/>
                </params>
                <comment line="152">
                    NOTREACHED                    
                </comment>
                <comment line="163">
                    The server key exchange message is sent by the server only
                     when the server certificate message does not contain the
                     proper amount of data to allow the client to exchange a
                     premaster secret, such as when RSA_EXPORT is used and the
                     public key in the server certificate is longer than 512 bits.                    
                </comment>
                <comment line="243">
                    save for later, it&apos;s handled by serverHelloDone                    
                </comment>
                <comment line="295">
                                        
                </comment>
                <comment line="296">
                    Move state machine forward if the message handling                    
                </comment>
                <comment line="297">
                    code didn&apos;t already do so                    
                </comment>
                <comment line="298">
                                        
                </comment>
                <scope line="133"/>
                <scope line="149"/>
                <scope line="170"/>
                <scope line="175"/>
                <scope line="181"/>
                <scope line="189"/>
                <scope line="191"/>
                <scope line="201"/>
                <scope line="207"/>
                <scope line="214"/>
                <scope line="219"/>
                <scope line="244"/>
                <scope line="248"/>
                <scope line="254"/>
                <scope line="258">
                    <declaration name="peerSignAlgs" type="Collection&lt;SignatureAndHashAlgorithm&gt;" line="259"/>
                    <scope line="261"/>
                    <declaration name="supportedPeerSignAlgs" type="Collection&lt;SignatureAndHashAlgorithm&gt;" line="266"/>
                    <scope line="269"/>
                </scope>
                <scope line="299"/>
            </method>
            <method name="serverHelloRequest" type="void" line="310">
                <params>
                    <param name="mesg" type="HelloRequest"/>
                </params>
                <comment line="315">
                                        
                </comment>
                <comment line="316">
                    Could be (e.g. at connection setup) that we already                    
                </comment>
                <comment line="317">
                    sent the &quot;client hello&quot; but the server&apos;s not seen it.                    
                </comment>
                <comment line="318">
                                        
                </comment>
                <comment line="321">
                    renegotiation is not allowed.                    
                </comment>
                <comment line="323">
                    response with a no_renegotiation warning,                    
                </comment>
                <comment line="326">
                    invalidate the handshake so that the caller can                    
                </comment>
                <comment line="327">
                    dispose this object.                    
                </comment>
                <comment line="330">
                    If there is still unread block in the handshake                    
                </comment>
                <comment line="331">
                    input stream, it would be truncated with the disposal                    
                </comment>
                <comment line="332">
                    and the next handshake message will become incomplete.                    
                </comment>
                <comment line="333">
                                        
                </comment>
                <comment line="334">
                    However, according to SSL/TLS specifications, no more                    
                </comment>
                <comment line="335">
                    handshake message should immediately follow ClientHello                    
                </comment>
                <comment line="336">
                    or HelloRequest. So just let it be.                    
                </comment>
                <comment line="338">
                    For SSLv3, send the handshake_failure fatal error.                    
                </comment>
                <comment line="339">
                    Note that SSLv3 does not define a no_renegotiation                    
                </comment>
                <comment line="340">
                    alert like TLSv1. However we cannot ignore the message                    
                </comment>
                <comment line="341">
                    simply, otherwise the other side was waiting for a                    
                </comment>
                <comment line="342">
                    response that would never come.                    
                </comment>
                <scope line="311"/>
                <scope line="319">
                    <scope line="320">
                        <scope line="322"/>
                        <scope line="337"/>
                    </scope>
                    <scope line="346">
                        <scope line="347">
                            <scope line="348"/>
                        </scope>
                    </scope>
                </scope>
            </method>
            <method name="serverHello" type="void" line="370">
                <params>
                    <param name="mesg" type="ServerHello"/>
                </params>
                <comment line="376">
                    check if the server selected protocol version is OK for us                    
                </comment>
                <comment line="387">
                    Set protocolVersion and propagate to SSLSocket and the                    
                </comment>
                <comment line="388">
                    Handshake streams                    
                </comment>
                <comment line="391">
                    check the &quot;renegotiation_info&quot; extension                    
                </comment>
                <comment line="396">
                    verify the length of the &quot;renegotiated_connection&quot; field                    
                </comment>
                <comment line="398">
                    abort the handshake with a fatal handshake_failure alert                    
                </comment>
                <comment line="405">
                    For a legacy renegotiation, the client MUST verify that                    
                </comment>
                <comment line="406">
                    it does not contain the &quot;renegotiation_info&quot; extension.                    
                </comment>
                <comment line="412">
                    verify the client_verify_data and server_verify_data values                    
                </comment>
                <comment line="427">
                    no renegotiation indication extension                    
                </comment>
                <comment line="430">
                    abort the handshake with a fatal handshake_failure alert                    
                </comment>
                <comment line="441">
                    For a secure renegotiation, the client must abort the                    
                </comment>
                <comment line="442">
                    handshake if no &quot;renegotiation_info&quot; extension is present.                    
                </comment>
                <comment line="448">
                    we have already allowed unsafe renegotation before request                    
                </comment>
                <comment line="449">
                    the renegotiation.                    
                </comment>
                <comment line="453">
                                        
                </comment>
                <comment line="454">
                    Save server nonce, we always use it to compute connection                    
                </comment>
                <comment line="455">
                    keys and it&apos;s also used to create the master secret if we&apos;re                    
                </comment>
                <comment line="456">
                    creating a new session (i.e. in the full handshake).                    
                </comment>
                <comment line="457">
                                        
                </comment>
                <comment line="474">
                    NOTREACHED                    
                </comment>
                <comment line="477">
                    so far so good, let&apos;s look at the session                    
                </comment>
                <comment line="479">
                    we tried to resume, let&apos;s see what the server decided                    
                </comment>
                <comment line="481">
                    server resumed the session, let&apos;s make sure everything                    
                </comment>
                <comment line="482">
                    checks out                    
                </comment>
                <comment line="484">
                    Verify that the session ciphers are unchanged.                    
                </comment>
                <comment line="491">
                    verify protocol version match                    
                </comment>
                <comment line="498">
                    validate subject identity                    
                </comment>
                <comment line="519">
                    Eliminate dependency on KerberosPrincipal                    
                </comment>
                <comment line="540">
                    looks fine; resume it, and update the state machine.                    
                </comment>
                <comment line="548">
                    we wanted to resume, but the server refused                    
                </comment>
                <comment line="566">
                    check extensions                    
                </comment>
                <comment line="578">
                    Create a new session, we need to do the full handshake                    
                </comment>
                <scope line="372"/>
                <declaration name="mesgVersion" type="ProtocolVersion" line="377"/>
                <scope line="378"/>
                <declaration name="serverHelloRI" type="RenegotiationInfoExtension" line="392"/>
                <scope line="394">
                    <scope line="395">
                        <scope line="397"/>
                    </scope>
                    <scope line="404">
                        <scope line="407"/>
                        <declaration name="verifyData" type="byte[]" line="413"/>
                        <scope line="420"/>
                    </scope>
                </scope>
                <scope line="426">
                    <scope line="428">
                        <scope line="429"/>
                        <scope line="436"/>
                    </scope>
                    <scope line="440">
                        <scope line="443"/>
                    </scope>
                </scope>
                <scope line="460"/>
                <scope line="466"/>
                <scope line="470"/>
                <scope line="478">
                    <scope line="480">
                        <declaration name="sessionSuite" type="CipherSuite" line="485"/>
                        <scope line="486"/>
                        <declaration name="sessionVersion" type="ProtocolVersion" line="492"/>
                        <scope line="493"/>
                        <scope line="500">
                            <declaration name="localPrincipal" type="Principal" line="501"/>
                            <declaration name="subject" type="Subject" line="503"/>
                            <scope line="504">
                                <anonymous_class line="506">
                                    <method name="run" type="Subject" line="507"/>
                                </anonymous_class>
                            </scope>
                            <scope line="510">
                                <scope line="512"/>
                            </scope>
                            <scope line="518">
                                <declaration name="principals" type="Set&lt;Principal&gt;" line="520"/>
                                <scope line="522"/>
                                <scope line="525"/>
                            </scope>
                            <scope line="529"/>
                        </scope>
                        <scope line="544"/>
                    </scope>
                    <scope line="547">
                        <scope line="550"/>
                    </scope>
                </scope>
                <scope line="557">
                    <scope line="558"/>
                </scope>
                <scope line="567">
                    <declaration name="type" type="ExtensionType" line="568"/>
                    <scope line="572"/>
                </scope>
                <scope line="583"/>
            </method>
            <method name="serverKeyExchange" type="void" line="594">
                <params>
                    <param name="mesg" type="RSA_ServerKeyExchange"/>
                </params>
                <comment line="601">
                    NOTREACHED                    
                </comment>
                <scope line="595"/>
                <scope line="598"/>
            </method>
            <method name="serverKeyExchange" type="void" line="614">
                <params>
                    <param name="mesg" type="DH_ServerKeyExchange"/>
                </params>
                <scope line="615"/>
            </method>
            <method name="serverKeyExchange" type="void" line="624">
                <params>
                    <param name="mesg" type="ECDH_ServerKeyExchange"/>
                </params>
                <scope line="625"/>
                <declaration name="key" type="ECPublicKey" line="628"/>
            </method>
            <method name="serverHelloDone" type="void" line="637">
                <params>
                    <param name="mesg" type="ServerHelloDone"/>
                </params>
                <comment line="641">
                    Always make sure the input has been digested before we
                     start emitting data, to ensure the hashes are correctly
                     computed for the Finished and CertificateVerify messages
                     which we send (here).                    
                </comment>
                <comment line="649">
                    FIRST ... if requested, send an appropriate Certificate chain
                     to authenticate the client, and remember the associated private
                     key to sign the CertificateVerify message.                    
                </comment>
                <comment line="674">
                    ignore if we do not have EC crypto available                    
                </comment>
                <comment line="678">
                    Fixed DH/ECDH client authentication not supported                    
                </comment>
                <comment line="683">
                    Any other values (currently not used in TLS)                    
                </comment>
                <comment line="716">
                    for EC, make sure we use a supported named curve                    
                </comment>
                <comment line="737">
                                        
                </comment>
                <comment line="738">
                    No appropriate cert was found ... report this to the                    
                </comment>
                <comment line="739">
                    server.  For SSLv3, send the no_certificate alert;                    
                </comment>
                <comment line="740">
                    TLS uses an empty cert chain instead.                    
                </comment>
                <comment line="741">
                                        
                </comment>
                <comment line="749">
                                        
                </comment>
                <comment line="750">
                    At last ... send any client certificate chain.                    
                </comment>
                <comment line="751">
                                        
                </comment>
                <comment line="760">
                    SECOND ... send the client key exchange message.  The
                     procedure used is a function of the cipher suite selected;
                     one is always needed.                    
                </comment>
                <comment line="781">
                    For RSA key exchange, we randomly generate a new
                     pre-master secret and encrypt it with the server&apos;s
                     public key.  Then we save that pre-master secret
                     so that we can calculate the keying data later;
                     it&apos;s a performance speedup not to do that until
                     the client&apos;s waiting for the server response, but
                     more of a speedup for the D-H case.
                    
                     If the RSA_EXPORT scheme is active, when the public
                     key in the server certificate is less than or equal
                     to 512 bits in length, use the cert&apos;s public key,
                     otherwise, the ephemeral one.                    
                </comment>
                <comment line="798">
                    K_RSA_EXPORT                    
                </comment>
                <comment line="800">
                    extraneous ephemeralServerKey check done                    
                </comment>
                <comment line="801">
                    above in processMessage()                    
                </comment>
                <comment line="817">
                    For DH Key exchange, we only need to make sure the server
                     knows our public key, so we calculate the same pre-master
                     secret.
                    
                     For certs that had DH keys in them, we send an empty
                     handshake message (no key) ... we flag this case by
                     passing a null &quot;dhPublic&quot; value.
                    
                     Otherwise we send ephemeral DH keys, unsigned.                    
                </comment>
                <comment line="828">
                    if (useDH_RSA || useDH_DSS)                    
                </comment>
                <comment line="874">
                    Record the principals involved in exchange                    
                </comment>
                <comment line="880">
                    somethings very wrong                    
                </comment>
                <comment line="890">
                    THIRD, send a &quot;change_cipher_spec&quot; record followed by the
                     &quot;Finished&quot; message.  We flush the messages we&apos;ve queued up, to
                     get concurrency between client and server.  The concurrency is
                     useful as we calculate the master secret, which is needed both
                     to compute the &quot;Finished&quot; message, and to compute the keys used
                     to protect all records following the change_cipher_spec.                    
                </comment>
                <comment line="902">
                    We deferred calculating the master secret and this connection&apos;s
                     keying data; we do it now.  Deferring this calculation is good
                     from a performance point of view, since it lets us do it during
                     some time that network delays and the server&apos;s own calculations
                     would otherwise cause to be &quot;dead&quot; in the critical path.                    
                </comment>
                <comment line="943">
                    FOURTH, if we sent a Certificate, we need to send a signed
                     CertificateVerify (unless the key in the client&apos;s certificate
                     was a Diffie-Hellman key).).
                    
                     This uses a hash of the previous handshake messages ... either
                     a nonfinal one (if the particular implementation supports it)
                     or else using the third element in the arrays of hashes being
                     computed.                    
                </comment>
                <comment line="985">
                    NOTREACHED, make compiler happy                    
                </comment>
                <comment line="999">
                    OK, that&apos;s that!                    
                </comment>
                <scope line="638"/>
                <declaration name="signingKey" type="PrivateKey" line="654"/>
                <scope line="656">
                    <declaration name="km" type="X509ExtendedKeyManager" line="657"/>
                    <declaration name="keytypesTmp" type="ArrayList&lt;String&gt;" line="659"/>
                    <scope line="661">
                        <declaration name="typeName" type="String" line="662"/>
                        <scope line="691"/>
                    </scope>
                    <declaration name="alias" type="String" line="696"/>
                    <declaration name="keytypesTmpSize" type="int" line="697"/>
                    <scope line="698">
                        <declaration name="keytypes" type="String" line="699"/>
                        <scope line="702"/>
                        <scope line="705"/>
                    </scope>
                    <declaration name="m1" type="CertificateMsg" line="711"/>
                    <scope line="712">
                        <declaration name="certs" type="X509Certificate[]" line="713"/>
                        <scope line="714">
                            <declaration name="publicKey" type="PublicKey" line="715"/>
                            <scope line="717">
                                <declaration name="params" type="ECParameterSpec" line="718"/>
                                <declaration name="index" type="int" line="720"/>
                                <scope line="724"/>
                            </scope>
                            <scope line="728"/>
                        </scope>
                    </scope>
                    <scope line="736">
                        <scope line="742"/>
                        <scope line="744"/>
                    </scope>
                    <scope line="752">
                        <scope line="753"/>
                    </scope>
                </scope>
                <declaration name="m2" type="HandshakeMessage" line="765"/>
                <scope line="771"/>
                <scope line="776"/>
                <declaration name="key" type="PublicKey" line="795"/>
                <scope line="796"/>
                <scope line="798">
                    <scope line="799"/>
                    <scope line="803">
                        <scope line="804"/>
                    </scope>
                </scope>
                <scope line="834"/>
                <scope line="843"/>
                <scope line="851"/>
                <scope line="855"/>
                <declaration name="params" type="ECParameterSpec" line="859"/>
                <declaration name="hostname" type="String" line="865"/>
                <scope line="866"/>
                <declaration name="kerberosMsg" type="KerberosClientKeyExchange" line="870"/>
                <scope line="884"/>
                <declaration name="preMasterSecret" type="SecretKey" line="909"/>
                <declaration name="secretBytes" type="byte[]" line="917"/>
                <scope line="953">
                    <declaration name="m3" type="CertificateVerify" line="954"/>
                    <scope line="955">
                        <declaration name="preferableSignatureAlgorithm" type="SignatureAndHashAlgorithm" line="956"/>
                        <scope line="957">
                            <scope line="962"/>
                            <declaration name="hashAlg" type="String" line="967"/>
                            <scope line="970"/>
                        </scope>
                    </scope>
                    <scope line="982"/>
                    <scope line="988"/>
                </scope>
                <scope line="993">
                    <scope line="994"/>
                </scope>
            </method>
            <method name="serverFinished" type="void" line="1012">
                <params>
                    <param name="mesg" type="Finished"/>
                </params>
                <comment line="1023">
                    NOTREACHED                    
                </comment>
                <comment line="1026">
                    save server verify data for secure renegotiation                    
                </comment>
                <comment line="1033">
                    OK, it verified.  If we&apos;re doing the fast handshake, add that
                     &quot;Finished&quot; message to the hash of handshake messages, then send
                     our own change_cipher_spec and Finished message for the server
                     to verify in turn.  These are the last handshake messages.
                    
                     In any case, update the session cache.  We&apos;re done handshaking,
                     so there are no threats any more associated with partially
                     completed handshakes.                    
                </comment>
                <scope line="1013"/>
                <declaration name="verified" type="boolean" line="1017"/>
                <scope line="1020"/>
                <scope line="1029"/>
                <scope line="1043"/>
                <scope line="1049">
                    <scope line="1050">
                        <scope line="1054"/>
                    </scope>
                    <scope line="1057"/>
                </scope>
            </method>
            <method name="sendChangeCipherAndFinish" type="void" line="1073">
                <params>
                    <param name="finishedTag" type="boolean"/>
                </params>
                <comment line="1077">
                    Send the change_cipher_spec message, then the Finished message
                     which we just calculated (and protected using the keys we just
                     calculated).  Server responds with its Finished message, except
                     in the &quot;fast handshake&quot; (resume session) case.                    
                </comment>
                <comment line="1085">
                    save client verify data for secure renegotiation                    
                </comment>
                <comment line="1092">
                    Update state machine so server MUST send &apos;finished&apos; next.
                     (In &quot;long&quot; handshake case; in short case, we&apos;re responding
                     to its message.)                    
                </comment>
                <declaration name="mesg" type="Finished" line="1074"/>
                <scope line="1088"/>
            </method>
            <method name="getKickstartMessage" type="HandshakeMessage" line="1104">
                <comment line="1105">
                    session ID of the ClientHello message                    
                </comment>
                <comment line="1108">
                    a list of cipher suites sent by the client                    
                </comment>
                <comment line="1111">
                    set the max protocol version this client is supporting.                    
                </comment>
                <comment line="1114">
                                        
                </comment>
                <comment line="1115">
                    Try to resume an existing session.  This might be mandatory,                    
                </comment>
                <comment line="1116">
                    given certain API options.                    
                </comment>
                <comment line="1117">
                                        
                </comment>
                <comment line="1162">
                    Update SSL version number in underlying SSL socket and                    
                </comment>
                <comment line="1163">
                    handshake output stream, so that the output records (at the                    
                </comment>
                <comment line="1164">
                    record layer) have the correct version                    
                </comment>
                <comment line="1168">
                    Force use of the previous session ciphersuite, and
                     add the SCSV if enabled.                    
                </comment>
                <comment line="1183">
                    otherwise, renegotiation_info extension will be used                    
                </comment>
                <comment line="1193">
                    exclude SCSV for secure renegotiation                    
                </comment>
                <comment line="1206">
                    make sure there is a negotiable cipher suite.                    
                </comment>
                <comment line="1219">
                    Not a TLS1.2+ handshake                    
                </comment>
                <comment line="1220">
                    For SSLv2Hello, HandshakeHash.reset() will be called, so we                    
                </comment>
                <comment line="1221">
                    cannot call HandshakeHash.protocolDetermined() here. As it does                    
                </comment>
                <comment line="1222">
                    not follow the spec that HandshakeHash.reset() can be only be                    
                </comment>
                <comment line="1223">
                    called before protocolDetermined.                    
                </comment>
                <comment line="1224">
                    if (maxProtocolVersion.v &lt; ProtocolVersion.TLS12.v) {                    
                </comment>
                <comment line="1225">
                    handshakeHash.protocolDetermined(maxProtocolVersion);                    
                </comment>
                <comment line="1226">
                    }                    
                </comment>
                <comment line="1228">
                    create the ClientHello message                    
                </comment>
                <comment line="1233">
                    add signature_algorithm extension                    
                </comment>
                <comment line="1235">
                    we will always send the signature_algorithm extension                    
                </comment>
                <comment line="1246">
                    add server_name extension                    
                </comment>
                <comment line="1248">
                    We cannot use the hostname resolved from name services.  For                    
                </comment>
                <comment line="1249">
                    virtual hosting, multiple hostnames may be bound to the same IP                    
                </comment>
                <comment line="1250">
                    address, so the hostname resolved from name services is not                    
                </comment>
                <comment line="1251">
                    reliable.                    
                </comment>
                <comment line="1254">
                    we only allow FQDN                    
                </comment>
                <comment line="1262">
                    reset the client random cookie                    
                </comment>
                <comment line="1265">
                    need to set the renegotiation_info extension for:
                     1: secure renegotiation
                     2: initial handshake and no SCSV in the ClientHello
                     3: insecure renegotiation and no SCSV in the ClientHello                    
                </comment>
                <declaration name="sessionId" type="SessionId" line="1106"/>
                <declaration name="cipherSuites" type="CipherSuiteList" line="1109"/>
                <scope line="1121">
                    <scope line="1122"/>
                    <scope line="1126"/>
                </scope>
                <scope line="1130"/>
                <scope line="1134">
                    <declaration name="sessionSuite" type="CipherSuite" line="1135"/>
                    <declaration name="sessionVersion" type="ProtocolVersion" line="1136"/>
                    <scope line="1137">
                        <scope line="1138"/>
                    </scope>
                    <scope line="1144">
                        <scope line="1145"/>
                    </scope>
                    <scope line="1151">
                        <scope line="1152">
                            <scope line="1153"/>
                        </scope>
                    </scope>
                    <scope line="1172">
                        <scope line="1173"/>
                        <declaration name="cipherList" type="Collection&lt;CipherSuite&gt;" line="1178"/>
                        <scope line="1181"/>
                    </scope>
                </scope>
                <scope line="1189"/>
                <scope line="1194">
                    <declaration name="cipherList" type="Collection&lt;CipherSuite&gt;" line="1195"/>
                    <scope line="1197">
                        <scope line="1198"/>
                    </scope>
                </scope>
                <declaration name="negotiable" type="boolean" line="1207"/>
                <scope line="1208">
                    <scope line="1209"/>
                </scope>
                <scope line="1215"/>
                <declaration name="clientHelloMessage" type="ClientHello" line="1229"/>
                <scope line="1234">
                    <declaration name="localSignAlgs" type="Collection&lt;SignatureAndHashAlgorithm&gt;" line="1236"/>
                    <scope line="1238"/>
                </scope>
                <scope line="1247">
                    <declaration name="hostname" type="String" line="1252"/>
                    <scope line="1257"/>
                </scope>
                <scope line="1272"/>
            </method>
            <method name="handshakeAlert" type="void" line="1282">
                <params>
                    <param name="description" type="byte"/>
                </params>
                <declaration name="message" type="String" line="1283"/>
                <scope line="1285"/>
            </method>
            <method name="serverCertificate" type="void" line="1296">
                <params>
                    <param name="mesg" type="CertificateMsg"/>
                </params>
                <comment line="1305">
                    ask the trust manager to verify the chain                    
                </comment>
                <comment line="1308">
                    find out the key exchange algorithm used                    
                </comment>
                <comment line="1309">
                    use &quot;RSA&quot; for non-ephemeral &quot;RSA_EXPORT&quot;                    
                </comment>
                <comment line="1330">
                    Unlikely to happen, because we have wrapped the old                    
                </comment>
                <comment line="1331">
                    X509TrustManager with the new X509ExtendedTrustManager.                    
                </comment>
                <comment line="1336">
                    This will throw an exception, so include the original error.                    
                </comment>
                <scope line="1297"/>
                <declaration name="peerCerts" type="X509Certificate[]" line="1300"/>
                <scope line="1301"/>
                <declaration name="tm" type="X509TrustManager" line="1306"/>
                <scope line="1307">
                    <declaration name="keyExchangeString" type="String" line="1310"/>
                    <scope line="1311"/>
                    <scope line="1313"/>
                    <scope line="1317">
                        <scope line="1318"/>
                        <scope line="1323"/>
                    </scope>
                    <scope line="1329"/>
                </scope>
                <scope line="1335"/>
            </method>
        </class>
    </source>