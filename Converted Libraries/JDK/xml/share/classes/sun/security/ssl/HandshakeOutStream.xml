<?xml version="1.0" encoding="UTF-8"?>
    <source package="sun.security.ssl">
        <import package="java.io.OutputStream"/>
        <import package="java.io.IOException"/>
        <import package="java.security.MessageDigest"/>
        <class name="HandshakeOutStream" line="33">
            <extends class="OutputStream"/>
            <comment line="76">
                Update the handshake data hashes ... mostly for use after a
                 client cert has been sent, so the cert verify message can be
                 constructed correctly yet without forcing extra IO.  In all
                 other cases, automatic hash calculation suffices.                
            </comment>
            <comment line="86">
                Write some data out onto the stream ... buffers as much as possible.
                 Hashes are updated automatically if something gets flushed to the
                 network (e.g. a big cert message etc).                
            </comment>
            <comment line="105">
                write-a-byte                
            </comment>
            <comment line="138">
                Tell the OutputRecord that a finished message was
                 contained either in this record or the one immeiately
                 preceeding it.  We need to reliably pass back notifications
                 that a finish message occured.                
            </comment>
            <comment line="150">
                Put integers encoded in standard 8, 16, 24, and 32 bit
                 big endian formats. Note that OutputStream.write(int) only
                 writes the least significant 8 bits and ignores the rest.                
            </comment>
            <comment line="187">
                Put byte arrays with length encoded as 8, 16, 24 bit
                 integers in big-endian format.                
            </comment>
            <javadoc line="33">
                Output stream for handshake data.  This is used only internally
                  to the SSL classes.
                  MT note:  one thread at a time is presumed be writing handshake
                  messages, but (after initial connection setup) it&apos;s possible to
                  have other threads reading/writing application data.  It&apos;s the
                  SSLSocketImpl class that synchronizes record writes.                
                <author>
                    David Brownell                    
                </author>
            </javadoc>
            <declaration name="socket" type="SSLSocketImpl" line="46"/>
            <declaration name="engine" type="SSLEngineImpl" line="47"/>
            <declaration name="r" type="OutputRecord" line="49"/>
            <method name="HandshakeOutStream" type="constructor" line="53">
                <params>
                    <param name="protocolVersion" type="ProtocolVersion"/>
                    <param name="helloVersion" type="ProtocolVersion"/>
                    <param name="handshakeHash" type="HandshakeHash"/>
                    <param name="socket" type="SSLSocketImpl"/>
                </params>
            </method>
            <method name="HandshakeOutStream" type="constructor" line="61">
                <params>
                    <param name="protocolVersion" type="ProtocolVersion"/>
                    <param name="helloVersion" type="ProtocolVersion"/>
                    <param name="handshakeHash" type="HandshakeHash"/>
                    <param name="engine" type="SSLEngineImpl"/>
                </params>
            </method>
            <method name="init" type="void" line="68">
                <params>
                    <param name="protocolVersion" type="ProtocolVersion"/>
                    <param name="helloVersion" type="ProtocolVersion"/>
                    <param name="handshakeHash" type="HandshakeHash"/>
                </params>
            </method>
            <method name="doHashes" type="void" line="81"/>
            <method name="write" type="void" line="90">
                <params>
                    <param name="buf" type="byte"/>
                    <param name="off" type="int"/>
                    <param name="len" type="int"/>
                </params>
                <scope line="91">
                    <declaration name="howmuch" type="int" line="92"/>
                    <scope line="94"/>
                    <scope line="96"/>
                </scope>
            </method>
            <method name="write" type="void" line="107">
                <params>
                    <param name="i" type="int"/>
                </params>
                <scope line="108"/>
            </method>
            <method name="flush" type="void" line="114">
                <comment line="119">
                    Had problems writing; check if there was an                    
                </comment>
                <comment line="120">
                    alert from peer. If alert received, waitForClose                    
                </comment>
                <comment line="121">
                    will throw an exception for the alert                    
                </comment>
                <comment line="124">
                    No alert was received, just rethrow exception                    
                </comment>
                <comment line="127">
                    engine != null                    
                </comment>
                <comment line="128">
                    Even if record might be empty, flush anyway in case
                     there is a finished handshake message that we need
                     to queue.                    
                </comment>
                <scope line="115">
                    <scope line="116"/>
                    <scope line="118"/>
                </scope>
                <scope line="127"/>
            </method>
            <method name="setFinishedMsg" type="void" line="143"/>
            <method name="putInt8" type="void" line="155">
                <params>
                    <param name="i" type="int"/>
                </params>
            </method>
            <method name="putInt16" type="void" line="159">
                <params>
                    <param name="i" type="int"/>
                </params>
                <scope line="160"/>
            </method>
            <method name="putInt24" type="void" line="167">
                <params>
                    <param name="i" type="int"/>
                </params>
                <scope line="168"/>
            </method>
            <method name="putInt32" type="void" line="176">
                <params>
                    <param name="i" type="int"/>
                </params>
                <scope line="177"/>
            </method>
            <method name="putBytes8" type="void" line="190">
                <params>
                    <param name="b" type="byte"/>
                </params>
                <scope line="191"/>
            </method>
            <method name="putBytes16" type="void" line="199">
                <params>
                    <param name="b" type="byte"/>
                </params>
                <scope line="200"/>
            </method>
            <method name="putBytes24" type="void" line="208">
                <params>
                    <param name="b" type="byte"/>
                </params>
                <scope line="209"/>
            </method>
        </class>
    </source>