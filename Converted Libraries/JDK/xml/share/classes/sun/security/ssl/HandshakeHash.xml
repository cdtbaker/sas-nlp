<?xml version="1.0" encoding="UTF-8"?>
    <source package="sun.security.ssl">
        <import package="java.io.ByteArrayOutputStream"/>
        <import package="java.security"/>
        <import package="java.util.Arrays"/>
        <import package="java.util.LinkedList"/>
        <import package="java.util.List"/>
        <import package="java.util.Locale"/>
        <import package="java.util.Set"/>
        <class name="HandshakeHash" line="37">
            <comment line="105">
                Common                
            </comment>
            <comment line="107">
                -1:  unknown
                  1:  &lt;=TLS 1.1
                  2:  TLS 1.2                
            </comment>
            <comment line="114">
                For TLS 1.1                
            </comment>
            <comment line="116">
                needs to be saved for later use                
            </comment>
            <comment line="118">
                For TLS 1.2
                 cvAlgDetermined == true means setCertificateVerifyAlg() is called                
            </comment>
            <comment line="190">
                ///////////////////////////////////////////////////////////
                 Below are old methods for pre-TLS 1.1
                /                
            </comment>
            <comment line="225">
                ///////////////////////////////////////////////////////////
                 Below are new methods for TLS 1.2
                /                
            </comment>
            <comment line="295">
                Calculates the hash in the CertificateVerify. Must be called right
                 after setCertificateVerifyAlg()                
            </comment>
            <comment line="299">
                byte[] getCertificateVerifyHash() {
                throw new Error(&quot;Do not call getCertificateVerifyHash()&quot;);                
            </comment>
            <javadoc line="37">
                Abstraction for the SSL/TLS hash of all handshake messages that is
                  maintained to verify the integrity of the negotiation. Internally,
                  it consists of an MD5 and an SHA1 digest. They are used in the client
                  and server finished messages and in certificate verify messages (if sent).
                  This class transparently deals with cloneable and non-cloneable digests.
                  This class now supports TLS 1.2 also. The key difference for TLS 1.2
                  is that you cannot determine the hash algorithms for CertificateVerify
                  at a early stage. On the other hand, it&apos;s simpler than TLS 1.1 (and earlier)
                  that there is no messy MD5+SHA1 digests.
                  You need to obey these conventions when using this class:
                  1. protocolDetermined(version) should be called when the negotiated
                  protocol version is determined.
                  2. Before protocolDetermined() is called, only update(), reset(),
                  restrictCertificateVerifyAlgs(), setFinishedAlg(), and
                  setCertificateVerifyAlg() can be called.
                  3. After protocolDetermined() is called, reset() cannot be called.
                  4. After protocolDetermined() is called, if the version is pre-TLS 1.2,
                  getFinishedHash() and getCertificateVerifyHash() cannot be called. Otherwise,
                  getMD5Clone() and getSHAClone() cannot be called.
                  5. getMD5Clone() and getSHAClone() can only be called after
                  protocolDetermined() is called and version is pre-TLS 1.2.
                  6. getFinishedHash() and getCertificateVerifyHash() can only be called after
                  all protocolDetermined(), setCertificateVerifyAlg() and setFinishedAlg()
                  have been called and the version is TLS 1.2. If a CertificateVerify message
                  is to be used, call setCertificateVerifyAlg() with the hash algorithm as the
                  argument. Otherwise, you still must call setCertificateVerifyAlg(null) before
                  calculating any hash value.
                  Suggestions: Call protocolDetermined(), restrictCertificateVerifyAlgs(),
                  setFinishedAlg(), and setCertificateVerifyAlg() as early as possible.
                  Example:
                  &lt;pre&gt;
                  HandshakeHash hh = new HandshakeHash(...)
                  hh.protocolDetermined(ProtocolVersion.TLS12);
                  hh.update(clientHelloBytes);
                  hh.setFinishedAlg(&quot;SHA-256&quot;);
                  hh.update(serverHelloBytes);
                  ...
                  hh.setCertificateVerifyAlg(&quot;SHA-384&quot;);
                  hh.update(CertificateVerifyBytes);
                  byte[] cvDigest = hh.getCertificateVerifyHash();
                  ...
                  hh.update(finished1);
                  byte[] finDigest1 = hh.getFinishedHash();
                  hh.update(finished2);
                  byte[] finDigest2 = hh.getFinishedHash();
                  &lt;/pre&gt;
                  If no CertificateVerify message is to be used, call
                  &lt;pre&gt;
                  hh.setCertificateVerifyAlg(null);
                  &lt;/pre&gt;
                  This call can be made once you are certain that this message
                  will never be used.                
            </javadoc>
            <declaration name="version" type="int" line="109"/>
            <declaration name="data" type="ByteArrayOutputStream" line="110"/>
            <declaration name="isServer" type="boolean" line="111"/>
            <declaration name="md5" type="MessageDigest" line="114"/>
            <declaration name="clonesNeeded" type="int" line="115"/>
            <declaration name="cvAlgDetermined" type="boolean" line="119"/>
            <declaration name="cvAlg" type="String" line="120"/>
            <declaration name="finMD" type="MessageDigest" line="121"/>
            <javadoc line="123">
                Create a new HandshakeHash. needCertificateVerify indicates whether
                  a hash for the certificate verify message is required. The argument
                  algs is a set of all possible hash algorithms that might be used in
                  TLS 1.2. If the caller is sure that TLS 1.2 won&apos;t be used or no
                  CertificateVerify message will be used, leave it null or empty.                
            </javadoc>
            <method name="HandshakeHash" type="constructor" line="131">
                <params>
                    <param name="isServer" type="boolean"/>
                    <param name="needCertificateVerify" type="boolean"/>
                    <param name="algs" type="Set<String>"/>
                </params>
            </method>
            <method name="update" type="void" line="136">
                <params>
                    <param name="b" type="byte[]"/>
                    <param name="offset" type="int"/>
                    <param name="len" type="int"/>
                </params>
                <scope line="143"/>
            </method>
            <javadoc line="151">
                Reset the remaining digests. Note this does not reset the number of
                  digest clones that can be obtained. Digests that have already been
                  cloned and are gone remain gone.                
            </javadoc>
            <method name="reset" type="void" line="156">
                <scope line="157"/>
            </method>
            <method name="protocolDetermined" type="void" line="165">
                <params>
                    <param name="pv" type="ProtocolVersion"/>
                </params>
                <comment line="168">
                    Do not set again, will ignore                    
                </comment>
                <comment line="174">
                    initiate md5, sha and call update on saved array                    
                </comment>
                <scope line="174"/>
                <scope line="177"/>
                <declaration name="bytes" type="byte[]" line="181"/>
            </method>
            <javadoc line="193">
                Return a new MD5 digest updated with all data hashed so far.                
            </javadoc>
            <method name="getMD5Clone" type="MessageDigest" line="196">
                <scope line="197"/>
            </method>
            <javadoc line="204">
                Return a new SHA digest updated with all data hashed so far.                
            </javadoc>
            <method name="getSHAClone" type="MessageDigest" line="207">
                <scope line="208"/>
            </method>
            <method name="cloneDigest" type="MessageDigest" line="215">
                <params>
                    <param name="digest" type="MessageDigest"/>
                </params>
                <comment line="220">
                    cannot occur for digests generated via CloneableDigest                    
                </comment>
                <scope line="216"/>
                <scope line="218"/>
            </method>
            <method name="normalizeAlgName" type="String" line="228">
                <params>
                    <param name="alg" type="String"/>
                </params>
                <scope line="230">
                    <scope line="231"/>
                    <scope line="234"/>
                </scope>
            </method>
            <javadoc line="240">
                Specifies the hash algorithm used in Finished. This should be called
                  based in info in ServerHello.
                  Can be called multiple times.                
            </javadoc>
            <method name="setFinishedAlg" type="void" line="245">
                <params>
                    <param name="s" type="String"/>
                </params>
                <comment line="252">
                    Can be called multiple times, but only set once                    
                </comment>
                <scope line="246"/>
                <scope line="254"/>
                <scope line="256"/>
            </method>
            <javadoc line="262">
                Restricts the possible algorithms for the CertificateVerify. Called by
                  the server based on info in CertRequest. The argument must be a subset
                  of the argument with the same name in the constructor. The method can be
                  called multiple times. If the caller is sure that no CertificateVerify
                  message will be used, leave this argument null or empty.                
            </javadoc>
            <method name="restrictCertificateVerifyAlgs" type="void" line="269">
                <params>
                    <param name="algs" type="Set<String>"/>
                </params>
                <comment line="275">
                    Not used yet                    
                </comment>
                <scope line="270"/>
            </method>
            <javadoc line="277">
                Specifies the hash algorithm used in CertificateVerify.
                  Can be called multiple times.                
            </javadoc>
            <method name="setCertificateVerifyAlg" type="void" line="281">
                <params>
                    <param name="s" type="String"/>
                </params>
                <comment line="284">
                    Can be called multiple times, but only set once                    
                </comment>
            </method>
            <method name="getAllHandshakeMessages" type="byte[]" line="290"/>
            <javadoc line="302">
                Calculates the hash in Finished. Must be called after setFinishedAlg().
                  This method can be called twice, for Finished messages of the server
                  side and client side respectively.                
            </javadoc>
            <method name="getFinishedHash" type="byte[]" line="307">
                <scope line="308"/>
                <scope line="310"/>
            </method>
        </class>
        <class name="CloneableDigest" line="316">
            <extends class="MessageDigest"/>
            <comment line="105">
                Common                
            </comment>
            <comment line="107">
                -1:  unknown
                  1:  &lt;=TLS 1.1
                  2:  TLS 1.2                
            </comment>
            <comment line="114">
                For TLS 1.1                
            </comment>
            <comment line="116">
                needs to be saved for later use                
            </comment>
            <comment line="118">
                For TLS 1.2
                 cvAlgDetermined == true means setCertificateVerifyAlg() is called                
            </comment>
            <comment line="190">
                ///////////////////////////////////////////////////////////
                 Below are old methods for pre-TLS 1.1
                /                
            </comment>
            <comment line="225">
                ///////////////////////////////////////////////////////////
                 Below are new methods for TLS 1.2
                /                
            </comment>
            <comment line="295">
                Calculates the hash in the CertificateVerify. Must be called right
                 after setCertificateVerifyAlg()                
            </comment>
            <comment line="299">
                byte[] getCertificateVerifyHash() {
                throw new Error(&quot;Do not call getCertificateVerifyHash()&quot;);                
            </comment>
            <implements interface="Cloneable"/>
            <javadoc line="316">
                A wrapper for MessageDigests that simulates cloning of non-cloneable
                  digests. It uses the standard MessageDigest API and therefore can be used
                  transparently in place of a regular digest.
                  Note that we extend the MessageDigest class directly rather than
                  MessageDigestSpi. This works because MessageDigest was originally designed
                  this way in the JDK 1.1 days which allows us to avoid creating an internal
                  provider.
                  It can be &quot;cloned&quot; a limited number of times, which is specified at
                  construction time. This is achieved by internally maintaining n digests
                  in parallel. Consequently, it is only 1/n-th times as fast as the original
                  digest.
                  Example:
                  MessageDigest md = CloneableDigest.getDigest(&quot;SHA&quot;, 2);
                  md.update(data1);
                  MessageDigest md2 = (MessageDigest)md.clone();
                  md2.update(data2);
                  byte[] d1 = md2.digest(); // digest of data1 || data2
                  md.update(data3);
                  byte[] d2 = md.digest();  // digest of data1 || data3
                  This class is not thread safe.                
            </javadoc>
            <declaration name="digests" type="MessageDigest[]" line="345"/>
            <javadoc line="345">
                The individual MessageDigests. Initially, all elements are non-null.
                  When clone() is called, the non-null element with the maximum index is
                  returned and the array element set to null.
                  All non-null element are always in the same state.                
            </javadoc>
            <method name="CloneableDigest" type="constructor" line="355">
                <params>
                    <param name="digest" type="MessageDigest"/>
                    <param name="n" type="int"/>
                    <param name="algorithm" type="String"/>
                </params>
                <scope line="359"/>
            </method>
            <javadoc line="364">
                Return a MessageDigest for the given algorithm that can be cloned the
                  specified number of times. If the default implementation supports
                  cloning, it is returned. Otherwise, an instance of this class is
                  returned.                
            </javadoc>
            <method name="getDigest" type="MessageDigest" line="371">
                <params>
                    <param name="algorithm" type="String"/>
                    <param name="n" type="int"/>
                </params>
                <comment line="376">
                    already cloneable, use it                    
                </comment>
                <declaration name="digest" type="MessageDigest" line="372"/>
                <scope line="373"/>
                <scope line="377"/>
            </method>
            <javadoc line="382">
                Check if this object is still usable. If it has already been cloned the
                  maximum number of times, there are no digests left and this object can no
                  longer be used.                
            </javadoc>
            <method name="checkState" type="void" line="387">
                <comment line="389">
                    XXX handshaking currently doesn&apos;t stop updating hashes...
                     if (digests[0] == null) {
                         throw new IllegalStateException(&quot;no digests left&quot;);
                     }                    
                </comment>
            </method>
            <method name="engineGetDigestLength" type="int" line="394"/>
            <method name="engineUpdate" type="void" line="399">
                <params>
                    <param name="b" type="byte"/>
                </params>
                <scope line="401"/>
            </method>
            <method name="engineUpdate" type="void" line="406">
                <params>
                    <param name="b" type="byte[]"/>
                    <param name="offset" type="int"/>
                    <param name="len" type="int"/>
                </params>
                <scope line="408"/>
            </method>
            <method name="engineDigest" type="byte[]" line="413">
                <declaration name="digest" type="byte[]" line="415"/>
            </method>
            <method name="engineDigest" type="int" line="421">
                <params>
                    <param name="buf" type="byte[]"/>
                    <param name="offset" type="int"/>
                    <param name="len" type="int"/>
                </params>
                <declaration name="n" type="int" line="423"/>
            </method>
            <javadoc line="428">
                Reset all digests after a digest() call. digests[0] has already been
                  implicitly reset by the digest() call and does not need to be reset
                  again.                
            </javadoc>
            <method name="digestReset" type="void" line="433">
                <scope line="434"/>
            </method>
            <method name="engineReset" type="void" line="439">
                <scope line="441"/>
            </method>
            <method name="clone" type="Object" line="446">
                <comment line="456">
                    cannot occur                    
                </comment>
                <scope line="448">
                    <scope line="449">
                        <declaration name="digest" type="MessageDigest" line="450"/>
                    </scope>
                </scope>
            </method>
        </class>
    </source>