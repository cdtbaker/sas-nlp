<?xml version="1.0" encoding="UTF-8"?>
    <source package="sun.security.ssl">
        <import package="java.io"/>
        <import package="java.nio"/>
        <import package="java.nio.ReadOnlyBufferException"/>
        <import package="java.util.LinkedList"/>
        <import package="java.security"/>
        <import package="javax.crypto.BadPaddingException"/>
        <import package="javax.net.ssl"/>
        <import package="javax.net.ssl.SSLEngineResult"/>
        <import package="com.sun.net.ssl.internal.ssl.X509ExtendedTrustManager"/>
        <class name="SSLEngineImpl" line="41">
            <extends class="SSLEngine"/>
            <comment line="116">
                                
            </comment>
            <comment line="117">
                Fields and global comments                
            </comment>
            <comment line="118">
                                
            </comment>
            <comment line="120">
                There&apos;s a state machine associated with each connection, which
                 among other roles serves to negotiate session changes.
                
                 - START with constructor, until the TCP connection&apos;s around.
                 - HANDSHAKE picks session parameters before allowing traffic.
                          There are many substates due to sequencing requirements
                          for handshake messages.
                 - DATA may be transmitted.
                 - RENEGOTIATE state allows concurrent data and handshaking
                          traffic (&quot;same&quot; substates as HANDSHAKE), and terminates
                          in selection of new session (and connection) parameters
                 - ERROR state immediately precedes abortive disconnect.
                 - CLOSED when one side closes down, used to start the shutdown
                          process.  SSL connection objects are not reused.
                
                 State affects what SSL record types may legally be sent:
                
                 - Handshake ... only in HANDSHAKE and RENEGOTIATE states
                 - App Data ... only in DATA and RENEGOTIATE states
                 - Alert ... in HANDSHAKE, DATA, RENEGOTIATE
                
                 Re what may be received:  same as what may be sent, except that
                 HandshakeRequest handshaking messages can come from servers even
                 in the application data state, to request entry to RENEGOTIATE.
                
                 The state machine within HANDSHAKE and RENEGOTIATE states controls
                 the pending session, not the connection state, until the change
                 cipher spec and &quot;Finished&quot; handshake messages are processed and
                 make the &quot;new&quot; session become the current one.
                
                 NOTE: details of the SMs always need to be nailed down better.
                 The text above illustrates the core ideas.
                
                                +----&gt;-------+------&gt;---------&gt;-------+
                                |            |                        |
                     &lt;-----&lt;    ^            ^  &lt;-----&lt;               |
                START&gt;-----&gt;HANDSHAKE&gt;-----&gt;DATA&gt;-----&gt;RENEGOTIATE    |
                                v            v               v        |
                                |            |               |        |
                                +------------+---------------+        |
                                |                                     |
                                v                                     |
                               ERROR&gt;------&gt;-----&gt;CLOSED&lt;--------&lt;----+
                
                 ALSO, note that the the purpose of handshaking (renegotiation is
                 included) is to assign a different, and perhaps new, session to
                 the connection.  The SSLv3 spec is a bit confusing on that new
                 protocol feature.                
            </comment>
            <comment line="179">
                Once we&apos;re in state cs_CLOSED, we can continue to
                 wrapunwrap until we finish sendingreceiving the messages
                 for close_notify.  EngineWriter handles outboundDone.                
            </comment>
            <comment line="188">
                The authentication context holds all information used to establish
                 who this end of the connection is (certificate chains, private keys,
                 etc) and who is trusted (e.g. as CAs or websites).                
            </comment>
            <comment line="195">
                This connection is one of (potentially) many associated with
                 any given session.  The output of the handshake protocol is a
                 new session ... although all the protocol description talks
                 about changing the cipher spec (and it does change), in fact
                 that&apos;s incidental since it&apos;s done by changing everything that
                 is associated with a session at the same time.  (TLSIETF may
                 change that to add client authentication wo new key exchg.)                
            </comment>
            <comment line="209">
                Client authentication be off, requested, or required.
                
                 This will be used by both this class and SSLSocket&apos;s variants.                
            </comment>
            <comment line="218">
                Flag indicating if the next record we receive MUST be a Finished
                 message. Temporarily set during the handshake to ensure that
                 a change cipher spec message is followed by a finished message.                
            </comment>
            <comment line="226">
                If someone tries to closeInbound() (say at End-Of-Stream)
                 our engine having received a close_notify, we need to
                 notify the app that we may have a truncation attack underway.                
            </comment>
            <comment line="233">
                For improved diagnostics, we detail connection closure
                 If the engine is closed (connectionState &gt;= cs_ERROR),
                 closeReason != null indicates if the engine was closed
                 because of an error or because or normal shutdown.                
            </comment>
            <comment line="241">
                Per-connection private state that doesn&apos;t change when the
                 session is changed.                
            </comment>
            <comment line="251">
                The cipher suites enabled for use on this connection.                
            </comment>
            <comment line="254">
                the endpoint identification protocol                
            </comment>
            <comment line="257">
                The cryptographic algorithm constraints                
            </comment>
            <comment line="260">
                Have we been told whether we&apos;re client or server?                
            </comment>
            <comment line="264">
                The protocol versions enabled for use on this connection.
                
                 Note: we support a pseudo protocol called SSLv2Hello which when
                 set will result in an SSL v2 Hello being sent with SSL (version 3.0)
                 or TLS (version 3.1, 3.2, etc.) version info.                
            </comment>
            <comment line="273">
                The SSL version associated with this connection.                
            </comment>
            <comment line="278">
                Crypto state that&apos;s reinitialized when the session changes.                
            </comment>
            <comment line="283">
                NOTE: compression state would be saved here                
            </comment>
            <comment line="285">
                security parameters for secure renegotiation.                
            </comment>
            <comment line="292">
                READ ME  READ ME  READ ME  READ ME  READ ME  READ ME 
                 IMPORTANT STUFF TO UNDERSTANDING THE SYNCHRONIZATION ISSUES.
                 READ ME  READ ME  READ ME  READ ME  READ ME  READ ME 
                
                 There are several locks here.
                
                 The primary lock is the per-instance lock used by
                 synchronized(this) and the synchronized methods.  It controls all
                 access to things such as the connection state and variables which
                 affect handshaking.  If we are inside a synchronized method, we
                 can access the state directly, otherwise, we must use the
                 synchronized equivalents.
                
                 Note that we must never acquire the &lt;code&gt;this&lt;code&gt; lock after
                 &lt;code&gt;writeLock&lt;code&gt; or run the risk of deadlock.
                
                 Grab some coffee, and be careful with any code changes.                
            </comment>
            <comment line="315">
                Class and subclass dynamic debugging support                
            </comment>
            <comment line="320">
                                
            </comment>
            <comment line="321">
                Initialization/Constructors                
            </comment>
            <comment line="322">
                                
            </comment>
            <comment line="471">
                Report the current status of the Handshaker                
            </comment>
            <comment line="513">
                                
            </comment>
            <comment line="514">
                Handshaking and connection state code                
            </comment>
            <comment line="515">
                                
            </comment>
            <comment line="517">
                Provides &quot;this&quot; synchronization for connection state.
                 Otherwise, you can access it directly.                
            </comment>
            <comment line="529">
                Get the Access Control Context.
                
                 Used for a known context to
                 run tasks in, and for determining which credentials
                 to use for Subject-based (JAAS) decisions.                
            </comment>
            <comment line="540">
                Is a handshake currently underway?                
            </comment>
            <comment line="547">
                When a connection finishes handshaking by enabling use of a newly
                 negotiated session, each end learns about it in two halves (read,
                 and write).  When both read and write ciphers have changed, and the
                 last handshake message has been read, the connection has joined
                 (rejoined) the new session.
                
                 NOTE:  The SSLv3 spec is rather unclear on the concepts here.
                 Sessions don&apos;t change once they&apos;re established (including cipher
                 suite and master secret) but connections can join them (and leave
                 them).  They&apos;re created by handshaking, though sometime handshaking
                 causes connections to join up with pre-established sessions.
                
                 Synchronized on &quot;this&quot; from readRecord.                
            </comment>
            <comment line="593">
                used by Handshaker to change the active write cipher, follows
                 the output of the CCS message.
                
                 Also synchronized on &quot;this&quot; from readRecorddelegatedTask.                
            </comment>
            <comment line="623">
                Updates the SSL version associated with this connection.
                 Called from Handshaker once it has determined the negotiated version.                
            </comment>
            <comment line="722">
                Start a SSLEngine handshake                
            </comment>
            <comment line="735">
                                
            </comment>
            <comment line="736">
                Read/unwrap side                
            </comment>
            <comment line="737">
                                
            </comment>
            <comment line="771">
                Makes additional checks for unwrap, but this time more
                 specific to this packet and the current state of the machine.                
            </comment>
            <comment line="903">
                Actually do the read record processing.
                
                 Returns a Status if it can make specific determinations
                 of the engine state.  In particular, we need to signal
                 that a handshake just completed.
                
                 It would be nice to be symmetrical with the write side and move
                 the majority of this to EngineInputRecord, but there&apos;s too much
                 SSLEngine state to do that cleanly.  It must still live here.                
            </comment>
            <comment line="1136">
                                
            </comment>
            <comment line="1137">
                write/wrap side                
            </comment>
            <comment line="1138">
                                
            </comment>
            <comment line="1178">
                Makes additional checks for unwrap, but this time more
                 specific to this packet and the current state of the machine.                
            </comment>
            <comment line="1270">
                Central point to writeget all of the outgoing data.                
            </comment>
            <comment line="1302">
                Non-application OutputRecords go through here.                
            </comment>
            <comment line="1325">
                                
            </comment>
            <comment line="1326">
                Close code                
            </comment>
            <comment line="1327">
                                
            </comment>
            <comment line="1483">
                Close the inbound side of the connection.  We grab the
                 lock here, and do the real work in the internal verison.
                 We do check for truncation attacks.                
            </comment>
            <comment line="1524">
                                
            </comment>
            <comment line="1525">
                Misc stuff                
            </comment>
            <comment line="1526">
                                
            </comment>
            <comment line="1561">
                                
            </comment>
            <comment line="1562">
                EXCEPTION AND ALERT HANDLING                
            </comment>
            <comment line="1563">
                                
            </comment>
            <comment line="1565">
                Send a warning alert.                
            </comment>
            <comment line="1582">
                We&apos;ve got a fatal error here, so start the shutdown process.
                
                 Because of the way the code was written, we have some code
                 calling fatal directly when the &quot;description&quot; is known
                 and some throwing Exceptions which are then caught by higher
                 levels which then call here.  This code needs to determine
                 if one of the lower levels has already started the process.
                
                 We won&apos;t worry about Error&apos;s, if we have one of those,
                 we&apos;re in worse trouble.  Note:  the networking code doesn&apos;t
                 deal with Errors either.                
            </comment>
            <comment line="1689">
                Process an incoming alert ... caller must already have synchronized
                 access to &quot;this&quot;.                
            </comment>
            <comment line="1748">
                Emit alerts.  Caller must have synchronized with &quot;this&quot;.                
            </comment>
            <comment line="1797">
                                
            </comment>
            <comment line="1798">
                VARIOUS OTHER METHODS (COMMON TO SSLSocket)                
            </comment>
            <comment line="1799">
                                
            </comment>
            <javadoc line="41">
                Implementation of an non-blocking SSLEngine.
                  Currently, the SSLEngine code exists in parallel with the current
                  SSLSocket.  As such, the current implementation is using legacy code
                  with many of the same abstractions.  However, it varies in many
                  areas, most dramatically in the IO handling.
                  There are three main I/O threads that can be existing in parallel:
                  wrap(), unwrap(), and beginHandshake().  We are encouraging users to
                  not call multiple instances of wrap or unwrap, because the data could
                  appear to flow out of the SSLEngine in a non-sequential order.  We
                  take all steps we can to at least make sure the ordering remains
                  consistent, but once the calls returns, anything can happen.  For
                  example, thread1 and thread2 both call wrap, thread1 gets the first
                  packet, thread2 gets the second packet, but thread2 gets control back
                  before thread1, and sends the data.  The receiving side would see an
                  out-of-order error.
                  Handshaking is still done the same way as SSLSocket using the normal
                  InputStream/OutputStream abstactions.  We create
                  ClientHandshakers/ServerHandshakers, which produce/consume the
                  handshaking data.  The transfer of the data is largely handled by the
                  HandshakeInStream/HandshakeOutStreams.  Lastly, the
                  InputRecord/OutputRecords still have the same functionality, except
                  that they are overridden with EngineInputRecord/EngineOutputRecord,
                  which provide SSLEngine-specific functionality.
                  Some of the major differences are:
                  EngineInputRecord/EngineOutputRecord/EngineWriter:
                  In order to avoid writing whole new control flows for
                  handshaking, and to reuse most of the same code, we kept most
                  of the actual handshake code the same.  As usual, reading
                  handshake data may trigger output of more handshake data, so
                  what we do is write this data to internal buffers, and wait for
                  wrap() to be called to give that data a ride.
                  All data is routed through
                  EngineInputRecord/EngineOutputRecord.  However, all handshake
                  data (ct_alert/ct_change_cipher_spec/ct_handshake) are passed
                  through to the the underlying InputRecord/OutputRecord, and
                  the data uses the internal buffers.
                  Application data is handled slightly different, we copy the data
                  directly from the src to the dst buffers, and do all operations
                  on those buffers, saving the overhead of multiple copies.
                  In the case of an inbound record, unwrap passes the inbound
                  ByteBuffer to the InputRecord.  If the data is handshake data,
                  the data is read into the InputRecord&apos;s internal buffer.  If
                  the data is application data, the data is decoded directly into
                  the dst buffer.
                  In the case of an outbound record, when the write to the
                  &quot;real&quot; OutputStream&apos;s would normally take place, instead we
                  call back up to the EngineOutputRecord&apos;s version of
                  writeBuffer, at which time we capture the resulting output in a
                  ByteBuffer, and send that back to the EngineWriter for internal
                  storage.
                  EngineWriter is responsible for &quot;handling&quot; all outbound
                  data, be it handshake or app data, and for returning the data
                  to wrap() in the proper order.
                  ClientHandshaker/ServerHandshaker/Handshaker:
                  Methods which relied on SSLSocket now have work on either
                  SSLSockets or SSLEngines.                
                <author>
                    Brad Wetmore                    
                </author>
            </javadoc>
            <declaration name="connectionState" type="int" line="169"/>
            <declaration name="cs_START" type="int" line="171"/>
            <declaration name="cs_HANDSHAKE" type="int" line="172"/>
            <declaration name="cs_DATA" type="int" line="173"/>
            <declaration name="cs_RENEGOTIATE" type="int" line="174"/>
            <declaration name="cs_ERROR" type="int" line="175"/>
            <declaration name="cs_CLOSED" type="int" line="176"/>
            <declaration name="inboundDone" type="boolean" line="183"/>
            <declaration name="writer" type="EngineWriter" line="185"/>
            <declaration name="sslContext" type="SSLContextImpl" line="192"/>
            <declaration name="handshaker" type="Handshaker" line="203"/>
            <declaration name="sess" type="SSLSessionImpl" line="204"/>
            <declaration name="handshakeSession" type="SSLSessionImpl" line="205"/>
            <declaration name="clauth_none" type="byte" line="213"/>
            <declaration name="clauth_requested" type="byte" line="214"/>
            <declaration name="clauth_required" type="byte" line="215"/>
            <declaration name="expectingFinished" type="boolean" line="222"/>
            <declaration name="recvCN" type="boolean" line="230"/>
            <declaration name="closeReason" type="SSLException" line="238"/>
            <declaration name="doClientAuth" type="byte" line="244"/>
            <declaration name="enableSessionCreation" type="boolean" line="245"/>
            <declaration name="inputRecord" type="EngineInputRecord" line="246"/>
            <declaration name="outputRecord" type="EngineOutputRecord" line="247"/>
            <declaration name="acc" type="AccessControlContext" line="248"/>
            <declaration name="enabledCipherSuites" type="CipherSuiteList" line="251"/>
            <declaration name="identificationProtocol" type="String" line="254"/>
            <declaration name="algorithmConstraints" type="AlgorithmConstraints" line="257"/>
            <declaration name="serverModeSet" type="boolean" line="260"/>
            <declaration name="roleIsServer" type="boolean" line="261"/>
            <declaration name="enabledProtocols" type="ProtocolList" line="270"/>
            <declaration name="protocolVersion" type="ProtocolVersion" line="275"/>
            <declaration name="readMAC" type="MAC" line="280"/>
            <declaration name="readCipher" type="CipherBox" line="281"/>
            <declaration name="secureRenegotiation" type="boolean" line="287"/>
            <declaration name="clientVerifyData" type="byte[]" line="288"/>
            <declaration name="serverVerifyData" type="byte[]" line="289"/>
            <declaration name="wrapLock" type="Object" line="310"/>
            <declaration name="unwrapLock" type="Object" line="311"/>
            <declaration name="writeLock" type="Object" line="312"/>
            <declaration name="debug" type="Debug" line="317"/>
            <javadoc line="323">
                Constructor for an SSLEngine from SSLContext, without
                  host/port hints.  This Engine will not be able to cache
                  sessions, but must renegotiate everything by hand.                
            </javadoc>
            <method name="SSLEngineImpl" type="constructor" line="328">
                <params>
                    <param name="ctx" type="SSLContextImpl"/>
                </params>
            </method>
            <javadoc line="333">
                Constructor for an SSLEngine from SSLContext.                
            </javadoc>
            <method name="SSLEngineImpl" type="constructor" line="336">
                <params>
                    <param name="ctx" type="SSLContextImpl"/>
                    <param name="host" type="String"/>
                    <param name="port" type="int"/>
                </params>
            </method>
            <javadoc line="341">
                Initializes the Engine                
            </javadoc>
            <method name="init" type="void" line="344">
                <params>
                    <param name="ctx" type="SSLContextImpl"/>
                </params>
                <comment line="353">
                    State is cs_START until we initialize the handshaker.
                    
                     Apps using SSLEngine are probably going to be server.
                     Somewhat arbitrary choice.                    
                </comment>
                <comment line="362">
                    default read and write side cipher and MAC support
                    
                     Note:  compression support would go here too                    
                </comment>
                <comment line="372">
                    default security parameters for secure renegotiation                    
                </comment>
                <comment line="386">
                    Save the Access Control Context.  This will be used later
                     for a couple of things, including providing a context to
                     run tasks in, and for determining which credentials
                     to use for Subject based (JAAS) decisions                    
                </comment>
                <comment line="394">
                    All outbound application data goes through this OutputRecord,
                     other data goes through their respective records created
                     elsewhere.  All inbound data goes through this one
                     input record.                    
                </comment>
                <scope line="345"/>
            </method>
            <javadoc line="408">
                Initialize the handshaker object. This means:
                  . if a handshake is already in progress (state is cs_HANDSHAKE
                  or cs_RENEGOTIATE), do nothing and return
                  . if the engine is already closed, throw an Exception (internal error)
                  . otherwise (cs_START or cs_DATA), create the appropriate handshaker
                  object and advance the connection state (to cs_HANDSHAKE or
                  cs_RENEGOTIATE, respectively).
                  This method is called right after a new engine is created, when
                  starting renegotiation, or when changing client/server mode of the
                  engine.                
            </javadoc>
            <method name="initHandshaker" type="void" line="424">
                <comment line="427">
                                        
                </comment>
                <comment line="428">
                    Starting a new handshake.                    
                </comment>
                <comment line="429">
                                        
                </comment>
                <comment line="434">
                                        
                </comment>
                <comment line="435">
                    We&apos;re already in the middle of a handshake.                    
                </comment>
                <comment line="436">
                                        
                </comment>
                <comment line="441">
                                        
                </comment>
                <comment line="442">
                    Anyone allowed to call this routine is required to                    
                </comment>
                <comment line="443">
                    do so ONLY if the connection state is reasonable...                    
                </comment>
                <comment line="444">
                                        
                </comment>
                <comment line="449">
                    state is either cs_START or cs_DATA                    
                </comment>
                <comment line="452">
                    cs_DATA                    
                </comment>
                <scope line="450"/>
                <scope line="452"/>
                <scope line="455"/>
                <scope line="460"/>
            </method>
            <method name="getHSStatus" type="HandshakeStatus" line="473">
                <params>
                    <param name="hss" type="HandshakeStatus"/>
                </params>
                <comment line="489">
                    Special case where we&apos;re closing, but
                     still need the close_notify before we
                     can officially be closed.
                    
                     Note isOutboundDone is taken care of by
                     hasOutboundData() above.                    
                </comment>
                <comment line="499">
                    else not handshaking                    
                </comment>
                <scope line="475"/>
                <scope line="479">
                    <scope line="480"/>
                    <scope line="482">
                        <scope line="483"/>
                        <scope line="485"/>
                    </scope>
                    <scope line="488">
                        <scope line="497"/>
                    </scope>
                </scope>
            </method>
            <method name="checkTaskThrown" type="void" line="506">
                <scope line="507"/>
            </method>
            <method name="getConnectionState" type="int" line="520"/>
            <method name="setConnectionState" type="void" line="524">
                <params>
                    <param name="state" type="int"/>
                </params>
            </method>
            <method name="getAcc" type="AccessControlContext" line="535"/>
            <method name="getHandshakeStatus" type="SSLEngineResult.HandshakeStatus" line="542"/>
            <method name="changeReadCiphers" type="void" line="561">
                <comment line="568">
                    ... create decompressor                    
                </comment>
                <comment line="576">
                    &quot;can&apos;t happen&quot;                    
                </comment>
                <comment line="581">
                    Dispose of any intermediate state in the underlying cipher.
                     For PKCS11 ciphers, this will release any attached sessions,
                     and thus make finalization faster.
                    
                     Since MAC&apos;s doFinal() is called for every SSLTLS packet, it&apos;s
                     not necessary to do the same with MAC&apos;s.                    
                </comment>
                <scope line="563"/>
                <declaration name="oldCipher" type="CipherBox" line="570"/>
                <scope line="572"/>
                <scope line="575"/>
            </method>
            <method name="changeWriteCiphers" type="void" line="598">
                <comment line="605">
                    ... create compressor                    
                </comment>
                <comment line="613">
                    &quot;can&apos;t happen&quot;                    
                </comment>
                <comment line="618">
                    See comment above.                    
                </comment>
                <scope line="600"/>
                <declaration name="oldCipher" type="CipherBox" line="607"/>
                <scope line="609"/>
                <scope line="612"/>
            </method>
            <method name="setVersion" type="void" line="626">
                <params>
                    <param name="protocolVersion" type="ProtocolVersion"/>
                </params>
            </method>
            <javadoc line="632">
                Kickstart the handshake if it is not already in progress.
                  This means:
                  . if handshaking is already underway, do nothing and return
                  . if the engine is not connected or already closed, throw an
                  Exception.
                  . otherwise, call initHandshake() to initialize the handshaker
                  object and progress the state. Then, send the initial
                  handshaking message if appropriate (always on clients and
                  on servers when renegotiating).                
            </javadoc>
            <method name="kickstartHandshake" type="void" line="646">
                <comment line="658">
                    handshaker already setup, proceed                    
                </comment>
                <comment line="674">
                    initialize the handshaker, move to cs_RENEGOTIATE                    
                </comment>
                <comment line="679">
                    handshaking already in progress, return                    
                </comment>
                <comment line="683">
                    cs_ERROR/cs_CLOSED                    
                </comment>
                <comment line="687">
                                        
                </comment>
                <comment line="688">
                    Kickstart handshake state machine if we need to ...                    
                </comment>
                <comment line="689">
                                        
                </comment>
                <comment line="690">
                    Note that handshaker.kickstart() writes the message                    
                </comment>
                <comment line="691">
                    to its HandshakeOutStream, which calls back into                    
                </comment>
                <comment line="692">
                    SSLSocketImpl.writeRecord() to send it.                    
                </comment>
                <comment line="693">
                                        
                </comment>
                <comment line="695">
                    prior to handshaking, activate the handshake                    
                </comment>
                <comment line="697">
                    don&apos;t use SSLv2Hello when renegotiating                    
                </comment>
                <comment line="704">
                    send client hello                    
                </comment>
                <comment line="706">
                    instanceof ServerHandshaker                    
                </comment>
                <comment line="708">
                    initial handshake, no kickstart message to send                    
                </comment>
                <comment line="710">
                    we want to renegotiate, send hello request                    
                </comment>
                <comment line="713">
                    hello request is not included in the handshake                    
                </comment>
                <comment line="714">
                    hashes, reset them                    
                </comment>
                <scope line="650"/>
                <scope line="662"/>
                <scope line="667">
                    <scope line="668"/>
                </scope>
                <scope line="694">
                    <scope line="696"/>
                    <scope line="699"/>
                    <scope line="703"/>
                    <scope line="706">
                        <scope line="707"/>
                        <scope line="709"/>
                    </scope>
                </scope>
            </method>
            <method name="beginHandshake" type="void" line="724">
                <scope line="725"/>
                <scope line="727"/>
            </method>
            <javadoc line="739">
                Unwraps a buffer.  Does a variety of checks before grabbing
                  the unwrapLock, which blocks multiple unwraps from occuring.                
            </javadoc>
            <method name="unwrap" type="SSLEngineResult" line="744">
                <params>
                    <param name="netData" type="ByteBuffer"/>
                    <param name="appData" type="ByteBuffer[]"/>
                    <param name="offset" type="int"/>
                    <param name="length" type="int"/>
                </params>
                <comment line="753">
                    Don&apos;t reset position so it looks like we didn&apos;t
                     consume anything.  We did consume something, and it
                     got us into this situation, so report that much back.
                     Our days of consuming are now over anyway.                    
                </comment>
                <comment line="761">
                    make compiler happy                    
                </comment>
                <comment line="763">
                    Just in case something failed to reset limits properly.                    
                </comment>
                <declaration name="ea" type="EngineArgs" line="746"/>
                <scope line="748">
                    <scope line="749"/>
                </scope>
                <scope line="752"/>
                <scope line="762"/>
            </method>
            <method name="readNetRecord" type="SSLEngineResult" line="774">
                <params>
                    <param name="ea" type="EngineArgs"/>
                </params>
                <comment line="779">
                    See if the handshaker needs to report back some SSLException.                    
                </comment>
                <comment line="784">
                    Check if we are closingclosed.                    
                </comment>
                <comment line="791">
                    If we&apos;re still in cs_HANDSHAKE, make sure it&apos;s been
                     started.                    
                </comment>
                <comment line="800">
                    If there&apos;s still outbound data to flush, we
                     can return without trying to unwrap anything.                    
                </comment>
                <comment line="812">
                    Grab a copy of this if it doesn&apos;t already exist,
                     and we can use it several places before anything major
                     happens on this side.  Races aren&apos;t critical
                     here.                    
                </comment>
                <comment line="822">
                    If we have a task outstanding, this MUST be done before
                     doing any more unwrapping, because we could be in the middle
                     of receiving a handshake message, for example, a finished
                     message which would change the ciphers.                    
                </comment>
                <comment line="833">
                    Check the packet to make sure enough is here.
                     This will also indirectly check for 0 len packets.                    
                </comment>
                <comment line="839">
                    Is this packet bigger than SSL/TLS normally allows?                    
                </comment>
                <comment line="847">
                    Expand the expected maximum packet/application buffer                    
                </comment>
                <comment line="848">
                    sizes.                    
                </comment>
                <comment line="853">
                    Check for OVERFLOW.
                    
                     To be considered: We could delay enforcing the application buffer
                     free space requirement until after the initial handshaking.                    
                </comment>
                <comment line="863">
                    check for UNDERFLOW.                    
                </comment>
                <comment line="869">
                    We&apos;re now ready to actually do the read.
                     The only result code we really need to be exactly
                     right is the HS finished, for signaling to
                     HandshakeCompletedListeners.                    
                </comment>
                <comment line="885">
                    Check the various condition that we could be reporting.
                    
                     It&apos;s possible something might have happened between the
                     above and now, but it was better to minimally lock &quot;this&quot;
                     during the read process.  We&apos;ll return the current
                     status, which is more representative of the current state.
                    
                     status above should cover:  FINISHED, NEED_TASK                    
                </comment>
                <declaration name="status" type="Status" line="776"/>
                <declaration name="hsStatus" type="HandshakeStatus" line="777"/>
                <scope line="787"/>
                <scope line="795">
                    <scope line="797">
                        <scope line="806"/>
                    </scope>
                </scope>
                <scope line="818"/>
                <scope line="828"/>
                <declaration name="packetLen" type="int" line="837"/>
                <scope line="840">
                    <scope line="841"/>
                    <scope line="846"/>
                </scope>
                <scope line="859"/>
                <scope line="864"/>
                <scope line="875"/>
                <scope line="877"/>
                <scope line="879">
                    <declaration name="ex" type="SSLException" line="880"/>
                </scope>
            </method>
            <method name="readRecord" type="HandshakeStatus" line="913">
                <params>
                    <param name="ea" type="EngineArgs"/>
                </params>
                <comment line="917">
                    The various operations will return new sliced BB&apos;s,
                     this will avoid having to worry about positions and
                     limits in the netBB.                    
                </comment>
                <comment line="927">
                    Read a record ... maybe emitting an alert if we get a
                     comprehensible but unsupported &quot;hello&quot; message during
                     format checking (e.g. V2).                    
                </comment>
                <comment line="938">
                    The basic SSLv3 record protection involves (optional)
                     encryption for privacy, and an integrity check ensuring
                     data origin authentication.  We do them both here, and
                     throw a fatal alert if the integrity check fails.                    
                </comment>
                <comment line="947">
                    RFC 2246 states that decryption_failed should be used                    
                </comment>
                <comment line="948">
                    for this purpose. However, that allows certain attacks,                    
                </comment>
                <comment line="949">
                    so we just send bad record MAC. We also need to make                    
                </comment>
                <comment line="950">
                    sure to always check the MAC to avoid a timing attack                    
                </comment>
                <comment line="951">
                    for the same issue. See paper by Vaudenay et al.                    
                </comment>
                <comment line="952">
                                        
                </comment>
                <comment line="953">
                    rewind the BB if necessary.                    
                </comment>
                <comment line="958">
                    use the same alert types as for MAC failure below                    
                </comment>
                <comment line="975">
                    if (!inputRecord.decompress(c))                    
                </comment>
                <comment line="976">
                    fatal(Alerts.alert_decompression_failure,                    
                </comment>
                <comment line="977">
                    &quot;decompression failure&quot;);                    
                </comment>
                <comment line="980">
                    Process the record.                    
                </comment>
                <comment line="987">
                    Handshake messages always go to a pending session
                     handshaker ... if there isn&apos;t one, create one.  This
                     must work asynchronously, for renegotiation.
                    
                     NOTE that handshaking will either resume a session
                     which was in the cache (and which might have other
                     connections in it already), or else will start a new
                     session (new keys exchanged) with just this connection
                     in it.                    
                </comment>
                <comment line="1000">
                    prior to handshaking, activate the handshake                    
                </comment>
                <comment line="1002">
                    don&apos;t use SSLv2Hello when renegotiating                    
                </comment>
                <comment line="1009">
                    process the handshake record ... may contain just
                     a partial handshake message or multiple messages.
                    
                     The handshaker state machine will ensure that it&apos;s
                     a finished message.                    
                </comment>
                <comment line="1021">
                    if state is cs_RENEGOTIATE, revert it to cs_DATA                    
                </comment>
                <comment line="1026">
                    reset the parameters for secure renegotiation.                    
                </comment>
                <comment line="1040">
                    No handshakeListeners here.  That&apos;s a                    
                </comment>
                <comment line="1041">
                    SSLSocket thing.                    
                </comment>
                <comment line="1048">
                    Pass this right back up to the application.                    
                </comment>
                <comment line="1062">
                    Don&apos;t return data once the inbound side is
                     closed.                    
                </comment>
                <comment line="1085">
                                        
                </comment>
                <comment line="1086">
                    The first message after a change_cipher_spec                    
                </comment>
                <comment line="1087">
                    record MUST be a &quot;Finished&quot; handshake record,                    
                </comment>
                <comment line="1088">
                    else it&apos;s a protocol violation.  We force this                    
                </comment>
                <comment line="1089">
                    to be checked by a minor tweak to the state                    
                </comment>
                <comment line="1090">
                    machine.                    
                </comment>
                <comment line="1091">
                                        
                </comment>
                <comment line="1093">
                    next message MUST be a finished message                    
                </comment>
                <comment line="1098">
                                        
                </comment>
                <comment line="1099">
                    TLS requires that unrecognized records be ignored.                    
                </comment>
                <comment line="1100">
                                        
                </comment>
                <comment line="1107">
                    switch                    
                </comment>
                <comment line="1109">
                    We only need to check the sequence number state for
                     non-handshaking record.
                    
                     Note that in order to maintain the handshake status
                     properly, we check the sequence number after the last
                     record reading process. As we request renegotiation
                     or close the connection for wrapped sequence number
                     when there is enough sequence number space left to
                     handle a few more records, so the sequence number
                     of the last record cannot be wrapped.                    
                </comment>
                <comment line="1128">
                    synchronized (this)                    
                </comment>
                <declaration name="hsStatus" type="HandshakeStatus" line="915"/>
                <declaration name="readBB" type="ByteBuffer" line="922"/>
                <declaration name="decryptedBB" type="ByteBuffer" line="923"/>
                <scope line="925">
                    <scope line="932"/>
                    <scope line="934"/>
                    <scope line="944"/>
                    <scope line="946">
                        <declaration name="alertType" type="byte" line="959"/>
                    </scope>
                    <scope line="966">
                        <scope line="967"/>
                        <scope line="970"/>
                    </scope>
                    <scope line="984">
                        <scope line="999">
                            <scope line="1001"/>
                            <scope line="1004"/>
                        </scope>
                        <scope line="1019">
                            <scope line="1022"/>
                        </scope>
                        <scope line="1025">
                            <scope line="1034"/>
                        </scope>
                        <scope line="1042"/>
                        <scope line="1051"/>
                        <scope line="1057"/>
                        <scope line="1066"/>
                        <scope line="1079"/>
                        <scope line="1101"/>
                        <scope line="1122">
                            <scope line="1124"/>
                        </scope>
                    </scope>
                </scope>
            </method>
            <javadoc line="1140">
                Wraps a buffer.  Does a variety of checks before grabbing
                  the wrapLock, which blocks multiple wraps from occuring.                
            </javadoc>
            <method name="wrap" type="SSLEngineResult" line="1145">
                <params>
                    <param name="appData" type="ByteBuffer[]"/>
                    <param name="offset" type="int"/>
                    <param name="length" type="int"/>
                    <param name="netData" type="ByteBuffer"/>
                </params>
                <comment line="1149">
                    We can be smarter about using smaller buffer sizes later.
                     For now, force it to be large enough to handle any
                     valid SSLTLS record.                    
                </comment>
                <comment line="1168">
                    make compiler happy                    
                </comment>
                <comment line="1170">
                    Just in case something didn&apos;t reset limits properly.                    
                </comment>
                <declaration name="ea" type="EngineArgs" line="1147"/>
                <scope line="1154"/>
                <scope line="1159">
                    <scope line="1160"/>
                </scope>
                <scope line="1163"/>
                <scope line="1169"/>
            </method>
            <method name="writeAppRecord" type="SSLEngineResult" line="1181">
                <params>
                    <param name="ea" type="EngineArgs"/>
                </params>
                <comment line="1186">
                    See if the handshaker needs to report back some SSLException.                    
                </comment>
                <comment line="1191">
                    short circuit if we&apos;re closedclosing.                    
                </comment>
                <comment line="1198">
                    If we&apos;re still in cs_HANDSHAKE, make sure it&apos;s been
                     started.                    
                </comment>
                <comment line="1207">
                    If there&apos;s no HS data available to write, we can return
                     without trying to wrap anything.                    
                </comment>
                <comment line="1219">
                    Grab a copy of this if it doesn&apos;t already exist,
                     and we can use it several places before anything major
                     happens on this side.  Races aren&apos;t critical
                     here.                    
                </comment>
                <comment line="1229">
                    If we have a task outstanding, this MUST be done before
                     doing any more wrapping, because we could be in the middle
                     of receiving a handshake message, for example, a finished
                     message which would change the ciphers.                    
                </comment>
                <comment line="1240">
                    This will obtain any waiting outbound data, or will
                     process the outbound appData.                    
                </comment>
                <comment line="1256">
                    writeRecord might have reported some status.
                     Now check for the remaining cases.
                    
                     status above should cover:  NEED_WRAPFINISHED                    
                </comment>
                <declaration name="status" type="Status" line="1183"/>
                <declaration name="hsStatus" type="HandshakeStatus" line="1184"/>
                <scope line="1194"/>
                <scope line="1202">
                    <scope line="1204">
                        <scope line="1213"/>
                    </scope>
                </scope>
                <scope line="1225"/>
                <scope line="1235"/>
                <scope line="1244">
                    <scope line="1245"/>
                </scope>
                <scope line="1248"/>
                <scope line="1250">
                    <declaration name="ex" type="SSLException" line="1251"/>
                </scope>
            </method>
            <method name="writeRecord" type="HandshakeStatus" line="1273">
                <params>
                    <param name="eor" type="EngineOutputRecord"/>
                    <param name="ea" type="EngineArgs"/>
                </params>
                <comment line="1275">
                    eventually compress as well.                    
                </comment>
                <comment line="1279">
                    We only need to check the sequence number state for
                     non-handshaking record.
                    
                     Note that in order to maintain the handshake status
                     properly, we check the sequence number after the last
                     record writing process. As we request renegotiation
                     or close the connection for wrapped sequence number
                     when there is enough sequence number space left to
                     handle a few more records, so the sequence number
                     of the last record cannot be wrapped.                    
                </comment>
                <declaration name="hsStatus" type="HandshakeStatus" line="1276"/>
                <scope line="1292">
                    <scope line="1293"/>
                </scope>
            </method>
            <method name="writeRecord" type="void" line="1304">
                <params>
                    <param name="eor" type="EngineOutputRecord"/>
                </params>
                <comment line="1305">
                    eventually compress as well.                    
                </comment>
                <comment line="1308">
                    Check the sequence number state
                    
                     Note that in order to maintain the connection IO
                     properly, we check the sequence number after the last
                     record writing process. As we request renegotiation
                     or close the connection for wrapped sequence number
                     when there is enough sequence number space left to
                     handle a few more records, so the sequence number
                     of the last record cannot be wrapped.                    
                </comment>
                <scope line="1319"/>
            </method>
            <javadoc line="1328">
                Check the sequence number state
                  RFC 4346 states that, &quot;Sequence numbers are of type uint64 and
                  may not exceed 2^64-1.  Sequence numbers do not wrap. If a TLS
                  implementation would need to wrap a sequence number, it must
                  renegotiate instead.&quot;
                  Return true if the handshake status may be changed.                
            </javadoc>
            <method name="checkSequenceNumber" type="boolean" line="1339">
                <params>
                    <param name="mac" type="MAC"/>
                    <param name="type" type="byte"/>
                </params>
                <comment line="1341">
                    Don&apos;t bother to check the sequence number for error or
                     closed connections, or NULL MAC                    
                </comment>
                <comment line="1349">
                    Conservatively, close the connection immediately when the
                     sequence number is close to overflow                    
                </comment>
                <comment line="1354">
                    TLS protocols do not define a error alert for sequence
                     number overflow. We use handshake_failure error alert
                     for handshaking and bad_record_mac for other records.                    
                </comment>
                <comment line="1367">
                    make the compiler happy                    
                </comment>
                <comment line="1370">
                    Ask for renegotiation when need to renew sequence number.
                    
                     Don&apos;t bother to kickstart the renegotiation when the local is
                     asking for it.                    
                </comment>
                <scope line="1345"/>
                <scope line="1353">
                    <scope line="1359"/>
                </scope>
                <scope line="1376">
                    <scope line="1377"/>
                </scope>
            </method>
            <javadoc line="1389">
                Signals that no more outbound application data will be sent
                  on this &lt;code&gt;SSLEngine&lt;/code&gt;.                
            </javadoc>
            <method name="closeOutboundInternal" type="void" line="1393">
                <comment line="1399">
                    Already closed, ignore                    
                </comment>
                <comment line="1408">
                    If we haven&apos;t even started yet, don&apos;t bother reading inbound.                    
                </comment>
                <comment line="1420">
                    Otherwise we indicate clean termination.                    
                </comment>
                <comment line="1423">
                    case cs_HANDSHAKE:                    
                </comment>
                <comment line="1424">
                    case cs_DATA:                    
                </comment>
                <comment line="1425">
                    case cs_RENEGOTIATE:                    
                </comment>
                <comment line="1432">
                    See comment in changeReadCiphers()                    
                </comment>
                <scope line="1395"/>
                <scope line="1402"/>
            </method>
            <method name="closeOutbound" type="void" line="1438">
                <comment line="1439">
                    Dump out a close_notify to the remote side                    
                </comment>
                <scope line="1442"/>
            </method>
            <javadoc line="1449">
                Returns the outbound application data closure state                
            </javadoc>
            <method name="isOutboundDone" type="boolean" line="1452"/>
            <javadoc line="1456">
                Signals that no more inbound network data will be sent
                  to this &lt;code&gt;SSLEngine&lt;/code&gt;.                
            </javadoc>
            <method name="closeInboundInternal" type="void" line="1460">
                <comment line="1466">
                    Already closed, ignore                    
                </comment>
                <comment line="1476">
                    See comment in changeReadCiphers()                    
                </comment>
                <scope line="1462"/>
                <scope line="1469"/>
            </method>
            <method name="closeInbound" type="void" line="1487">
                <comment line="1488">
                    Currently closes the outbound side as well.  The IETF TLS
                     working group has expressed the opinion that 12 open
                     connections are not allowed by the spec.  May change
                     someday in the future.                    
                </comment>
                <comment line="1498">
                    No need to throw an Exception if we haven&apos;t even started yet.                    
                </comment>
                <comment line="1502">
                    Only receive the Exception once                    
                </comment>
                <comment line="1507">
                    Currently, this is a no-op, but in case we change
                     the close inbound code later.                    
                </comment>
                <scope line="1494"/>
                <scope line="1501"/>
                <scope line="1506"/>
            </method>
            <javadoc line="1515">
                Returns the network inbound data closure state                
            </javadoc>
            <method name="isInboundDone" type="boolean" line="1518"/>
            <javadoc line="1528">
                Returns the current &lt;code&gt;SSLSession&lt;/code&gt; for this
                  &lt;code&gt;SSLEngine&lt;/code&gt;
                  &lt;P&gt;
                  These can be long lived, and frequently correspond to an
                  entire login session for some user.                
            </javadoc>
            <method name="getSession" type="SSLSession" line="1535"/>
            <method name="getHandshakeSession" type="SSLSession" line="1540"/>
            <method name="setHandshakeSession" type="void" line="1544">
                <params>
                    <param name="session" type="SSLSessionImpl"/>
                </params>
            </method>
            <javadoc line="1548">
                Returns a delegated &lt;code&gt;Runnable&lt;/code&gt; task for
                  this &lt;code&gt;SSLEngine&lt;/code&gt;.                
            </javadoc>
            <method name="getDelegatedTask" type="Runnable" line="1552">
                <scope line="1553"/>
            </method>
            <method name="warning" type="void" line="1567">
                <params>
                    <param name="description" type="byte"/>
                </params>
            </method>
            <method name="fatal" type="void" line="1572">
                <params>
                    <param name="description" type="byte"/>
                    <param name="diagnostic" type="String"/>
                </params>
            </method>
            <method name="fatal" type="void" line="1577">
                <params>
                    <param name="description" type="byte"/>
                    <param name="cause" type="Throwable"/>
                </params>
            </method>
            <method name="fatal" type="void" line="1595">
                <params>
                    <param name="description" type="byte"/>
                    <param name="diagnostic" type="String"/>
                    <param name="cause" type="Throwable"/>
                </params>
                <comment line="1597">
                    If we have no further information, make a general-purpose
                     message for folks to see.  We generally have one or the other.                    
                </comment>
                <comment line="1608">
                    If we&apos;ve already shutdown because of an error,
                     there is nothing we can do except rethrow the exception.
                    
                     Most exceptions seen here will be SSLExceptions.
                     We may find the occasional Exception which hasn&apos;t been
                     converted to a SSLException, so we&apos;ll do it here.                    
                </comment>
                <comment line="1640">
                    Ok, this engine&apos;s going down.                    
                </comment>
                <comment line="1653">
                    If we haven&apos;t even started handshaking yet, no need
                     to generate the fatal close alert.                    
                </comment>
                <comment line="1661">
                    only true if != null                    
                </comment>
                <comment line="1664">
                    Including RuntimeExceptions, but we&apos;ll throw those
                     down below.  The closeReason isn&apos;t used again,
                     except for null checks.                    
                </comment>
                <comment line="1677">
                    See comment in changeReadCiphers()                    
                </comment>
                <scope line="1601"/>
                <scope line="1604"/>
                <scope line="1616">
                    <scope line="1617"/>
                    <scope line="1622"/>
                    <scope line="1624"/>
                    <scope line="1626">
                        <declaration name="ssle" type="SSLException" line="1627"/>
                    </scope>
                </scope>
                <scope line="1634"/>
                <declaration name="oldState" type="int" line="1643"/>
                <scope line="1649"/>
                <scope line="1657"/>
                <scope line="1661"/>
                <scope line="1663"/>
                <scope line="1681"/>
                <scope line="1683"/>
            </method>
            <method name="recvAlert" type="void" line="1692">
                <comment line="1695">
                    check for short message                    
                </comment>
                <comment line="1722">
                    reply to close                    
                </comment>
                <comment line="1726">
                                        
                </comment>
                <comment line="1727">
                    The other legal warnings relate to certificates,                    
                </comment>
                <comment line="1728">
                    e.g. no_certificate, bad_certificate, etc; these                    
                </comment>
                <comment line="1729">
                    are important to the handshaking code, which can                    
                </comment>
                <comment line="1730">
                    also handle illegal protocol alerts if needed.                    
                </comment>
                <comment line="1731">
                                        
                </comment>
                <comment line="1736">
                    fatal or unknown level                    
                </comment>
                <declaration name="level" type="byte" line="1693"/>
                <declaration name="description" type="byte" line="1694"/>
                <scope line="1695"/>
                <scope line="1700">
                    <scope line="1701">
                        <scope line="1704"/>
                        <scope line="1706"/>
                        <scope line="1708"/>
                    </scope>
                </scope>
                <scope line="1715">
                    <scope line="1716">
                        <scope line="1717"/>
                        <scope line="1720"/>
                    </scope>
                    <scope line="1724">
                        <scope line="1732"/>
                    </scope>
                </scope>
                <scope line="1736">
                    <declaration name="reason" type="String" line="1737"/>
                    <scope line="1739"/>
                </scope>
            </method>
            <method name="sendAlert" type="void" line="1750">
                <params>
                    <param name="level" type="byte"/>
                    <param name="description" type="byte"/>
                </params>
                <comment line="1751">
                    the connectionState cannot be cs_START                    
                </comment>
                <comment line="1756">
                    For initial handshaking, don&apos;t send alert message to peer if                    
                </comment>
                <comment line="1757">
                    handshaker has not started.                    
                </comment>
                <scope line="1752"/>
                <scope line="1759"/>
                <declaration name="r" type="EngineOutputRecord" line="1763"/>
                <declaration name="useDebug" type="boolean" line="1766"/>
                <scope line="1767">
                    <scope line="1768">
                        <scope line="1771"/>
                        <scope line="1773"/>
                        <scope line="1775"/>
                    </scope>
                </scope>
                <scope line="1785"/>
                <scope line="1787">
                    <scope line="1788"/>
                </scope>
            </method>
            <javadoc line="1801">
                Controls whether new connections may cause creation of new SSL
                  sessions.
                  As long as handshaking has not started, we can change
                  whether we enable session creations.  Otherwise,
                  we will need to wait for the next handshake.                
            </javadoc>
            <method name="setEnableSessionCreation" type="void" line="1809">
                <params>
                    <param name="flag" type="boolean"/>
                </params>
                <scope line="1812"/>
            </method>
            <javadoc line="1817">
                Returns true if new connections may cause creation of new SSL
                  sessions.                
            </javadoc>
            <method name="getEnableSessionCreation" type="boolean" line="1821"/>
            <javadoc line="1826">
                Sets the flag controlling whether a server mode engine
                  REQUIRES SSL client authentication.
                  As long as handshaking has not started, we can change
                  whether client authentication is needed.  Otherwise,
                  we will need to wait for the next handshake.                
            </javadoc>
            <method name="setNeedClientAuth" type="void" line="1834">
                <params>
                    <param name="flag" type="boolean"/>
                </params>
                <scope line="1840"/>
            </method>
            <method name="getNeedClientAuth" type="boolean" line="1845"/>
            <javadoc line="1849">
                Sets the flag controlling whether a server mode engine
                  REQUESTS SSL client authentication.
                  As long as handshaking has not started, we can change
                  whether client authentication is requested.  Otherwise,
                  we will need to wait for the next handshake.                
            </javadoc>
            <method name="setWantClientAuth" type="void" line="1857">
                <params>
                    <param name="flag" type="boolean"/>
                </params>
                <scope line="1863"/>
            </method>
            <method name="getWantClientAuth" type="boolean" line="1868"/>
            <javadoc line="1873">
                Sets the flag controlling whether the engine is in SSL
                  client or server mode.  Must be called before any SSL
                  traffic has started.                
            </javadoc>
            <method name="setUseClientMode" type="void" line="1878">
                <params>
                    <param name="flag" type="boolean"/>
                </params>
                <comment line="1882">
                    If we need to change the engine mode and the enabled
                     protocols haven&apos;t specifically been set by the user,
                     change them to the corresponding default ones.                    
                </comment>
                <comment line="1897">
                    If we have a handshaker, but haven&apos;t started
                     SSL traffic, we can throw away our current
                     handshaker, and start from scratch.  Don&apos;t
                     need to call doneConnect() again, we already
                     have the streams.                    
                </comment>
                <comment line="1906">
                    If we need to change the engine mode and the enabled
                     protocols haven&apos;t specifically been set by the user,
                     change them to the corresponding default ones.                    
                </comment>
                <comment line="1922">
                    If handshake has started, that&apos;s an error.  Fall through...                    
                </comment>
                <comment line="1931">
                    We can let them continue if they catch this correctly,
                     we don&apos;t need to shut this down.                    
                </comment>
                <scope line="1888"/>
                <scope line="1905">
                    <scope line="1912"/>
                </scope>
                <scope line="1925"/>
            </method>
            <method name="getUseClientMode" type="boolean" line="1940"/>
            <javadoc line="1945">
                Returns the names of the cipher suites which could be enabled for use
                  on an SSL connection.  Normally, only a subset of these will actually
                  be enabled by default, since this list may include cipher suites which
                  do not support the mutual authentication of servers and clients, or
                  which do not protect data confidentiality.  Servers may also need
                  certain kinds of certificates to use certain cipher suites.                
                <return>
                    an array of cipher suite names                    
                </return>
            </javadoc>
            <method name="getSupportedCipherSuites" type="String[]" line="1955"/>
            <javadoc line="1959">
                Controls which particular cipher suites are enabled for use on
                  this connection.  The cipher suites must have been listed by
                  getCipherSuites() as being supported.  Even if a suite has been
                  enabled, it might never be used if no peer supports it or the
                  requisite certificates (and private keys) are not available.                
                <param>
                    suites Names of all the cipher suites to enable.                    
                </param>
            </javadoc>
            <method name="setEnabledCipherSuites" type="void" line="1968">
                <params>
                    <param name="suites" type="String[]"/>
                </params>
                <scope line="1970"/>
            </method>
            <javadoc line="1975">
                Returns the names of the SSL cipher suites which are currently enabled
                  for use on this connection.  When an SSL engine is first created,
                  all enabled cipher suites &lt;em&gt;(a)&lt;/em&gt; protect data confidentiality,
                  by traffic encryption, and &lt;em&gt;(b)&lt;/em&gt; can mutually authenticate
                  both clients and servers.  Thus, in some environments, this value
                  might be empty.                
                <return>
                    an array of cipher suite names                    
                </return>
            </javadoc>
            <method name="getEnabledCipherSuites" type="String[]" line="1985"/>
            <javadoc line="1990">
                Returns the protocols that are supported by this implementation.
                  A subset of the supported protocols may be enabled for this connection                
                <return>
                    an array of protocol names.                    
                </return>
            </javadoc>
            <method name="getSupportedProtocols" type="String[]" line="1995"/>
            <javadoc line="1999">
                Controls which protocols are enabled for use on
                  this connection.  The protocols must have been listed by
                  getSupportedProtocols() as being supported.                
                <param>
                    protocols protocols to enable.                    
                </param>
                <exception>
                    IllegalArgumentException when one of the protocols
                      named by the parameter is not supported.                    
                </exception>
            </javadoc>
            <method name="setEnabledProtocols" type="void" line="2008">
                <params>
                    <param name="protocols" type="String[]"/>
                </params>
                <scope line="2010"/>
            </method>
            <method name="getEnabledProtocols" type="String[]" line="2015"/>
            <javadoc line="2019">
                Returns the SSLParameters in effect for this SSLEngine.                
            </javadoc>
            <method name="getSSLParameters" type="SSLParameters" line="2022">
                <comment line="2025">
                    the super implementation does not handle the following parameters                    
                </comment>
                <declaration name="params" type="SSLParameters" line="2023"/>
            </method>
            <javadoc line="2032">
                Applies SSLParameters to this engine.                
            </javadoc>
            <method name="setSSLParameters" type="void" line="2035">
                <params>
                    <param name="params" type="SSLParameters"/>
                </params>
                <comment line="2038">
                    the super implementation does not handle the following parameters                    
                </comment>
                <scope line="2041"/>
            </method>
            <javadoc line="2047">
                Return the name of the current thread. Utility method.                
            </javadoc>
            <method name="threadName" type="String" line="2050"/>
            <javadoc line="2054">
                Returns a printable representation of this end of the connection.                
            </javadoc>
            <method name="toString" type="String" line="2057">
                <declaration name="retval" type="StringBuilder" line="2058"/>
                <declaration name="host" type="String" line="2063"/>
            </method>
        </class>
    </source>