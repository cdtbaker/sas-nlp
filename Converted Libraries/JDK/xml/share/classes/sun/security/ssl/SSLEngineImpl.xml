<?xml version="1.0" encoding="UTF-8"?>
    <source package="sun.security.ssl">
        <import package="java.io"/>
        <import package="java.nio"/>
        <import package="java.nio.ReadOnlyBufferException"/>
        <import package="java.util.LinkedList"/>
        <import package="java.security"/>
        <import package="javax.crypto.BadPaddingException"/>
        <import package="javax.net.ssl"/>
        <import package="javax.net.ssl.SSLEngineResult"/>
        <import package="com.sun.net.ssl.internal.ssl.X509ExtendedTrustManager"/>
        <class name="SSLEngineImpl" line="11">
            <extends class="SSLEngine"/>
            <javadoc line="11">
                Implementation of an non-blocking SSLEngine.
                  Currently, the SSLEngine code exists in parallel with the current
                  SSLSocket.  As such, the current implementation is using legacy code
                  with many of the same abstractions.  However, it varies in many
                  areas, most dramatically in the IO handling.
                  There are three main I/O threads that can be existing in parallel:
                  wrap(), unwrap(), and beginHandshake().  We are encouraging users to
                  not call multiple instances of wrap or unwrap, because the data could
                  appear to flow out of the SSLEngine in a non-sequential order.  We
                  take all steps we can to at least make sure the ordering remains
                  consistent, but once the calls returns, anything can happen.  For
                  example, thread1 and thread2 both call wrap, thread1 gets the first
                  packet, thread2 gets the second packet, but thread2 gets control back
                  before thread1, and sends the data.  The receiving side would see an
                  out-of-order error.
                  Handshaking is still done the same way as SSLSocket using the normal
                  InputStream/OutputStream abstactions.  We create
                  ClientHandshakers/ServerHandshakers, which produce/consume the
                  handshaking data.  The transfer of the data is largely handled by the
                  HandshakeInStream/HandshakeOutStreams.  Lastly, the
                  InputRecord/OutputRecords still have the same functionality, except
                  that they are overridden with EngineInputRecord/EngineOutputRecord,
                  which provide SSLEngine-specific functionality.
                  Some of the major differences are:
                  EngineInputRecord/EngineOutputRecord/EngineWriter:
                  In order to avoid writing whole new control flows for
                  handshaking, and to reuse most of the same code, we kept most
                  of the actual handshake code the same.  As usual, reading
                  handshake data may trigger output of more handshake data, so
                  what we do is write this data to internal buffers, and wait for
                  wrap() to be called to give that data a ride.
                  All data is routed through
                  EngineInputRecord/EngineOutputRecord.  However, all handshake
                  data (ct_alert/ct_change_cipher_spec/ct_handshake) are passed
                  through to the the underlying InputRecord/OutputRecord, and
                  the data uses the internal buffers.
                  Application data is handled slightly different, we copy the data
                  directly from the src to the dst buffers, and do all operations
                  on those buffers, saving the overhead of multiple copies.
                  In the case of an inbound record, unwrap passes the inbound
                  ByteBuffer to the InputRecord.  If the data is handshake data,
                  the data is read into the InputRecord&apos;s internal buffer.  If
                  the data is application data, the data is decoded directly into
                  the dst buffer.
                  In the case of an outbound record, when the write to the
                  &quot;real&quot; OutputStream&apos;s would normally take place, instead we
                  call back up to the EngineOutputRecord&apos;s version of
                  writeBuffer, at which time we capture the resulting output in a
                  ByteBuffer, and send that back to the EngineWriter for internal
                  storage.
                  EngineWriter is responsible for &quot;handling&quot; all outbound
                  data, be it handshake or app data, and for returning the data
                  to wrap() in the proper order.
                  ClientHandshaker/ServerHandshaker/Handshaker:
                  Methods which relied on SSLSocket now have work on either
                  SSLSockets or SSLEngines.                
                <author>
                    Brad Wetmore                    
                </author>
            </javadoc>
            <declaration name="connectionState" type="int" line="71"/>
            <declaration name="cs_START" type="int" line="72"/>
            <declaration name="cs_HANDSHAKE" type="int" line="73"/>
            <declaration name="cs_DATA" type="int" line="74"/>
            <declaration name="cs_RENEGOTIATE" type="int" line="75"/>
            <declaration name="cs_ERROR" type="int" line="76"/>
            <declaration name="cs_CLOSED" type="int" line="77"/>
            <declaration name="inboundDone" type="boolean" line="78"/>
            <declaration name="writer" type="EngineWriter" line="79"/>
            <declaration name="sslContext" type="SSLContextImpl" line="80"/>
            <declaration name="handshaker" type="Handshaker" line="81"/>
            <declaration name="sess" type="SSLSessionImpl" line="82"/>
            <declaration name="handshakeSession" type="SSLSessionImpl" line="83"/>
            <declaration name="clauth_none" type="byte" line="84"/>
            <declaration name="clauth_requested" type="byte" line="85"/>
            <declaration name="clauth_required" type="byte" line="86"/>
            <declaration name="expectingFinished" type="boolean" line="87"/>
            <declaration name="recvCN" type="boolean" line="88"/>
            <declaration name="closeReason" type="SSLException" line="89"/>
            <declaration name="doClientAuth" type="byte" line="90"/>
            <declaration name="enableSessionCreation" type="boolean" line="91"/>
            <declaration name="inputRecord" type="EngineInputRecord" line="92"/>
            <declaration name="outputRecord" type="EngineOutputRecord" line="93"/>
            <declaration name="acc" type="AccessControlContext" line="94"/>
            <declaration name="enabledCipherSuites" type="CipherSuiteList" line="95"/>
            <declaration name="identificationProtocol" type="String" line="96"/>
            <declaration name="algorithmConstraints" type="AlgorithmConstraints" line="97"/>
            <declaration name="serverModeSet" type="boolean" line="98"/>
            <declaration name="roleIsServer" type="boolean" line="99"/>
            <declaration name="enabledProtocols" type="ProtocolList" line="100"/>
            <declaration name="protocolVersion" type="ProtocolVersion" line="101"/>
            <declaration name="readMAC" type="MAC" line="102"/>
            <declaration name="readCipher" type="CipherBox" line="103"/>
            <declaration name="secureRenegotiation" type="boolean" line="104"/>
            <declaration name="clientVerifyData" type="byte[]" line="105"/>
            <declaration name="serverVerifyData" type="byte[]" line="106"/>
            <declaration name="wrapLock" type="Object" line="107"/>
            <declaration name="unwrapLock" type="Object" line="108"/>
            <declaration name="writeLock" type="Object" line="109"/>
            <declaration name="debug" type="Debug" line="110"/>
            <javadoc line="111">
                Constructor for an SSLEngine from SSLContext, without
                  host/port hints.  This Engine will not be able to cache
                  sessions, but must renegotiate everything by hand.                
            </javadoc>
            <method name="SSLEngineImpl" type="constructor" line="116">
                <params>
                    <param name="ctx" type="SSLContextImpl"/>
                </params>
            </method>
            <javadoc line="120">
                Constructor for an SSLEngine from SSLContext.                
            </javadoc>
            <method name="SSLEngineImpl" type="constructor" line="123">
                <params>
                    <param name="ctx" type="SSLContextImpl"/>
                    <param name="host" type="String"/>
                    <param name="port" type="int"/>
                </params>
            </method>
            <javadoc line="127">
                Initializes the Engine                
            </javadoc>
            <method name="init" type="void" line="130">
                <params>
                    <param name="ctx" type="SSLContextImpl"/>
                </params>
                <scope line="131"/>
            </method>
            <javadoc line="157">
                Initialize the handshaker object. This means:
                  . if a handshake is already in progress (state is cs_HANDSHAKE
                  or cs_RENEGOTIATE), do nothing and return
                  . if the engine is already closed, throw an Exception (internal error)
                  . otherwise (cs_START or cs_DATA), create the appropriate handshaker
                  object and advance the connection state (to cs_HANDSHAKE or
                  cs_RENEGOTIATE, respectively).
                  This method is called right after a new engine is created, when
                  starting renegotiation, or when changing client/server mode of the
                  engine.                
            </javadoc>
            <method name="initHandshaker" type="void" line="169">
                <scope line="180"/>
                <scope line="183"/>
                <scope line="186"/>
                <scope line="189"/>
            </method>
            <method name="getHSStatus" type="HandshakeStatus" line="195">
                <params>
                    <param name="hss" type="HandshakeStatus"/>
                </params>
                <scope line="196"/>
                <scope line="199">
                    <scope line="200"/>
                    <scope line="203">
                        <scope line="204"/>
                        <scope line="207"/>
                    </scope>
                    <scope line="211">
                        <scope line="212"/>
                    </scope>
                </scope>
            </method>
            <method name="checkTaskThrown" type="void" line="219">
                <scope line="220"/>
            </method>
            <method name="getConnectionState" type="int" line="224"/>
            <method name="setConnectionState" type="void" line="227">
                <params>
                    <param name="state" type="int"/>
                </params>
            </method>
            <method name="getAcc" type="AccessControlContext" line="230"/>
            <method name="getHandshakeStatus" type="SSLEngineResult.HandshakeStatus" line="233"/>
            <method name="changeReadCiphers" type="void" line="236">
                <scope line="237"/>
                <declaration name="oldCipher" type="CipherBox" line="240"/>
                <scope line="241"/>
                <scope line="245"/>
            </method>
            <method name="changeWriteCiphers" type="void" line="250">
                <scope line="251"/>
                <declaration name="oldCipher" type="CipherBox" line="254"/>
                <scope line="255"/>
                <scope line="259"/>
            </method>
            <method name="setVersion" type="void" line="264">
                <params>
                    <param name="protocolVersion" type="ProtocolVersion"/>
                </params>
            </method>
            <javadoc line="268">
                Kickstart the handshake if it is not already in progress.
                  This means:
                  . if handshaking is already underway, do nothing and return
                  . if the engine is not connected or already closed, throw an
                  Exception.
                  . otherwise, call initHandshake() to initialize the handshaker
                  object and progress the state. Then, send the initial
                  handshaking message if appropriate (always on clients and
                  on servers when renegotiating).                
            </javadoc>
            <method name="kickstartHandshake" type="void" line="279">
                <scope line="282"/>
                <scope line="290"/>
                <scope line="293">
                    <scope line="294"/>
                </scope>
                <scope line="305">
                    <scope line="306"/>
                    <scope line="309"/>
                    <scope line="312"/>
                    <scope line="315">
                        <scope line="316"/>
                        <scope line="318"/>
                    </scope>
                </scope>
            </method>
            <method name="beginHandshake" type="void" line="325">
                <scope line="326"/>
                <scope line="329"/>
            </method>
            <javadoc line="333">
                Unwraps a buffer.  Does a variety of checks before grabbing
                  the unwrapLock, which blocks multiple unwraps from occuring.                
            </javadoc>
            <method name="unwrap" type="SSLEngineResult" line="337">
                <params>
                    <param name="netData" type="ByteBuffer"/>
                    <param name="appData" type="ByteBuffer[]"/>
                    <param name="offset" type="int"/>
                    <param name="length" type="int"/>
                </params>
                <declaration name="ea" type="EngineArgs" line="338"/>
                <scope line="339">
                    <scope line="340"/>
                </scope>
                <scope line="344"/>
                <scope line="348"/>
            </method>
            <method name="readNetRecord" type="SSLEngineResult" line="352">
                <params>
                    <param name="ea" type="EngineArgs"/>
                </params>
                <declaration name="status" type="Status" line="353"/>
                <declaration name="hsStatus" type="HandshakeStatus" line="354"/>
                <scope line="356"/>
                <scope line="359">
                    <scope line="360">
                        <scope line="363"/>
                    </scope>
                </scope>
                <scope line="368"/>
                <scope line="371"/>
                <declaration name="packetLen" type="int" line="374"/>
                <scope line="375">
                    <scope line="376"/>
                    <scope line="379"/>
                </scope>
                <scope line="383"/>
                <scope line="386"/>
                <scope line="389"/>
                <scope line="392"/>
                <scope line="395">
                    <declaration name="ex" type="SSLException" line="396"/>
                </scope>
            </method>
            <method name="readRecord" type="HandshakeStatus" line="404">
                <params>
                    <param name="ea" type="EngineArgs"/>
                </params>
                <declaration name="hsStatus" type="HandshakeStatus" line="405"/>
                <declaration name="readBB" type="ByteBuffer" line="406"/>
                <declaration name="decryptedBB" type="ByteBuffer" line="407"/>
                <scope line="408">
                    <scope line="409"/>
                    <scope line="412"/>
                    <scope line="415"/>
                    <scope line="418">
                        <declaration name="alertType" type="byte" line="421"/>
                    </scope>
                    <scope line="424">
                        <scope line="425"/>
                        <scope line="428"/>
                    </scope>
                    <scope line="432">
                        <scope line="436">
                            <scope line="437"/>
                            <scope line="440"/>
                        </scope>
                        <scope line="446">
                            <scope line="448"/>
                        </scope>
                        <scope line="452">
                            <scope line="458"/>
                        </scope>
                        <scope line="464"/>
                        <scope line="469"/>
                        <scope line="472"/>
                        <scope line="475"/>
                        <scope line="483"/>
                        <scope line="490"/>
                        <scope line="495">
                            <scope line="496"/>
                        </scope>
                    </scope>
                </scope>
            </method>
            <javadoc line="504">
                Wraps a buffer.  Does a variety of checks before grabbing
                  the wrapLock, which blocks multiple wraps from occuring.                
            </javadoc>
            <method name="wrap" type="SSLEngineResult" line="508">
                <params>
                    <param name="appData" type="ByteBuffer[]"/>
                    <param name="offset" type="int"/>
                    <param name="length" type="int"/>
                    <param name="netData" type="ByteBuffer"/>
                </params>
                <declaration name="ea" type="EngineArgs" line="509"/>
                <scope line="510"/>
                <scope line="513">
                    <scope line="514"/>
                </scope>
                <scope line="518"/>
                <scope line="523"/>
            </method>
            <method name="writeAppRecord" type="SSLEngineResult" line="527">
                <params>
                    <param name="ea" type="EngineArgs"/>
                </params>
                <declaration name="status" type="Status" line="528"/>
                <declaration name="hsStatus" type="HandshakeStatus" line="529"/>
                <scope line="531"/>
                <scope line="534">
                    <scope line="535">
                        <scope line="538"/>
                    </scope>
                </scope>
                <scope line="543"/>
                <scope line="546"/>
                <scope line="549">
                    <scope line="550"/>
                </scope>
                <scope line="554"/>
                <scope line="557">
                    <declaration name="ex" type="SSLException" line="558"/>
                </scope>
            </method>
            <method name="writeRecord" type="HandshakeStatus" line="566">
                <params>
                    <param name="eor" type="EngineOutputRecord"/>
                    <param name="ea" type="EngineArgs"/>
                </params>
                <declaration name="hsStatus" type="HandshakeStatus" line="567"/>
                <scope line="568">
                    <scope line="569"/>
                </scope>
            </method>
            <method name="writeRecord" type="void" line="575">
                <params>
                    <param name="eor" type="EngineOutputRecord"/>
                </params>
                <scope line="577"/>
            </method>
            <javadoc line="581">
                Check the sequence number state
                  RFC 4346 states that, &quot;Sequence numbers are of type uint64 and
                  may not exceed 2^64-1.  Sequence numbers do not wrap. If a TLS
                  implementation would need to wrap a sequence number, it must
                  renegotiate instead.&quot;
                  Return true if the handshake status may be changed.                
            </javadoc>
            <method name="checkSequenceNumber" type="boolean" line="589">
                <params>
                    <param name="mac" type="MAC"/>
                    <param name="type" type="byte"/>
                </params>
                <scope line="590"/>
                <scope line="593">
                    <scope line="594"/>
                </scope>
                <scope line="600">
                    <scope line="601"/>
                </scope>
            </method>
            <javadoc line="609">
                Signals that no more outbound application data will be sent
                  on this &lt;code&gt;SSLEngine&lt;/code&gt;.                
            </javadoc>
            <method name="closeOutboundInternal" type="void" line="613">
                <scope line="614"/>
                <scope line="617"/>
            </method>
            <method name="closeOutbound" type="void" line="636">
                <scope line="637"/>
            </method>
            <javadoc line="642">
                Returns the outbound application data closure state                
            </javadoc>
            <method name="isOutboundDone" type="boolean" line="645"/>
            <javadoc line="648">
                Signals that no more inbound network data will be sent
                  to this &lt;code&gt;SSLEngine&lt;/code&gt;.                
            </javadoc>
            <method name="closeInboundInternal" type="void" line="652">
                <scope line="653"/>
                <scope line="656"/>
            </method>
            <method name="closeInbound" type="void" line="664">
                <scope line="665"/>
                <scope line="668"/>
                <scope line="672"/>
            </method>
            <javadoc line="676">
                Returns the network inbound data closure state                
            </javadoc>
            <method name="isInboundDone" type="boolean" line="679"/>
            <javadoc line="682">
                Returns the current &lt;code&gt;SSLSession&lt;/code&gt; for this
                  &lt;code&gt;SSLEngine&lt;/code&gt;
                  &lt;P&gt;
                  These can be long lived, and frequently correspond to an
                  entire login session for some user.                
            </javadoc>
            <method name="getSession" type="SSLSession" line="689"/>
            <method name="getHandshakeSession" type="SSLSession" line="692"/>
            <method name="setHandshakeSession" type="void" line="695">
                <params>
                    <param name="session" type="SSLSessionImpl"/>
                </params>
            </method>
            <javadoc line="698">
                Returns a delegated &lt;code&gt;Runnable&lt;/code&gt; task for
                  this &lt;code&gt;SSLEngine&lt;/code&gt;.                
            </javadoc>
            <method name="getDelegatedTask" type="Runnable" line="702">
                <scope line="703"/>
            </method>
            <method name="warning" type="void" line="708">
                <params>
                    <param name="description" type="byte"/>
                </params>
            </method>
            <method name="fatal" type="void" line="711">
                <params>
                    <param name="description" type="byte"/>
                    <param name="diagnostic" type="String"/>
                </params>
            </method>
            <method name="fatal" type="void" line="714">
                <params>
                    <param name="description" type="byte"/>
                    <param name="cause" type="Throwable"/>
                </params>
            </method>
            <method name="fatal" type="void" line="717">
                <params>
                    <param name="description" type="byte"/>
                    <param name="diagnostic" type="String"/>
                    <param name="cause" type="Throwable"/>
                </params>
                <scope line="718"/>
                <scope line="721"/>
                <scope line="724">
                    <scope line="725"/>
                    <scope line="728"/>
                    <scope line="731"/>
                    <scope line="734">
                        <declaration name="ssle" type="SSLException" line="735"/>
                    </scope>
                </scope>
                <scope line="740"/>
                <declaration name="oldState" type="int" line="743"/>
                <scope line="747"/>
                <scope line="750"/>
                <scope line="753"/>
                <scope line="756"/>
                <scope line="763"/>
                <scope line="766"/>
            </method>
            <method name="recvAlert" type="void" line="770">
                <declaration name="level" type="byte" line="771"/>
                <declaration name="description" type="byte" line="772"/>
                <scope line="773"/>
                <scope line="776">
                    <scope line="777">
                        <scope line="780"/>
                        <scope line="783"/>
                        <scope line="786"/>
                    </scope>
                </scope>
                <scope line="792">
                    <scope line="793">
                        <scope line="794"/>
                        <scope line="797"/>
                    </scope>
                    <scope line="802">
                        <scope line="803"/>
                    </scope>
                </scope>
                <scope line="808">
                    <declaration name="reason" type="String" line="809"/>
                    <scope line="810"/>
                </scope>
            </method>
            <method name="sendAlert" type="void" line="816">
                <params>
                    <param name="level" type="byte"/>
                    <param name="description" type="byte"/>
                </params>
                <scope line="817"/>
                <scope line="820"/>
                <declaration name="r" type="EngineOutputRecord" line="823"/>
                <declaration name="useDebug" type="boolean" line="825"/>
                <scope line="826">
                    <scope line="827">
                        <scope line="830"/>
                        <scope line="833"/>
                        <scope line="836"/>
                    </scope>
                </scope>
                <scope line="844"/>
                <scope line="847">
                    <scope line="848"/>
                </scope>
            </method>
            <javadoc line="853">
                Controls whether new connections may cause creation of new SSL
                  sessions.
                  As long as handshaking has not started, we can change
                  whether we enable session creations.  Otherwise,
                  we will need to wait for the next handshake.                
            </javadoc>
            <method name="setEnableSessionCreation" type="void" line="860">
                <params>
                    <param name="flag" type="boolean"/>
                </params>
                <scope line="862"/>
            </method>
            <javadoc line="866">
                Returns true if new connections may cause creation of new SSL
                  sessions.                
            </javadoc>
            <method name="getEnableSessionCreation" type="boolean" line="870"/>
            <javadoc line="873">
                Sets the flag controlling whether a server mode engine
                  REQUIRES SSL client authentication.
                  As long as handshaking has not started, we can change
                  whether client authentication is needed.  Otherwise,
                  we will need to wait for the next handshake.                
            </javadoc>
            <method name="setNeedClientAuth" type="void" line="880">
                <params>
                    <param name="flag" type="boolean"/>
                </params>
                <scope line="882"/>
            </method>
            <method name="getNeedClientAuth" type="boolean" line="886"/>
            <javadoc line="889">
                Sets the flag controlling whether a server mode engine
                  REQUESTS SSL client authentication.
                  As long as handshaking has not started, we can change
                  whether client authentication is requested.  Otherwise,
                  we will need to wait for the next handshake.                
            </javadoc>
            <method name="setWantClientAuth" type="void" line="896">
                <params>
                    <param name="flag" type="boolean"/>
                </params>
                <scope line="898"/>
            </method>
            <method name="getWantClientAuth" type="boolean" line="902"/>
            <javadoc line="905">
                Sets the flag controlling whether the engine is in SSL
                  client or server mode.  Must be called before any SSL
                  traffic has started.                
            </javadoc>
            <method name="setUseClientMode" type="void" line="910">
                <params>
                    <param name="flag" type="boolean"/>
                </params>
                <scope line="913"/>
                <scope line="921">
                    <scope line="922"/>
                </scope>
                <scope line="931"/>
            </method>
            <method name="getUseClientMode" type="boolean" line="937"/>
            <javadoc line="940">
                Returns the names of the cipher suites which could be enabled for use
                  on an SSL connection.  Normally, only a subset of these will actually
                  be enabled by default, since this list may include cipher suites which
                  do not support the mutual authentication of servers and clients, or
                  which do not protect data confidentiality.  Servers may also need
                  certain kinds of certificates to use certain cipher suites.                
                <return>
                    an array of cipher suite names                    
                </return>
            </javadoc>
            <method name="getSupportedCipherSuites" type="String[]" line="949"/>
            <javadoc line="952">
                Controls which particular cipher suites are enabled for use on
                  this connection.  The cipher suites must have been listed by
                  getCipherSuites() as being supported.  Even if a suite has been
                  enabled, it might never be used if no peer supports it or the
                  requisite certificates (and private keys) are not available.                
                <param>
                    suites Names of all the cipher suites to enable.                    
                </param>
            </javadoc>
            <method name="setEnabledCipherSuites" type="void" line="960">
                <params>
                    <param name="suites" type="String[]"/>
                </params>
                <scope line="962"/>
            </method>
            <javadoc line="966">
                Returns the names of the SSL cipher suites which are currently enabled
                  for use on this connection.  When an SSL engine is first created,
                  all enabled cipher suites &lt;em&gt;(a)&lt;/em&gt; protect data confidentiality,
                  by traffic encryption, and &lt;em&gt;(b)&lt;/em&gt; can mutually authenticate
                  both clients and servers.  Thus, in some environments, this value
                  might be empty.                
                <return>
                    an array of cipher suite names                    
                </return>
            </javadoc>
            <method name="getEnabledCipherSuites" type="String[]" line="975"/>
            <javadoc line="978">
                Returns the protocols that are supported by this implementation.
                  A subset of the supported protocols may be enabled for this connection                
                <return>
                    an array of protocol names.                    
                </return>
            </javadoc>
            <method name="getSupportedProtocols" type="String[]" line="983"/>
            <javadoc line="986">
                Controls which protocols are enabled for use on
                  this connection.  The protocols must have been listed by
                  getSupportedProtocols() as being supported.                
                <param>
                    protocols protocols to enable.                    
                </param>
                <exception>
                    IllegalArgumentException when one of the protocols
                      named by the parameter is not supported.                    
                </exception>
            </javadoc>
            <method name="setEnabledProtocols" type="void" line="994">
                <params>
                    <param name="protocols" type="String[]"/>
                </params>
                <scope line="996"/>
            </method>
            <method name="getEnabledProtocols" type="String[]" line="1000"/>
            <javadoc line="1003">
                Returns the SSLParameters in effect for this SSLEngine.                
            </javadoc>
            <method name="getSSLParameters" type="SSLParameters" line="1006">
                <declaration name="params" type="SSLParameters" line="1007"/>
            </method>
            <javadoc line="1012">
                Applies SSLParameters to this engine.                
            </javadoc>
            <method name="setSSLParameters" type="void" line="1015">
                <params>
                    <param name="params" type="SSLParameters"/>
                </params>
                <scope line="1019"/>
            </method>
            <javadoc line="1024">
                Return the name of the current thread. Utility method.                
            </javadoc>
            <method name="threadName" type="String" line="1027"/>
            <javadoc line="1030">
                Returns a printable representation of this end of the connection.                
            </javadoc>
            <method name="toString" type="String" line="1033">
                <declaration name="retval" type="StringBuilder" line="1034"/>
                <declaration name="host" type="String" line="1038"/>
            </method>
        </class>
    </source>