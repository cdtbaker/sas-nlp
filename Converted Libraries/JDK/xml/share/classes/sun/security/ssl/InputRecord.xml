<?xml version="1.0" encoding="UTF-8"?>
    <source package="sun.security.ssl">
        <import package="java.io"/>
        <import package="java.nio"/>
        <import package="java.net.SocketException"/>
        <import package="java.net.SocketTimeoutException"/>
        <import package="javax.crypto.BadPaddingException"/>
        <import package="javax.net.ssl"/>
        <import package="sun.misc.HexDumpEncoder"/>
        <class name="InputRecord" line="41">
            <extends class="ByteArrayInputStream"/>
            <comment line="62">
                SSLv2 ruled out?                
            </comment>
            <comment line="66">
                The ClientHello version to accept. If set to ProtocolVersion.SSL20Hello                
            </comment>
            <comment line="67">
                and the first message we read is a ClientHello in V2 format, we convert                
            </comment>
            <comment line="68">
                it to V3. Otherwise we throw an exception when encountering a V2 hello.                
            </comment>
            <comment line="71">
                                
            </comment>
            <comment line="74">
                                
            </comment>
            <comment line="77">
                                
            </comment>
            <comment line="80">
                Construct the record to hold the maximum sized input record.
                 Data will be filled in separately.                
            </comment>
            <comment line="102">
                Enable format checks if initial handshaking hasn&apos;t completed                
            </comment>
            <comment line="109">
                return whether the data in this record is valid, decrypted data                
            </comment>
            <comment line="118">
                Return the content type of the record.                
            </comment>
            <comment line="125">
                For handshaking, we need to be able to hash every byte above the
                 record marking layer.  This is where we&apos;re guaranteed to see those
                 bytes, so this is where we can hash them ... especially in the
                 case of hashing the initial V2 message!                
            </comment>
            <comment line="139">
                Verify and remove the MAC ... used for all records.                
            </comment>
            <comment line="177">
                Well ... hello_request messages are _never_ hashed since we can&apos;t
                 know when they&apos;d appear in the sequence.                
            </comment>
            <comment line="188">
                We hash the (plaintext) we&apos;ve processed, but only on demand.
                
                 There is one place where we want to access the hash in the middle
                 of a record:  client cert message gets hashed, and part of the
                 same record is the client cert verify message which uses that hash.
                 So we track how much we&apos;ve read and hashed.                
            </comment>
            <comment line="205">
                Need a helper function so we can hash the V2 hello correctly                
            </comment>
            <comment line="223">
                Handshake messages may cross record boundaries.  We &quot;queue&quot;
                 these in big buffers if we need to cope with this problem.
                 This is not anticipated to be a common case; if this turns
                 out to be wrong, this can readily be sped up.                
            </comment>
            <comment line="298">
                We may need to send this SSL v2 &quot;No Cipher&quot; message back, if we
                 are faced with an SSLv2 &quot;hello&quot; that&apos;s not saying &quot;I talk v3&quot;.
                 It&apos;s the only one documented in the V2 spec as a fatal error.                
            </comment>
            <comment line="336">
                Read the SSL V3 record ... first time around, check to see if it
                 really IS a V3 record.  Handle SSL V2 clients which can talk V3.0,
                 as well as real V3 record format; otherwise report an error.                
            </comment>
            <comment line="551">
                Actually do the write here.  For SSLEngine&apos;s HS data,
                 we&apos;ll override this method and let it take the appropriate
                 action.                
            </comment>
            <comment line="562">
                Support &quot;old&quot; clients which are capable of SSL V3.0 protocol ... for
                 example, Navigator 3.0 clients.  The V2 message is in the header and
                 the bytes passed as parameter.  This routine translates the V2 message
                 into an equivalent V3 one.                
            </comment>
            <implements interface="Record"/>
            <javadoc line="41">
                SSL 3.0 records, as pulled off a TCP stream.  Input records are
                  basically buffers tied to a particular input stream ... a layer
                  above this must map these records into the model of a continuous
                  stream of data.
                  Since this returns SSL 3.0 records, it&apos;s the layer that needs to
                  map SSL 2.0 style handshake records into SSL 3.0 ones for those
                  &quot;old&quot; clients that interop with both V2 and V3 servers.  Not as
                  pretty as might be desired.
                  NOTE:  During handshaking, each message must be hashed to support
                  verification that the handshake process wasn&apos;t compromised.                
                <author>
                    David Brownell                    
                </author>
            </javadoc>
            <declaration name="handshakeHash" type="HandshakeHash" line="59"/>
            <declaration name="lastHashed" type="int" line="60"/>
            <declaration name="formatVerified" type="boolean" line="61"/>
            <declaration name="isClosed" type="boolean" line="62"/>
            <declaration name="appDataValid" type="boolean" line="63"/>
            <declaration name="helloVersion" type="ProtocolVersion" line="68"/>
            <declaration name="debug" type="Debug" line="71"/>
            <declaration name="exlen" type="int" line="74"/>
            <declaration name="v2Buf" type="byte" line="77"/>
            <method name="InputRecord" type="constructor" line="83"/>
            <method name="setHelloVersion" type="void" line="93">
                <params>
                    <param name="helloVersion" type="ProtocolVersion"/>
                </params>
            </method>
            <method name="getHelloVersion" type="ProtocolVersion" line="97"/>
            <method name="enableFormatChecks" type="void" line="104"/>
            <method name="isAppDataValid" type="boolean" line="109"/>
            <method name="setAppDataValid" type="void" line="113">
                <params>
                    <param name="value" type="boolean"/>
                </params>
            </method>
            <method name="contentType" type="byte" line="120"/>
            <method name="setHandshakeHash" type="void" line="130">
                <params>
                    <param name="handshakeHash" type="HandshakeHash"/>
                </params>
            </method>
            <method name="getHandshakeHash" type="HandshakeHash" line="134"/>
            <method name="checkMAC" type="boolean" line="141">
                <params>
                    <param name="signer" type="MAC"/>
                </params>
                <comment line="143">
                    no mac                    
                </comment>
                <comment line="150">
                    data length would be negative, something is wrong                    
                </comment>
                <declaration name="len" type="int" line="142"/>
                <scope line="143"/>
                <declaration name="offset" type="int" line="147"/>
                <scope line="149"/>
                <declaration name="mac" type="byte[]" line="154"/>
                <scope line="157"/>
                <scope line="161">
                    <scope line="162"/>
                </scope>
            </method>
            <method name="decrypt" type="void" line="170">
                <params>
                    <param name="box" type="CipherBox"/>
                </params>
                <declaration name="len" type="int" line="171"/>
            </method>
            <method name="ignore" type="void" line="180">
                <params>
                    <param name="bytes" type="int"/>
                </params>
                <scope line="181"/>
            </method>
            <method name="doHashes" type="void" line="195">
                <declaration name="len" type="int" line="196"/>
                <scope line="198"/>
            </method>
            <method name="hashInternal" type="void" line="207">
                <params>
                    <param name="databuf" type="byte"/>
                    <param name="offset" type="int"/>
                    <param name="len" type="int"/>
                </params>
                <scope line="208">
                    <scope line="209">
                        <declaration name="hd" type="HexDumpEncoder" line="210"/>
                    </scope>
                    <scope line="216"/>
                </scope>
            </method>
            <method name="queueHandshake" type="void" line="228">
                <params>
                    <param name="r" type="InputRecord"/>
                </params>
                <comment line="231">
                    Hash any data that&apos;s read but unhashed.                    
                </comment>
                <comment line="236">
                    Move any unread data to the front of the buffer,
                     flagging it all as unhashed.                    
                </comment>
                <comment line="250">
                    Grow &quot;buf&quot; if needed                    
                </comment>
                <comment line="262">
                    Append the new buffer to this one.                    
                </comment>
                <comment line="268">
                    Adjust lastHashed; important for now with clients which
                     send SSL V2 client hellos.  This will go away eventually,
                     by buffer code cleanup.                    
                </comment>
                <comment line="279">
                    we&apos;ve read the record, advance the pointers                    
                </comment>
                <declaration name="len" type="int" line="229"/>
                <scope line="240">
                    <scope line="242"/>
                </scope>
                <scope line="254">
                    <declaration name="newbuf" type="byte" line="255"/>
                </scope>
                <scope line="274"/>
                <scope line="276"/>
            </method>
            <javadoc line="284">
                Prevent any more data from being read into this record,
                  and flag the record as holding no data.                
            </javadoc>
            <method name="close" type="void" line="288"/>
            <declaration name="v2NoCipher" type="byte[]" line="302"/>
            <method name="readFully" type="int" line="309">
                <params>
                    <param name="s" type="InputStream"/>
                    <param name="b" type="byte"/>
                    <param name="off" type="int"/>
                    <param name="len" type="int"/>
                </params>
                <declaration name="n" type="int" line="310"/>
                <scope line="311">
                    <declaration name="readLen" type="int" line="312"/>
                    <scope line="313"/>
                    <scope line="317">
                        <scope line="318">
                            <declaration name="hd" type="HexDumpEncoder" line="319"/>
                            <declaration name="bb" type="ByteBuffer" line="320"/>
                        </scope>
                        <scope line="325"/>
                    </scope>
                </scope>
            </method>
            <method name="read" type="void" line="340">
                <params>
                    <param name="s" type="InputStream"/>
                    <param name="o" type="OutputStream"/>
                </params>
                <comment line="345">
                    For SSL it really _is_ an error if the other end went away
                     so ungracefully as to not shut down cleanly.                    
                </comment>
                <comment line="360">
                    The first record might use some other record marking convention,
                     typically SSL v2 header.  (PCT could also be detected here.)
                     This case is currently common -- Navigator 3.0 usually works
                     this way, as do IE 3.0 and other products.                    
                </comment>
                <comment line="368">
                    The first record must either be a handshake record or an
                     alert message. If it&apos;s not, it is either invalid or an
                     SSLv2 message.                    
                </comment>
                <comment line="378">
                    formatVerified == true                    
                </comment>
                <scope line="341"/>
                <scope line="349">
                    <declaration name="really" type="int" line="350"/>
                    <scope line="351"/>
                </scope>
                <scope line="366">
                    <scope line="373"/>
                    <scope line="375"/>
                </scope>
                <scope line="378"/>
            </method>
            <javadoc line="383">
                Read a SSL/TLS record. Throw an IOException if the format is invalid.                
            </javadoc>
            <method name="readV3Record" type="void" line="387">
                <params>
                    <param name="s" type="InputStream"/>
                    <param name="o" type="OutputStream"/>
                </params>
                <comment line="389">
                    Check if too old (currently not possible)                    
                </comment>
                <comment line="390">
                    or if the major version does not match.                    
                </comment>
                <comment line="391">
                    The actual version negotiation is in the handshaker classes                    
                </comment>
                <comment line="398">
                    Get and check length, then the data.                    
                </comment>
                <comment line="403">
                    Check for upper bound.                    
                </comment>
                <comment line="412">
                    Grow &quot;buf&quot; if needed. Since buf is maxRecordSize by default,
                     this only occurs when we receive records which violate the
                     SSL specification. This is a workaround for a Microsoft SSL bug.                    
                </comment>
                <comment line="431">
                    now we&apos;ve got a complete record.                    
                </comment>
                <comment line="444">
                    then caller decrypts, verifies, and uncompresses                    
                </comment>
                <declaration name="recordVersion" type="ProtocolVersion" line="388"/>
                <scope line="393"/>
                <declaration name="contentLen" type="int" line="401"/>
                <scope line="406"/>
                <scope line="417">
                    <declaration name="newbuf" type="byte[]" line="418"/>
                </scope>
                <scope line="423">
                    <declaration name="really" type="int" line="424"/>
                    <scope line="426"/>
                </scope>
                <scope line="435">
                    <scope line="436"/>
                </scope>
            </method>
            <javadoc line="449">
                Deal with unknown records. Called if the first data we read on this
                  connection does not look like an SSL/TLS record. It could a SSLv2
                  message, or just garbage.                
            </javadoc>
            <method name="handleUnknownRecord" type="void" line="455">
                <params>
                    <param name="s" type="InputStream"/>
                    <param name="o" type="OutputStream"/>
                </params>
                <comment line="456">
                    No?  Oh well; does it look like a V2 &quot;ClientHello&quot;?
                     That&apos;d be an unpadded handshake message; we don&apos;t
                     bother checking length just now.                    
                </comment>
                <comment line="462">
                    if the user has disabled SSLv2Hello (using
                     setEnabledProtocol) then throw an
                     exception                    
                </comment>
                <comment line="475">
                    Looks like a V2 client hello, but not one saying
                     &quot;let&apos;s talk SSLv3&quot;.  So we send an SSLv2 error
                     message, one that&apos;s treated as fatal by clients.
                     (Otherwise we&apos;ll hang.)                    
                </comment>
                <comment line="484">
                                        
                </comment>
                <comment line="489">
                    If we can map this into a V3 ClientHello, read and
                     hash the rest of the V2 handshake, turn it into a
                     V3 ClientHello message, and pass it up.                    
                </comment>
                <comment line="507">
                    now we&apos;ve got a complete record.                    
                </comment>
                <comment line="526">
                    Does it look like a V2 &quot;ServerHello&quot;?                    
                </comment>
                <comment line="534">
                    If this is a V2 NoCipher message then this means
                     the other server doesn&apos;t support V3. Otherwise, we just
                     don&apos;t understand what it&apos;s saying.                    
                </comment>
                <scope line="461">
                    <scope line="467"/>
                    <declaration name="recordVersion" type="ProtocolVersion" line="471"/>
                    <scope line="474">
                        <scope line="481"/>
                        <scope line="483"/>
                    </scope>
                    <declaration name="len" type="int" line="494"/>
                    <scope line="496"/>
                    <scope line="499">
                        <declaration name="really" type="int" line="500"/>
                        <scope line="502"/>
                    </scope>
                    <scope line="516"/>
                </scope>
                <scope line="525">
                    <scope line="529"/>
                    <scope line="539">
                        <scope line="540"/>
                    </scope>
                </scope>
            </method>
            <method name="writeBuffer" type="void" line="556">
                <params>
                    <param name="s" type="OutputStream"/>
                    <param name="buf" type="byte[]"/>
                    <param name="off" type="int"/>
                    <param name="len" type="int"/>
                </params>
            </method>
            <method name="V2toV3ClientHello" type="void" line="568">
                <params>
                    <param name="v2Msg" type="byte"/>
                </params>
                <comment line="571">
                    Build the first part of the V3 record header from the V2 one
                     that&apos;s now buffered up.  (Lengths are fixed up later).                    
                </comment>
                <comment line="576">
                    V3.x                    
                </comment>
                <comment line="578">
                    header [3..4] for handshake message length                    
                </comment>
                <comment line="579">
                    count = 5;                    
                </comment>
                <comment line="581">
                    Store the generic V3 handshake header:  4 bytes                    
                </comment>
                <comment line="584">
                    HandshakeMessage.ht_client_hello                    
                </comment>
                <comment line="585">
                    buf [6..8] for length of ClientHello (int24)                    
                </comment>
                <comment line="586">
                    count += 4;                    
                </comment>
                <comment line="588">
                    ClientHello header starts with SSL version                    
                </comment>
                <comment line="593">
                    count += 2;                    
                </comment>
                <comment line="596">
                    Start parsing the V2 message ...                    
                </comment>
                <comment line="605">
                    Copy Random valuenonce ... if less than the 32 bytes of
                     a V3 &quot;Random&quot;, right justify and zero pad to the left.  Else
                     just take the last 32 bytes.                    
                </comment>
                <comment line="623">
                    Copy Session ID (only one byte length!)                    
                </comment>
                <comment line="632">
                    Copy and translate cipher suites ... V2 specs with first byte zero
                     are really V3 specs (in the last 2 bytes), just copy those and drop
                     the other ones.  Preference order remains unchanged.
                    
                     Example:  Netscape Navigator 3.0 (exportable) says:
                    
                     03,     SSL_RSA_EXPORT_WITH_RC4_40_MD5
                     06,     SSL_RSA_EXPORT_WITH_RC2_CBC_40_MD5
                    
                     Microsoft Internet Explorer 3.0 (exportable) supports only
                    
                     03,     SSL_RSA_EXPORT_WITH_RC4_40_MD5                    
                </comment>
                <comment line="663">
                    Append compression methods (defaultnull only)                    
                </comment>
                <comment line="667">
                    Session.compression_null                    
                </comment>
                <comment line="669">
                    Fill in lengths of the messages we synthesized (nested:
                     V3 handshake message within V3 record) and then return                    
                </comment>
                <declaration name="i" type="int" line="569"/>
                <declaration name="cipherSpecLen" type="int" line="599"/>
                <declaration name="offset" type="int" line="610"/>
                <scope line="612"/>
                <scope line="617"/>
                <declaration name="j" type="int" line="646"/>
                <scope line="651"/>
            </method>
            <javadoc line="683">
                Return a description for the given content type. This method should be
                  in Record, but since that is an interface this is not possible.
                  Called from InputRecord and OutputRecord.                
            </javadoc>
            <method name="contentName" type="String" line="688">
                <params>
                    <param name="contentType" type="int"/>
                </params>
            </method>
        </class>
    </source>