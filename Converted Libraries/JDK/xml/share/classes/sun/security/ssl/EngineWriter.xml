<?xml version="1.0" encoding="UTF-8"?>
    <source package="sun.security.ssl">
        <import package="javax.net.ssl"/>
        <import package="java.io.IOException"/>
        <import package="java.nio.ByteBuffer"/>
        <import package="java.util.LinkedList"/>
        <import package="javax.net.ssl.SSLEngineResult.HandshakeStatus"/>
        <import package="sun.misc.HexDumpEncoder"/>
        <class name="EngineWriter" line="35">
            <comment line="41">
                Outgoing handshake Data waiting for a ride is stored here.
                 Normal application data is written directly into the outbound
                 buffer, but handshake data can be written out at any time,
                 so we have buffer it somewhere.
                
                 When wrap is called, we first check to see if there is
                 any data waiting, then if we&apos;re in a data transfer state,
                 we try to write app data.
                
                 This will contain either ByteBuffers, or the marker
                 HandshakeStatus.FINISHED to signify that a handshake just completed.                
            </comment>
            <comment line="58">
                                
            </comment>
            <comment line="65">
                Upper levels assured us we had room for at least one packet of data.
                 As per the SSLEngine spec, we only return one SSL packets worth of
                 data.                
            </comment>
            <comment line="98">
                Properly orders the output of the data written to the wrap call.
                 This is only handshake data, application data goes through the
                 other writeRecord.                
            </comment>
            <comment line="126">
                Output the packet info.                
            </comment>
            <comment line="146">
                Properly orders the output of the data written to the wrap call.
                 Only app data goes through here, handshake data goes through
                 the other writeRecord.
                
                 Shouldn&apos;t expect to have an IOException here.
                
                 Return any determined status.                
            </comment>
            <comment line="201">
                We already hold &quot;this&quot; lock, this is the callback from the
                 outputRecord.write() above.  We already know this
                 writer can accept more data (outboundClosed == false),
                 and the closure is sync&apos;d.                
            </comment>
            <comment line="211">
                This is for the really rare case that someone is writing from
                 the InputRecord before we know what to do with it.                
            </comment>
            <comment line="225">
                Non-synch&apos;d version of this method, called by internals                
            </comment>
            <javadoc line="35">
                A class to help abstract away SSLEngine writing synchronization.                
            </javadoc>
            <declaration name="outboundList" type="LinkedList&lt;Object&gt;" line="53"/>
            <declaration name="outboundClosed" type="boolean" line="55"/>
            <declaration name="debug" type="Debug" line="58"/>
            <method name="EngineWriter" type="constructor" line="60"/>
            <method name="getOutboundData" type="HandshakeStatus" line="69">
                <params>
                    <param name="dstBB" type="ByteBuffer"/>
                </params>
                <comment line="79">
                    If we have more data in the queue, it&apos;s either
                     a finished message, or an indication that we need
                     to call wrap again.                    
                </comment>
                <comment line="87">
                    consume the message                    
                </comment>
                <declaration name="msg" type="Object" line="71"/>
                <declaration name="bbIn" type="ByteBuffer" line="74"/>
                <scope line="84">
                    <scope line="86"/>
                    <scope line="89"/>
                </scope>
                <scope line="92"/>
            </method>
            <method name="writeRecord" type="void" line="103">
                <params>
                    <param name="outputRecord" type="EngineOutputRecord"/>
                    <param name="writeMAC" type="MAC"/>
                    <param name="writeCipher" type="CipherBox"/>
                </params>
                <comment line="105">
                    Only output if we&apos;re still open.                    
                </comment>
                <comment line="114">
                    Did our handshakers notify that we just sent the
                     Finished message?
                    
                     Add an &quot;I&apos;m finished&quot; message to the queue.                    
                </comment>
                <scope line="108"/>
                <scope line="120"/>
            </method>
            <method name="dumpPacket" type="void" line="128">
                <params>
                    <param name="ea" type="EngineArgs"/>
                    <param name="hsData" type="boolean"/>
                </params>
                <scope line="129">
                    <declaration name="hd" type="HexDumpEncoder" line="130"/>
                    <declaration name="bb" type="ByteBuffer" line="132"/>
                    <declaration name="pos" type="int" line="134"/>
                </scope>
                <scope line="142"/>
            </method>
            <method name="writeRecord" type="HandshakeStatus" line="156">
                <params>
                    <param name="outputRecord" type="EngineOutputRecord"/>
                    <param name="ea" type="EngineArgs"/>
                    <param name="writeMAC" type="MAC"/>
                    <param name="writeCipher" type="CipherBox"/>
                </params>
                <comment line="158">
                    If we have data ready to go, output this first before
                     trying to consume app data.                    
                </comment>
                <comment line="166">
                    We could have put the dump in
                     OutputRecord.write(OutputStream), but let&apos;s actually
                     output when it&apos;s actually output by the SSLEngine.                    
                </comment>
                <comment line="177">
                    If we are closed, no more app data can be output.
                     Only existing handshake data (above) can be obtained.                    
                </comment>
                <comment line="191">
                    No way new outbound handshake data got here if we&apos;re
                     locked properly.
                    
                     We don&apos;t have any status we can return.                    
                </comment>
                <scope line="162">
                    <declaration name="hss" type="HandshakeStatus" line="163"/>
                    <scope line="165"/>
                </scope>
                <scope line="181"/>
                <scope line="187"/>
            </method>
            <method name="putOutboundData" type="void" line="206">
                <params>
                    <param name="bytes" type="ByteBuffer"/>
                </params>
            </method>
            <method name="putOutboundDataSync" type="void" line="215">
                <params>
                    <param name="bytes" type="ByteBuffer"/>
                </params>
                <scope line="217"/>
            </method>
            <method name="hasOutboundDataInternal" type="boolean" line="227"/>
            <method name="hasOutboundData" type="boolean" line="231"/>
            <method name="isOutboundDone" type="boolean" line="235"/>
            <method name="closeOutbound" type="void" line="239"/>
        </class>
    </source>