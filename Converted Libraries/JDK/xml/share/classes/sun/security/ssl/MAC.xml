<?xml version="1.0" encoding="UTF-8"?>
    <source package="sun.security.ssl">
        <import package="java.security.InvalidKeyException"/>
        <import package="java.security.NoSuchAlgorithmException"/>
        <import package="java.nio.ByteBuffer"/>
        <import package="javax.crypto.Mac"/>
        <import package="javax.crypto.SecretKey"/>
        <import package="sun.security.ssl.CipherSuite.MacAlg"/>
        <import package="sun.security.ssl.CipherSuite"/>
        <class name="MAC" line="40">
            <comment line="59">
                Value of the null MAC is fixed                
            </comment>
            <comment line="62">
                internal identifier for the MAC algorithm                
            </comment>
            <comment line="65">
                stuff defined by the kind of MAC algorithm                
            </comment>
            <comment line="68">
                JCE Mac object                
            </comment>
            <comment line="71">
                byte array containing the additional information we MAC in each record
                 (see below)                
            </comment>
            <comment line="75">
                sequence number + record type + + record length                
            </comment>
            <comment line="78">
                sequence number + record type + protocol version + record length                
            </comment>
            <comment line="81">
                offset of record type in block                
            </comment>
            <comment line="84">
                offset of protocol version number in block (TLS only)                
            </comment>
            <comment line="182">
                Check whether to renew the sequence number
                
                 Sequence numbers are of type uint64 and may not exceed 2^64-1.
                 Sequence numbers do not wrap.  If a TLS
                 implementation would need to wrap a sequence number, it must
                 renegotiate instead.                
            </comment>
            <comment line="199">
                increment the sequence number in the block array
                 it is a 64-bit number stored in big-endian format                
            </comment>
            <comment line="208">
                Compute based on either buffer type, either bb.positionlimit
                 or bufoffsetlen.                
            </comment>
            <javadoc line="40">
                This class computes the &quot;Message Authentication Code&quot; (MAC) for each
                  SSL message.  This is essentially a shared-secret signature, used to
                  provide integrity protection for SSL messages.  The MAC is actually
                  one of several keyed hashes, as associated with the cipher suite and
                  protocol version.  (SSL v3.0 uses one construct, TLS uses another.)
                  &lt;P&gt;NOTE: MAC computation is the only place in the SSL protocol that the
                  sequence number is used.  It&apos;s also reset to zero with each change of
                  a cipher spec, so this is the only place this state is needed.                
                <author>
                    David Brownell                    
                </author>
                <author>
                    Andreas Sterbenz                    
                </author>
            </javadoc>
            <declaration name="NULL" type="MAC" line="56"/>
            <declaration name="nullMAC" type="byte" line="59"/>
            <declaration name="macAlg" type="MacAlg" line="62"/>
            <declaration name="macSize" type="int" line="65"/>
            <declaration name="mac" type="Mac" line="68"/>
            <declaration name="block" type="byte[]" line="72"/>
            <declaration name="BLOCK_SIZE_SSL" type="int" line="75"/>
            <declaration name="BLOCK_SIZE_TLS" type="int" line="78"/>
            <declaration name="BLOCK_OFFSET_TYPE" type="int" line="81"/>
            <declaration name="BLOCK_OFFSET_VERSION" type="int" line="84"/>
            <method name="MAC" type="constructor" line="86"/>
            <javadoc line="93">
                Set up, configured for the given SSL/TLS MAC type and version.                
            </javadoc>
            <method name="MAC" type="constructor" line="97">
                <params>
                    <param name="macAlg" type="MacAlg"/>
                    <param name="protocolVersion" type="ProtocolVersion"/>
                    <param name="key" type="SecretKey"/>
                </params>
                <comment line="110">
                    TLS 1.2+                    
                </comment>
                <comment line="112">
                    TLS 1.2+                    
                </comment>
                <declaration name="algorithm" type="String" line="101"/>
                <declaration name="tls" type="boolean" line="102"/>
                <scope line="104"/>
                <scope line="106"/>
                <scope line="108"/>
                <scope line="110"/>
                <scope line="112"/>
                <scope line="119"/>
                <scope line="123"/>
            </method>
            <javadoc line="128">
                Returns the length of the MAC.                
            </javadoc>
            <method name="MAClen" type="int" line="131"/>
            <javadoc line="135">
                Computes and returns the MAC for the data in this byte array.                
                <param>
                    type record type                    
                </param>
                <param>
                    buf compressed record on which the MAC is computed                    
                </param>
                <param>
                    offset start of compressed record data                    
                </param>
                <param>
                    len the size of the compressed record                    
                </param>
            </javadoc>
            <method name="compute" type="byte[]" line="143">
                <params>
                    <param name="type" type="byte"/>
                    <param name="buf" type="byte"/>
                    <param name="offset" type="int"/>
                    <param name="len" type="int"/>
                </params>
            </method>
            <javadoc line="147">
                Compute and returns the MAC for the remaining data
                  in this ByteBuffer.
                  On return, the bb position == limit, and limit will
                  have not changed.                
                <param>
                    type record type                    
                </param>
                <param>
                    bb a ByteBuffer in which the position and limit
                      demarcate the data to be MAC'd.                    
                </param>
            </javadoc>
            <method name="compute" type="byte[]" line="158">
                <params>
                    <param name="type" type="byte"/>
                    <param name="bb" type="ByteBuffer"/>
                </params>
            </method>
            <javadoc line="162">
                Check whether the sequence number is close to wrap
                  Sequence numbers are of type uint64 and may not exceed 2^64-1.
                  Sequence numbers do not wrap. When the sequence number is near
                  to wrap, we need to close the connection immediately.                
            </javadoc>
            <method name="seqNumOverflow" type="boolean" line="169">
                <comment line="171">
                    Conservatively, we don&apos;t allow more records to be generated
                     when there are only 2^8 sequence numbers left.                    
                </comment>
            </method>
            <method name="seqNumIsHuge" type="boolean" line="189">
                <comment line="191">
                    Conservatively, we should ask for renegotiation when there are
                     only 2^48 sequence numbers left.                    
                </comment>
            </method>
            <method name="incrementSequenceNumber" type="void" line="200">
                <declaration name="k" type="int" line="201"/>
                <scope line="202"/>
            </method>
            <method name="compute" type="byte[]" line="212">
                <params>
                    <param name="type" type="byte"/>
                    <param name="bb" type="ByteBuffer"/>
                    <param name="buf" type="byte[]"/>
                    <param name="offset" type="int"/>
                    <param name="len" type="int"/>
                </params>
                <comment line="226">
                    content                    
                </comment>
                <scope line="214"/>
                <scope line="226"/>
                <scope line="228"/>
            </method>
        </class>
    </source>