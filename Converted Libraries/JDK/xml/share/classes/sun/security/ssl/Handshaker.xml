<?xml version="1.0" encoding="UTF-8"?>
    <source package="sun.security.ssl">
        <import package="java.io"/>
        <import package="java.util"/>
        <import package="java.security"/>
        <import package="java.security.NoSuchAlgorithmException"/>
        <import package="java.security.AccessController"/>
        <import package="java.security.AlgorithmConstraints"/>
        <import package="java.security.AccessControlContext"/>
        <import package="java.security.PrivilegedExceptionAction"/>
        <import package="java.security.PrivilegedActionException"/>
        <import package="javax.crypto"/>
        <import package="javax.crypto.spec"/>
        <import package="javax.net.ssl"/>
        <import package="sun.misc.HexDumpEncoder"/>
        <import package="sun.security.internal.spec"/>
        <import package="sun.security.internal.interfaces.TlsMasterSecret"/>
        <import package="sun.security.ssl.HandshakeMessage"/>
        <import package="sun.security.ssl.CipherSuite"/>
        <import package="sun.security.ssl.CipherSuite.PRF"/>
        <class name="Handshaker" line="20">
            <javadoc line="20">
                Handshaker ... processes handshake records from an SSL V3.0
                  data stream, handling all the details of the handshake protocol.
                  Note that the real protocol work is done in two subclasses, the  base
                  class just provides the control flow and key generation framework.                
                <author>
                    David Brownell                    
                </author>
            </javadoc>
            <declaration name="protocolVersion" type="ProtocolVersion" line="28"/>
            <declaration name="activeProtocolVersion" type="ProtocolVersion" line="29"/>
            <declaration name="secureRenegotiation" type="boolean" line="30"/>
            <declaration name="clientVerifyData" type="byte[]" line="31"/>
            <declaration name="serverVerifyData" type="byte[]" line="32"/>
            <declaration name="isInitialHandshake" type="boolean" line="33"/>
            <declaration name="enabledProtocols" type="ProtocolList" line="34"/>
            <declaration name="enabledCipherSuites" type="CipherSuiteList" line="35"/>
            <declaration name="identificationProtocol" type="String" line="36"/>
            <declaration name="algorithmConstraints" type="AlgorithmConstraints" line="37"/>
            <declaration name="localSupportedSignAlgs" type="Collection&amp;lt;SignatureAndHashAlgorithm&amp;gt;" line="38"/>
            <declaration name="peerSupportedSignAlgs" type="Collection&amp;lt;SignatureAndHashAlgorithm&amp;gt;" line="39"/>
            <declaration name="activeProtocols" type="ProtocolList" line="40"/>
            <declaration name="activeCipherSuites" type="CipherSuiteList" line="41"/>
            <declaration name="isClient" type="boolean" line="42"/>
            <declaration name="needCertVerify" type="boolean" line="43"/>
            <declaration name="conn" type="SSLSocketImpl" line="44"/>
            <declaration name="engine" type="SSLEngineImpl" line="45"/>
            <declaration name="handshakeHash" type="HandshakeHash" line="46"/>
            <declaration name="input" type="HandshakeInStream" line="47"/>
            <declaration name="output" type="HandshakeOutStream" line="48"/>
            <declaration name="state" type="int" line="49"/>
            <declaration name="sslContext" type="SSLContextImpl" line="50"/>
            <declaration name="clnt_random" type="RandomCookie" line="51"/>
            <declaration name="session" type="SSLSessionImpl" line="52"/>
            <declaration name="cipherSuite" type="CipherSuite" line="53"/>
            <declaration name="keyExchange" type="KeyExchange" line="54"/>
            <declaration name="resumingSession" type="boolean" line="55"/>
            <declaration name="enableNewSession" type="boolean" line="56"/>
            <declaration name="clntWriteKey" type="SecretKey" line="57"/>
            <declaration name="clntWriteIV" type="IvParameterSpec" line="58"/>
            <declaration name="clntMacSecret" type="SecretKey" line="59"/>
            <declaration name="taskDelegated" type="boolean" line="60"/>
            <declaration name="delegatedTask" type="DelegatedTask" line="61"/>
            <declaration name="thrown" type="Exception" line="62"/>
            <declaration name="thrownLock" type="Object" line="63"/>
            <declaration name="debug" type="Debug" line="64"/>
            <declaration name="allowUnsafeRenegotiation" type="boolean" line="65"/>
            <declaration name="allowLegacyHelloMessages" type="boolean" line="66"/>
            <declaration name="invalidated" type="boolean" line="67"/>
            <method name="Handshaker" type="constructor" line="68">
                <params>
                    <param name="c" type="SSLSocketImpl"/>
                    <param name="context" type="SSLContextImpl"/>
                    <param name="enabledProtocols" type="ProtocolList"/>
                    <param name="needCertVerify" type="boolean"/>
                    <param name="isClient" type="boolean"/>
                    <param name="activeProtocolVersion" type="ProtocolVersion"/>
                    <param name="isInitialHandshake" type="boolean"/>
                    <param name="secureRenegotiation" type="boolean"/>
                    <param name="clientVerifyData" type="byte[]"/>
                    <param name="serverVerifyData" type="byte[]"/>
                </params>
            </method>
            <method name="Handshaker" type="constructor" line="72">
                <params>
                    <param name="engine" type="SSLEngineImpl"/>
                    <param name="context" type="SSLContextImpl"/>
                    <param name="enabledProtocols" type="ProtocolList"/>
                    <param name="needCertVerify" type="boolean"/>
                    <param name="isClient" type="boolean"/>
                    <param name="activeProtocolVersion" type="ProtocolVersion"/>
                    <param name="isInitialHandshake" type="boolean"/>
                    <param name="secureRenegotiation" type="boolean"/>
                    <param name="clientVerifyData" type="byte[]"/>
                    <param name="serverVerifyData" type="byte[]"/>
                </params>
            </method>
            <method name="init" type="void" line="76">
                <params>
                    <param name="context" type="SSLContextImpl"/>
                    <param name="enabledProtocols" type="ProtocolList"/>
                    <param name="needCertVerify" type="boolean"/>
                    <param name="isClient" type="boolean"/>
                    <param name="activeProtocolVersion" type="ProtocolVersion"/>
                    <param name="isInitialHandshake" type="boolean"/>
                    <param name="secureRenegotiation" type="boolean"/>
                    <param name="clientVerifyData" type="byte[]"/>
                    <param name="serverVerifyData" type="byte[]"/>
                </params>
                <scope line="77"/>
                <scope line="92"/>
                <scope line="95"/>
            </method>
            <method name="fatalSE" type="void" line="100">
                <params>
                    <param name="b" type="byte"/>
                    <param name="diagnostic" type="String"/>
                </params>
            </method>
            <method name="fatalSE" type="void" line="103">
                <params>
                    <param name="b" type="byte"/>
                    <param name="cause" type="Throwable"/>
                </params>
            </method>
            <method name="fatalSE" type="void" line="106">
                <params>
                    <param name="b" type="byte"/>
                    <param name="diagnostic" type="String"/>
                    <param name="cause" type="Throwable"/>
                </params>
                <scope line="107"/>
                <scope line="110"/>
            </method>
            <method name="warningSE" type="void" line="114">
                <params>
                    <param name="b" type="byte"/>
                </params>
                <scope line="115"/>
                <scope line="118"/>
            </method>
            <method name="getRawHostnameSE" type="String" line="122">
                <scope line="123"/>
                <scope line="126"/>
            </method>
            <method name="getHostSE" type="String" line="130">
                <scope line="131"/>
                <scope line="134"/>
            </method>
            <method name="getHostAddressSE" type="String" line="138">
                <scope line="139"/>
                <scope line="142"/>
            </method>
            <method name="isLoopbackSE" type="boolean" line="146">
                <scope line="147"/>
                <scope line="150"/>
            </method>
            <method name="getPortSE" type="int" line="154">
                <scope line="155"/>
                <scope line="158"/>
            </method>
            <method name="getLocalPortSE" type="int" line="162">
                <scope line="163"/>
                <scope line="166"/>
            </method>
            <method name="getAccSE" type="AccessControlContext" line="170">
                <scope line="171"/>
                <scope line="174"/>
            </method>
            <method name="setVersionSE" type="void" line="178">
                <params>
                    <param name="protocolVersion" type="ProtocolVersion"/>
                </params>
                <scope line="179"/>
                <scope line="182"/>
            </method>
            <javadoc line="186">
                Set the active protocol version and propagate it to the SSLSocket
                  and our handshake streams. Called from ClientHandshaker
                  and ServerHandshaker with the negotiated protocol version.                
            </javadoc>
            <method name="setVersion" type="void" line="191">
                <params>
                    <param name="protocolVersion" type="ProtocolVersion"/>
                </params>
            </method>
            <javadoc line="196">
                Set the enabled protocols. Called from the constructor or
                  SSLSocketImpl/SSLEngineImpl.setEnabledProtocols() (if the
                  handshake is not yet in progress).                
            </javadoc>
            <method name="setEnabledProtocols" type="void" line="201">
                <params>
                    <param name="enabledProtocols" type="ProtocolList"/>
                </params>
            </method>
            <javadoc line="206">
                Set the enabled cipher suites. Called from
                  SSLSocketImpl/SSLEngineImpl.setEnabledCipherSuites() (if the
                  handshake is not yet in progress).                
            </javadoc>
            <method name="setEnabledCipherSuites" type="void" line="211">
                <params>
                    <param name="enabledCipherSuites" type="CipherSuiteList"/>
                </params>
            </method>
            <javadoc line="216">
                Set the algorithm constraints. Called from the constructor or
                  SSLSocketImpl/SSLEngineImpl.setAlgorithmConstraints() (if the
                  handshake is not yet in progress).                
            </javadoc>
            <method name="setAlgorithmConstraints" type="void" line="221">
                <params>
                    <param name="algorithmConstraints" type="AlgorithmConstraints"/>
                </params>
            </method>
            <method name="getLocalSupportedSignAlgs" type="Collection&lt;SignatureAndHashAlgorithm&gt;" line="227">
                <scope line="228"/>
            </method>
            <method name="setPeerSupportedSignAlgs" type="void" line="233">
                <params>
                    <param name="algorithms" type="Collection&lt;SignatureAndHashAlgorithm&gt;"/>
                </params>
            </method>
            <method name="getPeerSupportedSignAlgs" type="Collection&lt;SignatureAndHashAlgorithm&gt;" line="236"/>
            <javadoc line="239">
                Set the identification protocol. Called from the constructor or
                  SSLSocketImpl/SSLEngineImpl.setIdentificationProtocol() (if the
                  handshake is not yet in progress).                
            </javadoc>
            <method name="setIdentificationProtocol" type="void" line="244">
                <params>
                    <param name="protocol" type="String"/>
                </params>
            </method>
            <javadoc line="247">
                Prior to handshaking, activate the handshake and initialize the version,
                  input stream and output stream.                
            </javadoc>
            <method name="activate" type="void" line="251">
                <params>
                    <param name="helloVersion" type="ProtocolVersion"/>
                </params>
                <scope line="252"/>
                <scope line="255"/>
                <scope line="258"/>
                <scope line="261"/>
                <scope line="264"/>
                <scope line="267"/>
                <scope line="270"/>
                <declaration name="localSupportedHashAlgorithms" type="Set&amp;lt;String&amp;gt;" line="273"/>
                <scope line="276"/>
                <scope line="282"/>
            </method>
            <javadoc line="290">
                Set cipherSuite and keyExchange to the given CipherSuite.
                  Does not perform any verification that this is a valid selection,
                  this must be done before calling this method.                
            </javadoc>
            <method name="setCipherSuite" type="void" line="295">
                <params>
                    <param name="s" type="CipherSuite"/>
                </params>
            </method>
            <javadoc line="299">
                Check if the given ciphersuite is enabled and available.
                  Does not check if the required server certificates are available.                
            </javadoc>
            <method name="isNegotiable" type="boolean" line="303">
                <params>
                    <param name="s" type="CipherSuite"/>
                </params>
                <scope line="304"/>
            </method>
            <javadoc line="309">
                Check if the given protocol version is enabled and available.                
            </javadoc>
            <method name="isNegotiable" type="boolean" line="312">
                <params>
                    <param name="protocolVersion" type="ProtocolVersion"/>
                </params>
                <scope line="313"/>
            </method>
            <javadoc line="318">
                Select a protocol version from the list. Called from
                  ServerHandshaker to negotiate protocol version.
                  Return the lower of the protocol version suggested in the
                  clien hello and the highest supported by the server.                
            </javadoc>
            <method name="selectProtocolVersion" type="ProtocolVersion" line="324">
                <params>
                    <param name="protocolVersion" type="ProtocolVersion"/>
                </params>
                <scope line="325"/>
            </method>
            <javadoc line="330">
                Get the active cipher suites.
                  In TLS 1.1, many weak or vulnerable cipher suites were obsoleted,
                  such as TLS_RSA_EXPORT_WITH_RC4_40_MD5. The implementation MUST NOT
                  negotiate these cipher suites in TLS 1.1 or later mode.
                  Therefore, when the active protocols only include TLS 1.1 or later,
                  the client cannot request to negotiate those obsoleted cipher
                  suites.  That is, the obsoleted suites should not be included in the
                  client hello. So we need to create a subset of the enabled cipher
                  suites, the active cipher suites, which does not contain obsoleted
                  cipher suites of the minimum active protocol.
                  Return empty list instead of null if no active cipher suites.                
            </javadoc>
            <method name="getActiveCipherSuites" type="CipherSuiteList" line="343">
                <scope line="344">
                    <scope line="345"/>
                    <declaration name="suites" type="ArrayList&amp;lt;CipherSuite&amp;gt;" line="348"/>
                    <scope line="349">
                        <scope line="350">
                            <scope line="351">
                                <scope line="352"/>
                            </scope>
                            <scope line="356">
                                <scope line="357"/>
                                <scope line="360"/>
                            </scope>
                        </scope>
                    </scope>
                </scope>
            </method>
            <method name="getActiveProtocols" type="ProtocolList" line="370">
                <scope line="371">
                    <declaration name="protocols" type="ArrayList&amp;lt;ProtocolVersion&amp;gt;" line="372"/>
                    <scope line="373">
                        <declaration name="found" type="boolean" line="374"/>
                        <scope line="375">
                            <scope line="376">
                                <scope line="377"/>
                                <scope line="382"/>
                            </scope>
                            <scope line="386"/>
                        </scope>
                        <scope line="390"/>
                    </scope>
                </scope>
            </method>
            <javadoc line="398">
                As long as handshaking has not activated, we can
                  change whether session creations are allowed.
                  Callers should do their own checking if handshaking
                  has activated.                
            </javadoc>
            <method name="setEnableSessionCreation" type="void" line="404">
                <params>
                    <param name="newSessions" type="boolean"/>
                </params>
            </method>
            <javadoc line="407">
                Create a new read cipher and return it to caller.                
            </javadoc>
            <method name="newReadCipher" type="CipherBox" line="410">
                <declaration name="cipher" type="BulkCipher" line="411"/>
                <declaration name="box" type="CipherBox" line="412"/>
                <scope line="413"/>
                <scope line="418"/>
            </method>
            <javadoc line="425">
                Create a new write cipher and return it to caller.                
            </javadoc>
            <method name="newWriteCipher" type="CipherBox" line="428">
                <declaration name="cipher" type="BulkCipher" line="429"/>
                <declaration name="box" type="CipherBox" line="430"/>
                <scope line="431"/>
                <scope line="436"/>
            </method>
            <javadoc line="443">
                Create a new read MAC and return it to caller.                
            </javadoc>
            <method name="newReadMAC" type="MAC" line="446">
                <declaration name="macAlg" type="MacAlg" line="447"/>
                <declaration name="mac" type="MAC" line="448"/>
                <scope line="449"/>
                <scope line="453"/>
            </method>
            <javadoc line="459">
                Create a new write MAC and return it to caller.                
            </javadoc>
            <method name="newWriteMAC" type="MAC" line="462">
                <declaration name="macAlg" type="MacAlg" line="463"/>
                <declaration name="mac" type="MAC" line="464"/>
                <scope line="465"/>
                <scope line="469"/>
            </method>
            <method name="isDone" type="boolean" line="475"/>
            <method name="getSession" type="SSLSessionImpl" line="478"/>
            <method name="setHandshakeSessionSE" type="void" line="481">
                <params>
                    <param name="handshakeSession" type="SSLSessionImpl"/>
                </params>
                <scope line="482"/>
                <scope line="485"/>
            </method>
            <method name="isSecureRenegotiation" type="boolean" line="489"/>
            <method name="getClientVerifyData" type="byte[]" line="492"/>
            <method name="getServerVerifyData" type="byte[]" line="495"/>
            <method name="process_record" type="void" line="498">
                <params>
                    <param name="r" type="InputRecord"/>
                    <param name="expectingFinished" type="boolean"/>
                </params>
                <scope line="501"/>
                <scope line="504">
                    <anonymous_class line="505">
                        <method name="run" type="Void" line="506"/>
                    </anonymous_class>
                </scope>
            </method>
            <method name="processLoop" type="void" line="514">
                <scope line="515">
                    <declaration name="messageType" type="byte" line="516"/>
                    <declaration name="messageLen" type="int" line="517"/>
                    <scope line="521"/>
                    <scope line="525"/>
                    <scope line="530"/>
                </scope>
            </method>
            <javadoc line="537">
                Returns true iff the handshaker has been activated.
                  In activated state, the handshaker may not send any messages out.                
            </javadoc>
            <method name="activated" type="boolean" line="541"/>
            <javadoc line="544">
                Returns true iff the handshaker has sent any messages.                
            </javadoc>
            <method name="started" type="boolean" line="547"/>
            <method name="kickstart" type="void" line="550">
                <scope line="551"/>
                <declaration name="m" type="HandshakeMessage" line="554"/>
                <scope line="555"/>
            </method>
            <method name="getKickstartMessage" type="HandshakeMessage" line="562"/>
            <javadoc line="562">
                Both client and server modes can start handshaking; but the
                  message they send to do so is different.                
            </javadoc>
            <method name="processMessage" type="void" line="567"/>
            <method name="handshakeAlert" type="void" line="568"/>
            <method name="sendChangeCipherSpec" type="void" line="569">
                <params>
                    <param name="mesg" type="Finished"/>
                    <param name="lastMessage" type="boolean"/>
                </params>
                <declaration name="r" type="OutputRecord" line="571"/>
                <scope line="572"/>
                <scope line="575"/>
                <scope line="580">
                    <scope line="582">
                        <scope line="585"/>
                    </scope>
                    <scope line="591"/>
                </scope>
                <scope line="595">
                    <scope line="596">
                        <scope line="599"/>
                        <scope line="603"/>
                    </scope>
                </scope>
            </method>
            <method name="calculateKeys" type="void" line="610">
                <params>
                    <param name="preMasterSecret" type="SecretKey"/>
                    <param name="version" type="ProtocolVersion"/>
                </params>
                <declaration name="master" type="SecretKey" line="611"/>
            </method>
            <method name="calculateMasterSecret" type="SecretKey" line="615">
                <params>
                    <param name="preMasterSecret" type="SecretKey"/>
                    <param name="requestedVersion" type="ProtocolVersion"/>
                </params>
                <scope line="616">
                    <declaration name="dump" type="HexDumpEncoder" line="617"/>
                </scope>
                <declaration name="masterAlg" type="String" line="622"/>
                <declaration name="prf" type="PRF" line="623"/>
                <scope line="624"/>
                <scope line="628"/>
                <declaration name="prfHashAlg" type="String" line="632"/>
                <declaration name="prfHashLength" type="int" line="633"/>
                <declaration name="prfBlockSize" type="int" line="634"/>
                <declaration name="spec" type="TlsMasterSecretParameterSpec" line="635"/>
                <declaration name="masterSecret" type="SecretKey" line="636"/>
                <scope line="637">
                    <declaration name="kg" type="KeyGenerator" line="638"/>
                </scope>
                <scope line="642">
                    <scope line="643"/>
                    <scope line="646"/>
                    <scope line="651"/>
                    <scope line="654"/>
                </scope>
                <scope line="659"/>
                <declaration name="tlsKey" type="TlsMasterSecret" line="662"/>
                <declaration name="major" type="int" line="663"/>
                <declaration name="minor" type="int" line="664"/>
                <scope line="665"/>
                <declaration name="premasterVersion" type="ProtocolVersion" line="668"/>
                <declaration name="versionMismatch" type="boolean" line="669"/>
                <scope line="670"/>
                <scope line="673"/>
                <scope line="676"/>
            </method>
            <method name="calculateConnectionKeys" type="void" line="683">
                <params>
                    <param name="masterKey" type="SecretKey"/>
                </params>
                <declaration name="hashSize" type="int" line="684"/>
                <declaration name="is_exportable" type="boolean" line="685"/>
                <declaration name="cipher" type="BulkCipher" line="686"/>
                <declaration name="expandedKeySize" type="int" line="687"/>
                <declaration name="keyMaterialAlg" type="String" line="688"/>
                <declaration name="prf" type="PRF" line="689"/>
                <scope line="690"/>
                <scope line="694"/>
                <declaration name="prfHashAlg" type="String" line="698"/>
                <declaration name="prfHashLength" type="int" line="699"/>
                <declaration name="prfBlockSize" type="int" line="700"/>
                <declaration name="spec" type="TlsKeyMaterialParameterSpec" line="701"/>
                <scope line="702">
                    <declaration name="kg" type="KeyGenerator" line="703"/>
                    <declaration name="keySpec" type="TlsKeyMaterialSpec" line="705"/>
                </scope>
                <scope line="713"/>
                <scope line="716">
                    <scope line="717">
                        <declaration name="dump" type="HexDumpEncoder" line="718"/>
                        <scope line="730"/>
                        <scope line="736"/>
                        <scope line="739"/>
                        <scope line="745">
                            <scope line="746"/>
                            <scope line="749"/>
                        </scope>
                    </scope>
                </scope>
            </method>
            <method name="printHex" type="void" line="757">
                <params>
                    <param name="dump" type="HexDumpEncoder"/>
                    <param name="bytes" type="byte[]"/>
                </params>
                <scope line="758"/>
                <scope line="761">
                    <scope line="762"/>
                    <scope line="765"/>
                </scope>
            </method>
            <javadoc line="769">
                Throw an SSLException with the specified message and cause.
                  Shorthand until a new SSLException constructor is added.
                  This method never returns.                
            </javadoc>
            <method name="throwSSLException" type="void" line="774">
                <params>
                    <param name="msg" type="String"/>
                    <param name="cause" type="Throwable"/>
                </params>
                <declaration name="e" type="SSLException" line="775"/>
            </method>
            <class name="DelegatedTask" line="779">
                <type_params>
                    <type_param name="E"/>
                </type_params>
                <implements interface="Runnable"/>
                <declaration name="pea" type="PrivilegedExceptionAction&amp;lt;E&amp;gt;" line="780"/>
                <method name="DelegatedTask" type="constructor" line="781">
                    <params>
                        <param name="pea" type="PrivilegedExceptionAction&lt;E&gt;"/>
                    </params>
                </method>
                <method name="run" type="void" line="784">
                    <scope line="785">
                        <scope line="786"/>
                        <scope line="789"/>
                        <scope line="792"/>
                    </scope>
                </method>
            </class>
            <method name="delegateTask" type="void" line="800">
                <params>
                    <param name="pea" type="PrivilegedExceptionAction&lt;T&gt;"/>
                </params>
            </method>
            <method name="getTask" type="DelegatedTask" line="805">
                <scope line="806"/>
                <scope line="810"/>
            </method>
            <method name="taskOutstanding" type="boolean" line="814"/>
            <method name="checkThrown" type="void" line="817">
                <scope line="818">
                    <scope line="819">
                        <declaration name="msg" type="String" line="820"/>
                        <scope line="821"/>
                        <declaration name="e" type="Exception" line="824"/>
                        <scope line="826"/>
                        <scope line="829"/>
                        <scope line="832"/>
                        <scope line="835"/>
                        <scope line="838"/>
                        <scope line="841"/>
                    </scope>
                </scope>
            </method>
        </class>
    </source>