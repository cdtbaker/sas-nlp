<?xml version="1.0" encoding="UTF-8"?>
    <source package="sun.security.ssl">
        <import package="java.io"/>
        <import package="java.util"/>
        <import package="java.security"/>
        <import package="java.security.NoSuchAlgorithmException"/>
        <import package="java.security.AccessController"/>
        <import package="java.security.AlgorithmConstraints"/>
        <import package="java.security.AccessControlContext"/>
        <import package="java.security.PrivilegedExceptionAction"/>
        <import package="java.security.PrivilegedActionException"/>
        <import package="javax.crypto"/>
        <import package="javax.crypto.spec"/>
        <import package="javax.net.ssl"/>
        <import package="sun.misc.HexDumpEncoder"/>
        <import package="sun.security.internal.spec"/>
        <import package="sun.security.internal.interfaces.TlsMasterSecret"/>
        <import package="sun.security.ssl.HandshakeMessage"/>
        <import package="sun.security.ssl.CipherSuite"/>
        <import package="sun.security.ssl.CipherSuite.PRF"/>
        <class name="Handshaker" line="53">
            <comment line="65">
                protocol version being established using this Handshaker                
            </comment>
            <comment line="68">
                the currently active protocol version during a renegotiation                
            </comment>
            <comment line="71">
                security parameters for secure renegotiation.                
            </comment>
            <comment line="76">
                Is it an initial negotiation  or a renegotiation?                
            </comment>
            <comment line="79">
                List of enabled protocols                
            </comment>
            <comment line="82">
                List of enabled CipherSuites                
            </comment>
            <comment line="85">
                The endpoint identification protocol                
            </comment>
            <comment line="88">
                The cryptographic algorithm constraints                
            </comment>
            <comment line="91">
                Local supported signature and algorithms                
            </comment>
            <comment line="94">
                Peer supported signature and algorithms                
            </comment>
            <comment line="97">
                List of active protocols
                
                 Active protocols is a subset of enabled protocols, and will
                 contain only those protocols that have vaild cipher suites
                 enabled.                
            </comment>
            <comment line="108">
                List of active cipher suites
                
                 Active cipher suites is a subset of enabled cipher suites, and will
                 contain only those cipher suites available for the active protocols.                
            </comment>
            <comment line="130">
                current CipherSuite. Never null, initially SSL_NULL_WITH_NULL_NULL                
            </comment>
            <comment line="133">
                current key exchange. Never null, initially K_NULL                
            </comment>
            <comment line="136">
                                
            </comment>
            <comment line="139">
                                
            </comment>
            <comment line="142">
                Temporary storage for the individual keys. Set by
                 calculateConnectionKeys() and cleared once the ciphers are
                 activated.                
            </comment>
            <comment line="149">
                Delegated task subsystem data structures.
                
                 If thrown is set, we need to propagate this back immediately
                 on entry into processMessage().
                
                 Data is protected by the SSLEngine.this lock.                
            </comment>
            <comment line="161">
                Could probably use a java.util.concurrent.atomic.AtomicReference
                 here instead of using this lock.  Consider changing.                
            </comment>
            <comment line="165">
                                
            </comment>
            <comment line="168">
                By default, disable the unsafe legacy session renegotiation                
            </comment>
            <comment line="172">
                For maximum interoperability and backward compatibility, RFC 5746
                 allows server (or client) to accept ClientHello (or ServerHello)
                 message without the secure renegotiation_info extension or SCSV.
                
                 For maximum security, RFC 5746 also allows server (or client) to
                 reject such message with a fatal &quot;handshake_failure&quot; alert.
                
                 By default, allow such legacy hello messages.                
            </comment>
            <comment line="183">
                need to dispose the object when it is invalidated                
            </comment>
            <comment line="259">
                Reroutes calls to the SSLSocket or SSLEngine (SE).
                
                 We could have also done it by extra classes
                 and letting them override, but this seemed much
                 less involved.                
            </comment>
            <comment line="601">
                Get the active protocol versions.
                
                 In TLS 1.1, many weak or vulnerable cipher suites were obsoleted,
                 such as TLS_RSA_EXPORT_WITH_RC4_40_MD5. The implementation MUST NOT
                 negotiate these cipher suites in TLS 1.1 or later mode.
                
                 For example, if &quot;TLS_RSA_EXPORT_WITH_RC4_40_MD5&quot; is the
                 only enabled cipher suite, the client cannot request TLS 1.1 or
                 later, even though TLS 1.1 or later is enabled.  We need to create a
                 subset of the enabled protocols, called the active protocols, which
                 contains protocols appropriate to the list of enabled Ciphersuites.
                
                 Return empty list instead of null if no active protocol versions.                
            </comment>
            <comment line="735">
                Returns true iff the handshake sequence is done, so that
                 this freshly created session can become the current one.                
            </comment>
            <comment line="744">
                Returns the session which was created through this
                 handshake sequence ... should be called after isDone()
                 returns true.                
            </comment>
            <comment line="753">
                Set the handshake session                
            </comment>
            <comment line="764">
                Returns true if renegotiation is in use for this connection.                
            </comment>
            <comment line="771">
                Returns the verify_data from the Finished message sent by the client.                
            </comment>
            <comment line="778">
                Returns the verify_data from the Finished message sent by the server.                
            </comment>
            <comment line="785">
                This routine is fed SSL handshake records when they become available,
                 and processes messages found therein.                
            </comment>
            <comment line="816">
                On input, we hash messages one at a time since servers may need
                 to access an intermediate hash to validate a CertificateVerify
                 message.
                
                 Note that many handshake messages can come in one record (and often
                 do, to reduce network resource utilization), and one message can also
                 require multiple records (e.g. very large Certificate messages).                
            </comment>
            <comment line="894">
                Used to kickstart the negotiation ... either writing a
                 ClientHello or a HelloRequest as appropriate, whichever
                 the subclass returns.  NOP if handshaking&apos;s already started.                
            </comment>
            <comment line="921">
                Client and Server side protocols are each driven though this
                 call, which processes a single message and drives the appropriate
                 side of the protocol state machine (depending on the subclass).                
            </comment>
            <comment line="929">
                Most alerts in the protocol relate to handshaking problems.
                 Alerts are detected as the connection reads data.                
            </comment>
            <comment line="935">
                Sends a change cipher spec message and updates the write side
                 cipher state so that future messages use the just-negotiated spec.                
            </comment>
            <comment line="994">
                Single access point to key calculation logic.  Given the
                 pre-master secret and the nonces from client and server,
                 produce all the keying material to be used.                
            </comment>
            <comment line="1006">
                Calculate the master secret from its various components.  This is
                 used for key exchange by all cipher suites.
                
                 The master secret is the catenation of three MD5 hashes, each
                 consisting of the pre-master secret and a SHA1 hash.  Those three
                 SHA1 hashes are of (different) constant strings, the pre-master
                 secret, and the nonces provided by the client and the server.                
            </comment>
            <comment line="1143">
                Calculate the keys needed for this connection, once the session&apos;s
                 master secret has been calculated.  Uses the master key and nonces;
                 the amount of keying material generated is a function of the cipher
                 suite that&apos;s been negotiated.
                
                 This gets called both on the &quot;full handshake&quot; (where we exchanged
                 a premaster secret and started a new session) as well as on the
                 &quot;fast handshake&quot; (where we just resumed a pre-existing session).                
            </comment>
            <comment line="1283">
                Implement a simple task delegator.
                
                 We are currently implementing this as a single delegator, may
                 try for parallel tasks later.  Client Authentication could
                 benefit from this, where ClientKeyExchangeCertificateVerify
                 could be carried out in parallel.                
            </comment>
            <comment line="1329">
                See if there are any tasks which need to be delegated
                
                 Locked by SSLEngine.this.                
            </comment>
            <comment line="1338">
                The previous caller failed for some reason, report back the
                 Exception.  We won&apos;t worry about Error&apos;s.
                
                 Locked by SSLEngine.this.                
            </comment>
            <javadoc line="53">
                Handshaker ... processes handshake records from an SSL V3.0
                  data stream, handling all the details of the handshake protocol.
                  Note that the real protocol work is done in two subclasses, the  base
                  class just provides the control flow and key generation framework.                
                <author>
                    David Brownell                    
                </author>
            </javadoc>
            <declaration name="protocolVersion" type="ProtocolVersion" line="65"/>
            <declaration name="activeProtocolVersion" type="ProtocolVersion" line="68"/>
            <declaration name="secureRenegotiation" type="boolean" line="71"/>
            <declaration name="clientVerifyData" type="byte[]" line="72"/>
            <declaration name="serverVerifyData" type="byte[]" line="73"/>
            <declaration name="isInitialHandshake" type="boolean" line="76"/>
            <declaration name="enabledProtocols" type="ProtocolList" line="79"/>
            <declaration name="enabledCipherSuites" type="CipherSuiteList" line="82"/>
            <declaration name="identificationProtocol" type="String" line="85"/>
            <declaration name="algorithmConstraints" type="AlgorithmConstraints" line="88"/>
            <declaration name="localSupportedSignAlgs" type="Collection&lt;SignatureAndHashAlgorithm&gt;" line="91"/>
            <declaration name="peerSupportedSignAlgs" type="Collection&lt;SignatureAndHashAlgorithm&gt;" line="94"/>
            <declaration name="activeProtocols" type="ProtocolList" line="105"/>
            <declaration name="activeCipherSuites" type="CipherSuiteList" line="113"/>
            <declaration name="isClient" type="boolean" line="115"/>
            <declaration name="needCertVerify" type="boolean" line="116"/>
            <declaration name="conn" type="SSLSocketImpl" line="118"/>
            <declaration name="engine" type="SSLEngineImpl" line="119"/>
            <declaration name="handshakeHash" type="HandshakeHash" line="121"/>
            <declaration name="input" type="HandshakeInStream" line="122"/>
            <declaration name="output" type="HandshakeOutStream" line="123"/>
            <declaration name="state" type="int" line="124"/>
            <declaration name="sslContext" type="SSLContextImpl" line="125"/>
            <declaration name="clnt_random" type="RandomCookie" line="126"/>
            <declaration name="session" type="SSLSessionImpl" line="127"/>
            <declaration name="cipherSuite" type="CipherSuite" line="130"/>
            <declaration name="keyExchange" type="KeyExchange" line="133"/>
            <declaration name="resumingSession" type="boolean" line="136"/>
            <declaration name="enableNewSession" type="boolean" line="139"/>
            <declaration name="clntWriteKey" type="SecretKey" line="144"/>
            <declaration name="clntWriteIV" type="IvParameterSpec" line="145"/>
            <declaration name="clntMacSecret" type="SecretKey" line="146"/>
            <declaration name="taskDelegated" type="boolean" line="156"/>
            <declaration name="delegatedTask" type="DelegatedTask" line="157"/>
            <declaration name="thrown" type="Exception" line="158"/>
            <declaration name="thrownLock" type="Object" line="162"/>
            <declaration name="debug" type="Debug" line="165"/>
            <declaration name="allowUnsafeRenegotiation" type="boolean" line="168"/>
            <declaration name="allowLegacyHelloMessages" type="boolean" line="179"/>
            <declaration name="invalidated" type="boolean" line="183"/>
            <method name="Handshaker" type="constructor" line="189">
                <params>
                    <param name="c" type="SSLSocketImpl"/>
                    <param name="context" type="SSLContextImpl"/>
                    <param name="enabledProtocols" type="ProtocolList"/>
                    <param name="needCertVerify" type="boolean"/>
                    <param name="isClient" type="boolean"/>
                    <param name="activeProtocolVersion" type="ProtocolVersion"/>
                    <param name="isInitialHandshake" type="boolean"/>
                    <param name="secureRenegotiation" type="boolean"/>
                    <param name="clientVerifyData" type="byte[]"/>
                    <param name="serverVerifyData" type="byte[]"/>
                </params>
            </method>
            <method name="Handshaker" type="constructor" line="200">
                <params>
                    <param name="engine" type="SSLEngineImpl"/>
                    <param name="context" type="SSLContextImpl"/>
                    <param name="enabledProtocols" type="ProtocolList"/>
                    <param name="needCertVerify" type="boolean"/>
                    <param name="isClient" type="boolean"/>
                    <param name="activeProtocolVersion" type="ProtocolVersion"/>
                    <param name="isInitialHandshake" type="boolean"/>
                    <param name="secureRenegotiation" type="boolean"/>
                    <param name="clientVerifyData" type="byte[]"/>
                    <param name="serverVerifyData" type="byte[]"/>
                </params>
            </method>
            <method name="init" type="void" line="211">
                <params>
                    <param name="context" type="SSLContextImpl"/>
                    <param name="enabledProtocols" type="ProtocolList"/>
                    <param name="needCertVerify" type="boolean"/>
                    <param name="isClient" type="boolean"/>
                    <param name="activeProtocolVersion" type="ProtocolVersion"/>
                    <param name="isInitialHandshake" type="boolean"/>
                    <param name="secureRenegotiation" type="boolean"/>
                    <param name="clientVerifyData" type="byte[]"/>
                    <param name="serverVerifyData" type="byte[]"/>
                </params>
                <comment line="238">
                    engine != null                    
                </comment>
                <comment line="243">
                    In addition to the connection state machine, controlling
                     how the connection deals with the different sorts of records
                     that get sent (notably handshake transitions!), there&apos;s
                     also a handshaking state machine that controls message
                     sequencing.
                    
                     It&apos;s a convenient artifact of the protocol that this can,
                     with only a couple of minor exceptions, be driven by the
                     type constant for the last message seen:  except for the
                     client&apos;s cert verify, those constants are in a convenient
                     order to drastically simplify state machine checking.                    
                </comment>
                <comment line="256">
                    initialized but not activated                    
                </comment>
                <scope line="213"/>
                <scope line="235"/>
                <scope line="237"/>
            </method>
            <method name="fatalSE" type="void" line="265">
                <params>
                    <param name="b" type="byte"/>
                    <param name="diagnostic" type="String"/>
                </params>
            </method>
            <method name="fatalSE" type="void" line="269">
                <params>
                    <param name="b" type="byte"/>
                    <param name="cause" type="Throwable"/>
                </params>
            </method>
            <method name="fatalSE" type="void" line="274">
                <params>
                    <param name="b" type="byte"/>
                    <param name="diagnostic" type="String"/>
                    <param name="cause" type="Throwable"/>
                </params>
                <scope line="275"/>
                <scope line="277"/>
            </method>
            <method name="warningSE" type="void" line="282">
                <params>
                    <param name="b" type="byte"/>
                </params>
                <scope line="283"/>
                <scope line="285"/>
            </method>
            <method name="getRawHostnameSE" type="String" line="290">
                <scope line="291"/>
                <scope line="293"/>
            </method>
            <method name="getHostSE" type="String" line="298">
                <scope line="299"/>
                <scope line="301"/>
            </method>
            <method name="getHostAddressSE" type="String" line="306">
                <comment line="311">
                    This is for caching only, doesn&apos;t matter that&apos;s is really
                     a hostname.  The main thing is that it doesn&apos;t do
                     a reverse DNS lookup, potentially slowing things down.                    
                </comment>
                <scope line="307"/>
                <scope line="309"/>
            </method>
            <method name="isLoopbackSE" type="boolean" line="319">
                <scope line="320"/>
                <scope line="322"/>
            </method>
            <method name="getPortSE" type="int" line="327">
                <scope line="328"/>
                <scope line="330"/>
            </method>
            <method name="getLocalPortSE" type="int" line="335">
                <scope line="336"/>
                <scope line="338"/>
            </method>
            <method name="getAccSE" type="AccessControlContext" line="343">
                <scope line="344"/>
                <scope line="346"/>
            </method>
            <method name="setVersionSE" type="void" line="351">
                <params>
                    <param name="protocolVersion" type="ProtocolVersion"/>
                </params>
                <scope line="352"/>
                <scope line="354"/>
            </method>
            <javadoc line="359">
                Set the active protocol version and propagate it to the SSLSocket
                  and our handshake streams. Called from ClientHandshaker
                  and ServerHandshaker with the negotiated protocol version.                
            </javadoc>
            <method name="setVersion" type="void" line="364">
                <params>
                    <param name="protocolVersion" type="ProtocolVersion"/>
                </params>
            </method>
            <javadoc line="371">
                Set the enabled protocols. Called from the constructor or
                  SSLSocketImpl/SSLEngineImpl.setEnabledProtocols() (if the
                  handshake is not yet in progress).                
            </javadoc>
            <method name="setEnabledProtocols" type="void" line="376">
                <params>
                    <param name="enabledProtocols" type="ProtocolList"/>
                </params>
            </method>
            <javadoc line="383">
                Set the enabled cipher suites. Called from
                  SSLSocketImpl/SSLEngineImpl.setEnabledCipherSuites() (if the
                  handshake is not yet in progress).                
            </javadoc>
            <method name="setEnabledCipherSuites" type="void" line="388">
                <params>
                    <param name="enabledCipherSuites" type="CipherSuiteList"/>
                </params>
            </method>
            <javadoc line="394">
                Set the algorithm constraints. Called from the constructor or
                  SSLSocketImpl/SSLEngineImpl.setAlgorithmConstraints() (if the
                  handshake is not yet in progress).                
            </javadoc>
            <method name="setAlgorithmConstraints" type="void" line="399">
                <params>
                    <param name="algorithmConstraints" type="AlgorithmConstraints"/>
                </params>
            </method>
            <method name="getLocalSupportedSignAlgs" type="Collection<SignatureAndHashAlgorithm>" line="408">
                <scope line="409"/>
            </method>
            <method name="setPeerSupportedSignAlgs" type="void" line="419">
                <params>
                    <param name="algorithms" type="Collection<SignatureAndHashAlgorithm>"/>
                </params>
            </method>
            <method name="getPeerSupportedSignAlgs" type="Collection<SignatureAndHashAlgorithm>" line="424"/>
            <javadoc line="429">
                Set the identification protocol. Called from the constructor or
                  SSLSocketImpl/SSLEngineImpl.setIdentificationProtocol() (if the
                  handshake is not yet in progress).                
            </javadoc>
            <method name="setIdentificationProtocol" type="void" line="434">
                <params>
                    <param name="protocol" type="String"/>
                </params>
            </method>
            <javadoc line="438">
                Prior to handshaking, activate the handshake and initialize the version,
                  input stream and output stream.                
            </javadoc>
            <method name="activate" type="void" line="442">
                <params>
                    <param name="helloVersion" type="ProtocolVersion"/>
                </params>
                <comment line="461">
                    temporary protocol version until the actual protocol version
                     is negotiated in the Hello exchange. This affects the record
                     version we sent with the ClientHello.                    
                </comment>
                <comment line="474">
                    We accumulate digests of the handshake messages so that
                     we can read/write CertificateVerify and Finished messages,
                     getting assurance against some particular active attacks.                    
                </comment>
                <comment line="483">
                    Generate handshake input/output stream.                    
                </comment>
                <comment line="499">
                    move state to activated                    
                </comment>
                <scope line="443"/>
                <scope line="448"/>
                <scope line="452"/>
                <scope line="456"/>
                <scope line="463"/>
                <scope line="465"/>
                <scope line="469"/>
                <declaration name="localSupportedHashAlgorithms" type="Set&lt;String&gt;" line="476"/>
                <scope line="484"/>
                <scope line="490"/>
            </method>
            <javadoc line="502">
                Set cipherSuite and keyExchange to the given CipherSuite.
                  Does not perform any verification that this is a valid selection,
                  this must be done before calling this method.                
            </javadoc>
            <method name="setCipherSuite" type="void" line="507">
                <params>
                    <param name="s" type="CipherSuite"/>
                </params>
            </method>
            <javadoc line="512">
                Check if the given ciphersuite is enabled and available.
                  Does not check if the required server certificates are available.                
            </javadoc>
            <method name="isNegotiable" type="boolean" line="516">
                <params>
                    <param name="s" type="CipherSuite"/>
                </params>
                <scope line="517"/>
            </method>
            <javadoc line="524">
                Check if the given protocol version is enabled and available.                
            </javadoc>
            <method name="isNegotiable" type="boolean" line="527">
                <params>
                    <param name="protocolVersion" type="ProtocolVersion"/>
                </params>
                <scope line="528"/>
            </method>
            <javadoc line="535">
                Select a protocol version from the list. Called from
                  ServerHandshaker to negotiate protocol version.
                  Return the lower of the protocol version suggested in the
                  clien hello and the highest supported by the server.                
            </javadoc>
            <method name="selectProtocolVersion" type="ProtocolVersion" line="542">
                <params>
                    <param name="protocolVersion" type="ProtocolVersion"/>
                </params>
                <scope line="543"/>
            </method>
            <javadoc line="550">
                Get the active cipher suites.
                  In TLS 1.1, many weak or vulnerable cipher suites were obsoleted,
                  such as TLS_RSA_EXPORT_WITH_RC4_40_MD5. The implementation MUST NOT
                  negotiate these cipher suites in TLS 1.1 or later mode.
                  Therefore, when the active protocols only include TLS 1.1 or later,
                  the client cannot request to negotiate those obsoleted cipher
                  suites.  That is, the obsoleted suites should not be included in the
                  client hello. So we need to create a subset of the enabled cipher
                  suites, the active cipher suites, which does not contain obsoleted
                  cipher suites of the minimum active protocol.
                  Return empty list instead of null if no active cipher suites.                
            </javadoc>
            <method name="getActiveCipherSuites" type="CipherSuiteList" line="566">
                <scope line="567">
                    <scope line="568"/>
                    <declaration name="suites" type="ArrayList&lt;CipherSuite&gt;" line="572"/>
                    <scope line="574">
                        <scope line="575">
                            <scope line="577">
                                <scope line="580"/>
                            </scope>
                            <scope line="583">
                                <scope line="584"/>
                                <scope line="587"/>
                            </scope>
                        </scope>
                    </scope>
                </scope>
            </method>
            <method name="getActiveProtocols" type="ProtocolList" line="615">
                <scope line="616">
                    <declaration name="protocols" type="ArrayList&lt;ProtocolVersion&gt;" line="617"/>
                    <scope line="618">
                        <declaration name="found" type="boolean" line="619"/>
                        <scope line="620">
                            <scope line="622">
                                <scope line="625"/>
                                <scope line="629"/>
                            </scope>
                            <scope line="634"/>
                        </scope>
                        <scope line="640"/>
                    </scope>
                </scope>
            </method>
            <javadoc line="651">
                As long as handshaking has not activated, we can
                  change whether session creations are allowed.
                  Callers should do their own checking if handshaking
                  has activated.                
            </javadoc>
            <method name="setEnableSessionCreation" type="void" line="658">
                <params>
                    <param name="newSessions" type="boolean"/>
                </params>
            </method>
            <javadoc line="662">
                Create a new read cipher and return it to caller.                
            </javadoc>
            <method name="newReadCipher" type="CipherBox" line="665">
                <declaration name="cipher" type="BulkCipher" line="666"/>
                <declaration name="box" type="CipherBox" line="667"/>
                <scope line="668"/>
                <scope line="673"/>
            </method>
            <javadoc line="682">
                Create a new write cipher and return it to caller.                
            </javadoc>
            <method name="newWriteCipher" type="CipherBox" line="685">
                <declaration name="cipher" type="BulkCipher" line="686"/>
                <declaration name="box" type="CipherBox" line="687"/>
                <scope line="688"/>
                <scope line="693"/>
            </method>
            <javadoc line="702">
                Create a new read MAC and return it to caller.                
            </javadoc>
            <method name="newReadMAC" type="MAC" line="705">
                <declaration name="macAlg" type="MacAlg" line="706"/>
                <declaration name="mac" type="MAC" line="707"/>
                <scope line="708"/>
                <scope line="711"/>
            </method>
            <javadoc line="718">
                Create a new write MAC and return it to caller.                
            </javadoc>
            <method name="newWriteMAC" type="MAC" line="721">
                <declaration name="macAlg" type="MacAlg" line="722"/>
                <declaration name="mac" type="MAC" line="723"/>
                <scope line="724"/>
                <scope line="727"/>
            </method>
            <method name="isDone" type="boolean" line="738"/>
            <method name="getSession" type="SSLSessionImpl" line="748"/>
            <method name="setHandshakeSessionSE" type="void" line="755">
                <params>
                    <param name="handshakeSession" type="SSLSessionImpl"/>
                </params>
                <scope line="756"/>
                <scope line="758"/>
            </method>
            <method name="isSecureRenegotiation" type="boolean" line="766"/>
            <method name="getClientVerifyData" type="byte[]" line="773"/>
            <method name="getServerVerifyData" type="byte[]" line="780"/>
            <method name="process_record" type="void" line="789">
                <params>
                    <param name="r" type="InputRecord"/>
                    <param name="expectingFinished" type="boolean"/>
                </params>
                <comment line="794">
                    Store the incoming handshake data, then see if we can
                     now process any completed handshake messages                    
                </comment>
                <comment line="800">
                    We don&apos;t need to create a separate delegatable task
                     for finished messages.                    
                </comment>
                <scope line="803"/>
                <scope line="805">
                    <anonymous_class line="806">
                        <method name="run" type="Void" line="807"/>
                    </anonymous_class>
                </scope>
            </method>
            <method name="processLoop" type="void" line="824">
                <comment line="827">
                    need to read off 4 bytes at least to get the handshake
                     message type and length.                    
                </comment>
                <comment line="833">
                    See if we can read the handshake message header, and
                     then the entire handshake message.  If not, wait till
                     we can read and process an entire message.                    
                </comment>
                <comment line="848">
                    Process the messsage.  We require
                     that processMessage() consumes the entire message.  In
                     lieu of explicit error checks (how?!) we assume that the
                     data will look like garbage on encodingprocessing errors,
                     and that other protocol code will detect such errors.
                    
                     Note that digesting is normally deferred till after the
                     message has been processed, though to process at least the
                     client&apos;s Finished message (i.e. send the server&apos;s) we need
                     to acccelerate that digesting.
                    
                     Also, note that hello request messages are never hashed;
                     that includes the hello request header, too.                    
                </comment>
                <scope line="828">
                    <declaration name="messageType" type="byte" line="829"/>
                    <declaration name="messageLen" type="int" line="830"/>
                    <scope line="842"/>
                    <scope line="862"/>
                    <scope line="866"/>
                </scope>
            </method>
            <javadoc line="875">
                Returns true iff the handshaker has been activated.
                  In activated state, the handshaker may not send any messages out.                
            </javadoc>
            <method name="activated" type="boolean" line="880"/>
            <javadoc line="884">
                Returns true iff the handshaker has sent any messages.                
            </javadoc>
            <method name="started" type="boolean" line="887">
                <comment line="889">
                    0: HandshakeMessage.ht_hello_request
                     1: HandshakeMessage.ht_client_hello                    
                </comment>
            </method>
            <method name="kickstart" type="void" line="898">
                <scope line="899"/>
                <declaration name="m" type="HandshakeMessage" line="903"/>
                <scope line="905"/>
            </method>
            <method name="getKickstartMessage" type="HandshakeMessage" line="914"/>
            <javadoc line="914">
                Both client and server modes can start handshaking; but the
                  message they send to do so is different.                
            </javadoc>
            <method name="processMessage" type="void" line="925"/>
            <method name="handshakeAlert" type="void" line="932"/>
            <method name="sendChangeCipherSpec" type="void" line="939">
                <params>
                    <param name="mesg" type="Finished"/>
                    <param name="lastMessage" type="boolean"/>
                </params>
                <comment line="942">
                    i.e. handshake data                    
                </comment>
                <comment line="944">
                    The write cipher state is protected by the connection write lock
                     so we must grab it while making the change. We also
                     make sure no writes occur between sending the ChangeCipherSpec
                     message, installing the new cipher state, and sending the
                     Finished message.
                    
                     We already hold SSLEngineSSLSocket &quot;this&quot; by virtue
                     of this being called from the readRecord code.                    
                </comment>
                <comment line="962">
                    single byte of data                    
                </comment>
                <declaration name="r" type="OutputRecord" line="953"/>
                <scope line="954"/>
                <scope line="956"/>
                <scope line="963">
                    <scope line="965">
                        <scope line="968"/>
                    </scope>
                    <scope line="973"/>
                </scope>
                <scope line="976">
                    <scope line="977">
                        <scope line="980"/>
                        <scope line="985"/>
                    </scope>
                </scope>
            </method>
            <method name="calculateKeys" type="void" line="998">
                <params>
                    <param name="preMasterSecret" type="SecretKey"/>
                    <param name="version" type="ProtocolVersion"/>
                </params>
                <declaration name="master" type="SecretKey" line="999"/>
            </method>
            <method name="calculateMasterSecret" type="SecretKey" line="1015">
                <params>
                    <param name="preMasterSecret" type="SecretKey"/>
                    <param name="requestedVersion" type="ProtocolVersion"/>
                </params>
                <comment line="1026">
                    Nonces are dumped with connection keygen, no
                     benefit to doing it twice                    
                </comment>
                <comment line="1030">
                    What algs/params do we need to use?                    
                </comment>
                <comment line="1057">
                    For RSA premaster secrets, do not signal a protocol error
                     due to the Bleichenbacher attack. See comments further down.                    
                </comment>
                <comment line="1078">
                    recursive call with new premaster secret                    
                </comment>
                <comment line="1082">
                    if no version check requested (client side handshake), or version
                     information is not available (not an RSA premaster secret),
                     return master secret immediately.                    
                </comment>
                <comment line="1090">
                    we have checked the ClientKeyExchange message when reading TLS
                     record, the following check is necessary to ensure that
                     JCE provider does not ignore the checking, or the previous
                     checking process bypassed the premaster secret version checking.                    
                </comment>
                <comment line="1101">
                    check if the premaster secret version is ok
                     the specification says that it must be the maximum version supported
                     by the client from its ClientHello message. However, many
                     implementations send the negotiated version, so accept both
                     for SSL v3.0 and TLS v1.0.
                     NOTE that we may be comparing two unsupported version numbers, which
                     is why we cannot use object reference equality in this special case.                    
                </comment>
                <comment line="1112">
                    we never checked the client_version in server side
                     for TLS v1.0 and SSL v3.0. For compatibility, we
                     maintain this behavior.                    
                </comment>
                <comment line="1122">
                    check passed, return key                    
                </comment>
                <comment line="1126">
                    Due to the Bleichenbacher attack, do not signal a protocol error.
                     Generate a random premaster secret and continue with the handshake,
                     which will fail when verifying the finished messages.
                     For more information, see comments in PreMasterSecret.                    
                </comment>
                <comment line="1139">
                    recursive call with new premaster secret                    
                </comment>
                <scope line="1017">
                    <declaration name="dump" type="HexDumpEncoder" line="1018"/>
                </scope>
                <declaration name="masterAlg" type="String" line="1030"/>
                <declaration name="prf" type="PRF" line="1031"/>
                <scope line="1033"/>
                <scope line="1036"/>
                <declaration name="prfHashAlg" type="String" line="1041"/>
                <declaration name="prfHashLength" type="int" line="1042"/>
                <declaration name="prfBlockSize" type="int" line="1043"/>
                <declaration name="spec" type="TlsMasterSecretParameterSpec" line="1045"/>
                <declaration name="masterSecret" type="SecretKey" line="1050"/>
                <scope line="1051">
                    <declaration name="kg" type="KeyGenerator" line="1052"/>
                </scope>
                <scope line="1055">
                    <scope line="1059"/>
                    <scope line="1063"/>
                    <scope line="1069"/>
                    <scope line="1072"/>
                </scope>
                <scope line="1085"/>
                <declaration name="tlsKey" type="TlsMasterSecret" line="1093"/>
                <declaration name="major" type="int" line="1094"/>
                <declaration name="minor" type="int" line="1095"/>
                <scope line="1096"/>
                <declaration name="premasterVersion" type="ProtocolVersion" line="1107"/>
                <declaration name="versionMismatch" type="boolean" line="1109"/>
                <scope line="1116"/>
                <scope line="1120"/>
                <scope line="1129"/>
            </method>
            <method name="calculateConnectionKeys" type="void" line="1152">
                <params>
                    <param name="masterKey" type="SecretKey"/>
                </params>
                <comment line="1154">
                    For both the read and write sides of the protocol, we use the
                     master to generate MAC secrets and cipher keying material.  Block
                     ciphers need initialization vectors, which we also generate.
                    
                     First we figure out how much keying material is needed.                    
                </comment>
                <comment line="1166">
                    Which algs/params do we need to use?                    
                </comment>
                <comment line="1197">
                    Return null if IVs are not supposed to be generated.
                     e.g. TLS 1.1+.                    
                </comment>
                <comment line="1208">
                    Dump the connection keys as they&apos;re generated.                    
                </comment>
                <comment line="1217">
                    Inputs:                    
                </comment>
                <comment line="1225">
                    Outputs:                    
                </comment>
                <declaration name="hashSize" type="int" line="1160"/>
                <declaration name="is_exportable" type="boolean" line="1161"/>
                <declaration name="cipher" type="BulkCipher" line="1162"/>
                <declaration name="expandedKeySize" type="int" line="1163"/>
                <declaration name="keyMaterialAlg" type="String" line="1166"/>
                <declaration name="prf" type="PRF" line="1167"/>
                <scope line="1169"/>
                <scope line="1172"/>
                <declaration name="prfHashAlg" type="String" line="1177"/>
                <declaration name="prfHashLength" type="int" line="1178"/>
                <declaration name="prfBlockSize" type="int" line="1179"/>
                <declaration name="spec" type="TlsKeyMaterialParameterSpec" line="1181"/>
                <scope line="1188">
                    <declaration name="kg" type="KeyGenerator" line="1189"/>
                    <declaration name="keySpec" type="TlsKeyMaterialSpec" line="1191"/>
                </scope>
                <scope line="1203"/>
                <scope line="1210">
                    <scope line="1211">
                        <declaration name="dump" type="HexDumpEncoder" line="1212"/>
                        <scope line="1230"/>
                        <scope line="1235"/>
                        <scope line="1239"/>
                        <scope line="1244">
                            <scope line="1245"/>
                            <scope line="1248"/>
                        </scope>
                    </scope>
                </scope>
            </method>
            <method name="printHex" type="void" line="1257">
                <params>
                    <param name="dump" type="HexDumpEncoder"/>
                    <param name="bytes" type="byte[]"/>
                </params>
                <comment line="1265">
                    just for debugging, ignore this                    
                </comment>
                <scope line="1258"/>
                <scope line="1260">
                    <scope line="1261"/>
                    <scope line="1263"/>
                </scope>
            </method>
            <javadoc line="1269">
                Throw an SSLException with the specified message and cause.
                  Shorthand until a new SSLException constructor is added.
                  This method never returns.                
            </javadoc>
            <method name="throwSSLException" type="void" line="1275">
                <params>
                    <param name="msg" type="String"/>
                    <param name="cause" type="Throwable"/>
                </params>
                <declaration name="e" type="SSLException" line="1276"/>
            </method>
            <class name="DelegatedTask" line="1290">
                <type_params>
                    <type_param name="E"/>
                </type_params>
                <implements interface="Runnable"/>
                <declaration name="pea" type="PrivilegedExceptionAction&lt;E&gt;" line="1292"/>
                <method name="DelegatedTask" type="constructor" line="1294">
                    <params>
                        <param name="pea" type="PrivilegedExceptionAction<E>"/>
                    </params>
                </method>
                <method name="run" type="void" line="1298">
                    <scope line="1299">
                        <scope line="1300"/>
                        <scope line="1302"/>
                        <scope line="1304"/>
                    </scope>
                </method>
            </class>
            <method name="delegateTask" type="void" line="1313">
                <params>
                    <param name="pea" type="PrivilegedExceptionAction<T>"/>
                </params>
            </method>
            <method name="getTask" type="DelegatedTask" line="1319">
                <scope line="1320"/>
                <scope line="1323"/>
            </method>
            <method name="taskOutstanding" type="boolean" line="1333"/>
            <method name="checkThrown" type="void" line="1343">
                <comment line="1354">
                    See what the underlying type of exception is.  We should
                     throw the same thing.  Chain thrown to the new exception.                    
                </comment>
                <comment line="1377">
                    If it&apos;s SSLException or any other Exception,
                     we&apos;ll wrap it in an SSLException.                    
                </comment>
                <scope line="1344">
                    <scope line="1345">
                        <declaration name="msg" type="String" line="1347"/>
                        <scope line="1349"/>
                        <declaration name="e" type="Exception" line="1357"/>
                        <scope line="1360"/>
                        <scope line="1363"/>
                        <scope line="1366"/>
                        <scope line="1369"/>
                        <scope line="1372"/>
                        <scope line="1375"/>
                    </scope>
                </scope>
            </method>
        </class>
    </source>