<?xml version="1.0" encoding="UTF-8"?>
    <source package="sun.security.ssl">
        <import package="java.io"/>
        <import package="java.nio.channels.SocketChannel"/>
        <import package="java.net"/>
        <import package="javax.net.ssl"/>
        <class name="BaseSSLSocketImpl" line="35">
            <extends class="SSLSocket"/>
            <comment line="51">
                Normally &quot;self&quot; is &quot;this&quot; ... but not when this connection is
                 layered over a preexisting socket.  If we&apos;re using an existing
                 socket, we delegate some actions to it.  Else, we delegate
                 instead to &quot;super&quot;.  This is important to ensure that we don&apos;t
                 recurse infinitely ... e.g. close() calling itself, or doing
                 IO in terms of our own streams.                
            </comment>
            <comment line="71">
                CONSTANTS AND STATIC METHODS                
            </comment>
            <comment line="89">
                MISC SOCKET METHODS                
            </comment>
            <comment line="188">
                CLOSE RELATED METHODS                
            </comment>
            <comment line="270">
                GET ADDRESS METHODS                
            </comment>
            <comment line="321">
                SOCKET OPTION METHODS                
            </comment>
            <javadoc line="35">
                Abstract base class for SSLSocketImpl. Its purpose is to house code with
                  no SSL related logic (or no logic at all). This makes SSLSocketImpl shorter
                  and easier to read. It contains a few constants and static methods plus
                  overridden java.net.Socket methods.
                  Methods are defined final to ensure that they are not accidentally
                  overridden in SSLSocketImpl.                
                <see>
                    javax.net.ssl.SSLSocket                    
                </see>
                <see>
                    SSLSocketImpl                    
                </see>
            </javadoc>
            <declaration name="self" type="Socket" line="58"/>
            <method name="BaseSSLSocketImpl" type="constructor" line="60"/>
            <method name="BaseSSLSocketImpl" type="constructor" line="65">
                <params>
                    <param name="socket" type="Socket"/>
                </params>
            </method>
            <declaration name="PROP_NAME" type="String" line="74"/>
            <javadoc line="74">
                TLS requires that a close_notify warning alert is sent before the
                  connection is closed in order to avoid truncation attacks. Some
                  implementations (MS IIS and others) don&apos;t do that. The property
                  below controls whether we accept that or treat it as an error.
                  The default is &quot;false&quot;, i.e. tolerate the broken behavior.                
            </javadoc>
            <declaration name="requireCloseNotify" type="boolean" line="85"/>
            <javadoc line="92">
                Returns the unique {@link java.nio.SocketChannel SocketChannel} object
                  associated with this socket, if any.                
                <see>
                    java.net.Socket#getChannel                    
                </see>
            </javadoc>
            <method name="getChannel" type="SocketChannel" line="97">
                <scope line="98"/>
                <scope line="100"/>
            </method>
            <javadoc line="105">
                Binds the address to the socket.                
                <see>
                    java.net.Socket#bind                    
                </see>
            </javadoc>
            <method name="bind" type="void" line="109">
                <params>
                    <param name="bindpoint" type="SocketAddress"/>
                </params>
                <comment line="111">
                    Bind to this socket                    
                </comment>
                <comment line="117">
                    If we&apos;re binding on a layered socket...                    
                </comment>
                <scope line="113"/>
                <scope line="115"/>
            </method>
            <javadoc line="122">
                Returns the address of the endpoint this socket is connected to                
                <see>
                    java.net.Socket#getLocalSocketAddress                    
                </see>
            </javadoc>
            <method name="getLocalSocketAddress" type="SocketAddress" line="126">
                <scope line="127"/>
                <scope line="129"/>
            </method>
            <javadoc line="134">
                Returns the address of the endpoint this socket is connected to                
                <see>
                    java.net.Socket#getRemoteSocketAddress                    
                </see>
            </javadoc>
            <method name="getRemoteSocketAddress" type="SocketAddress" line="138">
                <scope line="139"/>
                <scope line="141"/>
            </method>
            <javadoc line="146">
                Connects this socket to the server.
                  This method is either called on an unconnected SSLSocketImpl by the
                  application, or it is called in the constructor of a regular
                  SSLSocketImpl. If we are layering on top on another socket, then
                  this method should not be called, because we assume that the
                  underlying socket is already connected by the time it is passed to
                  us.                
                <param>
                    endpoint the &lt;code&gt;SocketAddress&lt;/code&gt;                    
                </param>
                <throws>
                    IOException if an error occurs during the connection                    
                </throws>
            </javadoc>
            <method name="connect" type="void" line="159">
                <params>
                    <param name="endpoint" type="SocketAddress"/>
                </params>
            </method>
            <javadoc line="163">
                Returns the connection state of the socket.                
                <see>
                    java.net.Socket#isConnected                    
                </see>
            </javadoc>
            <method name="isConnected" type="boolean" line="167">
                <scope line="168"/>
                <scope line="170"/>
            </method>
            <javadoc line="175">
                Returns the binding state of the socket.                
                <see>
                    java.net.Socket#isBound                    
                </see>
            </javadoc>
            <method name="isBound" type="boolean" line="179">
                <scope line="180"/>
                <scope line="182"/>
            </method>
            <javadoc line="191">
                The semantics of shutdownInput is not supported in TLS 1.0
                  spec. Thus when the method is called on an SSL socket, an
                  UnsupportedOperationException will be thrown.                
                <throws>
                    UnsupportedOperationException                    
                </throws>
            </javadoc>
            <method name="shutdownInput" type="void" line="198"/>
            <javadoc line="203">
                The semantics of shutdownOutput is not supported in TLS 1.0
                  spec. Thus when the method is called on an SSL socket, an
                  UnsupportedOperationException will be thrown.                
                <throws>
                    UnsupportedOperationException                    
                </throws>
            </javadoc>
            <method name="shutdownOutput" type="void" line="210"/>
            <javadoc line="216">
                Returns the input state of the socket                
                <see>
                    java.net.Socket#isInputShutdown                    
                </see>
            </javadoc>
            <method name="isInputShutdown" type="boolean" line="220">
                <scope line="221"/>
                <scope line="223"/>
            </method>
            <javadoc line="228">
                Returns the output state of the socket                
                <see>
                    java.net.Socket#isOutputShutdown                    
                </see>
            </javadoc>
            <method name="isOutputShutdown" type="boolean" line="232">
                <scope line="233"/>
                <scope line="235"/>
            </method>
            <javadoc line="240">
                Ensures that the SSL connection is closed down as cleanly
                  as possible, in case the application forgets to do so.
                  This allows SSL connections to be implicitly reclaimed,
                  rather than forcing them to be explicitly reclaimed at
                  the penalty of prematurly killing SSL sessions.                
            </javadoc>
            <method name="finalize" type="void" line="247">
                <comment line="257">
                    ignore                    
                </comment>
                <comment line="260">
                    We called close on the underlying socket above to
                     make doubly sure all resources got released.  We
                     don&apos;t finalize self in the case of overlain sockets,
                     that&apos;s a different object which the GC will finalize
                     separately.                    
                </comment>
                <scope line="248"/>
                <scope line="250">
                    <scope line="251">
                        <scope line="252"/>
                    </scope>
                    <scope line="255"/>
                </scope>
                <scope line="258"/>
            </method>
            <javadoc line="273">
                Returns the address of the remote peer for this connection.                
            </javadoc>
            <method name="getInetAddress" type="InetAddress" line="276">
                <scope line="277"/>
                <scope line="279"/>
            </method>
            <javadoc line="284">
                Gets the local address to which the socket is bound.                
                <return>
                    the local address to which the socket is bound.                    
                </return>
                <since>
                    JDK1.1                    
                </since>
            </javadoc>
            <method name="getLocalAddress" type="InetAddress" line="290">
                <scope line="291"/>
                <scope line="293"/>
            </method>
            <javadoc line="298">
                Returns the number of the remote port that this connection uses.                
            </javadoc>
            <method name="getPort" type="int" line="301">
                <scope line="302"/>
                <scope line="304"/>
            </method>
            <javadoc line="309">
                Returns the number of the local port that this connection uses.                
            </javadoc>
            <method name="getLocalPort" type="int" line="312">
                <scope line="313"/>
                <scope line="315"/>
            </method>
            <javadoc line="324">
                Enables or disables the Nagle optimization.                
                <see>
                    java.net.Socket#setTcpNoDelay                    
                </see>
            </javadoc>
            <method name="setTcpNoDelay" type="void" line="328">
                <params>
                    <param name="value" type="boolean"/>
                </params>
                <scope line="329"/>
                <scope line="331"/>
            </method>
            <javadoc line="336">
                Returns true if the Nagle optimization is disabled.  This
                  relates to low-level buffering of TCP traffic, delaying the
                  traffic to promote better throughput.                
                <see>
                    java.net.Socket#getTcpNoDelay                    
                </see>
            </javadoc>
            <method name="getTcpNoDelay" type="boolean" line="343">
                <scope line="344"/>
                <scope line="346"/>
            </method>
            <javadoc line="351">
                Assigns the socket&apos;s linger timeout.                
                <see>
                    java.net.Socket#setSoLinger                    
                </see>
            </javadoc>
            <method name="setSoLinger" type="void" line="356">
                <params>
                    <param name="flag" type="boolean"/>
                    <param name="linger" type="int"/>
                </params>
                <scope line="357"/>
                <scope line="359"/>
            </method>
            <javadoc line="364">
                Returns the socket&apos;s linger timeout.                
                <see>
                    java.net.Socket#getSoLinger                    
                </see>
            </javadoc>
            <method name="getSoLinger" type="int" line="368">
                <scope line="369"/>
                <scope line="371"/>
            </method>
            <javadoc line="376">
                Send one byte of urgent data on the socket.                
                <see>
                    java.net.Socket#sendUrgentDataAt this point, there seems to be no specific requirement to support
                      this for an SSLSocket. An implementation can be provided if a need
                      arises in future.                    
                </see>
            </javadoc>
            <method name="sendUrgentData" type="void" line="383">
                <params>
                    <param name="data" type="int"/>
                </params>
            </method>
            <javadoc line="388">
                Enable/disable OOBINLINE (receipt of TCP urgent data) By default, this
                  option is disabled and TCP urgent data received on a socket is silently
                  discarded.                
                <see>
                    java.net.Socket#setOOBInlineSetting OOBInline does not have any effect on SSLSocket,
                      since currently we don&apos;t support sending urgent data.                    
                </see>
            </javadoc>
            <method name="setOOBInline" type="void" line="396">
                <params>
                    <param name="on" type="boolean"/>
                </params>
            </method>
            <javadoc line="401">
                Tests if OOBINLINE is enabled.                
                <see>
                    java.net.Socket#getOOBInline                    
                </see>
            </javadoc>
            <method name="getOOBInline" type="boolean" line="405"/>
            <javadoc line="410">
                Returns the socket timeout.                
                <see>
                    java.net.Socket#getSoTimeout                    
                </see>
            </javadoc>
            <method name="getSoTimeout" type="int" line="414">
                <scope line="415"/>
                <scope line="417"/>
            </method>
            <method name="setSendBufferSize" type="void" line="422">
                <params>
                    <param name="size" type="int"/>
                </params>
                <scope line="423"/>
                <scope line="425"/>
            </method>
            <method name="getSendBufferSize" type="int" line="430">
                <scope line="431"/>
                <scope line="433"/>
            </method>
            <method name="setReceiveBufferSize" type="void" line="438">
                <params>
                    <param name="size" type="int"/>
                </params>
                <scope line="439"/>
                <scope line="441"/>
            </method>
            <method name="getReceiveBufferSize" type="int" line="446">
                <scope line="447"/>
                <scope line="449"/>
            </method>
            <javadoc line="454">
                Enable/disable SO_KEEPALIVE.                
                <see>
                    java.net.Socket#setKeepAlive                    
                </see>
            </javadoc>
            <method name="setKeepAlive" type="void" line="458">
                <params>
                    <param name="on" type="boolean"/>
                </params>
                <scope line="459"/>
                <scope line="461"/>
            </method>
            <javadoc line="466">
                Tests if SO_KEEPALIVE is enabled.                
                <see>
                    java.net.Socket#getKeepAlive                    
                </see>
            </javadoc>
            <method name="getKeepAlive" type="boolean" line="470">
                <scope line="471"/>
                <scope line="473"/>
            </method>
            <javadoc line="478">
                Sets traffic class or type-of-service octet in the IP header for
                  packets sent from this Socket.                
                <see>
                    java.net.Socket#setTrafficClass                    
                </see>
            </javadoc>
            <method name="setTrafficClass" type="void" line="483">
                <params>
                    <param name="tc" type="int"/>
                </params>
                <scope line="484"/>
                <scope line="486"/>
            </method>
            <javadoc line="491">
                Gets traffic class or type-of-service in the IP header for packets
                  sent from this Socket.                
                <see>
                    java.net.Socket#getTrafficClass                    
                </see>
            </javadoc>
            <method name="getTrafficClass" type="int" line="496">
                <scope line="497"/>
                <scope line="499"/>
            </method>
            <javadoc line="504">
                Enable/disable SO_REUSEADDR.                
                <see>
                    java.net.Socket#setReuseAddress                    
                </see>
            </javadoc>
            <method name="setReuseAddress" type="void" line="508">
                <params>
                    <param name="on" type="boolean"/>
                </params>
                <scope line="509"/>
                <scope line="511"/>
            </method>
            <javadoc line="516">
                Tests if SO_REUSEADDR is enabled.                
                <see>
                    java.net.Socket#getReuseAddress                    
                </see>
            </javadoc>
            <method name="getReuseAddress" type="boolean" line="520">
                <scope line="521"/>
                <scope line="523"/>
            </method>
            <javadoc line="528">
                Sets performance preferences for this socket.                
                <see>
                    java.net.Socket#setPerformancePreferences(int,int,int)                    
                </see>
            </javadoc>
            <method name="setPerformancePreferences" type="void" line="534">
                <params>
                    <param name="connectionTime" type="int"/>
                    <param name="latency" type="int"/>
                    <param name="bandwidth" type="int"/>
                </params>
                <scope line="535"/>
                <scope line="538"/>
            </method>
        </class>
    </source>