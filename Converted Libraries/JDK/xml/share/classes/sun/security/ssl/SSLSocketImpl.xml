<?xml version="1.0" encoding="UTF-8"?>
    <source package="sun.security.ssl">
        <import package="java.io"/>
        <import package="java.net"/>
        <import package="java.security.GeneralSecurityException"/>
        <import package="java.security.AccessController"/>
        <import package="java.security.AccessControlContext"/>
        <import package="java.security.PrivilegedAction"/>
        <import package="java.security.AlgorithmConstraints"/>
        <import package="java.util"/>
        <import package="java.util.concurrent.TimeUnit"/>
        <import package="java.util.concurrent.locks.ReentrantLock"/>
        <import package="javax.crypto.BadPaddingException"/>
        <import package="javax.net.ssl"/>
        <import package="com.sun.net.ssl.internal.ssl.X509ExtendedTrustManager"/>
        <class name="SSLSocketImpl" line="46">
            <extends class="BaseSSLSocketImpl"/>
            <comment line="68">
                ERROR HANDLING GUIDELINES
                 (which exceptions to throw and catch and which not to throw and catch)
                
                 . if there is an IOException (SocketException) when accessing the
                   underlying Socket, pass it through
                
                 . do not throw IOExceptions, throw SSLExceptions (or a subclass)
                
                 . for internal errors (things that indicate a bug in JSSE or a
                   grossly misconfigured J2RE), throw either an SSLException or
                   a RuntimeException at your convenience.
                
                 . handshaking code (Handshaker or HandshakeMessage) should generally
                   pass through exceptions, but can handle them if they know what to
                   do.
                
                 . exception chaining should be used for all new code. If you happen
                   to touch old code that does not use chaining, you should change it.
                
                 . there is a top level exception handler that sits at all entry
                   points from application code to SSLSocket readwrite code. It
                   makes sure that all errors are handled (see handleException()).
                
                 . JSSE internal code should generally not call close(), call
                   closeInternal().                
            </comment>
            <comment line="96">
                There&apos;s a state machine associated with each connection, which
                 among other roles serves to negotiate session changes.
                
                 - START with constructor, until the TCP connection&apos;s around.
                 - HANDSHAKE picks session parameters before allowing traffic.
                          There are many substates due to sequencing requirements
                          for handshake messages.
                 - DATA may be transmitted.
                 - RENEGOTIATE state allows concurrent data and handshaking
                          traffic (&quot;same&quot; substates as HANDSHAKE), and terminates
                          in selection of new session (and connection) parameters
                 - ERROR state immediately precedes abortive disconnect.
                 - SENT_CLOSE sent a close_notify to the peer. For layered,
                          non-autoclose socket, must now read close_notify
                          from peer before closing the connection. For nonlayered or
                          non-autoclose socket, close connection and go onto
                          cs_CLOSED state.
                 - CLOSED after sending close_notify alert, &amp; socket is closed.
                          SSL connection objects are not reused.
                 - APP_CLOSED once the application calls close(). Then it behaves like
                          a closed socket, e.g.. getInputStream() throws an Exception.
                
                 State affects what SSL record types may legally be sent:
                
                 - Handshake ... only in HANDSHAKE and RENEGOTIATE states
                 - App Data ... only in DATA and RENEGOTIATE states
                 - Alert ... in HANDSHAKE, DATA, RENEGOTIATE
                
                 Re what may be received:  same as what may be sent, except that
                 HandshakeRequest handshaking messages can come from servers even
                 in the application data state, to request entry to RENEGOTIATE.
                
                 The state machine within HANDSHAKE and RENEGOTIATE states controls
                 the pending session, not the connection state, until the change
                 cipher spec and &quot;Finished&quot; handshake messages are processed and
                 make the &quot;new&quot; session become the current one.
                
                 NOTE: details of the SMs always need to be nailed down better.
                 The text above illustrates the core ideas.
                
                                +----&gt;-------+------&gt;---------&gt;-------+
                                |            |                        |
                     &lt;-----&lt;    ^            ^  &lt;-----&lt;               v
                START&gt;-----&gt;HANDSHAKE&gt;-----&gt;DATA&gt;-----&gt;RENEGOTIATE  SENT_CLOSE
                                v            v               v        |   |
                                |            |               |        |   v
                                +------------+---------------+        v ERROR
                                |                                     |   |
                                v                                     |   |
                               ERROR&gt;------&gt;-----&gt;CLOSED&lt;--------&lt;----+-- +
                                                     |
                                                     v
                                                 APP_CLOSED
                
                 ALSO, note that the the purpose of handshaking (renegotiation is
                 included) is to assign a different, and perhaps new, session to
                 the connection.  The SSLv3 spec is a bit confusing on that new
                 protocol feature.                
            </comment>
            <comment line="166">
                Client authentication be off, requested, or required.
                
                 Migrated to SSLEngineImpl:
                    clauth_nonecl_auth_requestedclauth_required                
            </comment>
            <comment line="173">
                Drives the protocol state machine.                
            </comment>
            <comment line="178">
                Flag indicating if the next record we receive MUST be a Finished
                 message. Temporarily set during the handshake to ensure that
                 a change cipher spec message is followed by a finished message.                
            </comment>
            <comment line="185">
                For improved diagnostics, we detail connection closure
                 If the socket is closed (connectionState &gt;= cs_ERROR),
                 closeReason != null indicates if the socket was closed
                 because of an error or because or normal shutdown.                
            </comment>
            <comment line="193">
                Per-connection private state that doesn&apos;t change when the
                 session is changed.                
            </comment>
            <comment line="204">
                We cannot use the hostname resolved from name services.  For
                 virtual hosting, multiple hostnames may be bound to the same IP
                 address, so the hostname resolved from name services is not
                 reliable.                
            </comment>
            <comment line="212">
                The cipher suites enabled for use on this connection.                
            </comment>
            <comment line="215">
                The endpoint identification protocol                
            </comment>
            <comment line="218">
                The cryptographic algorithm constraints                
            </comment>
            <comment line="221">
                READ ME  READ ME  READ ME  READ ME  READ ME  READ ME 
                 IMPORTANT STUFF TO UNDERSTANDING THE SYNCHRONIZATION ISSUES.
                 READ ME  READ ME  READ ME  READ ME  READ ME  READ ME 
                
                 There are several locks here.
                
                 The primary lock is the per-instance lock used by
                 synchronized(this) and the synchronized methods.  It controls all
                 access to things such as the connection state and variables which
                 affect handshaking.  If we are inside a synchronized method, we
                 can access the state directly, otherwise, we must use the
                 synchronized equivalents.
                
                 The handshakeLock is used to ensure that only one thread performs
                 the complete initial handshake.  If someone is handshaking, any
                 stray application or startHandshake() requests who find the
                 connection state is cs_HANDSHAKE will stall on handshakeLock
                 until handshaking is done.  Once the handshake is done, we either
                 succeeded or failed, but we can never go back to the cs_HANDSHAKE
                 or cs_START state again.
                
                 Note that the readwrite() calls here in SSLSocketImpl are not
                 obviously synchronized.  In fact, it&apos;s very nonintuitive, and
                 requires careful examination of code paths.  Grab some coffee,
                 and be careful with any code changes.
                
                 There can be only three threads active at a time in the IO
                 subsection of this class.
                    1.  startHandshake
                    2.  AppInputStream
                    3.  AppOutputStream
                 One thread could call startHandshake().
                 AppInputStreamAppOutputStream read() and write() calls are each
                 synchronized on &apos;this&apos; in their respective classes, so only one
                 app. thread will be doing a SSLSocketImpl.read() or .write()&apos;s at
                 a time.
                
                 If handshaking is required (state cs_HANDSHAKE), and
                 getConnectionState() for someall threads returns cs_HANDSHAKE,
                 only one can grab the handshakeLock, and the rest will stall
                 either on getConnectionState(), or on the handshakeLock if they
                 happen to successfully race through the getConnectionState().
                
                 If a writer is doing the initial handshaking, it must create a
                 temporary reader to read the responses from the other side.  As a
                 side-effect, the writer&apos;s reader will have priority over any
                 other reader.  However, the writer&apos;s reader is not allowed to
                 consume any application data.  When handshakeLock is finally
                 released, we either have a cs_DATA connection, or a
                 cs_CLOSEDcs_ERROR socket.
                
                 The writeLock is held while writing on a socket connection and
                 also to protect the MAC and cipher for their direction.  The
                 writeLock is package private for Handshaker which holds it while
                 writing the ChangeCipherSpec message.
                
                 To avoid the problem of a thread trying to change operational
                 modes on a socket while handshaking is going on, we synchronize
                 on &apos;this&apos;.  If handshaking has not started yet, we tell the
                 handshaker to change its mode.  If handshaking has started,
                 we simply store that request until the next pending session
                 is created, at which time the new handshaker&apos;s state is set.
                
                 The readLock is held during readRecord(), which is responsible
                 for reading an InputRecord, decrypting it, and processing it.
                 The readLock ensures that these three steps are done atomically
                 and that once started, no other thread can block on InputRecord.read.
                 This is necessary so that processing of close_notify alerts
                 from the peer are handled properly.                
            </comment>
            <comment line="298">
                Crypto state that&apos;s reinitialized when the session changes.                
            </comment>
            <comment line="303">
                NOTE: compression state would be saved here                
            </comment>
            <comment line="305">
                security parameters for secure renegotiation.                
            </comment>
            <comment line="312">
                The authentication context holds all information used to establish
                 who this end of the connection is (certificate chains, private keys,
                 etc) and who is trusted (e.g. as CAs or websites).                
            </comment>
            <comment line="320">
                This connection is one of (potentially) many associated with
                 any given session.  The output of the handshake protocol is a
                 new session ... although all the protocol description talks
                 about changing the cipher spec (and it does change), in fact
                 that&apos;s incidental since it&apos;s done by changing everything that
                 is associated with a session at the same time.  (TLSIETF may
                 change that to add client authentication wo new key exchg.)                
            </comment>
            <comment line="334">
                If anyone wants to get notified about handshake completions,
                 they&apos;ll show up on this list.                
            </comment>
            <comment line="341">
                Reuse the same internal inputoutput streams.                
            </comment>
            <comment line="348">
                These input and output streams block their data in SSL records,
                 and usually arrange integrity and privacy protection for those
                 records.  The guts of the SSL protocol are wrapped up in these
                 streams, and in the handshaking that establishes the details of
                 that integrity and privacy protection.                
            </comment>
            <comment line="358">
                The protocol versions enabled for use on this connection.
                
                 Note: we support a pseudo protocol called SSLv2Hello which when
                 set will result in an SSL v2 Hello being sent with SSL (version 3.0)
                 or TLS (version 3.1, 3.2, etc.) version info.                
            </comment>
            <comment line="367">
                The SSL version associated with this connection.                
            </comment>
            <comment line="372">
                                
            </comment>
            <comment line="375">
                CONSTRUCTORS AND INITIALIZATION CODE                
            </comment>
            <comment line="467">
                Package-private constructor used ONLY by SSLServerSocket.  The
                 java.net package accepts the TCP connection after this call is
                 made.  This just initializes handshake state to use &quot;server mode&quot;,
                 giving control over the use of SSL client authentication.                
            </comment>
            <comment line="650">
                READING AND WRITING RECORDS                
            </comment>
            <comment line="654">
                Record Output. Application data can&apos;t be sent until the first
                 handshake establishes a session.
                
                 NOTE:  we let empty records be written as a hook to force some
                 TCP-level activity, notably handshaking, to occur.                
            </comment>
            <comment line="811">
                Read an application data record.  Alerts and handshake
                 messages are handled directly.                
            </comment>
            <comment line="823">
                Clear the pipeline of records from the peer, optionally returning
                 application data.   Caller is responsible for knowing that it&apos;s
                 possible to do this kind of clearing, if they don&apos;t want app
                 data -- e.g. since it&apos;s the initial SSL handshake.
                
                 Don&apos;t synchronize (this) during a blocking read() since it
                 protects data which is accessed on the write side as well.                
            </comment>
            <comment line="1147">
                HANDSHAKE RELATED CODE                
            </comment>
            <comment line="1389">
                CLOSURE RELATED CALLS                
            </comment>
            <comment line="1472">
                Closing the connection is tricky ... we can&apos;t officially close the
                 connection until we know the other end is ready to go away too,
                 and if ever the connection gets aborted we must forget session
                 state (it becomes invalid).                
            </comment>
            <comment line="1693">
                EXCEPTION AND ALERT HANDLING                
            </comment>
            <comment line="1781">
                Send a warning alert.                
            </comment>
            <comment line="1798">
                Send a fatal alert, and throw an exception so that callers will
                 need to stand on their heads to accidentally continue processing.                
            </comment>
            <comment line="1861">
                Process an incoming alert ... caller must already have synchronized
                 access to &quot;this&quot;.                
            </comment>
            <comment line="1919">
                Emit alerts.  Caller must have synchronized with &quot;this&quot;.                
            </comment>
            <comment line="1967">
                VARIOUS OTHER METHODS                
            </comment>
            <comment line="1971">
                When a connection finishes handshaking by enabling use of a newly
                 negotiated session, each end learns about it in two halves (read,
                 and write).  When both read and write ciphers have changed, and the
                 last handshake message has been read, the connection has joined
                 (rejoined) the new session.
                
                 NOTE:  The SSLv3 spec is rather unclear on the concepts here.
                 Sessions don&apos;t change once they&apos;re established (including cipher
                 suite and master secret) but connections can join them (and leave
                 them).  They&apos;re created by handshaking, though sometime handshaking
                 causes connections to join up with pre-established sessions.                
            </comment>
            <comment line="2015">
                used by Handshaker                
            </comment>
            <comment line="2040">
                Updates the SSL version associated with this connection.
                 Called from Handshaker once it has determined the negotiated version.                
            </comment>
            <comment line="2061">
                ONLY used by HttpsClient to setup the URI specified hostname                
            </comment>
            <comment line="2431">
                We allocate a separate thread to deliver handshake completion
                 events.  This ensures that the notifications don&apos;t block the
                 protocol state machine.                
            </comment>
            <javadoc line="46">
                Implementation of an SSL socket.  This is a normal connection type
                  socket, implementing SSL over some lower level socket, such as TCP.
                  Because it is layered over some lower level socket, it MUST override
                  all default socket methods.
                  &lt;P&gt; This API offers a non-traditional option for establishing SSL
                  connections.  You may first establish the connection directly, then pass
                  that connection to the SSL socket constructor with a flag saying which
                  role should be taken in the handshake protocol.  (The two ends of the
                  connection must not choose the same role!)  This allows setup of SSL
                  proxying or tunneling, and also allows the kind of &quot;role reversal&quot;
                  that is required for most FTP data transfers.                
                <see>
                    javax.net.ssl.SSLSocket                    
                </see>
                <see>
                    SSLServerSocket                    
                </see>
                <author>
                    David Brownell                    
                </author>
            </javadoc>
            <declaration name="cs_START" type="int" line="155"/>
            <declaration name="cs_HANDSHAKE" type="int" line="156"/>
            <declaration name="cs_DATA" type="int" line="157"/>
            <declaration name="cs_RENEGOTIATE" type="int" line="158"/>
            <declaration name="cs_ERROR" type="int" line="159"/>
            <declaration name="cs_SENT_CLOSE" type="int" line="160"/>
            <declaration name="cs_CLOSED" type="int" line="161"/>
            <declaration name="cs_APP_CLOSED" type="int" line="162"/>
            <declaration name="connectionState" type="int" line="175"/>
            <declaration name="expectingFinished" type="boolean" line="182"/>
            <declaration name="closeReason" type="SSLException" line="190"/>
            <declaration name="doClientAuth" type="byte" line="196"/>
            <declaration name="roleIsServer" type="boolean" line="197"/>
            <declaration name="enableSessionCreation" type="boolean" line="198"/>
            <declaration name="host" type="String" line="199"/>
            <declaration name="autoClose" type="boolean" line="200"/>
            <declaration name="acc" type="AccessControlContext" line="201"/>
            <declaration name="rawHostname" type="String" line="209"/>
            <declaration name="enabledCipherSuites" type="CipherSuiteList" line="212"/>
            <declaration name="identificationProtocol" type="String" line="215"/>
            <declaration name="algorithmConstraints" type="AlgorithmConstraints" line="218"/>
            <declaration name="handshakeLock" type="Object" line="291"/>
            <declaration name="writeLock" type="ReentrantLock" line="292"/>
            <declaration name="readLock" type="Object" line="293"/>
            <declaration name="inrec" type="InputRecord" line="295"/>
            <declaration name="readMAC" type="MAC" line="300"/>
            <declaration name="readCipher" type="CipherBox" line="301"/>
            <declaration name="secureRenegotiation" type="boolean" line="307"/>
            <declaration name="clientVerifyData" type="byte[]" line="308"/>
            <declaration name="serverVerifyData" type="byte[]" line="309"/>
            <declaration name="sslContext" type="SSLContextImpl" line="316"/>
            <declaration name="handshaker" type="Handshaker" line="328"/>
            <declaration name="sess" type="SSLSessionImpl" line="329"/>
            <declaration name="handshakeSession" type="SSLSessionImpl" line="330"/>
            <declaration name="handshakeListeners" type="HashMap&lt;HandshakeCompletedListener,AccessControlContext&gt;" line="337"/>
            <declaration name="sockInput" type="InputStream" line="343"/>
            <declaration name="sockOutput" type="OutputStream" line="344"/>
            <declaration name="input" type="AppInputStream" line="354"/>
            <declaration name="output" type="AppOutputStream" line="355"/>
            <declaration name="enabledProtocols" type="ProtocolList" line="364"/>
            <declaration name="protocolVersion" type="ProtocolVersion" line="369"/>
            <declaration name="debug" type="Debug" line="372"/>
            <javadoc line="378">
                Constructs an SSL connection to a named host at a specified port,
                  using the authentication context provided.  This endpoint acts as
                  the client, and may rejoin an existing SSL session if appropriate.                
                <param>
                    context authentication context to use                    
                </param>
                <param>
                    host name of the host with which to connect                    
                </param>
                <param>
                    port number of the server's port                    
                </param>
            </javadoc>
            <method name="SSLSocketImpl" type="constructor" line="388">
                <params>
                    <param name="context" type="SSLContextImpl"/>
                    <param name="host" type="String"/>
                    <param name="port" type="int"/>
                </params>
                <declaration name="socketAddress" type="SocketAddress" line="393"/>
            </method>
            <javadoc line="400">
                Constructs an SSL connection to a server at a specified address.
                  and TCP port, using the authentication context provided.  This
                  endpoint acts as the client, and may rejoin an existing SSL session
                  if appropriate.                
                <param>
                    context authentication context to use                    
                </param>
                <param>
                    address the server's host                    
                </param>
                <param>
                    port its port                    
                </param>
            </javadoc>
            <method name="SSLSocketImpl" type="constructor" line="411">
                <params>
                    <param name="context" type="SSLContextImpl"/>
                    <param name="host" type="InetAddress"/>
                    <param name="port" type="int"/>
                </params>
                <declaration name="socketAddress" type="SocketAddress" line="414"/>
            </method>
            <javadoc line="418">
                Constructs an SSL connection to a named host at a specified port,
                  using the authentication context provided.  This endpoint acts as
                  the client, and may rejoin an existing SSL session if appropriate.                
                <param>
                    context authentication context to use                    
                </param>
                <param>
                    host name of the host with which to connect                    
                </param>
                <param>
                    port number of the server's port                    
                </param>
                <param>
                    localAddr the local address the socket is bound to                    
                </param>
                <param>
                    localPort the local port the socket is bound to                    
                </param>
            </javadoc>
            <method name="SSLSocketImpl" type="constructor" line="431">
                <params>
                    <param name="context" type="SSLContextImpl"/>
                    <param name="host" type="String"/>
                    <param name="port" type="int"/>
                    <param name="localAddr" type="InetAddress"/>
                    <param name="localPort" type="int"/>
                </params>
                <declaration name="socketAddress" type="SocketAddress" line="437"/>
            </method>
            <javadoc line="444">
                Constructs an SSL connection to a server at a specified address.
                  and TCP port, using the authentication context provided.  This
                  endpoint acts as the client, and may rejoin an existing SSL session
                  if appropriate.                
                <param>
                    context authentication context to use                    
                </param>
                <param>
                    address the server's host                    
                </param>
                <param>
                    port its port                    
                </param>
                <param>
                    localAddr the local address the socket is bound to                    
                </param>
                <param>
                    localPort the local port the socket is bound to                    
                </param>
            </javadoc>
            <method name="SSLSocketImpl" type="constructor" line="458">
                <params>
                    <param name="context" type="SSLContextImpl"/>
                    <param name="host" type="InetAddress"/>
                    <param name="port" type="int"/>
                    <param name="localAddr" type="InetAddress"/>
                    <param name="localPort" type="int"/>
                </params>
                <declaration name="socketAddress" type="SocketAddress" line="462"/>
            </method>
            <method name="SSLSocketImpl" type="constructor" line="476">
                <params>
                    <param name="context" type="SSLContextImpl"/>
                    <param name="serverMode" type="boolean"/>
                    <param name="suites" type="CipherSuiteList"/>
                    <param name="clientAuth" type="byte"/>
                    <param name="sessionCreation" type="boolean"/>
                    <param name="protocols" type="ProtocolList"/>
                    <param name="identificationProtocol" type="String"/>
                    <param name="algorithmConstraints" type="AlgorithmConstraints"/>
                </params>
                <comment line="486">
                    Override what was picked out for us.                    
                </comment>
            </method>
            <javadoc line="493">
                Package-private constructor used to instantiate an unconnected
                  socket. The java.net package will connect it, either when the
                  connect() call is made by the application.  This instance is
                  meant to set handshake state to use &quot;client mode&quot;.                
            </javadoc>
            <method name="SSLSocketImpl" type="constructor" line="499">
                <params>
                    <param name="context" type="SSLContextImpl"/>
                </params>
            </method>
            <javadoc line="505">
                Layer SSL traffic over an existing connection, rather than creating
                  a new connection.  The existing connection may be used only for SSL
                  traffic (using this SSLSocket) until the SSLSocket.close() call
                  returns. However, if a protocol error is detected, that existing
                  connection is automatically closed.
                  &lt;P&gt; This particular constructor always uses the socket in the
                  role of an SSL client. It may be useful in cases which start
                  using SSL after some initial data transfers, for example in some
                  SSL tunneling applications or as part of some kinds of application
                  protocols which negotiate use of a SSL based security.                
                <param>
                    sock the existing connection                    
                </param>
                <param>
                    context the authentication context to use                    
                </param>
            </javadoc>
            <method name="SSLSocketImpl" type="constructor" line="522">
                <params>
                    <param name="context" type="SSLContextImpl"/>
                    <param name="sock" type="Socket"/>
                    <param name="host" type="String"/>
                    <param name="port" type="int"/>
                    <param name="autoClose" type="boolean"/>
                </params>
                <comment line="525">
                    We always layer over a connected socket                    
                </comment>
                <scope line="525"/>
            </method>
            <javadoc line="535">
                Initializes the client socket.                
            </javadoc>
            <method name="init" type="void" line="538">
                <params>
                    <param name="context" type="SSLContextImpl"/>
                    <param name="isServer" type="boolean"/>
                </params>
                <comment line="544">
                    role is as specified, state is START until after
                     the low level connection&apos;s established.                    
                </comment>
                <comment line="551">
                    default read and write side cipher and MAC support
                    
                     Note:  compression support would go here too                    
                </comment>
                <comment line="561">
                    initial security parameters for secure renegotiation                    
                </comment>
                <comment line="573">
                    save the acc                    
                </comment>
            </method>
            <javadoc line="579">
                Connects this socket to the server with a specified timeout
                  value.
                  This method is either called on an unconnected SSLSocketImpl by the
                  application, or it is called in the constructor of a regular
                  SSLSocketImpl. If we are layering on top on another socket, then
                  this method should not be called, because we assume that the
                  underlying socket is already connected by the time it is passed to
                  us.                
                <param>
                    endpoint the <code>SocketAddress</code>                    
                </param>
                <param>
                    timeout  the timeout value to be used, 0 is no timeout                    
                </param>
                <throws>
                    IOException if an error occurs during the connection                    
                </throws>
                <throws>
                    SocketTimeoutException if timeout expires before connecting                    
                </throws>
            </javadoc>
            <method name="connect" type="void" line="596">
                <params>
                    <param name="endpoint" type="SocketAddress"/>
                    <param name="timeout" type="int"/>
                </params>
                <scope line="598"/>
                <scope line="602"/>
            </method>
            <javadoc line="611">
                Initialize the handshaker and socket streams.
                  Called by connect, the layered constructor, and SSLServerSocket.                
            </javadoc>
            <method name="doneConnect" type="void" line="616">
                <comment line="618">
                    Save the input and output streams.  May be done only after
                     java.net actually connects using the socket &quot;self&quot;, else
                     we get some pretty bizarre failure modes.                    
                </comment>
                <comment line="631">
                    Move to handshaking state, with pending session initialized
                     to defaults and the appropriate kind of handshaker set up.                    
                </comment>
                <scope line="622"/>
                <scope line="625"/>
            </method>
            <method name="getConnectionState" type="int" line="637"/>
            <method name="setConnectionState" type="void" line="641">
                <params>
                    <param name="state" type="int"/>
                </params>
            </method>
            <method name="getAcc" type="AccessControlContext" line="645"/>
            <method name="writeRecord" type="void" line="660">
                <params>
                    <param name="r" type="OutputRecord"/>
                </params>
                <comment line="662">
                    The loop is in case of HANDSHAKE --&gt; ERROR transitions, etc                    
                </comment>
                <comment line="667">
                    Not all states support passing application data.  We
                     synchronize access to the connection state, so that
                     synchronous handshakes can complete cleanly.                    
                </comment>
                <comment line="674">
                    We&apos;ve deferred the initial handshaking till just now,
                     when presumably a thread&apos;s decided it&apos;s OK to block for
                     longish periods of time for IO purposes (as well as
                     configured the cipher suites it wants to use).                    
                </comment>
                <comment line="691">
                    dummy                    
                </comment>
                <comment line="696">
                    we should never get here (check in AppOutputStream)
                     this is just a fallback                    
                </comment>
                <comment line="704">
                    Else something&apos;s goofy in this state machine&apos;s use.                    
                </comment>
                <comment line="712">
                    Don&apos;t bother to really write empty records.  We went this
                     far to drive the handshake machinery, for correctness; not
                     writing empty records improves performance by cutting CPU
                     time and network resource usage.  However, some protocol
                     implementations are fragile and don&apos;t like to see empty
                     records, so this also increases robustness.                    
                </comment>
                <comment line="722">
                    If the record is a close notify alert, we need to honor
                     socket option SO_LINGER. Note that we will try to send
                     the close notify even if the SO_LINGER set to zero.                    
                </comment>
                <comment line="727">
                    keep and clear the current thread interruption status.                    
                </comment>
                <comment line="742">
                    For layered, non-autoclose sockets, we are not
                     able to bring them into a usable state, so we
                     treat it as fatal error.                    
                </comment>
                <comment line="746">
                    Note that the alert description is
                     specified as -1, so no message will be send
                     to peer anymore.                    
                </comment>
                <comment line="755">
                    RFC2246 requires that the session becomes
                     unresumable if any connection is terminated
                     without proper close_notify messages with
                     level equal to warning.
                    
                     RFC4346 no longer requires that a session not be
                     resumed if failure to properly close a connection.
                    
                     We choose to make the session unresumable if
                     failed to send the close_notify message.                    
                </comment>
                <comment line="769">
                    keep interrupted status                    
                </comment>
                <comment line="773">
                    restore the interrupted status                    
                </comment>
                <scope line="665">
                    <scope line="697"/>
                    <scope line="699"/>
                </scope>
                <scope line="719">
                    <scope line="724">
                        <declaration name="interrupted" type="boolean" line="727"/>
                        <scope line="728">
                            <scope line="729">
                                <scope line="730"/>
                                <scope line="732"/>
                            </scope>
                            <scope line="735">
                                <declaration name="ssle" type="SSLException" line="736"/>
                                <scope line="744"/>
                                <scope line="749"/>
                            </scope>
                        </scope>
                        <scope line="767"/>
                        <scope line="773"/>
                    </scope>
                    <scope line="776">
                        <scope line="778"/>
                        <scope line="780"/>
                    </scope>
                </scope>
            </method>
            <method name="writeRecordInternal" type="void" line="787">
                <params>
                    <param name="r" type="OutputRecord"/>
                </params>
                <comment line="789">
                    r.compress(c);                    
                </comment>
                <comment line="794">
                    Check the sequence number state
                    
                     Note that in order to maintain the connection IO
                     properly, we check the sequence number after the last
                     record writing process. As we request renegotiation
                     or close the connection for wrapped sequence number
                     when there is enough sequence number space left to
                     handle a few more records, so the sequence number
                     of the last record cannot be wrapped.                    
                </comment>
                <scope line="804"/>
            </method>
            <method name="readDataRecord" type="void" line="814">
                <params>
                    <param name="r" type="InputRecord"/>
                </params>
                <scope line="815"/>
            </method>
            <method name="readRecord" type="void" line="832">
                <params>
                    <param name="r" type="InputRecord"/>
                    <param name="needAppData" type="boolean"/>
                </params>
                <comment line="836">
                    readLock protects reading and processing of an InputRecord.
                     It keeps the reading from sockInput and processing of the record
                     atomic so that no two threads can be blocked on the
                     read from the same input stream at the same time.
                     This is required for example when a reader thread is
                     blocked on the read and another thread is trying to
                     close the socket. For a non-autoclose, layered socket,
                     the thread performing the close needs to read the close_notify.
                    
                     Use readLock instead of &apos;this&apos; for locking because
                     &apos;this&apos; also protects data accessed during writing.                    
                </comment>
                <comment line="848">
                    Read and handle records ... return application data
                     ONLY if it&apos;s needed.                    
                </comment>
                <comment line="855">
                    Read a record ... maybe emitting an alert if we get a
                     comprehensible but unsupported &quot;hello&quot; message during
                     format checking (e.g. V2).                    
                </comment>
                <comment line="867">
                    discard this exception                    
                </comment>
                <comment line="890">
                    treat as if we had received a close_notify                    
                </comment>
                <comment line="897">
                    The basic SSLv3 record protection involves (optional)
                     encryption for privacy, and an integrity check ensuring
                     data origin authentication.  We do them both here, and
                     throw a fatal alert if the integrity check fails.                    
                </comment>
                <comment line="906">
                    RFC 2246 states that decryption_failed should be used
                     for this purpose. However, that allows certain attacks,
                     so we just send bad record MAC. We also need to make
                     sure to always check the MAC to avoid a timing attack
                     for the same issue. See paper by Vaudenay et al.                    
                </comment>
                <comment line="912">
                    use the same alert types as for MAC failure below                    
                </comment>
                <comment line="928">
                    if (!r.decompress(c))
                         fatal(Alerts.alert_decompression_failure,
                             &quot;decompression failure&quot;);                    
                </comment>
                <comment line="932">
                    Process the record.                    
                </comment>
                <comment line="938">
                    Handshake messages always go to a pending session
                     handshaker ... if there isn&apos;t one, create one.  This
                     must work asynchronously, for renegotiation.
                    
                     NOTE that handshaking will either resume a session
                     which was in the cache (and which might have other
                     connections in it already), or else will start a new
                     session (new keys exchanged) with just this connection
                     in it.                    
                </comment>
                <comment line="951">
                    prior to handshaking, activate the handshake                    
                </comment>
                <comment line="953">
                    don&apos;t use SSLv2Hello when renegotiating                    
                </comment>
                <comment line="960">
                    process the handshake record ... may contain just
                     a partial handshake message or multiple messages.
                    
                     The handshaker state machine will ensure that it&apos;s
                     a finished message.                    
                </comment>
                <comment line="972">
                    if state is cs_RENEGOTIATE, revert it to cs_DATA                    
                </comment>
                <comment line="977">
                    reset the parameters for secure renegotiation.                    
                </comment>
                <comment line="988">
                    Tell folk about handshake completion, but do
                     it in a separate thread.                    
                </comment>
                <comment line="1008">
                    Pass this right back up to the application.                    
                </comment>
                <comment line="1041">
                    The first message after a change_cipher_spec
                     record MUST be a &quot;Finished&quot; handshake record,
                     else it&apos;s a protocol violation.  We force this
                     to be checked by a minor tweak to the state
                     machine.                    
                </comment>
                <comment line="1049">
                    next message MUST be a finished message                    
                </comment>
                <comment line="1054">
                    TLS requires that unrecognized records be ignored.                    
                </comment>
                <comment line="1063">
                    switch                    
                </comment>
                <comment line="1065">
                    Check the sequence number state
                    
                     Note that in order to maintain the connection IO
                     properly, we check the sequence number after the last
                     record reading process. As we request renegotiation
                     or close the connection for wrapped sequence number
                     when there is enough sequence number space left to
                     handle a few more records, so the sequence number
                     of the last record cannot be wrapped.                    
                </comment>
                <comment line="1081">
                    synchronized (this)                    
                </comment>
                <comment line="1084">
                    couldn&apos;t read, due to some kind of error                    
                </comment>
                <comment line="1089">
                    synchronized (readLock)                    
                </comment>
                <declaration name="state" type="int" line="833"/>
                <scope line="846">
                    <scope line="853">
                        <scope line="859"/>
                        <scope line="862">
                            <scope line="863"/>
                            <scope line="865"/>
                        </scope>
                        <scope line="869">
                            <declaration name="handshaking" type="boolean" line="870"/>
                            <declaration name="rethrow" type="boolean" line="871"/>
                            <scope line="872"/>
                            <scope line="877">
                                <declaration name="e" type="SSLException" line="878"/>
                                <scope line="879"/>
                                <scope line="882"/>
                            </scope>
                            <scope line="888"/>
                        </scope>
                        <scope line="902"/>
                        <scope line="904">
                            <declaration name="alertType" type="byte" line="912"/>
                        </scope>
                        <scope line="917">
                            <scope line="918"/>
                            <scope line="921"/>
                        </scope>
                        <scope line="934">
                            <scope line="949">
                                <scope line="951"/>
                                <scope line="954"/>
                            </scope>
                            <scope line="969">
                                <scope line="972"/>
                            </scope>
                            <scope line="975">
                                <scope line="991">
                                    <declaration name="event" type="HandshakeCompletedEvent" line="992"/>
                                    <declaration name="t" type="Thread" line="995"/>
                                </scope>
                            </scope>
                            <scope line="1001"/>
                            <scope line="1010"/>
                            <scope line="1015"/>
                            <scope line="1019"/>
                            <scope line="1034"/>
                            <scope line="1056"/>
                            <scope line="1075"/>
                        </scope>
                    </scope>
                </scope>
            </method>
            <javadoc line="1091">
                Check the sequence number state
                  RFC 4346 states that, &quot;Sequence numbers are of type uint64 and
                  may not exceed 2^64-1.  Sequence numbers do not wrap. If a TLS
                  implementation would need to wrap a sequence number, it must
                  renegotiate instead.&quot;                
            </javadoc>
            <method name="checkSequenceNumber" type="void" line="1100">
                <params>
                    <param name="mac" type="MAC"/>
                    <param name="type" type="byte"/>
                </params>
                <comment line="1103">
                    Don&apos;t bother to check the sequence number for error or
                     closed connections, or NULL MAC.                    
                </comment>
                <comment line="1111">
                    Conservatively, close the connection immediately when the
                     sequence number is close to overflow                    
                </comment>
                <comment line="1116">
                    TLS protocols do not define a error alert for sequence
                     number overflow. We use handshake_failure error alert
                     for handshaking and bad_record_mac for other records.                    
                </comment>
                <comment line="1131">
                    Ask for renegotiation when need to renew sequence number.
                    
                     Don&apos;t bother to kickstart the renegotiation when the local is
                     asking for it.                    
                </comment>
                <scope line="1106"/>
                <scope line="1114">
                    <scope line="1120"/>
                </scope>
                <scope line="1136">
                    <scope line="1137"/>
                </scope>
            </method>
            <javadoc line="1150">
                Return the AppInputStream. For use by Handshaker only.                
            </javadoc>
            <method name="getAppInputStream" type="AppInputStream" line="1153"/>
            <javadoc line="1157">
                Return the AppOutputStream. For use by Handshaker only.                
            </javadoc>
            <method name="getAppOutputStream" type="AppOutputStream" line="1160"/>
            <javadoc line="1164">
                Initialize the handshaker object. This means:
                  . if a handshake is already in progress (state is cs_HANDSHAKE
                  or cs_RENEGOTIATE), do nothing and return
                  . if the socket is already closed, throw an Exception (internal error)
                  . otherwise (cs_START or cs_DATA), create the appropriate handshaker
                  object, and advance the connection state (to cs_HANDSHAKE or
                  cs_RENEGOTIATE, respectively).
                  This method is called right after a new socket is created, when
                  starting renegotiation, or when changing client/ server mode of the
                  socket.                
            </javadoc>
            <method name="initHandshaker" type="void" line="1180">
                <comment line="1184">
                    Starting a new handshake.                    
                </comment>
                <comment line="1191">
                    We&apos;re already in the middle of a handshake.                    
                </comment>
                <comment line="1198">
                    Anyone allowed to call this routine is required to
                     do so ONLY if the connection state is reasonable...                    
                </comment>
                <comment line="1206">
                    state is either cs_START or cs_DATA                    
                </comment>
                <comment line="1209">
                    cs_DATA                    
                </comment>
                <scope line="1206"/>
                <scope line="1208"/>
                <scope line="1211"/>
                <scope line="1216"/>
            </method>
            <javadoc line="1226">
                Synchronously perform the initial handshake.
                  If the handshake is already in progress, this method blocks until it
                  is completed. If the initial handshake has already been completed,
                  it returns immediately.                
            </javadoc>
            <method name="performInitialHandshake" type="void" line="1233">
                <comment line="1235">
                    use handshakeLock and the state check to make sure only
                     one thread performs the handshake                    
                </comment>
                <comment line="1241">
                    All initial handshaking goes through this
                     InputRecord until we have a valid SSL connection.
                     Once initial handshaking is finished, AppInputStream&apos;s
                     InputRecord can handle any future renegotiation.
                    
                     Keep this local so that it goes out of scope and is
                     eventually GC&apos;d.                    
                </comment>
                <comment line="1253">
                    Grab the characteristics already assigned to
                     AppInputStream&apos;s InputRecord.  Enable checking for
                     SSLv2 hellos on this first handshake.                    
                </comment>
                <scope line="1236">
                    <scope line="1237">
                        <scope line="1249"/>
                    </scope>
                </scope>
            </method>
            <javadoc line="1268">
                Starts an SSL handshake on this connection.                
            </javadoc>
            <method name="startHandshake" type="void" line="1271">
                <comment line="1273">
                    start an ssl handshake that could be resumed from timeout exception                    
                </comment>
            </method>
            <javadoc line="1276">
                Starts an ssl handshake on this connection.                
                <param>
                    resumable indicates the handshake process is resumable from a
                      certain exception. If <code>resumable</code>, the socket will
                      be reserved for exceptions like timeout; otherwise, the socket
                      will be closed, no further communications could be done.                    
                </param>
            </javadoc>
            <method name="startHandshake" type="void" line="1284">
                <params>
                    <param name="resumable" type="boolean"/>
                </params>
                <comment line="1289">
                    do initial handshake                    
                </comment>
                <comment line="1292">
                    start renegotiation                    
                </comment>
                <comment line="1296">
                    shutdown and rethrow (wrapped) exception as appropriate                    
                </comment>
                <scope line="1286">
                    <scope line="1287"/>
                    <scope line="1290"/>
                </scope>
                <scope line="1294"/>
            </method>
            <javadoc line="1300">
                Kickstart the handshake if it is not already in progress.
                  This means:
                  . if handshaking is already underway, do nothing and return
                  . if the socket is not connected or already closed, throw an
                  Exception.
                  . otherwise, call initHandshake() to initialize the handshaker
                  object and progress the state. Then, send the initial
                  handshaking message if appropriate (always on clients and
                  on servers when renegotiating).                
            </javadoc>
            <method name="kickstartHandshake" type="void" line="1314">
                <comment line="1320">
                    handshaker already setup, proceed                    
                </comment>
                <comment line="1336">
                    initialize the handshaker, move to cs_RENEGOTIATE                    
                </comment>
                <comment line="1341">
                    handshaking already in progress, return                    
                </comment>
                <comment line="1344">
                    The only way to get a socket in the state is when
                     you have an unconnected socket.                    
                </comment>
                <comment line="1356">
                    Kickstart handshake state machine if we need to ...
                    
                     Note that handshaker.kickstart() writes the message
                     to its HandshakeOutStream, which calls back into
                     SSLSocketImpl.writeRecord() to send it.                    
                </comment>
                <comment line="1364">
                    prior to handshaking, activate the handshake                    
                </comment>
                <comment line="1366">
                    don&apos;t use SSLv2Hello when renegotiating                    
                </comment>
                <comment line="1373">
                    send client hello                    
                </comment>
                <comment line="1377">
                    initial handshake, no kickstart message to send                    
                </comment>
                <comment line="1379">
                    we want to renegotiate, send hello request                    
                </comment>
                <comment line="1381">
                    hello request is not included in the handshake
                     hashes, reset them                    
                </comment>
                <scope line="1323"/>
                <scope line="1328">
                    <scope line="1329"/>
                </scope>
                <scope line="1362">
                    <scope line="1364"/>
                    <scope line="1367"/>
                    <scope line="1371"/>
                    <scope line="1374">
                        <scope line="1375"/>
                        <scope line="1377"/>
                    </scope>
                </scope>
            </method>
            <javadoc line="1392">
                Return whether the socket has been explicitly closed by the application.                
            </javadoc>
            <method name="isClosed" type="boolean" line="1395"/>
            <javadoc line="1399">
                Return whether we have reached end-of-file.
                  If the socket is not connected, has been shutdown because of an error
                  or has been closed, throw an Exception.                
            </javadoc>
            <method name="checkEOF" type="boolean" line="1405">
                <comment line="1423">
                    either closed because of error, or normal EOF                    
                </comment>
                <scope line="1423"/>
                <declaration name="e" type="IOException" line="1426"/>
            </method>
            <javadoc line="1434">
                Check if we can write data to this socket. If not, throw an IOException.                
            </javadoc>
            <method name="checkWrite" type="void" line="1437">
                <comment line="1440">
                    we are at EOF, write must throw Exception                    
                </comment>
                <scope line="1438"/>
            </method>
            <method name="closeSocket" type="void" line="1444">
                <scope line="1446"/>
                <scope line="1449"/>
                <scope line="1451"/>
            </method>
            <method name="closeSocket" type="void" line="1456">
                <params>
                    <param name="selfInitiated" type="boolean"/>
                </params>
                <comment line="1466">
                    layered &amp;&amp; non-autoclose
                     read close_notify alert to clear input stream                    
                </comment>
                <scope line="1457"/>
                <scope line="1460"/>
                <scope line="1462"/>
                <scope line="1464"/>
            </method>
            <javadoc line="1478">
                Closes the SSL connection.  SSL includes an application level
                  shutdown handshake; you should close SSL sockets explicitly
                  rather than leaving it for finalization, so that your remote
                  peer does not experience a protocol error.                
            </javadoc>
            <method name="close" type="void" line="1484">
                <comment line="1489">
                    caller is initiating close                    
                </comment>
                <scope line="1485"/>
            </method>
            <javadoc line="1492">
                Don&apos;t synchronize the whole method because waitForClose()
                  (which calls readRecord()) might be called.                
                <param>
                    selfInitiated Indicates which party initiated the close.
                      If selfInitiated, this side is initiating a close; for layered and
                      non-autoclose socket, wait for close_notify response.
                      If !selfInitiated, peer sent close_notify; we reciprocate but
                      no need to wait for response.                    
                </param>
            </javadoc>
            <method name="closeInternal" type="void" line="1502">
                <params>
                    <param name="selfInitiated" type="boolean"/>
                </params>
                <comment line="1514">
                    java.net code sometimes closes sockets &quot;early&quot;, when
                     we can&apos;t actually do IO on them.                    
                </comment>
                <comment line="1521">
                    If we&apos;re closing down due to error, we already sent (or else
                     received) the fatal alert ... no niceties, blow the connection
                     away as quickly as possible (even if we didn&apos;t allocate the
                     socket ourselves; it&apos;s unusable, regardless).                    
                </comment>
                <comment line="1531">
                    Sometimes close() gets called more than once.                    
                </comment>
                <comment line="1538">
                    Otherwise we indicate clean termination.                    
                </comment>
                <comment line="1541">
                    case cs_HANDSHAKE:
                     case cs_DATA:
                     case cs_RENEGOTIATE:
                     case cs_SENT_CLOSE:                    
                </comment>
                <comment line="1549">
                    connection was closed while we waited                    
                </comment>
                <comment line="1556">
                    we need to ensure socket is closed out
                     if we encounter any errors.                    
                </comment>
                <comment line="1559">
                    cache this for later use                    
                </comment>
                <comment line="1566">
                    If state was cs_SENT_CLOSE before, we don&apos;t do the actual
                     closing since it is already in progress.                    
                </comment>
                <comment line="1575">
                    We were called because a close_notify message was
                     received. This may be due to another thread calling
                     read() or due to our call to waitForClose() below.
                     In either case, just return.                    
                </comment>
                <comment line="1581">
                    Another thread explicitly called close(). We need to
                     wait for the closing to complete before returning.                    
                </comment>
                <comment line="1588">
                    ignore                    
                </comment>
                <comment line="1609">
                    Upon exit from this method, the state is always &gt;= cs_CLOSED                    
                </comment>
                <comment line="1612">
                    notify any threads waiting for the closing to finish                    
                </comment>
                <comment line="1616">
                    Dispose of ciphers since we&apos;ve closed socket                    
                </comment>
                <comment line="1620">
                    Rethrow the error to the calling method
                     The Throwable caught can only be an Error or RuntimeException                    
                </comment>
                <scope line="1503"/>
                <declaration name="state" type="int" line="1508"/>
                <declaration name="closeSocketCalled" type="boolean" line="1509"/>
                <declaration name="cachedThrowable" type="Throwable" line="1510"/>
                <scope line="1511">
                    <scope line="1545">
                        <scope line="1547"/>
                        <scope line="1550">
                            <scope line="1551"/>
                            <scope line="1554"/>
                        </scope>
                    </scope>
                    <scope line="1567">
                        <scope line="1568"/>
                        <scope line="1573"/>
                        <scope line="1582">
                            <scope line="1583">
                                <scope line="1584"/>
                                <scope line="1586"/>
                            </scope>
                        </scope>
                        <scope line="1591"/>
                    </scope>
                    <scope line="1599"/>
                </scope>
                <scope line="1606">
                    <scope line="1607"/>
                    <scope line="1614"/>
                    <scope line="1618"/>
                </scope>
            </method>
            <javadoc line="1631">
                Reads a close_notify or a fatal alert from the input stream.
                  Keep reading records until we get a close_notify or until
                  the connection is otherwise closed.  The close_notify or alert
                  might be read by another reader,
                  which will then process the close and set the connection state.                
            </javadoc>
            <method name="waitForClose" type="void" line="1638">
                <params>
                    <param name="rethrow" type="boolean"/>
                </params>
                <comment line="1651">
                    create the InputRecord if it isn&apos;t intialized.                    
                </comment>
                <comment line="1656">
                    Ask for app data and then throw it away                    
                </comment>
                <comment line="1660">
                    if time out, ignore the exception and continue                    
                </comment>
                <comment line="1670">
                    pass exception up                    
                </comment>
                <scope line="1639"/>
                <scope line="1645">
                    <declaration name="state" type="int" line="1646"/>
                    <scope line="1649">
                        <scope line="1651"/>
                        <scope line="1656"/>
                        <scope line="1658"/>
                    </scope>
                </scope>
                <scope line="1663">
                    <scope line="1664"/>
                    <scope line="1668"/>
                </scope>
            </method>
            <javadoc line="1674">
                Called by closeInternal() only. Be sure to consider the
                  synchronization locks carefully before calling it elsewhere.                
            </javadoc>
            <method name="disposeCiphers" type="void" line="1678">
                <comment line="1680">
                    See comment in changeReadCiphers()                    
                </comment>
                <comment line="1684">
                    See comment in changeReadCiphers()                    
                </comment>
                <scope line="1680"/>
                <scope line="1685"/>
                <scope line="1687"/>
            </method>
            <javadoc line="1696">
                Handle an exception. This method is called by top level exception
                  handlers (in read(), write()) to make sure we always shutdown the
                  connection correctly and do not pass runtime exception to the
                  application.                
            </javadoc>
            <method name="handleException" type="void" line="1702">
                <params>
                    <param name="e" type="Exception"/>
                </params>
            </method>
            <javadoc line="1706">
                Handle an exception. This method is called by top level exception
                  handlers (in read(), write(), startHandshake()) to make sure we
                  always shutdown the connection correctly and do not pass runtime
                  exception to the application.
                  This method never returns normally, it always throws an IOException.
                  We first check if the socket has already been shutdown because of an
                  error. If so, we just rethrow the exception. If the socket has not
                  been shutdown, we sent a fatal alert and remember the exception.                
                <param>
                    e the Exception                    
                </param>
                <param>
                    resumable indicates the caller process is resumable from the
                      exception. If <code>resumable</code>, the socket will be
                      reserved for exceptions like timeout; otherwise, the socket
                      will be closed, no further communications could be done.                    
                </param>
            </javadoc>
            <method name="handleException" type="void" line="1725">
                <params>
                    <param name="e" type="Exception"/>
                    <param name="resumable" type="boolean"/>
                </params>
                <comment line="1732">
                    don&apos;t close the Socket in case of timeouts or interrupts if
                     the process is resumable.                    
                </comment>
                <comment line="1738">
                    if we&apos;ve already shutdown because of an error,
                     there is nothing to do except rethrow the exception                    
                </comment>
                <comment line="1741">
                    includes SSLException                    
                </comment>
                <comment line="1744">
                    this is odd, not an IOException.
                     normally, this should not happen
                     if closeReason has been already been set                    
                </comment>
                <comment line="1752">
                    need to perform error shutdown                    
                </comment>
                <comment line="1755">
                    IOException from the socket
                     this means the TCP connection is already dead
                     we call fatal just to set the error status                    
                </comment>
                <comment line="1761">
                    ignore (IOException wrapped in SSLException)                    
                </comment>
                <comment line="1763">
                    rethrow original IOException                    
                </comment>
                <comment line="1767">
                    must be SSLException or RuntimeException                    
                </comment>
                <scope line="1726"/>
                <scope line="1733"/>
                <scope line="1739">
                    <scope line="1740"/>
                    <scope line="1742"/>
                </scope>
                <declaration name="isSSLException" type="boolean" line="1752"/>
                <scope line="1753">
                    <scope line="1757"/>
                    <scope line="1759"/>
                </scope>
                <declaration name="alertType" type="byte" line="1767"/>
                <scope line="1768">
                    <scope line="1769"/>
                    <scope line="1771"/>
                </scope>
                <scope line="1774"/>
            </method>
            <method name="warning" type="void" line="1783">
                <params>
                    <param name="description" type="byte"/>
                </params>
            </method>
            <method name="fatal" type="void" line="1788">
                <params>
                    <param name="description" type="byte"/>
                    <param name="diagnostic" type="String"/>
                </params>
            </method>
            <method name="fatal" type="void" line="1793">
                <params>
                    <param name="description" type="byte"/>
                    <param name="cause" type="Throwable"/>
                </params>
            </method>
            <method name="fatal" type="void" line="1802">
                <params>
                    <param name="description" type="byte"/>
                    <param name="diagnostic" type="String"/>
                    <param name="cause" type="Throwable"/>
                </params>
                <comment line="1817">
                    Has there been an error received yet?  If not, remember it.
                     By RFC 2246, we don&apos;t bother waiting for a response.
                     Fatal errors require immediate shutdown.                    
                </comment>
                <comment line="1823">
                    Try to clear the kernel buffer to avoid TCP connection resets.                    
                </comment>
                <comment line="1830">
                    If the description equals -1, the alert won&apos;t be sent to peer.                    
                </comment>
                <comment line="1834">
                    only true if != null                    
                </comment>
                <comment line="1842">
                    Clean up our side.                    
                </comment>
                <comment line="1846">
                    Another thread may have disposed the ciphers during closing                    
                </comment>
                <comment line="1851">
                    We should lock readLock and writeLock if no deadlock risks.
                     See comment in changeReadCiphers()                    
                </comment>
                <scope line="1803"/>
                <scope line="1807"/>
                <declaration name="oldState" type="int" line="1811"/>
                <scope line="1812"/>
                <scope line="1821">
                    <scope line="1825"/>
                    <scope line="1830"/>
                    <scope line="1833"/>
                    <scope line="1835"/>
                </scope>
                <scope line="1846"/>
            </method>
            <method name="recvAlert" type="void" line="1864">
                <params>
                    <param name="r" type="InputRecord"/>
                </params>
                <comment line="1868">
                    check for short message                    
                </comment>
                <comment line="1894">
                    reply to close                    
                </comment>
                <comment line="1898">
                    The other legal warnings relate to certificates,
                     e.g. no_certificate, bad_certificate, etc; these
                     are important to the handshaking code, which can
                     also handle illegal protocol alerts if needed.                    
                </comment>
                <comment line="1908">
                    fatal or unknown level                    
                </comment>
                <declaration name="level" type="byte" line="1865"/>
                <declaration name="description" type="byte" line="1866"/>
                <scope line="1867"/>
                <scope line="1872">
                    <scope line="1873">
                        <scope line="1876"/>
                        <scope line="1878"/>
                        <scope line="1880"/>
                    </scope>
                </scope>
                <scope line="1887">
                    <scope line="1888">
                        <scope line="1889"/>
                        <scope line="1892"/>
                    </scope>
                    <scope line="1895">
                        <scope line="1903"/>
                    </scope>
                </scope>
                <scope line="1907">
                    <declaration name="reason" type="String" line="1908"/>
                    <scope line="1910"/>
                </scope>
            </method>
            <method name="sendAlert" type="void" line="1921">
                <params>
                    <param name="level" type="byte"/>
                    <param name="description" type="byte"/>
                </params>
                <comment line="1923">
                    the connectionState cannot be cs_START                    
                </comment>
                <comment line="1928">
                    For initial handshaking, don&apos;t send alert message to peer if
                     handshaker has not started.                    
                </comment>
                <scope line="1923"/>
                <scope line="1930"/>
                <declaration name="r" type="OutputRecord" line="1934"/>
                <declaration name="useDebug" type="boolean" line="1937"/>
                <scope line="1938">
                    <scope line="1939">
                        <scope line="1942"/>
                        <scope line="1944"/>
                        <scope line="1946"/>
                    </scope>
                </scope>
                <scope line="1956"/>
                <scope line="1958">
                    <scope line="1959"/>
                </scope>
            </method>
            <method name="changeReadCiphers" type="void" line="1983">
                <comment line="1991">
                    ... create decompressor                    
                </comment>
                <comment line="1999">
                    &quot;can&apos;t happen&quot;                    
                </comment>
                <comment line="2004">
                    Dispose of any intermediate state in the underlying cipher.
                     For PKCS11 ciphers, this will release any attached sessions,
                     and thus make finalization faster.
                    
                     Since MAC&apos;s doFinal() is called for every SSLTLS packet, it&apos;s
                     not necessary to do the same with MAC&apos;s.                    
                </comment>
                <scope line="1985"/>
                <declaration name="oldCipher" type="CipherBox" line="1992"/>
                <scope line="1994"/>
                <scope line="1997"/>
            </method>
            <method name="changeWriteCiphers" type="void" line="2015">
                <comment line="2023">
                    ... create compressor                    
                </comment>
                <comment line="2031">
                    &quot;can&apos;t happen&quot;                    
                </comment>
                <comment line="2036">
                    See comment above.                    
                </comment>
                <scope line="2017"/>
                <declaration name="oldCipher" type="CipherBox" line="2024"/>
                <scope line="2026"/>
                <scope line="2029"/>
            </method>
            <method name="setVersion" type="void" line="2043">
                <params>
                    <param name="protocolVersion" type="ProtocolVersion"/>
                </params>
            </method>
            <method name="getHost" type="String" line="2048">
                <comment line="2050">
                    Note that the host may be null or empty for localhost.                    
                </comment>
                <scope line="2050"/>
            </method>
            <method name="getRawHostname" type="String" line="2056"/>
            <method name="setHost" type="void" line="2061">
                <params>
                    <param name="host" type="String"/>
                </params>
            </method>
            <javadoc line="2066">
                Gets an input stream to read from the peer on the other side.
                  Data read from this stream was always integrity protected in
                  transit, and will usually have been confidentiality protected.                
            </javadoc>
            <method name="getInputStream" type="InputStream" line="2071">
                <comment line="2077">
                    Can&apos;t call isConnected() here, because the Handshakers
                     do some initialization before we actually connect.                    
                </comment>
                <scope line="2072"/>
                <scope line="2080"/>
            </method>
            <javadoc line="2087">
                Gets an output stream to write to the peer on the other side.
                  Data written on this stream is always integrity protected, and
                  will usually be confidentiality protected.                
            </javadoc>
            <method name="getOutputStream" type="OutputStream" line="2092">
                <comment line="2098">
                    Can&apos;t call isConnected() here, because the Handshakers
                     do some initialization before we actually connect.                    
                </comment>
                <scope line="2093"/>
                <scope line="2101"/>
            </method>
            <javadoc line="2108">
                Returns the the SSL Session in use by this connection.  These can
                  be long lived, and frequently correspond to an entire login session
                  for some user.                
            </javadoc>
            <method name="getSession" type="SSLSession" line="2113">
                <comment line="2115">
                    Force a synchronous handshake, if appropriate.                    
                </comment>
                <comment line="2120">
                    start handshaking, if failed, the connection will be closed.                    
                </comment>
                <comment line="2123">
                    handshake failed. log and return a nullSession                    
                </comment>
                <scope line="2117">
                    <scope line="2118"/>
                    <scope line="2121">
                        <scope line="2123"/>
                    </scope>
                </scope>
                <scope line="2129"/>
            </method>
            <method name="getHandshakeSession" type="SSLSession" line="2135"/>
            <method name="setHandshakeSession" type="void" line="2139">
                <params>
                    <param name="session" type="SSLSessionImpl"/>
                </params>
            </method>
            <javadoc line="2143">
                Controls whether new connections may cause creation of new SSL
                  sessions.
                  As long as handshaking has not started, we can change
                  whether we enable session creations.  Otherwise,
                  we will need to wait for the next handshake.                
            </javadoc>
            <method name="setEnableSessionCreation" type="void" line="2151">
                <params>
                    <param name="flag" type="boolean"/>
                </params>
                <scope line="2154"/>
            </method>
            <javadoc line="2159">
                Returns true if new connections may cause creation of new SSL
                  sessions.                
            </javadoc>
            <method name="getEnableSessionCreation" type="boolean" line="2163"/>
            <javadoc line="2168">
                Sets the flag controlling whether a server mode socket
                  REQUIRES SSL client authentication.
                  As long as handshaking has not started, we can change
                  whether client authentication is needed.  Otherwise,
                  we will need to wait for the next handshake.                
            </javadoc>
            <method name="setNeedClientAuth" type="void" line="2176">
                <params>
                    <param name="flag" type="boolean"/>
                </params>
                <scope line="2182"/>
            </method>
            <method name="getNeedClientAuth" type="boolean" line="2187"/>
            <javadoc line="2191">
                Sets the flag controlling whether a server mode socket
                  REQUESTS SSL client authentication.
                  As long as handshaking has not started, we can change
                  whether client authentication is requested.  Otherwise,
                  we will need to wait for the next handshake.                
            </javadoc>
            <method name="setWantClientAuth" type="void" line="2199">
                <params>
                    <param name="flag" type="boolean"/>
                </params>
                <scope line="2205"/>
            </method>
            <method name="getWantClientAuth" type="boolean" line="2210"/>
            <javadoc line="2215">
                Sets the flag controlling whether the socket is in SSL
                  client or server mode.  Must be called before any SSL
                  traffic has started.                
            </javadoc>
            <method name="setUseClientMode" type="void" line="2220">
                <params>
                    <param name="flag" type="boolean"/>
                </params>
                <comment line="2225">
                    If we need to change the socket mode and the enabled
                     protocols haven&apos;t specifically been set by the user,
                     change them to the corresponding default ones.                    
                </comment>
                <comment line="2238">
                    If we have a handshaker, but haven&apos;t started
                     SSL traffic, we can throw away our current
                     handshaker, and start from scratch.  Don&apos;t
                     need to call doneConnect() again, we already
                     have the streams.                    
                </comment>
                <comment line="2247">
                    If we need to change the socket mode and the enabled
                     protocols haven&apos;t specifically been set by the user,
                     change them to the corresponding default ones.                    
                </comment>
                <comment line="2262">
                    If handshake has started, that&apos;s an error.  Fall through...                    
                </comment>
                <scope line="2230"/>
                <scope line="2245">
                    <scope line="2252"/>
                </scope>
                <scope line="2264"/>
            </method>
            <method name="getUseClientMode" type="boolean" line="2274"/>
            <javadoc line="2279">
                Returns the names of the cipher suites which could be enabled for use
                  on an SSL connection.  Normally, only a subset of these will actually
                  be enabled by default, since this list may include cipher suites which
                  do not support the mutual authentication of servers and clients, or
                  which do not protect data confidentiality.  Servers may also need
                  certain kinds of certificates to use certain cipher suites.                
                <return>
                    an array of cipher suite names                    
                </return>
            </javadoc>
            <method name="getSupportedCipherSuites" type="String[]" line="2289"/>
            <javadoc line="2293">
                Controls which particular cipher suites are enabled for use on
                  this connection.  The cipher suites must have been listed by
                  getCipherSuites() as being supported.  Even if a suite has been
                  enabled, it might never be used if no peer supports it or the
                  requisite certificates (and private keys) are not available.                
                <param>
                    suites Names of all the cipher suites to enable.                    
                </param>
            </javadoc>
            <method name="setEnabledCipherSuites" type="void" line="2302">
                <params>
                    <param name="suites" type="String[]"/>
                </params>
                <scope line="2304"/>
            </method>
            <javadoc line="2309">
                Returns the names of the SSL cipher suites which are currently enabled
                  for use on this connection.  When an SSL socket is first created,
                  all enabled cipher suites &lt;em&gt;(a)&lt;/em&gt; protect data confidentiality,
                  by traffic encryption, and &lt;em&gt;(b)&lt;/em&gt; can mutually authenticate
                  both clients and servers.  Thus, in some environments, this value
                  might be empty.                
                <return>
                    an array of cipher suite names                    
                </return>
            </javadoc>
            <method name="getEnabledCipherSuites" type="String[]" line="2319"/>
            <javadoc line="2324">
                Returns the protocols that are supported by this implementation.
                  A subset of the supported protocols may be enabled for this connection                
                <return>
                    an array of protocol names.                    
                </return>
            </javadoc>
            <method name="getSupportedProtocols" type="String[]" line="2329"/>
            <javadoc line="2333">
                Controls which protocols are enabled for use on
                  this connection.  The protocols must have been listed by
                  getSupportedProtocols() as being supported.                
                <param>
                    protocols protocols to enable.                    
                </param>
                <exception>
                    IllegalArgumentException when one of the protocols
                      named by the parameter is not supported.                    
                </exception>
            </javadoc>
            <method name="setEnabledProtocols" type="void" line="2342">
                <params>
                    <param name="protocols" type="String[]"/>
                </params>
                <scope line="2344"/>
            </method>
            <method name="getEnabledProtocols" type="String[]" line="2349"/>
            <javadoc line="2353">
                Assigns the socket timeout.                
                <see>
                    java.net.Socket#setSoTimeout                    
                </see>
            </javadoc>
            <method name="setSoTimeout" type="void" line="2357">
                <params>
                    <param name="timeout" type="int"/>
                </params>
                <scope line="2358"/>
                <scope line="2362"/>
                <scope line="2364"/>
            </method>
            <javadoc line="2369">
                Registers an event listener to receive notifications that an
                  SSL handshake has completed on this connection.                
            </javadoc>
            <method name="addHandshakeCompletedListener" type="void" line="2374">
                <params>
                    <param name="listener" type="HandshakeCompletedListener"/>
                </params>
                <scope line="2375"/>
                <scope line="2378"/>
            </method>
            <javadoc line="2386">
                Removes a previously registered handshake completion listener.                
            </javadoc>
            <method name="removeHandshakeCompletedListener" type="void" line="2390">
                <params>
                    <param name="listener" type="HandshakeCompletedListener"/>
                </params>
                <scope line="2391"/>
                <scope line="2394"/>
                <scope line="2397"/>
            </method>
            <javadoc line="2402">
                Returns the SSLParameters in effect for this SSLSocket.                
            </javadoc>
            <method name="getSSLParameters" type="SSLParameters" line="2405">
                <comment line="2409">
                    the super implementation does not handle the following parameters                    
                </comment>
                <declaration name="params" type="SSLParameters" line="2406"/>
            </method>
            <javadoc line="2415">
                Applies SSLParameters to this socket.                
            </javadoc>
            <method name="setSSLParameters" type="void" line="2418">
                <params>
                    <param name="params" type="SSLParameters"/>
                </params>
                <comment line="2422">
                    the super implementation does not handle the following parameters                    
                </comment>
                <scope line="2424"/>
            </method>
            <class name="NotifyHandshakeThread" line="2435">
                <extends class="Thread"/>
                <comment line="2439">
                    who gets notified                    
                </comment>
                <comment line="2440">
                    the notification                    
                </comment>
                <declaration name="targets" type="Set&lt;Map.Entry&lt;HandshakeCompletedListener,AccessControlContext&gt;&gt;" line="2437"/>
                <declaration name="event" type="HandshakeCompletedEvent" line="2439"/>
                <method name="NotifyHandshakeThread" type="constructor" line="2443">
                    <params>
                        <param name="entrySet" type="Set<Map.Entry<HandshakeCompletedListener,AccessControlContext>>"/>
                        <param name="e" type="HandshakeCompletedEvent"/>
                    </params>
                </method>
                <method name="run" type="void" line="2450">
                    <scope line="2452">
                        <declaration name="l" type="HandshakeCompletedListener" line="2454"/>
                        <declaration name="acc" type="AccessControlContext" line="2455"/>
                        <anonymous_class line="2456">
                            <method name="run" type="Void" line="2457"/>
                        </anonymous_class>
                    </scope>
                </method>
            </class>
            <javadoc line="2466">
                Return the name of the current thread. Utility method.                
            </javadoc>
            <method name="threadName" type="String" line="2469"/>
            <javadoc line="2473">
                Returns a printable representation of this end of the connection.                
            </javadoc>
            <method name="toString" type="String" line="2476">
                <declaration name="retval" type="StringBuffer" line="2477"/>
                <scope line="2484"/>
                <scope line="2486"/>
            </method>
        </class>
    </source>