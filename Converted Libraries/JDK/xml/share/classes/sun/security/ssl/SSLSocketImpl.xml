<?xml version="1.0" encoding="UTF-8"?>
    <source package="sun.security.ssl">
        <import package="java.io"/>
        <import package="java.net"/>
        <import package="java.security.GeneralSecurityException"/>
        <import package="java.security.AccessController"/>
        <import package="java.security.AccessControlContext"/>
        <import package="java.security.PrivilegedAction"/>
        <import package="java.security.AlgorithmConstraints"/>
        <import package="java.util"/>
        <import package="java.util.concurrent.TimeUnit"/>
        <import package="java.util.concurrent.locks.ReentrantLock"/>
        <import package="javax.crypto.BadPaddingException"/>
        <import package="javax.net.ssl"/>
        <import package="com.sun.net.ssl.internal.ssl.X509ExtendedTrustManager"/>
        <class name="SSLSocketImpl" line="15">
            <extends class="BaseSSLSocketImpl"/>
            <javadoc line="15">
                Implementation of an SSL socket.  This is a normal connection type
                  socket, implementing SSL over some lower level socket, such as TCP.
                  Because it is layered over some lower level socket, it MUST override
                  all default socket methods.
                  &lt;P&gt; This API offers a non-traditional option for establishing SSL
                  connections.  You may first establish the connection directly, then pass
                  that connection to the SSL socket constructor with a flag saying which
                  role should be taken in the handshake protocol.  (The two ends of the
                  connection must not choose the same role!)  This allows setup of SSL
                  proxying or tunneling, and also allows the kind of &quot;role reversal&quot;
                  that is required for most FTP data transfers.                
                <see>
                    javax.net.ssl.SSLSocket                    
                </see>
                <see>
                    SSLServerSocket                    
                </see>
                <author>
                    David Brownell                    
                </author>
            </javadoc>
            <declaration name="cs_START" type="int" line="32"/>
            <declaration name="cs_HANDSHAKE" type="int" line="33"/>
            <declaration name="cs_DATA" type="int" line="34"/>
            <declaration name="cs_RENEGOTIATE" type="int" line="35"/>
            <declaration name="cs_ERROR" type="int" line="36"/>
            <declaration name="cs_SENT_CLOSE" type="int" line="37"/>
            <declaration name="cs_CLOSED" type="int" line="38"/>
            <declaration name="cs_APP_CLOSED" type="int" line="39"/>
            <declaration name="connectionState" type="int" line="40"/>
            <declaration name="expectingFinished" type="boolean" line="41"/>
            <declaration name="closeReason" type="SSLException" line="42"/>
            <declaration name="doClientAuth" type="byte" line="43"/>
            <declaration name="roleIsServer" type="boolean" line="44"/>
            <declaration name="enableSessionCreation" type="boolean" line="45"/>
            <declaration name="host" type="String" line="46"/>
            <declaration name="autoClose" type="boolean" line="47"/>
            <declaration name="acc" type="AccessControlContext" line="48"/>
            <declaration name="rawHostname" type="String" line="49"/>
            <declaration name="enabledCipherSuites" type="CipherSuiteList" line="50"/>
            <declaration name="identificationProtocol" type="String" line="51"/>
            <declaration name="algorithmConstraints" type="AlgorithmConstraints" line="52"/>
            <declaration name="handshakeLock" type="Object" line="53"/>
            <declaration name="writeLock" type="ReentrantLock" line="54"/>
            <declaration name="readLock" type="Object" line="55"/>
            <declaration name="inrec" type="InputRecord" line="56"/>
            <declaration name="readMAC" type="MAC" line="57"/>
            <declaration name="readCipher" type="CipherBox" line="58"/>
            <declaration name="secureRenegotiation" type="boolean" line="59"/>
            <declaration name="clientVerifyData" type="byte[]" line="60"/>
            <declaration name="serverVerifyData" type="byte[]" line="61"/>
            <declaration name="sslContext" type="SSLContextImpl" line="62"/>
            <declaration name="handshaker" type="Handshaker" line="63"/>
            <declaration name="sess" type="SSLSessionImpl" line="64"/>
            <declaration name="handshakeSession" type="SSLSessionImpl" line="65"/>
            <declaration name="handshakeListeners" type="HashMap&amp;lt;HandshakeCompletedListener,AccessControlContext&amp;gt;" line="66"/>
            <declaration name="sockInput" type="InputStream" line="67"/>
            <declaration name="sockOutput" type="OutputStream" line="68"/>
            <declaration name="input" type="AppInputStream" line="69"/>
            <declaration name="output" type="AppOutputStream" line="70"/>
            <declaration name="enabledProtocols" type="ProtocolList" line="71"/>
            <declaration name="protocolVersion" type="ProtocolVersion" line="72"/>
            <declaration name="debug" type="Debug" line="73"/>
            <javadoc line="74">
                Constructs an SSL connection to a named host at a specified port,
                  using the authentication context provided.  This endpoint acts as
                  the client, and may rejoin an existing SSL session if appropriate.                
                <param>
                    context authentication context to use                    
                </param>
                <param>
                    host name of the host with which to connect                    
                </param>
                <param>
                    port number of the server&apos;s port                    
                </param>
            </javadoc>
            <method name="SSLSocketImpl" type="constructor" line="82">
                <params>
                    <param name="context" type="SSLContextImpl"/>
                    <param name="host" type="String"/>
                    <param name="port" type="int"/>
                </params>
                <declaration name="socketAddress" type="SocketAddress" line="87"/>
            </method>
            <javadoc line="90">
                Constructs an SSL connection to a server at a specified address.
                  and TCP port, using the authentication context provided.  This
                  endpoint acts as the client, and may rejoin an existing SSL session
                  if appropriate.                
                <param>
                    context authentication context to use                    
                </param>
                <param>
                    address the server&apos;s host                    
                </param>
                <param>
                    port its port                    
                </param>
            </javadoc>
            <method name="SSLSocketImpl" type="constructor" line="99">
                <params>
                    <param name="context" type="SSLContextImpl"/>
                    <param name="host" type="InetAddress"/>
                    <param name="port" type="int"/>
                </params>
                <declaration name="socketAddress" type="SocketAddress" line="102"/>
            </method>
            <javadoc line="105">
                Constructs an SSL connection to a named host at a specified port,
                  using the authentication context provided.  This endpoint acts as
                  the client, and may rejoin an existing SSL session if appropriate.                
                <param>
                    context authentication context to use                    
                </param>
                <param>
                    host name of the host with which to connect                    
                </param>
                <param>
                    port number of the server&apos;s port                    
                </param>
                <param>
                    localAddr the local address the socket is bound to                    
                </param>
                <param>
                    localPort the local port the socket is bound to                    
                </param>
            </javadoc>
            <method name="SSLSocketImpl" type="constructor" line="115">
                <params>
                    <param name="context" type="SSLContextImpl"/>
                    <param name="host" type="String"/>
                    <param name="port" type="int"/>
                    <param name="localAddr" type="InetAddress"/>
                    <param name="localPort" type="int"/>
                </params>
                <declaration name="socketAddress" type="SocketAddress" line="121"/>
            </method>
            <javadoc line="124">
                Constructs an SSL connection to a server at a specified address.
                  and TCP port, using the authentication context provided.  This
                  endpoint acts as the client, and may rejoin an existing SSL session
                  if appropriate.                
                <param>
                    context authentication context to use                    
                </param>
                <param>
                    address the server&apos;s host                    
                </param>
                <param>
                    port its port                    
                </param>
                <param>
                    localAddr the local address the socket is bound to                    
                </param>
                <param>
                    localPort the local port the socket is bound to                    
                </param>
            </javadoc>
            <method name="SSLSocketImpl" type="constructor" line="135">
                <params>
                    <param name="context" type="SSLContextImpl"/>
                    <param name="host" type="InetAddress"/>
                    <param name="port" type="int"/>
                    <param name="localAddr" type="InetAddress"/>
                    <param name="localPort" type="int"/>
                </params>
                <declaration name="socketAddress" type="SocketAddress" line="139"/>
            </method>
            <method name="SSLSocketImpl" type="constructor" line="142">
                <params>
                    <param name="context" type="SSLContextImpl"/>
                    <param name="serverMode" type="boolean"/>
                    <param name="suites" type="CipherSuiteList"/>
                    <param name="clientAuth" type="byte"/>
                    <param name="sessionCreation" type="boolean"/>
                    <param name="protocols" type="ProtocolList"/>
                    <param name="identificationProtocol" type="String"/>
                    <param name="algorithmConstraints" type="AlgorithmConstraints"/>
                </params>
            </method>
            <javadoc line="152">
                Package-private constructor used to instantiate an unconnected
                  socket. The java.net package will connect it, either when the
                  connect() call is made by the application.  This instance is
                  meant to set handshake state to use &quot;client mode&quot;.                
            </javadoc>
            <method name="SSLSocketImpl" type="constructor" line="158">
                <params>
                    <param name="context" type="SSLContextImpl"/>
                </params>
            </method>
            <javadoc line="162">
                Layer SSL traffic over an existing connection, rather than creating
                  a new connection.  The existing connection may be used only for SSL
                  traffic (using this SSLSocket) until the SSLSocket.close() call
                  returns. However, if a protocol error is detected, that existing
                  connection is automatically closed.
                  &lt;P&gt; This particular constructor always uses the socket in the
                  role of an SSL client. It may be useful in cases which start
                  using SSL after some initial data transfers, for example in some
                  SSL tunneling applications or as part of some kinds of application
                  protocols which negotiate use of a SSL based security.                
                <param>
                    sock the existing connection                    
                </param>
                <param>
                    context the authentication context to use                    
                </param>
            </javadoc>
            <method name="SSLSocketImpl" type="constructor" line="176">
                <params>
                    <param name="context" type="SSLContextImpl"/>
                    <param name="sock" type="Socket"/>
                    <param name="host" type="String"/>
                    <param name="port" type="int"/>
                    <param name="autoClose" type="boolean"/>
                </params>
                <scope line="178"/>
            </method>
            <javadoc line="187">
                Initializes the client socket.                
            </javadoc>
            <method name="init" type="void" line="190">
                <params>
                    <param name="context" type="SSLContextImpl"/>
                    <param name="isServer" type="boolean"/>
                </params>
            </method>
            <javadoc line="210">
                Connects this socket to the server with a specified timeout
                  value.
                  This method is either called on an unconnected SSLSocketImpl by the
                  application, or it is called in the constructor of a regular
                  SSLSocketImpl. If we are layering on top on another socket, then
                  this method should not be called, because we assume that the
                  underlying socket is already connected by the time it is passed to
                  us.                
                <param>
                    endpoint the &lt;code&gt;SocketAddress&lt;/code&gt;                    
                </param>
                <param>
                    timeout  the timeout value to be used, 0 is no timeout                    
                </param>
                <throws>
                    IOException if an error occurs during the connection                    
                </throws>
                <throws>
                    SocketTimeoutException if timeout expires before connecting                    
                </throws>
            </javadoc>
            <method name="connect" type="void" line="224">
                <params>
                    <param name="endpoint" type="SocketAddress"/>
                    <param name="timeout" type="int"/>
                </params>
                <scope line="225"/>
                <scope line="228"/>
            </method>
            <javadoc line="234">
                Initialize the handshaker and socket streams.
                  Called by connect, the layered constructor, and SSLServerSocket.                
            </javadoc>
            <method name="doneConnect" type="void" line="238">
                <scope line="239"/>
                <scope line="243"/>
            </method>
            <method name="getConnectionState" type="int" line="249"/>
            <method name="setConnectionState" type="void" line="252">
                <params>
                    <param name="state" type="int"/>
                </params>
            </method>
            <method name="getAcc" type="AccessControlContext" line="255"/>
            <method name="writeRecord" type="void" line="258">
                <params>
                    <param name="r" type="OutputRecord"/>
                </params>
                <scope line="259">
                    <scope line="273"/>
                    <scope line="276"/>
                </scope>
                <scope line="283">
                    <scope line="284">
                        <declaration name="interrupted" type="boolean" line="285"/>
                        <scope line="286">
                            <scope line="287">
                                <scope line="288"/>
                                <scope line="291"/>
                            </scope>
                            <scope line="295">
                                <declaration name="ssle" type="SSLException" line="296"/>
                                <scope line="297"/>
                                <scope line="300"/>
                            </scope>
                        </scope>
                        <scope line="306"/>
                        <scope line="309"/>
                    </scope>
                    <scope line="313">
                        <scope line="315"/>
                        <scope line="318"/>
                    </scope>
                </scope>
            </method>
            <method name="writeRecordInternal" type="void" line="324">
                <params>
                    <param name="r" type="OutputRecord"/>
                </params>
                <scope line="328"/>
            </method>
            <method name="readDataRecord" type="void" line="332">
                <params>
                    <param name="r" type="InputRecord"/>
                </params>
                <scope line="333"/>
            </method>
            <method name="readRecord" type="void" line="338">
                <params>
                    <param name="r" type="InputRecord"/>
                    <param name="needAppData" type="boolean"/>
                </params>
                <declaration name="state" type="int" line="339"/>
                <scope line="340">
                    <scope line="341">
                        <scope line="342"/>
                        <scope line="346">
                            <scope line="347"/>
                            <scope line="350"/>
                        </scope>
                        <scope line="354">
                            <declaration name="handshaking" type="boolean" line="355"/>
                            <declaration name="rethrow" type="boolean" line="356"/>
                            <scope line="357"/>
                            <scope line="360">
                                <declaration name="e" type="SSLException" line="361"/>
                                <scope line="362"/>
                                <scope line="365"/>
                            </scope>
                            <scope line="371"/>
                        </scope>
                        <scope line="376"/>
                        <scope line="379">
                            <declaration name="alertType" type="byte" line="381"/>
                        </scope>
                        <scope line="384">
                            <scope line="385"/>
                            <scope line="388"/>
                        </scope>
                        <scope line="392">
                            <scope line="396">
                                <scope line="397"/>
                                <scope line="400"/>
                            </scope>
                            <scope line="406">
                                <scope line="408"/>
                            </scope>
                            <scope line="412">
                                <scope line="420">
                                    <declaration name="event" type="HandshakeCompletedEvent" line="421"/>
                                    <declaration name="t" type="Thread" line="422"/>
                                </scope>
                            </scope>
                            <scope line="426"/>
                            <scope line="431"/>
                            <scope line="434"/>
                            <scope line="437"/>
                            <scope line="446"/>
                            <scope line="453"/>
                            <scope line="458"/>
                        </scope>
                    </scope>
                </scope>
            </method>
            <javadoc line="468">
                Check the sequence number state
                  RFC 4346 states that, &quot;Sequence numbers are of type uint64 and
                  may not exceed 2^64-1.  Sequence numbers do not wrap. If a TLS
                  implementation would need to wrap a sequence number, it must
                  renegotiate instead.&quot;                
            </javadoc>
            <method name="checkSequenceNumber" type="void" line="475">
                <params>
                    <param name="mac" type="MAC"/>
                    <param name="type" type="byte"/>
                </params>
                <scope line="476"/>
                <scope line="479">
                    <scope line="480"/>
                </scope>
                <scope line="485">
                    <scope line="486"/>
                </scope>
            </method>
            <javadoc line="492">
                Return the AppInputStream. For use by Handshaker only.                
            </javadoc>
            <method name="getAppInputStream" type="AppInputStream" line="495"/>
            <javadoc line="498">
                Return the AppOutputStream. For use by Handshaker only.                
            </javadoc>
            <method name="getAppOutputStream" type="AppOutputStream" line="501"/>
            <javadoc line="504">
                Initialize the handshaker object. This means:
                  . if a handshake is already in progress (state is cs_HANDSHAKE
                  or cs_RENEGOTIATE), do nothing and return
                  . if the socket is already closed, throw an Exception (internal error)
                  . otherwise (cs_START or cs_DATA), create the appropriate handshaker
                  object, and advance the connection state (to cs_HANDSHAKE or
                  cs_RENEGOTIATE, respectively).
                  This method is called right after a new socket is created, when
                  starting renegotiation, or when changing client/ server mode of the
                  socket.                
            </javadoc>
            <method name="initHandshaker" type="void" line="516">
                <scope line="527"/>
                <scope line="530"/>
                <scope line="533"/>
                <scope line="536"/>
            </method>
            <javadoc line="542">
                Synchronously perform the initial handshake.
                  If the handshake is already in progress, this method blocks until it
                  is completed. If the initial handshake has already been completed,
                  it returns immediately.                
            </javadoc>
            <method name="performInitialHandshake" type="void" line="548">
                <scope line="549">
                    <scope line="550">
                        <scope line="552"/>
                    </scope>
                </scope>
            </method>
            <javadoc line="563">
                Starts an SSL handshake on this connection.                
            </javadoc>
            <method name="startHandshake" type="void" line="566"/>
            <javadoc line="569">
                Starts an ssl handshake on this connection.                
                <param>
                    resumable indicates the handshake process is resumable from a
                      certain exception. If &lt;code&gt;resumable&lt;/code&gt;, the socket will
                      be reserved for exceptions like timeout; otherwise, the socket
                      will be closed, no further communications could be done.                    
                </param>
            </javadoc>
            <method name="startHandshake" type="void" line="576">
                <params>
                    <param name="resumable" type="boolean"/>
                </params>
                <scope line="578">
                    <scope line="579"/>
                    <scope line="582"/>
                </scope>
                <scope line="586"/>
            </method>
            <javadoc line="590">
                Kickstart the handshake if it is not already in progress.
                  This means:
                  . if handshaking is already underway, do nothing and return
                  . if the socket is not connected or already closed, throw an
                  Exception.
                  . otherwise, call initHandshake() to initialize the handshaker
                  object and progress the state. Then, send the initial
                  handshaking message if appropriate (always on clients and
                  on servers when renegotiating).                
            </javadoc>
            <method name="kickstartHandshake" type="void" line="601">
                <scope line="606"/>
                <scope line="609">
                    <scope line="610"/>
                </scope>
                <scope line="623">
                    <scope line="624"/>
                    <scope line="627"/>
                    <scope line="630"/>
                    <scope line="633">
                        <scope line="634"/>
                        <scope line="636"/>
                    </scope>
                </scope>
            </method>
            <javadoc line="643">
                Return whether the socket has been explicitly closed by the application.                
            </javadoc>
            <method name="isClosed" type="boolean" line="646"/>
            <javadoc line="649">
                Return whether we have reached end-of-file.
                  If the socket is not connected, has been shutdown because of an error
                  or has been closed, throw an Exception.                
            </javadoc>
            <method name="checkEOF" type="boolean" line="654">
                <scope line="668"/>
                <declaration name="e" type="IOException" line="671"/>
            </method>
            <javadoc line="676">
                Check if we can write data to this socket. If not, throw an IOException.                
            </javadoc>
            <method name="checkWrite" type="void" line="679">
                <scope line="680"/>
            </method>
            <method name="closeSocket" type="void" line="684">
                <scope line="685"/>
                <scope line="688"/>
                <scope line="691"/>
            </method>
            <method name="closeSocket" type="void" line="695">
                <params>
                    <param name="selfInitiated" type="boolean"/>
                </params>
                <scope line="696"/>
                <scope line="699"/>
                <scope line="702"/>
                <scope line="705"/>
            </method>
            <javadoc line="709">
                Closes the SSL connection.  SSL includes an application level
                  shutdown handshake; you should close SSL sockets explicitly
                  rather than leaving it for finalization, so that your remote
                  peer does not experience a protocol error.                
            </javadoc>
            <method name="close" type="void" line="715">
                <scope line="716"/>
            </method>
            <javadoc line="722">
                Don&apos;t synchronize the whole method because waitForClose()
                  (which calls readRecord()) might be called.                
                <param>
                    selfInitiated Indicates which party initiated the close.
                      If selfInitiated, this side is initiating a close; for layered and
                      non-autoclose socket, wait for close_notify response.
                      If !selfInitiated, peer sent close_notify; we reciprocate but
                      no need to wait for response.                    
                </param>
            </javadoc>
            <method name="closeInternal" type="void" line="731">
                <params>
                    <param name="selfInitiated" type="boolean"/>
                </params>
                <scope line="732"/>
                <declaration name="state" type="int" line="735"/>
                <declaration name="closeSocketCalled" type="boolean" line="736"/>
                <declaration name="cachedThrowable" type="Throwable" line="737"/>
                <scope line="738">
                    <scope line="749">
                        <scope line="750"/>
                        <scope line="753">
                            <scope line="754"/>
                            <scope line="758"/>
                        </scope>
                    </scope>
                    <scope line="766">
                        <scope line="767"/>
                        <scope line="770"/>
                        <scope line="773">
                            <scope line="774">
                                <scope line="775"/>
                                <scope line="778"/>
                            </scope>
                        </scope>
                        <scope line="782"/>
                    </scope>
                    <scope line="787"/>
                </scope>
                <scope line="794">
                    <scope line="795"/>
                    <scope line="799"/>
                    <scope line="802"/>
                </scope>
            </method>
            <javadoc line="808">
                Reads a close_notify or a fatal alert from the input stream.
                  Keep reading records until we get a close_notify or until
                  the connection is otherwise closed.  The close_notify or alert
                  might be read by another reader,
                  which will then process the close and set the connection state.                
            </javadoc>
            <method name="waitForClose" type="void" line="815">
                <params>
                    <param name="rethrow" type="boolean"/>
                </params>
                <scope line="816"/>
                <scope line="819">
                    <declaration name="state" type="int" line="820"/>
                    <scope line="821">
                        <scope line="822"/>
                        <scope line="825"/>
                        <scope line="828"/>
                    </scope>
                </scope>
                <scope line="833">
                    <scope line="834"/>
                    <scope line="837"/>
                </scope>
            </method>
            <javadoc line="842">
                Called by closeInternal() only. Be sure to consider the
                  synchronization locks carefully before calling it elsewhere.                
            </javadoc>
            <method name="disposeCiphers" type="void" line="846">
                <scope line="847"/>
                <scope line="851"/>
                <scope line="854"/>
            </method>
            <javadoc line="858">
                Handle an exception. This method is called by top level exception
                  handlers (in read(), write()) to make sure we always shutdown the
                  connection correctly and do not pass runtime exception to the
                  application.                
            </javadoc>
            <method name="handleException" type="void" line="864">
                <params>
                    <param name="e" type="Exception"/>
                </params>
            </method>
            <javadoc line="867">
                Handle an exception. This method is called by top level exception
                  handlers (in read(), write(), startHandshake()) to make sure we
                  always shutdown the connection correctly and do not pass runtime
                  exception to the application.
                  This method never returns normally, it always throws an IOException.
                  We first check if the socket has already been shutdown because of an
                  error. If so, we just rethrow the exception. If the socket has not
                  been shutdown, we sent a fatal alert and remember the exception.                
                <param>
                    e the Exception                    
                </param>
                <param>
                    resumable indicates the caller process is resumable from the
                      exception. If &lt;code&gt;resumable&lt;/code&gt;, the socket will be
                      reserved for exceptions like timeout; otherwise, the socket
                      will be closed, no further communications could be done.                    
                </param>
            </javadoc>
            <method name="handleException" type="void" line="882">
                <params>
                    <param name="e" type="Exception"/>
                    <param name="resumable" type="boolean"/>
                </params>
                <scope line="883"/>
                <scope line="886"/>
                <scope line="889">
                    <scope line="890"/>
                    <scope line="893"/>
                </scope>
                <declaration name="isSSLException" type="boolean" line="897"/>
                <scope line="898">
                    <scope line="899"/>
                    <scope line="902"/>
                </scope>
                <declaration name="alertType" type="byte" line="906"/>
                <scope line="907">
                    <scope line="908"/>
                    <scope line="911"/>
                </scope>
                <scope line="915"/>
            </method>
            <method name="warning" type="void" line="920">
                <params>
                    <param name="description" type="byte"/>
                </params>
            </method>
            <method name="fatal" type="void" line="923">
                <params>
                    <param name="description" type="byte"/>
                    <param name="diagnostic" type="String"/>
                </params>
            </method>
            <method name="fatal" type="void" line="926">
                <params>
                    <param name="description" type="byte"/>
                    <param name="cause" type="Throwable"/>
                </params>
            </method>
            <method name="fatal" type="void" line="929">
                <params>
                    <param name="description" type="byte"/>
                    <param name="diagnostic" type="String"/>
                    <param name="cause" type="Throwable"/>
                </params>
                <scope line="930"/>
                <scope line="934"/>
                <declaration name="oldState" type="int" line="937"/>
                <scope line="938"/>
                <scope line="941">
                    <scope line="942"/>
                    <scope line="945"/>
                    <scope line="948"/>
                    <scope line="951"/>
                </scope>
                <scope line="956"/>
            </method>
            <method name="recvAlert" type="void" line="963">
                <params>
                    <param name="r" type="InputRecord"/>
                </params>
                <declaration name="level" type="byte" line="964"/>
                <declaration name="description" type="byte" line="965"/>
                <scope line="966"/>
                <scope line="969">
                    <scope line="970">
                        <scope line="973"/>
                        <scope line="976"/>
                        <scope line="979"/>
                    </scope>
                </scope>
                <scope line="985">
                    <scope line="986">
                        <scope line="987"/>
                        <scope line="990"/>
                    </scope>
                    <scope line="994">
                        <scope line="995"/>
                    </scope>
                </scope>
                <scope line="1000">
                    <declaration name="reason" type="String" line="1001"/>
                    <scope line="1002"/>
                </scope>
            </method>
            <method name="sendAlert" type="void" line="1008">
                <params>
                    <param name="level" type="byte"/>
                    <param name="description" type="byte"/>
                </params>
                <scope line="1009"/>
                <scope line="1012"/>
                <declaration name="r" type="OutputRecord" line="1015"/>
                <declaration name="useDebug" type="boolean" line="1017"/>
                <scope line="1018">
                    <scope line="1019">
                        <scope line="1022"/>
                        <scope line="1025"/>
                        <scope line="1028"/>
                    </scope>
                </scope>
                <scope line="1036"/>
                <scope line="1039">
                    <scope line="1040"/>
                </scope>
            </method>
            <method name="changeReadCiphers" type="void" line="1045">
                <scope line="1046"/>
                <declaration name="oldCipher" type="CipherBox" line="1049"/>
                <scope line="1050"/>
                <scope line="1054"/>
            </method>
            <method name="changeWriteCiphers" type="void" line="1059">
                <scope line="1060"/>
                <declaration name="oldCipher" type="CipherBox" line="1063"/>
                <scope line="1064"/>
                <scope line="1068"/>
            </method>
            <method name="setVersion" type="void" line="1073">
                <params>
                    <param name="protocolVersion" type="ProtocolVersion"/>
                </params>
            </method>
            <method name="getHost" type="String" line="1077">
                <scope line="1078"/>
            </method>
            <method name="getRawHostname" type="String" line="1083"/>
            <method name="setHost" type="void" line="1086">
                <params>
                    <param name="host" type="String"/>
                </params>
            </method>
            <javadoc line="1090">
                Gets an input stream to read from the peer on the other side.
                  Data read from this stream was always integrity protected in
                  transit, and will usually have been confidentiality protected.                
            </javadoc>
            <method name="getInputStream" type="InputStream" line="1095">
                <scope line="1096"/>
                <scope line="1099"/>
            </method>
            <javadoc line="1104">
                Gets an output stream to write to the peer on the other side.
                  Data written on this stream is always integrity protected, and
                  will usually be confidentiality protected.                
            </javadoc>
            <method name="getOutputStream" type="OutputStream" line="1109">
                <scope line="1110"/>
                <scope line="1113"/>
            </method>
            <javadoc line="1118">
                Returns the the SSL Session in use by this connection.  These can
                  be long lived, and frequently correspond to an entire login session
                  for some user.                
            </javadoc>
            <method name="getSession" type="SSLSession" line="1123">
                <scope line="1124">
                    <scope line="1125"/>
                    <scope line="1128">
                        <scope line="1129"/>
                    </scope>
                </scope>
                <scope line="1134"/>
            </method>
            <method name="getHandshakeSession" type="SSLSession" line="1138"/>
            <method name="setHandshakeSession" type="void" line="1141">
                <params>
                    <param name="session" type="SSLSessionImpl"/>
                </params>
            </method>
            <javadoc line="1144">
                Controls whether new connections may cause creation of new SSL
                  sessions.
                  As long as handshaking has not started, we can change
                  whether we enable session creations.  Otherwise,
                  we will need to wait for the next handshake.                
            </javadoc>
            <method name="setEnableSessionCreation" type="void" line="1151">
                <params>
                    <param name="flag" type="boolean"/>
                </params>
                <scope line="1153"/>
            </method>
            <javadoc line="1157">
                Returns true if new connections may cause creation of new SSL
                  sessions.                
            </javadoc>
            <method name="getEnableSessionCreation" type="boolean" line="1161"/>
            <javadoc line="1164">
                Sets the flag controlling whether a server mode socket
                  REQUIRES SSL client authentication.
                  As long as handshaking has not started, we can change
                  whether client authentication is needed.  Otherwise,
                  we will need to wait for the next handshake.                
            </javadoc>
            <method name="setNeedClientAuth" type="void" line="1171">
                <params>
                    <param name="flag" type="boolean"/>
                </params>
                <scope line="1173"/>
            </method>
            <method name="getNeedClientAuth" type="boolean" line="1177"/>
            <javadoc line="1180">
                Sets the flag controlling whether a server mode socket
                  REQUESTS SSL client authentication.
                  As long as handshaking has not started, we can change
                  whether client authentication is requested.  Otherwise,
                  we will need to wait for the next handshake.                
            </javadoc>
            <method name="setWantClientAuth" type="void" line="1187">
                <params>
                    <param name="flag" type="boolean"/>
                </params>
                <scope line="1189"/>
            </method>
            <method name="getWantClientAuth" type="boolean" line="1193"/>
            <javadoc line="1196">
                Sets the flag controlling whether the socket is in SSL
                  client or server mode.  Must be called before any SSL
                  traffic has started.                
            </javadoc>
            <method name="setUseClientMode" type="void" line="1201">
                <params>
                    <param name="flag" type="boolean"/>
                </params>
                <scope line="1204"/>
                <scope line="1211">
                    <scope line="1212"/>
                </scope>
                <scope line="1221"/>
            </method>
            <method name="getUseClientMode" type="boolean" line="1227"/>
            <javadoc line="1230">
                Returns the names of the cipher suites which could be enabled for use
                  on an SSL connection.  Normally, only a subset of these will actually
                  be enabled by default, since this list may include cipher suites which
                  do not support the mutual authentication of servers and clients, or
                  which do not protect data confidentiality.  Servers may also need
                  certain kinds of certificates to use certain cipher suites.                
                <return>
                    an array of cipher suite names                    
                </return>
            </javadoc>
            <method name="getSupportedCipherSuites" type="String[]" line="1239"/>
            <javadoc line="1242">
                Controls which particular cipher suites are enabled for use on
                  this connection.  The cipher suites must have been listed by
                  getCipherSuites() as being supported.  Even if a suite has been
                  enabled, it might never be used if no peer supports it or the
                  requisite certificates (and private keys) are not available.                
                <param>
                    suites Names of all the cipher suites to enable.                    
                </param>
            </javadoc>
            <method name="setEnabledCipherSuites" type="void" line="1250">
                <params>
                    <param name="suites" type="String[]"/>
                </params>
                <scope line="1252"/>
            </method>
            <javadoc line="1256">
                Returns the names of the SSL cipher suites which are currently enabled
                  for use on this connection.  When an SSL socket is first created,
                  all enabled cipher suites &lt;em&gt;(a)&lt;/em&gt; protect data confidentiality,
                  by traffic encryption, and &lt;em&gt;(b)&lt;/em&gt; can mutually authenticate
                  both clients and servers.  Thus, in some environments, this value
                  might be empty.                
                <return>
                    an array of cipher suite names                    
                </return>
            </javadoc>
            <method name="getEnabledCipherSuites" type="String[]" line="1265"/>
            <javadoc line="1268">
                Returns the protocols that are supported by this implementation.
                  A subset of the supported protocols may be enabled for this connection                
                <return>
                    an array of protocol names.                    
                </return>
            </javadoc>
            <method name="getSupportedProtocols" type="String[]" line="1273"/>
            <javadoc line="1276">
                Controls which protocols are enabled for use on
                  this connection.  The protocols must have been listed by
                  getSupportedProtocols() as being supported.                
                <param>
                    protocols protocols to enable.                    
                </param>
                <exception>
                    IllegalArgumentException when one of the protocols
                      named by the parameter is not supported.                    
                </exception>
            </javadoc>
            <method name="setEnabledProtocols" type="void" line="1284">
                <params>
                    <param name="protocols" type="String[]"/>
                </params>
                <scope line="1286"/>
            </method>
            <method name="getEnabledProtocols" type="String[]" line="1290"/>
            <javadoc line="1293">
                Assigns the socket timeout.                
                <see>
                    java.net.Socket#setSoTimeout                    
                </see>
            </javadoc>
            <method name="setSoTimeout" type="void" line="1297">
                <params>
                    <param name="timeout" type="int"/>
                </params>
                <scope line="1298"/>
                <scope line="1301"/>
                <scope line="1304"/>
            </method>
            <javadoc line="1308">
                Registers an event listener to receive notifications that an
                  SSL handshake has completed on this connection.                
            </javadoc>
            <method name="addHandshakeCompletedListener" type="void" line="1312">
                <params>
                    <param name="listener" type="HandshakeCompletedListener"/>
                </params>
                <scope line="1313"/>
                <scope line="1316"/>
            </method>
            <javadoc line="1321">
                Removes a previously registered handshake completion listener.                
            </javadoc>
            <method name="removeHandshakeCompletedListener" type="void" line="1324">
                <params>
                    <param name="listener" type="HandshakeCompletedListener"/>
                </params>
                <scope line="1325"/>
                <scope line="1328"/>
                <scope line="1331"/>
            </method>
            <javadoc line="1335">
                Returns the SSLParameters in effect for this SSLSocket.                
            </javadoc>
            <method name="getSSLParameters" type="SSLParameters" line="1338">
                <declaration name="params" type="SSLParameters" line="1339"/>
            </method>
            <javadoc line="1344">
                Applies SSLParameters to this socket.                
            </javadoc>
            <method name="setSSLParameters" type="void" line="1347">
                <params>
                    <param name="params" type="SSLParameters"/>
                </params>
                <scope line="1351"/>
            </method>
            <class name="NotifyHandshakeThread" line="1356">
                <extends class="Thread"/>
                <declaration name="targets" type="Set&amp;lt;Map.Entry&amp;lt;HandshakeCompletedListener,AccessControlContext&amp;gt;&amp;gt;" line="1357"/>
                <declaration name="event" type="HandshakeCompletedEvent" line="1358"/>
                <method name="NotifyHandshakeThread" type="constructor" line="1359">
                    <params>
                        <param name="entrySet" type="Set&lt;Map.Entry&lt;HandshakeCompletedListener,AccessControlContext&gt;&gt;"/>
                        <param name="e" type="HandshakeCompletedEvent"/>
                    </params>
                </method>
                <method name="run" type="void" line="1364">
                    <scope line="1365">
                        <declaration name="l" type="HandshakeCompletedListener" line="1366"/>
                        <declaration name="acc" type="AccessControlContext" line="1367"/>
                        <anonymous_class line="1368">
                            <method name="run" type="Void" line="1369"/>
                        </anonymous_class>
                    </scope>
                </method>
            </class>
            <javadoc line="1378">
                Return the name of the current thread. Utility method.                
            </javadoc>
            <method name="threadName" type="String" line="1381"/>
            <javadoc line="1384">
                Returns a printable representation of this end of the connection.                
            </javadoc>
            <method name="toString" type="String" line="1387">
                <declaration name="retval" type="StringBuffer" line="1388"/>
                <scope line="1393"/>
                <scope line="1396"/>
            </method>
        </class>
    </source>