<?xml version="1.0" encoding="UTF-8"?>
    <source package="sun.security.ssl">
        <import package="java.io"/>
        <import package="java.nio"/>
        <import package="javax.net.ssl.SSLException"/>
        <import package="sun.misc.HexDumpEncoder"/>
        <class name="EngineOutputRecord" line="36">
            <extends class="OutputRecord"/>
            <comment line="54">
                All handshake hashing is done by the superclass                
            </comment>
            <comment line="58">
                Default constructor makes a record supporting the maximum
                 SSL record size.  It allocates the header bytes directly.
                
                 @param type the content type for the record                
            </comment>
            <comment line="136">
                Encrypt a ByteBuffer.
                
                 We assume that the higher levels have assured us enough
                 room for the encryption (plus padding), otherwise we&apos;ll
                 indirectly throw a BufferOverFlowException runtime exception.
                
                 position and limit will be the same, and points to the
                 next free spot.                
            </comment>
            <comment line="150">
                Override the actual write below.  We do things this way to be
                 consistent with InputRecord.  InputRecord may try to write out
                 data to the peer, and then throw an Exception.  This forces
                 data to be generatedoutput before the exception is ever
                 generated.                
            </comment>
            <comment line="167">
                Main method for writing non-application data.
                 We MACencrypt, then send down for processing.                
            </comment>
            <javadoc line="36">
                A OutputRecord class extension which uses external ByteBuffers
                  or the internal ByteArrayOutputStream for data manipulations.
                  &lt;P&gt;
                  Instead of rewriting this entire class
                  to use ByteBuffers, we leave things intact, so handshake, CCS,
                  and alerts will continue to use the internal buffers, but application
                  data will use external buffers.                
                <author>
                    Brad Wetmore                    
                </author>
            </javadoc>
            <declaration name="writer" type="EngineWriter" line="49"/>
            <declaration name="finishedMsg" type="boolean" line="51"/>
            <method name="EngineOutputRecord" type="constructor" line="63">
                <params>
                    <param name="type" type="byte"/>
                    <param name="engine" type="SSLEngineImpl"/>
                </params>
            </method>
            <javadoc line="68">
                Get the size of the buffer we need for records of the specified
                  type.
                  &lt;P&gt;
                  Application data buffers will provide their own byte buffers,
                  and will not use the internal byte caching.                
            </javadoc>
            <method name="recordSize" type="int" line="75">
                <params>
                    <param name="type" type="byte"/>
                </params>
            </method>
            <method name="setFinishedMsg" type="void" line="92"/>
            <method name="flush" type="void" line="96"/>
            <method name="isFinishedMsg" type="boolean" line="100"/>
            <javadoc line="105">
                Calculate the MAC value, storing the result either in
                  the internal buffer, or at the end of the destination
                  ByteBuffer.
                  &lt;P&gt;
                  We assume that the higher levels have assured us enough
                  room, otherwise we&apos;ll indirectly throw a
                  BufferOverFlowException runtime exception.
                  position should equal limit, and points to the next
                  free spot.                
            </javadoc>
            <method name="addMAC" type="void" line="118">
                <params>
                    <param name="signer" type="MAC"/>
                    <param name="bb" type="ByteBuffer"/>
                </params>
                <comment line="123">
                    position was advanced to limit in compute above.
                    
                     Mark next area as writable (above layers should have
                     established that we have plenty of room), then write
                     out the hash.                    
                </comment>
                <scope line="120">
                    <declaration name="hash" type="byte[]" line="121"/>
                </scope>
            </method>
            <method name="encrypt" type="void" line="145">
                <params>
                    <param name="box" type="CipherBox"/>
                    <param name="bb" type="ByteBuffer"/>
                </params>
            </method>
            <method name="writeBuffer" type="void" line="157">
                <params>
                    <param name="s" type="OutputStream"/>
                    <param name="buf" type="byte[]"/>
                    <param name="off" type="int"/>
                    <param name="len" type="int"/>
                </params>
                <comment line="158">
                    Copy data out of buffer, it&apos;s ready to go.                    
                </comment>
                <declaration name="netBB" type="ByteBuffer" line="161"/>
            </method>
            <method name="write" type="void" line="170">
                <params>
                    <param name="writeMAC" type="MAC"/>
                    <param name="writeCipher" type="CipherBox"/>
                </params>
                <comment line="171">
                    Sanity check.                    
                </comment>
                <comment line="183">
                    Don&apos;t bother to really write empty records.  We went this
                     far to drive the handshake machinery, for correctness; not
                     writing empty records improves performance by cutting CPU
                     time and network resource usage.  Also, some protocol
                     implementations are fragile and don&apos;t like to see empty
                     records, so this increases robustness.
                    
                     (Even change cipher spec messages have a byte of data!)                    
                </comment>
                <comment line="194">
                    compress();              // eventually                    
                </comment>
                <comment line="197">
                    send down for processing                    
                </comment>
                <scope line="193"/>
            </method>
            <javadoc line="202">
                Main wrap/write driver.                
            </javadoc>
            <method name="write" type="void" line="206">
                <params>
                    <param name="ea" type="EngineArgs"/>
                    <param name="writeMAC" type="MAC"/>
                    <param name="writeCipher" type="CipherBox"/>
                </params>
                <comment line="207">
                    sanity check to make sure someone didn&apos;t inadvertantly
                     send us an impossible combination we don&apos;t know how
                     to process.                    
                </comment>
                <comment line="214">
                    Have we set the MAC&apos;s yet?  If not, we&apos;re not ready
                     to process application data yet.                    
                </comment>
                <comment line="222">
                    Don&apos;t bother to really write empty records.  We went this
                     far to drive the handshake machinery, for correctness; not
                     writing empty records improves performance by cutting CPU
                     time and network resource usage.  Also, some protocol
                     implementations are fragile and don&apos;t like to see empty
                     records, so this increases robustness.                    
                </comment>
                <comment line="235">
                    Copy out existing buffer values.                    
                </comment>
                <comment line="242">
                    Where to put the data.  Jump over the header.
                    
                     Don&apos;t need to worry about SSLv2 rewrites, if we&apos;re here,
                     that&apos;s long since done.                    
                </comment>
                <comment line="253">
                    &quot;flip&quot; but skip over header again, add MAC &amp; encrypt
                     addMAC will expand the limit to reflect the new
                     data.                    
                </comment>
                <comment line="262">
                    Encrypt may pad, so again the limit may have changed.                    
                </comment>
                <comment line="274">
                    v3.0/v3.1 ...                    
                </comment>
                <comment line="282">
                    Finish out the record header.                    
                </comment>
                <comment line="291">
                    Position was already set by encrypt() above.                    
                </comment>
                <scope line="218"/>
                <declaration name="length" type="int" line="230"/>
                <scope line="231"/>
                <declaration name="dstBB" type="ByteBuffer" line="238"/>
                <declaration name="dstPos" type="int" line="239"/>
                <declaration name="dstLim" type="int" line="240"/>
                <declaration name="dstData" type="int" line="248"/>
                <scope line="270"/>
                <declaration name="packetLength" type="int" line="280"/>
            </method>
        </class>
    </source>