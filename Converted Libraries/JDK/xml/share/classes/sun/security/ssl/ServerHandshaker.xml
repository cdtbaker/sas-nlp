<?xml version="1.0" encoding="UTF-8"?>
    <source package="sun.security.ssl">
        <import package="java.io"/>
        <import package="java.util"/>
        <import package="java.security"/>
        <import package="java.security.cert"/>
        <import package="java.security.interfaces"/>
        <import package="java.security.spec.ECParameterSpec"/>
        <import package="javax.crypto.SecretKey"/>
        <import package="javax.crypto.spec.SecretKeySpec"/>
        <import package="javax.net.ssl"/>
        <import package="javax.security.auth.Subject"/>
        <import package="sun.security.ssl.HandshakeMessage"/>
        <import package="sun.security.ssl.CipherSuite"/>
        <import package="sun.security.ssl.SignatureAndHashAlgorithm"/>
        <import package="sun.security.ssl.CipherSuite"/>
        <import package="sun.security.ssl.CipherSuite.KeyExchange"/>
        <class name="ServerHandshaker" line="49">
            <extends class="Handshaker"/>
            <comment line="60">
                is the server going to require the client to authenticate?                
            </comment>
            <comment line="63">
                our authentication info                
            </comment>
            <comment line="69">
                flag to check for clientCertificateVerify message                
            </comment>
            <comment line="72">
                For exportable ciphersuites using non-exportable key sizes, we use
                 ephemeral RSA keys. We could also do anonymous RSA in the same way
                 but there are no such ciphersuites currently defined.                
            </comment>
            <comment line="80">
                For anonymous and ephemeral Diffie-Hellman key exchange, we use
                 ephemeral Diffie-Hellman keys.                
            </comment>
            <comment line="86">
                Helper for ECDH based key exchanges                
            </comment>
            <comment line="89">
                version request by the client in its ClientHello
                 we remember it for the RSA premaster secret version check                
            </comment>
            <comment line="95">
                the preferable signature algorithm used by ServerKeyExchange message                
            </comment>
            <comment line="98">
                Constructor ... use the keys found in the auth context.                
            </comment>
            <comment line="114">
                Constructor ... use the keys found in the auth context.                
            </comment>
            <comment line="130">
                As long as handshaking has not started, we can change
                 whether client authentication is required.  Otherwise,
                 we will need to wait for the next handshake.                
            </comment>
            <comment line="139">
                This routine handles all the server side handshake messages, one at
                 a time.  Given the message type (and in some cases the pending cipher
                 spec) it parses the type-specific message.  Then it calls a function
                 that handles that specific message.
                
                 It updates the state machine as each message is processed, and writes
                 responses as needed using the connection in the constructor.                
            </comment>
            <comment line="265">
                ClientHello presents the server with a bunch of options, to which the
                 server replies with a ServerHello listing the ones which this session
                 will use.  If needed, it also writes its Certificate plus in some cases
                 a ServerKeyExchange message.  It may also write a CertificateRequest,
                 to elicit a client certificate.
                
                 All these messages are terminated by a ServerHelloDone message.  In
                 most cases, all this can be sent in a single Record.                
            </comment>
            <comment line="872">
                Choose cipher suite from among those supported by client. Sets
                 the cipherSuite and keyExchange variables.                
            </comment>
            <comment line="1146">
                Get some &quot;ephemeral&quot; RSA keys for this context. This means
                 generating them if it&apos;s not already been done.
                
                 Note that we currently do not implement any ciphersuites that use
                 strong ephemeral RSA. (We do not support the EXPORT1024 ciphersuites
                 and standard RSA ciphersuites prohibit ephemeral mode for some reason)
                 This means that export is always true and 512 bit keys are generated.                
            </comment>
            <comment line="1167">
                Acquire some &quot;ephemeral&quot; Diffie-Hellman  keys for this handshake.
                 We don&apos;t reuse these, for improved forward secrecy.                
            </comment>
            <comment line="1182">
                Setup the ephemeral ECDH parameters.
                 If we cannot continue because we do not support any of the curves that
                 the client requested, return false. Otherwise (all is well), return true.                
            </comment>
            <comment line="1326">
                For Kerberos ciphers, the premaster secret is encrypted using
                 the session key. See RFC 2712.                
            </comment>
            <comment line="1345">
                Diffie Hellman key exchange is used when the server presented
                 D-H parameters in its certificate (signed using RSA or DSSDSA),
                 or else the server presented no certificate but sent D-H params
                 in a ServerKeyExchange message.  Use of D-H is specified by the
                 cipher suite chosen.
                
                 The message optionally contains the client&apos;s D-H public key (if
                 it wasn&apos;t not sent in a client certificate).  As always with D-H,
                 if a client and a server have each other&apos;s D-H public keys and
                 they use common algorithm parameters, they have a shared key
                 that&apos;s derived via the D-H calculation.  That key becomes the
                 pre-master secret.                
            </comment>
            <comment line="1377">
                Client wrote a message to verify the certificate it sent earlier.
                
                 Note that this certificate isn&apos;t involved in key exchange.  Client
                 authentication messages are included in the checksums used to
                 validate the handshake (e.g. Finished messages).  Other than that,
                 the _exact_ identity of the client is less fundamental to protocol
                 security than its role in selecting keys via the pre-master secret.                
            </comment>
            <comment line="1431">
                Client writes &quot;finished&quot; at the end of its handshake, after cipher
                 spec is changed.   We verify it and then send ours.
                
                 When we&apos;re resuming a session, we&apos;ll have already sent our own
                 Finished message so just the verification is needed.                
            </comment>
            <comment line="1512">
                Compute finished message with the &quot;server&quot; digest (and then forget
                 about that digest, it can&apos;t be used again).                
            </comment>
            <comment line="1550">
                Returns a HelloRequest message to kickstart renegotiations                
            </comment>
            <comment line="1558">
                Fault detected during handshake.                
            </comment>
            <comment line="1586">
                RSA key exchange is normally used.  The client encrypts a &quot;pre-master
                 secret&quot; with the server&apos;s public key, from the Certificate (or else
                 ServerKeyExchange) message that was sent to it by the server.  That&apos;s
                 decrypted using the private key before we get here.                
            </comment>
            <comment line="1601">
                Verify the certificate sent by the client. We&apos;ll only get one if we
                 sent a CertificateRequest to request client authentication. If we
                 are in TLS mode, the client may send a message with no certificates
                 to indicate it does not have an appropriate chain. (In SSLv3 mode,
                 it would send a no certificate alert).                
            </comment>
            <javadoc line="49">
                ServerHandshaker does the protocol handshaking from the point
                  of view of a server.  It is driven asychronously by handshake messages
                  as delivered by the parent Handshaker class, and also uses
                  common functionality (e.g. key generation) that is provided there.                
                <author>
                    David Brownell                    
                </author>
            </javadoc>
            <declaration name="doClientAuth" type="byte" line="60"/>
            <declaration name="certs" type="X509Certificate[]" line="63"/>
            <declaration name="privateKey" type="PrivateKey" line="64"/>
            <declaration name="kerberosKeys" type="SecretKey[]" line="66"/>
            <declaration name="needClientVerify" type="boolean" line="69"/>
            <declaration name="tempPrivateKey" type="PrivateKey" line="76"/>
            <declaration name="tempPublicKey" type="PublicKey" line="77"/>
            <declaration name="dh" type="DHCrypt" line="83"/>
            <declaration name="ecdh" type="ECDHCrypt" line="86"/>
            <declaration name="clientRequestedVersion" type="ProtocolVersion" line="90"/>
            <declaration name="supportedCurves" type="SupportedEllipticCurvesExtension" line="92"/>
            <declaration name="preferableSignatureAlgorithm" type="SignatureAndHashAlgorithm" line="95"/>
            <method name="ServerHandshaker" type="constructor" line="104">
                <params>
                    <param name="socket" type="SSLSocketImpl"/>
                    <param name="context" type="SSLContextImpl"/>
                    <param name="enabledProtocols" type="ProtocolList"/>
                    <param name="clientAuth" type="byte"/>
                    <param name="activeProtocolVersion" type="ProtocolVersion"/>
                    <param name="isInitialHandshake" type="boolean"/>
                    <param name="secureRenegotiation" type="boolean"/>
                    <param name="clientVerifyData" type="byte[]"/>
                    <param name="serverVerifyData" type="byte[]"/>
                </params>
            </method>
            <method name="ServerHandshaker" type="constructor" line="120">
                <params>
                    <param name="engine" type="SSLEngineImpl"/>
                    <param name="context" type="SSLContextImpl"/>
                    <param name="enabledProtocols" type="ProtocolList"/>
                    <param name="clientAuth" type="byte"/>
                    <param name="activeProtocolVersion" type="ProtocolVersion"/>
                    <param name="isInitialHandshake" type="boolean"/>
                    <param name="secureRenegotiation" type="boolean"/>
                    <param name="clientVerifyData" type="byte[]"/>
                    <param name="serverVerifyData" type="byte[]"/>
                </params>
            </method>
            <method name="setClientAuth" type="void" line="134">
                <params>
                    <param name="clientAuth" type="byte"/>
                </params>
            </method>
            <method name="processMessage" type="void" line="148">
                <params>
                    <param name="type" type="byte"/>
                    <param name="message_len" type="int"/>
                </params>
                <comment line="150">
                    In SSLv3 and TLS, messages follow strictly increasing
                     numerical order _except_ for one annoying special case.                    
                </comment>
                <comment line="165">
                    send it off for processing.                    
                </comment>
                <comment line="175">
                    NOTREACHED                    
                </comment>
                <comment line="185">
                    The client&apos;s pre-master secret is decrypted using
                     either the server&apos;s normal private RSA key, or the
                     temporary one used for non-export or signing-only
                     certificateskeys.                    
                </comment>
                <comment line="209">
                    The pre-master secret is derived using the normal
                     Diffie-Hellman calculation.   Note that the main
                     protocol difference in these five flavors is in how
                     the ServerKeyExchange message was constructed!                    
                </comment>
                <comment line="231">
                    All keys are calculated from the premaster secret
                     and the exchanged nonces in the same way.                    
                </comment>
                <comment line="253">
                    Move the state machine forward except for that annoying
                     special case.  This means that clients could send extra
                     cert verify messages; not a problem so long as all of
                     them actually check out.                    
                </comment>
                <scope line="155"/>
                <declaration name="ch" type="ClientHello" line="163"/>
                <scope line="171"/>
                <declaration name="preMasterSecret" type="SecretKey" line="180"/>
                <declaration name="pms" type="RSAClientKeyExchange" line="190"/>
                <scope line="258"/>
            </method>
            <method name="clientHello" type="void" line="274">
                <params>
                    <param name="mesg" type="ClientHello"/>
                </params>
                <comment line="280">
                    Does the message include security renegotiation indication?                    
                </comment>
                <comment line="283">
                    check the TLS_EMPTY_RENEGOTIATION_INFO_SCSV                    
                </comment>
                <comment line="290">
                    abort the handshake with a fatal handshake_failure alert                    
                </comment>
                <comment line="301">
                    check the &quot;renegotiation_info&quot; extension                    
                </comment>
                <comment line="307">
                    verify the length of the &quot;renegotiated_connection&quot; field                    
                </comment>
                <comment line="309">
                    abort the handshake with a fatal handshake_failure alert                    
                </comment>
                <comment line="317">
                    unexpected RI extension for insecure renegotiation,
                     abort the handshake with a fatal handshake_failure alert                    
                </comment>
                <comment line="324">
                    verify the client_verify_data value                    
                </comment>
                <comment line="333">
                    if the connection&apos;s &quot;secure_renegotiation&quot; flag is set to TRUE
                     and the &quot;renegotiation_info&quot; extension is not present, abort
                     the handshake.                    
                </comment>
                <comment line="340">
                    if there is no security renegotiation indication or the previous
                     handshake is insecure.                    
                </comment>
                <comment line="345">
                    abort the handshake with a fatal handshake_failure alert                    
                </comment>
                <comment line="350">
                    continue with legacy ClientHello                    
                </comment>
                <comment line="356">
                    abort the handshake                    
                </comment>
                <comment line="358">
                    response with a no_renegotiation warning,                    
                </comment>
                <comment line="361">
                    invalidate the handshake so that the caller can
                     dispose this object.                    
                </comment>
                <comment line="365">
                    If there is still unread block in the handshake
                     input stream, it would be truncated with the disposal
                     and the next handshake message will become incomplete.
                    
                     However, according to SSL/TLS specifications, no more
                     handshake message could immediately follow ClientHello
                     or HelloRequest. But in case of any improper messages,
                     we&apos;d better check to ensure there is no remaining bytes
                     in the handshake input stream.                    
                </comment>
                <comment line="382">
                    For SSLv3, send the handshake_failure fatal error.
                     Note that SSLv3 does not define a no_renegotiation
                     alert like TLSv1. However we cannot ignore the message
                     simply, otherwise the other side was waiting for a
                     response that would never come.                    
                </comment>
                <comment line="390">
                    !isInitialHandshake &amp;&amp; allowUnsafeRenegotiation                    
                </comment>
                <comment line="391">
                    continue with unsafe renegotiation.                    
                </comment>
                <comment line="399">
                    Always make sure this entire record has been digested before we
                     start emitting output, to ensure correct digesting order.                    
                </comment>
                <comment line="405">
                    FIRST, construct the ServerHello using the options and priorities
                     from the ClientHello.  Update the (pending) cipher spec as we do
                     so, and save the client&apos;s version to protect against rollback
                     attacks.
                    
                     There are a bunch of minor tasks here, and one major one: deciding
                     if the short or the full handshake sequence will be used.                    
                </comment>
                <comment line="418">
                    select a proper protocol version.                    
                </comment>
                <comment line="433">
                    random ... save client and server values for later use
                     in computing the master secret (from pre-master secret)
                     and thence the other crypto keys.
                    
                     NOTE:  this use of three inputs to generating _each_ set
                     of ciphers slows things down, but it does increase the
                     security since each connection in the session can hold
                     its own authenticated (and strong) keys.  One could make
                     creation of a session a rare thing...                    
                </comment>
                <comment line="448">
                    forget about the current session                    
                </comment>
                <comment line="449">
                    Here we go down either of two paths:  (a) the fast one, where
                     the client&apos;s asked to rejoin an existing session, and the server
                     permits this; (b) the other one, where a new session is created.                    
                </comment>
                <comment line="455">
                    client is trying to resume a session, let&apos;s see...                    
                </comment>
                <comment line="460">
                    Check if we can use the fast path, resuming a session.  We
                     can do so iff we have a valid record for that session, and
                     the cipher suite for that session was on the list which the
                     client requested, and if we&apos;re not forgetting any needed
                     authentication on the part of the client.                    
                </comment>
                <comment line="472">
                    cannot resume session with different version                    
                </comment>
                <comment line="487">
                    validate subject identity                    
                </comment>
                <comment line="511">
                    Eliminate dependency on KerberosPrincipal                    
                </comment>
                <comment line="539">
                    verify that the ciphersuite from the cached session
                     is in the list of client requested ciphersuites and
                     we have it enabled                    
                </comment>
                <comment line="546">
                    everything looks ok, set the ciphersuite
                     this should be done last when we are sure we
                     will resume                    
                </comment>
                <comment line="561">
                    else client did not try to resume                    
                </comment>
                <comment line="563">
                    If client hasn&apos;t specified a session we can resume, start a
                     new one and choose its cipher suite and compression options.
                     Unless new session creation is disabled for this connection!                    
                </comment>
                <comment line="576">
                    We only need to handle the &quot;signature_algorithm&quot; extension
                     for full handshakes and TLS 1.2 or later.                    
                </comment>
                <comment line="601">
                    else, need to use peer implicit supported signature algs                    
                </comment>
                <comment line="613">
                    else, we will set the implicit peer supported signature
                     algorithms in chooseCipherSuite()                    
                </comment>
                <comment line="617">
                    set the handshake session                    
                </comment>
                <comment line="620">
                    choose cipher suite and corresponding private key                    
                </comment>
                <comment line="626">
                    chooseCompression(mesg);                    
                </comment>
                <comment line="628">
                    set the handshake session                    
                </comment>
                <comment line="644">
                    For ServerHellos that are initial handshakes, then the
                     &quot;renegotiated_connection&quot; field in &quot;renegotiation_info&quot;
                     extension is of zero length.
                    
                     For ServerHellos that are renegotiating, this field contains
                     the concatenation of client_verify_data and server_verify_data.
                    
                     Note that for initial handshakes, both the clientVerifyData
                     variable and serverVerifyData variable are of zero length.                    
                </comment>
                <comment line="664">
                    If we are resuming a session, we finish writing handshake
                     messages right now and then finish.                    
                </comment>
                <comment line="675">
                    SECOND, write the server Certificate(s) if we need to.
                    
                     NOTE:  while an &quot;anonymous RSA&quot; mode is explicitly allowed by
                     the protocol, we can&apos;t support it since all of the SSL flavors
                     defined in the protocol spec are explicitly stated to require
                     using RSA certificates.                    
                </comment>
                <comment line="684">
                    Server certificates are omitted for Kerberos ciphers                    
                </comment>
                <comment line="693">
                    Set local certs in the SSLSession, output
                     debug info, and then actually write to the client.                    
                </comment>
                <comment line="703">
                    XXX has some side effects with OS TCP buffering,
                     leave it out for now                    
                </comment>
                <comment line="706">
                    let client verify chain in the meantime...
                     output.flush();                    
                </comment>
                <comment line="714">
                    THIRD, the ServerKeyExchange message ... iff it&apos;s needed.
                    
                     It&apos;s usually needed unless there&apos;s an encryption-capable
                     RSA cert, or a D-H cert.  The notable exception is that
                     exportable ciphers used with big RSA keys need to downgrade
                     to use short RSA keys, even when the keycert encrypts OK.                    
                </comment>
                <comment line="728">
                    no server key exchange for RSA or KRB5 ciphersuites                    
                </comment>
                <comment line="742">
                    make compiler happy                    
                </comment>
                <comment line="745">
                    RSA_EXPORT with short key, don&apos;t need ServerKeyExchange                    
                </comment>
                <comment line="761">
                    make compiler happy                    
                </comment>
                <comment line="781">
                    make compiler happy                    
                </comment>
                <comment line="786">
                    ServerKeyExchange not used for fixed ECDH                    
                </comment>
                <comment line="799">
                    FOURTH, the CertificateRequest message.  The details of
                     the message can be affected by the key exchange algorithm
                     in use.  For example, certs with fixed Diffie-Hellman keys
                     are only useful with the DH_DSS and DH_RSA key exchange
                     algorithms.
                    
                     Needed only if server requires client to authenticate self.
                     Illegal for anonymous flavors, so we need to check that.
                    
                     CertificateRequest is omitted for Kerberos ciphers                    
                </comment>
                <comment line="819">
                    We currently use all local upported signature and hash
                     algorithms. However, to minimize the computation cost
                     of requested hash algorithms, we may use a restricted
                     set of signature algorithms in the future.                    
                </comment>
                <comment line="853">
                    FIFTH, say ServerHelloDone.                    
                </comment>
                <comment line="863">
                    Flush any buffered messages so the client will see them.
                     Ideally, all the messages above go in a single network level
                     message to the client.  Without big Certificate chains, it&apos;s
                     going to be the common case.                    
                </comment>
                <scope line="275"/>
                <declaration name="renegotiationIndicated" type="boolean" line="280"/>
                <declaration name="cipherSuites" type="CipherSuiteList" line="283"/>
                <scope line="284">
                    <scope line="286"/>
                    <scope line="288">
                        <scope line="290"/>
                        <scope line="293"/>
                    </scope>
                </scope>
                <declaration name="clientHelloRI" type="RenegotiationInfoExtension" line="301"/>
                <scope line="303">
                    <scope line="305">
                        <scope line="307"/>
                    </scope>
                    <scope line="314">
                        <scope line="315"/>
                        <scope line="325"/>
                    </scope>
                </scope>
                <scope line="331"/>
                <scope line="341">
                    <scope line="342">
                        <scope line="343"/>
                        <scope line="350"/>
                    </scope>
                    <scope line="354">
                        <scope line="356">
                            <scope line="373"/>
                        </scope>
                        <scope line="380"/>
                    </scope>
                    <scope line="389">
                        <scope line="391"/>
                    </scope>
                </scope>
                <declaration name="m1" type="ServerHello" line="413"/>
                <declaration name="selectedVersion" type="ProtocolVersion" line="418"/>
                <scope line="421"/>
                <scope line="453">
                    <declaration name="previous" type="SSLSessionImpl" line="456"/>
                    <scope line="466">
                        <scope line="469">
                            <declaration name="oldVersion" type="ProtocolVersion" line="470"/>
                            <scope line="472"/>
                        </scope>
                        <scope line="478">
                            <scope line="479"/>
                            <scope line="481"/>
                        </scope>
                        <scope line="487">
                            <declaration name="suite" type="CipherSuite" line="488"/>
                            <scope line="490">
                                <declaration name="localPrincipal" type="Principal" line="491"/>
                                <declaration name="subject" type="Subject" line="493"/>
                                <scope line="494">
                                    <anonymous_class line="496">
                                        <method name="run" type="Subject" line="497"/>
                                    </anonymous_class>
                                </scope>
                                <scope line="501">
                                    <scope line="503"/>
                                </scope>
                                <scope line="509">
                                    <declaration name="principals" type="Set&lt;Principal&gt;" line="511"/>
                                    <scope line="513">
                                        <scope line="515"/>
                                    </scope>
                                    <scope line="519"/>
                                </scope>
                                <scope line="524"/>
                            </scope>
                        </scope>
                        <scope line="536">
                            <declaration name="suite" type="CipherSuite" line="537"/>
                            <scope line="542"/>
                            <scope line="544"/>
                        </scope>
                        <scope line="552">
                            <scope line="555"/>
                        </scope>
                    </scope>
                </scope>
                <scope line="567">
                    <scope line="568"/>
                    <scope line="577">
                        <declaration name="signAlgs" type="SignatureAlgorithmsExtension" line="578"/>
                        <scope line="581">
                            <declaration name="peerSignAlgs" type="Collection&lt;SignatureAndHashAlgorithm&gt;" line="582"/>
                            <scope line="584"/>
                            <declaration name="supportedPeerSignAlgs" type="Collection&lt;SignatureAndHashAlgorithm&gt;" line="589"/>
                            <scope line="593"/>
                        </scope>
                    </scope>
                    <scope line="608">
                        <scope line="609"/>
                    </scope>
                </scope>
                <scope line="626"/>
                <scope line="631">
                    <scope line="632"/>
                </scope>
                <scope line="642">
                    <declaration name="serverHelloRI" type="HelloExtension" line="652"/>
                </scope>
                <scope line="657"/>
                <scope line="667"/>
                <scope line="682"/>
                <scope line="685">
                    <scope line="686"/>
                    <declaration name="m2" type="CertificateMsg" line="690"/>
                    <scope line="697"/>
                </scope>
                <scope line="707">
                    <scope line="708"/>
                </scope>
                <declaration name="m3" type="ServerKeyExchange" line="722"/>
                <scope line="731">
                    <scope line="732"/>
                    <scope line="738"/>
                </scope>
                <scope line="743"/>
                <scope line="750"/>
                <scope line="758"/>
                <scope line="769"/>
                <scope line="777"/>
                <scope line="791">
                    <scope line="792"/>
                </scope>
                <scope line="811">
                    <declaration name="m4" type="CertificateRequest" line="813"/>
                    <declaration name="caCerts" type="X509Certificate" line="814"/>
                    <declaration name="localSignAlgs" type="Collection&lt;SignatureAndHashAlgorithm&gt;" line="816"/>
                    <scope line="817">
                        <scope line="823"/>
                        <declaration name="localHashAlgs" type="Set&lt;String&gt;" line="828"/>
                        <scope line="831"/>
                    </scope>
                    <scope line="842"/>
                </scope>
                <scope line="846">
                    <scope line="847"/>
                </scope>
                <declaration name="m5" type="ServerHelloDone" line="855"/>
                <scope line="857"/>
            </method>
            <method name="chooseCipherSuite" type="void" line="875">
                <params>
                    <param name="mesg" type="ClientHello"/>
                </params>
                <scope line="876">
                    <scope line="877"/>
                    <scope line="881">
                        <scope line="883"/>
                    </scope>
                    <scope line="887"/>
                </scope>
            </method>
            <javadoc line="896">
                Set the given CipherSuite, if possible. Return the result.
                  The call succeeds if the CipherSuite is available and we have
                  the necessary certificates to complete the handshake. We don&apos;t
                  check if the CipherSuite is actually enabled.
                  If successful, this method also generates ephemeral keys if
                  required for this ciphersuite. This may take some time, so this
                  method should only be called if you really want to use the
                  CipherSuite.
                  This method is called from chooseCipherSuite() in this class.                
            </javadoc>
            <method name="trySetCipherSuite" type="boolean" line="909">
                <params>
                    <param name="suite" type="CipherSuite"/>
                </params>
                <comment line="911">
                    If we&apos;re resuming a session we know we can
                     support this key exchange algorithm and in fact
                     have already cached the result of it in
                     the session state.                    
                </comment>
                <comment line="925">
                    must not negotiate the obsoleted weak cipher suites.                    
                </comment>
                <comment line="930">
                    must not negotiate unsupported cipher suites.                    
                </comment>
                <comment line="937">
                    null out any existing references                    
                </comment>
                <comment line="951">
                    we may optimize the performance                    
                </comment>
                <comment line="953">
                    If the negotiated key exchange algorithm is one of
                     (RSA, DHE_RSA, DH_RSA, RSA_PSK, ECDH_RSA, ECDHE_RSA),
                     behave as if client had sent the value {sha1,rsa}.                    
                </comment>
                <comment line="959">
                    case K_RSA_PSK:                    
                </comment>
                <comment line="966">
                    If the negotiated key exchange algorithm is one of
                     (DHE_DSS, DH_DSS), behave as if the client had
                     sent the value {sha1,dsa}.                    
                </comment>
                <comment line="975">
                    If the negotiated key exchange algorithm is one of
                     (ECDH_ECDSA, ECDHE_ECDSA), behave as if the client
                     had sent value {sha1,ecdsa}.                    
                </comment>
                <comment line="985">
                    no peer supported signature algorithms                    
                </comment>
                <comment line="997">
                    Sets the peer supported signature algorithm to use in KM
                     temporarily.                    
                </comment>
                <comment line="1005">
                    need RSA certs for authentication                    
                </comment>
                <comment line="1011">
                    need RSA certs for authentication                    
                </comment>
                <comment line="1023">
                    could not determine keylength, ignore key                    
                </comment>
                <comment line="1028">
                    get preferable peer signature algorithm for server key exchange                    
                </comment>
                <comment line="1038">
                    need RSA certs for authentication                    
                </comment>
                <comment line="1045">
                    get preferable peer signature algorithm for server key exchange                    
                </comment>
                <comment line="1055">
                    need RSA certs for authentication                    
                </comment>
                <comment line="1064">
                    get preferable peer signature algorithm for server key exchange                    
                </comment>
                <comment line="1074">
                    need DSS certs for authentication                    
                </comment>
                <comment line="1081">
                    get preferable peer signature algorithm for server key exchange                    
                </comment>
                <comment line="1091">
                    need EC cert signed using EC                    
                </comment>
                <comment line="1100">
                    need EC cert signed using RSA                    
                </comment>
                <comment line="1107">
                    need EC cert signed using EC                    
                </comment>
                <comment line="1115">
                    need Kerberos Key                    
                </comment>
                <comment line="1121">
                    no certs needed for anonymous                    
                </comment>
                <comment line="1125">
                    no certs needed for anonymous                    
                </comment>
                <comment line="1131">
                    internal error, unknown key exchange                    
                </comment>
                <comment line="1136">
                    set the peer implicit supported signature algorithms                    
                </comment>
                <comment line="1140">
                    we had alreay update the session                    
                </comment>
                <scope line="916"/>
                <scope line="920"/>
                <scope line="925"/>
                <scope line="930"/>
                <declaration name="keyExchange" type="KeyExchange" line="934"/>
                <declaration name="supportedSignAlgs" type="Collection&lt;SignatureAndHashAlgorithm&gt;" line="943"/>
                <scope line="944">
                    <scope line="945"/>
                    <scope line="947">
                        <declaration name="algorithm" type="SignatureAndHashAlgorithm" line="948"/>
                        <scope line="987"/>
                        <scope line="990"/>
                    </scope>
                </scope>
                <scope line="1005"/>
                <scope line="1011"/>
                <scope line="1015">
                    <scope line="1016">
                        <scope line="1017"/>
                    </scope>
                </scope>
                <scope line="1021"/>
                <scope line="1028">
                    <scope line="1032"/>
                </scope>
                <scope line="1038"/>
                <scope line="1045">
                    <scope line="1049"/>
                </scope>
                <scope line="1055"/>
                <scope line="1058"/>
                <scope line="1064">
                    <scope line="1068"/>
                </scope>
                <scope line="1074"/>
                <scope line="1081">
                    <scope line="1085"/>
                </scope>
                <scope line="1091"/>
                <scope line="1094"/>
                <scope line="1100"/>
                <scope line="1107"/>
                <scope line="1115"/>
                <scope line="1125"/>
                <scope line="1136">
                    <scope line="1137"/>
                </scope>
            </method>
            <method name="setupEphemeralRSAKeys" type="boolean" line="1154">
                <params>
                    <param name="export" type="boolean"/>
                </params>
                <declaration name="kp" type="KeyPair" line="1155"/>
                <scope line="1157"/>
                <scope line="1159"/>
            </method>
            <method name="setupEphemeralDHKeys" type="void" line="1170">
                <params>
                    <param name="export" type="boolean"/>
                </params>
                <comment line="1172">
                    Diffie-Hellman keys ... we use 768 bit private keys due
                     to the &quot;use twice as many key bits as bits you want secret&quot;
                     rule of thumb, assuming we want the same size premaster
                     secret with Diffie-Hellman and RSA key exchanges.  Except
                     that exportable ciphers max out at 512 bits modulus values.                    
                </comment>
            </method>
            <method name="setupEphemeralECDHKeys" type="boolean" line="1184">
                <comment line="1188">
                    if the client sent the supported curves extension, pick the
                     first one that we support;                    
                </comment>
                <comment line="1197">
                    no match found, cannot use this ciphersuite                    
                </comment>
                <comment line="1201">
                    pick our preference                    
                </comment>
                <declaration name="index" type="int" line="1185"/>
                <scope line="1186">
                    <scope line="1189">
                        <scope line="1190"/>
                    </scope>
                    <scope line="1195"/>
                </scope>
                <scope line="1199"/>
                <declaration name="oid" type="String" line="1203"/>
            </method>
            <method name="setupStaticECDHKeys" type="void" line="1208">
                <comment line="1210">
                    don&apos;t need to check whether the curve is supported, already done
                     in setupPrivateKeyAndChain().                    
                </comment>
            </method>
            <javadoc line="1214">
                Retrieve the server key and certificate for the specified algorithm
                  from the KeyManager and set the instance variables.                
                <return>
                    true if successful, false if not available or invalid                    
                </return>
            </javadoc>
            <method name="setupPrivateKeyAndChain" type="boolean" line="1220">
                <params>
                    <param name="algorithm" type="String"/>
                </params>
                <comment line="1246">
                    For ECC certs, check whether we support the EC domain parameters.
                     If the client sent a SupportedEllipticCurves ClientHello extension,
                     check against that too.                    
                </comment>
                <declaration name="km" type="X509ExtendedKeyManager" line="1221"/>
                <declaration name="alias" type="String" line="1222"/>
                <scope line="1223"/>
                <scope line="1225"/>
                <scope line="1228"/>
                <declaration name="tempPrivateKey" type="PrivateKey" line="1231"/>
                <scope line="1232"/>
                <declaration name="tempCerts" type="X509Certificate[]" line="1235"/>
                <scope line="1236"/>
                <declaration name="keyAlgorithm" type="String" line="1239"/>
                <declaration name="publicKey" type="PublicKey" line="1240"/>
                <scope line="1242"/>
                <scope line="1248">
                    <scope line="1249"/>
                    <declaration name="params" type="ECParameterSpec" line="1252"/>
                    <declaration name="index" type="int" line="1253"/>
                    <scope line="1254"/>
                    <scope line="1257"/>
                </scope>
            </method>
            <javadoc line="1266">
                Retrieve the Kerberos key for the specified server principal
                  from the JAAS configuration file.                
                <return>
                    true if successful, false if not available or invalid                    
                </return>
            </javadoc>
            <method name="setupKerberosKeys" type="boolean" line="1272">
                <comment line="1280">
                    Eliminate dependency on KerberosKey                    
                </comment>
                <comment line="1283">
                    get kerberos key for the default principal                    
                </comment>
                <comment line="1287">
                    check permission to access and use the secret key of the
                     Kerberized &quot;host&quot; service                    
                </comment>
                <comment line="1302">
                    Eliminate dependency on ServicePermission                    
                </comment>
                <comment line="1308">
                    %%% destroy keys? or will that affect Subject?                    
                </comment>
                <comment line="1317">
                    Likely exception here is LoginExceptin                    
                </comment>
                <scope line="1273"/>
                <scope line="1276">
                    <declaration name="acc" type="AccessControlContext" line="1277"/>
                    <anonymous_class line="1280">
                        <method name="run" type="SecretKey[]" line="1281">
                            <comment line="1283">
                                get kerberos key for the default principal                                
                            </comment>
                        </method>
                    </anonymous_class>
                    <scope line="1288">
                        <scope line="1289">
                            <scope line="1290"/>
                        </scope>
                        <declaration name="serverPrincipal" type="String" line="1296"/>
                        <declaration name="sm" type="SecurityManager" line="1298"/>
                        <scope line="1299">
                            <scope line="1300"/>
                        </scope>
                        <scope line="1305"/>
                    </scope>
                </scope>
                <scope line="1315">
                    <scope line="1317"/>
                </scope>
            </method>
            <method name="clientKeyExchange" type="SecretKey" line="1330">
                <params>
                    <param name="mesg" type="KerberosClientKeyExchange"/>
                </params>
                <comment line="1337">
                    Record the principals involved in exchange                    
                </comment>
                <scope line="1332"/>
                <declaration name="b" type="byte[]" line="1340"/>
            </method>
            <method name="clientKeyExchange" type="SecretKey" line="1359">
                <params>
                    <param name="mesg" type="DHClientKeyExchange"/>
                </params>
                <scope line="1361"/>
            </method>
            <method name="clientKeyExchange" type="SecretKey" line="1368">
                <params>
                    <param name="mesg" type="ECDHClientKeyExchange"/>
                </params>
                <scope line="1370"/>
            </method>
            <method name="clientCertificateVerify" type="void" line="1386">
                <params>
                    <param name="mesg" type="CertificateVerify"/>
                </params>
                <comment line="1426">
                    reset the flag for clientCertificateVerify message                    
                </comment>
                <scope line="1388"/>
                <scope line="1392">
                    <declaration name="signAlg" type="SignatureAndHashAlgorithm" line="1393"/>
                    <scope line="1395"/>
                    <declaration name="hashAlg" type="String" line="1400"/>
                    <scope line="1402"/>
                </scope>
                <scope line="1410">
                    <declaration name="publicKey" type="PublicKey" line="1411"/>
                    <declaration name="valid" type="boolean" line="1414"/>
                    <scope line="1416"/>
                </scope>
                <scope line="1420"/>
            </method>
            <method name="clientFinished" type="void" line="1437">
                <params>
                    <param name="mesg" type="Finished"/>
                </params>
                <comment line="1443">
                    Verify if client did send the certificate when client
                     authentication was required, otherwise server should not proceed                    
                </comment>
                <comment line="1448">
                    get X500Principal of the end-entity certificate for X509-based
                     ciphersuites, or Kerberos principal for Kerberos ciphersuites                    
                </comment>
                <comment line="1453">
                    Verify if client did send clientCertificateVerify message following
                     the client Certificate, otherwise server should not proceed                    
                </comment>
                <comment line="1462">
                    Verify the client&apos;s message with the &quot;before&quot; digest of messages,
                     and forget about continuing to use that digest.                    
                </comment>
                <comment line="1472">
                    NOTREACHED                    
                </comment>
                <comment line="1475">
                    save client verify data for secure renegotiation                    
                </comment>
                <comment line="1482">
                    OK, it verified.  If we&apos;re doing the full handshake, add that
                     &quot;Finished&quot; message to the hash of handshake messages, then send
                     the change_cipher_spec and Finished message.                    
                </comment>
                <comment line="1492">
                    Update the session cache only after the handshake completed, else
                     we&apos;re open to an attack against a partially completed handshake.                    
                </comment>
                <scope line="1438"/>
                <scope line="1446"/>
                <scope line="1456"/>
                <declaration name="verified" type="boolean" line="1465"/>
                <scope line="1468"/>
                <scope line="1477"/>
                <scope line="1486"/>
                <scope line="1496">
                    <scope line="1499"/>
                </scope>
                <scope line="1504"/>
            </method>
            <method name="sendChangeCipherAndFinish" type="void" line="1516">
                <params>
                    <param name="finishedTag" type="boolean"/>
                </params>
                <comment line="1524">
                    Send the change_cipher_spec record; then our Finished handshake
                     message will be the last handshake message.  Flush, and now we
                     are ready for application data!!                    
                </comment>
                <comment line="1531">
                    save server verify data for secure renegotiation                    
                </comment>
                <comment line="1538">
                    Update state machine so client MUST send &apos;finished&apos; next
                     The update should only take place if it is not in the fast
                     handshake mode since the server has to wait for a finished
                     message from the client.                    
                </comment>
                <declaration name="mesg" type="Finished" line="1520"/>
                <scope line="1533"/>
                <scope line="1543"/>
            </method>
            <method name="getKickstartMessage" type="HandshakeMessage" line="1552"/>
            <method name="handshakeAlert" type="void" line="1560">
                <params>
                    <param name="description" type="byte"/>
                </params>
                <comment line="1570">
                    It&apos;s ok to get a no_certificate alert from a client of which
                     we requested authentication information.
                     However, if we required it, then this is not acceptable.
                    
                     Anyone calling getPeerCertificates() on the
                     session will get an SSLPeerUnverifiedException.                    
                </comment>
                <declaration name="message" type="String" line="1562"/>
                <scope line="1564"/>
                <scope line="1578"/>
            </method>
            <method name="clientKeyExchange" type="SecretKey" line="1592">
                <params>
                    <param name="mesg" type="RSAClientKeyExchange"/>
                </params>
                <scope line="1594"/>
            </method>
            <method name="clientCertificate" type="void" line="1607">
                <params>
                    <param name="mesg" type="CertificateMsg"/>
                </params>
                <comment line="1616">
                    If the client authentication is only REQUESTED (e.g.
                     not REQUIRED, this is an acceptable condition.)                    
                </comment>
                <comment line="1621">
                    Smart (aka stupid) to forecast that no CertificateVerify
                     message will be received.                    
                </comment>
                <comment line="1633">
                    ask the trust manager to verify the chain                    
                </comment>
                <comment line="1637">
                    find out the types of client authentication used                    
                </comment>
                <comment line="1648">
                    unknown public key type                    
                </comment>
                <comment line="1665">
                    Unlikely to happen, because we have wrapped the old
                     X509TrustManager with the new X509ExtendedTrustManager.                    
                </comment>
                <comment line="1671">
                    This will throw an exception, so include the original error.                    
                </comment>
                <comment line="1674">
                    set the flag for clientCertificateVerify message                    
                </comment>
                <scope line="1608"/>
                <declaration name="peerCerts" type="X509Certificate[]" line="1612"/>
                <scope line="1614">
                    <scope line="1619">
                        <scope line="1622"/>
                    </scope>
                    <scope line="1626"/>
                </scope>
                <declaration name="tm" type="X509TrustManager" line="1633"/>
                <scope line="1635">
                    <declaration name="key" type="PublicKey" line="1637"/>
                    <declaration name="keyAlgorithm" type="String" line="1638"/>
                    <declaration name="authType" type="String" line="1639"/>
                    <scope line="1640"/>
                    <scope line="1642"/>
                    <scope line="1644"/>
                    <scope line="1646"/>
                    <scope line="1651">
                        <scope line="1652"/>
                        <scope line="1657"/>
                    </scope>
                    <scope line="1663"/>
                </scope>
                <scope line="1669"/>
            </method>
        </class>
    </source>