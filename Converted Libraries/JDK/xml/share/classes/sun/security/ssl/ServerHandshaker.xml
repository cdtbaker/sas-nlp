<?xml version="1.0" encoding="UTF-8"?>
    <source package="sun.security.ssl">
        <import package="java.io"/>
        <import package="java.util"/>
        <import package="java.security"/>
        <import package="java.security.cert"/>
        <import package="java.security.interfaces"/>
        <import package="java.security.spec.ECParameterSpec"/>
        <import package="javax.crypto.SecretKey"/>
        <import package="javax.crypto.spec.SecretKeySpec"/>
        <import package="javax.net.ssl"/>
        <import package="javax.security.auth.Subject"/>
        <import package="sun.security.ssl.HandshakeMessage"/>
        <import package="sun.security.ssl.CipherSuite"/>
        <import package="sun.security.ssl.SignatureAndHashAlgorithm"/>
        <import package="sun.security.ssl.CipherSuite"/>
        <import package="sun.security.ssl.CipherSuite.KeyExchange"/>
        <class name="ServerHandshaker" line="49">
            <extends class="Handshaker"/>
            <comment line="60">
                is the server going to require the client to authenticate?                
            </comment>
            <comment line="63">
                our authentication info                
            </comment>
            <comment line="69">
                flag to check for clientCertificateVerify message                
            </comment>
            <comment line="72">
                For exportable ciphersuites using non-exportable key sizes, we use
                 ephemeral RSA keys. We could also do anonymous RSA in the same way
                 but there are no such ciphersuites currently defined.                
            </comment>
            <comment line="80">
                For anonymous and ephemeral Diffie-Hellman key exchange, we use
                 ephemeral Diffie-Hellman keys.                
            </comment>
            <comment line="86">
                Helper for ECDH based key exchanges                
            </comment>
            <comment line="89">
                version request by the client in its ClientHello                
            </comment>
            <comment line="90">
                we remember it for the RSA premaster secret version check                
            </comment>
            <comment line="95">
                the preferable signature algorithm used by ServerKeyExchange message                
            </comment>
            <comment line="98">
                Constructor ... use the keys found in the auth context.                
            </comment>
            <comment line="114">
                Constructor ... use the keys found in the auth context.                
            </comment>
            <comment line="130">
                As long as handshaking has not started, we can change
                 whether client authentication is required.  Otherwise,
                 we will need to wait for the next handshake.                
            </comment>
            <comment line="139">
                This routine handles all the server side handshake messages, one at
                 a time.  Given the message type (and in some cases the pending cipher
                 spec) it parses the type-specific message.  Then it calls a function
                 that handles that specific message.
                
                 It updates the state machine as each message is processed, and writes
                 responses as needed using the connection in the constructor.                
            </comment>
            <comment line="265">
                ClientHello presents the server with a bunch of options, to which the
                 server replies with a ServerHello listing the ones which this session
                 will use.  If needed, it also writes its Certificate plus in some cases
                 a ServerKeyExchange message.  It may also write a CertificateRequest,
                 to elicit a client certificate.
                
                 All these messages are terminated by a ServerHelloDone message.  In
                 most cases, all this can be sent in a single Record.                
            </comment>
            <comment line="872">
                Choose cipher suite from among those supported by client. Sets
                 the cipherSuite and keyExchange variables.                
            </comment>
            <comment line="1146">
                Get some &quot;ephemeral&quot; RSA keys for this context. This means
                 generating them if it&apos;s not already been done.
                
                 Note that we currently do not implement any ciphersuites that use
                 strong ephemeral RSA. (We do not support the EXPORT1024 ciphersuites
                 and standard RSA ciphersuites prohibit ephemeral mode for some reason)
                 This means that export is always true and 512 bit keys are generated.                
            </comment>
            <comment line="1167">
                Acquire some &quot;ephemeral&quot; Diffie-Hellman  keys for this handshake.
                 We don&apos;t reuse these, for improved forward secrecy.                
            </comment>
            <comment line="1182">
                Setup the ephemeral ECDH parameters.                
            </comment>
            <comment line="1183">
                If we cannot continue because we do not support any of the curves that                
            </comment>
            <comment line="1184">
                the client requested, return false. Otherwise (all is well), return true.                
            </comment>
            <comment line="1326">
                For Kerberos ciphers, the premaster secret is encrypted using
                 the session key. See RFC 2712.                
            </comment>
            <comment line="1345">
                Diffie Hellman key exchange is used when the server presented
                 D-H parameters in its certificate (signed using RSA or DSSDSA),
                 or else the server presented no certificate but sent D-H params
                 in a ServerKeyExchange message.  Use of D-H is specified by the
                 cipher suite chosen.
                
                 The message optionally contains the client&apos;s D-H public key (if
                 it wasn&apos;t not sent in a client certificate).  As always with D-H,
                 if a client and a server have each other&apos;s D-H public keys and
                 they use common algorithm parameters, they have a shared key
                 that&apos;s derived via the D-H calculation.  That key becomes the
                 pre-master secret.                
            </comment>
            <comment line="1377">
                Client wrote a message to verify the certificate it sent earlier.
                
                 Note that this certificate isn&apos;t involved in key exchange.  Client
                 authentication messages are included in the checksums used to
                 validate the handshake (e.g. Finished messages).  Other than that,
                 the _exact_ identity of the client is less fundamental to protocol
                 security than its role in selecting keys via the pre-master secret.                
            </comment>
            <comment line="1431">
                Client writes &quot;finished&quot; at the end of its handshake, after cipher
                 spec is changed.   We verify it and then send ours.
                
                 When we&apos;re resuming a session, we&apos;ll have already sent our own
                 Finished message so just the verification is needed.                
            </comment>
            <comment line="1512">
                Compute finished message with the &quot;server&quot; digest (and then forget
                 about that digest, it can&apos;t be used again).                
            </comment>
            <comment line="1550">
                Returns a HelloRequest message to kickstart renegotiations                
            </comment>
            <comment line="1558">
                Fault detected during handshake.                
            </comment>
            <comment line="1586">
                RSA key exchange is normally used.  The client encrypts a &quot;pre-master
                 secret&quot; with the server&apos;s public key, from the Certificate (or else
                 ServerKeyExchange) message that was sent to it by the server.  That&apos;s
                 decrypted using the private key before we get here.                
            </comment>
            <comment line="1601">
                Verify the certificate sent by the client. We&apos;ll only get one if we
                 sent a CertificateRequest to request client authentication. If we
                 are in TLS mode, the client may send a message with no certificates
                 to indicate it does not have an appropriate chain. (In SSLv3 mode,
                 it would send a no certificate alert).                
            </comment>
            <javadoc line="49">
                ServerHandshaker does the protocol handshaking from the point
                  of view of a server.  It is driven asychronously by handshake messages
                  as delivered by the parent Handshaker class, and also uses
                  common functionality (e.g. key generation) that is provided there.                
                <author>
                    David Brownell                    
                </author>
            </javadoc>
            <declaration name="doClientAuth" type="byte" line="60"/>
            <declaration name="certs" type="X509Certificate[]" line="63"/>
            <declaration name="privateKey" type="PrivateKey" line="64"/>
            <declaration name="kerberosKeys" type="SecretKey[]" line="66"/>
            <declaration name="needClientVerify" type="boolean" line="69"/>
            <declaration name="tempPrivateKey" type="PrivateKey" line="76"/>
            <declaration name="tempPublicKey" type="PublicKey" line="77"/>
            <declaration name="dh" type="DHCrypt" line="83"/>
            <declaration name="ecdh" type="ECDHCrypt" line="86"/>
            <declaration name="clientRequestedVersion" type="ProtocolVersion" line="90"/>
            <declaration name="supportedCurves" type="SupportedEllipticCurvesExtension" line="92"/>
            <declaration name="preferableSignatureAlgorithm" type="SignatureAndHashAlgorithm" line="95"/>
            <method name="ServerHandshaker" type="constructor" line="104">
                <params>
                    <param name="socket" type="SSLSocketImpl"/>
                    <param name="context" type="SSLContextImpl"/>
                    <param name="enabledProtocols" type="ProtocolList"/>
                    <param name="clientAuth" type="byte"/>
                    <param name="activeProtocolVersion" type="ProtocolVersion"/>
                    <param name="isInitialHandshake" type="boolean"/>
                    <param name="secureRenegotiation" type="boolean"/>
                    <param name="clientVerifyData" type="byte[]"/>
                    <param name="serverVerifyData" type="byte[]"/>
                </params>
            </method>
            <method name="ServerHandshaker" type="constructor" line="120">
                <params>
                    <param name="engine" type="SSLEngineImpl"/>
                    <param name="context" type="SSLContextImpl"/>
                    <param name="enabledProtocols" type="ProtocolList"/>
                    <param name="clientAuth" type="byte"/>
                    <param name="activeProtocolVersion" type="ProtocolVersion"/>
                    <param name="isInitialHandshake" type="boolean"/>
                    <param name="secureRenegotiation" type="boolean"/>
                    <param name="clientVerifyData" type="byte[]"/>
                    <param name="serverVerifyData" type="byte[]"/>
                </params>
            </method>
            <method name="setClientAuth" type="void" line="134">
                <params>
                    <param name="clientAuth" type="byte"/>
                </params>
            </method>
            <method name="processMessage" type="void" line="148">
                <params>
                    <param name="type" type="byte"/>
                    <param name="message_len" type="int"/>
                </params>
                <comment line="149">
                                        
                </comment>
                <comment line="150">
                    In SSLv3 and TLS, messages follow strictly increasing                    
                </comment>
                <comment line="151">
                    numerical order _except_ for one annoying special case.                    
                </comment>
                <comment line="152">
                                        
                </comment>
                <comment line="164">
                    send it off for processing.                    
                </comment>
                <comment line="174">
                    NOTREACHED                    
                </comment>
                <comment line="184">
                    The client&apos;s pre-master secret is decrypted using
                     either the server&apos;s normal private RSA key, or the
                     temporary one used for non-export or signing-only
                     certificateskeys.                    
                </comment>
                <comment line="208">
                    The pre-master secret is derived using the normal
                     Diffie-Hellman calculation.   Note that the main
                     protocol difference in these five flavors is in how
                     the ServerKeyExchange message was constructed!                    
                </comment>
                <comment line="230">
                                        
                </comment>
                <comment line="231">
                    All keys are calculated from the premaster secret                    
                </comment>
                <comment line="232">
                    and the exchanged nonces in the same way.                    
                </comment>
                <comment line="233">
                                        
                </comment>
                <comment line="252">
                                        
                </comment>
                <comment line="253">
                    Move the state machine forward except for that annoying                    
                </comment>
                <comment line="254">
                    special case.  This means that clients could send extra                    
                </comment>
                <comment line="255">
                    cert verify messages; not a problem so long as all of                    
                </comment>
                <comment line="256">
                    them actually check out.                    
                </comment>
                <comment line="257">
                                        
                </comment>
                <scope line="155"/>
                <declaration name="ch" type="ClientHello" line="163"/>
                <scope line="171"/>
                <declaration name="preMasterSecret" type="SecretKey" line="180"/>
                <declaration name="pms" type="RSAClientKeyExchange" line="190"/>
                <scope line="258"/>
            </method>
            <method name="clientHello" type="void" line="274">
                <params>
                    <param name="mesg" type="ClientHello"/>
                </params>
                <comment line="279">
                    Does the message include security renegotiation indication?                    
                </comment>
                <comment line="282">
                    check the TLS_EMPTY_RENEGOTIATION_INFO_SCSV                    
                </comment>
                <comment line="289">
                    abort the handshake with a fatal handshake_failure alert                    
                </comment>
                <comment line="300">
                    check the &quot;renegotiation_info&quot; extension                    
                </comment>
                <comment line="306">
                    verify the length of the &quot;renegotiated_connection&quot; field                    
                </comment>
                <comment line="308">
                    abort the handshake with a fatal handshake_failure alert                    
                </comment>
                <comment line="316">
                    unexpected RI extension for insecure renegotiation,                    
                </comment>
                <comment line="317">
                    abort the handshake with a fatal handshake_failure alert                    
                </comment>
                <comment line="323">
                    verify the client_verify_data value                    
                </comment>
                <comment line="332">
                    if the connection&apos;s &quot;secure_renegotiation&quot; flag is set to TRUE                    
                </comment>
                <comment line="333">
                    and the &quot;renegotiation_info&quot; extension is not present, abort                    
                </comment>
                <comment line="334">
                    the handshake.                    
                </comment>
                <comment line="339">
                    if there is no security renegotiation indication or the previous                    
                </comment>
                <comment line="340">
                    handshake is insecure.                    
                </comment>
                <comment line="344">
                    abort the handshake with a fatal handshake_failure alert                    
                </comment>
                <comment line="349">
                    continue with legacy ClientHello                    
                </comment>
                <comment line="355">
                    abort the handshake                    
                </comment>
                <comment line="357">
                    response with a no_renegotiation warning,                    
                </comment>
                <comment line="360">
                    invalidate the handshake so that the caller can                    
                </comment>
                <comment line="361">
                    dispose this object.                    
                </comment>
                <comment line="364">
                    If there is still unread block in the handshake                    
                </comment>
                <comment line="365">
                    input stream, it would be truncated with the disposal                    
                </comment>
                <comment line="366">
                    and the next handshake message will become incomplete.                    
                </comment>
                <comment line="367">
                                        
                </comment>
                <comment line="368">
                    However, according to SSL/TLS specifications, no more                    
                </comment>
                <comment line="369">
                    handshake message could immediately follow ClientHello                    
                </comment>
                <comment line="370">
                    or HelloRequest. But in case of any improper messages,                    
                </comment>
                <comment line="371">
                    we&apos;d better check to ensure there is no remaining bytes                    
                </comment>
                <comment line="372">
                    in the handshake input stream.                    
                </comment>
                <comment line="381">
                    For SSLv3, send the handshake_failure fatal error.                    
                </comment>
                <comment line="382">
                    Note that SSLv3 does not define a no_renegotiation                    
                </comment>
                <comment line="383">
                    alert like TLSv1. However we cannot ignore the message                    
                </comment>
                <comment line="384">
                    simply, otherwise the other side was waiting for a                    
                </comment>
                <comment line="385">
                    response that would never come.                    
                </comment>
                <comment line="389">
                    !isInitialHandshake &amp;&amp; allowUnsafeRenegotiation                    
                </comment>
                <comment line="390">
                    continue with unsafe renegotiation.                    
                </comment>
                <comment line="398">
                    Always make sure this entire record has been digested before we
                     start emitting output, to ensure correct digesting order.                    
                </comment>
                <comment line="404">
                    FIRST, construct the ServerHello using the options and priorities
                     from the ClientHello.  Update the (pending) cipher spec as we do
                     so, and save the client&apos;s version to protect against rollback
                     attacks.
                    
                     There are a bunch of minor tasks here, and one major one: deciding
                     if the short or the full handshake sequence will be used.                    
                </comment>
                <comment line="417">
                    select a proper protocol version.                    
                </comment>
                <comment line="432">
                                        
                </comment>
                <comment line="433">
                    random ... save client and server values for later use                    
                </comment>
                <comment line="434">
                    in computing the master secret (from pre-master secret)                    
                </comment>
                <comment line="435">
                    and thence the other crypto keys.                    
                </comment>
                <comment line="436">
                                        
                </comment>
                <comment line="437">
                    NOTE:  this use of three inputs to generating _each_ set                    
                </comment>
                <comment line="438">
                    of ciphers slows things down, but it does increase the                    
                </comment>
                <comment line="439">
                    security since each connection in the session can hold                    
                </comment>
                <comment line="440">
                    its own authenticated (and strong) keys.  One could make                    
                </comment>
                <comment line="441">
                    creation of a session a rare thing...                    
                </comment>
                <comment line="442">
                                        
                </comment>
                <comment line="447">
                    forget about the current session                    
                </comment>
                <comment line="448">
                                        
                </comment>
                <comment line="449">
                    Here we go down either of two paths:  (a) the fast one, where                    
                </comment>
                <comment line="450">
                    the client&apos;s asked to rejoin an existing session, and the server                    
                </comment>
                <comment line="451">
                    permits this; (b) the other one, where a new session is created.                    
                </comment>
                <comment line="452">
                                        
                </comment>
                <comment line="454">
                    client is trying to resume a session, let&apos;s see...                    
                </comment>
                <comment line="459">
                                        
                </comment>
                <comment line="460">
                    Check if we can use the fast path, resuming a session.  We                    
                </comment>
                <comment line="461">
                    can do so iff we have a valid record for that session, and                    
                </comment>
                <comment line="462">
                    the cipher suite for that session was on the list which the                    
                </comment>
                <comment line="463">
                    client requested, and if we&apos;re not forgetting any needed                    
                </comment>
                <comment line="464">
                    authentication on the part of the client.                    
                </comment>
                <comment line="465">
                                        
                </comment>
                <comment line="471">
                    cannot resume session with different version                    
                </comment>
                <comment line="486">
                    validate subject identity                    
                </comment>
                <comment line="510">
                    Eliminate dependency on KerberosPrincipal                    
                </comment>
                <comment line="538">
                    verify that the ciphersuite from the cached session                    
                </comment>
                <comment line="539">
                    is in the list of client requested ciphersuites and                    
                </comment>
                <comment line="540">
                    we have it enabled                    
                </comment>
                <comment line="545">
                    everything looks ok, set the ciphersuite                    
                </comment>
                <comment line="546">
                    this should be done last when we are sure we                    
                </comment>
                <comment line="547">
                    will resume                    
                </comment>
                <comment line="560">
                    else client did not try to resume                    
                </comment>
                <comment line="562">
                                        
                </comment>
                <comment line="563">
                    If client hasn&apos;t specified a session we can resume, start a                    
                </comment>
                <comment line="564">
                    new one and choose its cipher suite and compression options.                    
                </comment>
                <comment line="565">
                    Unless new session creation is disabled for this connection!                    
                </comment>
                <comment line="566">
                                        
                </comment>
                <comment line="575">
                    We only need to handle the &quot;signature_algorithm&quot; extension                    
                </comment>
                <comment line="576">
                    for full handshakes and TLS 1.2 or later.                    
                </comment>
                <comment line="600">
                    else, need to use peer implicit supported signature algs                    
                </comment>
                <comment line="612">
                    else, we will set the implicit peer supported signature                    
                </comment>
                <comment line="613">
                    algorithms in chooseCipherSuite()                    
                </comment>
                <comment line="616">
                    set the handshake session                    
                </comment>
                <comment line="619">
                    choose cipher suite and corresponding private key                    
                </comment>
                <comment line="625">
                    chooseCompression(mesg);                    
                </comment>
                <comment line="627">
                    set the handshake session                    
                </comment>
                <comment line="643">
                    For ServerHellos that are initial handshakes, then the                    
                </comment>
                <comment line="644">
                    &quot;renegotiated_connection&quot; field in &quot;renegotiation_info&quot;                    
                </comment>
                <comment line="645">
                    extension is of zero length.                    
                </comment>
                <comment line="646">
                                        
                </comment>
                <comment line="647">
                    For ServerHellos that are renegotiating, this field contains                    
                </comment>
                <comment line="648">
                    the concatenation of client_verify_data and server_verify_data.                    
                </comment>
                <comment line="649">
                                        
                </comment>
                <comment line="650">
                    Note that for initial handshakes, both the clientVerifyData                    
                </comment>
                <comment line="651">
                    variable and serverVerifyData variable are of zero length.                    
                </comment>
                <comment line="663">
                                        
                </comment>
                <comment line="664">
                    If we are resuming a session, we finish writing handshake                    
                </comment>
                <comment line="665">
                    messages right now and then finish.                    
                </comment>
                <comment line="666">
                                        
                </comment>
                <comment line="674">
                    SECOND, write the server Certificate(s) if we need to.
                    
                     NOTE:  while an &quot;anonymous RSA&quot; mode is explicitly allowed by
                     the protocol, we can&apos;t support it since all of the SSL flavors
                     defined in the protocol spec are explicitly stated to require
                     using RSA certificates.                    
                </comment>
                <comment line="683">
                    Server certificates are omitted for Kerberos ciphers                    
                </comment>
                <comment line="692">
                    Set local certs in the SSLSession, output
                     debug info, and then actually write to the client.                    
                </comment>
                <comment line="702">
                    XXX has some side effects with OS TCP buffering,                    
                </comment>
                <comment line="703">
                    leave it out for now                    
                </comment>
                <comment line="705">
                    let client verify chain in the meantime...                    
                </comment>
                <comment line="706">
                    output.flush();                    
                </comment>
                <comment line="713">
                    THIRD, the ServerKeyExchange message ... iff it&apos;s needed.
                    
                     It&apos;s usually needed unless there&apos;s an encryption-capable
                     RSA cert, or a D-H cert.  The notable exception is that
                     exportable ciphers used with big RSA keys need to downgrade
                     to use short RSA keys, even when the keycert encrypts OK.                    
                </comment>
                <comment line="727">
                    no server key exchange for RSA or KRB5 ciphersuites                    
                </comment>
                <comment line="741">
                    make compiler happy                    
                </comment>
                <comment line="744">
                    RSA_EXPORT with short key, don&apos;t need ServerKeyExchange                    
                </comment>
                <comment line="760">
                    make compiler happy                    
                </comment>
                <comment line="780">
                    make compiler happy                    
                </comment>
                <comment line="785">
                    ServerKeyExchange not used for fixed ECDH                    
                </comment>
                <comment line="798">
                                        
                </comment>
                <comment line="799">
                    FOURTH, the CertificateRequest message.  The details of                    
                </comment>
                <comment line="800">
                    the message can be affected by the key exchange algorithm                    
                </comment>
                <comment line="801">
                    in use.  For example, certs with fixed Diffie-Hellman keys                    
                </comment>
                <comment line="802">
                    are only useful with the DH_DSS and DH_RSA key exchange                    
                </comment>
                <comment line="803">
                    algorithms.                    
                </comment>
                <comment line="804">
                                        
                </comment>
                <comment line="805">
                    Needed only if server requires client to authenticate self.                    
                </comment>
                <comment line="806">
                    Illegal for anonymous flavors, so we need to check that.                    
                </comment>
                <comment line="807">
                                        
                </comment>
                <comment line="808">
                    CertificateRequest is omitted for Kerberos ciphers                    
                </comment>
                <comment line="818">
                    We currently use all local upported signature and hash                    
                </comment>
                <comment line="819">
                    algorithms. However, to minimize the computation cost                    
                </comment>
                <comment line="820">
                    of requested hash algorithms, we may use a restricted                    
                </comment>
                <comment line="821">
                    set of signature algorithms in the future.                    
                </comment>
                <comment line="852">
                    FIFTH, say ServerHelloDone.                    
                </comment>
                <comment line="862">
                    Flush any buffered messages so the client will see them.
                     Ideally, all the messages above go in a single network level
                     message to the client.  Without big Certificate chains, it&apos;s
                     going to be the common case.                    
                </comment>
                <scope line="275"/>
                <declaration name="renegotiationIndicated" type="boolean" line="280"/>
                <declaration name="cipherSuites" type="CipherSuiteList" line="283"/>
                <scope line="284">
                    <scope line="286"/>
                    <scope line="288">
                        <scope line="290"/>
                        <scope line="293"/>
                    </scope>
                </scope>
                <declaration name="clientHelloRI" type="RenegotiationInfoExtension" line="301"/>
                <scope line="303">
                    <scope line="305">
                        <scope line="307"/>
                    </scope>
                    <scope line="314">
                        <scope line="315"/>
                        <scope line="325"/>
                    </scope>
                </scope>
                <scope line="331"/>
                <scope line="341">
                    <scope line="342">
                        <scope line="343"/>
                        <scope line="350"/>
                    </scope>
                    <scope line="354">
                        <scope line="356">
                            <scope line="373"/>
                        </scope>
                        <scope line="380"/>
                    </scope>
                    <scope line="389">
                        <scope line="391"/>
                    </scope>
                </scope>
                <declaration name="m1" type="ServerHello" line="413"/>
                <declaration name="selectedVersion" type="ProtocolVersion" line="418"/>
                <scope line="421"/>
                <scope line="453">
                    <declaration name="previous" type="SSLSessionImpl" line="456"/>
                    <scope line="466">
                        <scope line="469">
                            <declaration name="oldVersion" type="ProtocolVersion" line="470"/>
                            <scope line="472"/>
                        </scope>
                        <scope line="478">
                            <scope line="479"/>
                            <scope line="481"/>
                        </scope>
                        <scope line="487">
                            <declaration name="suite" type="CipherSuite" line="488"/>
                            <scope line="490">
                                <declaration name="localPrincipal" type="Principal" line="491"/>
                                <declaration name="subject" type="Subject" line="493"/>
                                <scope line="494">
                                    <anonymous_class line="496">
                                        <method name="run" type="Subject" line="497"/>
                                    </anonymous_class>
                                </scope>
                                <scope line="501">
                                    <scope line="503"/>
                                </scope>
                                <scope line="509">
                                    <declaration name="principals" type="Set&lt;Principal&gt;" line="511"/>
                                    <scope line="513">
                                        <scope line="515"/>
                                    </scope>
                                    <scope line="519"/>
                                </scope>
                                <scope line="524"/>
                            </scope>
                        </scope>
                        <scope line="536">
                            <declaration name="suite" type="CipherSuite" line="537"/>
                            <scope line="542"/>
                            <scope line="544"/>
                        </scope>
                        <scope line="552">
                            <scope line="555"/>
                        </scope>
                    </scope>
                </scope>
                <scope line="567">
                    <scope line="568"/>
                    <scope line="577">
                        <declaration name="signAlgs" type="SignatureAlgorithmsExtension" line="578"/>
                        <scope line="581">
                            <declaration name="peerSignAlgs" type="Collection&lt;SignatureAndHashAlgorithm&gt;" line="582"/>
                            <scope line="584"/>
                            <declaration name="supportedPeerSignAlgs" type="Collection&lt;SignatureAndHashAlgorithm&gt;" line="589"/>
                            <scope line="593"/>
                        </scope>
                    </scope>
                    <scope line="608">
                        <scope line="609"/>
                    </scope>
                </scope>
                <scope line="626"/>
                <scope line="631">
                    <scope line="632"/>
                </scope>
                <scope line="642">
                    <declaration name="serverHelloRI" type="HelloExtension" line="652"/>
                </scope>
                <scope line="657"/>
                <scope line="667"/>
                <scope line="682"/>
                <scope line="685">
                    <scope line="686"/>
                    <declaration name="m2" type="CertificateMsg" line="690"/>
                    <scope line="697"/>
                </scope>
                <scope line="707">
                    <scope line="708"/>
                </scope>
                <declaration name="m3" type="ServerKeyExchange" line="722"/>
                <scope line="731">
                    <scope line="732"/>
                    <scope line="738"/>
                </scope>
                <scope line="743"/>
                <scope line="750"/>
                <scope line="758"/>
                <scope line="769"/>
                <scope line="777"/>
                <scope line="791">
                    <scope line="792"/>
                </scope>
                <scope line="811">
                    <declaration name="m4" type="CertificateRequest" line="813"/>
                    <declaration name="caCerts" type="X509Certificate" line="814"/>
                    <declaration name="localSignAlgs" type="Collection&lt;SignatureAndHashAlgorithm&gt;" line="816"/>
                    <scope line="817">
                        <scope line="823"/>
                        <declaration name="localHashAlgs" type="Set&lt;String&gt;" line="828"/>
                        <scope line="831"/>
                    </scope>
                    <scope line="842"/>
                </scope>
                <scope line="846">
                    <scope line="847"/>
                </scope>
                <declaration name="m5" type="ServerHelloDone" line="855"/>
                <scope line="857"/>
            </method>
            <method name="chooseCipherSuite" type="void" line="875">
                <params>
                    <param name="mesg" type="ClientHello"/>
                </params>
                <scope line="876">
                    <scope line="877"/>
                    <scope line="881">
                        <scope line="883"/>
                    </scope>
                    <scope line="887"/>
                </scope>
            </method>
            <javadoc line="896">
                Set the given CipherSuite, if possible. Return the result.
                  The call succeeds if the CipherSuite is available and we have
                  the necessary certificates to complete the handshake. We don&apos;t
                  check if the CipherSuite is actually enabled.
                  If successful, this method also generates ephemeral keys if
                  required for this ciphersuite. This may take some time, so this
                  method should only be called if you really want to use the
                  CipherSuite.
                  This method is called from chooseCipherSuite() in this class.                
            </javadoc>
            <method name="trySetCipherSuite" type="boolean" line="909">
                <params>
                    <param name="suite" type="CipherSuite"/>
                </params>
                <comment line="910">
                    If we&apos;re resuming a session we know we can
                     support this key exchange algorithm and in fact
                     have already cached the result of it in
                     the session state.                    
                </comment>
                <comment line="924">
                    must not negotiate the obsoleted weak cipher suites.                    
                </comment>
                <comment line="929">
                    must not negotiate unsupported cipher suites.                    
                </comment>
                <comment line="936">
                    null out any existing references                    
                </comment>
                <comment line="950">
                    we may optimize the performance                    
                </comment>
                <comment line="952">
                    If the negotiated key exchange algorithm is one of                    
                </comment>
                <comment line="953">
                    (RSA, DHE_RSA, DH_RSA, RSA_PSK, ECDH_RSA, ECDHE_RSA),                    
                </comment>
                <comment line="954">
                    behave as if client had sent the value {sha1,rsa}.                    
                </comment>
                <comment line="958">
                    case K_RSA_PSK:                    
                </comment>
                <comment line="965">
                    If the negotiated key exchange algorithm is one of                    
                </comment>
                <comment line="966">
                    (DHE_DSS, DH_DSS), behave as if the client had                    
                </comment>
                <comment line="967">
                    sent the value {sha1,dsa}.                    
                </comment>
                <comment line="974">
                    If the negotiated key exchange algorithm is one of                    
                </comment>
                <comment line="975">
                    (ECDH_ECDSA, ECDHE_ECDSA), behave as if the client                    
                </comment>
                <comment line="976">
                    had sent value {sha1,ecdsa}.                    
                </comment>
                <comment line="984">
                    no peer supported signature algorithms                    
                </comment>
                <comment line="996">
                    Sets the peer supported signature algorithm to use in KM                    
                </comment>
                <comment line="997">
                    temporarily.                    
                </comment>
                <comment line="1004">
                    need RSA certs for authentication                    
                </comment>
                <comment line="1010">
                    need RSA certs for authentication                    
                </comment>
                <comment line="1022">
                    could not determine keylength, ignore key                    
                </comment>
                <comment line="1027">
                    get preferable peer signature algorithm for server key exchange                    
                </comment>
                <comment line="1037">
                    need RSA certs for authentication                    
                </comment>
                <comment line="1044">
                    get preferable peer signature algorithm for server key exchange                    
                </comment>
                <comment line="1054">
                    need RSA certs for authentication                    
                </comment>
                <comment line="1063">
                    get preferable peer signature algorithm for server key exchange                    
                </comment>
                <comment line="1073">
                    need DSS certs for authentication                    
                </comment>
                <comment line="1080">
                    get preferable peer signature algorithm for server key exchange                    
                </comment>
                <comment line="1090">
                    need EC cert signed using EC                    
                </comment>
                <comment line="1099">
                    need EC cert signed using RSA                    
                </comment>
                <comment line="1106">
                    need EC cert signed using EC                    
                </comment>
                <comment line="1114">
                    need Kerberos Key                    
                </comment>
                <comment line="1120">
                    no certs needed for anonymous                    
                </comment>
                <comment line="1124">
                    no certs needed for anonymous                    
                </comment>
                <comment line="1130">
                    internal error, unknown key exchange                    
                </comment>
                <comment line="1135">
                    set the peer implicit supported signature algorithms                    
                </comment>
                <comment line="1139">
                    we had alreay update the session                    
                </comment>
                <scope line="916"/>
                <scope line="920"/>
                <scope line="925"/>
                <scope line="930"/>
                <declaration name="keyExchange" type="KeyExchange" line="934"/>
                <declaration name="supportedSignAlgs" type="Collection&lt;SignatureAndHashAlgorithm&gt;" line="943"/>
                <scope line="944">
                    <scope line="945"/>
                    <scope line="947">
                        <declaration name="algorithm" type="SignatureAndHashAlgorithm" line="948"/>
                        <scope line="987"/>
                        <scope line="990"/>
                    </scope>
                </scope>
                <scope line="1005"/>
                <scope line="1011"/>
                <scope line="1015">
                    <scope line="1016">
                        <scope line="1017"/>
                    </scope>
                </scope>
                <scope line="1021"/>
                <scope line="1028">
                    <scope line="1032"/>
                </scope>
                <scope line="1038"/>
                <scope line="1045">
                    <scope line="1049"/>
                </scope>
                <scope line="1055"/>
                <scope line="1058"/>
                <scope line="1064">
                    <scope line="1068"/>
                </scope>
                <scope line="1074"/>
                <scope line="1081">
                    <scope line="1085"/>
                </scope>
                <scope line="1091"/>
                <scope line="1094"/>
                <scope line="1100"/>
                <scope line="1107"/>
                <scope line="1115"/>
                <scope line="1125"/>
                <scope line="1136">
                    <scope line="1137"/>
                </scope>
            </method>
            <method name="setupEphemeralRSAKeys" type="boolean" line="1154">
                <params>
                    <param name="export" type="boolean"/>
                </params>
                <declaration name="kp" type="KeyPair" line="1155"/>
                <scope line="1157"/>
                <scope line="1159"/>
            </method>
            <method name="setupEphemeralDHKeys" type="void" line="1170">
                <params>
                    <param name="export" type="boolean"/>
                </params>
                <comment line="1171">
                    Diffie-Hellman keys ... we use 768 bit private keys due
                     to the &quot;use twice as many key bits as bits you want secret&quot;
                     rule of thumb, assuming we want the same size premaster
                     secret with Diffie-Hellman and RSA key exchanges.  Except
                     that exportable ciphers max out at 512 bits modulus values.                    
                </comment>
            </method>
            <method name="setupEphemeralECDHKeys" type="boolean" line="1184">
                <comment line="1187">
                    if the client sent the supported curves extension, pick the                    
                </comment>
                <comment line="1188">
                    first one that we support;                    
                </comment>
                <comment line="1196">
                    no match found, cannot use this ciphersuite                    
                </comment>
                <comment line="1200">
                    pick our preference                    
                </comment>
                <declaration name="index" type="int" line="1185"/>
                <scope line="1186">
                    <scope line="1189">
                        <scope line="1190"/>
                    </scope>
                    <scope line="1195"/>
                </scope>
                <scope line="1199"/>
                <declaration name="oid" type="String" line="1203"/>
            </method>
            <method name="setupStaticECDHKeys" type="void" line="1208">
                <comment line="1209">
                    don&apos;t need to check whether the curve is supported, already done                    
                </comment>
                <comment line="1210">
                    in setupPrivateKeyAndChain().                    
                </comment>
            </method>
            <javadoc line="1214">
                Retrieve the server key and certificate for the specified algorithm
                  from the KeyManager and set the instance variables.                
                <return>
                    true if successful, false if not available or invalid                    
                </return>
            </javadoc>
            <method name="setupPrivateKeyAndChain" type="boolean" line="1220">
                <params>
                    <param name="algorithm" type="String"/>
                </params>
                <comment line="1245">
                    For ECC certs, check whether we support the EC domain parameters.                    
                </comment>
                <comment line="1246">
                    If the client sent a SupportedEllipticCurves ClientHello extension,                    
                </comment>
                <comment line="1247">
                    check against that too.                    
                </comment>
                <declaration name="km" type="X509ExtendedKeyManager" line="1221"/>
                <declaration name="alias" type="String" line="1222"/>
                <scope line="1223"/>
                <scope line="1225"/>
                <scope line="1228"/>
                <declaration name="tempPrivateKey" type="PrivateKey" line="1231"/>
                <scope line="1232"/>
                <declaration name="tempCerts" type="X509Certificate[]" line="1235"/>
                <scope line="1236"/>
                <declaration name="keyAlgorithm" type="String" line="1239"/>
                <declaration name="publicKey" type="PublicKey" line="1240"/>
                <scope line="1242"/>
                <scope line="1248">
                    <scope line="1249"/>
                    <declaration name="params" type="ECParameterSpec" line="1252"/>
                    <declaration name="index" type="int" line="1253"/>
                    <scope line="1254"/>
                    <scope line="1257"/>
                </scope>
            </method>
            <javadoc line="1266">
                Retrieve the Kerberos key for the specified server principal
                  from the JAAS configuration file.                
                <return>
                    true if successful, false if not available or invalid                    
                </return>
            </javadoc>
            <method name="setupKerberosKeys" type="boolean" line="1272">
                <comment line="1279">
                    Eliminate dependency on KerberosKey                    
                </comment>
                <comment line="1282">
                    get kerberos key for the default principal                    
                </comment>
                <comment line="1286">
                    check permission to access and use the secret key of the                    
                </comment>
                <comment line="1287">
                    Kerberized &quot;host&quot; service                    
                </comment>
                <comment line="1301">
                    Eliminate dependency on ServicePermission                    
                </comment>
                <comment line="1307">
                    %%% destroy keys? or will that affect Subject?                    
                </comment>
                <comment line="1316">
                    Likely exception here is LoginExceptin                    
                </comment>
                <scope line="1273"/>
                <scope line="1276">
                    <declaration name="acc" type="AccessControlContext" line="1277"/>
                    <anonymous_class line="1280">
                        <method name="run" type="SecretKey[]" line="1281">
                            <comment line="1282">
                                get kerberos key for the default principal                                
                            </comment>
                        </method>
                    </anonymous_class>
                    <scope line="1288">
                        <scope line="1289">
                            <scope line="1290"/>
                        </scope>
                        <declaration name="serverPrincipal" type="String" line="1296"/>
                        <declaration name="sm" type="SecurityManager" line="1298"/>
                        <scope line="1299">
                            <scope line="1300"/>
                        </scope>
                        <scope line="1305"/>
                    </scope>
                </scope>
                <scope line="1315">
                    <scope line="1317"/>
                </scope>
            </method>
            <method name="clientKeyExchange" type="SecretKey" line="1330">
                <params>
                    <param name="mesg" type="KerberosClientKeyExchange"/>
                </params>
                <comment line="1336">
                    Record the principals involved in exchange                    
                </comment>
                <scope line="1332"/>
                <declaration name="b" type="byte[]" line="1340"/>
            </method>
            <method name="clientKeyExchange" type="SecretKey" line="1359">
                <params>
                    <param name="mesg" type="DHClientKeyExchange"/>
                </params>
                <scope line="1361"/>
            </method>
            <method name="clientKeyExchange" type="SecretKey" line="1368">
                <params>
                    <param name="mesg" type="ECDHClientKeyExchange"/>
                </params>
                <scope line="1370"/>
            </method>
            <method name="clientCertificateVerify" type="void" line="1386">
                <params>
                    <param name="mesg" type="CertificateVerify"/>
                </params>
                <comment line="1425">
                    reset the flag for clientCertificateVerify message                    
                </comment>
                <scope line="1388"/>
                <scope line="1392">
                    <declaration name="signAlg" type="SignatureAndHashAlgorithm" line="1393"/>
                    <scope line="1395"/>
                    <declaration name="hashAlg" type="String" line="1400"/>
                    <scope line="1402"/>
                </scope>
                <scope line="1410">
                    <declaration name="publicKey" type="PublicKey" line="1411"/>
                    <declaration name="valid" type="boolean" line="1414"/>
                    <scope line="1416"/>
                </scope>
                <scope line="1420"/>
            </method>
            <method name="clientFinished" type="void" line="1437">
                <params>
                    <param name="mesg" type="Finished"/>
                </params>
                <comment line="1442">
                    Verify if client did send the certificate when client
                     authentication was required, otherwise server should not proceed                    
                </comment>
                <comment line="1447">
                    get X500Principal of the end-entity certificate for X509-based                    
                </comment>
                <comment line="1448">
                    ciphersuites, or Kerberos principal for Kerberos ciphersuites                    
                </comment>
                <comment line="1452">
                    Verify if client did send clientCertificateVerify message following
                     the client Certificate, otherwise server should not proceed                    
                </comment>
                <comment line="1461">
                    Verify the client&apos;s message with the &quot;before&quot; digest of messages,
                     and forget about continuing to use that digest.                    
                </comment>
                <comment line="1471">
                    NOTREACHED                    
                </comment>
                <comment line="1474">
                    save client verify data for secure renegotiation                    
                </comment>
                <comment line="1481">
                    OK, it verified.  If we&apos;re doing the full handshake, add that
                     &quot;Finished&quot; message to the hash of handshake messages, then send
                     the change_cipher_spec and Finished message.                    
                </comment>
                <comment line="1491">
                    Update the session cache only after the handshake completed, else
                     we&apos;re open to an attack against a partially completed handshake.                    
                </comment>
                <scope line="1438"/>
                <scope line="1446"/>
                <scope line="1456"/>
                <declaration name="verified" type="boolean" line="1465"/>
                <scope line="1468"/>
                <scope line="1477"/>
                <scope line="1486"/>
                <scope line="1496">
                    <scope line="1499"/>
                </scope>
                <scope line="1504"/>
            </method>
            <method name="sendChangeCipherAndFinish" type="void" line="1516">
                <params>
                    <param name="finishedTag" type="boolean"/>
                </params>
                <comment line="1523">
                    Send the change_cipher_spec record; then our Finished handshake
                     message will be the last handshake message.  Flush, and now we
                     are ready for application data!!                    
                </comment>
                <comment line="1530">
                    save server verify data for secure renegotiation                    
                </comment>
                <comment line="1537">
                    Update state machine so client MUST send &apos;finished&apos; next
                     The update should only take place if it is not in the fast
                     handshake mode since the server has to wait for a finished
                     message from the client.                    
                </comment>
                <declaration name="mesg" type="Finished" line="1520"/>
                <scope line="1533"/>
                <scope line="1543"/>
            </method>
            <method name="getKickstartMessage" type="HandshakeMessage" line="1552"/>
            <method name="handshakeAlert" type="void" line="1560">
                <params>
                    <param name="description" type="byte"/>
                </params>
                <comment line="1569">
                    It&apos;s ok to get a no_certificate alert from a client of which
                     we requested authentication information.
                     However, if we required it, then this is not acceptable.
                    
                     Anyone calling getPeerCertificates() on the
                     session will get an SSLPeerUnverifiedException.                    
                </comment>
                <declaration name="message" type="String" line="1562"/>
                <scope line="1564"/>
                <scope line="1578"/>
            </method>
            <method name="clientKeyExchange" type="SecretKey" line="1592">
                <params>
                    <param name="mesg" type="RSAClientKeyExchange"/>
                </params>
                <scope line="1594"/>
            </method>
            <method name="clientCertificate" type="void" line="1607">
                <params>
                    <param name="mesg" type="CertificateMsg"/>
                </params>
                <comment line="1615">
                    If the client authentication is only REQUESTED (e.g.
                     not REQUIRED, this is an acceptable condition.)                    
                </comment>
                <comment line="1620">
                    Smart (aka stupid) to forecast that no CertificateVerify                    
                </comment>
                <comment line="1621">
                    message will be received.                    
                </comment>
                <comment line="1632">
                    ask the trust manager to verify the chain                    
                </comment>
                <comment line="1636">
                    find out the types of client authentication used                    
                </comment>
                <comment line="1647">
                    unknown public key type                    
                </comment>
                <comment line="1664">
                    Unlikely to happen, because we have wrapped the old                    
                </comment>
                <comment line="1665">
                    X509TrustManager with the new X509ExtendedTrustManager.                    
                </comment>
                <comment line="1670">
                    This will throw an exception, so include the original error.                    
                </comment>
                <comment line="1673">
                    set the flag for clientCertificateVerify message                    
                </comment>
                <scope line="1608"/>
                <declaration name="peerCerts" type="X509Certificate[]" line="1612"/>
                <scope line="1614">
                    <scope line="1619">
                        <scope line="1622"/>
                    </scope>
                    <scope line="1626"/>
                </scope>
                <declaration name="tm" type="X509TrustManager" line="1633"/>
                <scope line="1635">
                    <declaration name="key" type="PublicKey" line="1637"/>
                    <declaration name="keyAlgorithm" type="String" line="1638"/>
                    <declaration name="authType" type="String" line="1639"/>
                    <scope line="1640"/>
                    <scope line="1642"/>
                    <scope line="1644"/>
                    <scope line="1646"/>
                    <scope line="1651">
                        <scope line="1652"/>
                        <scope line="1657"/>
                    </scope>
                    <scope line="1663"/>
                </scope>
                <scope line="1669"/>
            </method>
        </class>
    </source>