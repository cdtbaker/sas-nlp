<?xml version="1.0" encoding="UTF-8"?>
    <source package="sun.security.ssl">
        <import package="java.io.InputStream"/>
        <import package="java.io.IOException"/>
        <import package="java.security.MessageDigest"/>
        <import package="javax.net.ssl.SSLException"/>
        <class name="HandshakeInStream" line="35">
            <extends class="InputStream"/>
            <comment line="60">
                Construct the stream; we&apos;ll be accumulating hashes of the
                 input records using two sets of digests.                
            </comment>
            <comment line="70">
                overridden InputStream methods                
            </comment>
            <comment line="72">
                Return the number of bytes available for read().
                
                 Note that this returns the bytes remaining in the buffer, not
                 the bytes remaining in the current handshake message.                
            </comment>
            <comment line="82">
                Get a byte of handshake data.                
            </comment>
            <comment line="93">
                Get a bunch of bytes of handshake data.                
            </comment>
            <comment line="106">
                Skip some handshake data.                
            </comment>
            <comment line="113">
                Mark reset code, implemented using InputRecord mark reset.
                
                 Note that it currently provides only a limited mark functionality
                 and should be used with care (once a new handshake record has been
                 read, data that has already been consumed is lost even if marked).                
            </comment>
            <comment line="134">
                handshake management functions                
            </comment>
            <comment line="136">
                Here&apos;s an incoming record with handshake data.  Queue the contents;
                 it might be one or more entire messages, complete a message that&apos;s
                 partly queued, or both.                
            </comment>
            <comment line="145">
                Hash any data we&apos;ve consumed but not yet hashed.  Useful mostly
                 for processing client certificate messages (so we can check the
                 immediately following cert verify message) and finished messages
                 (so we can compute our own finished message).                
            </comment>
            <comment line="155">
                Do more than skip that handshake data ... totally ignore it.
                 The difference is that the data does not get hashed.                
            </comment>
            <comment line="164">
                Message parsing methods                
            </comment>
            <comment line="166">
                Read 8, 16, 24, and 32 bit SSL integer data types, encoded
                 in standard big-endian form.                
            </comment>
            <comment line="188">
                Read byte vectors with 8, 16, and 24 bit length encodings.                
            </comment>
            <javadoc line="35">
                InputStream for handshake data, used internally only. Contains the
                  handshake message buffer and methods to parse them.
                  Once a new handshake record arrives, it is buffered in this class until
                  processed by the Handshaker. The buffer may also contain incomplete
                  handshake messages in case the message is split across multiple records.
                  Handshaker.process_record deals with all that. It may also contain
                  handshake messages larger than the default buffer size (e.g. large
                  certificate messages). The buffer is grown dynamically to handle that
                  (see InputRecord.queueHandshake()).
                  Note that the InputRecord used as a buffer here is separate from the
                  AppInStream.r, which is where data from the socket is initially read
                  into. This is because once the initial handshake has been completed,
                  handshake and application data messages may be interleaved arbitrarily
                  and must be processed independently.                
                <author>
                    David Brownell                    
                </author>
            </javadoc>
            <declaration name="r" type="InputRecord" line="57"/>
            <method name="HandshakeInStream" type="constructor" line="63">
                <params>
                    <param name="handshakeHash" type="HandshakeHash"/>
                </params>
            </method>
            <method name="available" type="int" line="77"/>
            <method name="read" type="int" line="84">
                <declaration name="n" type="int" line="85"/>
                <scope line="86"/>
            </method>
            <method name="read" type="int" line="95">
                <params>
                    <param name="b" type="byte"/>
                    <param name="off" type="int"/>
                    <param name="len" type="int"/>
                </params>
                <comment line="97">
                    we read from a ByteArrayInputStream, it always returns the
                     data in a single read if enough is available                    
                </comment>
                <declaration name="n" type="int" line="98"/>
                <scope line="99"/>
            </method>
            <method name="skip" type="long" line="108">
                <params>
                    <param name="n" type="long"/>
                </params>
            </method>
            <method name="mark" type="void" line="120">
                <params>
                    <param name="readlimit" type="int"/>
                </params>
            </method>
            <method name="reset" type="void" line="124"/>
            <method name="markSupported" type="boolean" line="128"/>
            <method name="incomingRecord" type="void" line="140">
                <params>
                    <param name="in" type="InputRecord"/>
                </params>
            </method>
            <method name="digestNow" type="void" line="150"/>
            <method name="ignore" type="void" line="158">
                <params>
                    <param name="n" type="int"/>
                </params>
            </method>
            <method name="getInt8" type="int" line="170"/>
            <method name="getInt16" type="int" line="174"/>
            <method name="getInt24" type="int" line="178"/>
            <method name="getInt32" type="int" line="182"/>
            <method name="getBytes8" type="byte[]" line="191">
                <declaration name="len" type="int" line="192"/>
                <declaration name="b" type="byte" line="193"/>
            </method>
            <method name="getBytes16" type="byte[]" line="199">
                <declaration name="len" type="int" line="200"/>
                <declaration name="b" type="byte" line="201"/>
            </method>
            <method name="getBytes24" type="byte[]" line="207">
                <declaration name="len" type="int" line="208"/>
                <declaration name="b" type="byte" line="209"/>
            </method>
        </class>
    </source>