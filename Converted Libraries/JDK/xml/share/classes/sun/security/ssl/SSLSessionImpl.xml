<?xml version="1.0" encoding="UTF-8"?>
    <source package="sun.security.ssl">
        <import package="java.io"/>
        <import package="java.net"/>
        <import package="java.util.Enumeration"/>
        <import package="java.util.Hashtable"/>
        <import package="java.util.Vector"/>
        <import package="java.util.Arrays"/>
        <import package="java.util.Collection"/>
        <import package="java.security.Principal"/>
        <import package="java.security.PrivateKey"/>
        <import package="java.security.SecureRandom"/>
        <import package="java.security.cert.X509Certificate"/>
        <import package="java.security.cert.CertificateEncodingException"/>
        <import package="javax.crypto.SecretKey"/>
        <import package="javax.net.ssl.SSLSession"/>
        <import package="javax.net.ssl.SSLSessionContext"/>
        <import package="javax.net.ssl.SSLSessionBindingListener"/>
        <import package="javax.net.ssl.SSLSessionBindingEvent"/>
        <import package="javax.net.ssl.SSLPeerUnverifiedException"/>
        <import package="javax.net.ssl.SSLSession"/>
        <import package="javax.net.ssl.SSLPermission"/>
        <import package="javax.net.ssl.SSLException"/>
        <import package="javax.net.ssl.ExtendedSSLSession"/>
        <import package="javax.security.auth.x500.X500Principal"/>
        <import package="sun.security.ssl.CipherSuite"/>
        <import package="sun.security.ssl.CipherSuite.KeyExchange"/>
        <class name="SSLSessionImpl" line="27">
            <extends class="ExtendedSSLSession"/>
            <javadoc line="27">
                Implements the SSL session interface, and exposes the session context
                  which is maintained by SSL servers.
                  &lt;P&gt; Servers have the ability to manage the sessions associated with
                  their authentication context(s).  They can do this by enumerating the
                  IDs of the sessions which are cached, examining those sessions, and then
                  perhaps invalidating a given session so that it can&apos;t be used again.
                  If servers do not explicitly manage the cache, sessions will linger
                  until memory is low enough that the runtime environment purges cache
                  entries automatically to reclaim space.
                  &lt;P&gt;&lt;em&gt; The only reason this class is not package-private is that
                  there&apos;s no other public way to get at the server session context which
                  is associated with any given authentication context. &lt;/em&gt;                
                <author>
                    David Brownell                    
                </author>
            </javadoc>
            <declaration name="nullSession" type="SSLSessionImpl" line="43"/>
            <declaration name="compression_null" type="byte" line="44"/>
            <declaration name="protocolVersion" type="ProtocolVersion" line="45"/>
            <declaration name="sessionId" type="SessionId" line="46"/>
            <declaration name="peerCerts" type="X509Certificate[]" line="47"/>
            <declaration name="compressionMethod" type="byte" line="48"/>
            <declaration name="cipherSuite" type="CipherSuite" line="49"/>
            <declaration name="masterSecret" type="SecretKey" line="50"/>
            <declaration name="creationTime" type="long" line="51"/>
            <declaration name="lastUsedTime" type="long" line="52"/>
            <declaration name="host" type="String" line="53"/>
            <declaration name="port" type="int" line="54"/>
            <declaration name="context" type="SSLSessionContextImpl" line="55"/>
            <declaration name="sessionCount" type="int" line="56"/>
            <declaration name="invalidated" type="boolean" line="57"/>
            <declaration name="localCerts" type="X509Certificate[]" line="58"/>
            <declaration name="localPrivateKey" type="PrivateKey" line="59"/>
            <declaration name="localSupportedSignAlgs" type="String[]" line="60"/>
            <declaration name="peerSupportedSignAlgs" type="String[]" line="61"/>
            <declaration name="peerPrincipal" type="Principal" line="62"/>
            <declaration name="localPrincipal" type="Principal" line="63"/>
            <declaration name="counter" type="int" line="64"/>
            <declaration name="defaultRejoinable" type="boolean" line="65"/>
            <declaration name="debug" type="Debug" line="66"/>
            <method name="SSLSessionImpl" type="constructor" line="67"/>
            <method name="SSLSessionImpl" type="constructor" line="70">
                <params>
                    <param name="protocolVersion" type="ProtocolVersion"/>
                    <param name="cipherSuite" type="CipherSuite"/>
                    <param name="algorithms" type="Collection&lt;SignatureAndHashAlgorithm&gt;"/>
                    <param name="generator" type="SecureRandom"/>
                    <param name="host" type="String"/>
                    <param name="port" type="int"/>
                </params>
            </method>
            <method name="SSLSessionImpl" type="constructor" line="73">
                <params>
                    <param name="protocolVersion" type="ProtocolVersion"/>
                    <param name="cipherSuite" type="CipherSuite"/>
                    <param name="algorithms" type="Collection&lt;SignatureAndHashAlgorithm&gt;"/>
                    <param name="id" type="SessionId"/>
                    <param name="host" type="String"/>
                    <param name="port" type="int"/>
                </params>
                <scope line="84"/>
            </method>
            <method name="setMasterSecret" type="void" line="88">
                <params>
                    <param name="secret" type="SecretKey"/>
                </params>
                <scope line="89"/>
                <scope line="92"/>
            </method>
            <javadoc line="96">
                Returns the master secret ... treat with extreme caution!                
            </javadoc>
            <method name="getMasterSecret" type="SecretKey" line="99"/>
            <method name="setPeerCertificates" type="void" line="102">
                <params>
                    <param name="peer" type="X509Certificate[]"/>
                </params>
                <scope line="103"/>
            </method>
            <method name="setLocalCertificates" type="void" line="107">
                <params>
                    <param name="local" type="X509Certificate[]"/>
                </params>
            </method>
            <method name="setLocalPrivateKey" type="void" line="110">
                <params>
                    <param name="privateKey" type="PrivateKey"/>
                </params>
            </method>
            <method name="setPeerSupportedSignatureAlgorithms" type="void" line="113">
                <params>
                    <param name="algorithms" type="Collection&lt;SignatureAndHashAlgorithm&gt;"/>
                </params>
            </method>
            <javadoc line="116">
                Set the peer principal.                
            </javadoc>
            <method name="setPeerPrincipal" type="void" line="119">
                <params>
                    <param name="principal" type="Principal"/>
                </params>
                <scope line="120"/>
            </method>
            <javadoc line="124">
                Set the local principal.                
            </javadoc>
            <method name="setLocalPrincipal" type="void" line="127">
                <params>
                    <param name="principal" type="Principal"/>
                </params>
            </method>
            <javadoc line="130">
                Returns true iff this session may be resumed ... sessions are
                  usually resumable.  Security policies may suggest otherwise,
                  for example sessions that haven&apos;t been used for a while (say,
                  a working day) won&apos;t be resumable, and sessions might have a
                  maximum lifetime in any case.                
            </javadoc>
            <method name="isRejoinable" type="boolean" line="137"/>
            <method name="isValid" type="boolean" line="140"/>
            <javadoc line="143">
                Check if the authentication used when establishing this session
                  is still valid. Returns true if no authentication was used                
            </javadoc>
            <method name="isLocalAuthenticationValid" type="boolean" line="147">
                <scope line="148">
                    <scope line="149"/>
                    <scope line="152"/>
                </scope>
            </method>
            <javadoc line="159">
                Returns the ID for this session.  The ID is fixed for the
                  duration of the session; neither it, nor its value, changes.                
            </javadoc>
            <method name="getId" type="byte[]" line="163"/>
            <javadoc line="166">
                For server sessions, this returns the set of sessions which
                  are currently valid in this process.  For client sessions,
                  this returns null.                
            </javadoc>
            <method name="getSessionContext" type="SSLSessionContext" line="171">
                <declaration name="sm" type="SecurityManager" line="172"/>
                <scope line="173"/>
            </method>
            <method name="getSessionId" type="SessionId" line="178"/>
            <javadoc line="181">
                Returns the cipher spec in use on this session                
            </javadoc>
            <method name="getSuite" type="CipherSuite" line="184"/>
            <javadoc line="187">
                Resets the cipher spec in use on this session                
            </javadoc>
            <method name="setSuite" type="void" line="190">
                <params>
                    <param name="suite" type="CipherSuite"/>
                </params>
                <scope line="192"/>
            </method>
            <javadoc line="196">
                Returns the name of the cipher suite in use on this session                
            </javadoc>
            <method name="getCipherSuite" type="String" line="199"/>
            <method name="getProtocolVersion" type="ProtocolVersion" line="202"/>
            <javadoc line="205">
                Returns the standard name of the protocol in use on this session                
            </javadoc>
            <method name="getProtocol" type="String" line="208"/>
            <javadoc line="211">
                Returns the compression technique used in this session                
            </javadoc>
            <method name="getCompression" type="byte" line="214"/>
            <javadoc line="217">
                Returns the hashcode for this session                
            </javadoc>
            <method name="hashCode" type="int" line="220"/>
            <javadoc line="223">
                Returns true if sessions have same ids, false otherwise.                
            </javadoc>
            <method name="equals" type="boolean" line="226">
                <params>
                    <param name="obj" type="Object"/>
                </params>
                <scope line="227"/>
                <scope line="230">
                    <declaration name="sess" type="SSLSessionImpl" line="231"/>
                </scope>
            </method>
            <javadoc line="236">
                Return the cert chain presented by the peer in the
                  java.security.cert format.
                  Note: This method can be used only when using certificate-based
                  cipher suites; using it with non-certificate-based cipher suites,
                  such as Kerberos, will throw an SSLPeerUnverifiedException.                
                <return>
                    array of peer X.509 certs, with the peer&apos;s own cert
                      first in the chain, and with the &quot;root&quot; CA last.                    
                </return>
            </javadoc>
            <method name="getPeerCertificates" type="java.security.cert.Certificate[]" line="245">
                <scope line="246"/>
                <scope line="249"/>
            </method>
            <javadoc line="254">
                Return the cert chain presented to the peer in the
                  java.security.cert format.
                  Note: This method is useful only when using certificate-based
                  cipher suites.                
                <return>
                    array of peer X.509 certs, with the peer&apos;s own cert
                      first in the chain, and with the &quot;root&quot; CA last.                    
                </return>
            </javadoc>
            <method name="getLocalCertificates" type="java.security.cert.Certificate[]" line="262"/>
            <javadoc line="265">
                Return the cert chain presented by the peer in the
                  javax.security.cert format.
                  Note: This method can be used only when using certificate-based
                  cipher suites; using it with non-certificate-based cipher suites,
                  such as Kerberos, will throw an SSLPeerUnverifiedException.                
                <return>
                    array of peer X.509 certs, with the peer&apos;s own cert
                      first in the chain, and with the &quot;root&quot; CA last.                    
                </return>
            </javadoc>
            <method name="getPeerCertificateChain" type="javax.security.cert.X509Certificate[]" line="274">
                <scope line="275"/>
                <scope line="278"/>
                <declaration name="certs" type="javax.security.cert.X509Certificate[]" line="281"/>
                <scope line="283">
                    <declaration name="der" type="byte[]" line="284"/>
                    <scope line="285"/>
                    <scope line="289"/>
                    <scope line="292"/>
                </scope>
            </method>
            <javadoc line="298">
                Return the cert chain presented by the peer.
                  Note: This method can be used only when using certificate-based
                  cipher suites; using it with non-certificate-based cipher suites,
                  such as Kerberos, will throw an SSLPeerUnverifiedException.                
                <return>
                    array of peer X.509 certs, with the peer&apos;s own cert
                      first in the chain, and with the &quot;root&quot; CA last.                    
                </return>
            </javadoc>
            <method name="getCertificateChain" type="X509Certificate[]" line="306">
                <scope line="307"/>
                <scope line="310"/>
                <scope line="313"/>
            </method>
            <javadoc line="317">
                Returns the identity of the peer which was established as part of
                  defining the session.                
                <return>
                    the peer&apos;s principal. Returns an X500Principal of the
                      end-entity certificate for X509-based cipher suites, and
                      Principal for Kerberos cipher suites.                    
                </return>
                <throws>
                    SSLPeerUnverifiedException if the peer&apos;s identity has not
                      been verified                    
                </throws>
            </javadoc>
            <method name="getPeerPrincipal" type="Principal" line="326">
                <scope line="327">
                    <scope line="328"/>
                    <scope line="331"/>
                </scope>
                <scope line="335"/>
            </method>
            <javadoc line="340">
                Returns the principal that was sent to the peer during handshaking.                
                <return>
                    the principal sent to the peer. Returns an X500Principal
                      of the end-entity certificate for X509-based cipher suites, and
                      Principal for Kerberos cipher suites. If no principal was
                      sent, then null is returned.                    
                </return>
            </javadoc>
            <method name="getLocalPrincipal" type="Principal" line="347">
                <scope line="348"/>
            </method>
            <javadoc line="353">
                Returns the time this session was created.                
            </javadoc>
            <method name="getCreationTime" type="long" line="356"/>
            <javadoc line="359">
                Returns the last time this session was used to initialize
                  a connection.                
            </javadoc>
            <method name="getLastAccessedTime" type="long" line="363"/>
            <method name="setLastAccessedTime" type="void" line="366">
                <params>
                    <param name="time" type="long"/>
                </params>
            </method>
            <javadoc line="369">
                Returns the network address of the session&apos;s peer.  This
                  implementation does not insist that connections between
                  different ports on the same host must necessarily belong
                  to different sessions, though that is of course allowed.                
            </javadoc>
            <method name="getPeerAddress" type="InetAddress" line="375">
                <scope line="376"/>
                <scope line="379"/>
            </method>
            <method name="getPeerHost" type="String" line="383"/>
            <javadoc line="386">
                Need to provide the port info for caching sessions based on
                  host and port. Accessed by SSLSessionContextImpl                
            </javadoc>
            <method name="getPeerPort" type="int" line="390"/>
            <method name="setContext" type="void" line="393">
                <params>
                    <param name="ctx" type="SSLSessionContextImpl"/>
                </params>
                <scope line="394"/>
            </method>
            <javadoc line="398">
                Invalidate a session.  Active connections may still exist, but
                  no connections will be able to rejoin this session.                
            </javadoc>
            <method name="invalidate" type="void" line="402">
                <scope line="403"/>
                <scope line="407"/>
                <scope line="410"/>
            </method>
            <declaration name="table" type="Hashtable&amp;lt;SecureKey,Object&amp;gt;" line="415"/>
            <javadoc line="416">
                Assigns a session value.  Session change events are given if
                  appropriate, to any original value as well as the new value.                
            </javadoc>
            <method name="putValue" type="void" line="420">
                <params>
                    <param name="key" type="String"/>
                    <param name="value" type="Object"/>
                </params>
                <scope line="421"/>
                <declaration name="secureKey" type="SecureKey" line="424"/>
                <declaration name="oldValue" type="Object" line="425"/>
                <scope line="426">
                    <declaration name="e" type="SSLSessionBindingEvent" line="427"/>
                </scope>
                <scope line="431">
                    <declaration name="e" type="SSLSessionBindingEvent" line="432"/>
                </scope>
            </method>
            <javadoc line="437">
                Returns the specified session value.                
            </javadoc>
            <method name="getValue" type="Object" line="440">
                <params>
                    <param name="key" type="String"/>
                </params>
                <scope line="441"/>
                <declaration name="secureKey" type="SecureKey" line="444"/>
            </method>
            <javadoc line="447">
                Removes the specified session value, delivering a session changed
                  event as appropriate.                
            </javadoc>
            <method name="removeValue" type="void" line="451">
                <params>
                    <param name="key" type="String"/>
                </params>
                <scope line="452"/>
                <declaration name="secureKey" type="SecureKey" line="455"/>
                <declaration name="value" type="Object" line="456"/>
                <scope line="457">
                    <declaration name="e" type="SSLSessionBindingEvent" line="458"/>
                </scope>
            </method>
            <javadoc line="463">
                Lists the names of the session values.                
            </javadoc>
            <method name="getValueNames" type="String[]" line="466">
                <declaration name="e" type="Enumeration&amp;lt;SecureKey&amp;gt;" line="467"/>
                <declaration name="v" type="Vector&amp;lt;Object&amp;gt;" line="468"/>
                <declaration name="key" type="SecureKey" line="469"/>
                <declaration name="securityCtx" type="Object" line="470"/>
                <scope line="471">
                    <scope line="473"/>
                </scope>
                <declaration name="names" type="String[]" line="477"/>
            </method>
            <declaration name="acceptLargeFragments" type="boolean" line="481"/>
            <javadoc line="481">
                Use large packet sizes now or follow RFC 2246 packet sizes (2^14)
                  until changed.
                  In the TLS specification (section 6.2.1, RFC2246), it is not
                  recommended that the plaintext has more than 2^14 bytes.
                  However, some TLS implementations violate the specification.
                  This is a workaround for interoperability with these stacks.
                  Application could accept large fragments up to 2^15 bytes by
                  setting the system property jsse.SSLEngine.acceptLargeFragments
                  to &quot;true&quot;.                
            </javadoc>
            <javadoc line="493">
                Expand the buffer size of both SSL/TLS network packet and
                  application data.                
            </javadoc>
            <method name="expandBufferSizes" type="void" line="497"/>
            <javadoc line="500">
                Gets the current size of the largest SSL/TLS packet that is expected
                  when using this session.                
            </javadoc>
            <method name="getPacketBufferSize" type="int" line="504"/>
            <javadoc line="507">
                Gets the current size of the largest application data that is
                  expected when using this session.                
            </javadoc>
            <method name="getApplicationBufferSize" type="int" line="511"/>
            <javadoc line="514">
                Gets an array of supported signature algorithms that the local side is
                  willing to verify.                
            </javadoc>
            <method name="getLocalSupportedSignatureAlgorithms" type="String[]" line="518">
                <scope line="519"/>
            </method>
            <javadoc line="524">
                Gets an array of supported signature algorithms that the peer is
                  able to verify.                
            </javadoc>
            <method name="getPeerSupportedSignatureAlgorithms" type="String[]" line="528">
                <scope line="529"/>
            </method>
            <javadoc line="534">
                Returns a string representation of this SSL session                
            </javadoc>
            <method name="toString" type="String" line="537"/>
            <javadoc line="540">
                When SSL sessions are finalized, all values bound to
                  them are removed.                
            </javadoc>
            <method name="finalize" type="void" line="544">
                <declaration name="names" type="String[]" line="545"/>
                <scope line="546"/>
            </method>
        </class>
        <class name="SecureKey" line="551">
            <javadoc line="551">
                This &quot;struct&quot; class serves as a Hash Key that combines an
                  application-specific key and a security context.                
            </javadoc>
            <declaration name="nullObject" type="Object" line="556"/>
            <declaration name="appKey" type="Object" line="557"/>
            <declaration name="securityCtx" type="Object" line="558"/>
            <method name="getCurrentSecurityContext" type="Object" line="559">
                <declaration name="sm" type="SecurityManager" line="560"/>
                <declaration name="context" type="Object" line="561"/>
            </method>
            <method name="SecureKey" type="constructor" line="566">
                <params>
                    <param name="key" type="Object"/>
                </params>
            </method>
            <method name="getAppKey" type="Object" line="570"/>
            <method name="getSecurityContext" type="Object" line="573"/>
            <method name="hashCode" type="int" line="576"/>
            <method name="equals" type="boolean" line="579">
                <params>
                    <param name="o" type="Object"/>
                </params>
            </method>
        </class>
    </source>