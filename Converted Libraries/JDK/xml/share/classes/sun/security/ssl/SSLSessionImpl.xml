<?xml version="1.0" encoding="UTF-8"?>
    <source package="sun.security.ssl">
        <import package="java.io"/>
        <import package="java.net"/>
        <import package="java.util.Enumeration"/>
        <import package="java.util.Hashtable"/>
        <import package="java.util.Vector"/>
        <import package="java.util.Arrays"/>
        <import package="java.util.Collection"/>
        <import package="java.security.Principal"/>
        <import package="java.security.PrivateKey"/>
        <import package="java.security.SecureRandom"/>
        <import package="java.security.cert.X509Certificate"/>
        <import package="java.security.cert.CertificateEncodingException"/>
        <import package="javax.crypto.SecretKey"/>
        <import package="javax.net.ssl.SSLSession"/>
        <import package="javax.net.ssl.SSLSessionContext"/>
        <import package="javax.net.ssl.SSLSessionBindingListener"/>
        <import package="javax.net.ssl.SSLSessionBindingEvent"/>
        <import package="javax.net.ssl.SSLPeerUnverifiedException"/>
        <import package="javax.net.ssl.SSLSession"/>
        <import package="javax.net.ssl.SSLPermission"/>
        <import package="javax.net.ssl.SSLException"/>
        <import package="javax.net.ssl.ExtendedSSLSession"/>
        <import package="javax.security.auth.x500.X500Principal"/>
        <import package="sun.security.ssl.CipherSuite"/>
        <import package="sun.security.ssl.CipherSuite.KeyExchange"/>
        <class name="SSLSessionImpl" line="60">
            <extends class="ExtendedSSLSession"/>
            <comment line="81">
                we only really need a single null session                
            </comment>
            <comment line="86">
                compression methods                
            </comment>
            <comment line="89">
                The state of a single session, as described in section 7.1
                 of the SSLv3 spec.                
            </comment>
            <comment line="100">
                Information not part of the SSLv3 protocol spec, but used
                 to support session management policies.                
            </comment>
            <comment line="116">
                Principals for non-certificate based cipher suites                
            </comment>
            <comment line="120">
                We count session creations, eventually for statistical data but
                 also since counters make shorter debugging IDs than the big ones
                 we use in the protocol for uniqueness-over-time.                
            </comment>
            <comment line="127">
                Use of session caches is globally enableddisabled.                
            </comment>
            <comment line="132">
                                
            </comment>
            <comment line="135">
                Create a new non-rejoinable session, using the default (null)
                 cipher spec.  This constructor returns a session which could
                 be used either by a client or by a server, as a connection is
                 first opened and before handshaking begins.                
            </comment>
            <comment line="146">
                Create a new session, using a given cipher spec.  This will
                 be rejoinable if session caching is enabled; the constructor
                 is intended mostly for use by serves.                
            </comment>
            <comment line="158">
                Record a new session, using a given cipher spec and session ID.                
            </comment>
            <comment line="617">
                Table of application-specific session data indexed by an application
                 key and the calling security context. This is important since
                 sessions can be shared across different protection domains.                
            </comment>
            <javadoc line="60">
                Implements the SSL session interface, and exposes the session context
                  which is maintained by SSL servers.
                  &lt;P&gt; Servers have the ability to manage the sessions associated with
                  their authentication context(s).  They can do this by enumerating the
                  IDs of the sessions which are cached, examining those sessions, and then
                  perhaps invalidating a given session so that it can&apos;t be used again.
                  If servers do not explicitly manage the cache, sessions will linger
                  until memory is low enough that the runtime environment purges cache
                  entries automatically to reclaim space.
                  &lt;P&gt;&lt;em&gt; The only reason this class is not package-private is that
                  there&apos;s no other public way to get at the server session context which
                  is associated with any given authentication context. &lt;/em&gt;                
                <author>
                    David Brownell                    
                </author>
            </javadoc>
            <declaration name="nullSession" type="SSLSessionImpl" line="83"/>
            <declaration name="compression_null" type="byte" line="86"/>
            <declaration name="protocolVersion" type="ProtocolVersion" line="92"/>
            <declaration name="sessionId" type="SessionId" line="93"/>
            <declaration name="peerCerts" type="X509Certificate[]" line="94"/>
            <declaration name="compressionMethod" type="byte" line="95"/>
            <declaration name="cipherSuite" type="CipherSuite" line="96"/>
            <declaration name="masterSecret" type="SecretKey" line="97"/>
            <declaration name="creationTime" type="long" line="103"/>
            <declaration name="lastUsedTime" type="long" line="104"/>
            <declaration name="host" type="String" line="105"/>
            <declaration name="port" type="int" line="106"/>
            <declaration name="context" type="SSLSessionContextImpl" line="107"/>
            <declaration name="sessionCount" type="int" line="108"/>
            <declaration name="invalidated" type="boolean" line="109"/>
            <declaration name="localCerts" type="X509Certificate[]" line="110"/>
            <declaration name="localPrivateKey" type="PrivateKey" line="111"/>
            <declaration name="localSupportedSignAlgs" type="String[]" line="112"/>
            <declaration name="peerSupportedSignAlgs" type="String[]" line="113"/>
            <declaration name="peerPrincipal" type="Principal" line="116"/>
            <declaration name="localPrincipal" type="Principal" line="117"/>
            <declaration name="counter" type="int" line="124"/>
            <declaration name="defaultRejoinable" type="boolean" line="129"/>
            <declaration name="debug" type="Debug" line="132"/>
            <method name="SSLSessionImpl" type="constructor" line="140"/>
            <method name="SSLSessionImpl" type="constructor" line="152">
                <params>
                    <param name="protocolVersion" type="ProtocolVersion"/>
                    <param name="cipherSuite" type="CipherSuite"/>
                    <param name="algorithms" type="Collection<SignatureAndHashAlgorithm>"/>
                    <param name="generator" type="SecureRandom"/>
                    <param name="host" type="String"/>
                    <param name="port" type="int"/>
                </params>
            </method>
            <method name="SSLSessionImpl" type="constructor" line="162">
                <params>
                    <param name="protocolVersion" type="ProtocolVersion"/>
                    <param name="cipherSuite" type="CipherSuite"/>
                    <param name="algorithms" type="Collection<SignatureAndHashAlgorithm>"/>
                    <param name="id" type="SessionId"/>
                    <param name="host" type="String"/>
                    <param name="port" type="int"/>
                </params>
                <scope line="175"/>
            </method>
            <method name="setMasterSecret" type="void" line="180">
                <params>
                    <param name="secret" type="SecretKey"/>
                </params>
                <scope line="181"/>
                <scope line="183"/>
            </method>
            <javadoc line="188">
                Returns the master secret ... treat with extreme caution!                
            </javadoc>
            <method name="getMasterSecret" type="SecretKey" line="191"/>
            <method name="setPeerCertificates" type="void" line="195">
                <params>
                    <param name="peer" type="X509Certificate[]"/>
                </params>
                <scope line="196"/>
            </method>
            <method name="setLocalCertificates" type="void" line="201">
                <params>
                    <param name="local" type="X509Certificate[]"/>
                </params>
            </method>
            <method name="setLocalPrivateKey" type="void" line="205">
                <params>
                    <param name="privateKey" type="PrivateKey"/>
                </params>
            </method>
            <method name="setPeerSupportedSignatureAlgorithms" type="void" line="210">
                <params>
                    <param name="algorithms" type="Collection<SignatureAndHashAlgorithm>"/>
                </params>
            </method>
            <javadoc line="215">
                Set the peer principal.                
            </javadoc>
            <method name="setPeerPrincipal" type="void" line="218">
                <params>
                    <param name="principal" type="Principal"/>
                </params>
                <scope line="219"/>
            </method>
            <javadoc line="224">
                Set the local principal.                
            </javadoc>
            <method name="setLocalPrincipal" type="void" line="227">
                <params>
                    <param name="principal" type="Principal"/>
                </params>
            </method>
            <javadoc line="231">
                Returns true iff this session may be resumed ... sessions are
                  usually resumable.  Security policies may suggest otherwise,
                  for example sessions that haven&apos;t been used for a while (say,
                  a working day) won&apos;t be resumable, and sessions might have a
                  maximum lifetime in any case.                
            </javadoc>
            <method name="isRejoinable" type="boolean" line="238"/>
            <method name="isValid" type="boolean" line="243"/>
            <javadoc line="247">
                Check if the authentication used when establishing this session
                  is still valid. Returns true if no authentication was used                
            </javadoc>
            <method name="isLocalAuthenticationValid" type="boolean" line="251">
                <comment line="254">
                    if the private key is no longer valid, getAlgorithm()                    
                </comment>
                <comment line="255">
                    should throw an exception                    
                </comment>
                <comment line="256">
                    (e.g. Smartcard has been removed from the reader)                    
                </comment>
                <scope line="252">
                    <scope line="253"/>
                    <scope line="258"/>
                </scope>
            </method>
            <javadoc line="266">
                Returns the ID for this session.  The ID is fixed for the
                  duration of the session; neither it, nor its value, changes.                
            </javadoc>
            <method name="getId" type="byte[]" line="270"/>
            <javadoc line="274">
                For server sessions, this returns the set of sessions which
                  are currently valid in this process.  For client sessions,
                  this returns null.                
            </javadoc>
            <method name="getSessionContext" type="SSLSessionContext" line="279">
                <comment line="280">
                    An interim security policy until we can do something
                     more specific in 1.2. Only allow trusted code (code which
                     can set system properties) to get an
                     SSLSessionContext. This is to limit the ability of code to
                     look up specific sessions or enumerate over them. Otherwise,
                     code can only get session objects from successful SSL
                     connections which implies that they must have had permission
                     to make the network connection in the first place.                    
                </comment>
                <declaration name="sm" type="SecurityManager" line="290"/>
                <scope line="291"/>
            </method>
            <method name="getSessionId" type="SessionId" line="299"/>
            <javadoc line="304">
                Returns the cipher spec in use on this session                
            </javadoc>
            <method name="getSuite" type="CipherSuite" line="307"/>
            <javadoc line="311">
                Resets the cipher spec in use on this session                
            </javadoc>
            <method name="setSuite" type="void" line="314">
                <params>
                    <param name="suite" type="CipherSuite"/>
                </params>
                <scope line="317"/>
            </method>
            <javadoc line="322">
                Returns the name of the cipher suite in use on this session                
            </javadoc>
            <method name="getCipherSuite" type="String" line="325"/>
            <method name="getProtocolVersion" type="ProtocolVersion" line="329"/>
            <javadoc line="333">
                Returns the standard name of the protocol in use on this session                
            </javadoc>
            <method name="getProtocol" type="String" line="336"/>
            <javadoc line="340">
                Returns the compression technique used in this session                
            </javadoc>
            <method name="getCompression" type="byte" line="343"/>
            <javadoc line="347">
                Returns the hashcode for this session                
            </javadoc>
            <method name="hashCode" type="int" line="350"/>
            <javadoc line="355">
                Returns true if sessions have same ids, false otherwise.                
            </javadoc>
            <method name="equals" type="boolean" line="358">
                <params>
                    <param name="obj" type="Object"/>
                </params>
                <scope line="360"/>
                <scope line="364">
                    <declaration name="sess" type="SSLSessionImpl" line="365"/>
                </scope>
            </method>
            <javadoc line="374">
                Return the cert chain presented by the peer in the
                  java.security.cert format.
                  Note: This method can be used only when using certificate-based
                  cipher suites; using it with non-certificate-based cipher suites,
                  such as Kerberos, will throw an SSLPeerUnverifiedException.                
                <return>
                    array of peer X.509 certs, with the peer's own cert
                      first in the chain, and with the "root" CA last.                    
                </return>
            </javadoc>
            <method name="getPeerCertificates" type="java.security.cert.Certificate[]" line="385">
                <comment line="386">
                                        
                </comment>
                <comment line="387">
                    clone to preserve integrity of session ... caller can&apos;t                    
                </comment>
                <comment line="388">
                    change record of peer identity even by accident, much                    
                </comment>
                <comment line="389">
                    less do it intentionally.                    
                </comment>
                <comment line="390">
                                        
                </comment>
                <comment line="399">
                    Certs are immutable objects, therefore we don&apos;t clone them.                    
                </comment>
                <comment line="400">
                    But do need to clone the array, so that nothing is inserted                    
                </comment>
                <comment line="401">
                    into peerCerts.                    
                </comment>
                <scope line="392"/>
                <scope line="396"/>
            </method>
            <javadoc line="405">
                Return the cert chain presented to the peer in the
                  java.security.cert format.
                  Note: This method is useful only when using certificate-based
                  cipher suites.                
                <return>
                    array of peer X.509 certs, with the peer's own cert
                      first in the chain, and with the "root" CA last.                    
                </return>
            </javadoc>
            <method name="getLocalCertificates" type="java.security.cert.Certificate[]" line="414">
                <comment line="415">
                                        
                </comment>
                <comment line="416">
                    clone to preserve integrity of session ... caller can&apos;t                    
                </comment>
                <comment line="417">
                    change record of peer identity even by accident, much                    
                </comment>
                <comment line="418">
                    less do it intentionally.                    
                </comment>
            </method>
            <javadoc line="423">
                Return the cert chain presented by the peer in the
                  javax.security.cert format.
                  Note: This method can be used only when using certificate-based
                  cipher suites; using it with non-certificate-based cipher suites,
                  such as Kerberos, will throw an SSLPeerUnverifiedException.                
                <return>
                    array of peer X.509 certs, with the peer's own cert
                      first in the chain, and with the "root" CA last.                    
                </return>
            </javadoc>
            <method name="getPeerCertificateChain" type="javax.security.cert.X509Certificate[]" line="434">
                <comment line="435">
                                        
                </comment>
                <comment line="436">
                    clone to preserve integrity of session ... caller can&apos;t                    
                </comment>
                <comment line="437">
                    change record of peer identity even by accident, much                    
                </comment>
                <comment line="438">
                    less do it intentionally.                    
                </comment>
                <comment line="439">
                                        
                </comment>
                <scope line="441"/>
                <scope line="445"/>
                <declaration name="certs" type="javax.security.cert.X509Certificate[]" line="448"/>
                <scope line="450">
                    <declaration name="der" type="byte[]" line="451"/>
                    <scope line="452"/>
                    <scope line="455"/>
                    <scope line="457"/>
                </scope>
            </method>
            <javadoc line="465">
                Return the cert chain presented by the peer.
                  Note: This method can be used only when using certificate-based
                  cipher suites; using it with non-certificate-based cipher suites,
                  such as Kerberos, will throw an SSLPeerUnverifiedException.                
                <return>
                    array of peer X.509 certs, with the peer's own cert
                      first in the chain, and with the "root" CA last.                    
                </return>
            </javadoc>
            <method name="getCertificateChain" type="X509Certificate[]" line="475">
                <comment line="476">
                    clone to preserve integrity of session ... caller can&apos;t
                     change record of peer identity even by accident, much
                     less do it intentionally.                    
                </comment>
                <scope line="482"/>
                <scope line="486"/>
                <scope line="488"/>
            </method>
            <javadoc line="493">
                Returns the identity of the peer which was established as part of
                  defining the session.                
                <return>
                    the peer's principal. Returns an X500Principal of the
                      end-entity certificate for X509-based cipher suites, and
                      Principal for Kerberos cipher suites.                    
                </return>
                <throws>
                    SSLPeerUnverifiedException if the peer's identity has not
                      been verified                    
                </throws>
            </javadoc>
            <method name="getPeerPrincipal" type="Principal" line="506">
                <comment line="512">
                    Eliminate dependency on KerberosPrincipal                    
                </comment>
                <scope line="508">
                    <scope line="509"/>
                    <scope line="511"/>
                </scope>
                <scope line="516"/>
            </method>
            <javadoc line="522">
                Returns the principal that was sent to the peer during handshaking.                
                <return>
                    the principal sent to the peer. Returns an X500Principal
                      of the end-entity certificate for X509-based cipher suites, and
                      Principal for Kerberos cipher suites. If no principal was
                      sent, then null is returned.                    
                </return>
            </javadoc>
            <method name="getLocalPrincipal" type="Principal" line="530">
                <comment line="534">
                    Eliminate dependency on KerberosPrincipal                    
                </comment>
                <scope line="533"/>
            </method>
            <javadoc line="541">
                Returns the time this session was created.                
            </javadoc>
            <method name="getCreationTime" type="long" line="544"/>
            <javadoc line="548">
                Returns the last time this session was used to initialize
                  a connection.                
            </javadoc>
            <method name="getLastAccessedTime" type="long" line="552"/>
            <method name="setLastAccessedTime" type="void" line="556">
                <params>
                    <param name="time" type="long"/>
                </params>
            </method>
            <javadoc line="561">
                Returns the network address of the session&apos;s peer.  This
                  implementation does not insist that connections between
                  different ports on the same host must necessarily belong
                  to different sessions, though that is of course allowed.                
            </javadoc>
            <method name="getPeerAddress" type="InetAddress" line="567">
                <scope line="568"/>
                <scope line="570"/>
            </method>
            <method name="getPeerHost" type="String" line="575"/>
            <javadoc line="579">
                Need to provide the port info for caching sessions based on
                  host and port. Accessed by SSLSessionContextImpl                
            </javadoc>
            <method name="getPeerPort" type="int" line="583"/>
            <method name="setContext" type="void" line="587">
                <params>
                    <param name="ctx" type="SSLSessionContextImpl"/>
                </params>
                <scope line="588"/>
            </method>
            <javadoc line="593">
                Invalidate a session.  Active connections may still exist, but
                  no connections will be able to rejoin this session.                
            </javadoc>
            <method name="invalidate" type="void" line="597">
                <comment line="598">
                                        
                </comment>
                <comment line="599">
                    Can&apos;t invalidate the NULL session -- this would be                    
                </comment>
                <comment line="600">
                    attempted when we get a handshaking error on a brand                    
                </comment>
                <comment line="601">
                    new connection, with no &quot;real&quot; session yet.                    
                </comment>
                <comment line="602">
                                        
                </comment>
                <scope line="603"/>
                <scope line="607"/>
                <scope line="610"/>
            </method>
            <declaration name="table" type="Hashtable&lt;SecureKey,Object&gt;" line="621"/>
            <javadoc line="623">
                Assigns a session value.  Session change events are given if
                  appropriate, to any original value as well as the new value.                
            </javadoc>
            <method name="putValue" type="void" line="627">
                <params>
                    <param name="key" type="String"/>
                    <param name="value" type="Object"/>
                </params>
                <scope line="628"/>
                <declaration name="secureKey" type="SecureKey" line="632"/>
                <declaration name="oldValue" type="Object" line="633"/>
                <scope line="635">
                    <declaration name="e" type="SSLSessionBindingEvent" line="636"/>
                </scope>
                <scope line="641">
                    <declaration name="e" type="SSLSessionBindingEvent" line="642"/>
                </scope>
            </method>
            <javadoc line="650">
                Returns the specified session value.                
            </javadoc>
            <method name="getValue" type="Object" line="653">
                <params>
                    <param name="key" type="String"/>
                </params>
                <scope line="654"/>
                <declaration name="secureKey" type="SecureKey" line="658"/>
            </method>
            <javadoc line="663">
                Removes the specified session value, delivering a session changed
                  event as appropriate.                
            </javadoc>
            <method name="removeValue" type="void" line="667">
                <params>
                    <param name="key" type="String"/>
                </params>
                <scope line="668"/>
                <declaration name="secureKey" type="SecureKey" line="672"/>
                <declaration name="value" type="Object" line="673"/>
                <scope line="675">
                    <declaration name="e" type="SSLSessionBindingEvent" line="676"/>
                </scope>
            </method>
            <javadoc line="684">
                Lists the names of the session values.                
            </javadoc>
            <method name="getValueNames" type="String[]" line="687">
                <declaration name="e" type="Enumeration&lt;SecureKey&gt;" line="688"/>
                <declaration name="v" type="Vector&lt;Object&gt;" line="689"/>
                <declaration name="key" type="SecureKey" line="690"/>
                <declaration name="securityCtx" type="Object" line="691"/>
                <scope line="693">
                    <scope line="696"/>
                </scope>
                <declaration name="names" type="String[]" line="700"/>
            </method>
            <declaration name="acceptLargeFragments" type="boolean" line="706"/>
            <javadoc line="706">
                Use large packet sizes now or follow RFC 2246 packet sizes (2^14)
                  until changed.
                  In the TLS specification (section 6.2.1, RFC2246), it is not
                  recommended that the plaintext has more than 2^14 bytes.
                  However, some TLS implementations violate the specification.
                  This is a workaround for interoperability with these stacks.
                  Application could accept large fragments up to 2^15 bytes by
                  setting the system property jsse.SSLEngine.acceptLargeFragments
                  to &quot;true&quot;.                
            </javadoc>
            <javadoc line="722">
                Expand the buffer size of both SSL/TLS network packet and
                  application data.                
            </javadoc>
            <method name="expandBufferSizes" type="void" line="726"/>
            <javadoc line="730">
                Gets the current size of the largest SSL/TLS packet that is expected
                  when using this session.                
            </javadoc>
            <method name="getPacketBufferSize" type="int" line="734"/>
            <javadoc line="739">
                Gets the current size of the largest application data that is
                  expected when using this session.                
            </javadoc>
            <method name="getApplicationBufferSize" type="int" line="743"/>
            <javadoc line="747">
                Gets an array of supported signature algorithms that the local side is
                  willing to verify.                
            </javadoc>
            <method name="getLocalSupportedSignatureAlgorithms" type="String[]" line="751">
                <scope line="752"/>
            </method>
            <javadoc line="759">
                Gets an array of supported signature algorithms that the peer is
                  able to verify.                
            </javadoc>
            <method name="getPeerSupportedSignatureAlgorithms" type="String[]" line="763">
                <scope line="764"/>
            </method>
            <javadoc line="771">
                Returns a string representation of this SSL session                
            </javadoc>
            <method name="toString" type="String" line="772"/>
            <javadoc line="778">
                When SSL sessions are finalized, all values bound to
                  them are removed.                
            </javadoc>
            <method name="finalize" type="void" line="782">
                <declaration name="names" type="String[]" line="783"/>
                <scope line="784"/>
            </method>
        </class>
        <class name="SecureKey" line="791">
            <comment line="81">
                we only really need a single null session                
            </comment>
            <comment line="86">
                compression methods                
            </comment>
            <comment line="89">
                The state of a single session, as described in section 7.1
                 of the SSLv3 spec.                
            </comment>
            <comment line="100">
                Information not part of the SSLv3 protocol spec, but used
                 to support session management policies.                
            </comment>
            <comment line="116">
                Principals for non-certificate based cipher suites                
            </comment>
            <comment line="120">
                We count session creations, eventually for statistical data but
                 also since counters make shorter debugging IDs than the big ones
                 we use in the protocol for uniqueness-over-time.                
            </comment>
            <comment line="127">
                Use of session caches is globally enableddisabled.                
            </comment>
            <comment line="132">
                                
            </comment>
            <comment line="135">
                Create a new non-rejoinable session, using the default (null)
                 cipher spec.  This constructor returns a session which could
                 be used either by a client or by a server, as a connection is
                 first opened and before handshaking begins.                
            </comment>
            <comment line="146">
                Create a new session, using a given cipher spec.  This will
                 be rejoinable if session caching is enabled; the constructor
                 is intended mostly for use by serves.                
            </comment>
            <comment line="158">
                Record a new session, using a given cipher spec and session ID.                
            </comment>
            <comment line="617">
                Table of application-specific session data indexed by an application
                 key and the calling security context. This is important since
                 sessions can be shared across different protection domains.                
            </comment>
            <javadoc line="791">
                This &quot;struct&quot; class serves as a Hash Key that combines an
                  application-specific key and a security context.                
            </javadoc>
            <declaration name="nullObject" type="Object" line="796"/>
            <declaration name="appKey" type="Object" line="797"/>
            <declaration name="securityCtx" type="Object" line="798"/>
            <method name="getCurrentSecurityContext" type="Object" line="800">
                <declaration name="sm" type="SecurityManager" line="801"/>
                <declaration name="context" type="Object" line="802"/>
            </method>
            <method name="SecureKey" type="constructor" line="811">
                <params>
                    <param name="key" type="Object"/>
                </params>
            </method>
            <method name="getAppKey" type="Object" line="816"/>
            <method name="getSecurityContext" type="Object" line="820"/>
            <method name="hashCode" type="int" line="824"/>
            <method name="equals" type="boolean" line="828">
                <params>
                    <param name="o" type="Object"/>
                </params>
            </method>
        </class>
    </source>