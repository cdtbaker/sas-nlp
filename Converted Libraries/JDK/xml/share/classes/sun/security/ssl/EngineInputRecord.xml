<?xml version="1.0" encoding="UTF-8"?>
    <source package="sun.security.ssl">
        <import package="java.io"/>
        <import package="java.nio"/>
        <import package="javax.net.ssl"/>
        <import package="javax.crypto.BadPaddingException"/>
        <import package="sun.misc.HexDumpEncoder"/>
        <class name="EngineInputRecord" line="36">
            <extends class="InputRecord"/>
            <comment line="50">
                A dummy ByteBuffer we&apos;ll pass back even when the data
                 is stored internally.  It&apos;ll never actually be used.                
            </comment>
            <comment line="56">
                Flag to tell whether the last readparsed data resides
                 internal in the ByteArrayInputStream, or in the external
                 buffers.                
            </comment>
            <comment line="76">
                Check if there is enough inbound data in the ByteBuffer
                 to make a inbound packet.  Look for both SSLv2 and SSLv3.
                
                 @return -1 if there are not enough bytes to tell (small header),                
            </comment>
            <comment line="180">
                Verifies and removes the MAC value.  Returns true if
                 the MAC checks out OK.
                
                 On entry:
                     position = beginning of appMAC data
                     limit = end of MAC data.
                
                 On return:
                     position = beginning of app data
                     limit = end of app data                
            </comment>
            <comment line="245">
                Pass the data down if it&apos;s internally cached, otherwise
                 do it here.
                
                 If internal data, data is decrypted internally.
                
                 If external data(app), return a new ByteBuffer with data to
                 process.                
            </comment>
            <comment line="268">
                Override the actual write below.  We do things this way to be
                 consistent with InputRecord.  InputRecord may try to write out
                 data to the peer, and then throw an Exception.  This forces
                 data to be generatedoutput before the exception is ever
                 generated.                
            </comment>
            <comment line="285">
                Delineate or read a complete packet from src.
                
                 If internal data (hs, alert, ccs), the data is read and
                 stored internally.
                
                 If external data (app), return a new ByteBuffer which points
                 to the data to process.                
            </comment>
            <javadoc line="36">
                Wrapper class around InputRecord.
                  Application data is kept external to the InputRecord,
                  but handshake data (alert/change_cipher_spec/handshake) will
                  be kept internally in the ByteArrayInputStream.                
                <author>
                    Brad Wetmore                    
                </author>
            </javadoc>
            <declaration name="engine" type="SSLEngineImpl" line="47"/>
            <declaration name="tmpBB" type="ByteBuffer" line="53"/>
            <declaration name="internalData" type="boolean" line="60"/>
            <method name="EngineInputRecord" type="constructor" line="62">
                <params>
                    <param name="engine" type="SSLEngineImpl"/>
                </params>
            </method>
            <method name="contentType" type="byte" line="67">
                <scope line="68"/>
                <scope line="70"/>
            </method>
            <method name="bytesInCompletePacket" type="int" line="81">
                <params>
                    <param name="buf" type="ByteBuffer"/>
                </params>
                <comment line="84">
                    SSLv2 length field is in bytes 01
                     SSLv3TLS length field is in bytes 34                    
                </comment>
                <comment line="97">
                    If we have already verified previous packets, we can
                     ignore the verifications steps, and jump right to the
                     determination.  Otherwise, try one last hueristic to
                     see if it&apos;s SSLTLS.                    
                </comment>
                <comment line="106">
                    Last sanity check that it&apos;s not a wild record                    
                </comment>
                <comment line="112">
                    Check if too old (currently not possible)
                     or if the major version does not match.
                     The actual version negotiation is in the handshaker classes                    
                </comment>
                <comment line="121">
                    Reasonably sure this is a V3, disable further checks.
                     We can&apos;t do the same in the v2 check below, because
                     read still needs to parsehandle the v2 clientHello.                    
                </comment>
                <comment line="128">
                    One of the SSLv3TLS message types.                    
                </comment>
                <comment line="135">
                    Must be SSLv2 or something unknown.
                     Check if it&apos;s short (2 bytes) or
                     long (3) header.
                    
                     Internals can warn about unsupported SSLv2                    
                </comment>
                <comment line="150">
                    Check if too old (currently not possible)
                     or if the major version does not match.
                     The actual version negotiation is in the handshaker classes                    
                </comment>
                <comment line="156">
                    if it&apos;s not SSLv2, we&apos;re out of here.                    
                </comment>
                <comment line="163">
                    Client or Server Hello                    
                </comment>
                <comment line="171">
                    Gobblygook!                    
                </comment>
                <scope line="87"/>
                <declaration name="pos" type="int" line="91"/>
                <declaration name="byteZero" type="byte" line="92"/>
                <declaration name="len" type="int" line="94"/>
                <scope line="104">
                    <declaration name="recordVersion" type="ProtocolVersion" line="108"/>
                    <scope line="115"/>
                </scope>
                <scope line="133">
                    <declaration name="isShort" type="boolean" line="141"/>
                    <scope line="144">
                        <declaration name="recordVersion" type="ProtocolVersion" line="146"/>
                        <scope line="153">
                            <scope line="156"/>
                        </scope>
                        <declaration name="mask" type="int" line="165"/>
                    </scope>
                    <scope line="169"/>
                </scope>
            </method>
            <method name="checkMAC" type="boolean" line="191">
                <params>
                    <param name="signer" type="MAC"/>
                    <param name="bb" type="ByteBuffer"/>
                </params>
                <comment line="198">
                    no mac                    
                </comment>
                <comment line="202">
                    Grab the original limit                    
                </comment>
                <comment line="207">
                    Delineate the area to apply a MAC on.                    
                </comment>
                <comment line="219">
                    Delineate the MAC values, position was already set
                     by doing the compute above.
                    
                     We could zero the MAC area, but not much useful information
                     there anyway.                    
                </comment>
                <comment line="231">
                    No BB.equals(byte []); !                    
                </comment>
                <comment line="237">
                    Position to the data.                    
                </comment>
                <scope line="192"/>
                <declaration name="len" type="int" line="196"/>
                <scope line="197"/>
                <declaration name="lim" type="int" line="204"/>
                <declaration name="macData" type="int" line="209"/>
                <declaration name="mac" type="byte[]" line="212"/>
                <scope line="214"/>
                <scope line="228">
                    <scope line="229">
                        <scope line="230"/>
                    </scope>
                </scope>
                <scope line="235"/>
            </method>
            <method name="decrypt" type="ByteBuffer" line="254">
                <params>
                    <param name="box" type="CipherBox"/>
                    <param name="bb" type="ByteBuffer"/>
                </params>
                <scope line="256"/>
            </method>
            <method name="writeBuffer" type="void" line="275">
                <params>
                    <param name="s" type="OutputStream"/>
                    <param name="buf" type="byte[]"/>
                    <param name="off" type="int"/>
                    <param name="len" type="int"/>
                </params>
                <comment line="277">
                    Copy data out of buffer, it&apos;s ready to go.                    
                </comment>
                <declaration name="netBB" type="ByteBuffer" line="279"/>
            </method>
            <method name="read" type="ByteBuffer" line="293">
                <params>
                    <param name="srcBB" type="ByteBuffer"/>
                </params>
                <comment line="295">
                    Could have a src == nulldst == null check here,
                     but that was already checked by SSLEngine.unwrap before
                     ever attempting to read.                    
                </comment>
                <comment line="301">
                    If we have anything besides application data,
                     or if we haven&apos;t even done the initial v2 verification,
                     we send this down to be processed by the underlying
                     internal cache.                    
                </comment>
                <comment line="321">
                    Check if too old (currently not possible)
                     or if the major version does not match.
                     The actual version negotiation is in the handshaker classes                    
                </comment>
                <comment line="330">
                    It&apos;s really application data.  How much to consume?
                     Jump over the header.                    
                </comment>
                <comment line="341">
                    Use copy of BB                    
                </comment>
                <comment line="348">
                    Demarcate past header to end of packet.                    
                </comment>
                <comment line="352">
                    Protect remainder of buffer, create slice to actually
                     operate on.                    
                </comment>
                <scope line="307"/>
                <declaration name="srcPos" type="int" line="315"/>
                <declaration name="srcLim" type="int" line="316"/>
                <declaration name="recordVersion" type="ProtocolVersion" line="318"/>
                <scope line="324"/>
                <declaration name="len" type="int" line="333"/>
                <scope line="336">
                    <scope line="337">
                        <declaration name="hd" type="HexDumpEncoder" line="338"/>
                        <declaration name="bb" type="ByteBuffer" line="340"/>
                    </scope>
                    <scope line="344"/>
                </scope>
                <declaration name="bb" type="ByteBuffer" line="353"/>
            </method>
        </class>
    </source>