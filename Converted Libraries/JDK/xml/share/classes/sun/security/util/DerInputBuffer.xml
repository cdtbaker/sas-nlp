<?xml version="1.0" encoding="UTF-8"?>
    <source package="sun.security.util">
        <import package="java.io.ByteArrayInputStream"/>
        <import package="java.io.IOException"/>
        <import package="java.io.OutputStream"/>
        <import package="java.math.BigInteger"/>
        <import package="java.util.Date"/>
        <import package="sun.util.calendar.CalendarDate"/>
        <import package="sun.util.calendar.CalendarSystem"/>
        <class name="DerInputBuffer" line="36">
            <extends class="ByteArrayInputStream"/>
            <implements interface="Cloneable"/>
            <javadoc line="36">
                DER input buffer ... this is the main abstraction in the DER library
                  which actively works with the &quot;untyped byte stream&quot; abstraction.  It
                  does so with impunity, since it&apos;s not intended to be exposed to
                  anyone who could violate the &quot;typed value stream&quot; DER model and hence
                  corrupt the input stream of DER values.                
                <author>
                    David Brownell                    
                </author>
            </javadoc>
            <method name="DerInputBuffer" type="constructor" line="47">
                <params>
                    <param name="buf" type="byte[]"/>
                </params>
            </method>
            <method name="DerInputBuffer" type="constructor" line="49">
                <params>
                    <param name="buf" type="byte[]"/>
                    <param name="offset" type="int"/>
                    <param name="len" type="int"/>
                </params>
            </method>
            <method name="dup" type="DerInputBuffer" line="53">
                <scope line="54">
                    <declaration name="retval" type="DerInputBuffer" line="55"/>
                </scope>
                <scope line="59"/>
            </method>
            <method name="toByteArray" type="byte[]" line="64">
                <declaration name="len" type="int" line="65"/>
                <declaration name="retval" type="byte[]" line="68"/>
            </method>
            <method name="peek" type="int" line="74"/>
            <javadoc line="81">
                Compares this DerInputBuffer for equality with the specified
                  object.                
            </javadoc>
            <method name="equals" type="boolean" line="85">
                <params>
                    <param name="other" type="Object"/>
                </params>
            </method>
            <method name="equals" type="boolean" line="92">
                <params>
                    <param name="other" type="DerInputBuffer"/>
                </params>
                <declaration name="max" type="int" line="96"/>
                <scope line="99">
                    <scope line="100"/>
                </scope>
            </method>
            <javadoc line="107">
                Returns a hashcode for this DerInputBuffer.                
                <return>
                    a hashcode for this DerInputBuffer.                    
                </return>
            </javadoc>
            <method name="hashCode" type="int" line="112">
                <declaration name="retval" type="int" line="113"/>
                <declaration name="len" type="int" line="115"/>
                <declaration name="p" type="int" line="116"/>
            </method>
            <method name="truncate" type="void" line="123">
                <params>
                    <param name="len" type="int"/>
                </params>
            </method>
            <javadoc line="129">
                Returns the integer which takes up the specified number
                  of bytes in this buffer as a BigInteger.                
                <param>
                    len the number of bytes to use.                    
                </param>
                <param>
                    makePositive whether to always return a positive value,
                      irrespective of actual encoding                    
                </param>
                <return>
                    the integer as a BigInteger.                    
                </return>
            </javadoc>
            <method name="getBigInteger" type="BigInteger" line="137">
                <params>
                    <param name="len" type="int"/>
                    <param name="makePositive" type="boolean"/>
                </params>
                <scope line="141"/>
                <declaration name="bytes" type="byte[]" line="145"/>
                <scope line="150"/>
                <scope line="152"/>
            </method>
            <javadoc line="157">
                Returns the integer which takes up the specified number
                  of bytes in this buffer.                
                <throws>
                    IOException if the result is not within the valid
                      range for integer, i.e. between Integer.MIN_VALUE and
                      Integer.MAX_VALUE.                    
                </throws>
                <param>
                    len the number of bytes to use.                    
                </param>
                <return>
                    the integer.                    
                </return>
            </javadoc>
            <method name="getInteger" type="int" line="166">
                <params>
                    <param name="len" type="int"/>
                </params>
                <declaration name="result" type="BigInteger" line="168"/>
                <scope line="169"/>
                <scope line="172"/>
            </method>
            <javadoc line="178">
                Returns the bit string which takes up the specified
                  number of bytes in this buffer.                
            </javadoc>
            <method name="getBitString" type="byte[]" line="182">
                <params>
                    <param name="len" type="int"/>
                </params>
                <comment line="195">
                    minus the first byte which indicates the number of padding bits                    
                </comment>
                <comment line="199">
                    get rid of the padding bits                    
                </comment>
                <scope line="186"/>
                <declaration name="numOfPadBits" type="int" line="190"/>
                <scope line="191"/>
                <declaration name="retval" type="byte[]" line="195"/>
                <scope line="197"/>
            </method>
            <javadoc line="205">
                Returns the bit string which takes up the rest of this buffer.                
            </javadoc>
            <method name="getBitString" type="byte[]" line="208"/>
            <javadoc line="212">
                Returns the bit string which takes up the rest of this buffer.
                  The bit string need not be byte-aligned.                
            </javadoc>
            <method name="getUnalignedBitString" type="BitArray" line="216">
                <comment line="220">
                    Just copy the data into an aligned, padded octet buffer,
                     and consume the rest of the buffer.                    
                </comment>
                <comment line="230">
                    number of valid bits                    
                </comment>
                <declaration name="len" type="int" line="223"/>
                <declaration name="unusedBits" type="int" line="224"/>
                <scope line="225"/>
                <declaration name="bits" type="byte[]" line="228"/>
                <declaration name="length" type="int" line="230"/>
                <declaration name="bitArray" type="BitArray" line="234"/>
            </method>
            <javadoc line="239">
                Returns the UTC Time value that takes up the specified number
                  of bytes in this buffer.                
                <param>
                    len the number of bytes to use                    
                </param>
            </javadoc>
            <method name="getUTCTime" type="Date" line="244">
                <params>
                    <param name="len" type="int"/>
                </params>
            </method>
            <javadoc line="254">
                Returns the Generalized Time value that takes up the specified
                  number of bytes in this buffer.                
                <param>
                    len the number of bytes to use                    
                </param>
            </javadoc>
            <method name="getGeneralizedTime" type="Date" line="259">
                <params>
                    <param name="len" type="int"/>
                </params>
            </method>
            <javadoc line="270">
                Private helper routine to extract time from the der value.                
                <param>
                    len the number of bytes to use                    
                </param>
                <param>
                    generalized true if Generalized Time is to be read, false
                      if UTC Time is to be read.                    
                </param>
            </javadoc>
            <method name="getTime" type="Date" line="276">
                <params>
                    <param name="len" type="int"/>
                    <param name="generalized" type="boolean"/>
                </params>
                <comment line="279">
                    UTC time encoded as ASCII chars:
                           YYMMDDhhmmZ
                           YYMMDDhhmmssZ
                           YYMMDDhhmm+hhmm
                           YYMMDDhhmm-hhmm
                           YYMMDDhhmmss+hhmm
                           YYMMDDhhmmss-hhmm
                     UTC Time is broken in storing only two digits of year.
                     If YY &lt; 50, we assume 20YY;
                     if YY &gt;= 50, we assume 19YY, as per RFC 3280.
                    
                     Generalized time has a four-digit year and allows any
                     precision specified in ISO 8601. However, for our purposes,
                     we will only allow the same format as UTC time, except that
                     fractional seconds (millisecond precision) are supported.                    
                </comment>
                <comment line="306">
                    For the two extra YY                    
                </comment>
                <comment line="312">
                    origin 2000                    
                </comment>
                <comment line="315">
                    origin 1900                    
                </comment>
                <comment line="330">
                    YYMMDDhhmm                    
                </comment>
                <comment line="332">
                    We allow for non-encoded seconds, even though the
                     IETF-PKIX specification says that the seconds should
                     always be encoded even if it is zero.                    
                </comment>
                <comment line="343">
                    handle fractional seconds (if present)                    
                </comment>
                <comment line="347">
                    handle upto milisecond precision only                    
                </comment>
                <comment line="383">
                    Generalized time can theoretically allow any precision,
                     but we&apos;re not supporting that.                    
                </comment>
                <comment line="388">
                    no time zone                    
                </comment>
                <comment line="393">
                    Finally, &quot;Z&quot; or &quot;+hhmm&quot; or &quot;-hhmm&quot; ... offsets change hhmm                    
                </comment>
                <declaration name="year" type="int" line="296"/>
                <declaration name="type" type="String" line="297"/>
                <scope line="299"/>
                <scope line="306"/>
                <scope line="338">
                    <scope line="343">
                        <declaration name="precision" type="int" line="347"/>
                        <declaration name="peek" type="int" line="348"/>
                        <scope line="351"/>
                    </scope>
                </scope>
                <declaration name="gcal" type="CalendarSystem" line="386"/>
                <declaration name="date" type="CalendarDate" line="387"/>
                <declaration name="time" type="long" line="390"/>
                <declaration name="hr" type="int" line="398"/>
            </method>
        </class>
    </source>