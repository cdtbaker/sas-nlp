<?xml version="1.0" encoding="UTF-8"?>
    <source package="sun.security.util">
        <import package="java.io"/>
        <import package="java.math.BigInteger"/>
        <import package="java.util.Arrays"/>
        <class name="ObjectIdentifier" line="32">
            <comment line="65">
                IMPORTANT NOTES FOR CODE CHANGES (bug 4811968) IN JDK 1.7.0
                 ===========================================================
                
                 (Almost) serialization compatibility with old versions:
                
                 serialVersionUID is unchanged. Old field &quot;component&quot; is changed to
                 type Object so that &quot;poison&quot; (unknown object type for old versions)
                 can be put inside if there are huge components that cannot be saved
                 as integers.
                
                 New version use the new filed &quot;encoding&quot; only.
                
                 Below are all 4 cases in a serializationdeserialization process:
                
                 1. old -&gt; old: Not covered here
                 2. old -&gt; new: There&apos;s no &quot;encoding&quot; field, new readObject() reads
                    &quot;components&quot; and &quot;componentLen&quot; instead and inits correctly.
                 3. new -&gt; new: &quot;encoding&quot; field exists, new readObject() uses it
                    (ignoring the other 2 fields) and inits correctly.
                 4. new -&gt; old: old readObject() only recognizes &quot;components&quot; and
                    &quot;componentLen&quot; fields. If no huge components are involved, they
                    are serialized as legal values and old object can init correctly.
                    Otherwise, old object cannot recognize the form (component not int[])
                    and throw a ClassNotFoundException at deserialization time.
                
                 Therfore, for the first 3 cases, exact compatibility is preserved. In
                 the 4th case, non-huge OID is still supportable in old versions, while
                 huge OID is not.                
            </comment>
            <comment line="101">
                path from root                
            </comment>
            <comment line="105">
                how much is used.                
            </comment>
            <comment line="107">
                Is the components field calculated?                
            </comment>
            <comment line="264">
                Constructor, from the rest of a DER input buffer;
                 the tag and length have been removedverified
                 Validity check NOT included.                
            </comment>
            <comment line="314">
                n.b. the only public interface is DerOutputStream.putOID()                
            </comment>
            <comment line="590">
                Private methods to check validity of OID. They must be --
                 1. at least 2 components
                 2. all components must be non-negative
                 3. the first must be 0, 1 or 2
                 4. if the first is 0 or 1, the second must be &lt;40                
            </comment>
            <implements interface="Serializable"/>
            <javadoc line="32">
                Represent an ISO Object Identifier.
                  &lt;P&gt;Object Identifiers are arbitrary length hierarchical identifiers.
                  The individual components are numbers, and they define paths from the
                  root of an ISO-managed identifier space.  You will sometimes see a
                  string name used instead of (or in addition to) the numerical id.
                  These are synonyms for the numerical IDs, but are not widely used
                  since most sites do not know all the requisite strings, while all
                  sites can parse the numeric forms.
                  &lt;P&gt;So for example, JavaSoft has the sole authority to assign the
                  meaning to identifiers below the 1.3.6.1.4.1.42.2.17 node in the
                  hierarchy, and other organizations can easily acquire the ability
                  to assign such unique identifiers.                
                <author>
                    David Brownell                    
                </author>
                <author>
                    Amit Kapoor                    
                </author>
                <author>
                    Hemma Prafullchandra                    
                </author>
            </javadoc>
            <declaration name="encoding" type="byte[]" line="56"/>
            <javadoc line="56">
                We use the DER value (no tag, no length) as the internal format                
                <serial>
                                        
                </serial>
            </javadoc>
            <declaration name="stringForm" type="String" line="62"/>
            <declaration name="serialVersionUID" type="long" line="94"/>
            <declaration name="components" type="Object" line="96"/>
            <javadoc line="96">
                Changed to Object                
                <serial>
                                        
                </serial>
            </javadoc>
            <declaration name="componentLen" type="int" line="101"/>
            <javadoc line="101">
                @serial                
            </javadoc>
            <declaration name="componentsCalculated" type="boolean" line="107"/>
            <method name="readObject" type="void" line="110">
                <params>
                    <param name="is" type="ObjectInputStream"/>
                </params>
                <comment line="113">
                    from an old version                    
                </comment>
                <scope line="113"/>
            </method>
            <method name="writeObject" type="void" line="119">
                <params>
                    <param name="os" type="ObjectOutputStream"/>
                </params>
                <comment line="122">
                    every one understands this                    
                </comment>
                <scope line="120">
                    <declaration name="comps" type="int[]" line="121"/>
                    <scope line="122"/>
                    <scope line="125"/>
                </scope>
            </method>
            <class name="HugeOidNotSupportedByOldJDK" line="133">
                <implements interface="Serializable"/>
                <declaration name="serialVersionUID" type="long" line="134"/>
                <declaration name="theOne" type="HugeOidNotSupportedByOldJDK" line="135"/>
            </class>
            <javadoc line="138">
                Constructs, from a string.  This string should be of the form 1.23.56.
                  Validity check included.                
            </javadoc>
            <method name="ObjectIdentifier" type="constructor" line="143">
                <params>
                    <param name="oid" type="String"/>
                </params>
                <comment line="156">
                    length of one section                    
                </comment>
                <comment line="203">
                    already detected by checkXXX                    
                </comment>
                <declaration name="ch" type="int" line="144"/>
                <declaration name="start" type="int" line="145"/>
                <declaration name="end" type="int" line="146"/>
                <declaration name="pos" type="int" line="148"/>
                <declaration name="tmp" type="byte[]" line="149"/>
                <declaration name="first" type="int" line="150"/>
                <declaration name="count" type="int" line="151"/>
                <scope line="153">
                    <declaration name="comp" type="String" line="154"/>
                    <scope line="155">
                        <declaration name="length" type="int" line="156"/>
                        <scope line="158"/>
                        <scope line="161"/>
                        <scope line="166">
                            <declaration name="bignum" type="BigInteger" line="167"/>
                            <scope line="168"/>
                            <scope line="171">
                                <scope line="172"/>
                                <scope line="175"/>
                            </scope>
                        </scope>
                        <scope line="180">
                            <declaration name="num" type="int" line="181"/>
                            <scope line="182"/>
                            <scope line="185">
                                <scope line="186"/>
                                <scope line="189"/>
                            </scope>
                        </scope>
                    </scope>
                </scope>
                <scope line="203"/>
                <scope line="205"/>
            </method>
            <javadoc line="211">
                Constructor, from an array of integers.
                  Validity check included.                
            </javadoc>
            <method name="ObjectIdentifier" type="constructor" line="216">
                <params>
                    <param name="values" type="int"/>
                </params>
            </method>
            <javadoc line="225">
                Constructor, from an ASN.1 encoded input stream.
                  Validity check NOT included.
                  The encoding of the ID in the stream uses &quot;DER&quot;, a BER/1 subset.
                  In this case, that means a triple { typeId, length, data }.
                  &lt;P&gt;&lt;STRONG&gt;NOTE:&lt;/STRONG&gt;  When an exception is thrown, the
                  input stream has not been returned to its &quot;initial&quot; state.                
                <param>
                    in DER-encoded data holding an object ID                    
                </param>
                <exception>
                    IOException indicates a decoding error                    
                </exception>
            </javadoc>
            <method name="ObjectIdentifier" type="constructor" line="238">
                <params>
                    <param name="in" type="DerInputStream"/>
                </params>
                <comment line="242">
                    Object IDs are a &quot;universal&quot; type, and their tag needs only
                     one byte of encoding.  Verify that the tag of this datum
                     is that of an object ID.
                    
                     Then get and check the length of the ID&apos;s encoding.  We set
                     up so that we can use in.available() to check for the end of
                     this value in the data stream.                    
                </comment>
                <declaration name="type_id" type="byte" line="239"/>
                <declaration name="bufferEnd" type="int" line="240"/>
            </method>
            <method name="ObjectIdentifier" type="constructor" line="269">
                <params>
                    <param name="buf" type="DerInputBuffer"/>
                </params>
                <declaration name="in" type="DerInputStream" line="270"/>
            </method>
            <method name="init" type="void" line="276">
                <params>
                    <param name="components" type="int[]"/>
                    <param name="length" type="int"/>
                </params>
                <comment line="278">
                    +1 for empty input                    
                </comment>
                <declaration name="pos" type="int" line="277"/>
                <declaration name="tmp" type="byte[]" line="278"/>
                <scope line="282">
                    <declaration name="big" type="BigInteger" line="283"/>
                </scope>
                <scope line="288"/>
            </method>
            <javadoc line="295">
                This method is kept for compatibility reasons. The new implementation
                  does the check and conversion. All around the JDK, the method is called
                  in static blocks to initialize pre-defined ObjectIdentifieies. No
                  obvious performance hurt will be made after this change.
                  Old doc: Create a new ObjectIdentifier for internal use. The values are
                  neither checked nor cloned.                
            </javadoc>
            <method name="newInternal" type="ObjectIdentifier" line="304">
                <params>
                    <param name="values" type="int[]"/>
                </params>
                <comment line="309">
                    Should not happen, internal calls always uses legal values.                    
                </comment>
                <scope line="305"/>
                <scope line="307"/>
            </method>
            <method name="encode" type="void" line="317">
                <params>
                    <param name="out" type="DerOutputStream"/>
                </params>
            </method>
            <javadoc line="321">
                @deprecated Use equals((Object)oid)                
            </javadoc>
            <method name="equals" type="boolean" line="325">
                <params>
                    <param name="other" type="ObjectIdentifier"/>
                </params>
            </method>
            <javadoc line="329">
                Compares this identifier with another, for equality.                
                <return>
                    true iff the names are identical.                    
                </return>
            </javadoc>
            <method name="equals" type="boolean" line="335">
                <params>
                    <param name="obj" type="Object"/>
                </params>
                <scope line="336"/>
                <scope line="339"/>
                <declaration name="other" type="ObjectIdentifier" line="342"/>
            </method>
            <method name="hashCode" type="int" line="347"/>
            <javadoc line="351">
                Private helper method for serialization. To be compatible with old
                  versions of JDK.                
                <return>
                    components in an int array, if all the components are less than
                      Integer.MAX_VALUE. Otherwise, null.                    
                </return>
            </javadoc>
            <method name="toIntArray" type="int[]" line="357">
                <comment line="364">
                    one section [fromPos..i]                    
                </comment>
                <declaration name="length" type="int" line="358"/>
                <declaration name="result" type="int[]" line="359"/>
                <declaration name="which" type="int" line="360"/>
                <declaration name="fromPos" type="int" line="361"/>
                <scope line="362">
                    <scope line="363">
                        <scope line="365">
                            <declaration name="big" type="BigInteger" line="366"/>
                            <scope line="367">
                                <declaration name="second" type="BigInteger" line="369"/>
                                <scope line="370"/>
                                <scope line="372"/>
                            </scope>
                            <scope line="375">
                                <scope line="376"/>
                                <scope line="378"/>
                            </scope>
                        </scope>
                        <scope line="382">
                            <declaration name="retval" type="int" line="383"/>
                            <scope line="384">
                                <declaration name="tmp" type="byte" line="386"/>
                            </scope>
                            <scope line="389">
                                <scope line="390"/>
                                <scope line="393"/>
                            </scope>
                            <scope line="397"/>
                        </scope>
                    </scope>
                    <scope line="403"/>
                </scope>
            </method>
            <javadoc line="410">
                Returns a string form of the object ID.  The format is the
                  conventional &quot;dot&quot; notation for such IDs, without any
                  user-friendly descriptive strings, since those strings
                  will not be understood everywhere.                
            </javadoc>
            <method name="toString" type="String" line="417">
                <comment line="426">
                    one section [fromPos..i]                    
                </comment>
                <comment line="427">
                    not the first segment                    
                </comment>
                <comment line="430">
                    maybe big integer                    
                </comment>
                <comment line="433">
                    first section encoded with more than 4 bytes,                    
                </comment>
                <comment line="434">
                    must be 2.something                    
                </comment>
                <comment line="440">
                    small integer                    
                </comment>
                <declaration name="s" type="String" line="418"/>
                <scope line="419">
                    <declaration name="length" type="int" line="420"/>
                    <declaration name="sb" type="StringBuffer" line="421"/>
                    <declaration name="fromPos" type="int" line="423"/>
                    <scope line="424">
                        <scope line="425">
                            <scope line="427"/>
                            <scope line="430">
                                <declaration name="big" type="BigInteger" line="431"/>
                                <scope line="432"/>
                                <scope line="437"/>
                            </scope>
                            <scope line="440">
                                <declaration name="retval" type="int" line="441"/>
                                <scope line="442">
                                    <declaration name="tmp" type="byte" line="444"/>
                                </scope>
                                <scope line="447">
                                    <scope line="448"/>
                                    <scope line="452"/>
                                </scope>
                                <scope line="456"/>
                            </scope>
                        </scope>
                    </scope>
                </scope>
            </method>
            <javadoc line="469">
                Repack all bits from input to output. On the both sides, only a portion
                  (from the least significant bit) of the 8 bits in a byte is used. This
                  number is defined as the number of useful bits (NUB) for the array. All the
                  used bits from the input byte array and repacked into the output in the
                  exactly same order. The output bits are aligned so that the final bit of
                  the input (the least significant bit in the last byte), when repacked as
                  the final bit of the output, is still at the least significant position.
                  Zeroes will be padded on the left side of the first output byte if
                  necessary. All unused bits in the output are also zeroed.
                  For example: if the input is 01001100 with NUB 8, the output which
                  has a NUB 6 will look like:
                  00000001 00001100
                  The first 2 bits of the output bytes are unused bits. The other bits
                  turn out to be 000001 001100. While the 8 bits on the right are from
                  the input, the left 4 zeroes are padded to fill the 6 bits space.                
                <param>
                    in        the input byte array                    
                </param>
                <param>
                    ioffset   start point inside <code>in</code>                    
                </param>
                <param>
                    ilength   number of bytes to repack                    
                </param>
                <param>
                    iw        NUB for input                    
                </param>
                <param>
                    ow        NUB for output                    
                </param>
                <return>
                    the repacked bytes                    
                </return>
            </javadoc>
            <method name="pack" type="byte[]" line="494">
                <params>
                    <param name="in" type="byte[]"/>
                    <param name="ioffset" type="int"/>
                    <param name="ilength" type="int"/>
                    <param name="iw" type="int"/>
                    <param name="ow" type="int"/>
                </params>
                <comment line="502">
                    number of all used bits                    
                </comment>
                <comment line="505">
                    starting from the 0th bit in the input                    
                </comment>
                <comment line="508">
                    the number of padding 0&apos;s needed in the output, skip them                    
                </comment>
                <comment line="512">
                    unpacked bits in current input byte                    
                </comment>
                <comment line="513">
                    free space available in output byte                    
                </comment>
                <comment line="514">
                    choose the smaller number                    
                </comment>
                <comment line="516">
                    and move them!                    
                </comment>
                <comment line="517">
                    paste!                    
                </comment>
                <comment line="518">
                    locate the byte (+256 so that it&apos;s never negative)                    
                </comment>
                <comment line="519">
                    move to the end of a byte                    
                </comment>
                <comment line="520">
                    zero out all other bits                    
                </comment>
                <comment line="521">
                    move to the output position                    
                </comment>
                <comment line="522">
                    advance                    
                </comment>
                <comment line="523">
                    advance                    
                </comment>
                <scope line="498"/>
                <declaration name="bits" type="int" line="502"/>
                <declaration name="out" type="byte[]" line="503"/>
                <declaration name="ipos" type="int" line="506"/>
                <declaration name="opos" type="int" line="509"/>
                <scope line="511">
                    <declaration name="count" type="int" line="512"/>
                    <scope line="513"/>
                </scope>
            </method>
            <javadoc line="528">
                Repack from NUB 8 to a NUB 7 OID sub-identifier, remove all
                  unnecessary 0 headings, set the first bit of all non-tail
                  output bytes to 1 (as ITU-T Rec. X.690 8.19.2 says), and
                  paste it into an existing byte array.                
                <param>
                    out the existing array to be pasted into                    
                </param>
                <param>
                    ooffset the starting position to paste                    
                </param>
                <return>
                    the number of bytes pasted                    
                </return>
            </javadoc>
            <method name="pack7Oid" type="int" line="537">
                <params>
                    <param name="in" type="byte[]"/>
                    <param name="ioffset" type="int"/>
                    <param name="ilength" type="int"/>
                    <param name="out" type="byte[]"/>
                    <param name="ooffset" type="int"/>
                </params>
                <comment line="539">
                    paste at least one byte                    
                </comment>
                <declaration name="pack" type="byte[]" line="538"/>
                <declaration name="firstNonZero" type="int" line="539"/>
                <scope line="540">
                    <scope line="541"/>
                </scope>
            </method>
            <javadoc line="550">
                Repack from NUB 7 to NUB 8, remove all unnecessary 0
                  headings, and paste it into an existing byte array.                
                <param>
                    out the existing array to be pasted into                    
                </param>
                <param>
                    ooffset the starting position to paste                    
                </param>
                <return>
                    the number of bytes pasted                    
                </return>
            </javadoc>
            <method name="pack8" type="int" line="557">
                <params>
                    <param name="in" type="byte[]"/>
                    <param name="ioffset" type="int"/>
                    <param name="ilength" type="int"/>
                    <param name="out" type="byte[]"/>
                    <param name="ooffset" type="int"/>
                </params>
                <comment line="559">
                    paste at least one byte                    
                </comment>
                <declaration name="pack" type="byte[]" line="558"/>
                <declaration name="firstNonZero" type="int" line="559"/>
                <scope line="560">
                    <scope line="561"/>
                </scope>
            </method>
            <javadoc line="569">
                Pack the int into a OID sub-identifier DER encoding                
            </javadoc>
            <method name="pack7Oid" type="int" line="572">
                <params>
                    <param name="input" type="int"/>
                    <param name="out" type="byte[]"/>
                    <param name="ooffset" type="int"/>
                </params>
                <declaration name="b" type="byte[]" line="573"/>
            </method>
            <javadoc line="581">
                Pack the BigInteger into a OID subidentifier DER encoding                
            </javadoc>
            <method name="pack7Oid" type="int" line="584">
                <params>
                    <param name="input" type="BigInteger"/>
                    <param name="out" type="byte[]"/>
                    <param name="ooffset" type="int"/>
                </params>
                <declaration name="b" type="byte[]" line="585"/>
            </method>
            <javadoc line="597">
                Check the DER encoding. Since DER encoding defines that the integer bits
                  are unsigned, so there&apos;s no need to check the MSB.                
            </javadoc>
            <method name="check" type="void" line="601">
                <params>
                    <param name="encoding" type="byte[]"/>
                </params>
                <comment line="603">
                    too short                    
                </comment>
                <comment line="604">
                    not ended                    
                </comment>
                <comment line="609">
                    0x80 at the beginning of a subidentifier                    
                </comment>
                <declaration name="length" type="int" line="602"/>
                <scope line="604"/>
                <scope line="608">
                    <scope line="611"/>
                </scope>
            </method>
            <method name="checkCount" type="void" line="617">
                <params>
                    <param name="count" type="int"/>
                </params>
                <scope line="618"/>
            </method>
            <method name="checkFirstComponent" type="void" line="623">
                <params>
                    <param name="first" type="int"/>
                </params>
                <scope line="624"/>
            </method>
            <method name="checkFirstComponent" type="void" line="629">
                <params>
                    <param name="first" type="BigInteger"/>
                </params>
                <scope line="631"/>
            </method>
            <method name="checkSecondComponent" type="void" line="636">
                <params>
                    <param name="first" type="int"/>
                    <param name="second" type="int"/>
                </params>
                <scope line="637"/>
            </method>
            <method name="checkSecondComponent" type="void" line="642">
                <params>
                    <param name="first" type="int"/>
                    <param name="second" type="BigInteger"/>
                </params>
                <scope line="645"/>
            </method>
            <method name="checkOtherComponent" type="void" line="650">
                <params>
                    <param name="i" type="int"/>
                    <param name="num" type="int"/>
                </params>
                <scope line="651"/>
            </method>
            <method name="checkOtherComponent" type="void" line="656">
                <params>
                    <param name="i" type="int"/>
                    <param name="num" type="BigInteger"/>
                </params>
                <scope line="657"/>
            </method>
        </class>
    </source>