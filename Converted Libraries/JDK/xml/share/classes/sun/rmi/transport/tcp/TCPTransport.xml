<?xml version="1.0" encoding="UTF-8"?>
    <source package="sun.rmi.transport.tcp">
        <import package="java.lang.ref.Reference"/>
        <import package="java.lang.ref.SoftReference"/>
        <import package="java.lang.ref.WeakReference"/>
        <import package="java.lang.reflect.InvocationTargetException"/>
        <import package="java.io.DataInputStream"/>
        <import package="java.io.DataOutputStream"/>
        <import package="java.io.IOException"/>
        <import package="java.io.InputStream"/>
        <import package="java.io.OutputStream"/>
        <import package="java.io.BufferedInputStream"/>
        <import package="java.io.BufferedOutputStream"/>
        <import package="java.net.InetAddress"/>
        <import package="java.net.ServerSocket"/>
        <import package="java.net.Socket"/>
        <import package="java.rmi.RemoteException"/>
        <import package="java.rmi.server.ExportException"/>
        <import package="java.rmi.server.LogStream"/>
        <import package="java.rmi.server.RMIFailureHandler"/>
        <import package="java.rmi.server.RMISocketFactory"/>
        <import package="java.rmi.server.RemoteCall"/>
        <import package="java.rmi.server.ServerNotActiveException"/>
        <import package="java.rmi.server.UID"/>
        <import package="java.security.AccessControlContext"/>
        <import package="java.security.AccessController"/>
        <import package="java.util.ArrayList"/>
        <import package="java.util.LinkedList"/>
        <import package="java.util.List"/>
        <import package="java.util.Map"/>
        <import package="java.util.WeakHashMap"/>
        <import package="java.util.logging.Level"/>
        <import package="java.util.concurrent.ExecutorService"/>
        <import package="java.util.concurrent.RejectedExecutionException"/>
        <import package="java.util.concurrent.SynchronousQueue"/>
        <import package="java.util.concurrent.ThreadFactory"/>
        <import package="java.util.concurrent.ThreadPoolExecutor"/>
        <import package="java.util.concurrent.TimeUnit"/>
        <import package="java.util.concurrent.atomic.AtomicInteger"/>
        <import package="sun.rmi.runtime.Log"/>
        <import package="sun.rmi.runtime.NewThreadAction"/>
        <import package="sun.rmi.transport.Channel"/>
        <import package="sun.rmi.transport.Connection"/>
        <import package="sun.rmi.transport.DGCAckHandler"/>
        <import package="sun.rmi.transport.Endpoint"/>
        <import package="sun.rmi.transport.StreamRemoteCall"/>
        <import package="sun.rmi.transport.Target"/>
        <import package="sun.rmi.transport.Transport"/>
        <import package="sun.rmi.transport.TransportConstants"/>
        <import package="sun.rmi.transport.proxy.HttpReceiveSocket"/>
        <import package="sun.security.action.GetIntegerAction"/>
        <import package="sun.security.action.GetLongAction"/>
        <import package="sun.security.action.GetPropertyAction"/>
        <class name="TCPTransport" line="79">
            <extends class="Transport"/>
            <comment line="89">
                                
            </comment>
            <javadoc line="79">
                TCPTransport is the socket-based implementation of the RMI Transport
                  abstraction.                
                <author>
                    Ann Wollrath                    
                </author>
                <author>
                    Peter Jones                    
                </author>
            </javadoc>
            <declaration name="tcpLog" type="Log" line="89"/>
            <declaration name="maxConnectionThreads" type="int" line="93"/>
            <javadoc line="93">
                maximum number of connection handler threads                
            </javadoc>
            <declaration name="threadKeepAliveTime" type="long" line="99"/>
            <javadoc line="99">
                keep alive time for idle connection handler threads                
            </javadoc>
            <declaration name="connectionThreadPool" type="ExecutorService" line="105"/>
            <javadoc line="105">
                thread pool for connection handlers                
            </javadoc>
            <anonymous_class line="110">
                <method name="newThread" type="Thread" line="111">
                    <params>
                        <param name="runnable" type="Runnable"/>
                    </params>
                </method>
            </anonymous_class>
            <declaration name="connectionCount" type="AtomicInteger" line="117"/>
            <javadoc line="117">
                total connections handled                
            </javadoc>
            <declaration name="threadConnectionHandler" type="ThreadLocal&lt;ConnectionHandler&gt;" line="120"/>
            <javadoc line="120">
                client host for the current thread&apos;s connection                
            </javadoc>
            <declaration name="epList" type="LinkedList&lt;TCPEndpoint&gt;" line="124"/>
            <javadoc line="124">
                endpoints for this transport                
            </javadoc>
            <declaration name="exportCount" type="int" line="126"/>
            <javadoc line="126">
                number of objects exported on this transport                
            </javadoc>
            <declaration name="server" type="ServerSocket" line="128"/>
            <javadoc line="128">
                server socket for this transport                
            </javadoc>
            <declaration name="channelTable" type="Map&lt;TCPEndpoint,Reference&lt;TCPChannel&gt;&gt;" line="130"/>
            <javadoc line="130">
                table mapping endpoints to channels                
            </javadoc>
            <declaration name="defaultSocketFactory" type="RMISocketFactory" line="134"/>
            <declaration name="connectionReadTimeout" type="int" line="137"/>
            <javadoc line="137">
                number of milliseconds in accepted-connection timeout.
                  Warning: this should be greater than 15 seconds (the client-side
                  timeout), and defaults to 2 hours.
                  The maximum representable value is slightly more than 24 days
                  and 20 hours.                
            </javadoc>
            <javadoc line="148">
                Constructs a TCPTransport.                
            </javadoc>
            <method name="TCPTransport" type="constructor" line="151">
                <params>
                    <param name="epList" type="LinkedList<TCPEndpoint>"/>
                </params>
                <comment line="153">
                    assert ((epList.size() != null) &amp;&amp; (epList.size() &gt;= 1))                    
                </comment>
                <scope line="154"/>
            </method>
            <javadoc line="160">
                Closes all cached connections in every channel subordinated to this
                  transport.  Currently, this only closes outgoing connections.                
            </javadoc>
            <method name="shedConnectionCaches" type="void" line="164">
                <declaration name="channels" type="List&lt;TCPChannel&gt;" line="165"/>
                <scope line="166">
                    <scope line="168">
                        <declaration name="ch" type="TCPChannel" line="169"/>
                        <scope line="170"/>
                    </scope>
                </scope>
                <scope line="175"/>
            </method>
            <javadoc line="180">
                Returns a &lt;I&gt;Channel&lt;/I&gt; that generates connections to the
                  endpoint &lt;I&gt;ep&lt;/I&gt;. A Channel is an object that creates and
                  manages connections of a particular type to some particular
                  address space.                
                <param>
                    ep the endpoint to which connections will be generated.                    
                </param>
                <return>
                    the channel or null if the transport cannot
                      generate connections to this endpoint                    
                </return>
            </javadoc>
            <method name="getChannel" type="TCPChannel" line="189">
                <params>
                    <param name="ep" type="Endpoint"/>
                </params>
                <declaration name="ch" type="TCPChannel" line="190"/>
                <scope line="191">
                    <scope line="192">
                        <declaration name="ref" type="Reference&lt;TCPChannel&gt;" line="193"/>
                        <scope line="194"/>
                        <scope line="197">
                            <declaration name="tcpEndpoint" type="TCPEndpoint" line="198"/>
                        </scope>
                    </scope>
                </scope>
            </method>
            <javadoc line="208">
                Removes the &lt;I&gt;Channel&lt;/I&gt; that generates connections to the
                  endpoint &lt;I&gt;ep&lt;/I&gt;.                
            </javadoc>
            <method name="free" type="void" line="212">
                <params>
                    <param name="ep" type="Endpoint"/>
                </params>
                <scope line="213">
                    <scope line="214">
                        <declaration name="ref" type="Reference&lt;TCPChannel&gt;" line="215"/>
                        <scope line="216">
                            <declaration name="channel" type="TCPChannel" line="217"/>
                            <scope line="218"/>
                        </scope>
                    </scope>
                </scope>
            </method>
            <javadoc line="226">
                Export the object so that it can accept incoming calls.                
            </javadoc>
            <method name="exportObject" type="void" line="229">
                <params>
                    <param name="target" type="Target"/>
                </params>
                <comment line="231">
                    Ensure that a server socket is listening, and count this
                     export while synchronized to prevent the server socket from
                     being closed due to concurrent unexports.                    
                </comment>
                <comment line="241">
                    Try to add the Target to the exported object table; keep
                     counting this export (to keep server socket open) only if
                     that succeeds.                    
                </comment>
                <scope line="235"/>
                <declaration name="ok" type="boolean" line="245"/>
                <scope line="246"/>
                <scope line="249">
                    <scope line="250">
                        <scope line="251"/>
                    </scope>
                </scope>
            </method>
            <method name="targetUnexported" type="void" line="258"/>
            <javadoc line="262">
                Decrements the count of exported objects, closing the current
                  server socket if the count reaches zero.                
            </javadoc>
            <method name="decrementExportCount" type="void" line="266">
                <scope line="269">
                    <declaration name="ss" type="ServerSocket" line="270"/>
                    <scope line="272"/>
                    <scope line="274"/>
                </scope>
            </method>
            <javadoc line="279">
                Verify that the current access control context has permission to
                  accept the connection being dispatched by the current thread.                
            </javadoc>
            <method name="checkAcceptPermission" type="void" line="283">
                <params>
                    <param name="acc" type="AccessControlContext"/>
                </params>
                <declaration name="sm" type="SecurityManager" line="284"/>
                <scope line="285"/>
                <declaration name="h" type="ConnectionHandler" line="288"/>
                <scope line="289"/>
            </method>
            <method name="getEndpoint" type="TCPEndpoint" line="296">
                <scope line="297"/>
            </method>
            <javadoc line="302">
                Listen on transport&apos;s endpoint.                
            </javadoc>
            <method name="listen" type="void" line="305">
                <comment line="319">
                    Don&apos;t retry ServerSocket if creation fails since
                     &quot;port in use&quot; will cause export to hang if an
                     RMIFailureHandler is not installed.                    
                </comment>
                <comment line="335">
                    otherwise verify security access to existing server socket                    
                </comment>
                <declaration name="ep" type="TCPEndpoint" line="307"/>
                <declaration name="port" type="int" line="308"/>
                <scope line="310">
                    <scope line="311"/>
                    <scope line="316">
                        <declaration name="t" type="Thread" line="323"/>
                    </scope>
                    <scope line="327"/>
                    <scope line="329"/>
                </scope>
                <scope line="333">
                    <declaration name="sm" type="SecurityManager" line="335"/>
                    <scope line="336"/>
                </scope>
            </method>
            <class name="AcceptLoop" line="342">
                <comment line="350">
                    state for throttling loop on exceptions (local to accept thread)                    
                </comment>
                <implements interface="Runnable"/>
                <javadoc line="342">
                    Worker for accepting connections from a server socket.                    
                </javadoc>
                <declaration name="serverSocket" type="ServerSocket" line="347"/>
                <declaration name="lastExceptionTime" type="long" line="350"/>
                <declaration name="recentExceptionCount" type="int" line="351"/>
                <method name="AcceptLoop" type="constructor" line="353">
                    <params>
                        <param name="serverSocket" type="ServerSocket"/>
                    </params>
                </method>
                <method name="run" type="void" line="357">
                    <comment line="363">
                        Only one accept loop is started per server
                         socket, so after no more connections will be
                         accepted, ensure that the server socket is no
                         longer listening.                        
                    </comment>
                    <scope line="358"/>
                    <scope line="360">
                        <scope line="361"/>
                        <scope line="369"/>
                    </scope>
                </method>
                <javadoc line="374">
                    Accepts connections from the server socket and executes
                      handlers for them in the thread pool.                    
                </javadoc>
                <method name="executeAcceptLoop" type="void" line="378">
                    <comment line="390">
                        Find client host name (or &quot;0.0.0.0&quot; if unknown)                        
                    </comment>
                    <comment line="398">
                        Execute connection handler in the thread pool,
                         which uses non-system threads.                        
                    </comment>
                    <comment line="413">
                        If the server socket has been closed, such
                         as because there are no more exported
                         objects, then we expect accept to throw an
                         exception, so just terminate normally.                        
                    </comment>
                    <comment line="432">
                        Always close the accepted socket (if any)
                         if an exception occurs, but only after
                         logging an unexpected exception.                        
                    </comment>
                    <comment line="442">
                        In case we&apos;re running out of file descriptors,
                         release resources held in caches.                        
                    </comment>
                    <comment line="453">
                        A NoClassDefFoundError can occur if no file
                         descriptors are available, in which case this
                         loop should not terminate.                        
                    </comment>
                    <comment line="465">
                        continue loop                        
                    </comment>
                    <scope line="379"/>
                    <scope line="384">
                        <declaration name="socket" type="Socket" line="385"/>
                        <scope line="386">
                            <declaration name="clientAddr" type="InetAddress" line="392"/>
                            <declaration name="clientHost" type="String" line="393"/>
                            <scope line="401"/>
                            <scope line="404"/>
                        </scope>
                        <scope line="410">
                            <scope line="411">
                                <scope line="418"/>
                                <scope line="422">
                                    <scope line="423"/>
                                </scope>
                                <scope line="428"/>
                            </scope>
                            <scope line="430">
                                <scope line="436"/>
                            </scope>
                            <scope line="445">
                                <scope line="446"/>
                                <scope line="448"/>
                            </scope>
                            <scope line="460">
                                <scope line="461"/>
                            </scope>
                            <scope line="465"/>
                        </scope>
                    </scope>
                </method>
                <javadoc line="472">
                    Returns true if the accept loop should continue after the
                      specified exception has been caught, or false if the accept
                      loop should terminate (closing the server socket).  If
                      there is an RMIFailureHandler, this method returns the
                      result of passing the specified exception to it; otherwise,
                      this method always returns true, after sleeping to throttle
                      the accept loop if necessary.                    
                </javadoc>
                <method name="continueAfterAcceptFailure" type="boolean" line="481">
                    <params>
                        <param name="t" type="Throwable"/>
                    </params>
                    <declaration name="fh" type="RMIFailureHandler" line="482"/>
                    <scope line="483"/>
                    <scope line="486"/>
                </method>
                <javadoc line="492">
                    Throttles the accept loop after an exception has been
                      caught: if a burst of 10 exceptions in 5 seconds occurs,
                      then wait for 10 seconds to curb busy CPU usage.                    
                </javadoc>
                <method name="throttleLoopOnException" type="void" line="497">
                    <comment line="501">
                        last exception was long ago (or this is the first)                        
                    </comment>
                    <comment line="505">
                        exception burst window was started recently                        
                    </comment>
                    <declaration name="now" type="long" line="498"/>
                    <scope line="499"/>
                    <scope line="503">
                        <scope line="505">
                            <scope line="506"/>
                            <scope line="508"/>
                        </scope>
                    </scope>
                </method>
            </class>
            <javadoc line="515">
                close socket and eat exception                
            </javadoc>
            <method name="closeSocket" type="void" line="516">
                <params>
                    <param name="sock" type="Socket"/>
                </params>
                <comment line="521">
                    eat exception                    
                </comment>
                <scope line="517"/>
                <scope line="519"/>
            </method>
            <javadoc line="524">
                handleMessages decodes transport operations and handles messages
                  appropriately.  If an exception occurs during message handling,
                  the socket is closed.                
            </javadoc>
            <method name="handleMessages" type="void" line="529">
                <params>
                    <param name="conn" type="Connection"/>
                    <param name="persistent" type="boolean"/>
                </params>
                <comment line="536">
                    transport op                    
                </comment>
                <comment line="552">
                    service incoming RMI call                    
                </comment>
                <comment line="559">
                    send ack for ping                    
                </comment>
                <comment line="576">
                    exception during processing causes connection to close (below)                    
                </comment>
                <comment line="585">
                    eat exception                    
                </comment>
                <declaration name="port" type="int" line="530"/>
                <scope line="532">
                    <declaration name="in" type="DataInputStream" line="533"/>
                    <scope line="534">
                        <declaration name="op" type="int" line="535"/>
                        <scope line="536">
                            <scope line="537"/>
                        </scope>
                        <scope line="544"/>
                        <declaration name="call" type="RemoteCall" line="552"/>
                        <declaration name="out" type="DataOutputStream" line="559"/>
                    </scope>
                </scope>
                <scope line="574">
                    <scope line="576"/>
                </scope>
                <scope line="580">
                    <scope line="581"/>
                    <scope line="583"/>
                </scope>
            </method>
            <javadoc line="589">
                Returns the client host for the current thread&apos;s connection.  Throws
                  ServerNotActiveException if no connection is active for this thread.                
            </javadoc>
            <method name="getClientHost" type="String" line="593">
                <declaration name="h" type="ConnectionHandler" line="594"/>
                <scope line="595"/>
                <scope line="597"/>
            </method>
            <class name="ConnectionHandler" line="602">
                <comment line="350">
                    state for throttling loop on exceptions (local to accept thread)                    
                </comment>
                <implements interface="Runnable"/>
                <javadoc line="602">
                    Services messages on accepted connection                    
                </javadoc>
                <declaration name="POST" type="int" line="607"/>
                <javadoc line="607">
                    int value of &quot;POST&quot; in ASCII (Java&apos;s specified data formats
                      make this once-reviled tactic again socially acceptable)                    
                </javadoc>
                <declaration name="okContext" type="AccessControlContext" line="611"/>
                <javadoc line="611">
                    most recently accept-authorized AccessControlContext                    
                </javadoc>
                <declaration name="authCache" type="Map&lt;AccessControlContext,Reference&lt;AccessControlContext&gt;&gt;" line="613"/>
                <javadoc line="613">
                    cache of accept-authorized AccessControlContexts                    
                </javadoc>
                <declaration name="cacheSecurityManager" type="SecurityManager" line="616"/>
                <javadoc line="616">
                    security manager which authorized contexts in authCache                    
                </javadoc>
                <declaration name="socket" type="Socket" line="619"/>
                <declaration name="remoteHost" type="String" line="620"/>
                <method name="ConnectionHandler" type="constructor" line="622">
                    <params>
                        <param name="socket" type="Socket"/>
                        <param name="remoteHost" type="String"/>
                    </params>
                </method>
                <method name="getClientHost" type="String" line="627"/>
                <javadoc line="631">
                    Verify that the given AccessControlContext has permission to
                      accept this connection.                    
                </javadoc>
                <method name="checkAcceptPermission" type="void" line="637">
                    <params>
                        <param name="sm" type="SecurityManager"/>
                        <param name="acc" type="AccessControlContext"/>
                    </params>
                    <comment line="639">
                        Note: no need to synchronize on cache-related fields, since this
                         method only gets called from the ConnectionHandler&apos;s thread.                        
                    </comment>
                    <scope line="642"/>
                    <scope line="648"/>
                    <declaration name="addr" type="InetAddress" line="651"/>
                    <declaration name="host" type="String" line="652"/>
                </method>
                <method name="run" type="void" line="660">
                    <declaration name="t" type="Thread" line="661"/>
                    <declaration name="name" type="String" line="662"/>
                    <scope line="663"/>
                    <scope line="668"/>
                </method>
                <method name="run0" type="void" line="673">
                    <comment line="680">
                        set socket to disable Nagle&apos;s algorithm (always send
                         immediately)
                         TBD: should this be left up to socket factory instead?                        
                    </comment>
                    <comment line="686">
                        if we fail to set this, ignore and proceed anyway                        
                    </comment>
                    <comment line="688">
                        set socket to timeout after excessive idle time                        
                    </comment>
                    <comment line="693">
                        too bad, continue anyway                        
                    </comment>
                    <comment line="702">
                        Read magic (or HTTP wrapper)                        
                    </comment>
                    <comment line="710">
                        It&apos;s really a HTTP-wrapped request.  Repackage
                         the socket in a HttpReceiveSocket, reinitialize
                         sockIn and in, and reread magic.                        
                    </comment>
                    <comment line="713">
                        unread &quot;POST&quot;                        
                    </comment>
                    <comment line="728">
                        bufIn&apos;s mark will invalidate itself when it overflows
                         so it doesn&apos;t have to be turned off                        
                    </comment>
                    <comment line="731">
                        read and verify transport header                        
                    </comment>
                    <comment line="735">
                        protocol mismatch detected...
                         just close socket: this would recurse if we marshal an
                         exception to the client and the protocol at other end
                         doesn&apos;t match.                        
                    </comment>
                    <comment line="759">
                        send ack (or nack) for protocol                        
                    </comment>
                    <comment line="763">
                        no ack for protocol                        
                    </comment>
                    <comment line="765">
                        create dummy channel for receiving messages                        
                    </comment>
                    <comment line="772">
                        read input messages                        
                    </comment>
                    <comment line="777">
                        send ack                        
                    </comment>
                    <comment line="780">
                        suggest endpoint (in case client doesn&apos;t know host name)                        
                    </comment>
                    <comment line="791">
                        read and discard (possibly bogus) endpoint
                         REMIND: would be faster to read 2 bytes then skip N+4                        
                    </comment>
                    <comment line="800">
                        create dummy channel for receiving messages
                         (why not use clientHost and clientPort?)                        
                    </comment>
                    <comment line="808">
                        read input messages                        
                    </comment>
                    <comment line="818">
                        send ack                        
                    </comment>
                    <comment line="821">
                        suggest endpoint (in case client doesn&apos;t already have one)                        
                    </comment>
                    <comment line="831">
                        read endpoint client has decided to use                        
                    </comment>
                    <comment line="843">
                        create or find channel for this endpoint                        
                    </comment>
                    <comment line="854">
                        protocol not understood, send nack and close socket                        
                    </comment>
                    <comment line="861">
                        socket in unknown state: destroy socket                        
                    </comment>
                    <declaration name="endpoint" type="TCPEndpoint" line="674"/>
                    <declaration name="port" type="int" line="675"/>
                    <scope line="682"/>
                    <scope line="684"/>
                    <scope line="688"/>
                    <scope line="691"/>
                    <scope line="695">
                        <declaration name="sockIn" type="InputStream" line="696"/>
                        <declaration name="bufIn" type="InputStream" line="697"/>
                        <declaration name="in" type="DataInputStream" line="703"/>
                        <declaration name="magic" type="int" line="704"/>
                        <scope line="706">
                            <scope line="714"/>
                            <scope line="722"/>
                        </scope>
                        <declaration name="version" type="short" line="731"/>
                        <scope line="733"/>
                        <declaration name="sockOut" type="OutputStream" line="742"/>
                        <declaration name="bufOut" type="BufferedOutputStream" line="743"/>
                        <declaration name="out" type="DataOutputStream" line="745"/>
                        <declaration name="remotePort" type="int" line="747"/>
                        <scope line="749"/>
                        <declaration name="ep" type="TCPEndpoint" line="754"/>
                        <declaration name="ch" type="TCPChannel" line="755"/>
                        <declaration name="conn" type="TCPConnection" line="756"/>
                        <declaration name="protocol" type="byte" line="759"/>
                        <scope line="780"/>
                        <declaration name="clientHost" type="String" line="792"/>
                        <declaration name="clientPort" type="int" line="793"/>
                        <scope line="794"/>
                        <scope line="812"/>
                        <scope line="821"/>
                        <scope line="834"/>
                        <declaration name="multiplexer" type="ConnectionMultiplexer" line="840"/>
                        <scope line="841"/>
                    </scope>
                    <scope line="859"/>
                    <scope line="862"/>
                </method>
            </class>
        </class>
    </source>