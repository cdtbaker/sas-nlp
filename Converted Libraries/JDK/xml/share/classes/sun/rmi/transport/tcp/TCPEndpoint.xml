<?xml version="1.0" encoding="UTF-8"?>
    <source package="sun.rmi.transport.tcp">
        <import package="java.io.DataInput"/>
        <import package="java.io.DataOutput"/>
        <import package="java.io.IOException"/>
        <import package="java.io.ObjectInput"/>
        <import package="java.io.ObjectOutput"/>
        <import package="java.net.InetAddress"/>
        <import package="java.net.ServerSocket"/>
        <import package="java.net.Socket"/>
        <import package="java.rmi.ConnectIOException"/>
        <import package="java.rmi.RemoteException"/>
        <import package="java.rmi.server.RMIClientSocketFactory"/>
        <import package="java.rmi.server.RMIServerSocketFactory"/>
        <import package="java.rmi.server.RMISocketFactory"/>
        <import package="java.security.AccessController"/>
        <import package="java.util.Collection"/>
        <import package="java.util.HashMap"/>
        <import package="java.util.HashSet"/>
        <import package="java.util.LinkedList"/>
        <import package="java.util.Map"/>
        <import package="java.util.Set"/>
        <import package="sun.rmi.runtime.Log"/>
        <import package="sun.rmi.runtime.NewThreadAction"/>
        <import package="sun.rmi.transport.Channel"/>
        <import package="sun.rmi.transport.Endpoint"/>
        <import package="sun.rmi.transport.Target"/>
        <import package="sun.rmi.transport.Transport"/>
        <import package="sun.security.action.GetBooleanAction"/>
        <import package="sun.security.action.GetIntegerAction"/>
        <import package="sun.security.action.GetPropertyAction"/>
        <class name="TCPEndpoint" line="57">
            <comment line="84">
                this should be a *private* method since it is privileged                
            </comment>
            <comment line="89">
                this should be a *private* method since it is privileged                
            </comment>
            <comment line="514">
                                
            </comment>
            <implements interface="Endpoint"/>
            <javadoc line="57">
                TCPEndpoint represents some communication endpoint for an address
                  space (VM).                
                <author>
                    Ann Wollrath                    
                </author>
            </javadoc>
            <declaration name="host" type="String" line="64"/>
            <javadoc line="64">
                IP address or host name                
            </javadoc>
            <declaration name="port" type="int" line="66"/>
            <javadoc line="66">
                port number                
            </javadoc>
            <declaration name="csf" type="RMIClientSocketFactory" line="68"/>
            <javadoc line="68">
                custom client socket factory (null if not custom factory)                
            </javadoc>
            <declaration name="ssf" type="RMIServerSocketFactory" line="70"/>
            <javadoc line="70">
                custom server socket factory (null if not custom factory)                
            </javadoc>
            <declaration name="listenPort" type="int" line="73"/>
            <javadoc line="73">
                if local, the port number to listen on                
            </javadoc>
            <declaration name="transport" type="TCPTransport" line="75"/>
            <javadoc line="75">
                if local, the transport object associated with this endpoint                
            </javadoc>
            <declaration name="localHost" type="String" line="78"/>
            <javadoc line="78">
                the local host name                
            </javadoc>
            <declaration name="localHostKnown" type="boolean" line="80"/>
            <javadoc line="80">
                true if real local host name is known yet                
            </javadoc>
            <method name="getInt" type="int" line="84">
                <params>
                    <param name="name" type="String"/>
                    <param name="def" type="int"/>
                </params>
            </method>
            <method name="getBoolean" type="boolean" line="89">
                <params>
                    <param name="name" type="String"/>
                </params>
            </method>
            <javadoc line="93">
                Returns the value of the java.rmi.server.hostname property.                
            </javadoc>
            <method name="getHostnameProperty" type="String" line="96"/>
            <javadoc line="101">
                Find host name of local machine.  Property &quot;java.rmi.server.hostname&quot;
                  is used if set, so server administrator can compensate for the possible
                  inablility to get fully qualified host name from VM.                
            </javadoc>
            <scope line="106">
                <scope line="111">
                    <scope line="112">
                        <declaration name="localAddr" type="InetAddress" line="113"/>
                        <declaration name="raw" type="byte[]" line="114"/>
                        <scope line="118"/>
                        <scope line="125"/>
                        <scope line="127"/>
                    </scope>
                    <scope line="133"/>
                </scope>
                <scope line="139"/>
            </scope>
            <declaration name="localEndpoints" type="Map&lt;TCPEndpoint,LinkedList&lt;TCPEndpoint&gt;&gt;" line="146"/>
            <javadoc line="146">
                maps an endpoint key containing custom socket factories to
                  their own unique endpoint                
            </javadoc>
            <javadoc line="153">
                Create an endpoint for a specified host and port.
                  This should not be used by external classes to create endpoints
                  for servers in this VM; use getLocalEndpoint instead.                
            </javadoc>
            <method name="TCPEndpoint" type="constructor" line="158">
                <params>
                    <param name="host" type="String"/>
                    <param name="port" type="int"/>
                </params>
            </method>
            <javadoc line="162">
                Create a custom socket factory endpoint for a specified host and port.
                  This should not be used by external classes to create endpoints
                  for servers in this VM; use getLocalEndpoint instead.                
            </javadoc>
            <method name="TCPEndpoint" type="constructor" line="169">
                <params>
                    <param name="host" type="String"/>
                    <param name="port" type="int"/>
                    <param name="csf" type="RMIClientSocketFactory"/>
                    <param name="ssf" type="RMIServerSocketFactory"/>
                </params>
            </method>
            <javadoc line="178">
                Get an endpoint for the local address space on specified port.
                  If port number is 0, it returns shared default endpoint object
                  whose host name and port may or may not have been determined.                
            </javadoc>
            <method name="getLocalEndpoint" type="TCPEndpoint" line="183">
                <params>
                    <param name="port" type="int"/>
                </params>
            </method>
            <method name="getLocalEndpoint" type="TCPEndpoint" line="190">
                <params>
                    <param name="port" type="int"/>
                    <param name="csf" type="RMIClientSocketFactory"/>
                    <param name="ssf" type="RMIServerSocketFactory"/>
                </params>
                <comment line="191">
                    Find mapping for an endpoint key to the list of local unique
                     endpoints for this clientserver socket factory pair (perhaps
                     null) for the specific port.                    
                </comment>
                <comment line="204">
                    Create new endpoint list.                    
                </comment>
                <comment line="225">
                    assert (localHost == null ^ lastHost != null)                    
                </comment>
                <comment line="227">
                    Hostname has been updated; add updated endpoint
                     to list.                    
                </comment>
                <comment line="232">
                    Remove outdated endpoints only if the
                     port has already been set on those endpoints.                    
                </comment>
                <declaration name="ep" type="TCPEndpoint" line="196"/>
                <scope line="198">
                    <declaration name="endpointKey" type="TCPEndpoint" line="199"/>
                    <declaration name="epList" type="LinkedList&lt;TCPEndpoint&gt;" line="200"/>
                    <declaration name="localHost" type="String" line="201"/>
                    <scope line="203">
                        <scope line="214"/>
                    </scope>
                    <scope line="219">
                        <scope line="220">
                            <declaration name="lastHost" type="String" line="222"/>
                            <declaration name="lastPort" type="int" line="223"/>
                            <declaration name="lastTransport" type="TCPTransport" line="224"/>
                            <scope line="226">
                                <scope line="231"/>
                            </scope>
                        </scope>
                    </scope>
                </scope>
            </method>
            <javadoc line="250">
                Resamples the local hostname and returns the possibly-updated
                  local hostname.                
            </javadoc>
            <method name="resampleLocalHost" type="String" line="254">
                <comment line="259">
                    assert(localHostKnown ^ (localHost == null))                    
                </comment>
                <comment line="263">
                    If the local hostname is unknown, update ALL
                     existing endpoints with the new hostname.                    
                </comment>
                <comment line="269">
                    Only update the localHost field for reference
                     in future endpoint creation.                    
                </comment>
                <declaration name="hostnameProperty" type="String" line="256"/>
                <scope line="258">
                    <scope line="261">
                        <scope line="262"/>
                        <scope line="268">
                            <scope line="275"/>
                        </scope>
                    </scope>
                </scope>
            </method>
            <javadoc line="285">
                Set the local host name, if currently unknown.                
            </javadoc>
            <method name="setLocalHost" type="void" line="288">
                <params>
                    <param name="host" type="String"/>
                </params>
                <comment line="289">
                    assert (host != null)                    
                </comment>
                <comment line="292">
                    If host is not known, change the host field of ALL
                     the local endpoints.                    
                </comment>
                <scope line="291">
                    <scope line="296">
                        <scope line="300"/>
                        <scope line="305">
                            <scope line="306">
                                <scope line="307"/>
                            </scope>
                        </scope>
                    </scope>
                </scope>
            </method>
            <javadoc line="316">
                Set the port of the (shared) default endpoint object.
                  When first created, it contains port 0 because the transport
                  hasn&apos;t tried to listen to get assigned a port, or if listening
                  failed, a port hasn&apos;t been assigned from the server.                
            </javadoc>
            <method name="setDefaultPort" type="void" line="324">
                <params>
                    <param name="port" type="int"/>
                    <param name="csf" type="RMIClientSocketFactory"/>
                    <param name="ssf" type="RMIServerSocketFactory"/>
                </params>
                <comment line="338">
                    Remove all but the last element of the list
                     (which contains the most recent hostname).                    
                </comment>
                <comment line="347">
                    Allow future exports to use the actual bound port
                     explicitly (see 6269166).                    
                </comment>
                <declaration name="endpointKey" type="TCPEndpoint" line="325"/>
                <scope line="327">
                    <declaration name="epList" type="LinkedList&lt;TCPEndpoint&gt;" line="328"/>
                    <scope line="330">
                        <declaration name="size" type="int" line="331"/>
                        <declaration name="lastEp" type="TCPEndpoint" line="332"/>
                        <scope line="334"/>
                        <scope line="337"/>
                    </scope>
                    <declaration name="newEndpointKey" type="TCPEndpoint" line="351"/>
                    <scope line="354"/>
                </scope>
            </method>
            <javadoc line="363">
                Returns transport for making connections to remote endpoints;
                  (here, the default transport at port 0 is used).                
            </javadoc>
            <method name="getOutboundTransport" type="Transport" line="367">
                <declaration name="localEndpoint" type="TCPEndpoint" line="368"/>
            </method>
            <javadoc line="372">
                Returns the current list of known transports.
                  The returned list is an unshared collection of Transports,
                  including all transports which may have channels to remote
                  endpoints.                
            </javadoc>
            <method name="allKnownTransports" type="Collection<TCPTransport>" line="378">
                <comment line="379">
                    Loop through local endpoints, getting the transport of each one.                    
                </comment>
                <comment line="382">
                    presize s to number of localEndpoints                    
                </comment>
                <comment line="385">
                    Each local endpoint has its transport added to s.
                     Note: the transport is the same for all endpoints
                     in the list, so it is okay to pick any one of them.                    
                </comment>
                <declaration name="s" type="Set&lt;TCPTransport&gt;" line="380"/>
                <scope line="381">
                    <scope line="384">
                        <declaration name="ep" type="TCPEndpoint" line="390"/>
                    </scope>
                </scope>
            </method>
            <javadoc line="397">
                Release idle outbound connections to reduce demand on I/O resources.
                  All transports are asked to release excess connections.                
            </javadoc>
            <method name="shedConnectionCaches" type="void" line="401">
                <scope line="402"/>
            </method>
            <javadoc line="407">
                Export the object to accept incoming calls.                
            </javadoc>
            <method name="exportObject" type="void" line="410">
                <params>
                    <param name="target" type="Target"/>
                </params>
            </method>
            <javadoc line="414">
                Returns a channel for this (remote) endpoint.                
            </javadoc>
            <method name="getChannel" type="Channel" line="417"/>
            <javadoc line="421">
                Returns address for endpoint                
            </javadoc>
            <method name="getHost" type="String" line="424"/>
            <javadoc line="428">
                Returns the port for this endpoint.  If this endpoint was
                  created as a server endpoint (using getLocalEndpoint) for a
                  default/anonymous port and its inbound transport has started
                  listening, this method returns (instead of zero) the actual
                  bound port suitable for passing to clients.                
            </javadoc>
            <method name="getPort" type="int" line="435"/>
            <javadoc line="439">
                Returns the port that this endpoint&apos;s inbound transport listens
                  on, if this endpoint was created as a server endpoint (using
                  getLocalEndpoint).  If this endpoint was created for the
                  default/anonymous port, then this method returns zero even if
                  the transport has started listening.                
            </javadoc>
            <method name="getListenPort" type="int" line="446"/>
            <javadoc line="450">
                Returns the transport for incoming connections to this
                  endpoint, if this endpoint was created as a server endpoint
                  (using getLocalEndpoint).                
            </javadoc>
            <method name="getInboundTransport" type="Transport" line="455"/>
            <javadoc line="459">
                Get the client socket factory associated with this endpoint.                
            </javadoc>
            <method name="getClientSocketFactory" type="RMIClientSocketFactory" line="462"/>
            <javadoc line="466">
                Get the server socket factory associated with this endpoint.                
            </javadoc>
            <method name="getServerSocketFactory" type="RMIServerSocketFactory" line="469"/>
            <javadoc line="473">
                Return string representation for endpoint.                
            </javadoc>
            <method name="toString" type="String" line="476"/>
            <method name="hashCode" type="int" line="483"/>
            <method name="equals" type="boolean" line="487">
                <params>
                    <param name="obj" type="Object"/>
                </params>
                <comment line="495">
                    Fix for 4254510: perform socket factory class equality check
                     before socket factory equality check to avoid passing
                     a potentially naughty socket factory to this endpoint&apos;s
                     {client,server} socket factory equals method.                    
                </comment>
                <scope line="488">
                    <declaration name="ep" type="TCPEndpoint" line="489"/>
                </scope>
                <scope line="508"/>
            </method>
            <declaration name="FORMAT_HOST_PORT" type="int" line="514"/>
            <declaration name="FORMAT_HOST_PORT_FACTORY" type="int" line="515"/>
            <javadoc line="517">
                Write endpoint to output stream.                
            </javadoc>
            <method name="write" type="void" line="520">
                <params>
                    <param name="out" type="ObjectOutput"/>
                </params>
                <scope line="521"/>
                <scope line="525"/>
            </method>
            <javadoc line="533">
                Get the endpoint from the input stream.                
                <param>
                    in the input stream                    
                </param>
                <exception>
                    IOException If id could not be read (due to stream failure)                    
                </exception>
            </javadoc>
            <method name="read" type="TCPEndpoint" line="540">
                <params>
                    <param name="in" type="ObjectInput"/>
                </params>
                <declaration name="host" type="String" line="541"/>
                <declaration name="port" type="int" line="542"/>
                <declaration name="csf" type="RMIClientSocketFactory" line="543"/>
                <declaration name="format" type="byte" line="545"/>
            </method>
            <javadoc line="564">
                Write endpoint to output stream in older format used by
                  UnicastRef for JDK1.1 compatibility.                
            </javadoc>
            <method name="writeHostPortFormat" type="void" line="568">
                <params>
                    <param name="out" type="DataOutput"/>
                </params>
                <scope line="569"/>
            </method>
            <javadoc line="577">
                Create a new endpoint from input stream data.                
                <param>
                    in the input stream                    
                </param>
            </javadoc>
            <method name="readHostPortFormat" type="TCPEndpoint" line="583">
                <params>
                    <param name="in" type="DataInput"/>
                </params>
                <declaration name="host" type="String" line="584"/>
                <declaration name="port" type="int" line="585"/>
            </method>
            <method name="chooseFactory" type="RMISocketFactory" line="589">
                <declaration name="sf" type="RMISocketFactory" line="590"/>
                <scope line="591"/>
            </method>
            <javadoc line="597">
                Open and return new client socket connection to endpoint.                
            </javadoc>
            <method name="newSocket" type="Socket" line="600">
                <comment line="622">
                    We might have simply run out of file descriptors                    
                </comment>
                <comment line="625">
                    REMIND: should we retry createSocket?                    
                </comment>
                <comment line="627">
                    don&apos;t quit if out of memory                    
                </comment>
                <comment line="629">
                    don&apos;t quit if shed fails non-catastrophically                    
                </comment>
                <comment line="636">
                    set socket to disable Nagle&apos;s algorithm (always send immediately)                    
                </comment>
                <comment line="637">
                    TBD: should this be left up to socket factory instead?                    
                </comment>
                <comment line="641">
                    if we fail to set this, ignore and proceed anyway                    
                </comment>
                <comment line="644">
                    fix 4187495: explicitly set SO_KEEPALIVE to prevent client hangs                    
                </comment>
                <comment line="648">
                    ignore and proceed                    
                </comment>
                <scope line="601"/>
                <declaration name="socket" type="Socket" line="606"/>
                <scope line="608">
                    <declaration name="clientFactory" type="RMIClientSocketFactory" line="609"/>
                    <scope line="610"/>
                </scope>
                <scope line="615"/>
                <scope line="618"/>
                <scope line="621">
                    <scope line="623"/>
                    <scope line="626"/>
                    <scope line="628"/>
                </scope>
                <scope line="638"/>
                <scope line="640"/>
                <scope line="645"/>
                <scope line="647"/>
            </method>
            <javadoc line="654">
                Return new server socket to listen for connections on this endpoint.                
            </javadoc>
            <method name="newServerSocket" type="ServerSocket" line="657">
                <comment line="669">
                    if we listened on an anonymous port, set the default port                    
                </comment>
                <comment line="670">
                    (for this socket factory)                    
                </comment>
                <scope line="658"/>
                <declaration name="serverFactory" type="RMIServerSocketFactory" line="663"/>
                <scope line="664"/>
                <declaration name="server" type="ServerSocket" line="667"/>
            </method>
            <class name="FQDN" line="677">
                <comment line="149">
                    TBD: should this be a weak hash table?                    
                </comment>
                <implements interface="Runnable"/>
                <javadoc line="677">
                    The class FQDN encapsulates a routine that makes a best effort
                      attempt to retrieve the fully qualified domain name of the local
                      host.                    
                    <author>
                        Laird Dornin                        
                    </author>
                </javadoc>
                <declaration name="reverseLookup" type="String" line="686"/>
                <javadoc line="686">
                    strings in which we can store discovered fqdn                    
                </javadoc>
                <declaration name="hostAddress" type="String" line="691"/>
                <method name="FQDN" type="constructor" line="693">
                    <params>
                        <param name="hostAddress" type="String"/>
                    </params>
                </method>
                <javadoc line="697">
                    Do our best to obtain a fully qualified hostname for the local
                      host.  Perform the following steps to get a localhostname:
                      1. InetAddress.getLocalHost().getHostName() - if contains
                      &apos;.&apos; use as FQDN
                      2. if no &apos;.&apos; query name service for FQDN in a thread
                      Note: We query the name service for an FQDN by creating
                      an InetAddress via a stringified copy of the local ip
                      address; this creates an InetAddress with a null hostname.
                      Asking for the hostname of this InetAddress causes a name
                      service lookup.
                      3. if name service takes too long to return, use ip address
                      4. if name service returns but response contains no &apos;.&apos;
                      default to ipaddress.                    
                </javadoc>
                <method name="attemptFQDN" type="String" line="716">
                    <params>
                        <param name="localAddr" type="InetAddress"/>
                    </params>
                    <comment line="733">
                                                
                    </comment>
                    <comment line="737">
                                                
                    </comment>
                    <declaration name="hostName" type="String" line="718"/>
                    <scope line="720">
                        <declaration name="hostAddress" type="String" line="722"/>
                        <declaration name="f" type="FQDN" line="723"/>
                        <declaration name="nameServiceTimeOut" type="int" line="725"/>
                        <scope line="729">
                            <scope line="730"/>
                        </scope>
                        <scope line="736"/>
                        <scope line="743"/>
                    </scope>
                </method>
                <javadoc line="751">
                    Method that that will start a thread to wait to retrieve a
                      fully qualified domain name from a name service.  The spawned
                      thread may never return but we have marked it as a daemon so the vm
                      will terminate appropriately.                    
                </javadoc>
                <method name="getFQDN" type="void" line="757">
                    <comment line="759">
                                                
                    </comment>
                    <declaration name="t" type="Thread" line="760"/>
                </method>
                <method name="getHost" type="String" line="765"/>
                <javadoc line="769">
                    thread to query a name service for the fqdn of this host.                    
                </javadoc>
                <method name="run" type="void" line="772">
                    <declaration name="name" type="String" line="774"/>
                    <scope line="776"/>
                    <scope line="778"/>
                    <scope line="779">
                        <scope line="780"/>
                    </scope>
                </method>
            </class>
        </class>
    </source>