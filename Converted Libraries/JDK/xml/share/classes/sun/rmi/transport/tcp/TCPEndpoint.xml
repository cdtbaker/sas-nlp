<?xml version="1.0" encoding="UTF-8"?>
    <source package="sun.rmi.transport.tcp">
        <import package="java.io.DataInput"/>
        <import package="java.io.DataOutput"/>
        <import package="java.io.IOException"/>
        <import package="java.io.ObjectInput"/>
        <import package="java.io.ObjectOutput"/>
        <import package="java.net.InetAddress"/>
        <import package="java.net.ServerSocket"/>
        <import package="java.net.Socket"/>
        <import package="java.rmi.ConnectIOException"/>
        <import package="java.rmi.RemoteException"/>
        <import package="java.rmi.server.RMIClientSocketFactory"/>
        <import package="java.rmi.server.RMIServerSocketFactory"/>
        <import package="java.rmi.server.RMISocketFactory"/>
        <import package="java.security.AccessController"/>
        <import package="java.util.Collection"/>
        <import package="java.util.HashMap"/>
        <import package="java.util.HashSet"/>
        <import package="java.util.LinkedList"/>
        <import package="java.util.Map"/>
        <import package="java.util.Set"/>
        <import package="sun.rmi.runtime.Log"/>
        <import package="sun.rmi.runtime.NewThreadAction"/>
        <import package="sun.rmi.transport.Channel"/>
        <import package="sun.rmi.transport.Endpoint"/>
        <import package="sun.rmi.transport.Target"/>
        <import package="sun.rmi.transport.Transport"/>
        <import package="sun.security.action.GetBooleanAction"/>
        <import package="sun.security.action.GetIntegerAction"/>
        <import package="sun.security.action.GetPropertyAction"/>
        <class name="TCPEndpoint" line="31">
            <implements interface="Endpoint"/>
            <javadoc line="31">
                TCPEndpoint represents some communication endpoint for an address
                  space (VM).                
                <author>
                    Ann Wollrath                    
                </author>
            </javadoc>
            <declaration name="host" type="String" line="37"/>
            <javadoc line="37">
                IP address or host name                
            </javadoc>
            <declaration name="port" type="int" line="41"/>
            <javadoc line="41">
                port number                
            </javadoc>
            <declaration name="csf" type="RMIClientSocketFactory" line="45"/>
            <javadoc line="45">
                custom client socket factory (null if not custom factory)                
            </javadoc>
            <declaration name="ssf" type="RMIServerSocketFactory" line="49"/>
            <javadoc line="49">
                custom server socket factory (null if not custom factory)                
            </javadoc>
            <declaration name="listenPort" type="int" line="53"/>
            <javadoc line="53">
                if local, the port number to listen on                
            </javadoc>
            <declaration name="transport" type="TCPTransport" line="57"/>
            <javadoc line="57">
                if local, the transport object associated with this endpoint                
            </javadoc>
            <declaration name="localHost" type="String" line="61"/>
            <javadoc line="61">
                the local host name                
            </javadoc>
            <declaration name="localHostKnown" type="boolean" line="65"/>
            <javadoc line="65">
                true if real local host name is known yet                
            </javadoc>
            <method name="getInt" type="int" line="69">
                <params>
                    <param name="name" type="String"/>
                    <param name="def" type="int"/>
                </params>
            </method>
            <method name="getBoolean" type="boolean" line="72">
                <params>
                    <param name="name" type="String"/>
                </params>
            </method>
            <javadoc line="75">
                Returns the value of the java.rmi.server.hostname property.                
            </javadoc>
            <method name="getHostnameProperty" type="String" line="78"/>
            <javadoc line="81">
                Find host name of local machine.  Property &quot;java.rmi.server.hostname&quot;
                  is used if set, so server administrator can compensate for the possible
                  inablility to get fully qualified host name from VM.                
            </javadoc>
            <scope line="86">
                <scope line="89">
                    <scope line="90">
                        <declaration name="localAddr" type="InetAddress" line="91"/>
                        <declaration name="raw" type="byte[]" line="92"/>
                        <scope line="93"/>
                        <scope line="96"/>
                        <scope line="99"/>
                    </scope>
                    <scope line="103"/>
                </scope>
                <scope line="108"/>
            </scope>
            <declaration name="localEndpoints" type="Map&amp;lt;TCPEndpoint,LinkedList&amp;lt;TCPEndpoint&amp;gt;&amp;gt;" line="112"/>
            <javadoc line="112">
                maps an endpoint key containing custom socket factories to
                  their own unique endpoint                
            </javadoc>
            <javadoc line="117">
                Create an endpoint for a specified host and port.
                  This should not be used by external classes to create endpoints
                  for servers in this VM; use getLocalEndpoint instead.                
            </javadoc>
            <method name="TCPEndpoint" type="constructor" line="122">
                <params>
                    <param name="host" type="String"/>
                    <param name="port" type="int"/>
                </params>
            </method>
            <javadoc line="125">
                Create a custom socket factory endpoint for a specified host and port.
                  This should not be used by external classes to create endpoints
                  for servers in this VM; use getLocalEndpoint instead.                
            </javadoc>
            <method name="TCPEndpoint" type="constructor" line="130">
                <params>
                    <param name="host" type="String"/>
                    <param name="port" type="int"/>
                    <param name="csf" type="RMIClientSocketFactory"/>
                    <param name="ssf" type="RMIServerSocketFactory"/>
                </params>
            </method>
            <javadoc line="137">
                Get an endpoint for the local address space on specified port.
                  If port number is 0, it returns shared default endpoint object
                  whose host name and port may or may not have been determined.                
            </javadoc>
            <method name="getLocalEndpoint" type="TCPEndpoint" line="142">
                <params>
                    <param name="port" type="int"/>
                </params>
            </method>
            <method name="getLocalEndpoint" type="TCPEndpoint" line="145">
                <params>
                    <param name="port" type="int"/>
                    <param name="csf" type="RMIClientSocketFactory"/>
                    <param name="ssf" type="RMIServerSocketFactory"/>
                </params>
                <declaration name="ep" type="TCPEndpoint" line="146"/>
                <scope line="147">
                    <declaration name="endpointKey" type="TCPEndpoint" line="148"/>
                    <declaration name="epList" type="LinkedList&amp;lt;TCPEndpoint&amp;gt;" line="149"/>
                    <declaration name="localHost" type="String" line="150"/>
                    <scope line="151">
                        <scope line="158"/>
                    </scope>
                    <scope line="162">
                        <scope line="163">
                            <declaration name="lastHost" type="String" line="165"/>
                            <declaration name="lastPort" type="int" line="166"/>
                            <declaration name="lastTransport" type="TCPTransport" line="167"/>
                            <scope line="168">
                                <scope line="169"/>
                            </scope>
                        </scope>
                    </scope>
                </scope>
            </method>
            <javadoc line="182">
                Resamples the local hostname and returns the possibly-updated
                  local hostname.                
            </javadoc>
            <method name="resampleLocalHost" type="String" line="186">
                <declaration name="hostnameProperty" type="String" line="187"/>
                <scope line="188">
                    <scope line="189">
                        <scope line="190"/>
                        <scope line="193">
                            <scope line="195"/>
                        </scope>
                    </scope>
                </scope>
            </method>
            <javadoc line="203">
                Set the local host name, if currently unknown.                
            </javadoc>
            <method name="setLocalHost" type="void" line="206">
                <params>
                    <param name="host" type="String"/>
                </params>
                <scope line="207">
                    <scope line="208">
                        <scope line="211"/>
                        <scope line="214">
                            <scope line="215">
                                <scope line="216"/>
                            </scope>
                        </scope>
                    </scope>
                </scope>
            </method>
            <javadoc line="224">
                Set the port of the (shared) default endpoint object.
                  When first created, it contains port 0 because the transport
                  hasn&apos;t tried to listen to get assigned a port, or if listening
                  failed, a port hasn&apos;t been assigned from the server.                
            </javadoc>
            <method name="setDefaultPort" type="void" line="230">
                <params>
                    <param name="port" type="int"/>
                    <param name="csf" type="RMIClientSocketFactory"/>
                    <param name="ssf" type="RMIServerSocketFactory"/>
                </params>
                <declaration name="endpointKey" type="TCPEndpoint" line="231"/>
                <scope line="232">
                    <declaration name="epList" type="LinkedList&amp;lt;TCPEndpoint&amp;gt;" line="233"/>
                    <scope line="234">
                        <declaration name="size" type="int" line="235"/>
                        <declaration name="lastEp" type="TCPEndpoint" line="236"/>
                        <scope line="237"/>
                        <scope line="240"/>
                    </scope>
                    <declaration name="newEndpointKey" type="TCPEndpoint" line="245"/>
                    <scope line="247"/>
                </scope>
            </method>
            <javadoc line="252">
                Returns transport for making connections to remote endpoints;
                  (here, the default transport at port 0 is used).                
            </javadoc>
            <method name="getOutboundTransport" type="Transport" line="256">
                <declaration name="localEndpoint" type="TCPEndpoint" line="257"/>
            </method>
            <javadoc line="260">
                Returns the current list of known transports.
                  The returned list is an unshared collection of Transports,
                  including all transports which may have channels to remote
                  endpoints.                
            </javadoc>
            <method name="allKnownTransports" type="Collection&lt;TCPTransport&gt;" line="266">
                <declaration name="s" type="Set&amp;lt;TCPTransport&amp;gt;" line="267"/>
                <scope line="268">
                    <scope line="270">
                        <declaration name="ep" type="TCPEndpoint" line="271"/>
                    </scope>
                </scope>
            </method>
            <javadoc line="277">
                Release idle outbound connections to reduce demand on I/O resources.
                  All transports are asked to release excess connections.                
            </javadoc>
            <method name="shedConnectionCaches" type="void" line="281">
                <scope line="282"/>
            </method>
            <javadoc line="286">
                Export the object to accept incoming calls.                
            </javadoc>
            <method name="exportObject" type="void" line="289">
                <params>
                    <param name="target" type="Target"/>
                </params>
            </method>
            <javadoc line="292">
                Returns a channel for this (remote) endpoint.                
            </javadoc>
            <method name="getChannel" type="Channel" line="295"/>
            <javadoc line="298">
                Returns address for endpoint                
            </javadoc>
            <method name="getHost" type="String" line="301"/>
            <javadoc line="304">
                Returns the port for this endpoint.  If this endpoint was
                  created as a server endpoint (using getLocalEndpoint) for a
                  default/anonymous port and its inbound transport has started
                  listening, this method returns (instead of zero) the actual
                  bound port suitable for passing to clients.                
            </javadoc>
            <method name="getPort" type="int" line="311"/>
            <javadoc line="314">
                Returns the port that this endpoint&apos;s inbound transport listens
                  on, if this endpoint was created as a server endpoint (using
                  getLocalEndpoint).  If this endpoint was created for the
                  default/anonymous port, then this method returns zero even if
                  the transport has started listening.                
            </javadoc>
            <method name="getListenPort" type="int" line="321"/>
            <javadoc line="324">
                Returns the transport for incoming connections to this
                  endpoint, if this endpoint was created as a server endpoint
                  (using getLocalEndpoint).                
            </javadoc>
            <method name="getInboundTransport" type="Transport" line="329"/>
            <javadoc line="332">
                Get the client socket factory associated with this endpoint.                
            </javadoc>
            <method name="getClientSocketFactory" type="RMIClientSocketFactory" line="335"/>
            <javadoc line="338">
                Get the server socket factory associated with this endpoint.                
            </javadoc>
            <method name="getServerSocketFactory" type="RMIServerSocketFactory" line="341"/>
            <javadoc line="344">
                Return string representation for endpoint.                
            </javadoc>
            <method name="toString" type="String" line="347"/>
            <method name="hashCode" type="int" line="350"/>
            <method name="equals" type="boolean" line="353">
                <params>
                    <param name="obj" type="Object"/>
                </params>
                <scope line="354">
                    <declaration name="ep" type="TCPEndpoint" line="355"/>
                </scope>
                <scope line="362"/>
            </method>
            <declaration name="FORMAT_HOST_PORT" type="int" line="366"/>
            <declaration name="FORMAT_HOST_PORT_FACTORY" type="int" line="367"/>
            <javadoc line="368">
                Write endpoint to output stream.                
            </javadoc>
            <method name="write" type="void" line="371">
                <params>
                    <param name="out" type="ObjectOutput"/>
                </params>
                <scope line="372"/>
                <scope line="377"/>
            </method>
            <javadoc line="384">
                Get the endpoint from the input stream.                
                <param>
                    in the input stream                    
                </param>
                <exception>
                    IOException If id could not be read (due to stream failure)                    
                </exception>
            </javadoc>
            <method name="read" type="TCPEndpoint" line="389">
                <params>
                    <param name="in" type="ObjectInput"/>
                </params>
                <declaration name="host" type="String" line="390"/>
                <declaration name="port" type="int" line="391"/>
                <declaration name="csf" type="RMIClientSocketFactory" line="392"/>
                <declaration name="format" type="byte" line="393"/>
            </method>
            <javadoc line="409">
                Write endpoint to output stream in older format used by
                  UnicastRef for JDK1.1 compatibility.                
            </javadoc>
            <method name="writeHostPortFormat" type="void" line="413">
                <params>
                    <param name="out" type="DataOutput"/>
                </params>
                <scope line="414"/>
            </method>
            <javadoc line="420">
                Create a new endpoint from input stream data.                
                <param>
                    in the input stream                    
                </param>
            </javadoc>
            <method name="readHostPortFormat" type="TCPEndpoint" line="424">
                <params>
                    <param name="in" type="DataInput"/>
                </params>
                <declaration name="host" type="String" line="425"/>
                <declaration name="port" type="int" line="426"/>
            </method>
            <method name="chooseFactory" type="RMISocketFactory" line="429">
                <declaration name="sf" type="RMISocketFactory" line="430"/>
                <scope line="431"/>
            </method>
            <javadoc line="436">
                Open and return new client socket connection to endpoint.                
            </javadoc>
            <method name="newSocket" type="Socket" line="439">
                <scope line="440"/>
                <declaration name="socket" type="Socket" line="443"/>
                <scope line="444">
                    <declaration name="clientFactory" type="RMIClientSocketFactory" line="445"/>
                    <scope line="446"/>
                </scope>
                <scope line="451"/>
                <scope line="454"/>
                <scope line="457">
                    <scope line="458"/>
                    <scope line="461"/>
                    <scope line="463"/>
                </scope>
                <scope line="467"/>
                <scope line="470"/>
                <scope line="472"/>
                <scope line="475"/>
            </method>
            <javadoc line="479">
                Return new server socket to listen for connections on this endpoint.                
            </javadoc>
            <method name="newServerSocket" type="ServerSocket" line="482">
                <scope line="483"/>
                <declaration name="serverFactory" type="RMIServerSocketFactory" line="486"/>
                <scope line="487"/>
                <declaration name="server" type="ServerSocket" line="490"/>
            </method>
            <class name="FQDN" line="494">
                <implements interface="Runnable"/>
                <javadoc line="494">
                    The class FQDN encapsulates a routine that makes a best effort
                      attempt to retrieve the fully qualified domain name of the local
                      host.                    
                    <author>
                        Laird Dornin                        
                    </author>
                </javadoc>
                <declaration name="reverseLookup" type="String" line="501"/>
                <javadoc line="501">
                    strings in which we can store discovered fqdn                    
                </javadoc>
                <declaration name="hostAddress" type="String" line="505"/>
                <method name="FQDN" type="constructor" line="506">
                    <params>
                        <param name="hostAddress" type="String"/>
                    </params>
                </method>
                <javadoc line="509">
                    Do our best to obtain a fully qualified hostname for the local
                      host.  Perform the following steps to get a localhostname:
                      1. InetAddress.getLocalHost().getHostName() - if contains
                      &apos;.&apos; use as FQDN
                      2. if no &apos;.&apos; query name service for FQDN in a thread
                      Note: We query the name service for an FQDN by creating
                      an InetAddress via a stringified copy of the local ip
                      address; this creates an InetAddress with a null hostname.
                      Asking for the hostname of this InetAddress causes a name
                      service lookup.
                      3. if name service takes too long to return, use ip address
                      4. if name service returns but response contains no &apos;.&apos;
                      default to ipaddress.                    
                </javadoc>
                <method name="attemptFQDN" type="String" line="524">
                    <params>
                        <param name="localAddr" type="InetAddress"/>
                    </params>
                    <declaration name="hostName" type="String" line="525"/>
                    <scope line="526">
                        <declaration name="hostAddress" type="String" line="527"/>
                        <declaration name="f" type="FQDN" line="528"/>
                        <declaration name="nameServiceTimeOut" type="int" line="529"/>
                        <scope line="530">
                            <scope line="531"/>
                        </scope>
                        <scope line="536"/>
                        <scope line="540"/>
                    </scope>
                </method>
                <javadoc line="546">
                    Method that that will start a thread to wait to retrieve a
                      fully qualified domain name from a name service.  The spawned
                      thread may never return but we have marked it as a daemon so the vm
                      will terminate appropriately.                    
                </javadoc>
                <method name="getFQDN" type="void" line="552">
                    <declaration name="t" type="Thread" line="553"/>
                </method>
                <method name="getHost" type="String" line="556"/>
                <javadoc line="559">
                    thread to query a name service for the fqdn of this host.                    
                </javadoc>
                <method name="run" type="void" line="562">
                    <declaration name="name" type="String" line="563"/>
                    <scope line="564"/>
                    <scope line="567"/>
                    <scope line="569">
                        <scope line="570"/>
                    </scope>
                </method>
            </class>
        </class>
    </source>