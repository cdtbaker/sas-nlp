<?xml version="1.0" encoding="UTF-8"?>
    <source package="sun.rmi.transport">
        <import package="java.io.IOException"/>
        <import package="java.io.ObjectInput"/>
        <import package="java.io.ObjectOutput"/>
        <import package="java.rmi.Remote"/>
        <import package="java.rmi.RemoteException"/>
        <import package="java.rmi.server.ObjID"/>
        <import package="java.rmi.server.RMIClientSocketFactory"/>
        <import package="java.rmi.server.RMIServerSocketFactory"/>
        <import package="java.util.Arrays"/>
        <import package="sun.rmi.transport.tcp.TCPEndpoint"/>
        <class name="LiveRef" line="39">
            <implements interface="Cloneable"/>
            <javadoc line="39">
                NOTE: There is a JDK-internal dependency on the existence of this
                  class and its getClientSocketFactory method in the implementation
                  of javax.management.remote.rmi.RMIConnector.                
            </javadoc>
            <declaration name="ep" type="Endpoint" line="45"/>
            <javadoc line="45">
                wire representation for the object                
            </javadoc>
            <declaration name="id" type="ObjID" line="47"/>
            <declaration name="ch" type="Channel" line="49"/>
            <javadoc line="49">
                cached connection service for the object                
            </javadoc>
            <declaration name="isLocal" type="boolean" line="52"/>
            <javadoc line="52">
                flag to indicate whether this ref specifies a local server or
                  is a ref for a remote object (surrogate)                
            </javadoc>
            <javadoc line="57">
                Construct a &quot;well-known&quot; live reference to a remote object                
                <param>
                    isLocalServer If true, indicates this ref specifies a local
                      server in this address space; if false, the ref is for a remote
                      object (hence a surrogate or proxy) in another address space.                    
                </param>
            </javadoc>
            <method name="LiveRef" type="constructor" line="63">
                <params>
                    <param name="objID" type="ObjID"/>
                    <param name="endpoint" type="Endpoint"/>
                    <param name="isLocal" type="boolean"/>
                </params>
            </method>
            <javadoc line="69">
                Construct a new live reference for a server object in the local
                  address space.                
            </javadoc>
            <method name="LiveRef" type="constructor" line="73">
                <params>
                    <param name="port" type="int"/>
                </params>
            </method>
            <javadoc line="77">
                Construct a new live reference for a server object in the local
                  address space, to use sockets of the specified type.                
            </javadoc>
            <method name="LiveRef" type="constructor" line="84">
                <params>
                    <param name="port" type="int"/>
                    <param name="csf" type="RMIClientSocketFactory"/>
                    <param name="ssf" type="RMIServerSocketFactory"/>
                </params>
            </method>
            <javadoc line="88">
                Construct a new live reference for a &quot;well-known&quot; server object
                  in the local address space.                
            </javadoc>
            <method name="LiveRef" type="constructor" line="92">
                <params>
                    <param name="objID" type="ObjID"/>
                    <param name="port" type="int"/>
                </params>
            </method>
            <javadoc line="96">
                Construct a new live reference for a &quot;well-known&quot; server object
                  in the local address space, to use sockets of the specified type.                
            </javadoc>
            <method name="LiveRef" type="constructor" line="102">
                <params>
                    <param name="objID" type="ObjID"/>
                    <param name="port" type="int"/>
                    <param name="csf" type="RMIClientSocketFactory"/>
                    <param name="ssf" type="RMIServerSocketFactory"/>
                </params>
            </method>
            <javadoc line="106">
                Return a shallow copy of this ref.                
            </javadoc>
            <method name="clone" type="Object" line="109">
                <scope line="110">
                    <declaration name="newRef" type="LiveRef" line="111"/>
                </scope>
                <scope line="113"/>
            </method>
            <javadoc line="118">
                Return the port number associated with this ref.                
            </javadoc>
            <method name="getPort" type="int" line="121"/>
            <javadoc line="125">
                Return the client socket factory associated with this ref.
                  NOTE: There is a JDK-internal dependency on the existence of
                  this method in the implementation of
                  javax.management.remote.rmi.RMIConnector.                
            </javadoc>
            <method name="getClientSocketFactory" type="RMIClientSocketFactory" line="132"/>
            <javadoc line="136">
                Return the server socket factory associated with this ref.                
            </javadoc>
            <method name="getServerSocketFactory" type="RMIServerSocketFactory" line="139"/>
            <javadoc line="143">
                Export the object to accept incoming calls.                
            </javadoc>
            <method name="exportObject" type="void" line="146">
                <params>
                    <param name="target" type="Target"/>
                </params>
            </method>
            <method name="getChannel" type="Channel" line="150">
                <scope line="151"/>
            </method>
            <method name="getObjID" type="ObjID" line="157"/>
            <method name="getEndpoint" type="Endpoint" line="161"/>
            <method name="toString" type="String" line="165">
                <declaration name="type" type="String" line="166"/>
            </method>
            <method name="hashCode" type="int" line="176"/>
            <method name="equals" type="boolean" line="180">
                <params>
                    <param name="obj" type="Object"/>
                </params>
                <scope line="181">
                    <declaration name="ref" type="LiveRef" line="182"/>
                </scope>
                <scope line="186"/>
            </method>
            <method name="remoteEquals" type="boolean" line="191">
                <params>
                    <param name="obj" type="Object"/>
                </params>
                <comment line="204">
                    Fix for 4254103: LiveRef.remoteEquals should not fail
                     if one of the objects in the comparison has a null
                     server socket.  Comparison should only consider the
                     following criteria:
                    
                     hosts, ports, client socket factories and object IDs.                    
                </comment>
                <scope line="192">
                    <declaration name="ref" type="LiveRef" line="193"/>
                    <declaration name="thisEp" type="TCPEndpoint" line="195"/>
                    <declaration name="refEp" type="TCPEndpoint" line="196"/>
                    <declaration name="thisClientFactory" type="RMIClientSocketFactory" line="198"/>
                    <declaration name="refClientFactory" type="RMIClientSocketFactory" line="200"/>
                    <scope line="213"/>
                    <scope line="216"/>
                    <scope line="223"/>
                </scope>
                <scope line="227"/>
            </method>
            <method name="write" type="void" line="234">
                <params>
                    <param name="out" type="ObjectOutput"/>
                    <param name="useNewFormat" type="boolean"/>
                </params>
                <comment line="240">
                    Ensure that referential integrity is not broken while
                     this LiveRef is in transit.  If it is being marshalled
                     as part of a result, it may not otherwise be strongly
                     reachable after the remote call has completed; even if
                     it is being marshalled as part of an argument, the VM
                     may determine that the reference on the stack is no
                     longer reachable after marshalling (see 6181943)--
                     therefore, tell the stream to save a reference until a
                     timeout expires or, for results, a DGCAck message has
                     been received from the caller, or for arguments, the
                     remote call has completed.  For a &quot;local&quot; LiveRef, save
                     a reference to the impl directly, because the impl is
                     not reachable from the LiveRef (see 4114579);
                     otherwise, save a reference to the LiveRef, for the
                     client-side DGC to watch over.  (Also see 4017232.)                    
                </comment>
                <comment line="272">
                    All together now write out the endpoint, id, and flag                    
                </comment>
                <comment line="274">
                    (need to choose whether or not to use old JDK1.1 endpoint format)                    
                </comment>
                <declaration name="isResultStream" type="boolean" line="235"/>
                <scope line="236">
                    <declaration name="stream" type="ConnectionOutputStream" line="237"/>
                    <scope line="256">
                        <declaration name="oe" type="ObjectEndpoint" line="257"/>
                        <declaration name="target" type="Target" line="259"/>
                        <scope line="261">
                            <declaration name="impl" type="Remote" line="262"/>
                            <scope line="263"/>
                        </scope>
                    </scope>
                    <scope line="267"/>
                </scope>
                <scope line="274"/>
                <scope line="276"/>
            </method>
            <method name="read" type="LiveRef" line="285">
                <params>
                    <param name="in" type="ObjectInput"/>
                    <param name="useNewFormat" type="boolean"/>
                </params>
                <comment line="290">
                    Now read in the endpoint, id, and result flag
                     (need to choose whether or not to read old JDK1.1 endpoint format)                    
                </comment>
                <comment line="304">
                    save ref to send &quot;dirty&quot; call after all args/returns
                     have been unmarshaled.                    
                </comment>
                <comment line="308">
                    set flag in stream indicating that remote objects were
                     unmarshaled.  A DGC ack should be sent by the transport.                    
                </comment>
                <declaration name="ep" type="Endpoint" line="286"/>
                <declaration name="id" type="ObjID" line="287"/>
                <scope line="291"/>
                <scope line="293"/>
                <declaration name="isResultStream" type="boolean" line="297"/>
                <declaration name="ref" type="LiveRef" line="299"/>
                <scope line="301">
                    <declaration name="stream" type="ConnectionInputStream" line="302"/>
                    <scope line="306"/>
                </scope>
                <scope line="311"/>
            </method>
        </class>
    </source>