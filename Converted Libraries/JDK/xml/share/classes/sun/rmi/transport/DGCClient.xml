<?xml version="1.0" encoding="UTF-8"?>
    <source package="sun.rmi.transport">
        <import package="java.lang.ref.PhantomReference"/>
        <import package="java.lang.ref.ReferenceQueue"/>
        <import package="java.security.AccessController"/>
        <import package="java.security.PrivilegedAction"/>
        <import package="java.util.HashMap"/>
        <import package="java.util.HashSet"/>
        <import package="java.util.Iterator"/>
        <import package="java.util.List"/>
        <import package="java.util.Map"/>
        <import package="java.util.Set"/>
        <import package="java.rmi.ConnectException"/>
        <import package="java.rmi.RemoteException"/>
        <import package="java.rmi.dgc.DGC"/>
        <import package="java.rmi.dgc.Lease"/>
        <import package="java.rmi.dgc.VMID"/>
        <import package="java.rmi.server.ObjID"/>
        <import package="sun.misc.GC"/>
        <import package="sun.rmi.runtime.NewThreadAction"/>
        <import package="sun.rmi.server.UnicastRef"/>
        <import package="sun.rmi.server.Util"/>
        <import package="sun.security.action.GetLongAction"/>
        <class name="DGCClient" line="49">
            <comment line="117">
                Disallow anyone from creating one of these.                
            </comment>
            <javadoc line="49">
                DGCClient implements the client-side of the RMI distributed garbage
                  collection system.
                  The external interface to DGCClient is the &quot;registerRefs&quot; method.
                  When a LiveRef to a remote object enters the VM, it needs to be
                  registered with the DGCClient to participate in distributed garbage
                  collection.
                  When the first LiveRef to a particular remote object is registered,
                  a &quot;dirty&quot; call is made to the server-side distributed garbage
                  collector for the remote object, which returns a lease guaranteeing
                  that the server-side DGC will not collect the remote object for a
                  certain period of time.  While LiveRef instances to remote objects
                  on a particular server exist, the DGCClient periodically sends more
                  &quot;dirty&quot; calls to renew its lease.
                  The DGCClient tracks the local reachability of registered LiveRef
                  instances (using phantom references).  When the LiveRef instance
                  for a particular remote object becomes garbage collected locally,
                  a &quot;clean&quot; call is made to the server-side distributed garbage
                  collector, indicating that the server no longer needs to keep the
                  remote object alive for this client.                
                <see>
                    java.rmi.dgc.DGC, sun.rmi.transport.DGCImpl                    
                </see>
                <author>
                    Ann Wollrath                    
                </author>
                <author>
                    Peter Jones                    
                </author>
            </javadoc>
            <declaration name="nextSequenceNum" type="long" line="80"/>
            <javadoc line="80">
                next sequence number for DGC calls (access synchronized on class)                
            </javadoc>
            <declaration name="vmid" type="VMID" line="83"/>
            <javadoc line="83">
                unique identifier for this VM as a client of DGC                
            </javadoc>
            <declaration name="leaseValue" type="long" line="86"/>
            <javadoc line="86">
                lease duration to request (usually ignored by server)                
            </javadoc>
            <declaration name="cleanInterval" type="long" line="92"/>
            <javadoc line="92">
                maximum interval between retries of failed clean calls                
            </javadoc>
            <declaration name="gcInterval" type="long" line="98"/>
            <javadoc line="98">
                maximum interval between complete garbage collections of local heap                
            </javadoc>
            <declaration name="dirtyFailureRetries" type="int" line="104"/>
            <javadoc line="104">
                minimum retry count for dirty calls that fail                
            </javadoc>
            <declaration name="cleanFailureRetries" type="int" line="107"/>
            <javadoc line="107">
                retry count for clean calls that fail with ConnectException                
            </javadoc>
            <declaration name="emptyObjIDArray" type="ObjID[]" line="110"/>
            <javadoc line="110">
                constant empty ObjID array for lease renewal optimization                
            </javadoc>
            <declaration name="dgcID" type="ObjID" line="113"/>
            <javadoc line="113">
                ObjID for server-side DGC object                
            </javadoc>
            <method name="DGCClient" type="constructor" line="119"/>
            <javadoc line="121">
                Register the LiveRef instances in the supplied list to participate
                  in distributed garbage collection.
                  All of the LiveRefs in the list must be for remote objects at the
                  given endpoint.                
            </javadoc>
            <method name="registerRefs" type="void" line="128">
                <params>
                    <param name="ep" type="Endpoint"/>
                    <param name="refs" type="List"/>
                </params>
                <comment line="130">
                    Look up the given endpoint and register the refs with it.
                     The retrieved entry may get removed from the global endpoint
                     table before EndpointEntry.registerRefs() is able to acquire
                     its lock; in this event, it returns false, and we loop and
                     try again.                    
                </comment>
                <declaration name="epEntry" type="EndpointEntry" line="136"/>
                <scope line="137"/>
            </method>
            <javadoc line="142">
                Get the next sequence number to be used for a dirty or clean
                  operation from this VM.  This method should only be called while
                  synchronized on the EndpointEntry whose data structures the
                  operation affects.                
            </javadoc>
            <method name="getNextSequenceNum" type="long" line="148"/>
            <javadoc line="152">
                Given the length of a lease and the time that it was granted,
                  compute the absolute time at which it should be renewed, giving
                  room for reasonable computational and communication delays.                
            </javadoc>
            <method name="computeRenewTime" type="long" line="157">
                <params>
                    <param name="grantTime" type="long"/>
                    <param name="duration" type="long"/>
                </params>
                <comment line="159">
                    REMIND: This algorithm should be more sophisticated, waiting
                     a longer fraction of the lease duration for longer leases.                    
                </comment>
            </method>
            <class name="EndpointEntry" line="165">
                <javadoc line="165">
                    EndpointEntry encapsulates the client-side DGC information specific
                      to a particular Endpoint.  Of most significance is the table that
                      maps LiveRef value to RefEntry objects and the renew/clean thread
                      that handles asynchronous client-side DGC operations.                    
                </javadoc>
                <declaration name="endpoint" type="Endpoint" line="173"/>
                <javadoc line="173">
                    the endpoint that this entry is for                    
                </javadoc>
                <declaration name="dgc" type="DGC" line="175"/>
                <javadoc line="175">
                    synthesized reference to the remote server-side DGC                    
                </javadoc>
                <declaration name="refTable" type="Map" line="178"/>
                <javadoc line="178">
                    table of refs held for endpoint: maps LiveRef to RefEntry                    
                </javadoc>
                <declaration name="invalidRefs" type="Set" line="180"/>
                <javadoc line="180">
                    set of RefEntry instances from last (failed) dirty call                    
                </javadoc>
                <declaration name="removed" type="boolean" line="183"/>
                <javadoc line="183">
                    true if this entry has been removed from the global table                    
                </javadoc>
                <declaration name="renewTime" type="long" line="186"/>
                <javadoc line="186">
                    absolute time to renew current lease to this endpoint                    
                </javadoc>
                <declaration name="expirationTime" type="long" line="188"/>
                <javadoc line="188">
                    absolute time current lease to this endpoint will expire                    
                </javadoc>
                <declaration name="dirtyFailures" type="int" line="190"/>
                <javadoc line="190">
                    count of recent dirty calls that have failed                    
                </javadoc>
                <declaration name="dirtyFailureStartTime" type="long" line="192"/>
                <javadoc line="192">
                    absolute time of first recent failed dirty call                    
                </javadoc>
                <declaration name="dirtyFailureDuration" type="long" line="194"/>
                <javadoc line="194">
                    (average) elapsed time for recent failed dirty calls                    
                </javadoc>
                <declaration name="renewCleanThread" type="Thread" line="197"/>
                <javadoc line="197">
                    renew/clean thread for handling lease renewals and clean calls                    
                </javadoc>
                <declaration name="interruptible" type="boolean" line="199"/>
                <javadoc line="199">
                    true if renew/clean thread may be interrupted                    
                </javadoc>
                <declaration name="refQueue" type="ReferenceQueue" line="202"/>
                <javadoc line="202">
                    reference queue for phantom references                    
                </javadoc>
                <declaration name="pendingCleans" type="Set" line="204"/>
                <javadoc line="204">
                    set of clean calls that need to be made                    
                </javadoc>
                <declaration name="endpointTable" type="Map" line="207"/>
                <javadoc line="207">
                    global endpoint table: maps Endpoint to EndpointEntry                    
                </javadoc>
                <declaration name="gcLatencyRequest" type="GC.LatencyRequest" line="209"/>
                <javadoc line="209">
                    handle for GC latency request (for future cancellation)                    
                </javadoc>
                <javadoc line="212">
                    Look up the EndpointEntry for the given Endpoint.  An entry is
                      created if one does not already exist.                    
                </javadoc>
                <method name="lookup" type="EndpointEntry" line="216">
                    <params>
                        <param name="ep" type="Endpoint"/>
                    </params>
                    <comment line="223">
                        While we are tracking live remote references registered
                         in this VM, request a maximum latency for inspecting the
                         entire heap from the local garbage collector, to place
                         an upper bound on the time to discover remote references
                         that have become unreachable (see bugid 4171278).                        
                    </comment>
                    <scope line="217">
                        <declaration name="entry" type="EndpointEntry" line="218"/>
                        <scope line="219">
                            <scope line="229"/>
                        </scope>
                    </scope>
                </method>
                <method name="EndpointEntry" type="constructor" line="237">
                    <params>
                        <param name="endpoint" type="Endpoint"/>
                    </params>
                    <scope line="239">
                        <declaration name="dgcRef" type="LiveRef" line="240"/>
                    </scope>
                    <scope line="243"/>
                </method>
                <javadoc line="252">
                    Register the LiveRef instances in the supplied list to participate
                      in distributed garbage collection.
                      This method returns false if this entry was removed from the
                      global endpoint table (because it was empty) before these refs
                      could be registered.  In that case, a new EndpointEntry needs
                      to be looked up.
                      This method must NOT be called while synchronized on this entry.                    
                </javadoc>
                <method name="registerRefs" type="boolean" line="263">
                    <params>
                        <param name="refs" type="List"/>
                    </params>
                    <comment line="267">
                        entries for refs needing dirty                        
                    </comment>
                    <comment line="268">
                        sequence number for dirty call                        
                    </comment>
                    <declaration name="refsToDirty" type="Set" line="266"/>
                    <declaration name="sequenceNum" type="long" line="267"/>
                    <scope line="269">
                        <scope line="270"/>
                        <declaration name="iter" type="Iterator" line="274"/>
                        <scope line="275">
                            <declaration name="ref" type="LiveRef" line="276"/>
                            <declaration name="refEntry" type="RefEntry" line="279"/>
                            <scope line="280">
                                <declaration name="refClone" type="LiveRef" line="281"/>
                                <scope line="284"/>
                            </scope>
                        </scope>
                        <scope line="293"/>
                    </scope>
                </method>
                <javadoc line="307">
                    Remove the given RefEntry from the ref table.  If that makes
                      the ref table empty, remove this entry from the global endpoint
                      table.
                      This method must ONLY be called while synchronized on this entry.                    
                </javadoc>
                <method name="removeRefEntry" type="void" line="314">
                    <params>
                        <param name="refEntry" type="RefEntry"/>
                    </params>
                    <comment line="327">
                        If there are no longer any live remote references
                         registered, we are no longer concerned with the
                         latency of local garbage collection here.                        
                    </comment>
                    <scope line="321">
                        <scope line="322">
                            <declaration name="transport" type="Transport" line="324"/>
                            <scope line="331"/>
                        </scope>
                    </scope>
                </method>
                <javadoc line="341">
                    Make a DGC dirty call to this entry&apos;s endpoint, for the ObjIDs
                      corresponding to the given set of refs and with the given
                      sequence number.
                      This method must NOT be called while synchronized on this entry.                    
                </javadoc>
                <method name="makeDirtyCall" type="void" line="348">
                    <params>
                        <param name="refEntries" type="Set"/>
                        <param name="sequenceNum" type="long"/>
                    </params>
                    <comment line="381">
                        If this was the first recent failed dirty call,
                         reschedule another one immediately, in case there
                         was just a transient network problem, and remember
                         the start time and duration of this attempt for
                         future calculations of the delays between retries.                        
                    </comment>
                    <comment line="392">
                        For each successive failed dirty call, wait for a
                         (binary) exponentially increasing delay before
                         retrying, to avoid network congestion.                        
                    </comment>
                    <comment line="399">
                        Calculate the initial retry delay from the
                         average time elapsed for each of the first
                         two failed dirty calls.  The result must be
                         at least 1000ms, to prevent a tight loop.                        
                    </comment>
                    <comment line="412">
                        Continue if the last known held lease has not
                         expired, or else at least a fixed number of times,
                         or at least until we&apos;ve tried for a fixed amount
                         of time (the default lease value we request).                        
                    </comment>
                    <comment line="424">
                        Give up: postpone lease renewals until next
                         ref is registered for this endpoint.                        
                    </comment>
                    <comment line="433">
                        Add all of these refs to the set of refs for this
                         endpoint that may be invalid (this VM may not be in
                         the server&apos;s referenced set), so that we will
                         attempt to explicitly dirty them again in the
                         future.                        
                    </comment>
                    <comment line="442">
                        Record that a dirty call has failed for all of these
                         refs, so that clean calls for them in the future
                         will be strong.                        
                    </comment>
                    <comment line="454">
                        If the last known held lease will have expired before
                         the next renewal, all refs might be invalid.                        
                    </comment>
                    <declaration name="ids" type="ObjID[]" line="351"/>
                    <scope line="352"/>
                    <scope line="354"/>
                    <declaration name="startTime" type="long" line="358"/>
                    <scope line="359">
                        <declaration name="lease" type="Lease" line="360"/>
                        <declaration name="duration" type="long" line="362"/>
                        <declaration name="newRenewTime" type="long" line="364"/>
                        <declaration name="newExpirationTime" type="long" line="365"/>
                        <scope line="367"/>
                    </scope>
                    <scope line="373">
                        <declaration name="endTime" type="long" line="374"/>
                        <scope line="376">
                            <scope line="379"/>
                            <scope line="390">
                                <declaration name="n" type="int" line="396"/>
                                <scope line="397"/>
                                <declaration name="newRenewTime" type="long" line="408"/>
                                <scope line="420"/>
                                <scope line="422"/>
                            </scope>
                            <scope line="431">
                                <declaration name="iter" type="Iterator" line="446"/>
                                <scope line="447">
                                    <declaration name="refEntry" type="RefEntry" line="448"/>
                                </scope>
                            </scope>
                            <scope line="457"/>
                        </scope>
                    </scope>
                </method>
                <javadoc line="464">
                    Set the absolute time at which the lease for this entry should
                      be renewed.
                      This method must ONLY be called while synchronized on this entry.                    
                </javadoc>
                <method name="setRenewTime" type="void" line="470">
                    <params>
                        <param name="newRenewTime" type="long"/>
                    </params>
                    <scope line="473">
                        <scope line="475">
                            <anonymous_class line="477">
                                <method name="run" type="Void" line="478"/>
                            </anonymous_class>
                        </scope>
                    </scope>
                    <scope line="484"/>
                </method>
                <class name="RenewCleanThread" line="489">
                    <implements interface="Runnable"/>
                    <javadoc line="489">
                        RenewCleanThread handles the asynchronous client-side DGC activity
                          for this entry: renewing the leases and making clean calls.                        
                    </javadoc>
                    <method name="run" type="void" line="495">
                        <comment line="505">
                            Calculate time to block (waiting for phantom
                             reference notifications).  It is the time until the
                             lease renewal should be done, bounded on the low
                             end by 1 ms so that the reference queue will always
                             get processed, and if there are pending clean
                             requests (remaining because some clean calls
                             failed), bounded on the high end by the maximum
                             clean call retry interval.                            
                        </comment>
                        <comment line="522">
                            Set flag indicating that it is OK to interrupt this
                             thread now, such as if a earlier lease renewal time
                             is set, because we are only going to be blocking
                             and can deal with interrupts.                            
                        </comment>
                        <comment line="532">
                            Wait for the duration calculated above for any of
                             our phantom references to be enqueued.                            
                        </comment>
                        <comment line="542">
                            Set flag indicating that it is NOT OK to interrupt
                             this thread now, because we may be undertaking IO
                             operations that should not be interrupted (and we
                             will not be blocking arbitrarily).                            
                        </comment>
                        <comment line="549">
                            clear interrupted state                            
                        </comment>
                        <comment line="551">
                            If there was a phantom reference enqueued, process
                             it and all the rest on the queue, generating
                             clean requests as necessary.                            
                        </comment>
                        <comment line="560">
                            Check if it is time to renew this entry&apos;s lease.                            
                        </comment>
                        <scope line="496">
                            <declaration name="timeToWait" type="long" line="497"/>
                            <declaration name="phantom" type="RefEntry.PhantomLiveRef" line="498"/>
                            <declaration name="needRenewal" type="boolean" line="499"/>
                            <declaration name="refsToDirty" type="Set" line="500"/>
                            <declaration name="sequenceNum" type="long" line="501"/>
                            <scope line="503">
                                <declaration name="timeUntilRenew" type="long" line="514"/>
                                <scope line="517"/>
                            </scope>
                            <scope line="530"/>
                            <scope line="537"/>
                            <scope line="540">
                                <scope line="555"/>
                                <declaration name="currentTime" type="long" line="562"/>
                                <scope line="563">
                                    <scope line="565"/>
                                </scope>
                            </scope>
                            <scope line="573"/>
                            <scope line="577"/>
                        </scope>
                    </method>
                </class>
                <javadoc line="584">
                    Process the notification of the given phantom reference and any
                      others that are on this entry&apos;s reference queue.  Each phantom
                      reference is removed from its RefEntry&apos;s ref set.  All ref
                      entries that have no more registered instances are collected
                      into up to two batched clean call requests: one for refs
                      requiring a &quot;strong&quot; clean call, and one for the rest.
                      This method must ONLY be called while synchronized on this entry.                    
                </javadoc>
                <method name="processPhantomRefs" type="void" line="594">
                    <params>
                        <param name="phantom" type="RefEntry.PhantomLiveRef"/>
                    </params>
                    <declaration name="strongCleans" type="Set" line="597"/>
                    <declaration name="normalCleans" type="Set" line="598"/>
                    <scope line="600">
                        <declaration name="refEntry" type="RefEntry" line="601"/>
                        <scope line="603">
                            <scope line="604">
                                <scope line="605"/>
                            </scope>
                            <scope line="609">
                                <scope line="610"/>
                            </scope>
                        </scope>
                    </scope>
                    <scope line="620"/>
                    <scope line="625"/>
                </method>
                <class name="CleanRequest" line="632">
                    <javadoc line="632">
                        CleanRequest holds the data for the parameters of a clean call
                          that needs to be made.                        
                    </javadoc>
                    <declaration name="objIDs" type="ObjID[]" line="638"/>
                    <declaration name="sequenceNum" type="long" line="639"/>
                    <declaration name="strong" type="boolean" line="640"/>
                    <declaration name="failures" type="int" line="642"/>
                    <javadoc line="642">
                        how many times this request has failed                        
                    </javadoc>
                    <method name="CleanRequest" type="constructor" line="645">
                        <params>
                            <param name="objIDs" type="ObjID[]"/>
                            <param name="sequenceNum" type="long"/>
                            <param name="strong" type="boolean"/>
                        </params>
                    </method>
                </class>
                <javadoc line="652">
                    Make all of the clean calls described by the clean requests in
                      this entry&apos;s set of &quot;pending cleans&quot;.  Clean requests for clean
                      calls that succeed are removed from the &quot;pending cleans&quot; set.
                      This method must NOT be called while synchronized on this entry.                    
                </javadoc>
                <method name="makeCleanCalls" type="void" line="659">
                    <comment line="671">
                        Many types of exceptions here could have been
                         caused by a transient failure, so try again a
                         few times, but not forever.                        
                    </comment>
                    <declaration name="iter" type="Iterator" line="662"/>
                    <scope line="663">
                        <declaration name="request" type="CleanRequest" line="664"/>
                        <scope line="665"/>
                        <scope line="669">
                            <scope line="675"/>
                        </scope>
                    </scope>
                </method>
                <javadoc line="682">
                    Create an array of ObjIDs (needed for the DGC remote calls)
                      from the ids in the given set of refs.                    
                </javadoc>
                <method name="createObjIDArray" type="ObjID[]" line="686">
                    <params>
                        <param name="refEntries" type="Set"/>
                    </params>
                    <declaration name="ids" type="ObjID[]" line="687"/>
                    <declaration name="iter" type="Iterator" line="688"/>
                    <scope line="689"/>
                </method>
                <class name="RefEntry" line="695">
                    <javadoc line="695">
                        RefEntry encapsulates the client-side DGC information specific
                          to a particular LiveRef value.  In particular, it contains a
                          set of phantom references to all of the instances of the LiveRef
                          value registered in the system (but not garbage collected
                          locally).                        
                    </javadoc>
                    <declaration name="ref" type="LiveRef" line="704"/>
                    <javadoc line="704">
                        LiveRef value for this entry (not a registered instance)                        
                    </javadoc>
                    <declaration name="refSet" type="Set" line="706"/>
                    <javadoc line="706">
                        set of phantom references to registered instances                        
                    </javadoc>
                    <declaration name="dirtyFailed" type="boolean" line="708"/>
                    <javadoc line="708">
                        true if a dirty call containing this ref has failed                        
                    </javadoc>
                    <method name="RefEntry" type="constructor" line="711">
                        <params>
                            <param name="ref" type="LiveRef"/>
                        </params>
                    </method>
                    <javadoc line="715">
                        Return the LiveRef value for this entry (not a registered
                          instance).                        
                    </javadoc>
                    <method name="getRef" type="LiveRef" line="719"/>
                    <javadoc line="723">
                        Add a LiveRef to the set of registered instances for this entry.
                          This method must ONLY be invoked while synchronized on this
                          RefEntry&apos;s EndpointEntry.                        
                    </javadoc>
                    <method name="addInstanceToRefSet" type="void" line="729">
                        <params>
                            <param name="ref" type="LiveRef"/>
                        </params>
                        <comment line="734">
                            Only keep a phantom reference to the registered instance,
                             so that it can be garbage collected normally (and we can be
                             notified when that happens).                            
                        </comment>
                    </method>
                    <javadoc line="741">
                        Remove a PhantomLiveRef from the set of registered instances.
                          This method must ONLY be invoked while synchronized on this
                          RefEntry&apos;s EndpointEntry.                        
                    </javadoc>
                    <method name="removeInstanceFromRefSet" type="void" line="747">
                        <params>
                            <param name="phantom" type="PhantomLiveRef"/>
                        </params>
                    </method>
                    <javadoc line="753">
                        Return true if there are no registered LiveRef instances for
                          this entry still reachable in this VM.
                          This method must ONLY be invoked while synchronized on this
                          RefEntry&apos;s EndpointEntry.                        
                    </javadoc>
                    <method name="isRefSetEmpty" type="boolean" line="760"/>
                    <javadoc line="765">
                        Record that a dirty call that explicitly contained this
                          entry&apos;s ref has failed.
                          This method must ONLY be invoked while synchronized on this
                          RefEntry&apos;s EndpointEntry.                        
                    </javadoc>
                    <method name="markDirtyFailed" type="void" line="772"/>
                    <javadoc line="777">
                        Return true if a dirty call that explicitly contained this
                          entry&apos;s ref has failed (and therefore a clean call for this
                          ref needs to be marked &quot;strong&quot;).
                          This method must ONLY be invoked while synchronized on this
                          RefEntry&apos;s EndpointEntry.                        
                    </javadoc>
                    <method name="hasDirtyFailed" type="boolean" line="785"/>
                    <class name="PhantomLiveRef" line="790">
                        <extends class="PhantomReference"/>
                        <javadoc line="790">
                            PhantomLiveRef is a PhantomReference to a LiveRef instance,
                              used to detect when the LiveRef becomes permanently
                              unreachable in this VM.                            
                        </javadoc>
                        <method name="PhantomLiveRef" type="constructor" line="797">
                            <params>
                                <param name="ref" type="LiveRef"/>
                            </params>
                        </method>
                        <method name="getRefEntry" type="RefEntry" line="801"/>
                    </class>
                </class>
            </class>
        </class>
    </source>