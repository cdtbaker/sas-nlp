<?xml version="1.0" encoding="UTF-8"?>
    <source package="sun.rmi.transport">
        <import package="java.io.IOException"/>
        <import package="java.io.ObjectOutput"/>
        <import package="java.rmi.MarshalException"/>
        <import package="java.rmi.NoSuchObjectException"/>
        <import package="java.rmi.Remote"/>
        <import package="java.rmi.RemoteException"/>
        <import package="java.rmi.server.LogStream"/>
        <import package="java.rmi.server.ObjID"/>
        <import package="java.rmi.server.RemoteCall"/>
        <import package="java.rmi.server.RemoteServer"/>
        <import package="java.rmi.server.ServerNotActiveException"/>
        <import package="java.security.AccessControlContext"/>
        <import package="sun.rmi.runtime.Log"/>
        <import package="sun.rmi.server.Dispatcher"/>
        <import package="sun.rmi.server.UnicastServerRef"/>
        <class name="Transport" line="44">
            <comment line="61">
                                
            </comment>
            <javadoc line="44">
                Transport abstraction for enabling communication between different
                  VMs.                
                <author>
                    Ann Wollrath                    
                </author>
            </javadoc>
            <declaration name="logLevel" type="int" line="52"/>
            <javadoc line="52">
                &quot;transport&quot; package log level                
            </javadoc>
            <method name="getLogLevel" type="String" line="55"/>
            <declaration name="transportLog" type="Log" line="61"/>
            <declaration name="currentTransport" type="ThreadLocal" line="64"/>
            <javadoc line="64">
                References the current transport when a call is being serviced                
            </javadoc>
            <declaration name="dgcID" type="ObjID" line="67"/>
            <javadoc line="67">
                ObjID for DGCImpl                
            </javadoc>
            <method name="getChannel" type="Channel" line="70"/>
            <javadoc line="70">
                Returns a &lt;I&gt;Channel&lt;/I&gt; that generates connections to the
                  endpoint &lt;I&gt;ep&lt;/I&gt;. A Channel is an object that creates and
                  manages connections of a particular type to some particular
                  address space.                
                <param>
                    ep the endpoint to which connections will be generated.                    
                </param>
                <return>
                    the channel or null if the transport cannot
                      generate connections to this endpoint                    
                </return>
            </javadoc>
            <method name="free" type="void" line="81"/>
            <javadoc line="81">
                Removes the &lt;I&gt;Channel&lt;/I&gt; that generates connections to the
                  endpoint &lt;I&gt;ep&lt;/I&gt;.                
            </javadoc>
            <javadoc line="87">
                Export the object so that it can accept incoming calls.                
            </javadoc>
            <method name="exportObject" type="void" line="90">
                <params>
                    <param name="target" type="Target"/>
                </params>
            </method>
            <javadoc line="95">
                Invoked when an object that was exported on this transport has
                  become unexported, either by being garbage collected or by
                  being explicitly unexported.                
            </javadoc>
            <method name="targetUnexported" type="void" line="100"/>
            <javadoc line="102">
                Returns the current transport if a call is being serviced, otherwise
                  returns null.                
            </javadoc>
            <method name="currentTransport" type="Transport" line="106"/>
            <method name="checkAcceptPermission" type="void" line="110"/>
            <javadoc line="110">
                Verify that the current access control context has permission to accept
                  the connection being dispatched by the current thread.  The current
                  access control context is passed as a parameter to avoid the overhead of
                  an additional call to AccessController.getContext.                
            </javadoc>
            <javadoc line="118">
                Service an incoming remote call. When a message arrives on the
                  connection indicating the beginning of a remote call, the
                  threads are required to call the &lt;I&gt;serviceCall&lt;/I&gt; method of
                  their transport.  The default implementation of this method
                  locates and calls the dispatcher object.  Ordinarily a
                  transport implementation will not need to override this method.
                  At the entry to &lt;I&gt;tr.serviceCall(conn)&lt;/I&gt;, the connection&apos;s
                  input stream is positioned at the start of the incoming
                  message.  The &lt;I&gt;serviceCall&lt;/I&gt; method processes the incoming
                  remote invocation and sends the result on the connection&apos;s
                  output stream.  If it returns &quot;true&quot;, then the remote
                  invocation was processed without error and the transport can
                  cache the connection.  If it returns &quot;false&quot;, a protocol error
                  occurred during the call, and the transport should destroy the
                  connection.                
            </javadoc>
            <method name="serviceCall" type="boolean" line="135">
                <params>
                    <param name="call" type="RemoteCall"/>
                </params>
                <comment line="137">
                                        
                </comment>
                <comment line="147">
                                        
                </comment>
                <comment line="159">
                                        
                </comment>
                <comment line="199">
                    if calls are being logged, write out exception                    
                </comment>
                <comment line="201">
                    include client host name if possible                    
                </comment>
                <comment line="212">
                    We will get a RemoteException if either a) the objID is
                     not readable, b) the target is not in the object table, or
                     c) the object is in the midst of being unexported (note:
                     NoSuchObjectException is thrown by the incrementCallCount
                     method if the object is being unexported).  Here it is
                     relatively safe to marshal an exception to the client
                     since the client will not have seen a return value yet.                    
                </comment>
                <scope line="136">
                    <declaration name="impl" type="Remote" line="138"/>
                    <declaration name="id" type="ObjID" line="139"/>
                    <scope line="141"/>
                    <scope line="143"/>
                    <declaration name="transport" type="Transport" line="148"/>
                    <declaration name="target" type="Target" line="149"/>
                    <scope line="152"/>
                    <declaration name="disp" type="Dispatcher" line="156"/>
                    <scope line="158">
                        <declaration name="acc" type="AccessControlContext" line="162"/>
                        <declaration name="ccl" type="ClassLoader" line="164"/>
                        <declaration name="t" type="Thread" line="166"/>
                        <declaration name="savedCcl" type="ClassLoader" line="167"/>
                        <scope line="169">
                            <scope line="172">
                                <anonymous_class line="174">
                                    <method name="run" type="Void" line="175"/>
                                </anonymous_class>
                            </scope>
                            <scope line="181"/>
                        </scope>
                        <scope line="184"/>
                    </scope>
                    <scope line="189"/>
                    <scope line="193"/>
                </scope>
                <scope line="197">
                    <scope line="200">
                        <declaration name="clientHost" type="String" line="202"/>
                        <scope line="203"/>
                        <scope line="206"/>
                        <declaration name="message" type="String" line="208"/>
                    </scope>
                    <scope line="220">
                        <declaration name="out" type="ObjectOutput" line="221"/>
                    </scope>
                    <scope line="226"/>
                </scope>
            </method>
        </class>
    </source>