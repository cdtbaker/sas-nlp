<?xml version="1.0" encoding="UTF-8"?>
    <source package="sun.rmi.transport">
        <import package="java.io"/>
        <import package="java.util"/>
        <import package="java.rmi.RemoteException"/>
        <import package="java.rmi.server.UID"/>
        <import package="sun.rmi.server.MarshalInputStream"/>
        <import package="sun.rmi.runtime.Log"/>
        <class name="ConnectionInputStream" line="34">
            <extends class="MarshalInputStream"/>
            <javadoc line="34">
                Special stream to keep track of refs being unmarshaled so that
                  refs can be ref-counted locally.                
                <author>
                    Ann Wollrath                    
                </author>
            </javadoc>
            <declaration name="dgcAckNeeded" type="boolean" line="42"/>
            <javadoc line="42">
                indicates whether ack is required for DGC                
            </javadoc>
            <declaration name="incomingRefTable" type="Map" line="45"/>
            <javadoc line="45">
                Hashtable mapping Endpoints to lists of LiveRefs to register                
            </javadoc>
            <declaration name="ackID" type="UID" line="48"/>
            <javadoc line="48">
                identifier for gc ack                
            </javadoc>
            <javadoc line="51">
                Constructs a marshal input stream using the underlying
                  stream &quot;in&quot;.                
            </javadoc>
            <method name="ConnectionInputStream" type="constructor" line="55">
                <params>
                    <param name="in" type="InputStream"/>
                </params>
            </method>
            <method name="readID" type="void" line="59"/>
            <javadoc line="63">
                Save reference in order to send &quot;dirty&quot; call after all args/returns
                  have been unmarshaled.  Save in hashtable incomingRefTable.  This
                  table is keyed on endpoints, and holds objects of type
                  IncomingRefTableEntry.                
            </javadoc>
            <method name="saveRef" type="void" line="69">
                <params>
                    <param name="ref" type="LiveRef"/>
                </params>
                <comment line="72">
                    check whether endpoint is already in the hashtable                    
                </comment>
                <comment line="80">
                    add ref to list of refs for endpoint ep                    
                </comment>
                <declaration name="ep" type="Endpoint" line="70"/>
                <declaration name="refList" type="List" line="73"/>
                <scope line="75"/>
            </method>
            <javadoc line="84">
                Add references to DGC table (and possibly send dirty call).
                  RegisterRefs now calls DGCClient.referenced on all
                  refs with the same endpoint at once to achieve batching of
                  calls to the DGC                
            </javadoc>
            <method name="registerRefs" type="void" line="90">
                <scope line="91">
                    <declaration name="entrySet" type="Set" line="92"/>
                    <declaration name="iter" type="Iterator" line="93"/>
                    <scope line="94">
                        <declaration name="entry" type="Map.Entry" line="95"/>
                        <declaration name="ep" type="Endpoint" line="96"/>
                        <declaration name="refList" type="List" line="97"/>
                    </scope>
                </scope>
            </method>
            <javadoc line="103">
                Indicate that an ack is required to the distributed
                  collector.                
            </javadoc>
            <method name="setAckNeeded" type="void" line="107"/>
            <javadoc line="111">
                Done with input stream for remote call. Send DGC ack if necessary.
                  Allow sending of ack to fail without flagging an error.                
            </javadoc>
            <method name="done" type="void" line="115">
                <params>
                    <param name="c" type="Connection"/>
                </params>
                <comment line="116">
                    WARNING: The connection c may have already been freed.  It
                     is only be safe to use c to obtain c&apos;s channel.                    
                </comment>
                <comment line="140">
                    Fix for 4221173: if this connection is on top of an
                     HttpSendSocket, the DGCAck won&apos;t actually get sent until a
                     read operation is attempted on the socket.  Calling
                     available() is the most innocuous way of triggering the
                     write.                    
                </comment>
                <comment line="158">
                    eat exception                    
                </comment>
                <scope line="121">
                    <declaration name="conn" type="Connection" line="122"/>
                    <declaration name="ch" type="Channel" line="123"/>
                    <declaration name="reuse" type="boolean" line="124"/>
                    <scope line="128">
                        <declaration name="out" type="DataOutputStream" line="131"/>
                        <scope line="134"/>
                    </scope>
                    <scope line="149"/>
                    <scope line="151"/>
                    <scope line="154"/>
                    <scope line="157"/>
                </scope>
            </method>
        </class>
    </source>