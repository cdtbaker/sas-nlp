<?xml version="1.0" encoding="UTF-8"?>
    <source package="sun.rmi.transport">
        <import package="java.io"/>
        <import package="java.util"/>
        <import package="java.rmi.RemoteException"/>
        <import package="java.rmi.server.UID"/>
        <import package="sun.rmi.server.MarshalInputStream"/>
        <import package="sun.rmi.runtime.Log"/>
        <class name="ConnectionInputStream" line="8">
            <extends class="MarshalInputStream"/>
            <javadoc line="8">
                Special stream to keep track of refs being unmarshaled so that
                  refs can be ref-counted locally.                
                <author>
                    Ann Wollrath                    
                </author>
            </javadoc>
            <declaration name="dgcAckNeeded" type="boolean" line="14"/>
            <javadoc line="14">
                indicates whether ack is required for DGC                
            </javadoc>
            <declaration name="incomingRefTable" type="Map" line="18"/>
            <javadoc line="18">
                Hashtable mapping Endpoints to lists of LiveRefs to register                
            </javadoc>
            <declaration name="ackID" type="UID" line="22"/>
            <javadoc line="22">
                identifier for gc ack                
            </javadoc>
            <javadoc line="26">
                Constructs a marshal input stream using the underlying
                  stream &quot;in&quot;.                
            </javadoc>
            <method name="ConnectionInputStream" type="constructor" line="30">
                <params>
                    <param name="in" type="InputStream"/>
                </params>
            </method>
            <method name="readID" type="void" line="33"/>
            <javadoc line="36">
                Save reference in order to send &quot;dirty&quot; call after all args/returns
                  have been unmarshaled.  Save in hashtable incomingRefTable.  This
                  table is keyed on endpoints, and holds objects of type
                  IncomingRefTableEntry.                
            </javadoc>
            <method name="saveRef" type="void" line="42">
                <params>
                    <param name="ref" type="LiveRef"/>
                </params>
                <declaration name="ep" type="Endpoint" line="43"/>
                <declaration name="refList" type="List" line="44"/>
                <scope line="45"/>
            </method>
            <javadoc line="51">
                Add references to DGC table (and possibly send dirty call).
                  RegisterRefs now calls DGCClient.referenced on all
                  refs with the same endpoint at once to achieve batching of
                  calls to the DGC                
            </javadoc>
            <method name="registerRefs" type="void" line="57">
                <scope line="58">
                    <declaration name="entrySet" type="Set" line="59"/>
                    <declaration name="iter" type="Iterator" line="60"/>
                    <scope line="61">
                        <declaration name="entry" type="Map.Entry" line="62"/>
                        <declaration name="ep" type="Endpoint" line="63"/>
                        <declaration name="refList" type="List" line="64"/>
                    </scope>
                </scope>
            </method>
            <javadoc line="69">
                Indicate that an ack is required to the distributed
                  collector.                
            </javadoc>
            <method name="setAckNeeded" type="void" line="73"/>
            <javadoc line="76">
                Done with input stream for remote call. Send DGC ack if necessary.
                  Allow sending of ack to fail without flagging an error.                
            </javadoc>
            <method name="done" type="void" line="80">
                <params>
                    <param name="c" type="Connection"/>
                </params>
                <scope line="81">
                    <declaration name="conn" type="Connection" line="82"/>
                    <declaration name="ch" type="Channel" line="83"/>
                    <declaration name="reuse" type="boolean" line="84"/>
                    <scope line="86">
                        <declaration name="out" type="DataOutputStream" line="89"/>
                        <scope line="91"/>
                    </scope>
                    <scope line="99"/>
                    <scope line="102"/>
                    <scope line="105"/>
                    <scope line="108"/>
                </scope>
            </method>
        </class>
    </source>