<?xml version="1.0" encoding="UTF-8"?>
    <source package="sun.rmi.transport">
        <import package="java.rmi.Remote"/>
        <import package="java.rmi.NoSuchObjectException"/>
        <import package="java.rmi.dgc.VMID"/>
        <import package="java.rmi.server.ObjID"/>
        <import package="java.rmi.server.Unreferenced"/>
        <import package="java.security.AccessControlContext"/>
        <import package="java.security.AccessController"/>
        <import package="java.util"/>
        <import package="sun.rmi.runtime.Log"/>
        <import package="sun.rmi.runtime.NewThreadAction"/>
        <import package="sun.rmi.server.Dispatcher"/>
        <class name="Target" line="39">
            <javadoc line="39">
                A target contains information pertaining to a remote object that
                  resides in this address space.  Targets are located via the
                  ObjectTable.                
            </javadoc>
            <declaration name="id" type="ObjID" line="45"/>
            <javadoc line="45">
                object id for target                
            </javadoc>
            <declaration name="permanent" type="boolean" line="47"/>
            <javadoc line="47">
                flag indicating whether target is subject to collection                
            </javadoc>
            <declaration name="weakImpl" type="WeakRef" line="49"/>
            <javadoc line="49">
                weak reference to remote object implementation                
            </javadoc>
            <declaration name="disp" type="Dispatcher" line="51"/>
            <javadoc line="51">
                dispatcher for remote object                
            </javadoc>
            <declaration name="stub" type="Remote" line="53"/>
            <javadoc line="53">
                stub for remote object                
            </javadoc>
            <declaration name="refSet" type="Vector" line="55"/>
            <javadoc line="55">
                set of clients that hold references to this target                
            </javadoc>
            <declaration name="sequenceTable" type="Hashtable" line="57"/>
            <javadoc line="57">
                table that maps client endpoints to sequence numbers                
            </javadoc>
            <declaration name="acc" type="AccessControlContext" line="59"/>
            <javadoc line="59">
                access control context in which target was created                
            </javadoc>
            <declaration name="ccl" type="ClassLoader" line="61"/>
            <javadoc line="61">
                context class loader in which target was created                
            </javadoc>
            <declaration name="callCount" type="int" line="63"/>
            <javadoc line="63">
                number of pending/executing calls                
            </javadoc>
            <declaration name="removed" type="boolean" line="65"/>
            <javadoc line="65">
                true if this target has been removed from the object table                
            </javadoc>
            <declaration name="exportedTransport" type="Transport" line="67"/>
            <javadoc line="67">
                the transport through which this target was exported and
                  through which remote calls will be allowed                
            </javadoc>
            <declaration name="nextThreadNum" type="int" line="73"/>
            <javadoc line="73">
                number to identify next callback thread created here                
            </javadoc>
            <javadoc line="76">
                Construct a Target for a remote object &quot;impl&quot; with
                  a specific object id.
                  If &quot;permanent&quot; is true, then the impl is pinned permanently
                  (the impl will not be collected via distributed and/or local
                  GC).  If &quot;on&quot; is false, than the impl is subject to
                  collection. Permanent objects do not keep a server from
                  exiting.                
            </javadoc>
            <method name="Target" type="constructor" line="88">
                <params>
                    <param name="impl" type="Remote"/>
                    <param name="disp" type="Dispatcher"/>
                    <param name="stub" type="Remote"/>
                    <param name="id" type="ObjID"/>
                    <param name="permanent" type="boolean"/>
                </params>
                <comment line="95">
                    Fix for 4149366: so that downloaded parameter types unmarshalled
                     for this impl will be compatible with types known only to the
                     impl class&apos;s class loader (when it&apos;s not identical to the
                     exporting thread&apos;s context class loader), mark the impl&apos;s class
                     loader as the loader to use as the context class loader in the
                     server&apos;s dispatch thread while a call to this impl is being
                     processed (unless this exporting thread&apos;s context class loader is
                     a child of the impl&apos;s class loader, such as when a registry is
                     exported by an application, in which case this thread&apos;s context
                     class loader is preferred).                    
                </comment>
                <declaration name="threadContextLoader" type="ClassLoader" line="107"/>
                <declaration name="serverLoader" type="ClassLoader" line="109"/>
                <scope line="110"/>
                <scope line="112"/>
                <scope line="117"/>
            </method>
            <javadoc line="122">
                Return true if the first class loader is a child of (or identical
                  to) the second class loader.  Either loader may be &quot;null&quot;, which is
                  considered to be the parent of any non-null class loader.
                  (utility method added for the 1.2beta4 fix for 4149366)                
            </javadoc>
            <method name="checkLoaderAncestry" type="boolean" line="131">
                <params>
                    <param name="child" type="ClassLoader"/>
                    <param name="ancestor" type="ClassLoader"/>
                </params>
                <scope line="132"/>
                <scope line="134"/>
                <scope line="136">
                    <scope line="140">
                        <scope line="141"/>
                    </scope>
                </scope>
            </method>
            <javadoc line="149">
                Get the stub (proxy) object for this target                
            </javadoc>
            <method name="getStub" type="Remote" line="151"/>
            <javadoc line="155">
                Returns the object endpoint for the target.                
            </javadoc>
            <method name="getObjectEndpoint" type="ObjectEndpoint" line="158"/>
            <javadoc line="162">
                Get the weak reference for the Impl of this target.                
            </javadoc>
            <method name="getWeakImpl" type="WeakRef" line="165"/>
            <javadoc line="169">
                Returns the dispatcher for this remote object target.                
            </javadoc>
            <method name="getDispatcher" type="Dispatcher" line="172"/>
            <method name="getAccessControlContext" type="AccessControlContext" line="176"/>
            <method name="getContextClassLoader" type="ClassLoader" line="180"/>
            <javadoc line="184">
                Get the impl for this target.
                  Note: this may return null if the impl has been garbage collected.
                  (currently, there is no need to make this method public)                
            </javadoc>
            <method name="getImpl" type="Remote" line="189"/>
            <javadoc line="193">
                Returns true if the target is permanent.                
            </javadoc>
            <method name="isPermanent" type="boolean" line="196"/>
            <javadoc line="200">
                Pin impl in target. Pin the WeakRef object so it holds a strong
                  reference to the object to it will not be garbage collected locally.
                  This way there is a single object responsible for the weak ref
                  mechanism.                
            </javadoc>
            <method name="pinImpl" type="void" line="206"/>
            <javadoc line="210">
                Unpin impl in target.  Weaken the reference to impl so that it
                  can be garbage collected locally. But only if there the refSet
                  is empty.  All of the weak/strong handling is in WeakRef                
            </javadoc>
            <method name="unpinImpl" type="void" line="215">
                <comment line="216">
                    only unpin if:
                     a) impl is not permanent, and
                     b) impl is not already unpinned, and
                     c) there are no external references (outside this
                        address space) for the impl                    
                </comment>
                <scope line="222"/>
            </method>
            <javadoc line="227">
                Enable the transport through which remote calls to this target
                  are allowed to be set if it has not already been set.                
            </javadoc>
            <method name="setExportedTransport" type="void" line="231">
                <params>
                    <param name="exportedTransport" type="Transport"/>
                </params>
                <scope line="232"/>
            </method>
            <javadoc line="237">
                Add an endpoint to the remembered set.  Also adds a notifier
                  to call back if the address space associated with the endpoint
                  dies.                
            </javadoc>
            <method name="referenced" type="void" line="242">
                <params>
                    <param name="sequenceNum" type="long"/>
                    <param name="vmid" type="VMID"/>
                </params>
                <comment line="243">
                    check sequence number for vmid                    
                </comment>
                <comment line="250">
                    late dirty call; ignore.                    
                </comment>
                <comment line="255">
                    A Target must be pinned while its refSet is not empty.  It may
                     have become unpinned if external LiveRefs only existed in
                     serialized form for some period of time, or if a client failed
                     to renew its lease due to a transient network failure.  So,
                     make sure that it is pinned here; this fixes bugid 4069644.                    
                </comment>
                <comment line="263">
                    too late if impl was collected                    
                </comment>
                <declaration name="entry" type="SequenceEntry" line="244"/>
                <scope line="245"/>
                <scope line="247"/>
                <scope line="249"/>
                <scope line="254">
                    <scope line="266"/>
                </scope>
            </method>
            <javadoc line="276">
                Remove endpoint from remembered set.  If set becomes empty,
                  remove server from Transport&apos;s object table.                
            </javadoc>
            <method name="unreferenced" type="void" line="281">
                <params>
                    <param name="sequenceNum" type="long"/>
                    <param name="vmid" type="VMID"/>
                    <param name="strong" type="boolean"/>
                </params>
                <comment line="282">
                    check sequence number for vmid                    
                </comment>
                <comment line="285">
                    late clean call; ignore                    
                </comment>
                <comment line="288">
                    strong clean call; retain sequenceNum                    
                </comment>
                <comment line="291">
                    get rid of sequence number                    
                </comment>
                <declaration name="entry" type="SequenceEntry" line="283"/>
                <scope line="284"/>
                <scope line="287"/>
                <scope line="290"/>
                <scope line="295"/>
            </method>
            <javadoc line="302">
                Remove endpoint from the reference set.                
            </javadoc>
            <method name="refSetRemove" type="void" line="305">
                <params>
                    <param name="vmid" type="VMID"/>
                </params>
                <comment line="306">
                    remove notification request                    
                </comment>
                <comment line="310">
                    reference set is empty, so server can be garbage collected.                    
                </comment>
                <comment line="311">
                    remove object from table.                    
                </comment>
                <comment line="317">
                    If the remote object implements the Unreferenced interface,
                     invoke its unreferenced callback in a separate thread.                    
                </comment>
                <comment line="331">
                    REMIND: access to nextThreadNum not synchronized; you care?                    
                </comment>
                <comment line="332">
                    We must manually set the context class loader appropriately
                     for threads that may invoke user code (see bugid 4171278).                    
                </comment>
                <scope line="309">
                    <scope line="312"/>
                    <declaration name="obj" type="Remote" line="321"/>
                    <scope line="322">
                        <declaration name="unrefObj" type="Unreferenced" line="323"/>
                        <anonymous_class line="326">
                            <method name="run" type="void" line="327"/>
                        </anonymous_class>
                        <declaration name="t" type="Thread" line="324"/>
                        <anonymous_class line="337">
                            <method name="run" type="Void" line="338"/>
                        </anonymous_class>
                    </scope>
                </scope>
            </method>
            <javadoc line="351">
                Mark this target as not accepting new calls if any of the
                  following conditions exist: a) the force parameter is true,
                  b) the target&apos;s call count is zero, or c) the object is already
                  not accepting calls. Returns true if target is marked as not
                  accepting new calls; returns false otherwise.                
            </javadoc>
            <method name="unexport" type="boolean" line="358">
                <params>
                    <param name="force" type="boolean"/>
                </params>
                <comment line="362">
                    Fix for 4331349: unpin object so that it may be gc&apos;d.
                     Also, unregister all vmids referencing this target
                     so target can be gc&apos;d.                    
                </comment>
                <scope line="360">
                    <declaration name="dgc" type="DGCImpl" line="368"/>
                    <declaration name="enum_" type="Enumeration" line="369"/>
                    <scope line="370">
                        <declaration name="vmid" type="VMID" line="371"/>
                    </scope>
                </scope>
                <scope line="375"/>
            </method>
            <javadoc line="380">
                Mark this target as having been removed from the object table.                
            </javadoc>
            <method name="markRemoved" type="void" line="383">
                <scope line="384"/>
                <scope line="387"/>
                <scope line="391"/>
            </method>
            <javadoc line="396">
                Increment call count.                
            </javadoc>
            <method name="incrementCallCount" type="void" line="399">
                <scope line="401"/>
                <scope line="403"/>
            </method>
            <javadoc line="408">
                Decrement call count.                
            </javadoc>
            <method name="decrementCallCount" type="void" line="411">
                <comment line="417">
                    The &quot;keep-alive count&quot; is the number of non-permanent remote
                     objects that are either in the object table or still have calls
                     in progress.  Therefore, this state change may affect the
                     keep-alive count: if this target is for a non-permanent remote
                     object that has been removed from the object table and now has a
                     call count of zero, it needs to be decremented.                    
                </comment>
                <scope line="413"/>
                <scope line="425"/>
            </method>
            <javadoc line="430">
                Returns true if remembered set is empty; otherwise returns
                  false                
            </javadoc>
            <method name="isEmpty" type="boolean" line="434"/>
            <javadoc line="438">
                This method is called if the address space associated with the
                  vmid dies.  In that case, the vmid should be removed
                  from the reference set.                
            </javadoc>
            <method name="vmidDead" type="void" line="443">
                <params>
                    <param name="vmid" type="VMID"/>
                </params>
                <scope line="444"/>
            </method>
        </class>
        <class name="SequenceEntry" line="454">
            <declaration name="sequenceNum" type="long" line="455"/>
            <declaration name="keep" type="boolean" line="456"/>
            <method name="SequenceEntry" type="constructor" line="458">
                <params>
                    <param name="sequenceNum" type="long"/>
                </params>
            </method>
            <method name="retain" type="void" line="463">
                <params>
                    <param name="sequenceNum" type="long"/>
                </params>
            </method>
            <method name="update" type="void" line="468">
                <params>
                    <param name="sequenceNum" type="long"/>
                </params>
            </method>
        </class>
    </source>