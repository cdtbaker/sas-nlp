<?xml version="1.0" encoding="UTF-8"?>
    <source package="sun.rmi.transport.tcp">
        <import package="java.io.DataInputStream"/>
        <import package="java.io.DataOutputStream"/>
        <import package="java.io.IOException"/>
        <import package="java.lang.ref.Reference"/>
        <import package="java.lang.ref.SoftReference"/>
        <import package="java.net.Socket"/>
        <import package="java.rmi.ConnectIOException"/>
        <import package="java.rmi.RemoteException"/>
        <import package="java.security.AccessControlContext"/>
        <import package="java.security.AccessController"/>
        <import package="java.util.ArrayList"/>
        <import package="java.util.List"/>
        <import package="java.util.ListIterator"/>
        <import package="java.util.WeakHashMap"/>
        <import package="java.util.concurrent.Future"/>
        <import package="java.util.concurrent.ScheduledExecutorService"/>
        <import package="java.util.concurrent.TimeUnit"/>
        <import package="sun.rmi.runtime.Log"/>
        <import package="sun.rmi.runtime.NewThreadAction"/>
        <import package="sun.rmi.runtime.RuntimeUtil"/>
        <import package="sun.rmi.transport.Channel"/>
        <import package="sun.rmi.transport.Connection"/>
        <import package="sun.rmi.transport.Endpoint"/>
        <import package="sun.rmi.transport.TransportConstants"/>
        <import package="sun.security.action.GetIntegerAction"/>
        <import package="sun.security.action.GetLongAction"/>
        <class name="TCPChannel" line="54">
            <implements interface="Channel"/>
            <javadoc line="54">
                TCPChannel is the socket-based implementation of the RMI Channel
                  abstraction.                
                <author>
                    Ann Wollrath                    
                </author>
            </javadoc>
            <declaration name="ep" type="TCPEndpoint" line="61"/>
            <javadoc line="61">
                endpoint for this channel                
            </javadoc>
            <declaration name="tr" type="TCPTransport" line="63"/>
            <javadoc line="63">
                transport for this channel                
            </javadoc>
            <declaration name="freeList" type="List&lt;TCPConnection&gt;" line="65"/>
            <javadoc line="65">
                list of cached connections                
            </javadoc>
            <declaration name="reaper" type="Future&lt;?&gt;" line="68"/>
            <javadoc line="68">
                frees cached connections that have expired (guarded by freeList)                
            </javadoc>
            <declaration name="usingMultiplexer" type="boolean" line="71"/>
            <javadoc line="71">
                using multiplexer (for bi-directional applet communication                
            </javadoc>
            <declaration name="multiplexer" type="ConnectionMultiplexer" line="73"/>
            <javadoc line="73">
                connection multiplexer, if used                
            </javadoc>
            <declaration name="acceptor" type="ConnectionAcceptor" line="75"/>
            <javadoc line="75">
                connection acceptor (should be in TCPTransport)                
            </javadoc>
            <declaration name="okContext" type="AccessControlContext" line="78"/>
            <javadoc line="78">
                most recently authorized AccessControlContext                
            </javadoc>
            <declaration name="authcache" type="WeakHashMap&lt;AccessControlContext,Reference&lt;AccessControlContext&gt;&gt;" line="81"/>
            <javadoc line="81">
                cache of authorized AccessControlContexts                
            </javadoc>
            <declaration name="cacheSecurityManager" type="SecurityManager" line="85"/>
            <javadoc line="85">
                the SecurityManager which authorized okContext and authcache                
            </javadoc>
            <declaration name="idleTimeout" type="long" line="88"/>
            <javadoc line="88">
                client-side connection idle usage timeout                
            </javadoc>
            <declaration name="handshakeTimeout" type="int" line="93"/>
            <javadoc line="93">
                client-side connection handshake read timeout                
            </javadoc>
            <declaration name="responseTimeout" type="int" line="99"/>
            <javadoc line="99">
                client-side connection response read timeout (after handshake)                
            </javadoc>
            <declaration name="scheduler" type="ScheduledExecutorService" line="104"/>
            <javadoc line="104">
                thread pool for scheduling delayed tasks                
            </javadoc>
            <javadoc line="109">
                Create channel for endpoint.                
            </javadoc>
            <method name="TCPChannel" type="constructor" line="112">
                <params>
                    <param name="tr" type="TCPTransport"/>
                    <param name="ep" type="TCPEndpoint"/>
                </params>
            </method>
            <javadoc line="117">
                Return the endpoint for this channel.                
            </javadoc>
            <method name="getEndpoint" type="Endpoint" line="120"/>
            <javadoc line="124">
                Checks if the current caller has sufficient privilege to make
                  a connection to the remote endpoint.                
                <exception>
                    SecurityException if caller is not allowed to use this
                      Channel.                    
                </exception>
            </javadoc>
            <method name="checkConnectPermission" type="void" line="130">
                <comment line="137">
                    The security manager changed: flush the cache                    
                </comment>
                <comment line="146">
                    If ctx is the same context as last time, or if it
                     appears in the cache, bypass the checkConnect.                    
                </comment>
                <comment line="153">
                    A WeakHashMap is transformed into a SoftHashSet by making
                     each value softly refer to its own key (Peter&apos;s idea).                    
                </comment>
                <declaration name="security" type="SecurityManager" line="131"/>
                <scope line="135"/>
                <declaration name="ctx" type="AccessControlContext" line="143"/>
                <scope line="149"/>
            </method>
            <javadoc line="158">
                Supplies a connection to the endpoint of the address space
                  for which this is a channel.  The returned connection may
                  be one retrieved from a cache of idle connections.                
            </javadoc>
            <method name="newConnection" type="Connection" line="163">
                <comment line="167">
                    loop until we find a free live connection (in which case
                     we return) or until we run out of freelist (in which case
                     the loop exits)                    
                </comment>
                <comment line="172">
                    try to get a free connection                    
                </comment>
                <comment line="177">
                    If there is a security manager, make sure
                     the caller is allowed to connect to the
                     requested endpoint.                    
                </comment>
                <comment line="186">
                    at this point, conn is null iff the freelist is empty,
                     and nonnull if a free connection of uncertain vitality
                     has been found.                    
                </comment>
                <comment line="191">
                    check to see if the connection has closed since last use                    
                </comment>
                <comment line="197">
                    conn is dead, and cannot be reused (reuse =&gt; false)                    
                </comment>
                <comment line="202">
                    none free, so create a new connection                    
                </comment>
                <declaration name="conn" type="TCPConnection" line="164"/>
                <scope line="169">
                    <scope line="172">
                        <declaration name="elementPos" type="int" line="173"/>
                        <scope line="175"/>
                    </scope>
                    <scope line="189">
                        <scope line="191"/>
                    </scope>
                </scope>
            </method>
            <javadoc line="205">
                Create a new connection to the remote endpoint of this channel.
                  The returned connection is new.  The caller must already have
                  passed a security checkConnect or equivalent.                
            </javadoc>
            <method name="createConnection" type="Connection" line="210">
                <comment line="225">
                    choose protocol (single op if not reusable socket)                    
                </comment>
                <comment line="232">
                    Set socket read timeout to configured value for JRMP
                     connection handshake; this also serves to guard against
                     non-JRMP servers that do not respond (see 4322806).                    
                </comment>
                <comment line="242">
                    if we fail to set this, ignore and proceed anyway                    
                </comment>
                <comment line="263">
                    set local host name, if unknown                    
                </comment>
                <comment line="265">
                    do NOT set the default port, because we don&apos;t
                     know if we can&apos;t listen YET...                    
                </comment>
                <comment line="268">
                    write out default endpoint to match protocol
                     (but it serves no purpose)                    
                </comment>
                <comment line="279">
                    After JRMP handshake, set socket read timeout to value
                     configured for the rest of the lifetime of the
                     connection.  NOTE: this timeout, if configured to a
                     finite duration, places an upper bound on the time
                     that a remote method call is permitted to execute.                    
                </comment>
                <comment line="287">
                    If socket factory had set a non-zero timeout on its
                     own, then restore it instead of using the property-
                     configured value.                    
                </comment>
                <comment line="296">
                    if we fail to set this, ignore and proceed anyway                    
                </comment>
                <declaration name="conn" type="Connection" line="211"/>
                <scope line="215">
                    <declaration name="sock" type="Socket" line="216"/>
                    <scope line="219">
                        <declaration name="out" type="DataOutputStream" line="220"/>
                        <scope line="225"/>
                        <scope line="227">
                            <declaration name="originalSoTimeout" type="int" line="236"/>
                            <scope line="237"/>
                            <scope line="240"/>
                            <declaration name="in" type="DataInputStream" line="244"/>
                            <declaration name="ack" type="byte" line="246"/>
                            <scope line="247"/>
                            <declaration name="suggestedHost" type="String" line="254"/>
                            <declaration name="suggestedPort" type="int" line="255"/>
                            <scope line="256"/>
                            <declaration name="localEp" type="TCPEndpoint" line="269"/>
                            <scope line="273"/>
                            <scope line="285"/>
                            <scope line="294"/>
                        </scope>
                    </scope>
                    <scope line="300"/>
                </scope>
                <scope line="307">
                    <scope line="308"/>
                    <scope line="310">
                        <scope line="311"/>
                    </scope>
                </scope>
            </method>
            <javadoc line="323">
                Free the connection generated by this channel.                
                <param>
                    conn The connection                    
                </param>
                <param>
                    reuse If true, the connection is in a state in which it
                      can be reused for another method call.                    
                </param>
            </javadoc>
            <method name="free" type="void" line="329">
                <params>
                    <param name="conn" type="Connection"/>
                    <param name="reuse" type="boolean"/>
                </params>
                <comment line="339">
                    Cache connection; if reaper task for expired
                     connections isn&apos;t scheduled, then schedule it.                    
                </comment>
                <scope line="332">
                    <declaration name="lastuse" type="long" line="333"/>
                    <declaration name="tcpConnection" type="TCPConnection" line="334"/>
                    <scope line="342">
                        <scope line="344">
                            <anonymous_class line="348">
                                <method name="run" type="void" line="349"/>
                            </anonymous_class>
                        </scope>
                    </scope>
                </scope>
                <scope line="360">
                    <scope line="363"/>
                    <scope line="365"/>
                </scope>
            </method>
            <javadoc line="370">
                Send transport header over stream.                
            </javadoc>
            <method name="writeTransportHeader" type="void" line="375">
                <params>
                    <param name="out" type="DataOutputStream"/>
                </params>
                <comment line="378">
                    write out transport header                    
                </comment>
                <scope line="376">
                    <declaration name="dataOut" type="DataOutputStream" line="378"/>
                </scope>
                <scope line="382"/>
            </method>
            <javadoc line="388">
                Use given connection multiplexer object to obtain new connections
                  through this channel.                
            </javadoc>
            <method name="useMultiplexer" type="void" line="392">
                <params>
                    <param name="newMultiplexer" type="ConnectionMultiplexer"/>
                </params>
                <comment line="394">
                    for now, always just use the last one given                    
                </comment>
            </method>
            <javadoc line="399">
                Accept a connection provided over a multiplexed channel.                
            </javadoc>
            <method name="acceptMultiplexConnection" type="void" line="402">
                <params>
                    <param name="conn" type="Connection"/>
                </params>
                <scope line="403"/>
            </method>
            <javadoc line="410">
                Closes all the connections in the cache, whether timed out or not.                
            </javadoc>
            <method name="shedCache" type="void" line="413">
                <comment line="415">
                    Build a list of connections, to avoid holding the freeList
                     lock during (potentially long-running) close() calls.                    
                </comment>
                <comment line="423">
                    Close all the connections that were free                    
                </comment>
                <comment line="426">
                    help gc                    
                </comment>
                <comment line="430">
                    eat exception                    
                </comment>
                <declaration name="conn" type="Connection[]" line="416"/>
                <scope line="417"/>
                <scope line="423">
                    <declaration name="c" type="Connection" line="424"/>
                    <scope line="426"/>
                    <scope line="428"/>
                </scope>
            </method>
            <method name="freeCachedConnections" type="void" line="434">
                <comment line="436">
                    Remove each connection whose time out has expired.                    
                </comment>
                <comment line="455">
                    eat exception                    
                </comment>
                <scope line="438">
                    <declaration name="size" type="int" line="439"/>
                    <scope line="441">
                        <declaration name="time" type="long" line="442"/>
                        <declaration name="iter" type="ListIterator&lt;TCPConnection&gt;" line="443"/>
                        <scope line="445">
                            <declaration name="conn" type="TCPConnection" line="446"/>
                            <scope line="447">
                                <scope line="451"/>
                                <scope line="453"/>
                            </scope>
                        </scope>
                    </scope>
                    <scope line="461"/>
                </scope>
            </method>
        </class>
        <class name="ConnectionAcceptor" line="469">
            <implements interface="Runnable"/>
            <javadoc line="469">
                ConnectionAcceptor manages accepting new connections and giving them
                  to TCPTransport&apos;s message handler on new threads.
                  Since this object only needs to know which transport to give new
                  connections to, it doesn&apos;t need to be per-channel as currently
                  implemented.                
            </javadoc>
            <declaration name="transport" type="TCPTransport" line="479"/>
            <javadoc line="479">
                transport that will handle message on accepted connections                
            </javadoc>
            <declaration name="queue" type="List&lt;Connection&gt;" line="482"/>
            <javadoc line="482">
                queue of connections to be accepted                
            </javadoc>
            <declaration name="threadNum" type="int" line="485"/>
            <javadoc line="485">
                thread ID counter                
            </javadoc>
            <javadoc line="488">
                Create a new ConnectionAcceptor that will give connections
                  to the specified transport on a new thread.                
            </javadoc>
            <method name="ConnectionAcceptor" type="constructor" line="492">
                <params>
                    <param name="transport" type="TCPTransport"/>
                </params>
            </method>
            <javadoc line="496">
                Start a new thread to accept connections.                
            </javadoc>
            <method name="startNewAcceptor" type="void" line="499">
                <declaration name="t" type="Thread" line="500"/>
            </method>
            <javadoc line="507">
                Add connection to queue of connections to be accepted.                
            </javadoc>
            <method name="accept" type="void" line="510">
                <params>
                    <param name="conn" type="Connection"/>
                </params>
                <scope line="511"/>
            </method>
            <javadoc line="517">
                Give transport next accepted conection, when available.                
            </javadoc>
            <method name="run" type="void" line="520">
                <declaration name="conn" type="Connection" line="521"/>
                <scope line="523">
                    <scope line="524">
                        <scope line="525"/>
                        <scope line="527"/>
                    </scope>
                </scope>
            </method>
        </class>
    </source>