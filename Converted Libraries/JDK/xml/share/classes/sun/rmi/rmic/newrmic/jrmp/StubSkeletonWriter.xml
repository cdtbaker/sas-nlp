<?xml version="1.0" encoding="UTF-8"?>
    <source package="sun.rmi.rmic.newrmic.jrmp">
        <import package="com.sun.javadoc.ClassDoc"/>
        <import package="com.sun.javadoc.MethodDoc"/>
        <import package="com.sun.javadoc.Type"/>
        <import package="java.io.IOException"/>
        <import package="java.util.ArrayList"/>
        <import package="java.util.Iterator"/>
        <import package="java.util.List"/>
        <import package="sun.rmi.rmic.newrmic.BatchEnvironment"/>
        <import package="sun.rmi.rmic.newrmic.IndentingWriter"/>
        <import package="sun.rmi.rmic.newrmic.Constants"/>
        <import package="sun.rmi.rmic.newrmic.jrmp.Constants"/>
        <class name="StubSkeletonWriter" line="41">
            <comment line="63">
                binary names of the stub and skeleton classes to generate for
                 the remote class                
            </comment>
            <comment line="70">
                                
            </comment>
            <comment line="827">
                Following are a series of static utility methods useful during
                 the code generation process:                
            </comment>
            <javadoc line="41">
                Writes the source code for the stub class and (optionally) skeleton
                  class for a particular remote implementation class.
                  WARNING: The contents of this source file are not part of any
                  supported API.  Code that depends on them does so at its own risk:
                  they are subject to change or removal without notice.                
                <author>
                    Peter Jones                    
                </author>
            </javadoc>
            <declaration name="env" type="BatchEnvironment" line="53"/>
            <javadoc line="53">
                rmic environment for this object                
            </javadoc>
            <declaration name="remoteClass" type="RemoteClass" line="56"/>
            <javadoc line="56">
                the remote implemention class to generate code for                
            </javadoc>
            <declaration name="version" type="StubVersion" line="59"/>
            <javadoc line="59">
                version of the JRMP stub protocol to generate code for                
            </javadoc>
            <declaration name="stubClassName" type="String" line="66"/>
            <declaration name="skeletonClassName" type="String" line="67"/>
            <declaration name="packageName" type="String" line="70"/>
            <declaration name="stubClassSimpleName" type="String" line="71"/>
            <declaration name="skeletonClassSimpleName" type="String" line="72"/>
            <declaration name="remoteMethods" type="RemoteClass.Method[]" line="74"/>
            <javadoc line="74">
                remote methods of class, indexed by operation number                
            </javadoc>
            <declaration name="methodFieldNames" type="String[]" line="77"/>
            <javadoc line="77">
                Names to use for the java.lang.reflect.Method static fields in
                  the generated stub class corresponding to each remote method.                
            </javadoc>
            <javadoc line="83">
                Creates a StubSkeletonWriter instance for the specified remote
                  implementation class.  The generated code will implement the
                  specified JRMP stub protocol version.                
            </javadoc>
            <method name="StubSkeletonWriter" type="constructor" line="91">
                <params>
                    <param name="env" type="BatchEnvironment"/>
                    <param name="remoteClass" type="RemoteClass"/>
                    <param name="version" type="StubVersion"/>
                </params>
                <declaration name="i" type="int" line="100"/>
            </method>
            <javadoc line="109">
                Returns the binary name of the stub class to generate for the
                  remote implementation class.                
            </javadoc>
            <method name="stubClassName" type="String" line="113"/>
            <javadoc line="117">
                Returns the binary name of the skeleton class to generate for
                  the remote implementation class.                
            </javadoc>
            <method name="skeletonClassName" type="String" line="121"/>
            <javadoc line="125">
                Writes the stub class for the remote class to a stream.                
            </javadoc>
            <method name="writeStub" type="void" line="128">
                <params>
                    <param name="p" type="IndentingWriter"/>
                </params>
                <comment line="130">
                    Write boiler plate comment.                    
                </comment>
                <comment line="137">
                    If remote implementation class was in a particular package,
                     declare the stub class to be in the same package.                    
                </comment>
                <comment line="146">
                    Declare the stub class; implement all remote interfaces.                    
                </comment>
                <comment line="180">
                    We only need to declare and initialize the static fields of
                     Method objects for each remote method if there are any remote
                     methods; otherwise, skip this code entirely, to avoid generating
                     a trycatch block for a checked exception that cannot occur
                     (see bugid 4125181).                    
                </comment>
                <comment line="194">
                    Initialize java.lang.reflect.Method fields for each remote
                     method in a static initializer.                    
                </comment>
                <comment line="201">
                    Fat stubs must determine whether the API required for
                     the JDK 1.2 stub protocol is supported in the current
                     runtime, so that it can use it if supported.  This is
                     determined by using the Reflection API to test if the
                     new invoke method on RemoteRef exists, and setting the
                     static boolean &quot;useNewInvoke&quot; to true if it does, or
                     to false if a NoSuchMethodException is thrown.                    
                </comment>
                <comment line="229">
                    end try/catch block                    
                </comment>
                <comment line="230">
                    end static initializer                    
                </comment>
                <comment line="238">
                    Write each stub method.                    
                </comment>
                <comment line="249">
                    end stub class                    
                </comment>
                <scope line="141"/>
                <declaration name="remoteInterfaces" type="ClassDoc[]" line="151"/>
                <scope line="152">
                    <scope line="154">
                        <scope line="155"/>
                    </scope>
                </scope>
                <scope line="166"/>
                <scope line="175">
                    <scope line="187">
                        <scope line="188"/>
                        <scope line="200"/>
                        <scope line="222"/>
                        <scope line="224"/>
                    </scope>
                </scope>
                <scope line="241">
                    <scope line="243"/>
                </scope>
            </method>
            <javadoc line="252">
                Writes the constructors for the stub class.                
            </javadoc>
            <method name="writeStubConstructors" type="void" line="257">
                <params>
                    <param name="p" type="IndentingWriter"/>
                </params>
                <comment line="260">
                    Only stubs compatible with the JDK 1.1 stub protocol need
                     a no-arg constructor; later versions use reflection to find
                     the constructor that directly takes a RemoteRef argument.                    
                </comment>
                <scope line="267"/>
            </method>
            <javadoc line="278">
                Writes the stub method for the remote method with the given
                  operation number.                
            </javadoc>
            <method name="writeStubMethod" type="void" line="284">
                <params>
                    <param name="p" type="IndentingWriter"/>
                    <param name="opnum" type="int"/>
                </params>
                <comment line="293">
                    Declare stub method; throw exceptions declared in remote
                     interface(s).                    
                </comment>
                <comment line="319">
                    The RemoteRef.invoke methods throw Exception, but unless
                     this stub method throws Exception as well, we must catch
                     Exceptions thrown from the invocation.  So we must catch
                     Exception and rethrow something we can throw:
                     UnexpectedException, which is a subclass of
                     RemoteException.  But for any subclasses of Exception that
                     we can throw, like RemoteException, RuntimeException, and
                     any of the exceptions declared by this stub method, we want
                     them to pass through unmodified, so first we must catch any
                     such exceptions and rethrow them directly.
                    
                     We have to be careful generating the rethrowing catch
                     blocks here, because javac will flag an error if there are
                     any unreachable catch blocks, i.e. if the catch of an
                     exception class follows a previous catch of it or of one of
                     its superclasses.  The following method invocation takes
                     care of these details.                    
                </comment>
                <comment line="340">
                    If we need to catch any particular exceptions (i.e. this method
                     does not declare java.lang.Exception), put the entire stub
                     method in a try block.                    
                </comment>
                <comment line="356">
                    REMIND: why $?                    
                </comment>
                <comment line="401">
                    REMIND: why $?                    
                </comment>
                <comment line="410">
                    If any only if readObject has been invoked, we must catch
                     ClassNotFoundException as well as IOException.                    
                </comment>
                <comment line="426">
                    end if/else (useNewInvoke) block                    
                </comment>
                <comment line="429">
                    If we need to catch any particular exceptions, finally write
                     the catch blocks for them, rethrow any other Exceptions with an
                     UnexpectedException, and end the try block.                    
                </comment>
                <comment line="442">
                    end try/catch block                    
                </comment>
                <comment line="445">
                    end stub method                    
                </comment>
                <declaration name="method" type="RemoteClass.Method" line="285"/>
                <declaration name="methodDoc" type="MethodDoc" line="286"/>
                <declaration name="methodName" type="String" line="287"/>
                <declaration name="paramTypes" type="Type[]" line="288"/>
                <declaration name="paramNames" type="String" line="289"/>
                <declaration name="returnType" type="Type" line="290"/>
                <declaration name="exceptions" type="ClassDoc[]" line="291"/>
                <scope line="300">
                    <scope line="301"/>
                </scope>
                <scope line="307">
                    <scope line="309">
                        <scope line="310"/>
                    </scope>
                </scope>
                <declaration name="catchList" type="List&lt;ClassDoc&gt;" line="338"/>
                <scope line="345"/>
                <scope line="349"/>
                <scope line="354">
                    <scope line="355"/>
                    <scope line="359">
                        <scope line="361"/>
                    </scope>
                    <scope line="367"/>
                    <scope line="371"/>
                </scope>
                <scope line="376"/>
                <scope line="381">
                    <scope line="385"/>
                    <scope line="397"/>
                    <scope line="399">
                        <declaration name="objectRead" type="boolean" line="404"/>
                        <scope line="414"/>
                    </scope>
                </scope>
                <scope line="425"/>
                <scope line="434">
                    <scope line="435"/>
                </scope>
            </method>
            <javadoc line="448">
                Computes the exceptions that need to be caught and rethrown in
                  a stub method before wrapping Exceptions in
                  UnexpectedExceptions, given the exceptions declared in the
                  throws clause of the method.  Returns a list containing the
                  exception to catch.  Each exception is guaranteed to be unique,
                  i.e. not a subclass of any of the other exceptions in the list,
                  so the catch blocks for these exceptions may be generated in
                  any order relative to each other.
                  RemoteException and RuntimeException are each automatically
                  placed in the returned list (unless any of their superclasses
                  are already present), since those exceptions should always be
                  directly rethrown by a stub method.
                  The returned list will be empty if java.lang.Exception or one
                  of its superclasses is in the throws clause of the method,
                  indicating that no exceptions need to be caught.                
            </javadoc>
            <method name="computeUniqueCatchList" type="List<ClassDoc>" line="467">
                <params>
                    <param name="exceptions" type="ClassDoc[]"/>
                </params>
                <comment line="471">
                    always catch/rethrow these                    
                </comment>
                <comment line="473">
                                        
                </comment>
                <comment line="477">
                    If java.lang.Exception (or a superclass) was declared
                     in the throws clause of this stub method, then we don&apos;t
                     have to bother catching anything; clear the list and
                     return.                    
                </comment>
                <comment line="486">
                    Ignore other Throwables that do not extend Exception,
                     because they cannot be thrown by the invoke methods.                    
                </comment>
                <comment line="492">
                    Compare this exception against the current list of
                     exceptions that need to be caught:                    
                </comment>
                <comment line="499">
                    If a superclass of this exception is already on
                     the list to catch, then ignore this one and continue;                    
                </comment>
                <comment line="505">
                    If a subclass of this exception is on the list
                     to catch, then remove it;                    
                </comment>
                <comment line="512">
                                        
                </comment>
                <declaration name="uniqueList" type="List&lt;ClassDoc&gt;" line="468"/>
                <scope line="475">
                    <scope line="476"/>
                    <scope line="485"/>
                    <scope line="496">
                        <declaration name="ex2" type="ClassDoc" line="497"/>
                        <scope line="498"/>
                        <scope line="504"/>
                    </scope>
                </scope>
            </method>
            <javadoc line="518">
                Writes the skeleton for the remote class to a stream.                
            </javadoc>
            <method name="writeSkeleton" type="void" line="521">
                <params>
                    <param name="p" type="IndentingWriter"/>
                </params>
                <comment line="527">
                    Write boiler plate comment.                    
                </comment>
                <comment line="534">
                    If remote implementation class was in a particular package,
                     declare the skeleton class to be in the same package.                    
                </comment>
                <comment line="543">
                    Declare the skeleton class.                    
                </comment>
                <comment line="556">
                    Define the getOperations() method.                    
                </comment>
                <comment line="564">
                    Define the dispatch() method.                    
                </comment>
                <comment line="584">
                    Skeleton throws UnmarshalException if it does not recognize
                     the method hash; this is what UnicastServerRef.dispatch()
                     would do.                    
                </comment>
                <comment line="594">
                    Ignore the validation of the interface hash if the
                     operation number was negative, since it is really a
                     method hash instead.                    
                </comment>
                <comment line="608">
                    end if/else (opnum &lt; 0) block                    
                </comment>
                <comment line="612">
                    Cast remote object reference to the remote implementation
                     class, if it&apos;s not private.  We don&apos;t use the binary name
                     of the class like previous implementations did because that
                     would not compile with javac (since 1.4.1).  If the remote
                     implementation class is private, then we can&apos;t cast to it
                     like previous implementations did because that also would
                     not compile with javac-- so instead, we&apos;ll have to try to
                     cast to the remote interface for each remote method.                    
                </comment>
                <comment line="627">
                    Process call according to the operation number.                    
                </comment>
                <comment line="635">
                    Skeleton throws UnmarshalException if it does not recognize
                     the operation number; this is consistent with the case of an
                     unrecognized method hash.                    
                </comment>
                <comment line="642">
                    end switch statement                    
                </comment>
                <comment line="644">
                    end dispatch() method                    
                </comment>
                <comment line="646">
                    end skeleton class                    
                </comment>
                <scope line="522"/>
                <scope line="538"/>
                <scope line="572">
                    <scope line="574">
                        <scope line="575"/>
                    </scope>
                    <scope line="591"/>
                </scope>
                <scope line="607"/>
                <scope line="622"/>
                <scope line="631"/>
            </method>
            <javadoc line="649">
                Writes the case block for the skeleton&apos;s dispatch method for
                  the remote method with the given &quot;opnum&quot;.                
            </javadoc>
            <method name="writeSkeletonDispatchCase" type="void" line="655">
                <params>
                    <param name="p" type="IndentingWriter"/>
                    <param name="opnum" type="int"/>
                </params>
                <comment line="665">
                    Use nested block statement inside case to provide an independent
                     namespace for local variables used to unmarshal parameters for
                     this remote method.                    
                </comment>
                <comment line="673">
                    Declare local variables to hold arguments.                    
                </comment>
                <comment line="680">
                    Unmarshal arguments from call stream.                    
                </comment>
                <comment line="690">
                    If any only if readObject has been invoked, we must catch
                     ClassNotFoundException as well as IOException.                    
                </comment>
                <comment line="707">
                    Declare variable to hold return type, if not void.                    
                </comment>
                <comment line="711">
                    REMIND: why $?                    
                </comment>
                <comment line="714">
                    Invoke the method on the server object.  If the remote
                     implementation class is private, then we don&apos;t have a
                     reference cast to it, and so we try to cast to the remote
                     object reference to the method&apos;s declaring interface here.                    
                </comment>
                <comment line="731">
                    Always invoke getResultStream(true) on the call object to send
                     the indication of a successful invocation to the caller.  If
                     the return type is not void, keep the result stream and marshal
                     the return value.                    
                </comment>
                <comment line="751">
                    break from switch statement                    
                </comment>
                <comment line="753">
                    end nested block statement                    
                </comment>
                <declaration name="method" type="RemoteClass.Method" line="656"/>
                <declaration name="methodDoc" type="MethodDoc" line="657"/>
                <declaration name="methodName" type="String" line="658"/>
                <declaration name="paramTypes" type="Type" line="659"/>
                <declaration name="paramNames" type="String" line="660"/>
                <declaration name="returnType" type="Type" line="661"/>
                <scope line="672">
                    <scope line="676"/>
                    <declaration name="objectsRead" type="boolean" line="685"/>
                    <scope line="694"/>
                </scope>
                <scope line="702"/>
                <scope line="706"/>
                <declaration name="target" type="String" line="720"/>
                <scope line="724"/>
                <scope line="738"/>
                <scope line="742"/>
            </method>
            <javadoc line="757">
                Writes declaration and initializer for &quot;operations&quot; static array.                
            </javadoc>
            <method name="writeOperationsArray" type="void" line="762">
                <params>
                    <param name="p" type="IndentingWriter"/>
                </params>
                <scope line="764"/>
            </method>
            <javadoc line="774">
                Writes declaration and initializer for &quot;interfaceHash&quot; static field.                
            </javadoc>
            <method name="writeInterfaceHash" type="void" line="779">
                <params>
                    <param name="p" type="IndentingWriter"/>
                </params>
            </method>
            <javadoc line="784">
                Writes declaration for java.lang.reflect.Method static fields
                  corresponding to each remote method in a stub.                
            </javadoc>
            <method name="writeMethodFieldDeclarations" type="void" line="790">
                <params>
                    <param name="p" type="IndentingWriter"/>
                </params>
                <scope line="791"/>
            </method>
            <javadoc line="796">
                Writes code to initialize the static fields for each method
                  using the Java Reflection API.                
            </javadoc>
            <method name="writeMethodFieldInitializers" type="void" line="802">
                <params>
                    <param name="p" type="IndentingWriter"/>
                </params>
                <comment line="805">
                    Look up the Method object in the somewhat arbitrary
                     interface that we find in the Method object.                    
                </comment>
                <scope line="803">
                    <declaration name="method" type="RemoteClass.Method" line="809"/>
                    <declaration name="methodDoc" type="MethodDoc" line="810"/>
                    <declaration name="methodName" type="String" line="811"/>
                    <declaration name="paramTypes" type="Type" line="812"/>
                    <scope line="816"/>
                </scope>
            </method>
            <javadoc line="831">
                Generates an array of names for fields correspondins to the
                  given array of remote methods.  Each name in the returned array
                  is guaranteed to be unique.
                  The name of a method is included in its corresponding field
                  name to enhance readability of the generated code.                
            </javadoc>
            <method name="nameMethodFields" type="String[]" line="839">
                <params>
                    <param name="methods" type="RemoteClass.Method[]"/>
                </params>
                <declaration name="names" type="String[]" line="840"/>
                <scope line="841"/>
            </method>
            <javadoc line="847">
                Generates an array of names for parameters corresponding to the
                  given array of types for the parameters.  Each name in the
                  returned array is guaranteed to be unique.
                  A representation of the type of a parameter is included in its
                  corresponding parameter name to enhance the readability of the
                  generated code.                
            </javadoc>
            <method name="nameParameters" type="String[]" line="856">
                <params>
                    <param name="types" type="Type[]"/>
                </params>
                <declaration name="names" type="String[]" line="857"/>
                <scope line="858"/>
            </method>
            <javadoc line="865">
                Generates a readable string representing the given type
                  suitable for embedding within a Java identifier.                
            </javadoc>
            <method name="generateNameFromType" type="String" line="869">
                <params>
                    <param name="type" type="Type"/>
                </params>
                <declaration name="name" type="String" line="870"/>
                <declaration name="dimensions" type="int" line="871"/>
                <scope line="872"/>
            </method>
            <javadoc line="878">
                Writes a snippet of Java code to marshal a value named &quot;name&quot;
                  of type &quot;type&quot; to the java.io.ObjectOutput stream named
                  &quot;stream&quot;.
                  Primitive types are marshalled with their corresponding methods
                  in the java.io.DataOutput interface, and objects (including
                  arrays) are marshalled using the writeObject method.                
            </javadoc>
            <method name="writeMarshalArgument" type="void" line="891">
                <params>
                    <param name="p" type="IndentingWriter"/>
                    <param name="streamName" type="String"/>
                    <param name="type" type="Type"/>
                    <param name="name" type="String"/>
                </params>
                <scope line="892"/>
                <scope line="894"/>
                <scope line="896"/>
                <scope line="898"/>
                <scope line="900"/>
                <scope line="902"/>
                <scope line="904"/>
                <scope line="906"/>
                <scope line="908"/>
                <scope line="910"/>
            </method>
            <javadoc line="915">
                Writes Java statements to marshal a series of values in order
                  as named in the &quot;names&quot; array, with types as specified in the
                  &quot;types&quot; array, to the java.io.ObjectOutput stream named
                  &quot;stream&quot;.                
            </javadoc>
            <method name="writeMarshalArguments" type="void" line="925">
                <params>
                    <param name="p" type="IndentingWriter"/>
                    <param name="streamName" type="String"/>
                    <param name="types" type="Type[]"/>
                    <param name="names" type="String[]"/>
                </params>
                <scope line="928"/>
            </method>
            <javadoc line="934">
                Writes a snippet of Java code to unmarshal a value of type
                  &quot;type&quot; from the java.io.ObjectInput stream named &quot;stream&quot; into
                  a variable named &quot;name&quot; (if &quot;name&quot; is null, the value is
                  unmarshalled and discarded).
                  Primitive types are unmarshalled with their corresponding
                  methods in the java.io.DataInput interface, and objects
                  (including arrays) are unmarshalled using the readObject
                  method.
                  Returns true if code to invoke readObject was written, and
                  false otherwise.                
            </javadoc>
            <method name="writeUnmarshalArgument" type="boolean" line="952">
                <params>
                    <param name="p" type="IndentingWriter"/>
                    <param name="streamName" type="String"/>
                    <param name="type" type="Type"/>
                    <param name="name" type="String"/>
                </params>
                <declaration name="readObject" type="boolean" line="953"/>
                <scope line="955"/>
                <scope line="959"/>
                <scope line="962"/>
                <scope line="964"/>
                <scope line="966"/>
                <scope line="968"/>
                <scope line="970"/>
                <scope line="972"/>
                <scope line="974"/>
                <scope line="976"/>
                <scope line="978"/>
            </method>
            <javadoc line="985">
                Writes Java statements to unmarshal a series of values in order
                  of types as in the &quot;types&quot; array from the java.io.ObjectInput
                  stream named &quot;stream&quot; into variables as named in &quot;names&quot; (for
                  any element of &quot;names&quot; that is null, the corresponding value is
                  unmarshalled and discarded).                
            </javadoc>
            <method name="writeUnmarshalArguments" type="boolean" line="997">
                <params>
                    <param name="p" type="IndentingWriter"/>
                    <param name="streamName" type="String"/>
                    <param name="types" type="Type[]"/>
                    <param name="names" type="String[]"/>
                </params>
                <declaration name="readObject" type="boolean" line="1000"/>
                <scope line="1001">
                    <scope line="1002"/>
                </scope>
            </method>
            <javadoc line="1010">
                Returns a snippet of Java code to wrap a value named &quot;name&quot; of
                  type &quot;type&quot; into an object as appropriate for use by the Java
                  Reflection API.
                  For primitive types, an appropriate wrapper class is
                  instantiated with the primitive value.  For object types
                  (including arrays), no wrapping is necessary, so the value is
                  named directly.                
            </javadoc>
            <method name="wrapArgumentCode" type="String" line="1020">
                <params>
                    <param name="type" type="Type"/>
                    <param name="name" type="String"/>
                </params>
                <scope line="1021"/>
                <scope line="1023"/>
                <scope line="1026"/>
                <scope line="1028"/>
                <scope line="1030"/>
                <scope line="1032"/>
                <scope line="1034"/>
                <scope line="1036"/>
                <scope line="1038"/>
                <scope line="1040"/>
            </method>
            <javadoc line="1045">
                Returns a snippet of Java code to unwrap a value named &quot;name&quot;
                  into a value of type &quot;type&quot;, as appropriate for the Java
                  Reflection API.
                  For primitive types, the value is assumed to be of the
                  corresponding wrapper class, and a method is called on the
                  wrapper to retrieve the primitive value.  For object types
                  (include arrays), no unwrapping is necessary; the value is
                  simply cast to the expected real object type.                
            </javadoc>
            <method name="unwrapArgumentCode" type="String" line="1056">
                <params>
                    <param name="type" type="Type"/>
                    <param name="name" type="String"/>
                </params>
                <scope line="1057"/>
                <scope line="1059"/>
                <scope line="1061"/>
                <scope line="1063"/>
                <scope line="1065"/>
                <scope line="1067"/>
                <scope line="1069"/>
                <scope line="1071"/>
                <scope line="1073"/>
                <scope line="1075"/>
            </method>
        </class>
    </source>