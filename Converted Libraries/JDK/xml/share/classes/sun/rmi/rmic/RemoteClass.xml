<?xml version="1.0" encoding="UTF-8"?>
    <source package="sun.rmi.rmic">
        <import package="java.util.Vector"/>
        <import package="java.util.Hashtable"/>
        <import package="java.util.Enumeration"/>
        <import package="java.io.IOException"/>
        <import package="java.io.ByteArrayOutputStream"/>
        <import package="java.io.DataOutputStream"/>
        <import package="java.security.MessageDigest"/>
        <import package="java.security.DigestOutputStream"/>
        <import package="java.security.NoSuchAlgorithmException"/>
        <import package="sun.tools.java.Type"/>
        <import package="sun.tools.java.ClassDefinition"/>
        <import package="sun.tools.java.ClassDeclaration"/>
        <import package="sun.tools.java.MemberDefinition"/>
        <import package="sun.tools.java.Identifier"/>
        <import package="sun.tools.java.ClassNotFound"/>
        <class name="RemoteClass" line="44">
            <implements interface="sun.rmi.rmic.RMIConstants"/>
            <javadoc line="44">
                A RemoteClass object encapsulates RMI-specific information about
                  a remote implementation class, i.e. a class that implements
                  one or more remote interfaces.
                  WARNING: The contents of this source file are not part of any
                  supported API.  Code that depends on them does so at its own risk:
                  they are subject to change or removal without notice.                
                <author>
                    Peter Jones                    
                </author>
            </javadoc>
            <javadoc line="57">
                Create a RemoteClass object representing the remote meta-information
                  of the given class.
                  Returns true if successful.  If the class is not a properly formed
                  remote implementation class or if some other error occurs, the
                  return value will be null, and errors will have been reported to
                  the supplied BatchEnvironment.                
            </javadoc>
            <method name="forClass" type="RemoteClass" line="68">
                <params>
                    <param name="env" type="BatchEnvironment"/>
                    <param name="implClassDef" type="ClassDefinition"/>
                </params>
                <declaration name="rc" type="RemoteClass" line="69"/>
                <scope line="70"/>
                <scope line="72"/>
            </method>
            <javadoc line="77">
                Return the ClassDefinition for this class.                
            </javadoc>
            <method name="getClassDefinition" type="ClassDefinition" line="80"/>
            <javadoc line="84">
                Return the name of the class represented by this object.                
            </javadoc>
            <method name="getName" type="Identifier" line="87"/>
            <javadoc line="91">
                Return an array of ClassDefinitions representing all of the remote
                  interfaces implemented by this class.
                  A remote interface is any interface that extends Remote,
                  directly or indirectly.  The remote interfaces of a class
                  are the interfaces directly listed in either the class&apos;s
                  &quot;implements&quot; clause, or the &quot;implements&quot; clause of any
                  of its superclasses, that are remote interfaces.
                  The order of the array returned is arbitrary, and some elements
                  may be superfluous (i.e., superinterfaces of other interfaces
                  in the array).                
            </javadoc>
            <method name="getRemoteInterfaces" type="ClassDefinition[]" line="105"/>
            <javadoc line="109">
                Return an array of RemoteClass.Method objects representing all of
                  the remote methods implemented by this class, i.e. all of the
                  methods in the class&apos;s remote interfaces.
                  The methods in the array are ordered according to the comparision
                  of the strings consisting of their method name followed by their
                  type signature, so each method&apos;s index in the array corresponds
                  to its &quot;operation number&quot; in the JDK 1.1 version of the
                  stub/skeleton protocol.                
            </javadoc>
            <method name="getRemoteMethods" type="Method[]" line="120"/>
            <javadoc line="124">
                Return the &quot;interface hash&quot; used to match a stub/skeleton pair for
                  this class in the JDK 1.1 version of the stub/skeleton protocol.                
            </javadoc>
            <method name="getInterfaceHash" type="long" line="128"/>
            <javadoc line="132">
                Return string representation of this object, consisting of
                  the string &quot;remote class &quot; followed by the class name.                
            </javadoc>
            <method name="toString" type="String" line="136"/>
            <declaration name="env" type="BatchEnvironment" line="140"/>
            <javadoc line="140">
                rmic environment for this object                
            </javadoc>
            <declaration name="implClassDef" type="ClassDefinition" line="143"/>
            <javadoc line="143">
                the remote implementation class this object corresponds to                
            </javadoc>
            <declaration name="remoteInterfaces" type="ClassDefinition[]" line="146"/>
            <javadoc line="146">
                remote interfaces implemented by this class                
            </javadoc>
            <declaration name="remoteMethods" type="Method[]" line="149"/>
            <javadoc line="149">
                all the remote methods of this class                
            </javadoc>
            <declaration name="interfaceHash" type="long" line="152"/>
            <javadoc line="152">
                stub/skeleton &quot;interface hash&quot; for this class                
            </javadoc>
            <declaration name="defRemote" type="ClassDefinition" line="155"/>
            <javadoc line="155">
                cached definition for certain classes used in this environment                
            </javadoc>
            <declaration name="defException" type="ClassDefinition" line="157"/>
            <declaration name="defRemoteException" type="ClassDefinition" line="158"/>
            <javadoc line="160">
                Create a RemoteClass instance for the given class.  The resulting
                  object is not yet initialized.                
            </javadoc>
            <method name="RemoteClass" type="constructor" line="164">
                <params>
                    <param name="env" type="BatchEnvironment"/>
                    <param name="implClassDef" type="ClassDefinition"/>
                </params>
            </method>
            <javadoc line="169">
                Validate that the remote implementation class is properly formed
                  and fill in the data structures required by the public interface.                
            </javadoc>
            <method name="initialize" type="boolean" line="173">
                <comment line="174">
                    Verify that the &quot;impl&quot; is really a class, not an interface.                    
                </comment>
                <comment line="183">
                    Initialize cached definitions for the Remote interface and
                     the RemoteException class.                    
                </comment>
                <comment line="201">
                    Here we find all of the remote interfaces of our remote
                     implementation class.  For each class up the superclass
                     chain, add each directly-implemented interface that
                     somehow extends Remote to a list.                    
                </comment>
                <comment line="207">
                    list of remote interfaces found                    
                </comment>
                <comment line="217">
                    Add interface to the list if it extends Remote and
                     it is not already there.                    
                </comment>
                <comment line="225">
                                        
                </comment>
                <comment line="229">
                                        
                </comment>
                <comment line="234">
                    Verify that the candidate remote implementation class
                     implements at least one remote interface directly.                    
                </comment>
                <comment line="242">
                    This error message is used if the class does
                     implement a remote interface through one of
                     its superclasses, but not directly.                    
                </comment>
                <comment line="250">
                    This error message is used if the class never
                     implements a remote interface.                    
                </comment>
                <comment line="260">
                    Get definition for next superclass.                    
                </comment>
                <comment line="273">
                    The &quot;remotesImplemented&quot; vector now contains all of the remote
                     interfaces directly implemented by the remote class or by any
                     of its superclasses.
                    
                     At this point, we could optimize the list by removing superfluous
                     entries, i.e. any interfaces that are implemented by some other
                     interface in the list anyway.
                    
                     This should be correct; would it be worthwhile?
                    
                          for (int i = 0; i &lt; remotesImplemented.size();) {
                              ClassDefinition interfaceDef =
                                  (ClassDefinition) remotesImplemented.elementAt(i);
                              boolean isOtherwiseImplemented = false;
                              for (int j = 0; j &lt; remotesImplemented.size; j++) {
                                  if (j != i &amp;&amp;
                                      interfaceDef.implementedBy(env, (ClassDefinition)
                                      remotesImplemented.elementAt(j).
                                          getClassDeclaration()))
                                  {
                                      isOtherwiseImplemented = true;
                                      break;
                                  }
                              }
                              if (isOtherwiseImplemented) {
                                  remotesImplemented.removeElementAt(i);
                              } else {
                                  ++i;
                              }
                          }                    
                </comment>
                <comment line="306">
                    Now we collect the methods from all of the remote interfaces
                     into a hashtable.                    
                </comment>
                <comment line="323">
                    Convert vector of remote interfaces to an array
                     (order is not important for this array).                    
                </comment>
                <comment line="330">
                    Sort table of remote methods into an array.  The elements are
                     sorted in ascending order of the string of the method&apos;s name
                     and type signature, so that each elements index is equal to
                     its operation number of the JDK 1.1 version of the stubskeleton
                     protocol.                    
                </comment>
                <comment line="357">
                                        
                </comment>
                <comment line="372">
                                        
                </comment>
                <comment line="375">
                    Finally, pre-compute the interface hash to be used by
                     stubsskeletons for this remote class.                    
                </comment>
                <scope line="177"/>
                <scope line="187"/>
                <scope line="196"/>
                <declaration name="remotesImplemented" type="Vector&lt;ClassDefinition&gt;" line="207"/>
                <scope line="211">
                    <scope line="212">
                        <declaration name="interfaces" type="ClassDeclaration[]" line="213"/>
                        <scope line="214">
                            <declaration name="interfaceDef" type="ClassDefinition" line="215"/>
                            <scope line="223">
                                <scope line="226"/>
                            </scope>
                        </scope>
                        <scope line="238">
                            <scope line="241"/>
                            <scope line="249"/>
                        </scope>
                    </scope>
                    <scope line="267"/>
                </scope>
                <declaration name="methods" type="Hashtable&lt;String,Method&gt;" line="310"/>
                <declaration name="errors" type="boolean" line="311"/>
                <scope line="315">
                    <declaration name="interfaceDef" type="ClassDefinition" line="316"/>
                </scope>
                <declaration name="orderedKeys" type="String[]" line="337"/>
                <declaration name="count" type="int" line="338"/>
                <scope line="341">
                    <declaration name="m" type="Method" line="342"/>
                    <declaration name="key" type="String" line="343"/>
                    <declaration name="i" type="int" line="344"/>
                    <scope line="345">
                        <scope line="346"/>
                    </scope>
                </scope>
                <scope line="355">
                    <scope line="358">
                        <declaration name="exceptions" type="ClassDeclaration[]" line="361"/>
                        <scope line="365"/>
                    </scope>
                </scope>
            </method>
            <javadoc line="384">
                Collect and validate all methods from given interface and all of
                  its superinterfaces as remote methods.  Remote methods are added
                  to the supplied hashtable.  Returns true if successful,
                  or false if an error occurred.                
            </javadoc>
            <method name="collectRemoteMethods" type="boolean" line="392">
                <params>
                    <param name="interfaceDef" type="ClassDefinition"/>
                    <param name="table" type="Hashtable<String,Method>"/>
                </params>
                <comment line="398">
                    rmic used to enforce that a remote interface could not extend
                     a non-remote interface, i.e. an interface that did not itself
                     extend from Remote.  The current version of rmic does not have
                     this restriction, so the following code is now commented out.
                    
                     Verify that this interface extends Remote, since all interfaces
                     extended by a remote interface must implement Remote.
                    
                          try {
                              if (!defRemote.implementedBy(env,
                                  interfaceDef.getClassDeclaration()))
                              {
                                  env.error(0, &quot;rmic.can.mix.remote.nonremote&quot;,
                                      interfaceDef.getName());
                                  return false;
                              }
                          } catch (ClassNotFound e) {
                              env.error(0, &quot;class.not.found&quot;, e.name,
                                  interfaceDef.getName());
                              return false;
                          }                    
                </comment>
                <comment line="424">
                    Search interface&apos;s members for methods.                    
                </comment>
                <comment line="435">
                    Verify that each method throws RemoteException.                    
                </comment>
                <comment line="441">
                    rmic used to enforce that a remote method had to
                     explicitly list RemoteException in its &quot;throws&quot;
                     clause; i.e., just throwing Exception was not
                     acceptable.  The current version of rmic does not
                     have this restriction, so the following code is
                     now commented out.  Instead, the method is
                     considered valid if RemoteException is a subclass
                     of any of the methods declared exceptions.
                    
                      if (exceptions[i].getName().equals(
                          idRemoteException))
                      {
                          hasRemoteException = true;
                          break;
                      }                    
                </comment>
                <comment line="471">
                    If this method did not throw RemoteException as required,
                     generate the error but continue, so that multiple such
                     errors can be reported.                    
                </comment>
                <comment line="483">
                    Verify that the implementation of this method throws only
                     java.lang.Exception or its subclasses (fix bugid 4092486).
                     JRMP does not support remote methods throwing
                     java.lang.Throwable or other subclasses.                    
                </comment>
                <comment line="492">
                    should not be null                    
                </comment>
                <comment line="512">
                    Create RemoteClass.Method object to represent this method
                     found in a remote interface.                    
                </comment>
                <comment line="517">
                    Store remote method&apos;s representation in the table of
                     remote methods found, keyed by its name and parameter
                     signature.
                    
                     If the table already contains an entry with the same
                     method name and parameter signature, then we must
                     replace the old entry with a Method object that
                     represents a legal combination of the old and the new
                     methods; specifically, the combined method must have
                     a throws list that contains (only) all of the checked
                     exceptions that can be thrown by both the old or
                     the new method (see bugid 4070653).                    
                </comment>
                <comment line="544">
                    Recursively collect methods for all superinterfaces.                    
                </comment>
                <scope line="393"/>
                <declaration name="errors" type="boolean" line="422"/>
                <scope line="431">
                    <scope line="434">
                        <declaration name="exceptions" type="ClassDeclaration[]" line="438"/>
                        <declaration name="hasRemoteException" type="boolean" line="439"/>
                        <scope line="440">
                            <scope line="458">
                                <scope line="461"/>
                            </scope>
                            <scope line="465"/>
                        </scope>
                        <scope line="476"/>
                        <scope line="489">
                            <declaration name="implMethod" type="MemberDefinition" line="490"/>
                            <scope line="492">
                                <scope line="494">
                                    <scope line="497"/>
                                </scope>
                            </scope>
                        </scope>
                        <scope line="506"/>
                        <declaration name="newMethod" type="Method" line="516"/>
                        <declaration name="key" type="String" line="531"/>
                        <declaration name="oldMethod" type="Method" line="532"/>
                        <scope line="533">
                            <scope line="535"/>
                        </scope>
                    </scope>
                </scope>
                <scope line="547">
                    <declaration name="superDefs" type="ClassDeclaration[]" line="548"/>
                    <scope line="549">
                        <declaration name="superDef" type="ClassDefinition" line="550"/>
                    </scope>
                </scope>
                <scope line="555"/>
            </method>
            <javadoc line="563">
                Compute the &quot;interface hash&quot; of the stub/skeleton pair for this
                  remote implementation class.  This is the 64-bit value used to
                  enforce compatibility between a stub and a skeleton using the
                  JDK 1.1 version of the stub/skeleton protocol.
                  It is calculated using the first 64 bits of a SHA digest.  The
                  digest is from a stream consisting of the following data:
                  (int) stub version number, always 1
                  for each remote method, in order of operation number:
                  (UTF) method name
                  (UTF) method type signature
                  for each declared exception, in alphabetical name order:
                  (UTF) name of exception class                
            </javadoc>
            <method name="computeInterfaceHash" type="long" line="579">
                <comment line="594">
                    type signatures already use mangled class names                    
                </comment>
                <comment line="606">
                    use only the first 64 bits of the digest for the hash                    
                </comment>
                <declaration name="hash" type="long" line="580"/>
                <declaration name="sink" type="ByteArrayOutputStream" line="581"/>
                <scope line="582">
                    <declaration name="md" type="MessageDigest" line="583"/>
                    <declaration name="out" type="DataOutputStream" line="584"/>
                    <scope line="588">
                        <declaration name="m" type="MemberDefinition" line="589"/>
                        <declaration name="name" type="Identifier" line="590"/>
                        <declaration name="type" type="Type" line="591"/>
                        <declaration name="exceptions" type="ClassDeclaration" line="597"/>
                        <scope line="599"/>
                    </scope>
                    <declaration name="hashArray" type="byte" line="607"/>
                    <scope line="608"/>
                </scope>
                <scope line="611"/>
                <scope line="614"/>
            </method>
            <javadoc line="622">
                Sort array of class declarations alphabetically by their mangled
                  fully-qualfied class name.  This is used to feed a method&apos;s exceptions
                  in a canonical order into the digest stream for the interface hash
                  computation.                
            </javadoc>
            <method name="sortClassDeclarations" type="void" line="628">
                <params>
                    <param name="decl" type="ClassDeclaration[]"/>
                </params>
                <scope line="629">
                    <declaration name="curr" type="ClassDeclaration" line="630"/>
                    <declaration name="name" type="String" line="631"/>
                    <declaration name="j" type="int" line="632"/>
                    <scope line="633">
                        <scope line="636"/>
                    </scope>
                </scope>
            </method>
            <class name="Method" line="646">
                <implements interface="Cloneable"/>
                <javadoc line="646">
                    A RemoteClass.Method object encapsulates RMI-specific information
                      about a particular remote method in the remote implementation class
                      represented by the outer instance.                    
                </javadoc>
                <javadoc line="653">
                    Return the definition of the actual class member corresponing
                      to this method of a remote interface.
                      REMIND: Can this method be removed?                    
                </javadoc>
                <method name="getMemberDefinition" type="MemberDefinition" line="659"/>
                <javadoc line="663">
                    Return the name of this method.                    
                </javadoc>
                <method name="getName" type="Identifier" line="666"/>
                <javadoc line="670">
                    Return the type of this method.                    
                </javadoc>
                <method name="getType" type="Type" line="673"/>
                <javadoc line="677">
                    Return an array of the exception classes declared to be
                      thrown by this remote method.
                      For methods with the same name and type signature inherited
                      from multiple remote interfaces, the array will contain
                      the set of exceptions declared in all of the interfaces&apos;
                      methods that can be legally thrown in each of them.                    
                </javadoc>
                <method name="getExceptions" type="ClassDeclaration[]" line="686"/>
                <javadoc line="690">
                    Return the &quot;method hash&quot; used to identify this remote method
                      in the JDK 1.2 version of the stub protocol.                    
                </javadoc>
                <method name="getMethodHash" type="long" line="694"/>
                <javadoc line="698">
                    Return the string representation of this method.                    
                </javadoc>
                <method name="toString" type="String" line="701"/>
                <javadoc line="705">
                    Return the string representation of this method appropriate
                      for the construction of a java.rmi.server.Operation object.                    
                </javadoc>
                <method name="getOperationString" type="String" line="709"/>
                <javadoc line="713">
                    Return a string consisting of this method&apos;s name followed by
                      its method descriptor, using the Java VM&apos;s notation for
                      method descriptors (see section 4.3.3 of The Java Virtual
                      Machine Specification).                    
                </javadoc>
                <method name="getNameAndDescriptor" type="String" line="719"/>
                <declaration name="memberDef" type="MemberDefinition" line="724"/>
                <javadoc line="724">
                    Member definition for this method, from one of the remote
                      interfaces that this method was found in.
                      Note that this member definition may be only one of several
                      member defintions that correspond to this remote method object,
                      if several of this class&apos;s remote interfaces contain methods
                      with the same name and type signature.  Therefore, this member
                      definition may declare more exceptions thrown that this remote
                      method does.                    
                </javadoc>
                <declaration name="methodHash" type="long" line="737"/>
                <javadoc line="737">
                    stub &quot;method hash&quot; to identify this method                    
                </javadoc>
                <declaration name="exceptions" type="ClassDeclaration[]" line="740"/>
                <javadoc line="740">
                    Exceptions declared to be thrown by this remote method.
                      This list can include superfluous entries, such as
                      unchecked exceptions and subclasses of other entries.                    
                </javadoc>
                <javadoc line="748">
                    Create a new Method object corresponding to the given
                      method definition.                    
                </javadoc>
                <method name="Method" type="constructor" line="757">
                    <params>
                        <param name="memberDef" type="MemberDefinition"/>
                    </params>
                    <comment line="752">
                        Temporarily comment out the private modifier until
                         the VM allows outer class to access inner class&apos;s
                         private constructor                        
                    </comment>
                    <comment line="757">
                                                
                    </comment>
                </method>
                <javadoc line="763">
                    Cloning is supported by returning a shallow copy of this object.                    
                </javadoc>
                <method name="clone" type="Object" line="766">
                    <scope line="767"/>
                    <scope line="769"/>
                </method>
                <javadoc line="774">
                    Return a new Method object that is a legal combination of
                      this method object and another one.
                      This requires determining the exceptions declared by the
                      combined method, which must be (only) all of the exceptions
                      declared in both old Methods that may thrown in either of
                      them.                    
                </javadoc>
                <method name="mergeWith" type="Method" line="783">
                    <params>
                        <param name="other" type="Method"/>
                    </params>
                    <scope line="786"/>
                    <declaration name="legalExceptions" type="Vector&lt;ClassDeclaration&gt;" line="792"/>
                    <scope line="794"/>
                    <scope line="799"/>
                    <declaration name="merged" type="Method" line="805"/>
                </method>
                <javadoc line="812">
                    Add to the supplied list all exceptions in the &quot;from&quot; array
                      that are subclasses of an exception in the &quot;with&quot; array.                    
                </javadoc>
                <method name="collectCompatibleExceptions" type="void" line="820">
                    <params>
                        <param name="from" type="ClassDeclaration[]"/>
                        <param name="with" type="ClassDeclaration[]"/>
                        <param name="list" type="Vector<ClassDeclaration>"/>
                    </params>
                    <scope line="821">
                        <declaration name="exceptionDef" type="ClassDefinition" line="822"/>
                        <scope line="823">
                            <scope line="824">
                                <scope line="825"/>
                            </scope>
                        </scope>
                    </scope>
                </method>
                <javadoc line="834">
                    Compute the &quot;method hash&quot; of this remote method.  The method
                      hash is a long containing the first 64 bits of the SHA digest
                      from the UTF encoded string of the method name and descriptor.
                      REMIND: Should this method share implementation code with
                      the outer class&apos;s computeInterfaceHash() method?                    
                </javadoc>
                <method name="computeMethodHash" type="long" line="842">
                    <comment line="851">
                                                
                    </comment>
                    <comment line="856">
                                                
                    </comment>
                    <comment line="859">
                        use only the first 64 bits of the digest for the hash                        
                    </comment>
                    <declaration name="hash" type="long" line="843"/>
                    <declaration name="sink" type="ByteArrayOutputStream" line="844"/>
                    <scope line="845">
                        <declaration name="md" type="MessageDigest" line="846"/>
                        <declaration name="out" type="DataOutputStream" line="847"/>
                        <declaration name="methodString" type="String" line="850"/>
                        <scope line="852"/>
                        <declaration name="hashArray" type="byte" line="861"/>
                        <scope line="862"/>
                    </scope>
                    <scope line="865"/>
                    <scope line="868"/>
                </method>
            </class>
        </class>
    </source>