<?xml version="1.0" encoding="UTF-8"?>
    <source package="
 */
package sun.rmi.rmic">
        <import package="java.io.File"/>
        <import package="java.io.FileOutputStream"/>
        <import package="java.io.OutputStreamWriter"/>
        <import package="java.io.IOException"/>
        <import package="java.util.Enumeration"/>
        <import package="java.util.Hashtable"/>
        <import package="java.util.Vector"/>
        <import package="sun.tools.java.Type"/>
        <import package="sun.tools.java.Identifier"/>
        <import package="sun.tools.java.ClassDefinition"/>
        <import package="sun.tools.java.ClassDeclaration"/>
        <import package="sun.tools.java.ClassNotFound"/>
        <import package="sun.tools.java.ClassFile"/>
        <import package="sun.tools.java.MemberDefinition"/>
        <import package="com.sun.corba.se.impl.util.Utility"/>
        <javadoc line="31">
                        
        </javadoc>
        <class name="RMIGenerator" line="51">
            <comment line="1014">
                Following are a series of static utility methods useful during
                 the code generation process:                
            </comment>
            <implements interface="RMIConstants"/>
            <implements interface="Generator"/>
            <javadoc line="51">
                A Generator object will generate the Java source code of the stub
                  and skeleton classes for an RMI remote implementation class, using
                  a particular stub protocol version.
                  WARNING: The contents of this source file are not part of any
                  supported API.  Code that depends on them does so at its own risk:
                  they are subject to change or removal without notice.                
                <author>
                    Peter Jones,  Bryan Atsatt                    
                </author>
            </javadoc>
            <declaration name="versionOptions" type="Hashtable" line="64"/>
            <scope line="65"/>
            <javadoc line="71">
                Default constructor for Main to use.                
            </javadoc>
            <method name="RMIGenerator" type="constructor" line="74">
                <comment line="75">
                    default is -v1.2 (see 4638155)                    
                </comment>
            </method>
            <javadoc line="78">
                Examine and consume command line arguments.                
                <param>
                    argv The command line arguments. Ignore null
                      and unknown arguments. Set each consumed argument to null.                    
                </param>
                <param>
                    error Report any errors using the main.error() methods.                    
                </param>
                <return>
                    true if no errors, false otherwise.                    
                </return>
            </javadoc>
            <method name="parseArgs" type="boolean" line="85">
                <params>
                    <param name="argv" type="String"/>
                    <param name="main" type="Main"/>
                </params>
                <declaration name="explicitVersion" type="String" line="86"/>
                <scope line="87">
                    <scope line="88">
                        <declaration name="arg" type="String" line="89"/>
                        <scope line="90">
                            <scope line="93"/>
                        </scope>
                    </scope>
                </scope>
            </method>
            <javadoc line="107">
                Generate the source files for the stub and/or skeleton classes
                  needed by RMI for the given remote implementation class.                
                <param>
                    env       compiler environment                    
                </param>
                <param>
                    cdef      definition of remote implementation class
                      to generate stubs and/or skeletons for                    
                </param>
                <param>
                    destDir   directory for the root of the package hierarchy
                      for generated files                    
                </param>
            </javadoc>
            <method name="generate" type="void" line="117">
                <params>
                    <param name="env" type="BatchEnvironment"/>
                    <param name="cdef" type="ClassDefinition"/>
                    <param name="destDir" type="File"/>
                </params>
                <comment line="119">
                    exit if an error occurred                    
                </comment>
                <declaration name="remoteClass" type="RemoteClass" line="118"/>
                <declaration name="gen" type="RMIGenerator" line="122"/>
                <scope line="123"/>
                <scope line="125"/>
            </method>
            <method name="generate" type="void" line="132">
                <comment line="170">
                    For bugid 4135136: if skeleton files are not being generated
                     for this compilation run, delete old skeleton source or class
                     files for this remote implementation class that were
                     (presumably) left over from previous runs, to avoid user
                     confusion from extraneous or inconsistent generated files.                    
                </comment>
                <comment line="181">
                    ignore failures (no big deal)                    
                </comment>
                <scope line="135">
                    <declaration name="out" type="IndentingWriter" line="136"/>
                    <scope line="140"/>
                </scope>
                <scope line="144"/>
                <scope line="151">
                    <scope line="154">
                        <declaration name="out" type="IndentingWriter" line="155"/>
                        <scope line="160"/>
                    </scope>
                    <scope line="165"/>
                </scope>
                <scope line="169">
                    <declaration name="outputDir" type="File" line="178"/>
                    <declaration name="skeletonClassFile" type="File" line="179"/>
                </scope>
            </method>
            <javadoc line="186">
                Return the File object that should be used as the source file
                  for the given Java class, using the supplied destination
                  directory for the top of the package hierarchy.                
            </javadoc>
            <method name="sourceFileForClass" type="File" line="195">
                <params>
                    <param name="className" type="Identifier"/>
                    <param name="outputClassName" type="Identifier"/>
                    <param name="destDir" type="File"/>
                    <param name="env" type="BatchEnvironment"/>
                </params>
                <comment line="199">
                    Is there any existing _Tie equivalent leftover from a                    
                </comment>
                <comment line="200">
                    previous invocation of rmic -iiop? Only do this once per                    
                </comment>
                <comment line="201">
                    class by looking for skeleton generation...                    
                </comment>
                <comment line="208">
                    Found a tie. Is IIOP generation also being done?                    
                </comment>
                <comment line="212">
                    No, so write a warning...                    
                </comment>
                <declaration name="packageDir" type="File" line="196"/>
                <declaration name="outputName" type="String" line="197"/>
                <scope line="203">
                    <declaration name="classNameStr" type="String" line="204"/>
                    <declaration name="temp" type="File" line="205"/>
                    <scope line="206">
                        <scope line="210"/>
                    </scope>
                </scope>
                <declaration name="outputFileName" type="String" line="221"/>
            </method>
            <declaration name="env" type="BatchEnvironment" line="226"/>
            <javadoc line="226">
                rmic environment for this object                
            </javadoc>
            <declaration name="remoteClass" type="RemoteClass" line="229"/>
            <javadoc line="229">
                the remote class that this instance is generating code for                
            </javadoc>
            <declaration name="version" type="int" line="232"/>
            <javadoc line="232">
                version of the stub protocol to use in code generation                
            </javadoc>
            <declaration name="remoteMethods" type="RemoteClass.Method[]" line="235"/>
            <javadoc line="235">
                remote methods for remote class, indexed by operation number                
            </javadoc>
            <declaration name="remoteClassName" type="Identifier" line="238"/>
            <javadoc line="238">
                Names for the remote class and the stub and skeleton classes
                  to be generated for it.                
            </javadoc>
            <declaration name="stubClassName" type="Identifier" line="243"/>
            <declaration name="skeletonClassName" type="Identifier" line="244"/>
            <declaration name="cdef" type="ClassDefinition" line="246"/>
            <declaration name="destDir" type="File" line="247"/>
            <declaration name="stubFile" type="File" line="248"/>
            <declaration name="skeletonFile" type="File" line="249"/>
            <declaration name="methodFieldNames" type="String[]" line="251"/>
            <javadoc line="251">
                Names to use for the java.lang.reflect.Method static fields
                  corresponding to each remote method.                
            </javadoc>
            <declaration name="defException" type="ClassDefinition" line="257"/>
            <javadoc line="257">
                cached definition for certain exception classes in this environment                
            </javadoc>
            <declaration name="defRemoteException" type="ClassDefinition" line="259"/>
            <declaration name="defRuntimeException" type="ClassDefinition" line="260"/>
            <javadoc line="262">
                Create a new stub/skeleton Generator object for the given
                  remote implementation class to generate code according to
                  the given stub protocol version.                
            </javadoc>
            <method name="RMIGenerator" type="constructor" line="270">
                <params>
                    <param name="env" type="BatchEnvironment"/>
                    <param name="cdef" type="ClassDefinition"/>
                    <param name="destDir" type="File"/>
                    <param name="remoteClass" type="RemoteClass"/>
                    <param name="version" type="int"/>
                </params>
                <comment line="288">
                    Initialize cached definitions for exception classes used
                     in the generation process.                    
                </comment>
            </method>
            <javadoc line="303">
                Write the stub for the remote class to a stream.                
            </javadoc>
            <method name="writeStub" type="void" line="306">
                <params>
                    <param name="p" type="IndentingWriter"/>
                </params>
                <comment line="308">
                    Write boiler plate comment.                    
                </comment>
                <comment line="315">
                    If remote implementation class was in a particular package,
                     declare the stub class to be in the same package.                    
                </comment>
                <comment line="324">
                    Declare the stub class; implement all remote interfaces.                    
                </comment>
                <comment line="358">
                    We only need to declare and initialize the static fields of
                     Method objects for each remote method if there are any remote
                     methods; otherwise, skip this code entirely, to avoid generating
                     a trycatch block for a checked exception that cannot occur
                     (see bugid 4125181).                    
                </comment>
                <comment line="372">
                    Initialize java.lang.reflect.Method fields for each remote
                     method in a static initializer.                    
                </comment>
                <comment line="379">
                    Fat stubs must determine whether the API required for
                     the JDK 1.2 stub protocol is supported in the current
                     runtime, so that it can use it if supported.  This is
                     determined by using the Reflection API to test if the
                     new invoke method on RemoteRef exists, and setting the
                     static boolean &quot;useNewInvoke&quot; to true if it does, or
                     to false if a NoSuchMethodException is thrown.                    
                </comment>
                <comment line="403">
                    REMIND: By throwing an Error here, the application will
                     get the NoSuchMethodError directly when the stub class
                     is initialized.  If we throw a RuntimeException
                     instead, the application would get an
                     ExceptionInInitializerError.  Would that be more
                     appropriate, and if so, which RuntimeException should
                     be thrown?                    
                </comment>
                <comment line="416">
                    end try/catch block                    
                </comment>
                <comment line="417">
                    end static initializer                    
                </comment>
                <comment line="425">
                    Write each stub method.                    
                </comment>
                <comment line="436">
                    end stub class                    
                </comment>
                <scope line="319"/>
                <declaration name="remoteInterfaces" type="ClassDefinition[]" line="330"/>
                <scope line="331">
                    <scope line="333"/>
                </scope>
                <scope line="344"/>
                <scope line="353">
                    <scope line="365">
                        <scope line="366"/>
                        <scope line="378"/>
                        <scope line="400"/>
                        <scope line="402"/>
                    </scope>
                </scope>
                <scope line="428">
                    <scope line="430"/>
                </scope>
            </method>
            <javadoc line="439">
                Write the constructors for the stub class.                
            </javadoc>
            <method name="writeStubConstructors" type="void" line="444">
                <params>
                    <param name="p" type="IndentingWriter"/>
                </params>
                <comment line="447">
                    Only stubs compatible with the JDK 1.1 stub protocol need
                     a no-arg constructor; later versions use reflection to find
                     the constructor that directly takes a RemoteRef argument.                    
                </comment>
                <scope line="454"/>
            </method>
            <javadoc line="467">
                Write the stub method for the remote method with the given &quot;opnum&quot;.                
            </javadoc>
            <method name="writeStubMethod" type="void" line="472">
                <params>
                    <param name="p" type="IndentingWriter"/>
                    <param name="opnum" type="int"/>
                </params>
                <comment line="481">
                    Declare stub method; throw exceptions declared in remote
                     interface(s).                    
                </comment>
                <comment line="505">
                    The RemoteRef.invoke methods throw Exception, but unless this
                     stub method throws Exception as well, we must catch Exceptions
                     thrown from the invocation.  So we must catch Exception and
                     rethrow something we can throw: UnexpectedException, which is a
                     subclass of RemoteException.  But for any subclasses of Exception
                     that we can throw, like RemoteException, RuntimeException, and
                     any of the exceptions declared by this stub method, we want them
                     to pass through unharmed, so first we must catch any such
                     exceptions and rethrow it directly.
                    
                     We have to be careful generating the rethrowing catch blocks
                     here, because javac will flag an error if there are any
                     unreachable catch blocks, i.e. if the catch of an exception class
                     follows a previous catch of it or of one of its superclasses.
                     The following method invocation takes care of these details.                    
                </comment>
                <comment line="524">
                    If we need to catch any particular exceptions (i.e. this method
                     does not declare java.lang.Exception), put the entire stub
                     method in a try block.                    
                </comment>
                <comment line="540">
                    REMIND: why $?                    
                </comment>
                <comment line="584">
                    REMIND: why $?                    
                </comment>
                <comment line="593">
                    If any only if readObject has been invoked, we must catch
                     ClassNotFoundException as well as IOException.                    
                </comment>
                <comment line="609">
                    end if/else (useNewInvoke) block                    
                </comment>
                <comment line="612">
                    If we need to catch any particular exceptions, finally write
                     the catch blocks for them, rethrow any other Exceptions with an
                     UnexpectedException, and end the try block.                    
                </comment>
                <comment line="628">
                    end try/catch block                    
                </comment>
                <comment line="631">
                    end stub method                    
                </comment>
                <declaration name="method" type="RemoteClass.Method" line="473"/>
                <declaration name="methodName" type="Identifier" line="474"/>
                <declaration name="methodType" type="Type" line="475"/>
                <declaration name="paramTypes" type="Type" line="476"/>
                <declaration name="paramNames" type="String" line="477"/>
                <declaration name="returnType" type="Type" line="478"/>
                <declaration name="exceptions" type="ClassDeclaration[]" line="479"/>
                <scope line="488"/>
                <scope line="494">
                    <scope line="496"/>
                </scope>
                <declaration name="catchList" type="Vector" line="522"/>
                <scope line="529"/>
                <scope line="533"/>
                <scope line="538">
                    <scope line="539"/>
                    <scope line="543">
                        <scope line="545"/>
                    </scope>
                    <scope line="551"/>
                    <scope line="555"/>
                </scope>
                <scope line="560"/>
                <scope line="565">
                    <scope line="569"/>
                    <scope line="581"/>
                    <scope line="583">
                        <declaration name="objectRead" type="boolean" line="587"/>
                        <scope line="597"/>
                    </scope>
                </scope>
                <scope line="608"/>
                <scope line="617">
                    <scope line="620">
                        <declaration name="def" type="ClassDefinition" line="621"/>
                    </scope>
                </scope>
            </method>
            <javadoc line="634">
                Compute the exceptions which need to be caught and rethrown in a
                  stub method before wrapping Exceptions in UnexpectedExceptions,
                  given the exceptions declared in the throws clause of the method.
                  Returns a Vector containing ClassDefinition objects for each
                  exception to catch.  Each exception is guaranteed to be unique,
                  i.e. not a subclass of any of the other exceptions in the Vector,
                  so the catch blocks for these exceptions may be generated in any
                  order relative to each other.
                  RemoteException and RuntimeException are each automatically placed
                  in the returned Vector (if none of their superclasses are already
                  present), since those exceptions should always be directly rethrown
                  by a stub method.
                  The returned Vector will be empty if java.lang.Exception or one
                  of its superclasses is in the throws clause of the method, indicating
                  that no exceptions need to be caught.                
            </javadoc>
            <method name="computeUniqueCatchList" type="Vector" line="653">
                <params>
                    <param name="exceptions" type="ClassDeclaration[]"/>
                </params>
                <comment line="654">
                    unique exceptions to catch                    
                </comment>
                <comment line="659">
                                        
                </comment>
                <comment line="665">
                    (If java.lang.Exception (or a superclass) was declared
                     in the throws clause of this stub method, then we don&apos;t
                     have to bother catching anything; clear the list and
                     return.)                    
                </comment>
                <comment line="674">
                    Ignore other Throwables that do not extend Exception,
                     since they do not need to be caught anyway.                    
                </comment>
                <comment line="680">
                    Compare this exception against the current list of
                     exceptions that need to be caught:                    
                </comment>
                <comment line="688">
                    If a superclass of this exception is already on
                     the list to catch, then ignore and continue;                    
                </comment>
                <comment line="694">
                    If a subclass of this exception is on the list
                     to catch, then remove it.                    
                </comment>
                <comment line="700">
                    else continue comparing                    
                </comment>
                <comment line="703">
                                        
                </comment>
                <comment line="707">
                    REMIND: We do not exit from this exceptional condition,
                     generating questionable code and likely letting the
                     compiler report a resulting error later.                    
                </comment>
                <declaration name="uniqueList" type="Vector" line="654"/>
                <scope line="661">
                    <declaration name="decl" type="ClassDeclaration" line="662"/>
                    <scope line="663">
                        <scope line="664"/>
                        <scope line="673"/>
                        <scope line="684">
                            <declaration name="def" type="ClassDefinition" line="685"/>
                            <scope line="687"/>
                            <scope line="693"/>
                            <scope line="699"/>
                        </scope>
                    </scope>
                    <scope line="705"/>
                </scope>
            </method>
            <javadoc line="717">
                Write the skeleton for the remote class to a stream.                
            </javadoc>
            <method name="writeSkeleton" type="void" line="720">
                <params>
                    <param name="p" type="IndentingWriter"/>
                </params>
                <comment line="725">
                    Write boiler plate comment.                    
                </comment>
                <comment line="732">
                    If remote implementation class was in a particular package,
                     declare the skeleton class to be in the same package.                    
                </comment>
                <comment line="741">
                    Declare the skeleton class.                    
                </comment>
                <comment line="755">
                    Define the getOperations() method.                    
                </comment>
                <comment line="763">
                    Define the dispatch() method.                    
                </comment>
                <comment line="783">
                    Skeleton throws UnmarshalException if it does not recognize
                     the method hash; this is what UnicastServerRef.dispatch()
                     would do.                    
                </comment>
                <comment line="793">
                    Ignore the validation of the interface hash if the
                     operation number was negative, since it is really a
                     method hash instead.                    
                </comment>
                <comment line="807">
                    end if/else (opnum &lt; 0) block                    
                </comment>
                <comment line="811">
                    Cast remote object instance to our specific implementation class.                    
                </comment>
                <comment line="816">
                    Process call according to the operation number.                    
                </comment>
                <comment line="824">
                    Skeleton throws UnmarshalException if it does not recognize
                     the operation number; this is consistent with the case of an
                     unrecognized method hash.                    
                </comment>
                <comment line="831">
                    end switch statement                    
                </comment>
                <comment line="833">
                    end dispatch() method                    
                </comment>
                <comment line="835">
                    end skeleton class                    
                </comment>
                <scope line="721"/>
                <scope line="736"/>
                <scope line="771">
                    <scope line="773">
                        <scope line="774"/>
                    </scope>
                    <scope line="790"/>
                </scope>
                <scope line="806"/>
                <scope line="820"/>
            </method>
            <javadoc line="838">
                Write the case block for the skeleton&apos;s dispatch method for
                  the remote method with the given &quot;opnum&quot;.                
            </javadoc>
            <method name="writeSkeletonDispatchCase" type="void" line="844">
                <params>
                    <param name="p" type="IndentingWriter"/>
                    <param name="opnum" type="int"/>
                </params>
                <comment line="854">
                    Use nested block statement inside case to provide an independent
                     namespace for local variables used to unmarshal parameters for
                     this remote method.                    
                </comment>
                <comment line="862">
                    Declare local variables to hold arguments.                    
                </comment>
                <comment line="869">
                    Unmarshal arguments from call stream.                    
                </comment>
                <comment line="879">
                    If any only if readObject has been invoked, we must catch
                     ClassNotFoundException as well as IOException.                    
                </comment>
                <comment line="896">
                    Declare variable to hold return type, if not void.                    
                </comment>
                <comment line="899">
                    REMIND: why $?                    
                </comment>
                <comment line="902">
                    Invoke the method on the server object.                    
                </comment>
                <comment line="913">
                    Always invoke getResultStream(true) on the call object to send
                     the indication of a successful invocation to the caller.  If
                     the return type is not void, keep the result stream and marshal
                     the return value.                    
                </comment>
                <comment line="933">
                    break from switch statement                    
                </comment>
                <comment line="935">
                    end nested block statement                    
                </comment>
                <declaration name="method" type="RemoteClass.Method" line="845"/>
                <declaration name="methodName" type="Identifier" line="846"/>
                <declaration name="methodType" type="Type" line="847"/>
                <declaration name="paramTypes" type="Type" line="848"/>
                <declaration name="paramNames" type="String" line="849"/>
                <declaration name="returnType" type="Type" line="850"/>
                <scope line="861">
                    <scope line="865"/>
                    <declaration name="objectsRead" type="boolean" line="874"/>
                    <scope line="883"/>
                </scope>
                <scope line="891"/>
                <scope line="895"/>
                <scope line="906"/>
                <scope line="920"/>
                <scope line="924"/>
            </method>
            <javadoc line="939">
                Write declaration and initializer for &quot;operations&quot; static array.                
            </javadoc>
            <method name="writeOperationsArray" type="void" line="944">
                <params>
                    <param name="p" type="IndentingWriter"/>
                </params>
                <scope line="946"/>
            </method>
            <javadoc line="956">
                Write declaration and initializer for &quot;interfaceHash&quot; static field.                
            </javadoc>
            <method name="writeInterfaceHash" type="void" line="961">
                <params>
                    <param name="p" type="IndentingWriter"/>
                </params>
            </method>
            <javadoc line="966">
                Write declaration for java.lang.reflect.Method static fields
                  corresponding to each remote method in a stub.                
            </javadoc>
            <method name="writeMethodFieldDeclarations" type="void" line="972">
                <params>
                    <param name="p" type="IndentingWriter"/>
                </params>
                <scope line="973"/>
            </method>
            <javadoc line="979">
                Write code to initialize the static fields for each method
                  using the Java Reflection API.                
            </javadoc>
            <method name="writeMethodFieldInitializers" type="void" line="985">
                <params>
                    <param name="p" type="IndentingWriter"/>
                </params>
                <comment line="988">
                    Here we look up the Method object in the arbitrary interface
                     that we find in the RemoteClass.Method object.
                     REMIND: Is this arbitrary choice OK?
                     REMIND: Should this access be part of RemoteClass.Method&apos;s
                     abstraction?                    
                </comment>
                <scope line="986">
                    <declaration name="method" type="RemoteClass.Method" line="995"/>
                    <declaration name="def" type="MemberDefinition" line="996"/>
                    <declaration name="methodName" type="Identifier" line="997"/>
                    <declaration name="methodType" type="Type" line="998"/>
                    <declaration name="paramTypes" type="Type" line="999"/>
                    <scope line="1003"/>
                </scope>
            </method>
            <javadoc line="1018">
                Generate an array of names for fields that correspond to the given
                  array of remote methods.  Each name in the returned array is
                  guaranteed to be unique.
                  The name of a method is included in its corresponding field name
                  to enhance readability of the generated code.                
            </javadoc>
            <method name="nameMethodFields" type="String[]" line="1026">
                <params>
                    <param name="methods" type="RemoteClass.Method[]"/>
                </params>
                <declaration name="names" type="String[]" line="1027"/>
                <scope line="1028"/>
            </method>
            <javadoc line="1034">
                Generate an array of names for parameters corresponding to the
                  given array of types for the parameters.  Each name in the returned
                  array is guaranteed to be unique.
                  A representation of the type of a parameter is included in its
                  corresponding field name to enhance the readability of the generated
                  code.                
            </javadoc>
            <method name="nameParameters" type="String[]" line="1043">
                <params>
                    <param name="types" type="Type[]"/>
                </params>
                <declaration name="names" type="String[]" line="1044"/>
                <scope line="1045"/>
            </method>
            <javadoc line="1052">
                Generate a readable string representing the given type suitable
                  for embedding within a Java identifier.                
            </javadoc>
            <method name="generateNameFromType" type="String" line="1056">
                <params>
                    <param name="type" type="Type"/>
                </params>
                <declaration name="typeCode" type="int" line="1057"/>
            </method>
            <javadoc line="1077">
                Write a snippet of Java code to marshal a value named &quot;name&quot; of
                  type &quot;type&quot; to the java.io.ObjectOutput stream named &quot;stream&quot;.
                  Primitive types are marshalled with their corresponding methods
                  in the java.io.DataOutput interface, and objects (including arrays)
                  are marshalled using the writeObject method.                
            </javadoc>
            <method name="writeMarshalArgument" type="void" line="1089">
                <params>
                    <param name="p" type="IndentingWriter"/>
                    <param name="streamName" type="String"/>
                    <param name="type" type="Type"/>
                    <param name="name" type="String"/>
                </params>
                <declaration name="typeCode" type="int" line="1090"/>
            </method>
            <javadoc line="1125">
                Write Java statements to marshal a series of values in order as
                  named in the &quot;names&quot; array, with types as specified in the &quot;types&quot;
                  array&quot;, to the java.io.ObjectOutput stream named &quot;stream&quot;.                
            </javadoc>
            <method name="writeMarshalArguments" type="void" line="1134">
                <params>
                    <param name="p" type="IndentingWriter"/>
                    <param name="streamName" type="String"/>
                    <param name="types" type="Type[]"/>
                    <param name="names" type="String[]"/>
                </params>
                <scope line="1135"/>
                <scope line="1139"/>
            </method>
            <javadoc line="1145">
                Write a snippet of Java code to unmarshal a value of type &quot;type&quot;
                  from the java.io.ObjectInput stream named &quot;stream&quot; into a variable
                  named &quot;name&quot; (if &quot;name&quot; is null, the value in unmarshalled and
                  discarded).
                  Primitive types are unmarshalled with their corresponding methods
                  in the java.io.DataInput interface, and objects (including arrays)
                  are unmarshalled using the readObject method.                
            </javadoc>
            <method name="writeUnmarshalArgument" type="boolean" line="1159">
                <params>
                    <param name="p" type="IndentingWriter"/>
                    <param name="streamName" type="String"/>
                    <param name="type" type="Type"/>
                    <param name="name" type="String"/>
                </params>
                <declaration name="readObject" type="boolean" line="1160"/>
                <scope line="1162"/>
                <declaration name="typeCode" type="int" line="1166"/>
            </method>
            <javadoc line="1203">
                Write Java statements to unmarshal a series of values in order of
                  types as in the &quot;types&quot; array from the java.io.ObjectInput stream
                  named &quot;stream&quot; into variables as named in &quot;names&quot; (for any element
                  of &quot;names&quot; that is null, the corresponding value is unmarshalled
                  and discarded).                
            </javadoc>
            <method name="writeUnmarshalArguments" type="boolean" line="1215">
                <params>
                    <param name="p" type="IndentingWriter"/>
                    <param name="streamName" type="String"/>
                    <param name="types" type="Type[]"/>
                    <param name="names" type="String[]"/>
                </params>
                <scope line="1216"/>
                <declaration name="readObject" type="boolean" line="1220"/>
                <scope line="1221">
                    <scope line="1222"/>
                </scope>
            </method>
            <javadoc line="1230">
                Return a snippet of Java code to wrap a value named &quot;name&quot; of
                  type &quot;type&quot; into an object as appropriate for use by the
                  Java Reflection API.
                  For primitive types, an appropriate wrapper class instantiated
                  with the primitive value.  For object types (including arrays),
                  no wrapping is necessary, so the value is named directly.                
            </javadoc>
            <method name="wrapArgumentCode" type="String" line="1239">
                <params>
                    <param name="type" type="Type"/>
                    <param name="name" type="String"/>
                </params>
                <declaration name="typeCode" type="int" line="1240"/>
            </method>
            <javadoc line="1267">
                Return a snippet of Java code to unwrap a value named &quot;name&quot; into
                  a value of type &quot;type&quot;, as appropriate for the Java Reflection API.
                  For primitive types, the value is assumed to be of the corresponding
                  wrapper type, and a method is called on the wrapper type to retrieve
                  the primitive value.  For object types (include arrays), no
                  unwrapping is necessary; the value is simply cast to the expected
                  real object type.                
            </javadoc>
            <method name="unwrapArgumentCode" type="String" line="1277">
                <params>
                    <param name="type" type="Type"/>
                    <param name="name" type="String"/>
                </params>
                <declaration name="typeCode" type="int" line="1278"/>
            </method>
        </class>
    </source>