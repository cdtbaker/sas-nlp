<?xml version="1.0" encoding="UTF-8"?>
    <source package="sun.rmi.server">
        <import package="java.lang.ref.Reference"/>
        <import package="java.lang.ref.SoftReference"/>
        <import package="java.util.Map"/>
        <import package="java.util.WeakHashMap"/>
        <class name="WeakClassHashMap" line="32">
            <type_params>
                <type_param name="V"/>
            </type_params>
            <javadoc line="32">
                Abstract class that maps Class objects to lazily-computed values of
                  type V.  A concrete subclass must implement the computeValue method
                  to determine how the values are computed.
                  The keys are only weakly reachable through this map, so this map
                  does not prevent a class (along with its class loader, etc.) from
                  being garbage collected if it is not otherwise strongly reachable.
                  The values are only softly reachable through this map, so that the
                  computed values generally persist while not otherwise strongly
                  reachable, but their storage may be reclaimed if necessary.  Also,
                  note that if a key is strongly reachable from a value, then the key
                  is effectively softly reachable through this map, which may delay
                  garbage collection of classes (see 4429536).                
            </javadoc>
            <declaration name="internalMap" type="Map&lt;Class&lt;?&gt;,ValueCell&lt;V&gt;&gt;" line="49"/>
            <method name="WeakClassHashMap" type="constructor" line="52"/>
            <method name="get" type="V" line="54">
                <params>
                    <param name="remoteClass" type="Class<?>"/>
                </params>
                <comment line="55">
                    Use a mutable cell (a one-element list) to hold the soft
                     reference to a value, to allow the lazy value computation
                     to be synchronized with entry-level granularity instead of
                     by locking the whole table.                    
                </comment>
                <declaration name="valueCell" type="ValueCell&lt;V&gt;" line="61"/>
                <scope line="62">
                    <scope line="64"/>
                </scope>
                <scope line="69">
                    <declaration name="value" type="V" line="70"/>
                    <scope line="71"/>
                    <scope line="74"/>
                </scope>
            </method>
            <method name="computeValue" type="V" line="82"/>
            <class name="ValueCell" line="84">
                <type_params>
                    <type_param name="T"/>
                </type_params>
                <declaration name="ref" type="Reference&lt;T&gt;" line="85"/>
                <method name="ValueCell" type="constructor" line="86"/>
            </class>
        </class>
    </source>