<?xml version="1.0" encoding="UTF-8"?>
    <source package="sun.rmi.server">
        <import package="java.io.IOException"/>
        <import package="java.io.InputStream"/>
        <import package="java.io.ObjectInputStream"/>
        <import package="java.io.ObjectStreamClass"/>
        <import package="java.io.StreamCorruptedException"/>
        <import package="java.net.URL"/>
        <import package="java.util"/>
        <import package="java.security.AccessControlException"/>
        <import package="java.security.Permission"/>
        <import package="java.rmi.server.RMIClassLoader"/>
        <class name="MarshalInputStream" line="40">
            <extends class="ObjectInputStream"/>
            <comment line="84">
                Fix for 4179055: The remote object services inside the
                 activation daemon use stubs that are in the package
                 sun.rmi.server.  Classes for these stubs should be loaded from
                 the classpath by RMI system code and not by the normal
                 unmarshalling process as applications should not need to have
                 permission to access the sun implementation classes.
                
                 Note: this fix should be redone when API changes may be
                 integrated
                
                 During parameter unmarshalling RMI needs to explicitly permit
                 access to three sun. stub classes                
            </comment>
            <comment line="262">
                Returns the first non-null class loader up the execution stack, or null
                 if only code from the null class loader is on the stack.                
            </comment>
            <javadoc line="40">
                MarshalInputStream is an extension of ObjectInputStream.  When resolving
                  a class, it reads an object from the stream written by a corresponding
                  MarshalOutputStream.  If the class to be resolved is not available
                  locally, from the first class loader on the execution stack, or from the
                  context class loader of the current thread, it will attempt to load the
                  class from the location annotated by the sending MarshalOutputStream.
                  This location object must be a string representing a path of URLs.
                  A new MarshalInputStream should be created to deserialize remote objects or
                  graphs containing remote objects.  Objects are created from the stream
                  using the ObjectInputStream.readObject method.                
                <author>
                    Peter Jones                    
                </author>
            </javadoc>
            <declaration name="useCodebaseOnlyProperty" type="boolean" line="57"/>
            <javadoc line="57">
                value of &quot;java.rmi.server.useCodebaseOnly&quot; property,
                  as cached at class initialization time.                
            </javadoc>
            <declaration name="permittedSunClasses" type="Map&lt;String,Class&lt;?&gt;&gt;" line="66"/>
            <javadoc line="66">
                table to hold sun classes to which access is explicitly permitted                
            </javadoc>
            <declaration name="skipDefaultResolveClass" type="boolean" line="70"/>
            <javadoc line="70">
                if true, don&apos;t try superclass first in resolveClass()                
            </javadoc>
            <declaration name="doneCallbacks" type="Map&lt;Object,Runnable&gt;" line="73"/>
            <javadoc line="73">
                callbacks to make when done() called: maps Object to Runnable                
            </javadoc>
            <declaration name="useCodebaseOnly" type="boolean" line="77"/>
            <javadoc line="77">
                if true, load classes (if not available locally) only from the
                  URL specified by the &quot;java.rmi.server.codebase&quot; property.                
            </javadoc>
            <scope line="97">
                <scope line="98">
                    <declaration name="system" type="String" line="99"/>
                    <declaration name="registry" type="String" line="101"/>
                </scope>
                <scope line="106"/>
            </scope>
            <javadoc line="112">
                Load the &quot;rmi&quot; native library.                
            </javadoc>
            <scope line="115"/>
            <javadoc line="120">
                Create a new MarshalInputStream object.                
            </javadoc>
            <method name="MarshalInputStream" type="constructor" line="125">
                <params>
                    <param name="in" type="InputStream"/>
                </params>
            </method>
            <javadoc line="129">
                Returns a callback previously registered via the setDoneCallback
                  method with given key, or null if no callback has yet been registered
                  with that key.                
            </javadoc>
            <method name="getDoneCallback" type="Runnable" line="134">
                <params>
                    <param name="key" type="Object"/>
                </params>
                <comment line="135">
                    not thread-safe                    
                </comment>
            </method>
            <javadoc line="138">
                Registers a callback to make when this stream&apos;s done() method is
                  invoked, along with a key for retrieving the same callback instance
                  subsequently from the getDoneCallback method.                
            </javadoc>
            <method name="setDoneCallback" type="void" line="143">
                <params>
                    <param name="key" type="Object"/>
                    <param name="callback" type="Runnable"/>
                </params>
                <comment line="144">
                    assert(!doneCallbacks.contains(key));                    
                </comment>
                <comment line="145">
                    not thread-safe                    
                </comment>
            </method>
            <javadoc line="148">
                Indicates that the user of this MarshalInputStream is done reading
                  objects from it, so all callbacks registered with the setDoneCallback
                  method should now be (synchronously) executed.  When this method
                  returns, there are no more callbacks registered.
                  This method is implicitly invoked by close() before it delegates to
                  the superclass&apos;s close method.                
            </javadoc>
            <method name="done" type="void" line="157">
                <comment line="159">
                    not thread-safe                    
                </comment>
                <declaration name="iter" type="Iterator&lt;Runnable&gt;" line="158"/>
                <scope line="159">
                    <declaration name="callback" type="Runnable" line="160"/>
                </scope>
            </method>
            <javadoc line="166">
                Closes this stream, implicitly invoking done() first.                
            </javadoc>
            <method name="close" type="void" line="169"/>
            <javadoc line="174">
                resolveClass is extended to acquire (if present) the location
                  from which to load the specified class.
                  It will find, load, and return the class.                
            </javadoc>
            <method name="resolveClass" type="Class" line="181">
                <params>
                    <param name="classDesc" type="ObjectStreamClass"/>
                </params>
                <comment line="182">
                    Always read annotation written by MarshalOutputStream
                     describing where to load class from.                    
                </comment>
                <comment line="190">
                    Unless we were told to skip this consideration, choose the
                     &quot;default loader&quot; to simulate the default ObjectInputStream
                     resolveClass mechanism (that is, choose the first non-null
                     loader on the execution stack) to maximize the likelihood of
                     type compatibility with calling code.  (This consideration
                     is skipped during server parameter unmarshalling using the 1.2
                     stub protocol, because there would never be a non-null class
                     loader on the stack in that situation anyway.)                    
                </comment>
                <comment line="203">
                    If the &quot;java.rmi.server.useCodebaseOnly&quot; property was true or
                     useCodebaseOnly() was called or the annotation is not a String,
                     load from the local loader using the &quot;java.rmi.server.codebase&quot;
                     URL.  Otherwise, load from a loader using the codebase URL in
                     the annotation.                    
                </comment>
                <comment line="221">
                    Fix for 4442373: delegate to ObjectInputStream.resolveClass()
                     to resolve primitive classes.                    
                </comment>
                <declaration name="annotation" type="Object" line="186"/>
                <declaration name="className" type="String" line="188"/>
                <declaration name="defaultLoader" type="ClassLoader" line="200"/>
                <declaration name="codebase" type="String" line="210"/>
                <scope line="211"/>
                <scope line="215"/>
                <scope line="218"/>
                <scope line="220">
                    <scope line="225">
                        <scope line="228"/>
                    </scope>
                    <scope line="231"/>
                </scope>
            </method>
            <javadoc line="237">
                resolveProxyClass is extended to acquire (if present) the location
                  to determine the class loader to define the proxy class in.                
            </javadoc>
            <method name="resolveProxyClass" type="Class" line="243">
                <params>
                    <param name="interfaces" type="String[]"/>
                </params>
                <comment line="244">
                    Always read annotation written by MarshalOutputStream.                    
                </comment>
                <declaration name="annotation" type="Object" line="247"/>
                <declaration name="defaultLoader" type="ClassLoader" line="249"/>
                <declaration name="codebase" type="String" line="252"/>
                <scope line="253"/>
            </method>
            <method name="latestUserDefinedLoader" type="ClassLoader" line="265"/>
            <javadoc line="267">
                Fix for 4179055: Need to assist resolving sun stubs; resolve
                  class locally if it is a &quot;permitted&quot; sun class                
            </javadoc>
            <method name="checkSunClass" type="Class" line="273">
                <params>
                    <param name="className" type="String"/>
                    <param name="e" type="AccessControlException"/>
                </params>
                <comment line="274">
                    ensure that we are giving out a stub for the correct reason                    
                </comment>
                <comment line="283">
                    if class not permitted, throw the SecurityException                    
                </comment>
                <declaration name="perm" type="Permission" line="275"/>
                <declaration name="name" type="String" line="276"/>
                <scope line="277"/>
                <declaration name="resolvedClass" type="Class&lt;?&gt;" line="281"/>
                <scope line="288"/>
            </method>
            <javadoc line="295">
                Return the location for the class in the stream.  This method can
                  be overridden by subclasses that store this annotation somewhere
                  else than as the next object in the stream, as is done by this class.                
            </javadoc>
            <method name="readLocation" type="Object" line="302"/>
            <javadoc line="306">
                Set a flag to indicate that the superclass&apos;s default resolveClass()
                  implementation should not be invoked by our resolveClass().                
            </javadoc>
            <method name="skipDefaultResolveClass" type="void" line="310"/>
            <javadoc line="314">
                Disable code downloading except from the URL specified by the
                  &quot;java.rmi.server.codebase&quot; property.                
            </javadoc>
            <method name="useCodebaseOnly" type="void" line="318"/>
        </class>
    </source>