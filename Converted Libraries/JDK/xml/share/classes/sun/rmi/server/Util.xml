<?xml version="1.0" encoding="UTF-8"?>
    <source package="sun.rmi.server">
        <import package="java.io.ByteArrayOutputStream"/>
        <import package="java.io.IOException"/>
        <import package="java.io.DataOutputStream"/>
        <import package="java.lang.reflect.Constructor"/>
        <import package="java.lang.reflect.InvocationHandler"/>
        <import package="java.lang.reflect.InvocationTargetException"/>
        <import package="java.lang.reflect.Proxy"/>
        <import package="java.lang.reflect.Method"/>
        <import package="java.rmi.Remote"/>
        <import package="java.rmi.RemoteException"/>
        <import package="java.rmi.StubNotFoundException"/>
        <import package="java.rmi.registry.Registry"/>
        <import package="java.rmi.server.LogStream"/>
        <import package="java.rmi.server.ObjID"/>
        <import package="java.rmi.server.RMIClientSocketFactory"/>
        <import package="java.rmi.server.RemoteObjectInvocationHandler"/>
        <import package="java.rmi.server.RemoteRef"/>
        <import package="java.rmi.server.RemoteStub"/>
        <import package="java.rmi.server.Skeleton"/>
        <import package="java.rmi.server.SkeletonNotFoundException"/>
        <import package="java.security.AccessController"/>
        <import package="java.security.MessageDigest"/>
        <import package="java.security.DigestOutputStream"/>
        <import package="java.security.NoSuchAlgorithmException"/>
        <import package="java.util.ArrayList"/>
        <import package="java.util.Collections"/>
        <import package="java.util.Map"/>
        <import package="java.util.WeakHashMap"/>
        <import package="sun.rmi.registry.RegistryImpl"/>
        <import package="sun.rmi.runtime.Log"/>
        <import package="sun.rmi.transport.LiveRef"/>
        <import package="sun.rmi.transport.tcp.TCPEndpoint"/>
        <import package="sun.security.action.GetBooleanAction"/>
        <import package="sun.security.action.GetPropertyAction"/>
        <class name="Util" line="62">
            <comment line="181">
                Returns the classsuperclass that implements the remote interface.
                 @throws ClassNotFoundException if no class is found to have a
                 remote interface                
            </comment>
            <javadoc line="62">
                A utility class with static methods for creating stubs/proxies and
                  skeletons for remote objects.                
            </javadoc>
            <declaration name="logLevel" type="int" line="68"/>
            <javadoc line="68">
                &quot;server&quot; package log level                
            </javadoc>
            <declaration name="serverRefLog" type="Log" line="73"/>
            <javadoc line="73">
                server reference log                
            </javadoc>
            <declaration name="ignoreStubClasses" type="boolean" line="77"/>
            <javadoc line="77">
                cached value of property java.rmi.server.ignoreStubClasses                
            </javadoc>
            <declaration name="withoutStubs" type="Map&lt;Class&lt;?&gt;,Void&gt;" line="83"/>
            <javadoc line="83">
                cache of  impl classes that have no corresponding stub class                
            </javadoc>
            <declaration name="stubConsParamTypes" type="Class[]" line="87"/>
            <javadoc line="87">
                parameter types for stub constructor                
            </javadoc>
            <method name="Util" type="constructor" line="90"/>
            <javadoc line="93">
                Returns a proxy for the specified implClass.
                  If both of the following criteria is satisfied, a dynamic proxy for
                  the specified implClass is returned (otherwise a RemoteStub instance
                  for the specified implClass is returned):
                  a) either the property java.rmi.server.ignoreStubClasses is true or
                  a pregenerated stub class does not exist for the impl class, and
                  b) forceStubUse is false.
                  If the above criteria are satisfied, this method constructs a
                  dynamic proxy instance (that implements the remote interfaces of
                  implClass) constructed with a RemoteObjectInvocationHandler instance
                  constructed with the clientRef.
                  Otherwise, this method loads the pregenerated stub class (which
                  extends RemoteStub and implements the remote interfaces of
                  implClass) and constructs an instance of the pregenerated stub
                  class with the clientRef.                
                <param>
                    implClass the class to obtain remote interfaces from                    
                </param>
                <param>
                    clientRef the remote ref to use in the invocation handler                    
                </param>
                <param>
                    forceStubUse if true, forces creation of a RemoteStub                    
                </param>
                <throws>
                    IllegalArgumentException if implClass implements illegal
                      remote interfaces                    
                </throws>
                <throws>
                    StubNotFoundException if problem locating/creating stub or
                      creating the dynamic proxy instance                    
                </throws>
            </javadoc>
            <method name="createProxy" type="Remote" line="126">
                <params>
                    <param name="implClass" type="Class"/>
                    <param name="clientRef" type="RemoteRef"/>
                    <param name="forceStubUse" type="boolean"/>
                </params>
                <comment line="148">
                                        
                </comment>
                <declaration name="remoteClass" type="Class" line="127"/>
                <scope line="129"/>
                <scope line="131"/>
                <scope line="139"/>
                <declaration name="loader" type="ClassLoader" line="143"/>
                <declaration name="interfaces" type="Class[]" line="144"/>
                <declaration name="handler" type="InvocationHandler" line="145"/>
                <scope line="150"/>
                <scope line="154"/>
            </method>
            <javadoc line="159">
                Returns true if a stub class for the given impl class can be loaded,
                  otherwise returns false.                
                <param>
                    remoteClass the class to obtain remote interfaces from                    
                </param>
            </javadoc>
            <method name="stubClassExists" type="boolean" line="165">
                <params>
                    <param name="remoteClass" type="Class"/>
                </params>
                <scope line="166">
                    <scope line="167"/>
                    <scope line="173"/>
                </scope>
            </method>
            <method name="getRemoteClass" type="Class" line="187">
                <params>
                    <param name="cl" type="Class"/>
                </params>
                <comment line="192">
                    this class implements remote object                    
                </comment>
                <scope line="188">
                    <declaration name="interfaces" type="Class[]" line="189"/>
                    <scope line="190"/>
                </scope>
            </method>
            <javadoc line="200">
                Returns an array containing the remote interfaces implemented
                  by the given class.                
                <param>
                    remoteClass the class to obtain remote interfaces from                    
                </param>
                <throws>
                    IllegalArgumentException if remoteClass implements
                      any illegal remote interfaces                    
                </throws>
                <throws>
                    NullPointerException if remoteClass is null                    
                </throws>
            </javadoc>
            <method name="getRemoteInterfaces" type="Class[]" line="209">
                <params>
                    <param name="remoteClass" type="Class"/>
                </params>
                <declaration name="list" type="ArrayList&lt;Class&lt;?&gt;&gt;" line="210"/>
            </method>
            <javadoc line="215">
                Fills the given array list with the remote interfaces implemented
                  by the given class.                
                <throws>
                    IllegalArgumentException if the specified class implements
                      any illegal remote interfaces                    
                </throws>
                <throws>
                    NullPointerException if the specified class or list is null                    
                </throws>
            </javadoc>
            <method name="getRemoteInterfaces" type="void" line="223">
                <params>
                    <param name="list" type="ArrayList<Class<?>>"/>
                    <param name="cl" type="Class"/>
                </params>
                <comment line="232">
                    If it is a remote interface (if it extends from
                     java.rmi.Remote) and is not already in the list,
                     then add the interface to the list.                    
                </comment>
                <declaration name="superclass" type="Class" line="224"/>
                <scope line="225"/>
                <declaration name="interfaces" type="Class[]" line="229"/>
                <scope line="230">
                    <declaration name="intf" type="Class" line="231"/>
                    <scope line="237">
                        <scope line="238">
                            <declaration name="methods" type="Method[]" line="239"/>
                            <scope line="240"/>
                        </scope>
                    </scope>
                </scope>
            </method>
            <javadoc line="249">
                Verifies that the supplied method has at least one declared exception
                  type that is RemoteException or one of its superclasses.  If not,
                  then this method throws IllegalArgumentException.                
                <throws>
                    IllegalArgumentException if m is an illegal remote method                    
                </throws>
            </javadoc>
            <method name="checkMethod" type="void" line="256">
                <params>
                    <param name="m" type="Method"/>
                </params>
                <declaration name="ex" type="Class&lt;?&gt;[]" line="257"/>
                <scope line="258"/>
            </method>
            <javadoc line="266">
                Creates a RemoteStub instance for the specified class, constructed
                  with the specified RemoteRef.  The supplied class must be the most
                  derived class in the remote object&apos;s superclass chain that
                  implements a remote interface.  The stub class name is the name of
                  the specified remoteClass with the suffix &quot;_Stub&quot;.  The loading of
                  the stub class is initiated from class loader of the specified class
                  (which may be the bootstrap class loader).                
            </javadoc>
            <method name="createStub" type="RemoteStub" line="277">
                <params>
                    <param name="remoteClass" type="Class"/>
                    <param name="ref" type="RemoteRef"/>
                </params>
                <comment line="280">
                    Make sure to use the local stub loader for the stub classes.
                     When loaded by the local loader the load path can be
                     propagated to remote clients, by the MarshalOutputStreamInStream
                     pickle methods                    
                </comment>
                <declaration name="stubname" type="String" line="278"/>
                <scope line="285">
                    <declaration name="stubcl" type="Class&lt;?&gt;" line="286"/>
                    <declaration name="cons" type="Constructor" line="288"/>
                </scope>
                <scope line="291"/>
                <scope line="294"/>
                <scope line="297"/>
                <scope line="300"/>
                <scope line="303"/>
                <scope line="306"/>
            </method>
            <javadoc line="312">
                Locate and return the Skeleton for the specified remote object                
            </javadoc>
            <method name="createSkeleton" type="Skeleton" line="317">
                <params>
                    <param name="object" type="Remote"/>
                </params>
                <comment line="327">
                    now try to load the skeleton based ont he name of the class                    
                </comment>
                <declaration name="cl" type="Class" line="318"/>
                <scope line="319"/>
                <scope line="321"/>
                <declaration name="skelname" type="String" line="328"/>
                <scope line="329">
                    <declaration name="skelcl" type="Class" line="330"/>
                </scope>
                <scope line="333"/>
                <scope line="336"/>
                <scope line="339"/>
                <scope line="342"/>
            </method>
            <javadoc line="348">
                Compute the &quot;method hash&quot; of a remote method.  The method hash
                  is a long containing the first 64 bits of the SHA digest from
                  the UTF encoded string of the method name and descriptor.                
            </javadoc>
            <method name="computeMethodHash" type="long" line="353">
                <params>
                    <param name="m" type="Method"/>
                </params>
                <comment line="368">
                    use only the first 64 bits of the digest for the hash                    
                </comment>
                <comment line="375">
                                        
                </comment>
                <declaration name="hash" type="long" line="354"/>
                <declaration name="sink" type="ByteArrayOutputStream" line="355"/>
                <scope line="356">
                    <declaration name="md" type="MessageDigest" line="357"/>
                    <declaration name="out" type="DataOutputStream" line="358"/>
                    <declaration name="s" type="String" line="361"/>
                    <scope line="362"/>
                    <declaration name="hasharray" type="byte" line="370"/>
                    <scope line="371"/>
                </scope>
                <scope line="374"/>
                <scope line="377"/>
            </method>
            <javadoc line="383">
                Return a string consisting of the given method&apos;s name followed by
                  its &quot;method descriptor&quot;, as appropriate for use in the computation
                  of the &quot;method hash&quot;.
                  See section 4.3.3 of The Java Virtual Machine Specification for
                  the definition of a &quot;method descriptor&quot;.                
            </javadoc>
            <method name="getMethodNameAndDescriptor" type="String" line="391">
                <params>
                    <param name="m" type="Method"/>
                </params>
                <comment line="400">
                    optimization: handle void here                    
                </comment>
                <declaration name="desc" type="StringBuffer" line="392"/>
                <declaration name="paramTypes" type="Class[]" line="394"/>
                <scope line="395"/>
                <declaration name="returnType" type="Class" line="399"/>
                <scope line="400"/>
                <scope line="402"/>
            </method>
            <javadoc line="408">
                Get the descriptor of a particular type, as appropriate for either
                  a parameter or return type in a method descriptor.                
            </javadoc>
            <method name="getTypeDescriptor" type="String" line="412">
                <params>
                    <param name="type" type="Class"/>
                </params>
                <comment line="436">
                    According to JLS 20.3.2, the getName() method on Class does
                     return the VM type descriptor format for array classes (only);
                     using that should be quicker than the otherwise obvious code:
                    
                         return &quot;[&quot; + getTypeDescriptor(type.getComponentType());                    
                </comment>
                <scope line="413">
                    <scope line="414"/>
                    <scope line="416"/>
                    <scope line="418"/>
                    <scope line="420"/>
                    <scope line="422"/>
                    <scope line="424"/>
                    <scope line="426"/>
                    <scope line="428"/>
                    <scope line="430"/>
                    <scope line="432"/>
                </scope>
                <scope line="435"/>
                <scope line="444"/>
            </method>
            <javadoc line="449">
                Returns the binary name of the given type without package
                  qualification.  Nested types are treated no differently from
                  top-level types, so for a nested type, the returned name will
                  still be qualified with the simple name of its enclosing
                  top-level type (and perhaps other enclosing types), the
                  separator will be &apos;$&apos;, etc.                
            </javadoc>
            <method name="getUnqualifiedName" type="String" line="457">
                <params>
                    <param name="c" type="Class"/>
                </params>
                <declaration name="binaryName" type="String" line="458"/>
            </method>
        </class>
    </source>