<?xml version="1.0" encoding="UTF-8"?>
    <source package="sun.rmi.server">
        <import package="java.io.IOException"/>
        <import package="java.io.ObjectInput"/>
        <import package="java.io.ObjectOutput"/>
        <import package="java.lang.reflect.Method"/>
        <import package="java.rmi.MarshalException"/>
        <import package="java.rmi.Remote"/>
        <import package="java.rmi.RemoteException"/>
        <import package="java.rmi.ServerException"/>
        <import package="java.rmi.UnmarshalException"/>
        <import package="java.rmi.server.Operation"/>
        <import package="java.rmi.server.RemoteCall"/>
        <import package="java.rmi.server.RemoteObject"/>
        <import package="java.rmi.server.RemoteRef"/>
        <import package="java.security.AccessController"/>
        <import package="sun.rmi.runtime.Log"/>
        <import package="sun.rmi.transport.Connection"/>
        <import package="sun.rmi.transport.LiveRef"/>
        <import package="sun.rmi.transport.StreamRemoteCall"/>
        <import package="sun.security.action.GetBooleanAction"/>
        <class name="UnicastRef" line="48">
            <comment line="495">
                ----------------------------------------------------------------------;                
            </comment>
            <implements interface="RemoteRef"/>
            <javadoc line="48">
                NOTE: There is a JDK-internal dependency on the existence of this
                  class&apos;s getLiveRef method (as it is inherited by UnicastRef2) in
                  the implementation of javax.management.remote.rmi.RMIConnector.                
            </javadoc>
            <declaration name="clientRefLog" type="Log" line="55"/>
            <javadoc line="55">
                Client-side transport log.                
            </javadoc>
            <declaration name="clientCallLog" type="Log" line="61"/>
            <javadoc line="61">
                Client-side call log.                
            </javadoc>
            <declaration name="ref" type="LiveRef" line="69"/>
            <javadoc line="71">
                Create a new (empty) Unicast remote reference.                
            </javadoc>
            <method name="UnicastRef" type="constructor" line="74"/>
            <javadoc line="77">
                Create a new Unicast RemoteRef.                
            </javadoc>
            <method name="UnicastRef" type="constructor" line="80">
                <params>
                    <param name="liveRef" type="LiveRef"/>
                </params>
            </method>
            <javadoc line="84">
                Returns the current value of this UnicastRef&apos;s underlying
                  LiveRef.
                  NOTE: There is a JDK-internal dependency on the existence of
                  this method (as it is inherited by UnicastRef) in the
                  implementation of javax.management.remote.rmi.RMIConnector.                
            </javadoc>
            <method name="getLiveRef" type="LiveRef" line="92"/>
            <javadoc line="96">
                Invoke a method. This form of delegating method invocation
                  to the reference allows the reference to take care of
                  setting up the connection to the remote host, marshalling
                  some representation for the method and parameters, then
                  communicating the method invocation to the remote host.
                  This method either returns the result of a method invocation
                  on the remote object which resides on the remote host or
                  throws a RemoteException if the call failed or an
                  application-level exception if the remote invocation throws
                  an exception.                
                <param>
                    obj the proxy for the remote object                    
                </param>
                <param>
                    method the method to be invoked                    
                </param>
                <param>
                    params the parameter list                    
                </param>
                <param>
                    opnum  a hash that may be used to represent the method                    
                </param>
                <since>
                    1.2                    
                </since>
            </javadoc>
            <method name="invoke" type="Object" line="119">
                <params>
                    <param name="obj" type="Remote"/>
                    <param name="method" type="Method"/>
                    <param name="params" type="Object[]"/>
                    <param name="opnum" type="long"/>
                </params>
                <comment line="133">
                    If the call connection is &quot;reused&quot; early, remember not to
                     reuse again.                    
                </comment>
                <comment line="143">
                    create call context                    
                </comment>
                <comment line="146">
                    marshal parameters                    
                </comment>
                <comment line="160">
                    unmarshal return                    
                </comment>
                <comment line="169">
                    StreamRemoteCall.done() does not actually make use
                     of conn, therefore it is safe to reuse this
                     connection before the dirty call is sent for
                     registered refs.                    
                </comment>
                <comment line="176">
                    we are freeing the connection now, do not free
                     again or reuse.                    
                </comment>
                <comment line="181">
                                        
                </comment>
                <comment line="184">
                                        
                </comment>
                <comment line="202">
                    WARNING: If the conn has been reused early,
                     then it is too late to recover from thrown
                     IOExceptions caught here. This code is relying
                     on StreamRemoteCall.done() not actually
                     throwing IOExceptions.                    
                </comment>
                <comment line="213">
                    Need to distinguish between client (generated by the
                     invoke method itself) and server RuntimeExceptions.
                     Client side RuntimeExceptions are likely to have
                     corrupted the call connection and those from the server
                     are not likely to have done so.  If the exception came
                     from the server the call connection should be reused.                    
                </comment>
                <comment line="229">
                    Some failure during call; assume connection cannot
                     be reused.  Must assume failure even if ServerException
                     or ServerError occurs since these failures can happen
                     during parameter deserialization which would leave
                     the connection in a corrupted state.                    
                </comment>
                <comment line="240">
                    If errors occurred, the connection is most likely not
                      reusable.                    
                </comment>
                <comment line="248">
                    alreadyFreed ensures that we do not log a reuse that
                     may have already happened.                    
                </comment>
                <scope line="120"/>
                <scope line="124"/>
                <declaration name="conn" type="Connection" line="128"/>
                <declaration name="call" type="RemoteCall" line="129"/>
                <declaration name="reuse" type="boolean" line="130"/>
                <declaration name="alreadyFreed" type="boolean" line="135"/>
                <scope line="137">
                    <scope line="138"/>
                    <scope line="146">
                        <declaration name="out" type="ObjectOutput" line="147"/>
                        <declaration name="types" type="Class&lt;?&gt;[]" line="149"/>
                        <scope line="150"/>
                    </scope>
                    <scope line="153"/>
                    <scope line="162">
                        <declaration name="rtype" type="Class&lt;?&gt;" line="163"/>
                        <declaration name="in" type="ObjectInput" line="166"/>
                        <declaration name="returnValue" type="Object" line="173"/>
                    </scope>
                    <scope line="188"/>
                    <scope line="192"/>
                    <scope line="197">
                        <scope line="198"/>
                        <scope line="200"/>
                    </scope>
                </scope>
                <scope line="211">
                    <scope line="222"/>
                </scope>
                <scope line="227"/>
                <scope line="238"/>
                <scope line="245">
                    <scope line="250">
                        <scope line="251"/>
                    </scope>
                </scope>
            </method>
            <method name="marshalCustomCallData" type="void" line="261">
                <params>
                    <param name="out" type="ObjectOutput"/>
                </params>
            </method>
            <javadoc line="263">
                Marshal value to an ObjectOutput sink using RMI&apos;s serialization
                  format for parameters or return values.                
            </javadoc>
            <method name="marshalValue" type="void" line="270">
                <params>
                    <param name="type" type="Class<?>"/>
                    <param name="value" type="Object"/>
                    <param name="out" type="ObjectOutput"/>
                </params>
                <scope line="271">
                    <scope line="272"/>
                    <scope line="274"/>
                    <scope line="276"/>
                    <scope line="278"/>
                    <scope line="280"/>
                    <scope line="282"/>
                    <scope line="284"/>
                    <scope line="286"/>
                    <scope line="288"/>
                </scope>
                <scope line="291"/>
            </method>
            <javadoc line="296">
                Unmarshal value from an ObjectInput source using RMI&apos;s serialization
                  format for parameters or return values.                
            </javadoc>
            <method name="unmarshalValue" type="Object" line="302">
                <params>
                    <param name="type" type="Class<?>"/>
                    <param name="in" type="ObjectInput"/>
                </params>
                <scope line="303">
                    <scope line="304"/>
                    <scope line="306"/>
                    <scope line="308"/>
                    <scope line="310"/>
                    <scope line="312"/>
                    <scope line="314"/>
                    <scope line="316"/>
                    <scope line="318"/>
                    <scope line="320"/>
                </scope>
                <scope line="323"/>
            </method>
            <javadoc line="328">
                Create an appropriate call object for a new call on this object.
                  Passing operation array and index, allows the stubs generator to
                  assign the operation indexes and interpret them. The RemoteRef
                  may need the operation to encode in for the call.                
            </javadoc>
            <method name="newCall" type="RemoteCall" line="337">
                <params>
                    <param name="obj" type="RemoteObject"/>
                    <param name="ops" type="Operation[]"/>
                    <param name="opnum" type="int"/>
                    <param name="hash" type="long"/>
                </params>
                <comment line="345">
                                        
                </comment>
                <declaration name="conn" type="Connection" line="340"/>
                <scope line="341">
                    <scope line="345"/>
                    <declaration name="call" type="RemoteCall" line="349"/>
                    <scope line="351"/>
                    <scope line="353"/>
                </scope>
                <scope line="358"/>
            </method>
            <javadoc line="364">
                Invoke makes the remote call present in the RemoteCall object.
                  Invoke will raise any &quot;user&quot; exceptions which
                  should pass through and not be caught by the stub.  If any
                  exception is raised during the remote invocation, invoke should
                  take care of cleaning up the connection before raising the
                  &quot;user&quot; or remote exception.                
            </javadoc>
            <method name="invoke" type="void" line="373">
                <params>
                    <param name="call" type="RemoteCall"/>
                </params>
                <comment line="381">
                    Call did not complete; connection can&apos;t be reused.                    
                </comment>
                <comment line="389">
                    If errors occurred, the connection is most likely not
                      reusable.                    
                </comment>
                <comment line="397">
                    REMIND: Since runtime exceptions are no longer wrapped,
                     we can&apos;t assue that the connection was left in
                     a reusable state. Is this okay?                    
                </comment>
                <comment line="407">
                    Assume that these other exceptions are user exceptions
                     and leave the connection in a reusable state.                    
                </comment>
                <comment line="413">
                                        
                </comment>
                <comment line="417">
                    Don&apos;t free the connection if an exception did not
                     occur because the stub needs to unmarshal the
                     return value. The connection will be freed
                     by a call to the &quot;done&quot; method.                    
                </comment>
                <scope line="374"/>
                <scope line="379"/>
                <scope line="387"/>
                <scope line="395"/>
                <scope line="405"/>
            </method>
            <javadoc line="424">
                Private method to free a connection.                
            </javadoc>
            <method name="free" type="void" line="427">
                <params>
                    <param name="call" type="RemoteCall"/>
                    <param name="reuse" type="boolean"/>
                </params>
                <declaration name="conn" type="Connection" line="428"/>
            </method>
            <javadoc line="432">
                Done should only be called if the invoke returns successfully
                  (non-exceptionally) to the stub. It allows the remote reference to
                  clean up (or reuse) the connection.                
            </javadoc>
            <method name="done" type="void" line="437">
                <params>
                    <param name="call" type="RemoteCall"/>
                </params>
                <comment line="440">
                    Done only uses the connection inside the call to obtain the
                     channel the connection uses.  Once all information is read
                     from the connection, the connection may be freed.                    
                </comment>
                <comment line="446">
                                        
                </comment>
                <comment line="452">
                    WARNING: If the conn has been reused early, then it is
                     too late to recover from thrown IOExceptions caught
                     here. This code is relying on StreamRemoteCall.done()
                     not actually throwing IOExceptions.                    
                </comment>
                <scope line="448"/>
                <scope line="450"/>
            </method>
            <javadoc line="459">
                Log the details of an outgoing call.  The method parameter is either of
                  type java.lang.reflect.Method or java.rmi.server.Operation.                
            </javadoc>
            <method name="logClientCall" type="void" line="463">
                <params>
                    <param name="obj" type="Object"/>
                    <param name="method" type="Object"/>
                </params>
            </method>
            <javadoc line="469">
                Returns the class of the ref type to be serialized                
            </javadoc>
            <method name="getRefClass" type="String" line="472">
                <params>
                    <param name="out" type="ObjectOutput"/>
                </params>
            </method>
            <javadoc line="476">
                Write out external representation for remote ref.                
            </javadoc>
            <method name="writeExternal" type="void" line="479">
                <params>
                    <param name="out" type="ObjectOutput"/>
                </params>
            </method>
            <javadoc line="483">
                Read in external representation for remote ref.                
                <exception>
                    ClassNotFoundException If the class for an object
                      being restored cannot be found.                    
                </exception>
            </javadoc>
            <method name="readExternal" type="void" line="490">
                <params>
                    <param name="in" type="ObjectInput"/>
                </params>
            </method>
            <javadoc line="495">
                Method from object, forward from RemoteObject                
            </javadoc>
            <method name="remoteToString" type="String" line="498"/>
            <javadoc line="502">
                default implementation of hashCode for remote objects                
            </javadoc>
            <method name="remoteHashCode" type="int" line="505"/>
            <javadoc line="509">
                default implementation of equals for remote objects                
            </javadoc>
            <method name="remoteEquals" type="boolean" line="511">
                <params>
                    <param name="sub" type="RemoteRef"/>
                </params>
            </method>
        </class>
    </source>