<?xml version="1.0" encoding="UTF-8"?>
    <source package="sun.management">
        <import package="javax.management.ListenerNotFoundException"/>
        <import package="javax.management.MBeanNotificationInfo"/>
        <import package="javax.management.Notification"/>
        <import package="javax.management.NotificationEmitter"/>
        <import package="javax.management.NotificationFilter"/>
        <import package="javax.management.NotificationListener"/>
        <import package="java.util.List"/>
        <import package="java.util.ArrayList"/>
        <import package="java.util.ListIterator"/>
        <import package="java.util.Collections"/>
        <class name="NotificationEmitterSupport" line="40">
            <comment line="51">
                Implementation of NotificationEmitter interface                
            </comment>
            <comment line="52">
                Cloned from JMX NotificationBroadcasterSupport class.                
            </comment>
            <implements interface="NotificationEmitter"/>
            <javadoc line="40">
                Abstract helper class for notification emitter support.                
            </javadoc>
            <method name="NotificationEmitterSupport" type="constructor" line="45"/>
            <declaration name="listenerLock" type="Object" line="48"/>
            <method name="addNotificationListener" type="void" line="54">
                <params>
                    <param name="listener" type="NotificationListener"/>
                    <param name="filter" type="NotificationFilter"/>
                    <param name="handback" type="Object"/>
                </params>
                <comment line="60">
                    Adding a new listener takes O(n) time where n is the number
                    of existing listeners.  If you have a very large number of
                    listeners performance could degrade.  That&apos;s a fairly
                    surprising configuration, and it is hard to avoid this
                    behaviour while still retaining the property that the
                    listenerList is not synchronized while notifications are
                    being sent through it.  If this becomes a problem, a
                    possible solution would be a multiple-readers single-writer
                    setup, so any number of sendNotification() calls could run
                    concurrently but they would exclude an
                    addremoveNotificationListener.  A simpler but less
                    efficient solution would be to clone the listener list                    
                </comment>
                <scope line="56"/>
                <scope line="73">
                    <declaration name="newList" type="List&lt;ListenerInfo&gt;" line="74"/>
                </scope>
            </method>
            <method name="removeNotificationListener" type="void" line="82">
                <params>
                    <param name="listener" type="NotificationListener"/>
                </params>
                <comment line="86">
                    We scan the list of listeners in reverse order because
                    in forward order we would have to repeat the loop with                    
                </comment>
                <scope line="84">
                    <declaration name="newList" type="List&lt;ListenerInfo&gt;" line="85"/>
                    <scope line="89">
                        <declaration name="li" type="ListenerInfo" line="90"/>
                    </scope>
                </scope>
            </method>
            <method name="removeNotificationListener" type="void" line="104">
                <params>
                    <param name="listener" type="NotificationListener"/>
                    <param name="filter" type="NotificationFilter"/>
                    <param name="handback" type="Object"/>
                </params>
                <comment line="127">
                    We found this listener, but not with the given filter
                     and handback.  A more informative exception message may                    
                </comment>
                <declaration name="found" type="boolean" line="106"/>
                <scope line="108">
                    <declaration name="newList" type="List&lt;ListenerInfo&gt;" line="109"/>
                    <declaration name="size" type="int" line="110"/>
                    <scope line="111">
                        <declaration name="li" type="ListenerInfo" line="112"/>
                        <scope line="114">
                            <scope line="117"/>
                        </scope>
                    </scope>
                </scope>
                <scope line="126"/>
                <scope line="133"/>
            </method>
            <method name="sendNotification" type="void" line="138">
                <params>
                    <param name="notification" type="Notification"/>
                </params>
                <scope line="140"/>
                <declaration name="currentList" type="List&lt;ListenerInfo&gt;" line="144"/>
                <scope line="145"/>
                <declaration name="size" type="int" line="149"/>
                <scope line="150">
                    <declaration name="li" type="ListenerInfo" line="151"/>
                    <scope line="154">
                        <scope line="155"/>
                        <scope line="157"/>
                    </scope>
                </scope>
            </method>
            <method name="hasListeners" type="boolean" line="165">
                <scope line="166"/>
            </method>
            <class name="ListenerInfo" line="171">
                <declaration name="listener" type="NotificationListener" line="172"/>
                <declaration name="filter" type="NotificationFilter" line="173"/>
                <declaration name="handback" type="Object" line="174"/>
                <method name="ListenerInfo" type="constructor" line="178">
                    <params>
                        <param name="listener" type="NotificationListener"/>
                        <param name="filter" type="NotificationFilter"/>
                        <param name="handback" type="Object"/>
                    </params>
                </method>
            </class>
            <declaration name="listenerList" type="List&lt;ListenerInfo&gt;" line="185"/>
            <javadoc line="185">
                Current list of listeners, a List of ListenerInfo.  The object
                  referenced by this field is never modified.  Instead, the field
                  is set to a new object when a listener is added or removed,
                  within a synchronized(this).  In this way, there is no need to
                  synchronize when traversing the list to send a notification to
                  the listeners in it.  That avoids potential deadlocks if the
                  listeners end up depending on other threads that are themselves
                  accessing this NotificationBroadcasterSupport.                
            </javadoc>
            <method name="getNotificationInfo" type="MBeanNotificationInfo[]" line="197"/>
        </class>
    </source>