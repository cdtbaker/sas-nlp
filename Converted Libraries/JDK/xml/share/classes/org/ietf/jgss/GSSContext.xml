<?xml version="1.0" encoding="UTF-8"?>
    <source package="org.ietf.jgss">
        <import package="sun.security.jgss.spi"/>
        <import package="java.io.InputStream"/>
        <import package="java.io.OutputStream"/>
        <interface name="GSSContext">
            <javadoc line="32">
                This interface encapsulates the GSS-API security context and provides
                  the security services that are available over the context.  Security
                  contexts are established between peers using locally acquired
                  credentials.  Multiple contexts may exist simultaneously between a pair
                  of peers, using the same or different set of credentials.  GSS-API
                  functions in a manner independent of the underlying transport protocol
                  and depends on its calling application to transport the tokens that are
                  generated by the security context between the peers.&lt;p&gt;
                  If the caller instantiates the context using the default
                  &lt;code&gt;GSSManager&lt;/code&gt; instance, then the Kerberos v5 GSS-API mechanism
                  is guaranteed to be available for context establishment. This mechanism
                  is identified by the Oid &quot;1.2.840.113554.1.2.2&quot; and is defined in RFC
                  1964.&lt;p&gt;
                  Before the context establishment phase is initiated, the context
                  initiator may request specific characteristics desired of the
                  established context. Not all underlying mechanisms support all
                  characteristics that a caller might desire. After the context is
                  established, the caller can check the actual characteristics and services
                  offered by that context by means of various query methods. When using
                  the Kerberos v5 GSS-API mechanism offered by the default
                  &lt;code&gt;GSSManager&lt;/code&gt; instance, all optional services will be
                  available locally. They are mutual authentication, credential
                  delegation, confidentiality and integrity protection, and per-message
                  replay detection and sequencing. Note that in the GSS-API, message integrity
                  is a prerequisite for message confidentiality.&lt;p&gt;
                  The context establishment occurs in a loop where the
                  initiator calls {@link #initSecContext(byte[],int,int) initSecContext}and the acceptor calls {@link #acceptSecContext(byte[],int,int)acceptSecContext} until the context is established. While in this loop
                  the &lt;code&gt;initSecContext&lt;/code&gt; and &lt;code&gt;acceptSecContext&lt;/code&gt;
                  methods produce tokens that the application sends over to the peer. The
                  peer passes any such token as input to its &lt;code&gt;acceptSecContext&lt;/code&gt;
                  or &lt;code&gt;initSecContext&lt;/code&gt; as the case may be.&lt;p&gt;
                  During the context establishment phase, the {@link #isProtReady() isProtReady} method may be called to determine if the
                  context can be used for the per-message operations of {@link #wrap(byte[],int,int,MessageProp) wrap} and {@link #getMIC(byte[],int,int,MessageProp) getMIC}.  This allows applications to use
                  per-message operations on contexts which aren&apos;t yet fully
                  established.&lt;p&gt;
                  After the context has been established or the &lt;code&gt;isProtReady&lt;/code&gt;
                  method returns &lt;code&gt;true&lt;/code&gt;, the query routines can be invoked to
                  determine the actual characteristics and services of the established
                  context.  The application can also start using the per-message methods
                  of {@link #wrap(byte[],int,int,MessageProp) wrap} and{@link #getMIC(byte[],int,int,MessageProp) getMIC} to obtain
                  cryptographic operations on application supplied data.&lt;p&gt;
                  When the context is no longer needed, the application should call{@link #dispose() dispose} to release any system resources the context
                  may be using.&lt;p&gt;
                  A security context typically maintains sequencing and replay detection
                  information about the tokens it processes. Therefore, the sequence in
                  which any tokens are presented to this context for processing can be
                  important. Also note that none of the methods in this interface are
                  synchronized. Therefore, it is not advisable to share a
                  &lt;code&gt;GSSContext&lt;/code&gt; among several threads unless some application
                  level synchronization is in place.&lt;p&gt;
                  Finally, different mechanism providers might place different security
                  restrictions on using GSS-API contexts. These will be documented by the
                  mechanism provider. The application will need to ensure that it has the
                  appropriate permissions if such checks are made in the mechanism layer.&lt;p&gt;
                  The example code presented below demonstrates the usage of the
                  &lt;code&gt;GSSContext&lt;/code&gt; interface for the initiating peer.  Different
                  operations on the &lt;code&gt;GSSContext&lt;/code&gt; object are presented,
                  including: object instantiation, setting of desired flags, context
                  establishment, query of actual context flags, per-message operations on
                  application data, and finally context deletion.&lt;p&gt;
                  &lt;pre&gt;
                  // Create a context using default credentials
                  // and the implementation specific default mechanism
                  GSSManager manager ...
                  GSSName targetName ...
                  GSSContext context = manager.createContext(targetName, null, null,
                  GSSContext.INDEFINITE_LIFETIME);
                  // set desired context options prior to context establishment
                  context.requestConf(true);
                  context.requestMutualAuth(true);
                  context.requestReplayDet(true);
                  context.requestSequenceDet(true);
                  // establish a context between peers
                  byte []inToken = new byte[0];
                  // Loop while there still is a token to be processed
                  while (!context.isEstablished()) {
                  byte[] outToken
                  = context.initSecContext(inToken, 0, inToken.length);
                  // send the output token if generated
                  if (outToken != null)
                  sendToken(outToken);
                  if (!context.isEstablished()) {
                  inToken = readToken();
                  }
                  // display context information
                  System.out.println(&quot;Remaining lifetime in seconds = &quot;
                  + context.getLifetime());
                  System.out.println(&quot;Context mechanism = &quot; + context.getMech());
                  System.out.println(&quot;Initiator = &quot; + context.getSrcName());
                  System.out.println(&quot;Acceptor = &quot; + context.getTargName());
                  if (context.getConfState())
                  System.out.println(&quot;Confidentiality (i.e., privacy) is available&quot;);
                  if (context.getIntegState())
                  System.out.println(&quot;Integrity is available&quot;);
                  // perform wrap on an application supplied message, appMsg,
                  // using QOP = 0, and requesting privacy service
                  byte [] appMsg ...
                  MessageProp mProp = new MessageProp(0, true);
                  byte []tok = context.wrap(appMsg, 0, appMsg.length, mProp);
                  sendToken(tok);
                  // release the local-end of the context
                  context.dispose();
                  &lt;/pre&gt;                
                <author>
                    Mayank Upadhyay                    
                </author>
                <since>
                    1.4                    
                </since>
            </javadoc>
            <declaration name="DEFAULT_LIFETIME" type="int" line="176"/>
            <javadoc line="176">
                A lifetime constant representing the default context lifetime.  This
                  value is set to 0.                
            </javadoc>
            <declaration name="INDEFINITE_LIFETIME" type="int" line="182"/>
            <javadoc line="182">
                A lifetime constant representing indefinite context lifetime.
                  This value must is set to the maximum integer value in Java -{@link java.lang.Integer#MAX_VALUE Integer.MAX_VALUE}.                
            </javadoc>
            <method name="initSecContext" type="byte[]" line="189"/>
            <javadoc line="189">
                Called by the context initiator to start the context creation
                  phase and process any tokens generated
                  by the peer&apos;s &lt;code&gt;acceptSecContext&lt;/code&gt; method.
                  This method may return an output token which the application will need
                  to send to the peer for processing by its &lt;code&gt;acceptSecContext&lt;/code&gt;
                  method. The application can call {@link #isEstablished()isEstablished} to determine if the context establishment phase is
                  complete on this side of the context.  A return value of
                  &lt;code&gt;false&lt;/code&gt; from &lt;code&gt;isEstablished&lt;/code&gt; indicates that
                  more tokens are expected to be supplied to
                  &lt;code&gt;initSecContext&lt;/code&gt;.  Upon completion of the context
                  establishment, the available context options may be queried through
                  the get methods.&lt;p&gt;
                  Note that it is possible that the &lt;code&gt;initSecContext&lt;/code&gt; method
                  return a token for the peer, and &lt;code&gt;isEstablished&lt;/code&gt; return
                  &lt;code&gt;true&lt;/code&gt; also. This indicates that the token needs to be sent
                  to the peer, but the local end of the context is now fully
                  established.&lt;p&gt;
                  Some mechanism providers might require that the caller be granted
                  permission to initiate a security context. A failed permission check
                  might cause a {@link java.lang.SecurityException SecurityException}to be thrown from this method.&lt;p&gt;                
                <return>
                    a byte[] containing the token to be sent to the
                      peer. &lt;code&gt;null&lt;/code&gt; indicates that no token is generated.                    
                </return>
                <param>
                    inputBuf token generated by the peer. This parameter is ignored
                      on the first call since no token has been received from the peer.                    
                </param>
                <param>
                    offset the offset within the inputBuf where the token begins.                    
                </param>
                <param>
                    len the length of the token.                    
                </param>
                <throws>
                    GSSException containing the following
                      major error codes:{@link GSSException#DEFECTIVE_TOKEN GSSException.DEFECTIVE_TOKEN},{@link GSSException#BAD_MIC GSSException.BAD_MIC},{@link GSSException#NO_CRED GSSException.NO_CRED},{@link GSSException#CREDENTIALS_EXPIREDGSSException.CREDENTIALS_EXPIRED},{@link GSSException#BAD_BINDINGS GSSException.BAD_BINDINGS},{@link GSSException#OLD_TOKEN GSSException.OLD_TOKEN},{@link GSSException#DUPLICATE_TOKEN GSSException.DUPLICATE_TOKEN},{@link GSSException#BAD_NAMETYPE GSSException.BAD_NAMETYPE},{@link GSSException#BAD_MECH GSSException.BAD_MECH},{@link GSSException#FAILURE GSSException.FAILURE}                    
                </throws>
            </javadoc>
            <method name="initSecContext" type="int" line="239"/>
            <javadoc line="239">
                Called by the context initiator to start the context creation
                  phase and process any tokens generated
                  by the peer&apos;s &lt;code&gt;acceptSecContext&lt;/code&gt; method using
                  streams. This method may write an output token to the
                  &lt;code&gt;OutpuStream&lt;/code&gt;, which the application will
                  need to send to the peer for processing by its
                  &lt;code&gt;acceptSecContext&lt;/code&gt; call. Typically, the application would
                  ensure this by calling the  {@link java.io.OutputStream#flush() flush}method on an &lt;code&gt;OutputStream&lt;/code&gt; that encapsulates the
                  connection between the two peers. The application can
                  determine if a token is written to the OutputStream from the return
                  value of this method. A return value of &lt;code&gt;0&lt;/code&gt; indicates that
                  no token was written. The application can call{@link #isEstablished() isEstablished} to determine if the context
                  establishment phase is complete on this side of the context. A
                  return  value of &lt;code&gt;false&lt;/code&gt; from &lt;code&gt;isEstablished&lt;/code&gt;
                  indicates that more tokens are expected to be supplied to
                  &lt;code&gt;initSecContext&lt;/code&gt;.
                  Upon completion of the context establishment, the available context
                  options may be queried through the get methods.&lt;p&gt;
                  Note that it is possible that the &lt;code&gt;initSecContext&lt;/code&gt; method
                  return a token for the peer, and &lt;code&gt;isEstablished&lt;/code&gt; return
                  &lt;code&gt;true&lt;/code&gt; also. This indicates that the token needs to be sent
                  to the peer, but the local end of the context is now fully
                  established.&lt;p&gt;
                  The GSS-API authentication tokens contain a definitive start and
                  end. This method will attempt to read one of these tokens per
                  invocation, and may block on the stream if only part of the token is
                  available.  In all other respects this method is equivalent to the
                  byte array based {@link #initSecContext(byte[],int,int)initSecContext}.&lt;p&gt;
                  Some mechanism providers might require that the caller be granted
                  permission to initiate a security context. A failed permission check
                  might cause a {@link java.lang.SecurityException SecurityException}to be thrown from this method.&lt;p&gt;
                  The following example code demonstrates how this method might be
                  used:&lt;p&gt;
                  &lt;pre&gt;
                  InputStream is ...
                  OutputStream os ...
                  GSSContext context ...
                  // Loop while there is still a token to be processed
                  while (!context.isEstablished()) {
                  context.initSecContext(is, os);
                  // send output token if generated
                  os.flush();
                  }
                  &lt;/pre&gt;                
                <return>
                    the number of bytes written to the OutputStream as part of the
                      token to be sent to the peer. A value of 0 indicates that no token
                      needs to be sent.                    
                </return>
                <param>
                    inStream an InputStream that contains the token generated by
                      the peer. This parameter is ignored on the first call since no token
                      has been or will be received from the peer at that point.                    
                </param>
                <param>
                    outStream an OutputStream where the output token will be
                      written. During the final stage of context establishment, there may be
                      no bytes written.                    
                </param>
                <throws>
                    GSSException containing the following
                      major error codes:{@link GSSException#DEFECTIVE_TOKEN GSSException.DEFECTIVE_TOKEN},{@link GSSException#BAD_MIC GSSException.BAD_MIC},{@link GSSException#NO_CRED GSSException.NO_CRED},{@link GSSException#CREDENTIALS_EXPIRED GSSException.CREDENTIALS_EXPIRED},{@link GSSException#BAD_BINDINGS GSSException.BAD_BINDINGS},{@link GSSException#OLD_TOKEN GSSException.OLD_TOKEN},{@link GSSException#DUPLICATE_TOKEN GSSException.DUPLICATE_TOKEN},{@link GSSException#BAD_NAMETYPE GSSException.BAD_NAMETYPE},{@link GSSException#BAD_MECH GSSException.BAD_MECH},{@link GSSException#FAILURE GSSException.FAILURE}                    
                </throws>
            </javadoc>
            <method name="acceptSecContext" type="byte[]" line="324"/>
            <javadoc line="324">
                Called by the context acceptor upon receiving a token from the
                  peer. This method may return an output token which the application
                  will need to send to the peer for further processing by its
                  &lt;code&gt;initSecContext&lt;/code&gt; call.&lt;p&gt;
                  The application can call {@link #isEstablished() isEstablished} to
                  determine if the context establishment phase is complete for this
                  peer.  A return value of &lt;code&gt;false&lt;/code&gt; from
                  &lt;code&gt;isEstablished&lt;/code&gt; indicates that more tokens are expected to
                  be supplied to this method.    Upon completion of the context
                  establishment, the available context options may be queried through
                  the get methods.&lt;p&gt;
                  Note that it is possible that &lt;code&gt;acceptSecContext&lt;/code&gt; return a
                  token for the peer, and &lt;code&gt;isEstablished&lt;/code&gt; return
                  &lt;code&gt;true&lt;/code&gt; also.  This indicates that the token needs to be
                  sent to the peer, but the local end of the context is now fully
                  established.&lt;p&gt;
                  Some mechanism providers might require that the caller be granted
                  permission to accept a security context. A failed permission check
                  might cause a {@link java.lang.SecurityException SecurityException}to be thrown from this method.&lt;p&gt;
                  The following example code demonstrates how this method might be
                  used:&lt;p&gt;
                  &lt;pre&gt;
                  byte[] inToken;
                  byte[] outToken;
                  GSSContext context ...
                  // Loop while there is still a token to be processed
                  while (!context.isEstablished()) {
                  inToken = readToken();
                  outToken = context.acceptSecContext(inToken, 0,
                  inToken.length);
                  // send output token if generated
                  if (outToken != null)
                  sendToken(outToken);
                  }
                  &lt;/pre&gt;                
                <return>
                    a byte[] containing the token to be sent to the
                      peer. &lt;code&gt;null&lt;/code&gt; indicates that no token is generated.                    
                </return>
                <param>
                    inToken token generated by the peer.                    
                </param>
                <param>
                    offset the offset within the inToken where the token begins.                    
                </param>
                <param>
                    len the length of the token.                    
                </param>
                <throws>
                    GSSException containing the following
                      major error codes:{@link GSSException#DEFECTIVE_TOKEN GSSException.DEFECTIVE_TOKEN},{@link GSSException#BAD_MIC GSSException.BAD_MIC},{@link GSSException#NO_CRED GSSException.NO_CRED},{@link GSSException#CREDENTIALS_EXPIREDGSSException.CREDENTIALS_EXPIRED},{@link GSSException#BAD_BINDINGS GSSException.BAD_BINDINGS},{@link GSSException#OLD_TOKEN GSSException.OLD_TOKEN},{@link GSSException#DUPLICATE_TOKEN GSSException.DUPLICATE_TOKEN},{@link GSSException#BAD_MECH GSSException.BAD_MECH},{@link GSSException#FAILURE GSSException.FAILURE}                    
                </throws>
            </javadoc>
            <method name="acceptSecContext" type="void" line="391"/>
            <javadoc line="391">
                Called by the context acceptor to process a token from the peer using
                  streams.   It may write an output token to the
                  &lt;code&gt;OutputStream&lt;/code&gt;, which the application
                  will need to send to the peer for processing by its
                  &lt;code&gt;initSecContext&lt;/code&gt; method.  Typically, the application would
                  ensure this by calling the  {@link java.io.OutputStream#flush() flush}method on an &lt;code&gt;OutputStream&lt;/code&gt; that encapsulates the
                  connection between the two peers. The application can call{@link #isEstablished() isEstablished} to determine if the context
                  establishment phase is complete on this side of the context. A
                  return  value of &lt;code&gt;false&lt;/code&gt; from &lt;code&gt;isEstablished&lt;/code&gt;
                  indicates that more tokens are expected to be supplied to
                  &lt;code&gt;acceptSecContext&lt;/code&gt;.
                  Upon completion of the context establishment, the available context
                  options may be queried through the get methods.&lt;p&gt;
                  Note that it is possible that &lt;code&gt;acceptSecContext&lt;/code&gt; return a
                  token for the peer, and &lt;code&gt;isEstablished&lt;/code&gt; return
                  &lt;code&gt;true&lt;/code&gt; also.  This indicates that the token needs to be
                  sent to the peer, but the local end of the context is now fully
                  established.&lt;p&gt;
                  The GSS-API authentication tokens contain a definitive start and
                  end. This method will attempt to read one of these tokens per
                  invocation, and may block on the stream if only part of the token is
                  available. In all other respects this method is equivalent to the byte
                  array based {@link #acceptSecContext(byte[],int,int)acceptSecContext}.&lt;p&gt;
                  Some mechanism providers might require that the caller be granted
                  permission to accept a security context. A failed permission check
                  might cause a {@link java.lang.SecurityException SecurityException}to be thrown from this method.&lt;p&gt;
                  The following example code demonstrates how this method might be
                  used:&lt;p&gt;
                  &lt;pre&gt;
                  InputStream is ...
                  OutputStream os ...
                  GSSContext context ...
                  // Loop while there is still a token to be processed
                  while (!context.isEstablished()) {
                  context.acceptSecContext(is, os);
                  // send output token if generated
                  os.flush();
                  }
                  &lt;/pre&gt;                
                <param>
                    inStream an InputStream that contains the token generated by
                      the peer.                    
                </param>
                <param>
                    outStream an OutputStream where the output token will be
                      written. During the final stage of context establishment, there may be
                      no bytes written.                    
                </param>
                <throws>
                    GSSException containing the following
                      major error codes:{@link GSSException#DEFECTIVE_TOKEN GSSException.DEFECTIVE_TOKEN},{@link GSSException#BAD_MIC GSSException.BAD_MIC},{@link GSSException#NO_CRED GSSException.NO_CRED},{@link GSSException#CREDENTIALS_EXPIREDGSSException.CREDENTIALS_EXPIRED},{@link GSSException#BAD_BINDINGS GSSException.BAD_BINDINGS},{@link GSSException#OLD_TOKEN GSSException.OLD_TOKEN},{@link GSSException#DUPLICATE_TOKEN GSSException.DUPLICATE_TOKEN},{@link GSSException#BAD_MECH GSSException.BAD_MECH},{@link GSSException#FAILURE GSSException.FAILURE}                    
                </throws>
            </javadoc>
            <method name="isEstablished" type="boolean" line="479"/>
            <javadoc line="479">
                Used during context establishment to determine the state of the
                  context.                
                <return>
                    &lt;code&gt;true&lt;/code&gt; if this is a fully established context on
                      the caller&apos;s side and no more tokens are needed from the peer.                    
                </return>
            </javadoc>
            <method name="dispose" type="void" line="488"/>
            <javadoc line="488">
                Releases any system resources and cryptographic information stored in
                  the context object and invalidates the context.                
                <throws>
                    GSSException containing the following
                      major error codes:{@link GSSException#FAILURE GSSException.FAILURE}                    
                </throws>
            </javadoc>
            <method name="getWrapSizeLimit" type="int" line="499"/>
            <javadoc line="499">
                Used to determine limits on the size of the message
                  that can be passed to &lt;code&gt;wrap&lt;/code&gt;. Returns the maximum
                  message size that, if presented to the &lt;code&gt;wrap&lt;/code&gt; method with
                  the same &lt;code&gt;confReq&lt;/code&gt; and &lt;code&gt;qop&lt;/code&gt; parameters, will
                  result in an output token containing no more
                  than &lt;code&gt;maxTokenSize&lt;/code&gt; bytes.&lt;p&gt;
                  This call is intended for use by applications that communicate over
                  protocols that impose a maximum message size.  It enables the
                  application to fragment messages prior to applying protection.&lt;p&gt;
                  GSS-API implementations are recommended but not required to detect
                  invalid QOP values when &lt;code&gt;getWrapSizeLimit&lt;/code&gt; is called.
                  This routine guarantees only a maximum message size, not the
                  availability of specific QOP values for message protection.&lt;p&gt;                
                <param>
                    qop the level of protection wrap will be asked to provide.                    
                </param>
                <param>
                    confReq &lt;code&gt;true&lt;/code&gt; if wrap will be asked to provide
                      privacy, &lt;code&gt;false&lt;/code&gt;  otherwise.                    
                </param>
                <param>
                    maxTokenSize the desired maximum size of the token emitted by
                      wrap.                    
                </param>
                <return>
                    the maximum size of the input token for the given output
                      token size                    
                </return>
                <throws>
                    GSSException containing the following
                      major error codes:{@link GSSException#CONTEXT_EXPIRED GSSException.CONTEXT_EXPIRED},{@link GSSException#BAD_QOP GSSException.BAD_QOP},{@link GSSException#FAILURE GSSException.FAILURE}                    
                </throws>
            </javadoc>
            <method name="wrap" type="byte[]" line="533"/>
            <javadoc line="533">
                Applies per-message security services over the established security
                  context. The method will return a token with the
                  application supplied data and a cryptographic MIC over it.
                  The data may be encrypted if confidentiality (privacy) was
                  requested.&lt;p&gt;
                  The MessageProp object is instantiated by the application and used
                  to specify a QOP value which selects cryptographic algorithms, and a
                  privacy service to optionally encrypt the message.  The underlying
                  mechanism that is used in the call may not be able to provide the
                  privacy service.  It sets the actual privacy service that it does
                  provide in this MessageProp object which the caller should then
                  query upon return.  If the mechanism is not able to provide the
                  requested QOP, it throws a GSSException with the BAD_QOP code.&lt;p&gt;
                  Since some application-level protocols may wish to use tokens
                  emitted by wrap to provide &quot;secure framing&quot;, implementations should
                  support the wrapping of zero-length messages.&lt;p&gt;
                  The application will be responsible for sending the token to the
                  peer.                
                <param>
                    inBuf application data to be protected.                    
                </param>
                <param>
                    offset the offset within the inBuf where the data begins.                    
                </param>
                <param>
                    len the length of the data                    
                </param>
                <param>
                    msgProp instance of MessageProp that is used by the
                      application to set the desired QOP and privacy state. Set the
                      desired QOP to 0 to request the default QOP. Upon return from this
                      method, this object will contain the the actual privacy state that
                      was applied to the message by the underlying mechanism.                    
                </param>
                <return>
                    a byte[] containing the token to be sent to the peer.                    
                </return>
                <throws>
                    GSSException containing the following major error codes:{@link GSSException#CONTEXT_EXPIRED GSSException.CONTEXT_EXPIRED},{@link GSSException#BAD_QOP GSSException.BAD_QOP},{@link GSSException#FAILURE GSSException.FAILURE}                    
                </throws>
            </javadoc>
            <method name="wrap" type="void" line="574"/>
            <javadoc line="574">
                Applies per-message security services over the established security
                  context using streams. The method will return a
                  token with the application supplied data and a cryptographic MIC over it.
                  The data may be encrypted if confidentiality
                  (privacy) was requested. This method is equivalent to the byte array
                  based {@link #wrap(byte[],int,int,MessageProp) wrap} method.&lt;p&gt;
                  The application will be responsible for sending the token to the
                  peer.  Typically, the application would
                  ensure this by calling the  {@link java.io.OutputStream#flush() flush}method on an &lt;code&gt;OutputStream&lt;/code&gt; that encapsulates the
                  connection between the two peers.&lt;p&gt;
                  The MessageProp object is instantiated by the application and used
                  to specify a QOP value which selects cryptographic algorithms, and a
                  privacy service to optionally encrypt the message.  The underlying
                  mechanism that is used in the call may not be able to provide the
                  privacy service.  It sets the actual privacy service that it does
                  provide in this MessageProp object which the caller should then
                  query upon return.  If the mechanism is not able to provide the
                  requested QOP, it throws a GSSException with the BAD_QOP code.&lt;p&gt;
                  Since some application-level protocols may wish to use tokens
                  emitted by wrap to provide &quot;secure framing&quot;, implementations should
                  support the wrapping of zero-length messages.&lt;p&gt;                
                <param>
                    inStream an InputStream containing the application data to be
                      protected. All of the data that is available in
                      inStream is used.                    
                </param>
                <param>
                    outStream an OutputStream to write the protected message
                      to.                    
                </param>
                <param>
                    msgProp instance of MessageProp that is used by the
                      application to set the desired QOP and privacy state. Set the
                      desired QOP to 0 to request the default QOP. Upon return from this
                      method, this object will contain the the actual privacy state that
                      was applied to the message by the underlying mechanism.                    
                </param>
                <throws>
                    GSSException containing the following
                      major error codes:{@link GSSException#CONTEXT_EXPIRED GSSException.CONTEXT_EXPIRED},{@link GSSException#BAD_QOP GSSException.BAD_QOP},{@link GSSException#FAILURE GSSException.FAILURE}                    
                </throws>
            </javadoc>
            <method name="unwrap" type="byte[]" line="621"/>
            <javadoc line="621">
                Used to process tokens generated by the &lt;code&gt;wrap&lt;/code&gt; method on
                  the other side of the context. The method will return the message
                  supplied by the peer application to its wrap call, while at the same
                  time verifying the embedded MIC for that message.&lt;p&gt;
                  The MessageProp object is instantiated by the application and is
                  used by the underlying mechanism to return information to the caller
                  such as the QOP, whether confidentiality was applied to the message,
                  and other supplementary message state information.&lt;p&gt;
                  Since some application-level protocols may wish to use tokens
                  emitted by wrap to provide &quot;secure framing&quot;, implementations should
                  support the wrapping and unwrapping of zero-length messages.&lt;p&gt;                
                <param>
                    inBuf a byte array containing the wrap token received from
                      peer.                    
                </param>
                <param>
                    offset the offset where the token begins.                    
                </param>
                <param>
                    len the length of the token                    
                </param>
                <param>
                    msgProp upon return from the method, this object will contain
                      the applied QOP, the privacy state of the message, and supplementary
                      information stating if the token was a duplicate, old, out of
                      sequence or arriving after a gap.                    
                </param>
                <return>
                    a byte[] containing the message unwrapped from the input
                      token.                    
                </return>
                <throws>
                    GSSException containing the following
                      major error codes:{@link GSSException#DEFECTIVE_TOKEN GSSException.DEFECTIVE_TOKEN},{@link GSSException#BAD_MIC GSSException.BAD_MIC},{@link GSSException#CONTEXT_EXPIRED GSSException.CONTEXT_EXPIRED},{@link GSSException#FAILURE GSSException.FAILURE}                    
                </throws>
            </javadoc>
            <method name="unwrap" type="void" line="657"/>
            <javadoc line="657">
                Uses streams to process tokens generated by the &lt;code&gt;wrap&lt;/code&gt;
                  method on the other side of the context. The method will return the
                  message supplied by the peer application to its wrap call, while at
                  the same time verifying the embedded MIC for that message.&lt;p&gt;
                  The MessageProp object is instantiated by the application and is
                  used by the underlying mechanism to return information to the caller
                  such as the QOP, whether confidentiality was applied to the message,
                  and other supplementary message state information.&lt;p&gt;
                  Since some application-level protocols may wish to use tokens
                  emitted by wrap to provide &quot;secure framing&quot;, implementations should
                  support the wrapping and unwrapping of zero-length messages.&lt;p&gt;
                  The format of the input token that this method
                  reads is defined in the specification for the underlying mechanism that
                  will be used. This method will attempt to read one of these tokens per
                  invocation. If the mechanism token contains a definitive start and
                  end this method may block on the &lt;code&gt;InputStream&lt;/code&gt; if only
                  part of the token is available. If the start and end of the token
                  are not definitive then the method will attempt to treat all
                  available bytes as part of the token.&lt;p&gt;
                  Other than the possible blocking behavior described above, this
                  method is equivalent to the byte array based {@link #unwrap(byte[],int,int,MessageProp) unwrap} method.&lt;p&gt;                
                <param>
                    inStream an InputStream that contains the wrap token generated
                      by the peer.                    
                </param>
                <param>
                    outStream an OutputStream to write the application message
                      to.                    
                </param>
                <param>
                    msgProp upon return from the method, this object will contain
                      the applied QOP, the privacy state of the message, and supplementary
                      information stating if the token was a duplicate, old, out of
                      sequence or arriving after a gap.                    
                </param>
                <throws>
                    GSSException containing the following
                      major error codes:{@link GSSException#DEFECTIVE_TOKEN GSSException.DEFECTIVE_TOKEN},{@link GSSException#BAD_MIC GSSException.BAD_MIC},{@link GSSException#CONTEXT_EXPIRED GSSException.CONTEXT_EXPIRED},{@link GSSException#FAILURE GSSException.FAILURE}                    
                </throws>
            </javadoc>
            <method name="getMIC" type="byte[]" line="704"/>
            <javadoc line="704">
                Returns a token containing a cryptographic Message Integrity Code
                  (MIC) for the supplied message,  for transfer to the peer
                  application.  Unlike wrap, which encapsulates the user message in the
                  returned token, only the message MIC is returned in the output
                  token.&lt;p&gt;
                  Note that privacy can only be applied through the wrap call.&lt;p&gt;
                  Since some application-level protocols may wish to use tokens emitted
                  by getMIC to provide &quot;secure framing&quot;, implementations should support
                  derivation of MICs from zero-length messages.                
                <param>
                    inMsg the message to generate the MIC over.                    
                </param>
                <param>
                    offset offset within the inMsg where the message begins.                    
                </param>
                <param>
                    len the length of the message                    
                </param>
                <param>
                    msgProp an instance of &lt;code&gt;MessageProp&lt;/code&gt; that is used
                      by the application to set the desired QOP.  Set the desired QOP to
                      &lt;code&gt;0&lt;/code&gt; in &lt;code&gt;msgProp&lt;/code&gt; to request the default
                      QOP. Alternatively pass in &lt;code&gt;null&lt;/code&gt; for &lt;code&gt;msgProp&lt;/code&gt;
                      to request the default QOP.                    
                </param>
                <return>
                    a byte[] containing the token to be sent to the peer.                    
                </return>
                <throws>
                    GSSException containing the following
                      major error codes:{@link GSSException#CONTEXT_EXPIRED GSSException.CONTEXT_EXPIRED},{@link GSSException#BAD_QOP GSSException.BAD_QOP},{@link GSSException#FAILURE GSSException.FAILURE}                    
                </throws>
            </javadoc>
            <method name="getMIC" type="void" line="736"/>
            <javadoc line="736">
                Uses streams to produce a token containing a cryptographic MIC for
                  the supplied message, for transfer to the peer application.
                  Unlike wrap, which encapsulates the user message in the returned
                  token, only the message MIC is produced in the output token. This
                  method is equivalent to the byte array based {@link #getMIC(byte[],int,int,MessageProp) getMIC} method.
                  Note that privacy can only be applied through the wrap call.&lt;p&gt;
                  Since some application-level protocols may wish to use tokens emitted
                  by getMIC to provide &quot;secure framing&quot;, implementations should support
                  derivation of MICs from zero-length messages.                
                <param>
                    inStream an InputStream containing the message to generate the
                      MIC over. All of the data that is available in
                      inStream is used.                    
                </param>
                <param>
                    outStream an OutputStream to write the output token to.                    
                </param>
                <param>
                    msgProp an instance of &lt;code&gt;MessageProp&lt;/code&gt; that is used
                      by the application to set the desired QOP.  Set the desired QOP to
                      &lt;code&gt;0&lt;/code&gt; in &lt;code&gt;msgProp&lt;/code&gt; to request the default
                      QOP. Alternatively pass in &lt;code&gt;null&lt;/code&gt; for &lt;code&gt;msgProp&lt;/code&gt;
                      to request the default QOP.                    
                </param>
                <throws>
                    GSSException containing the following
                      major error codes:{@link GSSException#CONTEXT_EXPIRED GSSException.CONTEXT_EXPIRED},{@link GSSException#BAD_QOP GSSException.BAD_QOP},{@link GSSException#FAILURE GSSException.FAILURE}                    
                </throws>
            </javadoc>
            <method name="verifyMIC" type="void" line="769"/>
            <javadoc line="769">
                Verifies the cryptographic MIC, contained in the token parameter,
                  over the supplied message.&lt;p&gt;
                  The MessageProp object is instantiated by the application and is used
                  by the underlying mechanism to return information to the caller such
                  as the QOP indicating the strength of protection that was applied to
                  the message and other supplementary message state information.&lt;p&gt;
                  Since some application-level protocols may wish to use tokens emitted
                  by getMIC to provide &quot;secure framing&quot;, implementations should support
                  the calculation and verification of MICs over zero-length messages.                
                <param>
                    inToken the token generated by peer&apos;s getMIC method.                    
                </param>
                <param>
                    tokOffset the offset within the inToken where the token
                      begins.                    
                </param>
                <param>
                    tokLen the length of the token.                    
                </param>
                <param>
                    inMsg the application message to verify the cryptographic MIC
                      over.                    
                </param>
                <param>
                    msgOffset the offset in inMsg where the message begins.                    
                </param>
                <param>
                    msgLen the length of the message.                    
                </param>
                <param>
                    msgProp upon return from the method, this object will contain
                      the applied QOP and supplementary information stating if the token
                      was a duplicate, old, out of sequence or arriving after a gap.                    
                </param>
                <throws>
                    GSSException containing the following
                      major error codes:{@link GSSException#DEFECTIVE_TOKEN GSSException.DEFECTIVE_TOKEN}{@link GSSException#BAD_MIC GSSException.BAD_MIC}{@link GSSException#CONTEXT_EXPIRED GSSException.CONTEXT_EXPIRED}{@link GSSException#FAILURE GSSException.FAILURE}                    
                </throws>
            </javadoc>
            <method name="verifyMIC" type="void" line="805"/>
            <javadoc line="805">
                Uses streams to verify the cryptographic MIC, contained in the token
                  parameter, over the supplied message.  This method is equivalent to
                  the byte array based {@link #verifyMIC(byte[],int,int,byte[],int,int,MessageProp) verifyMIC} method.
                  The MessageProp object is instantiated by the application and is used
                  by the underlying mechanism to return information to the caller such
                  as the QOP indicating the strength of protection that was applied to
                  the message and other supplementary message state information.&lt;p&gt;
                  Since some application-level protocols may wish to use tokens emitted
                  by getMIC to provide &quot;secure framing&quot;, implementations should support
                  the calculation and verification of MICs over zero-length messages.&lt;p&gt;
                  The format of the input token that this method
                  reads is defined in the specification for the underlying mechanism that
                  will be used. This method will attempt to read one of these tokens per
                  invocation. If the mechanism token contains a definitive start and
                  end this method may block on the &lt;code&gt;InputStream&lt;/code&gt; if only
                  part of the token is available. If the start and end of the token
                  are not definitive then the method will attempt to treat all
                  available bytes as part of the token.&lt;p&gt;
                  Other than the possible blocking behavior described above, this
                  method is equivalent to the byte array based {@link #verifyMIC(byte[],int,int,byte[],int,int,MessageProp) verifyMIC} method.&lt;p&gt;                
                <param>
                    tokStream an InputStream containing the token generated by the
                      peer&apos;s getMIC method.                    
                </param>
                <param>
                    msgStream an InputStream containing the application message to
                      verify the cryptographic MIC over. All of the data
                      that is available in msgStream is used.                    
                </param>
                <param>
                    msgProp upon return from the method, this object will contain
                      the applied QOP and supplementary information stating if the token
                      was a duplicate, old, out of sequence or arriving after a gap.                    
                </param>
                <throws>
                    GSSException containing the following
                      major error codes:{@link GSSException#DEFECTIVE_TOKEN GSSException.DEFECTIVE_TOKEN}{@link GSSException#BAD_MIC GSSException.BAD_MIC}{@link GSSException#CONTEXT_EXPIRED GSSException.CONTEXT_EXPIRED}{@link GSSException#FAILURE GSSException.FAILURE}                    
                </throws>
            </javadoc>
            <method name="export" type="byte[]" line="852"/>
            <javadoc line="852">
                Exports this context so that another process may
                  import it.. Provided to support the sharing of work between
                  multiple processes. This routine will typically be used by the
                  context-acceptor, in an application where a single process receives
                  incoming connection requests and accepts security contexts over
                  them, then passes the established context to one or more other
                  processes for message exchange.&lt;p&gt;
                  This method deactivates the security context and creates an
                  interprocess token which, when passed to {@link GSSManager#createContext(byte[]) GSSManager.createContext} in
                  another process, will re-activate the context in the second process.
                  Only a single instantiation of a given context may be active at any
                  one time; a subsequent attempt by a context exporter to access the
                  exported security context will fail.&lt;p&gt;
                  The implementation may constrain the set of processes by which the
                  interprocess token may be imported, either as a function of local
                  security policy, or as a result of implementation decisions.  For
                  example, some implementations may constrain contexts to be passed
                  only between processes that run under the same account, or which are
                  part of the same process group.&lt;p&gt;
                  The interprocess token may contain security-sensitive information
                  (for example cryptographic keys).  While mechanisms are encouraged
                  to either avoid placing such sensitive information within
                  interprocess tokens, or to encrypt the token before returning it to
                  the application, in a typical GSS-API implementation this may not be
                  possible.  Thus the application must take care to protect the
                  interprocess token, and ensure that any process to which the token
                  is transferred is trustworthy. &lt;p&gt;
                  Implementations are not required to support the inter-process
                  transfer of security contexts.  Calling the {@link #isTransferable()isTransferable} method will indicate if the context object is
                  transferable.&lt;p&gt;
                  Calling this method on a context that
                  is not exportable will result in this exception being thrown with
                  the error code {@link GSSException#UNAVAILABLEGSSException.UNAVAILABLE}.                
                <return>
                    a byte[] containing the exported context                    
                </return>
                <see>
                    GSSManager#createContext(byte[])                    
                </see>
                <throws>
                    GSSException containing the following
                      major error codes:{@link GSSException#UNAVAILABLE GSSException.UNAVAILABLE},{@link GSSException#CONTEXT_EXPIRED GSSException.CONTEXT_EXPIRED},{@link GSSException#NO_CONTEXT GSSException.NO_CONTEXT},{@link GSSException#FAILURE GSSException.FAILURE}                    
                </throws>
            </javadoc>
            <method name="requestMutualAuth" type="void" line="907"/>
            <javadoc line="907">
                Requests that mutual authentication be done during
                  context establishment. This request can only be made on the context
                  initiator&apos;s side and it has to be done prior to the first call to
                  &lt;code&gt;initSecContext&lt;/code&gt;.&lt;p&gt;
                  Not all mechanisms support mutual authentication and some mechanisms
                  might require mutual authentication even if the application
                  doesn&apos;t. Therefore, the application should check to see if the
                  request was honored with the {@link #getMutualAuthState()getMutualAuthState} method.&lt;p&gt;                
                <param>
                    state a boolean value indicating whether mutual
                      authentication should be used or not.                    
                </param>
                <see>
                    #getMutualAuthState()                    
                </see>
                <throws>
                    GSSException containing the following
                      major error codes:{@link GSSException#FAILURE GSSException.FAILURE}                    
                </throws>
            </javadoc>
            <method name="requestReplayDet" type="void" line="929"/>
            <javadoc line="929">
                Requests that replay detection be enabled for the
                  per-message security services after context establishment. This
                  request can only be made on the context initiator&apos;s side and it has
                  to be done prior to the first call to
                  &lt;code&gt;initSecContext&lt;/code&gt;. During context establishment replay
                  detection is not an option and is a function of the underlying
                  mechanism&apos;s capabilities.&lt;p&gt;
                  Not all mechanisms support replay detection and some mechanisms
                  might require replay detection even if the application
                  doesn&apos;t. Therefore, the application should check to see if the
                  request was honored with the {@link #getReplayDetState()getReplayDetState} method. If replay detection is enabled then the{@link MessageProp#isDuplicateToken() MessageProp.isDuplicateToken} and {@link MessageProp#isOldToken() MessageProp.isOldToken} methods will return
                  valid results for the &lt;code&gt;MessageProp&lt;/code&gt; object that is passed
                  in to the &lt;code&gt;unwrap&lt;/code&gt; method or the &lt;code&gt;verifyMIC&lt;/code&gt;
                  method.&lt;p&gt;                
                <param>
                    state a boolean value indicating whether replay detection
                      should be enabled over the established context or not.                    
                </param>
                <see>
                    #getReplayDetState()                    
                </see>
                <throws>
                    GSSException containing the following
                      major error codes:{@link GSSException#FAILURE GSSException.FAILURE}                    
                </throws>
            </javadoc>
            <method name="requestSequenceDet" type="void" line="959"/>
            <javadoc line="959">
                Requests that sequence checking be enabled for the
                  per-message security services after context establishment. This
                  request can only be made on the context initiator&apos;s side and it has
                  to be done prior to the first call to
                  &lt;code&gt;initSecContext&lt;/code&gt;. During context establishment sequence
                  checking is not an option and is a function of the underlying
                  mechanism&apos;s capabilities.&lt;p&gt;
                  Not all mechanisms support sequence checking and some mechanisms
                  might require sequence checking even if the application
                  doesn&apos;t. Therefore, the application should check to see if the
                  request was honored with the {@link #getSequenceDetState()getSequenceDetState} method. If sequence checking is enabled then the{@link MessageProp#isDuplicateToken() MessageProp.isDuplicateToken},{@link MessageProp#isOldToken() MessageProp.isOldToken},{@link MessageProp#isUnseqToken() MessageProp.isUnseqToken}, and{@link MessageProp#isGapToken() MessageProp.isGapToken} methods will return
                  valid results for the &lt;code&gt;MessageProp&lt;/code&gt; object that is passed
                  in to the &lt;code&gt;unwrap&lt;/code&gt; method or the &lt;code&gt;verifyMIC&lt;/code&gt;
                  method.&lt;p&gt;                
                <param>
                    state a boolean value indicating whether sequence checking
                      should be enabled over the established context or not.                    
                </param>
                <see>
                    #getSequenceDetState()                    
                </see>
                <throws>
                    GSSException containing the following
                      major error codes:{@link GSSException#FAILURE GSSException.FAILURE}                    
                </throws>
            </javadoc>
            <method name="requestCredDeleg" type="void" line="991"/>
            <javadoc line="991">
                Requests that the initiator&apos;s credentials be
                  delegated to the acceptor during context establishment. This
                  request can only be made on the context initiator&apos;s side and it has
                  to be done prior to the first call to
                  &lt;code&gt;initSecContext&lt;/code&gt;.
                  Not all mechanisms support credential delegation. Therefore, an
                  application that desires delegation should check to see if the
                  request was honored with the {@link #getCredDelegState()getCredDelegState} method. If the application indicates that
                  delegation must not be used, then the mechanism will honor the
                  request and delegation will not occur. This is an exception
                  to the general rule that a mechanism may enable a service even if it
                  is not requested.&lt;p&gt;                
                <param>
                    state a boolean value indicating whether the credentials
                      should be delegated or not.                    
                </param>
                <see>
                    #getCredDelegState()                    
                </see>
                <throws>
                    GSSException containing the following
                      major error codes:{@link GSSException#FAILURE GSSException.FAILURE}                    
                </throws>
            </javadoc>
            <method name="requestAnonymity" type="void" line="1017"/>
            <javadoc line="1017">
                Requests that the initiator&apos;s identity not be
                  disclosed to the acceptor. This request can only be made on the
                  context initiator&apos;s side and it has to be done prior to the first
                  call to &lt;code&gt;initSecContext&lt;/code&gt;.
                  Not all mechanisms support anonymity for the initiator. Therefore, the
                  application should check to see if the request was honored with the{@link #getAnonymityState() getAnonymityState} method.&lt;p&gt;                
                <param>
                    state a boolean value indicating if the initiator should
                      be authenticated to the acceptor as an anonymous principal.                    
                </param>
                <see>
                    #getAnonymityState                    
                </see>
                <throws>
                    GSSException containing the following
                      major error codes:{@link GSSException#FAILURE GSSException.FAILURE}                    
                </throws>
            </javadoc>
            <method name="requestConf" type="void" line="1037"/>
            <javadoc line="1037">
                Requests that data confidentiality be enabled
                  for the &lt;code&gt;wrap&lt;/code&gt; method. This request can only be made on
                  the context initiator&apos;s side and it has to be done prior to the
                  first call to &lt;code&gt;initSecContext&lt;/code&gt;.
                  Not all mechanisms support confidentiality and other mechanisms
                  might enable it even if the application doesn&apos;t request
                  it. The application may check to see if the request was honored with
                  the {@link #getConfState() getConfState} method. If confidentiality
                  is enabled, only then will the mechanism honor a request for privacy
                  in the {@link MessageProp#MessageProp(int,boolean) MessageProp}object that is passed in to the &lt;code&gt;wrap&lt;/code&gt; method.&lt;p&gt;
                  Enabling confidentiality will also automatically enable
                  integrity.&lt;p&gt;                
                <param>
                    state a boolean value indicating whether confidentiality
                      should be enabled or not.                    
                </param>
                <see>
                    #getConfState()                    
                </see>
                <see>
                    #getIntegState()                    
                </see>
                <see>
                    #requestInteg(boolean)                    
                </see>
                <see>
                    MessageProp                    
                </see>
                <throws>
                    GSSException containing the following
                      major error codes:{@link GSSException#FAILURE GSSException.FAILURE}                    
                </throws>
            </javadoc>
            <method name="requestInteg" type="void" line="1067"/>
            <javadoc line="1067">
                Requests that data integrity be enabled
                  for the &lt;code&gt;wrap&lt;/code&gt; and &lt;code&gt;getMIC&lt;/code&gt;methods. This
                  request can only be made on the context initiator&apos;s side and it has
                  to be done prior to the first call to &lt;code&gt;initSecContext&lt;/code&gt;.
                  Not all mechanisms support integrity and other mechanisms
                  might enable it even if the application doesn&apos;t request
                  it. The application may check to see if the request was honored with
                  the {@link #getIntegState() getIntegState} method.&lt;p&gt;
                  Disabling integrity will also automatically disable
                  confidentiality.&lt;p&gt;                
                <param>
                    state a boolean value indicating whether integrity
                      should be enabled or not.                    
                </param>
                <see>
                    #getIntegState()                    
                </see>
                <throws>
                    GSSException containing the following
                      major error codes:{@link GSSException#FAILURE GSSException.FAILURE}                    
                </throws>
            </javadoc>
            <method name="requestLifetime" type="void" line="1091"/>
            <javadoc line="1091">
                Requests a lifetime in seconds for the
                  context. This method can only be called on the context initiator&apos;s
                  side  and it has to be done prior to the first call to
                  &lt;code&gt;initSecContext&lt;/code&gt;.&lt;p&gt;
                  The actual lifetime of the context will depend on the capabilites of
                  the underlying mechanism and the application should call the {@link #getLifetime() getLifetime} method to determine this.&lt;p&gt;                
                <param>
                    lifetime the desired context lifetime in seconds. Use
                      &lt;code&gt;INDEFINITE_LIFETIME&lt;/code&gt; to request an indefinite lifetime
                      and &lt;code&gt;DEFAULT_LIFETIME&lt;/code&gt; to request a default lifetime.                    
                </param>
                <see>
                    #getLifetime()                    
                </see>
                <throws>
                    GSSException containing the following
                      major error codes:{@link GSSException#FAILURE GSSException.FAILURE}                    
                </throws>
            </javadoc>
            <method name="setChannelBinding" type="void" line="1112"/>
            <javadoc line="1112">
                Sets the channel bindings to be used during context
                  establishment. This method can be called on both
                  the context initiator&apos;s and the context acceptor&apos;s side, but it must
                  be called before context establishment begins. This means that an
                  initiator must call it before the first call to
                  &lt;code&gt;initSecContext&lt;/code&gt; and the acceptor must call it before the
                  first call to &lt;code&gt;acceptSecContext&lt;/code&gt;.                
                <param>
                    cb the channel bindings to use.                    
                </param>
                <throws>
                    GSSException containing the following
                      major error codes:{@link GSSException#FAILURE GSSException.FAILURE}                    
                </throws>
            </javadoc>
            <method name="getCredDelegState" type="boolean" line="1129"/>
            <javadoc line="1129">
                Determines if credential delegation is enabled on
                  this context. It can be called by both the context initiator and the
                  context acceptor. For a definitive answer this method must be
                  called only after context establishment is complete. Note that if an
                  initiator requests that delegation not be allowed the {@link #requestCredDeleg(boolean) requestCredDeleg} method will honor that
                  request and this method will return &lt;code&gt;false&lt;/code&gt; on the
                  initiator&apos;s side from that point onwards. &lt;p&gt;                
                <return>
                    true if delegation is enabled, false otherwise.                    
                </return>
                <see>
                    #requestCredDeleg(boolean)                    
                </see>
            </javadoc>
            <method name="getMutualAuthState" type="boolean" line="1144"/>
            <javadoc line="1144">
                Determines if mutual authentication is enabled on
                  this context. It can be called by both the context initiator and the
                  context acceptor. For a definitive answer this method must be
                  called only after context establishment is complete. An initiator
                  that requests mutual authentication can call this method after
                  context completion and dispose the context if its request was not
                  honored.&lt;p&gt;                
                <return>
                    true if mutual authentication is enabled, false otherwise.                    
                </return>
                <see>
                    #requestMutualAuth(boolean)                    
                </see>
            </javadoc>
            <method name="getReplayDetState" type="boolean" line="1158"/>
            <javadoc line="1158">
                Determines if replay detection is enabled for the
                  per-message security services from this context. It can be called by
                  both the context initiator and the context acceptor. For a
                  definitive answer this method must be called only after context
                  establishment is complete. An initiator that requests replay
                  detection can call this method after context completion and
                  dispose the context if its request was not honored.&lt;p&gt;                
                <return>
                    true if replay detection is enabled, false otherwise.                    
                </return>
                <see>
                    #requestReplayDet(boolean)                    
                </see>
            </javadoc>
            <method name="getSequenceDetState" type="boolean" line="1172"/>
            <javadoc line="1172">
                Determines if sequence checking is enabled for the
                  per-message security services from this context. It can be called by
                  both the context initiator and the context acceptor. For a
                  definitive answer this method must be called only after context
                  establishment is complete. An initiator that requests sequence
                  checking can call this method after context completion and
                  dispose the context if its request was not honored.&lt;p&gt;                
                <return>
                    true if sequence checking is enabled, false otherwise.                    
                </return>
                <see>
                    #requestSequenceDet(boolean)                    
                </see>
            </javadoc>
            <method name="getAnonymityState" type="boolean" line="1186"/>
            <javadoc line="1186">
                Determines if the context initiator is
                  anonymously authenticated to the context acceptor. It can be called by
                  both the context initiator and the context acceptor, and at any
                  time. &lt;strong&gt;On the initiator side, a call to this method determines
                  if the identity of the initiator has been disclosed in any of the
                  context establishment tokens that might have been generated thus far
                  by &lt;code&gt;initSecContext&lt;/code&gt;. An initiator that absolutely must be
                  authenticated anonymously should call this method after each call to
                  &lt;code&gt;initSecContext&lt;/code&gt; to determine if the generated token
                  should be sent to the peer or the context aborted.&lt;/strong&gt; On the
                  acceptor side, a call to this method determines if any of the tokens
                  processed by &lt;code&gt;acceptSecContext&lt;/code&gt; thus far have divulged
                  the identity of the initiator.&lt;p&gt;                
                <return>
                    true if the context initiator is still anonymous, false
                      otherwise.                    
                </return>
                <see>
                    #requestAnonymity(boolean)                    
                </see>
            </javadoc>
            <method name="isTransferable" type="boolean" line="1207"/>
            <javadoc line="1207">
                Determines if the context is transferable to other processes
                  through the use of the {@link #export() export} method.  This call
                  is only valid on fully established contexts.                
                <return>
                    true if this context can be exported, false otherwise.                    
                </return>
                <throws>
                    GSSException containing the following
                      major error codes:{@link GSSException#FAILURE GSSException.FAILURE}                    
                </throws>
            </javadoc>
            <method name="isProtReady" type="boolean" line="1220"/>
            <javadoc line="1220">
                Determines if the context is ready for per message operations to be
                  used over it.  Some mechanisms may allow the usage of the
                  per-message operations before the context is fully established.                
                <return>
                    true if methods like &lt;code&gt;wrap&lt;/code&gt;, &lt;code&gt;unwrap&lt;/code&gt;,
                      &lt;code&gt;getMIC&lt;/code&gt;, and &lt;code&gt;verifyMIC&lt;/code&gt; can be used with
                      this context at the current stage of context establishment, false
                      otherwise.                    
                </return>
            </javadoc>
            <method name="getConfState" type="boolean" line="1232"/>
            <javadoc line="1232">
                Determines if data confidentiality is available
                  over the context. This method can be called by both the context
                  initiator and the context acceptor, but only after one of {@link #isProtReady() isProtReady} or {@link #isEstablished()isEstablished} return &lt;code&gt;true&lt;/code&gt;. If this method returns
                  &lt;code&gt;true&lt;/code&gt;, so will {@link #getIntegState()getIntegState}&lt;p&gt;                
                <return>
                    true if confidentiality services are available, false
                      otherwise.                    
                </return>
                <see>
                    #requestConf(boolean)                    
                </see>
            </javadoc>
            <method name="getIntegState" type="boolean" line="1247"/>
            <javadoc line="1247">
                Determines if data integrity is available
                  over the context. This method can be called by both the context
                  initiator and the context acceptor, but only after one of {@link #isProtReady() isProtReady} or {@link #isEstablished()isEstablished} return &lt;code&gt;true&lt;/code&gt;. This method will always
                  return &lt;code&gt;true&lt;/code&gt; if {@link #getConfState() getConfState}returns true.&lt;p&gt;                
                <return>
                    true if integrity services are available, false otherwise.                    
                </return>
                <see>
                    #requestInteg(boolean)                    
                </see>
            </javadoc>
            <method name="getLifetime" type="int" line="1261"/>
            <javadoc line="1261">
                Determines what the remaining lifetime for this
                  context is. It can be called by both the context initiator and the
                  context acceptor, but for a definitive answer it should be called
                  only after {@link #isEstablished() isEstablished} returns
                  true.&lt;p&gt;                
                <return>
                    the remaining lifetime in seconds                    
                </return>
                <see>
                    #requestLifetime(int)                    
                </see>
            </javadoc>
            <method name="getSrcName" type="GSSName" line="1273"/>
            <javadoc line="1273">
                Returns the name of the context initiator. This call is valid only
                  after one of {@link #isProtReady() isProtReady} or {@link #isEstablished() isEstablished} return &lt;code&gt;true&lt;/code&gt;.                
                <return>
                    a GSSName that is an MN containing the name of the context
                      initiator.                    
                </return>
                <see>
                    GSSName                    
                </see>
                <throws>
                    GSSException containing the following
                      major error codes:{@link GSSException#FAILURE GSSException.FAILURE}                    
                </throws>
            </javadoc>
            <method name="getTargName" type="GSSName" line="1288"/>
            <javadoc line="1288">
                Returns the name of the context acceptor. This call is valid only
                  after one of {@link #isProtReady() isProtReady} or {@link #isEstablished() isEstablished} return &lt;code&gt;true&lt;/code&gt;.                
                <return>
                    a GSSName that is an MN containing the name of the context
                      acceptor.                    
                </return>
                <throws>
                    GSSException containing the following
                      major error codes:{@link GSSException#FAILURE GSSException.FAILURE}                    
                </throws>
            </javadoc>
            <method name="getMech" type="Oid" line="1302"/>
            <javadoc line="1302">
                Determines what mechanism is being used for this
                  context. This method may be called before the context is fully
                  established, but the mechanism returned may change on successive
                  calls in the negotiated mechanism case.                
                <return>
                    the Oid of the mechanism being used                    
                </return>
                <throws>
                    GSSException containing the following
                      major error codes:{@link GSSException#FAILURE GSSException.FAILURE}                    
                </throws>
            </javadoc>
            <method name="getDelegCred" type="GSSCredential" line="1316"/>
            <javadoc line="1316">
                Obtains the credentials delegated by the context
                  initiator to the context acceptor. It should be called only on the
                  context acceptor&apos;s side, and once the context is fully
                  established. The caller can use the method {@link #getCredDelegState() getCredDelegState} to determine if there are
                  any delegated credentials.                
                <return>
                    a GSSCredential containing the initiator&apos;s delegated
                      credentials, or &lt;code&gt;null&lt;/code&gt; is no credentials
                      were delegated.                    
                </return>
                <throws>
                    GSSException containing the following
                      major error codes:{@link GSSException#FAILURE GSSException.FAILURE}                    
                </throws>
            </javadoc>
            <method name="isInitiator" type="boolean" line="1334"/>
            <javadoc line="1334">
                Determines if this is the context initiator. This
                  can be called on both the context initiator&apos;s and context acceptor&apos;s
                  side.                
                <return>
                    true if this is the context initiator, false if it is the
                      context acceptor.                    
                </return>
                <throws>
                    GSSException containing the following
                      major error codes:{@link GSSException#FAILURE GSSException.FAILURE}                    
                </throws>
            </javadoc>
        </interface>
    </source>