<?xml version="1.0" encoding="UTF-8"?>
    <source package="com.sun.jndi.ldap.ext">
        <import package="java.io.InputStream"/>
        <import package="java.io.OutputStream"/>
        <import package="java.io.BufferedInputStream"/>
        <import package="java.io.BufferedOutputStream"/>
        <import package="java.io.IOException"/>
        <import package="java.net.Socket"/>
        <import package="java.util.Collection"/>
        <import package="java.util.Iterator"/>
        <import package="java.util.List"/>
        <import package="java.security.Principal"/>
        <import package="java.security.cert.X509Certificate"/>
        <import package="java.security.cert.CertificateException"/>
        <import package="javax.net.ssl.SSLSession"/>
        <import package="javax.net.ssl.SSLSocket"/>
        <import package="javax.net.ssl.SSLSocketFactory"/>
        <import package="javax.net.ssl.SSLPeerUnverifiedException"/>
        <import package="javax.net.ssl.SSLContext"/>
        <import package="javax.net.ssl.HostnameVerifier"/>
        <import package="sun.security.util.HostnameChecker"/>
        <import package="javax.naming"/>
        <import package="javax.naming.ldap"/>
        <import package="com.sun.jndi.ldap.Connection"/>
        <class name="StartTlsResponseImpl" line="24">
            <extends class="StartTlsResponse"/>
            <javadoc line="24">
                This class implements the LDAPv3 Extended Response for StartTLS as
                  defined in
                  &lt;a href=&quot;http://www.ietf.org/rfc/rfc2830.txt&quot;&gt;Lightweight Directory
                  Access Protocol (v3): Extension for Transport Layer Security&lt;/a&gt;
                  The object identifier for StartTLS is 1.3.6.1.4.1.1466.20037
                  and no extended response value is defined.
                  &lt;p&gt;
                  The Start TLS extended request and response are used to establish
                  a TLS connection over the existing LDAP connection associated with
                  the JNDI context on which &lt;tt&gt;extendedOperation()&lt;/tt&gt; is invoked.                
                <see>
                    StartTlsRequest                    
                </see>
                <author>
                    Vincent Ryan                    
                </author>
            </javadoc>
            <declaration name="debug" type="boolean" line="39"/>
            <declaration name="DNSNAME_TYPE" type="int" line="40"/>
            <declaration name="hostname" type="String" line="41"/>
            <declaration name="ldapConnection" type="Connection" line="42"/>
            <declaration name="originalInputStream" type="InputStream" line="43"/>
            <declaration name="originalOutputStream" type="OutputStream" line="44"/>
            <declaration name="sslSocket" type="SSLSocket" line="45"/>
            <declaration name="defaultFactory" type="SSLSocketFactory" line="46"/>
            <declaration name="currentFactory" type="SSLSocketFactory" line="47"/>
            <declaration name="suites" type="String[]" line="48"/>
            <declaration name="verifier" type="HostnameVerifier" line="49"/>
            <declaration name="isClosed" type="boolean" line="50"/>
            <declaration name="serialVersionUID" type="long" line="51"/>
            <method name="StartTlsResponseImpl" type="constructor" line="52"/>
            <javadoc line="54">
                Overrides the default list of cipher suites enabled for use on the
                  TLS connection. The cipher suites must have already been listed by
                  &lt;tt&gt;SSLSocketFactory.getSupportedCipherSuites()&lt;/tt&gt; as being supported.
                  Even if a suite has been enabled, it still might not be used because
                  the peer does not support it, or because the requisite certificates
                  (and private keys) are not available.                
                <param>
                    suites The non-null list of names of all the cipher suites to
                      enable.                    
                </param>
                <see>
                    #negotiate                    
                </see>
            </javadoc>
            <method name="setEnabledCipherSuites" type="void" line="65">
                <params>
                    <param name="suites" type="String[]"/>
                </params>
            </method>
            <javadoc line="68">
                Overrides the default hostname verifier used by &lt;tt&gt;negotiate()&lt;/tt&gt;
                  after the TLS handshake has completed. If
                  &lt;tt&gt;setHostnameVerifier()&lt;/tt&gt; has not been called before
                  &lt;tt&gt;negotiate()&lt;/tt&gt; is invoked, &lt;tt&gt;negotiate()&lt;/tt&gt;
                  will perform a simple case ignore match. If called after
                  &lt;tt&gt;negotiate()&lt;/tt&gt;, this method does not do anything.                
                <param>
                    verifier The non-null hostname verifier callback.                    
                </param>
                <see>
                    #negotiate                    
                </see>
            </javadoc>
            <method name="setHostnameVerifier" type="void" line="78">
                <params>
                    <param name="verifier" type="HostnameVerifier"/>
                </params>
            </method>
            <javadoc line="81">
                Negotiates a TLS session using the default SSL socket factory.
                  &lt;p&gt;
                  This method is equivalent to &lt;tt&gt;negotiate(null)&lt;/tt&gt;.                
                <return>
                    The negotiated SSL session                    
                </return>
                <throw>
                    IOException If an IO error was encountered while establishing
                      the TLS session.                    
                </throw>
                <see>
                    #setEnabledCipherSuites                    
                </see>
                <see>
                    #setHostnameVerifier                    
                </see>
            </javadoc>
            <method name="negotiate" type="SSLSession" line="91"/>
            <javadoc line="94">
                Negotiates a TLS session using an SSL socket factory.
                  &lt;p&gt;
                  Creates an SSL socket using the supplied SSL socket factory and
                  attaches it to the existing connection. Performs the TLS handshake
                  and returns the negotiated session information.
                  &lt;p&gt;
                  If cipher suites have been set via &lt;tt&gt;setEnabledCipherSuites&lt;/tt&gt;
                  then they are enabled before the TLS handshake begins.
                  &lt;p&gt;
                  Hostname verification is performed after the TLS handshake completes.
                  The default check performs a case insensitive match of the server&apos;s
                  hostname against that in the server&apos;s certificate. The server&apos;s
                  hostname is extracted from the subjectAltName in the server&apos;s
                  certificate (if present). Otherwise the value of the common name
                  attribute of the subject name is used. If a callback has
                  been set via &lt;tt&gt;setHostnameVerifier&lt;/tt&gt; then that verifier is used if
                  the default check fails.
                  &lt;p&gt;
                  If an error occurs then the SSL socket is closed and an IOException
                  is thrown. The underlying connection remains intact.                
                <param>
                    factory The possibly null SSL socket factory to use.
                      If null, the default SSL socket factory is used.                    
                </param>
                <return>
                    The negotiated SSL session                    
                </return>
                <throw>
                    IOException If an IO error was encountered while establishing
                      the TLS session.                    
                </throw>
                <see>
                    #setEnabledCipherSuites                    
                </see>
                <see>
                    #setHostnameVerifier                    
                </see>
            </javadoc>
            <method name="negotiate" type="SSLSession" line="123">
                <params>
                    <param name="factory" type="SSLSocketFactory"/>
                </params>
                <scope line="124"/>
                <scope line="127"/>
                <scope line="130"/>
                <declaration name="sslSession" type="SSLSession" line="133"/>
                <scope line="134"/>
                <declaration name="verifExcep" type="SSLPeerUnverifiedException" line="137"/>
                <scope line="138">
                    <scope line="139"/>
                </scope>
                <scope line="144"/>
                <scope line="147"/>
                <scope line="153"/>
            </method>
            <javadoc line="158">
                Closes the TLS connection gracefully and reverts back to the underlying
                  connection.                
                <throw>
                    IOException If an IO error was encountered while closing the
                      TLS connection                    
                </throw>
            </javadoc>
            <method name="close" type="void" line="164">
                <scope line="165"/>
                <scope line="168"/>
                <scope line="172"/>
            </method>
            <javadoc line="178">
                Sets the connection for TLS to use. The TLS connection will be attached
                  to this connection.                
                <param>
                    ldapConnection The non-null connection to use.                    
                </param>
                <param>
                    hostname The server's hostname. If null, the hostname used to
                      open the connection will be used instead.                    
                </param>
            </javadoc>
            <method name="setConnection" type="void" line="185">
                <params>
                    <param name="ldapConnection" type="Connection"/>
                    <param name="hostname" type="String"/>
                </params>
            </method>
            <method name="getDefaultFactory" type="SSLSocketFactory" line="191">
                <scope line="192"/>
            </method>
            <method name="startHandshake" type="SSLSocket" line="197">
                <params>
                    <param name="factory" type="SSLSocketFactory"/>
                </params>
                <scope line="198"/>
                <scope line="201">
                    <scope line="204"/>
                </scope>
                <scope line="208">
                    <scope line="210"/>
                </scope>
                <scope line="214">
                    <scope line="215"/>
                    <scope line="219"/>
                    <scope line="223"/>
                </scope>
                <scope line="227">
                    <scope line="228"/>
                </scope>
            </method>
            <method name="verify" type="boolean" line="238">
                <params>
                    <param name="hostname" type="String"/>
                    <param name="session" type="SSLSession"/>
                </params>
                <declaration name="certs" type="java.security.cert.Certificate[]" line="239"/>
                <scope line="240"/>
                <scope line="243">
                    <declaration name="checker" type="HostnameChecker" line="244"/>
                    <scope line="245">
                        <declaration name="principal" type="Principal" line="246"/>
                        <scope line="247"/>
                    </scope>
                    <scope line="251">
                        <declaration name="peerCert" type="X509Certificate" line="253"/>
                        <scope line="254"/>
                        <scope line="257"/>
                    </scope>
                </scope>
                <scope line="264">
                    <declaration name="cipher" type="String" line="265"/>
                    <scope line="266"/>
                </scope>
                <scope line="271"/>
            </method>
            <method name="getPeerPrincipal" type="Principal" line="275">
                <params>
                    <param name="session" type="SSLSession"/>
                </params>
                <declaration name="principal" type="Principal" line="276"/>
                <scope line="277"/>
                <scope line="280"/>
            </method>
        </class>
    </source>