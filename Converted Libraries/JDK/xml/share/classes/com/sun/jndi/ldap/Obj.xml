<?xml version="1.0" encoding="UTF-8"?>
    <source package="com.sun.jndi.ldap">
        <import package="javax.naming"/>
        <import package="javax.naming.directory"/>
        <import package="javax.naming.spi.DirectoryManager"/>
        <import package="javax.naming.spi.DirStateFactory"/>
        <import package="java.io.IOException"/>
        <import package="java.io.ByteArrayInputStream"/>
        <import package="java.io.ByteArrayOutputStream"/>
        <import package="java.io.ObjectInputStream"/>
        <import package="java.io.ObjectOutputStream"/>
        <import package="java.io.ObjectStreamClass"/>
        <import package="java.io.InputStream"/>
        <import package="java.util.Hashtable"/>
        <import package="java.util.Vector"/>
        <import package="java.util.StringTokenizer"/>
        <import package="sun.misc.BASE64Encoder"/>
        <import package="sun.misc.BASE64Decoder"/>
        <import package="java.lang.reflect.Proxy"/>
        <import package="java.lang.reflect.Modifier"/>
        <class name="Obj" line="51">
            <comment line="61">
                Make sure no one can create one                
            </comment>
            <comment line="63">
                package private; used by Connection                
            </comment>
            <comment line="66">
                LDAP attributes used to support Java objects.                
            </comment>
            <comment line="90">
                LDAP object classes to support Java objects                
            </comment>
            <comment line="107">
                structural object class                
            </comment>
            <comment line="108">
                auxiliary java object class                
            </comment>
            <comment line="109">
                auxiliary reference object class                
            </comment>
            <comment line="110">
                auxiliary serialized object class                
            </comment>
            <comment line="111">
                auxiliary marshalled object class                
            </comment>
            <comment line="222">
                Decode an object from LDAP attribute(s).
                 The object may be a Reference, or a Serialized object.
                
                 See encodeObject() and encodeReference() for details on formats
                 expected.                
            </comment>
            <comment line="351">
                A RMI object is stored in the directory as
                 javaClassName
                   value: Object.getClass();
                 javaRemoteLocation
                   value: URL of RMI object (accessed through the RMI Registry)
                 javaCodebase:
                   value: URL of codebase of where to find classes for object
                
                 Return the RMI Location URL itself. This will be turned into
                 an RMI object when getObjectInstance() is called on it.
                 %%% Ignore codebase for now. Depend on RMI registry to send code.-RL
                 @deprecated For backward compatibility only                
            </comment>
            <comment line="370">
                Restore a Reference object from several LDAP attributes                
            </comment>
            <comment line="499">
                Serialize an object into a byte array                
            </comment>
            <comment line="519">
                Deserializes a byte array into an object.                
            </comment>
            <javadoc line="51">
                Class containing static methods and constants for dealing with
                  encoding/decoding JNDI References and Serialized Objects
                  in LDAP.                
                <author>
                    Vincent Ryan                    
                </author>
                <author>
                    Rosanna Lee                    
                </author>
            </javadoc>
            <method name="Obj" type="constructor" line="60"/>
            <declaration name="helper" type="VersionHelper" line="63"/>
            <declaration name="JAVA_ATTRIBUTES" type="String[]" line="66"/>
            <declaration name="OBJECT_CLASS" type="int" line="77"/>
            <declaration name="SERIALIZED_DATA" type="int" line="78"/>
            <declaration name="CLASSNAME" type="int" line="79"/>
            <declaration name="FACTORY" type="int" line="80"/>
            <declaration name="CODEBASE" type="int" line="81"/>
            <declaration name="REF_ADDR" type="int" line="82"/>
            <declaration name="TYPENAME" type="int" line="83"/>
            <declaration name="REMOTE_LOC" type="int" line="84"/>
            <javadoc line="84">
                @deprecated                
            </javadoc>
            <declaration name="JAVA_OBJECT_CLASSES" type="String[]" line="90"/>
            <declaration name="JAVA_OBJECT_CLASSES_LOWER" type="String[]" line="98"/>
            <declaration name="STRUCTURAL" type="int" line="106"/>
            <declaration name="BASE_OBJECT" type="int" line="107"/>
            <declaration name="REF_OBJECT" type="int" line="108"/>
            <declaration name="SER_OBJECT" type="int" line="109"/>
            <declaration name="MAR_OBJECT" type="int" line="110"/>
            <javadoc line="112">
                Encode an object in LDAP attributes.
                  Supports binding Referenceable or Reference, Serializable,
                  and DirContext.
                  If the object supports the Referenceable interface then encode
                  the reference to the object. See encodeReference() for details.
                  &lt;p&gt;
                  If the object is serializable, it is stored as follows:
                  javaClassName
                  value: Object.getClass();
                  javaSerializedData
                  value: serialized form of Object (in binary form).
                  javaTypeName
                  value: getTypeNames(Object.getClass());                
            </javadoc>
            <method name="encodeObject" type="Attributes" line="131">
                <params>
                    <param name="separator" type="char"/>
                    <param name="obj" type="Object"/>
                    <param name="attrs" type="Attributes"/>
                    <param name="objectClass" type="Attribute"/>
                    <param name="cloned" type="boolean"/>
                </params>
                <comment line="140">
                    References                    
                </comment>
                <comment line="161">
                    Serializable Object                    
                </comment>
                <comment line="185">
                    DirContext Object                    
                </comment>
                <comment line="187">
                    do nothing                    
                </comment>
                <comment line="192">
                    System.err.println(attrs);                    
                </comment>
                <declaration name="structural" type="boolean" line="132"/>
                <scope line="136"/>
                <scope line="141">
                    <scope line="144"/>
                </scope>
                <scope line="152">
                    <scope line="155"/>
                </scope>
                <scope line="162">
                    <scope line="165"/>
                    <scope line="168"/>
                    <scope line="174"/>
                    <scope line="178">
                        <declaration name="tAttr" type="Attribute" line="179"/>
                        <scope line="181"/>
                    </scope>
                </scope>
                <scope line="186"/>
                <scope line="188"/>
            </method>
            <javadoc line="196">
                Each value in javaCodebase contains a list of space-separated
                  URLs. Each value is independent; we can pick any of the values
                  so we just use the first one.                
                <return>
                    an array of URL strings for the codebase                    
                </return>
            </javadoc>
            <method name="getCodebases" type="String[]" line="203">
                <params>
                    <param name="codebaseAttr" type="Attribute"/>
                </params>
                <scope line="204"/>
                <scope line="206">
                    <declaration name="parser" type="StringTokenizer" line="207"/>
                    <declaration name="vec" type="Vector" line="209"/>
                    <scope line="210"/>
                    <declaration name="answer" type="String[]" line="213"/>
                    <scope line="214"/>
                </scope>
            </method>
            <method name="decodeObject" type="Object" line="229">
                <params>
                    <param name="attrs" type="Attributes"/>
                </params>
                <comment line="233">
                    Get codebase, which is used in all 3 cases.                    
                </comment>
                <comment line="240">
                    For backward compatibility only                    
                </comment>
                <declaration name="attr" type="Attribute" line="231"/>
                <declaration name="codebases" type="String[]" line="234"/>
                <scope line="235">
                    <scope line="236">
                        <declaration name="cl" type="ClassLoader" line="237"/>
                    </scope>
                    <scope line="239"/>
                    <scope line="249"/>
                </scope>
                <scope line="253">
                    <declaration name="ne" type="NamingException" line="254"/>
                </scope>
            </method>
            <javadoc line="260">
                Convert a Reference object into several LDAP attributes.
                  A Reference is stored as into the following attributes:
                  javaClassName
                  value: Reference.getClassName();
                  javaFactory
                  value: Reference.getFactoryClassName();
                  javaCodeBase
                  value: Reference.getFactoryClassLocation();
                  javaReferenceAddress
                  value: #0#typeA#valA
                  value: #1#typeB#valB
                  value: #2#typeC##[serialized RefAddr C]
                  value: #3#typeD#valD
                  where
                  -  the first character denotes the separator
                  -  the number following the first separator denotes the position
                  of the RefAddr within the Reference
                  -  &quot;typeA&quot; is RefAddr.getType()
                  -  ## denotes that the Base64-encoded form of the non-StringRefAddr
                  is to follow; otherwise the value that follows is
                  StringRefAddr.getContents()
                  The default separator is the hash character (#).
                  May provide property for this in future.                
            </javadoc>
            <method name="encodeReference" type="Attributes" line="291">
                <params>
                    <param name="separator" type="char"/>
                    <param name="ref" type="Reference"/>
                    <param name="attrs" type="Attributes"/>
                    <param name="orig" type="Object"/>
                </params>
                <comment line="310">
                    Get original object&apos;s types if caller has not explicitly                    
                </comment>
                <comment line="311">
                    specified other type names                    
                </comment>
                <declaration name="s" type="String" line="296"/>
                <scope line="298"/>
                <scope line="302"/>
                <scope line="306"/>
                <scope line="312">
                    <declaration name="tAttr" type="Attribute" line="313"/>
                    <scope line="315"/>
                </scope>
                <declaration name="count" type="int" line="320"/>
                <scope line="322">
                    <declaration name="refAttr" type="Attribute" line="324"/>
                    <declaration name="refAddr" type="RefAddr" line="325"/>
                    <declaration name="encoder" type="BASE64Encoder" line="326"/>
                    <scope line="328">
                        <scope line="331"/>
                        <scope line="335"/>
                    </scope>
                </scope>
            </method>
            <method name="decodeRmiObject" type="Object" line="365">
                <params>
                    <param name="className" type="String"/>
                    <param name="rmiName" type="String"/>
                    <param name="codebases" type="String[]"/>
                </params>
            </method>
            <method name="decodeReference" type="Reference" line="373">
                <params>
                    <param name="attrs" type="Attributes"/>
                    <param name="codebases" type="String[]"/>
                </params>
                <comment line="393">
                    string encoding of a RefAddr is either:
                    
                          #posn#&lt;type&gt;#&lt;address&gt;
                     or
                          #posn#&lt;type&gt;##&lt;base64-encoded address&gt;                    
                </comment>
                <comment line="409">
                    Temporary Vector for decoded RefAddr addresses - used to ensure
                     unordered addresses are correctly re-ordered.                    
                </comment>
                <comment line="425">
                    first character denotes encoding separator                    
                </comment>
                <comment line="427">
                    skip over separator                    
                </comment>
                <comment line="429">
                    extract position within Reference                    
                </comment>
                <comment line="447">
                    skip over position and trailing separator                    
                </comment>
                <comment line="449">
                    extract type                    
                </comment>
                <comment line="460">
                    skip over type and trailing separator                    
                </comment>
                <comment line="462">
                    extract content                    
                </comment>
                <comment line="464">
                    Empty content                    
                </comment>
                <comment line="467">
                    Double separators indicate a non-StringRefAddr                    
                </comment>
                <comment line="468">
                    Content is a Base64-encoded serialized RefAddr                    
                </comment>
                <comment line="470">
                    skip over consecutive separator                    
                </comment>
                <comment line="471">
                    %%% RL: exception if empty after double separator                    
                </comment>
                <comment line="483">
                    Single separator indicates a StringRefAddr                    
                </comment>
                <comment line="489">
                    Copy to real reference                    
                </comment>
                <declaration name="attr" type="Attribute" line="375"/>
                <declaration name="className" type="String" line="376"/>
                <declaration name="factory" type="String" line="377"/>
                <scope line="379"/>
                <scope line="381"/>
                <scope line="386"/>
                <declaration name="ref" type="Reference" line="390"/>
                <scope line="400">
                    <declaration name="val" type="String" line="402"/>
                    <declaration name="separator" type="char" line="403"/>
                    <declaration name="start" type="int" line="404"/>
                    <declaration name="decoder" type="BASE64Decoder" line="405"/>
                    <declaration name="cl" type="ClassLoader" line="407"/>
                    <declaration name="refAddrList" type="Vector" line="413"/>
                    <scope line="416">
                        <scope line="420"/>
                        <scope line="430"/>
                        <scope line="435"/>
                        <scope line="440"/>
                        <scope line="442"/>
                        <scope line="450"/>
                        <scope line="455"/>
                        <scope line="463"/>
                        <scope line="466">
                            <declaration name="ra" type="RefAddr" line="476"/>
                        </scope>
                        <scope line="482"/>
                    </scope>
                    <scope line="490"/>
                </scope>
            </method>
            <method name="serializeObject" type="byte[]" line="501">
                <params>
                    <param name="obj" type="Object"/>
                </params>
                <scope line="503">
                    <declaration name="bytes" type="ByteArrayOutputStream" line="504"/>
                    <declaration name="serial" type="ObjectOutputStream" line="505"/>
                </scope>
                <scope line="511">
                    <declaration name="ne" type="NamingException" line="512"/>
                </scope>
            </method>
            <method name="deserializeObject" type="Object" line="522">
                <params>
                    <param name="obj" type="byte[]"/>
                    <param name="cl" type="ClassLoader"/>
                </params>
                <comment line="525">
                    Create ObjectInputStream for deserialization                    
                </comment>
                <scope line="524">
                    <declaration name="bytes" type="ByteArrayInputStream" line="526"/>
                    <declaration name="deserial" type="ObjectInputStream" line="527"/>
                    <scope line="531"/>
                    <scope line="533">
                        <declaration name="ne" type="NamingException" line="534"/>
                    </scope>
                    <scope line="537"/>
                </scope>
                <scope line="540">
                    <declaration name="ne" type="NamingException" line="541"/>
                </scope>
            </method>
            <javadoc line="547">
                Returns the attributes to bind given an object and its attributes.                
            </javadoc>
            <method name="determineBindAttrs" type="Attributes" line="553">
                <params>
                    <param name="separator" type="char"/>
                    <param name="obj" type="Object"/>
                    <param name="attrs" type="Attributes"/>
                    <param name="cloned" type="boolean"/>
                    <param name="name" type="Name"/>
                    <param name="ctx" type="Context"/>
                    <param name="env" type="Hashtable"/>
                </params>
                <comment line="555">
                    Call state factories to convert object and attrs                    
                </comment>
                <comment line="561">
                    We&apos;re only storing attributes; no further processing required                    
                </comment>
                <comment line="566">
                    if object to be bound is a DirContext extract its attributes                    
                </comment>
                <comment line="574">
                    Create &quot;objectClass&quot; attribute                    
                </comment>
                <comment line="580">
                    No objectclasses supplied, use &quot;top&quot; to start                    
                </comment>
                <comment line="584">
                    Get existing objectclass attribute                    
                </comment>
                <comment line="587">
                    %%% workaround                    
                </comment>
                <comment line="591">
                    No objectclasses supplied, use &quot;top&quot; to start                    
                </comment>
                <comment line="599">
                    convert the supplied object into LDAP attributes                    
                </comment>
                <comment line="602">
                    System.err.println(&quot;Determined: &quot; + attrs);                    
                </comment>
                <declaration name="res" type="DirStateFactory.Result" line="556"/>
                <scope line="562"/>
                <scope line="567"/>
                <declaration name="ocNeedsCloning" type="boolean" line="572"/>
                <declaration name="objectClass" type="Attribute" line="575"/>
                <scope line="576"/>
                <scope line="583">
                    <scope line="586"/>
                    <scope line="592"/>
                    <scope line="594"/>
                </scope>
            </method>
            <class name="LoaderInputStream" line="606">
                <extends class="ObjectInputStream"/>
                <javadoc line="606">
                    An ObjectInputStream that uses a class loader to find classes.                    
                </javadoc>
                <declaration name="classLoader" type="ClassLoader" line="610"/>
                <method name="LoaderInputStream" type="constructor" line="612">
                    <params>
                        <param name="in" type="InputStream"/>
                        <param name="cl" type="ClassLoader"/>
                    </params>
                </method>
                <method name="resolveClass" type="Class" line="618">
                    <params>
                        <param name="desc" type="ObjectStreamClass"/>
                    </params>
                    <comment line="620">
                        %%% Should use Class.forName(desc.getName(), false, classLoader);                        
                    </comment>
                    <comment line="621">
                        except we can&apos;t because that is only available on JDK1.2                        
                    </comment>
                    <scope line="619"/>
                    <scope line="623"/>
                </method>
                <method name="resolveProxyClass" type="Class" line="629">
                    <params>
                        <param name="interfaces" type="String[]"/>
                    </params>
                    <comment line="633">
                        define proxy in class loader of non-public interface(s), if any                        
                    </comment>
                    <declaration name="nonPublicLoader" type="ClassLoader" line="630"/>
                    <declaration name="hasNonPublicInterface" type="boolean" line="631"/>
                    <declaration name="classObjs" type="Class[]" line="634"/>
                    <scope line="635">
                        <declaration name="cl" type="Class" line="636"/>
                        <scope line="637">
                            <scope line="638">
                                <scope line="639"/>
                            </scope>
                            <scope line="643"/>
                        </scope>
                    </scope>
                    <scope line="650"/>
                    <scope line="653"/>
                </method>
            </class>
        </class>
    </source>