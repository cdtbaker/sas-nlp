<?xml version="1.0" encoding="UTF-8"?>
    <source package="com.sun.jndi.cosnaming">
        <import package="javax.naming"/>
        <import package="java.util.Properties"/>
        <import package="java.util.Vector"/>
        <import package="java.util.Enumeration"/>
        <import package="org.omg.CosNaming.NameComponent"/>
        <class name="CNNameParser" line="35">
            <comment line="340">
                for testing only                
            </comment>
            <comment line="341">
                private static void print(String input) {
                try {
                System.out.println(&quot;\n &gt;&gt;&gt;&gt;&gt;&gt; input: &quot; + input);
                
                System.out.println(&quot;--Compound Name: &quot;);
                NameParser parser = new CNNameParser();
                Name name = parser.parse(input);
                for (int i = 0; i &lt; name.size(); i++) {
                System.out.println(&quot;\t&quot; + i + &quot;: &quot; + name.get(i));
                NameComponent cp = parseComponent(name.get(i));
                System.out.println(&quot;\t\t&quot; + &quot;id: &quot; + cp.id + &quot;;kind: &quot; + cp.kind);
                }
                System.out.println(&quot;\t&quot; + name.toString());
                
                System.out.println(&quot;--Composite Name: &quot;);
                Name composite = new CompositeName(input);
                for (int i = 0; i &lt; composite.size(); i++) {
                System.out.println(&quot;\t&quot; + i+&quot;: &quot; + composite.get(i));
                }
                System.out.println(&quot;\t&quot; + composite.toString());
                
                System.out.println(&quot;--Composite To NameComponent&quot;);
                NameComponent[] names = nameToCosName(composite);
                for (int i = 0; i &lt; composite.size(); i++) {
                System.out.println(&quot;\t&quot; + i+&quot;: id: &quot; + names[i].id + &quot;; kind: &quot; + names[i].kind);
                }
                System.out.println(&quot;\t&quot; + cosNameToInsString(names));
                } catch (NamingException e) {
                System.out.println(e);
                }
                }
                
                private static void checkName(Name name, String[] comps) throws Exception {
                if (name.size() != comps.length) {
                throw new Exception(
                &quot;test failed; incorrect component count in &quot; + name + &quot;; &quot; +
                &quot;expecting &quot; + comps.length + &quot; got &quot; + name.size());
                }
                for (int i = 0; i &lt; name.size(); i++) {
                if (!comps[i].equals(name.get(i))) {
                throw new Exception (
                &quot;test failed; invalid component in &quot; + name + &quot;; &quot; +
                &quot;expecting &apos;&quot; + comps[i] + &quot;&apos; got &apos;&quot; + name.get(i) + &quot;&apos;&quot;);
                }
                }
                }
                
                private static void checkCompound(NameParser parser,
                String input, String[] comps) throws Exception {
                checkName(parser.parse(input), comps);
                }
                
                private static void checkComposite(String input, String[] comps)
                throws Exception {
                checkName(new CompositeName(input), comps);
                }
                
                private static String[] compounds = {
                &quot;abc&quot;,
                &quot;a.bc.d&quot;,
                &quot;a&quot;,
                &quot;.&quot;,
                &quot;a.&quot;,
                &quot;c.d&quot;,
                &quot;.e&quot;,
                &quot;ax\\y\\zb&quot;,
                &quot;a\\.b.c\\.de.f&quot;,
                &quot;ab\\\\c&quot;,
                &quot;x\\\\.y&quot;,
                &quot;x\\.y&quot;,
                &quot;x.\\\\y&quot;,
                &quot;x.y\\\\&quot;,
                &quot;\\\\x.y&quot;,
                &quot;a.b\\.cd&quot;
                };
                private static String[][] compoundComps = {
                {&quot;a&quot;, &quot;b&quot;, &quot;c&quot;},
                {&quot;a.b&quot;, &quot;c.d&quot;},
                {&quot;a&quot;},
                {&quot;.&quot;},
                {&quot;a&quot;},
                {&quot;c.d&quot;},
                {&quot;.e&quot;},
                {&quot;a&quot;, &quot;x\\y\\z&quot;, &quot;b&quot;},
                {&quot;a\\.b.c\\.d&quot;, &quot;e.f&quot;},
                {&quot;a&quot;, &quot;b\\\\&quot;, &quot;c&quot;},
                {&quot;x\\\\.y&quot;},
                {&quot;x\\.y&quot;},
                {&quot;x.\\\\y&quot;},
                {&quot;x.y\\\\&quot;},
                {&quot;\\\\x.y&quot;},
                {&quot;a.b\\.c&quot;, &quot;d&quot;},
                };
                
                private static String[] composites = {
                &quot;abc&quot;,
                &quot;a.bc.d&quot;,
                &quot;a&quot;,
                &quot;.&quot;,
                &quot;a.&quot;,
                &quot;c.d&quot;,
                &quot;.e&quot;,
                &quot;ax\\\\\\y\\\\\\zb&quot;,
                &quot;a\\\\.b.c\\\\.de.f&quot;,
                &quot;ab\\\\\\\\c&quot;,
                &quot;x\\\\\\.y&quot;,
                &quot;x\\\\.y&quot;,
                &quot;x.\\\\\\\\y&quot;,
                &quot;x.y\\\\\\\\&quot;,
                &quot;\\\\\\\\x.y&quot;
                };
                
                private static String[][] compositeComps = {
                {&quot;a&quot;, &quot;b&quot;, &quot;c&quot;},
                {&quot;a.b&quot;, &quot;c.d&quot;},
                {&quot;a&quot;},
                {&quot;.&quot;},
                {&quot;a.&quot;},   unlike compound, kind sep is not consumed
                {&quot;c.d&quot;},
                {&quot;.e&quot;},
                {&quot;a&quot;, &quot;x\\y\\z&quot;, &quot;b&quot;},
                {&quot;a\\.b.c\\.d&quot;, &quot;e.f&quot;},
                {&quot;a&quot;, &quot;b\\\\&quot;, &quot;c&quot;},
                {&quot;x\\\\.y&quot;},
                {&quot;x\\.y&quot;},
                {&quot;x.\\\\y&quot;},
                {&quot;x.y\\\\&quot;},
                {&quot;\\\\x.y&quot;}
                };
                
                public static void main(String[] args) throws Exception {
                if (args.length &gt; 0) {
                for (int i = 0; i &lt; args.length; i++) {
                print(args[0]);
                }
                } else {
                print(&quot;x\\\\.y&quot;);
                print(&quot;x\\.y&quot;);
                print(&quot;x.\\\\y&quot;);
                print(&quot;x.y\\\\&quot;);
                print(&quot;\\\\x.y&quot;);
                }
                
                NameParser parser = new com.sun.jndi.cosnaming.CNNameParser();
                for (int i = 0; i &lt; compounds.length; i++) {
                checkCompound(parser, compounds[i], compoundComps[i]);
                }
                for (int i = 0; i &lt; composites.length; i++) {
                checkComposite(composites[i], compositeComps[i]);
                }
                
                System.out.println(&quot;hardwire&quot;);
                NameComponent[] foo = new NameComponent[1];
                foo[0] = new NameComponent(&quot;foo\\&quot;, &quot;bar&quot;);
                
                System.out.println(cosNameToInsString(foo));
                System.out.println(cosNameToName(foo));
                }                
            </comment>
            <implements interface="NameParser"/>
            <javadoc line="35">
                Parsing routines for NameParser as well as COS Naming stringified names.
                  This is used by CNCtx to create a NameComponent[] object and vice versa.
                  It follows Section 4.5 of Interoperable Naming Service (INS) 98-10-11.
                  In summary, the stringified form is a left-to-right, forward-slash
                  separated name. id and kinds are separated by &apos;.&apos;. backslash is the
                  escape character.                
                <author>
                    Rosanna Lee                    
                </author>
            </javadoc>
            <declaration name="mySyntax" type="Properties" line="48"/>
            <declaration name="kindSeparator" type="char" line="49"/>
            <declaration name="compSeparator" type="char" line="50"/>
            <declaration name="escapeChar" type="char" line="51"/>
            <scope line="52"/>
            <javadoc line="58">
                Constructs a new name parser for parsing names in INS syntax.                
            </javadoc>
            <method name="CNNameParser" type="constructor" line="61"/>
            <javadoc line="64">
                Returns a CompoundName given a string in INS syntax.                
                <param>
                    name The non-null string representation of the name.                    
                </param>
                <return>
                    a non-null CompoundName                    
                </return>
            </javadoc>
            <method name="parse" type="Name" line="69">
                <params>
                    <param name="name" type="String"/>
                </params>
                <declaration name="comps" type="Vector" line="70"/>
            </method>
            <javadoc line="74">
                Creates a NameComponent[] from a Name structure.
                  Used by CNCtx to convert the input Name arg into a NameComponent[].                
                <param>
                    a CompoundName or a CompositeName;
                      each component must be the stringified form of a NameComponent.                    
                </param>
            </javadoc>
            <method name="nameToCosName" type="NameComponent[]" line="81">
                <params>
                    <param name="name" type="Name"/>
                </params>
                <declaration name="len" type="int" line="82"/>
                <scope line="83"/>
                <declaration name="answer" type="NameComponent[]" line="87"/>
                <scope line="88"/>
            </method>
            <javadoc line="94">
                Returns the INS stringified form of a NameComponent[].
                  Used by CNCtx.getNameInNamespace(), CNCompoundName.toString().                
            </javadoc>
            <method name="cosNameToInsString" type="String" line="98">
                <params>
                    <param name="cname" type="NameComponent[]"/>
                </params>
                <declaration name="str" type="StringBuffer" line="99"/>
                <scope line="100">
                    <scope line="101"/>
                </scope>
            </method>
            <javadoc line="109">
                Creates a CompositeName from a NameComponent[].
                  Used by ExceptionMapper and CNBindingEnumeration to convert
                  a NameComponent[] into a composite name.                
            </javadoc>
            <method name="cosNameToName" type="Name" line="114">
                <params>
                    <param name="cname" type="NameComponent[]"/>
                </params>
                <comment line="120">
                    ignore                    
                </comment>
                <declaration name="nm" type="Name" line="115"/>
                <scope line="116">
                    <scope line="117"/>
                    <scope line="119"/>
                </scope>
            </method>
            <javadoc line="126">
                Converts an INS-syntax string name into a Vector in which
                  each element of the vector contains a stringified form of
                  a NameComponent.                
            </javadoc>
            <method name="insStringToStringifiedComps" type="Vector" line="132">
                <params>
                    <param name="str" type="String"/>
                </params>
                <comment line="141">
                    reset for new component                    
                </comment>
                <comment line="142">
                    always start off parsing id                    
                </comment>
                <comment line="152">
                    skip escape and let meta through                    
                </comment>
                <comment line="164">
                    just look for the first kindSeparator                    
                </comment>
                <comment line="165">
                    skip kind separator                    
                </comment>
                <comment line="181">
                    skip separator                    
                </comment>
                <declaration name="len" type="int" line="134"/>
                <declaration name="components" type="Vector" line="135"/>
                <declaration name="id" type="char[]" line="136"/>
                <declaration name="kind" type="char[]" line="137"/>
                <declaration name="idCount" type="int" line="138"/>
                <declaration name="idMode" type="boolean" line="139"/>
                <scope line="140">
                    <scope line="143">
                        <scope line="144"/>
                        <scope line="147">
                            <scope line="148"/>
                            <scope line="151">
                                <scope line="153"/>
                                <scope line="155"/>
                            </scope>
                            <scope line="158"/>
                        </scope>
                        <scope line="163"/>
                        <scope line="168">
                            <scope line="169"/>
                            <scope line="171"/>
                        </scope>
                    </scope>
                    <scope line="180"/>
                </scope>
            </method>
            <javadoc line="188">
                Return a NameComponent given its stringified form.                
            </javadoc>
            <method name="parseComponent" type="NameComponent" line="192">
                <params>
                    <param name="compStr" type="String"/>
                </params>
                <comment line="201">
                    Find the kind separator                    
                </comment>
                <comment line="223">
                    Set id                    
                </comment>
                <comment line="226">
                    Set kind                    
                </comment>
                <comment line="228">
                    no kind separator                    
                </comment>
                <comment line="230">
                    unescape kind                    
                </comment>
                <declaration name="comp" type="NameComponent" line="193"/>
                <declaration name="kindSep" type="int" line="194"/>
                <declaration name="len" type="int" line="195"/>
                <declaration name="j" type="int" line="197"/>
                <declaration name="newStr" type="char[]" line="198"/>
                <declaration name="escaped" type="boolean" line="199"/>
                <scope line="202">
                    <scope line="203"/>
                    <scope line="206">
                        <scope line="207"/>
                        <scope line="210"/>
                        <scope line="212"/>
                    </scope>
                    <scope line="216"/>
                    <scope line="218"/>
                </scope>
                <scope line="227"/>
                <scope line="229">
                    <scope line="233">
                        <scope line="234"/>
                        <scope line="237">
                            <scope line="238"/>
                            <scope line="241"/>
                            <scope line="243"/>
                        </scope>
                        <scope line="247"/>
                    </scope>
                </scope>
            </method>
            <method name="stringifyComponent" type="String" line="256">
                <params>
                    <param name="comp" type="NameComponent"/>
                </params>
                <comment line="262">
                    if neither id nor kind specified                    
                </comment>
                <declaration name="one" type="StringBuffer" line="257"/>
                <scope line="258"/>
                <scope line="261"/>
                <scope line="263"/>
            </method>
            <javadoc line="268">
                Returns a string with &apos;.&apos;, &apos;\&apos;, &apos;/&apos; escaped. Used when
                  stringifying the name into its INS stringified form.                
            </javadoc>
            <method name="escape" type="String" line="272">
                <params>
                    <param name="str" type="String"/>
                </params>
                <comment line="276">
                    no meta characters to escape                    
                </comment>
                <comment line="283">
                    escape meta character                    
                </comment>
                <scope line="275"/>
                <scope line="277">
                    <declaration name="len" type="int" line="278"/>
                    <declaration name="j" type="int" line="279"/>
                    <declaration name="newStr" type="char[]" line="280"/>
                    <scope line="281">
                        <scope line="282"/>
                    </scope>
                </scope>
            </method>
            <javadoc line="291">
                In INS, there are three meta characters: &apos;.&apos;, &apos;/&apos; and &apos;\&apos;.                
            </javadoc>
            <method name="isMeta" type="boolean" line="294">
                <params>
                    <param name="ch" type="char"/>
                </params>
            </method>
            <class name="CNCompoundName" line="304">
                <extends class="CompoundName"/>
                <javadoc line="304">
                    An implementation of CompoundName that bypasses the parsing
                      and stringifying code of the default CompoundName.                    
                </javadoc>
                <method name="CNCompoundName" type="constructor" line="309">
                    <params>
                        <param name="enum_" type="Enumeration"/>
                    </params>
                </method>
                <method name="clone" type="Object" line="313"/>
                <method name="getPrefix" type="Name" line="317">
                    <params>
                        <param name="posn" type="int"/>
                    </params>
                    <declaration name="comps" type="Enumeration" line="318"/>
                </method>
                <method name="getSuffix" type="Name" line="322">
                    <params>
                        <param name="posn" type="int"/>
                    </params>
                    <declaration name="comps" type="Enumeration" line="323"/>
                </method>
                <method name="toString" type="String" line="327">
                    <comment line="329">
                        Convert Name to NameComponent[] then stringify                        
                    </comment>
                    <scope line="328"/>
                    <scope line="331"/>
                </method>
                <declaration name="serialVersionUID" type="long" line="336"/>
            </class>
        </class>
    </source>