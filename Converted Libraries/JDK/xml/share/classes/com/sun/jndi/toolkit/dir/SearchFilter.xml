<?xml version="1.0" encoding="UTF-8"?>
    <source package="com.sun.jndi.toolkit.dir">
        <import package="javax.naming"/>
        <import package="javax.naming.directory"/>
        <import package="java.util.Enumeration"/>
        <import package="java.util.StringTokenizer"/>
        <import package="java.util.Vector"/>
        <class name="SearchFilter" line="33">
            <comment line="46">
                %%% &quot;filter&quot; and &quot;pos&quot; are not declared &quot;private&quot; due to bug 4064984.                
            </comment>
            <comment line="72">
                Returns true if targetAttrs passes the filter                
            </comment>
            <comment line="80">
                Utility routines used by member classes                
            </comment>
            <comment line="84">
                does some pre-processing on the string to make it look exactly lik                
            </comment>
            <comment line="85">
                what the parser expects. This only needs to be called once.                
            </comment>
            <comment line="234">
                                
            </comment>
            <comment line="250">
                                
            </comment>
            <comment line="252">
                note: declared here since member classes can&apos;t have static variables                
            </comment>
            <comment line="428">
                                
            </comment>
            <comment line="430">
                ----- static methods for producing string filters given attribute set                
            </comment>
            <comment line="431">
                ----- or object array                
            </comment>
            <comment line="467">
                Writes the hex representation of a byte to a StringBuffer.                
            </comment>
            <comment line="619">
                returns an Attributes instance containing only attributeIDs given in
                 &quot;attributeIDs&quot; whose values come from the given DSContext.                
            </comment>
            <comment line="641">
                For testing filter
                public static void main(String[] args) {
                
                Attributes attrs = new BasicAttributes(LdapClient.caseIgnore);
                attrs.put(&quot;cn&quot;, &quot;Rosanna Lee&quot;);
                attrs.put(&quot;sn&quot;, &quot;Lee&quot;);
                attrs.put(&quot;fn&quot;, &quot;Rosanna&quot;);
                attrs.put(&quot;id&quot;, &quot;10414&quot;);
                attrs.put(&quot;machine&quot;, &quot;jurassic&quot;);
                
                
                try {
                System.out.println(format(attrs));
                
                String  expr = &quot;(&amp;(Age = {0})(Account Balance &lt;= {1}))&quot;;
                Object[] fargs = new Object[2];
                 fill in the parameters
                fargs[0] = new Integer(65);
                fargs[1] = new Float(5000);
                
                System.out.println(format(expr, fargs));
                
                
                System.out.println(format(&quot;bin={0}&quot;,
                new Object[] {new byte[] {0, 1, 2, 3, 4, 5}}));
                
                System.out.println(format(&quot;bin=\\{anything}&quot;, null));
                
                } catch (NamingException e) {
                e.printStackTrace();
                }
                }                
            </comment>
            <implements interface="AttrFilter"/>
            <javadoc line="33">
                A class for parsing LDAP search filters (defined in RFC 1960, 2254)                
                <author>
                    Jon Ruiz                    
                </author>
                <author>
                    Rosanna Lee                    
                </author>
            </javadoc>
            <interface name="StringFilter">
                <implements interface="AttrFilter"/>
                <comment line="379">
                    used for substring comparisons (where proto has &quot;*&quot; wildcards                    
                </comment>
                <method name="parse" type="void" line="42"/>
            </interface>
            <declaration name="filter" type="String" line="46"/>
            <declaration name="pos" type="int" line="47"/>
            <declaration name="rootFilter" type="StringFilter" line="48"/>
            <declaration name="debug" type="boolean" line="50"/>
            <declaration name="BEGIN_FILTER_TOKEN" type="char" line="52"/>
            <declaration name="END_FILTER_TOKEN" type="char" line="53"/>
            <declaration name="AND_TOKEN" type="char" line="54"/>
            <declaration name="OR_TOKEN" type="char" line="55"/>
            <declaration name="NOT_TOKEN" type="char" line="56"/>
            <declaration name="EQUAL_TOKEN" type="char" line="57"/>
            <declaration name="APPROX_TOKEN" type="char" line="58"/>
            <declaration name="LESS_TOKEN" type="char" line="59"/>
            <declaration name="GREATER_TOKEN" type="char" line="60"/>
            <declaration name="EXTEND_TOKEN" type="char" line="61"/>
            <declaration name="WILDCARD_TOKEN" type="char" line="62"/>
            <method name="SearchFilter" type="constructor" line="64">
                <params>
                    <param name="filter" type="String"/>
                </params>
            </method>
            <method name="check" type="boolean" line="72">
                <params>
                    <param name="targetAttrs" type="Attributes"/>
                </params>
            </method>
            <method name="normalizeFilter" type="void" line="85">
                <comment line="86">
                    get rid of any leading whitespaces                    
                </comment>
                <comment line="88">
                    Sometimes, search filters don&apos;t have &quot;(&quot; and &quot;)&quot; - add them                    
                </comment>
                <comment line="92">
                    this would be a good place to strip whitespace if desired                    
                </comment>
                <scope line="89"/>
                <scope line="94"/>
            </method>
            <method name="skipWhiteSpace" type="void" line="98">
                <scope line="99"/>
            </method>
            <method name="createNextFilter" type="StringFilter" line="105">
                <comment line="111">
                    make sure every filter starts with &quot;(&quot;                    
                </comment>
                <comment line="119">
                    skip past the &quot;(&quot;                    
                </comment>
                <comment line="124">
                    use the next character to determine the type of filter                    
                </comment>
                <comment line="150">
                    make sure every filter ends with &quot;)&quot;                    
                </comment>
                <comment line="158">
                    skip past the &quot;)&quot;                    
                </comment>
                <comment line="162">
                    just rethrow these                    
                </comment>
                <comment line="164">
                    catch all - any uncaught exception while parsing will end up here                    
                </comment>
                <declaration name="filter" type="StringFilter" line="106"/>
                <scope line="110">
                    <scope line="112"/>
                    <scope line="127"/>
                    <scope line="132"/>
                    <scope line="137"/>
                    <scope line="142"/>
                    <scope line="151"/>
                </scope>
                <scope line="160">
                    <scope line="161"/>
                </scope>
                <scope line="165">
                    <scope line="166"/>
                </scope>
            </method>
            <method name="getCurrentChar" type="char" line="175"/>
            <method name="relCharAt" type="char" line="179">
                <params>
                    <param name="i" type="int"/>
                </params>
            </method>
            <method name="consumeChar" type="void" line="183"/>
            <method name="consumeChars" type="void" line="187">
                <params>
                    <param name="i" type="int"/>
                </params>
            </method>
            <method name="relIndexOf" type="int" line="191">
                <params>
                    <param name="ch" type="int"/>
                </params>
            </method>
            <method name="relSubstring" type="String" line="195">
                <params>
                    <param name="beginIndex" type="int"/>
                    <param name="endIndex" type="int"/>
                </params>
                <scope line="196"/>
            </method>
            <class name="CompoundFilter" line="202">
                <comment line="379">
                    used for substring comparisons (where proto has &quot;*&quot; wildcards                    
                </comment>
                <implements interface="StringFilter"/>
                <javadoc line="202">
                    A class for dealing with compound filters (&quot;and&quot; &amp; &quot;or&quot; filters).                    
                </javadoc>
                <declaration name="subFilters" type="Vector" line="206"/>
                <declaration name="polarity" type="boolean" line="207"/>
                <method name="CompoundFilter" type="constructor" line="209">
                    <params>
                        <param name="polarity" type="boolean"/>
                    </params>
                </method>
                <method name="parse" type="void" line="214">
                    <comment line="215">
                        consume the &quot;&amp;&quot;                        
                    </comment>
                    <scope line="216">
                        <scope line="217"/>
                        <declaration name="filter" type="StringFilter" line="218"/>
                    </scope>
                </method>
                <method name="check" type="boolean" line="224">
                    <params>
                        <param name="targetAttrs" type="Attributes"/>
                    </params>
                    <scope line="225">
                        <declaration name="filter" type="StringFilter" line="226"/>
                        <scope line="227"/>
                    </scope>
                </method>
            </class>
            <class name="NotFilter" line="235">
                <comment line="379">
                    used for substring comparisons (where proto has &quot;*&quot; wildcards                    
                </comment>
                <implements interface="StringFilter"/>
                <javadoc line="235">
                    A class for dealing with NOT filters                    
                </javadoc>
                <declaration name="filter" type="StringFilter" line="239"/>
                <method name="parse" type="void" line="241">
                    <comment line="242">
                        consume the &quot;!&quot;                        
                    </comment>
                </method>
                <method name="check" type="boolean" line="246">
                    <params>
                        <param name="targetAttrs" type="Attributes"/>
                    </params>
                </method>
            </class>
            <declaration name="EQUAL_MATCH" type="int" line="252"/>
            <declaration name="APPROX_MATCH" type="int" line="253"/>
            <declaration name="GREATER_MATCH" type="int" line="254"/>
            <declaration name="LESS_MATCH" type="int" line="255"/>
            <class name="AtomicFilter" line="257">
                <comment line="379">
                    used for substring comparisons (where proto has &quot;*&quot; wildcards                    
                </comment>
                <implements interface="StringFilter"/>
                <javadoc line="257">
                    A class for dealing wtih atomic filters                    
                </javadoc>
                <declaration name="attrID" type="String" line="261"/>
                <declaration name="value" type="String" line="262"/>
                <declaration name="matchType" type="int" line="263"/>
                <method name="parse" type="void" line="265">
                    <comment line="270">
                        find the end                        
                    </comment>
                    <comment line="273">
                        determine the match type                        
                    </comment>
                    <comment line="314">
                        update our position                        
                    </comment>
                    <scope line="269">
                        <declaration name="endPos" type="int" line="271"/>
                        <declaration name="i" type="int" line="274"/>
                        <scope line="275"/>
                        <declaration name="qualifier" type="int" line="276"/>
                        <scope line="279"/>
                        <scope line="286"/>
                        <scope line="293"/>
                        <scope line="300"/>
                        <scope line="304"/>
                    </scope>
                    <scope line="317">
                        <scope line="318"/>
                        <declaration name="sfe" type="InvalidSearchFilterException" line="320"/>
                    </scope>
                    <scope line="328"/>
                </method>
                <method name="check" type="boolean" line="332">
                    <params>
                        <param name="targetAttrs" type="Attributes"/>
                    </params>
                    <declaration name="candidates" type="Enumeration" line="333"/>
                    <scope line="335">
                        <declaration name="attr" type="Attribute" line="336"/>
                        <scope line="337"/>
                    </scope>
                    <scope line="341">
                        <scope line="342"/>
                    </scope>
                    <scope line="347">
                        <declaration name="val" type="String" line="348"/>
                        <scope line="349"/>
                        <scope line="353">
                            <scope line="354"/>
                        </scope>
                        <scope line="359"/>
                        <scope line="360"/>
                        <scope line="365"/>
                        <scope line="366"/>
                        <scope line="371"/>
                    </scope>
                </method>
                <method name="substringMatch" type="boolean" line="379">
                    <params>
                        <param name="proto" type="String"/>
                        <param name="value" type="String"/>
                    </params>
                    <comment line="380">
                        simple case 1: &quot;*&quot; means attribute presence is being tested                        
                    </comment>
                    <comment line="386">
                        simple case 2: if there are no wildcards, call String.equals()                        
                    </comment>
                    <comment line="392">
                        do the work: make sure all the substrings are present                        
                    </comment>
                    <comment line="396">
                        do we need to begin with the first token?                        
                    </comment>
                    <comment line="417">
                        do we need to end with the last token?                        
                    </comment>
                    <scope line="381">
                        <scope line="382"/>
                    </scope>
                    <scope line="387"/>
                    <scope line="391"/>
                    <declaration name="currentPos" type="int" line="393"/>
                    <declaration name="subStrs" type="StringTokenizer" line="394"/>
                    <scope line="399">
                        <scope line="400"/>
                    </scope>
                    <scope line="405">
                        <declaration name="currentStr" type="String" line="406"/>
                        <scope line="407"/>
                        <scope line="411"/>
                    </scope>
                    <scope line="419">
                        <scope line="420"/>
                    </scope>
                </method>
            </class>
            <javadoc line="433">
                Creates an LDAP filter as a conjuction of the attributes supplied.                
            </javadoc>
            <method name="format" type="String" line="436">
                <params>
                    <param name="attrs" type="Attributes"/>
                </params>
                <comment line="447">
                    only checking presence of attribute                    
                </comment>
                <comment line="462">
                    System.out.println(&quot;filter: &quot; + answer);                    
                </comment>
                <scope line="437"/>
                <declaration name="answer" type="String" line="441"/>
                <declaration name="attr" type="Attribute" line="443"/>
                <scope line="444">
                    <scope line="446"/>
                    <scope line="449">
                        <scope line="452">
                            <declaration name="val" type="String" line="453"/>
                            <scope line="454"/>
                        </scope>
                    </scope>
                </scope>
            </method>
            <method name="hexDigit" type="void" line="467">
                <params>
                    <param name="buf" type="StringBuffer"/>
                    <param name="x" type="byte"/>
                </params>
                <declaration name="c" type="char" line="468"/>
            </method>
            <javadoc line="486">
                Returns the string representation of an object (such as an attr value).
                  If obj is a byte array, encode each item as \xx, where xx is hex encoding
                  of the byte value.
                  Else, if obj is not a String, use its string representation (toString()).
                  Special characters in obj (or its string representation) are then
                  encoded appropriately according to RFC 2254.
                         \2a
                  (       \28
                  )       \29
                  \       \5c
                  NUL     \00                
            </javadoc>
            <method name="getEncodedStringRep" type="String" line="499">
                <params>
                    <param name="obj" type="Object"/>
                </params>
                <comment line="505">
                    binary data must be encoded as \hh where hh is a hex char                    
                </comment>
                <declaration name="str" type="String" line="500"/>
                <scope line="504">
                    <declaration name="bytes" type="byte[]" line="506"/>
                    <declaration name="b1" type="StringBuffer" line="507"/>
                    <scope line="508"/>
                </scope>
                <scope line="514"/>
                <scope line="516"/>
                <declaration name="len" type="int" line="519"/>
                <declaration name="buf" type="StringBuffer" line="520"/>
                <declaration name="ch" type="char" line="521"/>
                <scope line="522"/>
            </method>
            <javadoc line="547">
                Finds the first occurrence of &lt;tt&gt;ch&lt;/tt&gt; in &lt;tt&gt;val&lt;/tt&gt; starting
                  from position &lt;tt&gt;start&lt;/tt&gt;. It doesn&apos;t count if &lt;tt&gt;ch&lt;/tt&gt;
                  has been escaped by a backslash (\)                
            </javadoc>
            <method name="findUnescaped" type="int" line="552">
                <params>
                    <param name="ch" type="char"/>
                    <param name="val" type="String"/>
                    <param name="start" type="int"/>
                </params>
                <comment line="557">
                    if at start of string, or not there at all, or if not escaped                    
                </comment>
                <comment line="561">
                    start search after escaped star                    
                </comment>
                <declaration name="len" type="int" line="553"/>
                <scope line="555">
                    <declaration name="where" type="int" line="556"/>
                </scope>
            </method>
            <javadoc line="567">
                Formats the expression &lt;tt&gt;expr&lt;/tt&gt; using arguments from the array
                  &lt;tt&gt;args&lt;/tt&gt;.
                  &lt;code&gt;{i}&lt;/code&gt; specifies the &lt;code&gt;i&lt;/code&gt;&apos;th element from
                  the array &lt;code&gt;args&lt;/code&gt; is to be substituted for the
                  string &quot;&lt;code&gt;{i}&lt;/code&gt;&quot;.
                  To escape &apos;{&apos; or &apos;}&apos; (or any other character), use &apos;\&apos;.
                  Uses getEncodedStringRep() to do encoding.                
            </javadoc>
            <method name="format" type="String" line="581">
                <params>
                    <param name="expr" type="String"/>
                    <param name="args" type="Object[]"/>
                </params>
                <comment line="588">
                    skip &apos;{&apos;                    
                </comment>
                <comment line="595">
                    at this point, pend should be pointing at &apos;}&apos;                    
                </comment>
                <comment line="609">
                    skip &apos;}&apos;                    
                </comment>
                <declaration name="param" type="int" line="583"/>
                <declaration name="where" type="int" line="584"/>
                <declaration name="answer" type="StringBuffer" line="585"/>
                <scope line="587">
                    <declaration name="pstart" type="int" line="588"/>
                    <declaration name="pend" type="int" line="589"/>
                    <scope line="591"/>
                    <scope line="596"/>
                    <scope line="598"/>
                    <scope line="603"/>
                </scope>
            </method>
            <method name="selectAttributes" type="Attributes" line="623">
                <params>
                    <param name="originals" type="Attributes"/>
                    <param name="attrIDs" type="String[]"/>
                </params>
                <declaration name="result" type="Attributes" line="628"/>
                <scope line="630">
                    <declaration name="attr" type="Attribute" line="631"/>
                    <scope line="632"/>
                </scope>
            </method>
        </class>
    </source>