<?xml version="1.0" encoding="UTF-8"?>
    <source package="com.sun.jndi.ldap">
        <import package="javax.naming.NamingException"/>
        <import package="javax.naming.directory.InvalidSearchFilterException"/>
        <import package="java.io.IOException"/>
        <class name="Filter" line="33">
            <comment line="211">
                called by the LdapClient.compare method                
            </comment>
            <comment line="666">
                                
            </comment>
            <comment line="667">
                filter at filtOffset[0] - 1 points to a (. Find ) that matches it                
            </comment>
            <comment line="668">
                and return substring between the parens. Adjust filtOffset[0] to                
            </comment>
            <comment line="669">
                point to char after right paren                
            </comment>
            <comment line="670">
                                
            </comment>
            <comment line="706">
                                
            </comment>
            <comment line="707">
                Encode filter list of type &quot;(filter1)(filter2)...&quot;                
            </comment>
            <comment line="708">
                                
            </comment>
            <comment line="745">
                                
            </comment>
            <comment line="746">
                Encode extensible match                
            </comment>
            <comment line="747">
                                
            </comment>
            <comment line="809">
                //////////////////////////////////////////////////////////////////////////                
            </comment>
            <comment line="810">
                                
            </comment>
            <comment line="811">
                some debug print code that does indenting. Useful for debugging                
            </comment>
            <comment line="812">
                the filter generation code                
            </comment>
            <comment line="813">
                                
            </comment>
            <comment line="814">
                //////////////////////////////////////////////////////////////////////////                
            </comment>
            <comment line="842">
                ///////////// Constants used for encoding filter //////////////                
            </comment>
            <comment line="853">
                LDAPv3                
            </comment>
            <comment line="855">
                LDAPv3                
            </comment>
            <comment line="856">
                LDAPv3                
            </comment>
            <comment line="857">
                LDAPv3                
            </comment>
            <comment line="858">
                LDAPv3                
            </comment>
            <javadoc line="33">
                LDAP (RFC-1960) and LDAPv3 (RFC-2254) search filters.                
                <author>
                    Xuelei Fan                    
                </author>
                <author>
                    Vincent Ryan                    
                </author>
                <author>
                    Jagane Sundar                    
                </author>
                <author>
                    Rosanna Lee                    
                </author>
            </javadoc>
            <javadoc line="44">
                First convert filter string into byte[].
                  For LDAP v3, the conversion uses Unicode -&gt; UTF8
                  For LDAP v2, the conversion uses Unicode -&gt; ISO 8859 (Latin-1)
                  Then parse the byte[] as a filter, converting \hh to
                  a single byte, and encoding the resulting filter
                  into the supplied BER buffer                
            </javadoc>
            <method name="encodeFilterString" type="void" line="54">
                <params>
                    <param name="ber" type="BerEncoder"/>
                    <param name="filterStr" type="String"/>
                    <param name="isLdapv3" type="boolean"/>
                </params>
                <scope line="56"/>
                <declaration name="filter" type="byte[]" line="59"/>
                <declaration name="filterLen" type="int" line="60"/>
                <scope line="61"/>
                <scope line="63"/>
                <scope line="67"/>
            </method>
            <method name="encodeFilter" type="void" line="78">
                <params>
                    <param name="ber" type="BerEncoder"/>
                    <param name="filter" type="byte[]"/>
                    <param name="filterStart" type="int"/>
                    <param name="filterEnd" type="int"/>
                </params>
                <comment line="106">
                    filtOffset[0] has pointed to char after right paren                    
                </comment>
                <comment line="113">
                    filtOffset[0] has pointed to char after right paren                    
                </comment>
                <comment line="120">
                    filtOffset[0] has pointed to char after right paren                    
                </comment>
                <comment line="148">
                    points to the char after right paren.                    
                </comment>
                <comment line="158">
                                        
                </comment>
                <comment line="159">
                    End of sequence                    
                </comment>
                <comment line="160">
                                        
                </comment>
                <comment line="170">
                    assume simple type=value filter                    
                </comment>
                <comment line="172">
                    force break from outer                    
                </comment>
                <scope line="80"/>
                <scope line="85"/>
                <declaration name="nextOffset" type="int" line="89"/>
                <declaration name="parens" type="int" line="90"/>
                <declaration name="escape" type="boolean" line="91"/>
                <declaration name="filtOffset" type="int" line="95"/>
                <scope line="97">
                    <scope line="128">
                        <scope line="129"/>
                    </scope>
                    <scope line="176"/>
                </scope>
                <scope line="182"/>
                <scope line="186"/>
            </method>
            <javadoc line="192">
                convert character &apos;c&apos; that represents a hexadecimal digit to an integer.
                  if &apos;c&apos; is not a hexidecimal digit [0-9A-Fa-f], -1 is returned.
                  otherwise the converted value is returned.                
            </javadoc>
            <method name="hexchar2int" type="int" line="197">
                <params>
                    <param name="c" type="byte"/>
                </params>
                <scope line="198"/>
                <scope line="201"/>
                <scope line="204"/>
            </method>
            <method name="unescapeFilterValue" type="byte[]" line="212">
                <params>
                    <param name="orig" type="byte[]"/>
                    <param name="start" type="int"/>
                    <param name="end" type="int"/>
                </params>
                <comment line="227">
                    Try LDAP V3 escape (\xx)                    
                </comment>
                <comment line="230">
                    If there is no hex char following a &apos;\&apos; when
                     parsing a LDAP v3 filter (illegal by v3 way)
                     we fallback to the way we unescape in v2.                    
                </comment>
                <comment line="236">
                    V2: \* \( \)                    
                </comment>
                <comment line="240">
                    escaping already started but we can&apos;t find 2nd hex                    
                </comment>
                <declaration name="escape" type="boolean" line="213"/>
                <declaration name="ival" type="int" line="214"/>
                <declaration name="ch" type="byte" line="215"/>
                <scope line="217"/>
                <declaration name="len" type="int" line="221"/>
                <declaration name="tbuf" type="byte" line="222"/>
                <declaration name="j" type="int" line="223"/>
                <scope line="224">
                    <scope line="226">
                        <scope line="228">
                            <scope line="235"/>
                            <scope line="239"/>
                        </scope>
                        <scope line="243">
                            <scope line="244"/>
                            <scope line="247"/>
                        </scope>
                    </scope>
                    <scope line="252"/>
                    <scope line="255"/>
                </scope>
                <declaration name="answer" type="byte[]" line="259"/>
                <scope line="261"/>
            </method>
            <method name="indexOf" type="int" line="267">
                <params>
                    <param name="str" type="byte[]"/>
                    <param name="ch" type="char"/>
                    <param name="start" type="int"/>
                    <param name="end" type="int"/>
                </params>
                <scope line="268"/>
            </method>
            <method name="indexOf" type="int" line="275">
                <params>
                    <param name="str" type="byte[]"/>
                    <param name="target" type="String"/>
                    <param name="start" type="int"/>
                    <param name="end" type="int"/>
                </params>
                <declaration name="where" type="int" line="276"/>
                <scope line="277">
                    <scope line="278">
                        <scope line="279"/>
                    </scope>
                </scope>
            </method>
            <method name="findUnescaped" type="int" line="287">
                <params>
                    <param name="str" type="byte[]"/>
                    <param name="ch" type="char"/>
                    <param name="start" type="int"/>
                    <param name="end" type="int"/>
                </params>
                <comment line="291">
                    Count the immediate preceding &apos;\&apos; to find out if
                     this is an escaped &apos;&apos;. This is a made-up way for
                     parsing an escaped &apos;&apos; in v2. This is how the other leading
                     SDK vendors interpret v2.
                     For v3 we fallback to the way we parse &quot;\&quot; in v2.
                     It&apos;s not legal in v3 to use &quot;\&quot; to escape &apos;&apos;; the right
                     way is to use &quot;\2a&quot; instead.                    
                </comment>
                <comment line="306">
                    if at start of string, or not there at all, or if not escaped                    
                </comment>
                <comment line="310">
                    start search after escaped star                    
                </comment>
                <scope line="288">
                    <declaration name="where" type="int" line="289"/>
                    <declaration name="backSlashPos" type="int" line="300"/>
                    <declaration name="backSlashCnt" type="int" line="301"/>
                </scope>
            </method>
            <method name="encodeSimpleFilter" type="void" line="318">
                <params>
                    <param name="ber" type="BerEncoder"/>
                    <param name="filter" type="byte[]"/>
                    <param name="filtStart" type="int"/>
                    <param name="filtEnd" type="int"/>
                </params>
                <comment line="334">
                    value starts after equal sign                    
                </comment>
                <comment line="336">
                    beginning of string                    
                </comment>
                <comment line="359">
                    initializing ftype to make the compiler happy                    
                </comment>
                <comment line="369">
                    check validity of type                    
                </comment>
                <comment line="370">
                                        
                </comment>
                <comment line="371">
                    RFC4512 defines the type as the following ABNF:                    
                </comment>
                <comment line="372">
                    attr = attributedescription                    
                </comment>
                <comment line="373">
                    attributedescription = attributetype options                    
                </comment>
                <comment line="374">
                    attributetype = oid                    
                </comment>
                <comment line="375">
                    oid = descr / numericoid                    
                </comment>
                <comment line="376">
                    descr = keystring                    
                </comment>
                <comment line="377">
                    keystring = leadkeychar *keychar                    
                </comment>
                <comment line="378">
                    leadkeychar = ALPHA                    
                </comment>
                <comment line="379">
                    keychar = ALPHA / DIGIT / HYPHEN                    
                </comment>
                <comment line="380">
                    numericoid = number 1*( DOT number )                    
                </comment>
                <comment line="381">
                    number  = DIGIT / ( LDIGIT 1*DIGIT )                    
                </comment>
                <comment line="382">
                    options = *( SEMI option )                    
                </comment>
                <comment line="383">
                    option = 1*keychar                    
                </comment>
                <comment line="384">
                                        
                </comment>
                <comment line="385">
                    And RFC4515 defines the extensible type as the following ABNF:                    
                </comment>
                <comment line="386">
                    attr [dnattrs] [matchingrule] / [dnattrs] matchingrule                    
                </comment>
                <comment line="396">
                    &apos;;&apos; is an indicator of attribute options                    
                </comment>
                <comment line="403">
                    attribute options                    
                </comment>
                <comment line="408">
                    &apos;:&apos; is an indicator of extensible rules                    
                </comment>
                <comment line="415">
                    extensible matching                    
                </comment>
                <comment line="421">
                    numeric object identifier                    
                </comment>
                <comment line="429">
                    descriptor                    
                </comment>
                <comment line="430">
                    The underscore (&quot;_&quot;) character is not allowed by                    
                </comment>
                <comment line="431">
                    the LDAP specification. We allow it here to                    
                </comment>
                <comment line="432">
                    tolerate the incorrect use in practice.                    
                </comment>
                <comment line="443">
                    extensible matching                    
                </comment>
                <comment line="450">
                    check attribute options                    
                </comment>
                <comment line="461">
                    &apos;:&apos; is an indicator of extensible rules                    
                </comment>
                <comment line="468">
                    extensible matching                    
                </comment>
                <comment line="473">
                    The underscore (&quot;_&quot;) character is not allowed by                    
                </comment>
                <comment line="474">
                    the LDAP specification. We allow it here to                    
                </comment>
                <comment line="475">
                    tolerate the incorrect use in practice.                    
                </comment>
                <comment line="486">
                    check extensible matching                    
                </comment>
                <comment line="499">
                    allows no more than two extensible rules                    
                </comment>
                <comment line="515">
                    numeric object identifier                    
                </comment>
                <comment line="523">
                    descriptor                    
                </comment>
                <comment line="524">
                    The underscore (&quot;_&quot;) character is not allowed by                    
                </comment>
                <comment line="525">
                    the LDAP specification. We allow it here to                    
                </comment>
                <comment line="526">
                    tolerate the incorrect use in practice.                    
                </comment>
                <comment line="543">
                    ensure the latest byte is not isolated                    
                </comment>
                <comment line="550">
                    filter type is of &quot;equal&quot;                    
                </comment>
                <scope line="320"/>
                <declaration name="type" type="String" line="325"/>
                <declaration name="valueStart" type="int" line="326"/>
                <declaration name="eq" type="int" line="328"/>
                <scope line="329"/>
                <declaration name="ftype" type="int" line="338"/>
                <scope line="364"/>
                <declaration name="optionsStart" type="int" line="387"/>
                <declaration name="extensibleStart" type="int" line="388"/>
                <scope line="391">
                    <declaration name="isNumericOid" type="boolean" line="393"/>
                    <scope line="395">
                        <scope line="397">
                            <scope line="398"/>
                        </scope>
                        <scope line="409">
                            <scope line="410"/>
                        </scope>
                        <scope line="420">
                            <scope line="424"/>
                        </scope>
                        <scope line="428">
                            <scope line="436"/>
                        </scope>
                    </scope>
                </scope>
                <scope line="442"/>
                <scope line="445"/>
                <scope line="451">
                    <scope line="452">
                        <scope line="453">
                            <scope line="454"/>
                        </scope>
                        <scope line="462">
                            <scope line="463"/>
                        </scope>
                        <scope line="479"/>
                    </scope>
                </scope>
                <scope line="487">
                    <declaration name="isMatchingRule" type="boolean" line="488"/>
                    <scope line="489">
                        <scope line="490"/>
                        <scope line="495">
                            <declaration name="isNumericOid" type="boolean" line="496"/>
                            <scope line="498">
                                <scope line="500">
                                    <scope line="501"/>
                                    <scope line="505"/>
                                </scope>
                                <scope line="514">
                                    <scope line="518"/>
                                </scope>
                                <scope line="522">
                                    <scope line="530"/>
                                </scope>
                            </scope>
                        </scope>
                        <scope line="536"/>
                    </scope>
                </scope>
                <scope line="545"/>
                <scope line="550">
                    <scope line="551"/>
                    <scope line="554"/>
                    <scope line="556"/>
                </scope>
                <scope line="563"/>
                <scope line="565"/>
                <scope line="568"/>
                <scope line="578"/>
            </method>
            <method name="encodeSubstringFilter" type="void" line="585">
                <params>
                    <param name="ber" type="BerEncoder"/>
                    <param name="filter" type="byte[]"/>
                    <param name="typeStart" type="int"/>
                    <param name="typeEnd" type="int"/>
                    <param name="valueStart" type="int"/>
                    <param name="valueEnd" type="int"/>
                </params>
                <scope line="587"/>
                <declaration name="index" type="int" line="597"/>
                <declaration name="previndex" type="int" line="598"/>
                <scope line="599">
                    <scope line="600">
                        <scope line="601"/>
                    </scope>
                    <scope line="609">
                        <scope line="610"/>
                    </scope>
                </scope>
                <scope line="620"/>
                <scope line="630"/>
            </method>
            <method name="encodeComplexFilter" type="void" line="637">
                <params>
                    <param name="ber" type="BerEncoder"/>
                    <param name="filter" type="byte[]"/>
                    <param name="filterType" type="int"/>
                    <param name="filtOffset" type="int"/>
                    <param name="filtEnd" type="int"/>
                </params>
                <comment line="639">
                                        
                </comment>
                <comment line="640">
                    We have a complex filter of type &quot;&amp;(type=val)(type=val)&quot;                    
                </comment>
                <comment line="641">
                    with filtOffset[0] pointing to the &amp;                    
                </comment>
                <comment line="642">
                                        
                </comment>
                <scope line="644"/>
                <declaration name="parens" type="int[]" line="654"/>
                <scope line="659"/>
            </method>
            <method name="findRightParen" type="int[]" line="671">
                <params>
                    <param name="filter" type="byte[]"/>
                    <param name="filtOffset" type="int"/>
                    <param name="end" type="int"/>
                </params>
                <comment line="695">
                    String tmp = filter.substring(filtOffset[0], nextOffset);                    
                </comment>
                <declaration name="balance" type="int" line="673"/>
                <declaration name="escape" type="boolean" line="674"/>
                <declaration name="nextOffset" type="int" line="675"/>
                <scope line="677">
                    <scope line="678"/>
                </scope>
                <scope line="691"/>
                <declaration name="tmp" type="int[]" line="697"/>
            </method>
            <method name="encodeFilterList" type="void" line="709">
                <params>
                    <param name="ber" type="BerEncoder"/>
                    <param name="filter" type="byte[]"/>
                    <param name="start" type="int"/>
                    <param name="end" type="int"/>
                </params>
                <comment line="729">
                    add enclosing parens                    
                </comment>
                <scope line="711"/>
                <declaration name="filtOffset" type="int" line="716"/>
                <scope line="719">
                    <scope line="723"/>
                    <declaration name="parens" type="int[]" line="727"/>
                    <declaration name="len" type="int" line="730"/>
                    <declaration name="newfilter" type="byte[]" line="731"/>
                </scope>
                <scope line="738"/>
            </method>
            <method name="encodeExtensibleMatch" type="void" line="749">
                <params>
                    <param name="ber" type="BerEncoder"/>
                    <param name="filter" type="byte[]"/>
                    <param name="matchStart" type="int"/>
                    <param name="matchEnd" type="int"/>
                    <param name="valueStart" type="int"/>
                    <param name="valueEnd" type="int"/>
                </params>
                <comment line="758">
                    test for colon separator                    
                </comment>
                <comment line="761">
                    test for match DN                    
                </comment>
                <comment line="766">
                    test for matching rule                    
                </comment>
                <comment line="784">
                    test for attribute type                    
                </comment>
                <comment line="798">
                    This element is defined in RFC-2251 with an ASN.1 DEFAULT tag.
                     However, for Active Directory interoperability it is transmitted
                     even when FALSE.                    
                </comment>
                <declaration name="matchDN" type="boolean" line="751"/>
                <declaration name="colon" type="int" line="752"/>
                <declaration name="colon2" type="int" line="753"/>
                <declaration name="i" type="int" line="754"/>
                <scope line="759">
                    <scope line="762"/>
                    <scope line="768">
                        <scope line="770"/>
                        <scope line="774"/>
                        <scope line="778"/>
                    </scope>
                    <scope line="785"/>
                </scope>
                <scope line="789"/>
            </method>
            <declaration name="dbg" type="boolean" line="815"/>
            <declaration name="dbgIndent" type="int" line="816"/>
            <method name="dprint" type="void" line="818">
                <params>
                    <param name="msg" type="String"/>
                </params>
            </method>
            <method name="dprint" type="void" line="822">
                <params>
                    <param name="msg" type="String"/>
                    <param name="str" type="byte[]"/>
                </params>
            </method>
            <method name="dprint" type="void" line="826">
                <params>
                    <param name="msg" type="String"/>
                    <param name="str" type="byte[]"/>
                    <param name="start" type="int"/>
                    <param name="end" type="int"/>
                </params>
                <declaration name="dstr" type="String" line="827"/>
                <declaration name="i" type="int" line="828"/>
                <scope line="829"/>
                <scope line="835"/>
            </method>
            <declaration name="LDAP_FILTER_AND" type="int" line="843"/>
            <declaration name="LDAP_FILTER_OR" type="int" line="844"/>
            <declaration name="LDAP_FILTER_NOT" type="int" line="845"/>
            <declaration name="LDAP_FILTER_EQUALITY" type="int" line="846"/>
            <declaration name="LDAP_FILTER_SUBSTRINGS" type="int" line="847"/>
            <declaration name="LDAP_FILTER_GE" type="int" line="848"/>
            <declaration name="LDAP_FILTER_LE" type="int" line="849"/>
            <declaration name="LDAP_FILTER_PRESENT" type="int" line="850"/>
            <declaration name="LDAP_FILTER_APPROX" type="int" line="851"/>
            <declaration name="LDAP_FILTER_EXT" type="int" line="852"/>
            <declaration name="LDAP_FILTER_EXT_RULE" type="int" line="854"/>
            <declaration name="LDAP_FILTER_EXT_TYPE" type="int" line="855"/>
            <declaration name="LDAP_FILTER_EXT_VAL" type="int" line="856"/>
            <declaration name="LDAP_FILTER_EXT_DN" type="int" line="857"/>
            <declaration name="LDAP_SUBSTRING_INITIAL" type="int" line="859"/>
            <declaration name="LDAP_SUBSTRING_ANY" type="int" line="860"/>
            <declaration name="LDAP_SUBSTRING_FINAL" type="int" line="861"/>
        </class>
    </source>