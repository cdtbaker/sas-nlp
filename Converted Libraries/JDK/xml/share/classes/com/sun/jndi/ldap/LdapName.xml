<?xml version="1.0" encoding="UTF-8"?>
    <source package="com.sun.jndi.ldap">
        <import package="java.util.Enumeration"/>
        <import package="java.util.Vector"/>
        <import package="javax.naming"/>
        <import package="javax.naming.directory.Attributes"/>
        <import package="javax.naming.directory.Attribute"/>
        <import package="javax.naming.directory.BasicAttributes"/>
        <class name="LdapName" line="38">
            <comment line="81">
                if non-null, the DN in unparsed form                
            </comment>
            <comment line="82">
                parsed name components                
            </comment>
            <comment line="97">
                Constructs an LDAP name given its parsed components and, optionally
                 (if &quot;name&quot; is not null), the unparsed DN.                
            </comment>
            <comment line="106">
                Constructs an LDAP name given its parsed components (the elements
                 of &quot;rdns&quot; in the range [beg,end)) and, optionally
                 (if &quot;name&quot; is not null), the unparsed DN.                
            </comment>
            <comment line="246">
                Helper method for startsWith() and endsWith().
                 Returns true if components [beg,end) match the components of &quot;n&quot;.
                 If &quot;n&quot; is not an LdapName, each of its components is parsed as
                 the string form of an RDN.
                 The following must hold:  end - beg == n.size().                
            </comment>
            <comment line="279">
                If &quot;suffix&quot; is not an LdapName, each of its components is parsed as
                 the string form of an RDN.                
            </comment>
            <comment line="324">
                Best guess as to what RFC 2253 means by &quot;whitespace&quot;.                
            </comment>
            <comment line="385">
                DnParser implements a recursive descent parser for a single DN.                
            </comment>
            <comment line="590">
                Class Rdn represents a set of TypeAndValue.                
            </comment>
            <comment line="678">
                Class TypeAndValue represents an attribute type and its
                 corresponding value.                
            </comment>
            <comment line="985">
                For testing.                
            </comment>
            <comment line="988">
                public static void main(String[] args) {
                
                try {
                if (args.length == 1) {              parse and print components
                LdapName n = new LdapName(args[0]);
                
                Enumeration rdns = n.rdns.elements();
                while (rdns.hasMoreElements()) {
                Rdn rdn = (Rdn)rdns.nextElement();
                for (int i = 0; i &lt; rdn.tvs.size(); i++) {
                System.out.print(&quot;[&quot; + rdn.tvs.elementAt(i) + &quot;]&quot;);
                }
                System.out.println();
                }
                
                } else {                             compare two names
                LdapName n1 = new LdapName(args[0]);
                LdapName n2 = new LdapName(args[1]);
                n1.unparsed = null;
                n2.unparsed = null;
                boolean eq = n1.equals(n2);
                System.out.println(&quot;[&quot; + n1 + (eq ? &quot;] == [&quot; : &quot;] != [&quot;)
                + n2 + &quot;]&quot;);
                }
                } catch (Exception e) {
                e.printStackTrace();
                }
                }                
            </comment>
            <implements interface="Name"/>
            <javadoc line="38">
                &lt;code&gt;LdapName&lt;/code&gt; implements compound names for LDAP v3 as
                  specified by RFC 2253.
                  &lt;p&gt;
                  RFC 2253 has a few ambiguities and outright inconsistencies.  These
                  are resolved as follows:
                  &lt;ul&gt;
                  &lt;li&gt; RFC 2253 leaves the term &quot;whitespace&quot; undefined.  The
                  definition of &quot;optional-space&quot; given in RFC 1779 is used in
                  its place:  either a space character or a carriage return (&quot;\r&quot;).
                  &lt;li&gt; Whitespace is allowed on either side of &apos;,&apos;, &apos;;&apos;, &apos;=&apos;, and &apos;+&apos;.
                  Such whitespace is accepted but not generated by this code,
                  and is ignored when comparing names.
                  &lt;li&gt; AttributeValue strings containing &apos;=&apos; or non-leading &apos;#&apos;
                  characters (unescaped) are accepted.
                  &lt;/ul&gt;
                  &lt;p&gt;
                  String names passed to &lt;code&gt;LdapName&lt;/code&gt; or returned by it
                  use the full 16-bit Unicode character set.  They may also contain
                  characters encoded into UTF-8 with each octet represented by a
                  three-character substring such as &quot;\\B4&quot;.
                  They may not, however, contain characters encoded into UTF-8 with
                  each octet represented by a single character in the string:  the
                  meaning would be ambiguous.
                  &lt;p&gt;
                  &lt;code&gt;LdapName&lt;/code&gt; will properly parse all valid names, but
                  does not attempt to detect all possible violations when parsing
                  invalid names.  It&apos;s &quot;generous&quot;.
                  &lt;p&gt;
                  When names are tested for equality, attribute types and binary
                  values are case-insensitive, and string values are by default
                  case-insensitive.
                  String values with different but equivalent usage of quoting,
                  escaping, or UTF8-hex-encoding are considered equal.  The order of
                  components in multi-valued RDNs (such as &quot;ou=Sales+cn=Bob&quot;) is not
                  significant.                
                <author>
                    Scott Seligman                    
                </author>
            </javadoc>
            <declaration name="unparsed" type="String" line="80"/>
            <declaration name="rdns" type="Vector" line="81"/>
            <declaration name="valuesCaseSensitive" type="boolean" line="82"/>
            <javadoc line="84">
                Constructs an LDAP name from the given DN.                
                <param>
                    name      An LDAP DN.  To JNDI, a compound name.                    
                </param>
                <throws>
                    InvalidNameException if a syntax violation is detected.                    
                </throws>
            </javadoc>
            <method name="LdapName" type="constructor" line="91">
                <params>
                    <param name="name" type="String"/>
                </params>
            </method>
            <method name="LdapName" type="constructor" line="100">
                <params>
                    <param name="name" type="String"/>
                    <param name="rdns" type="Vector"/>
                </params>
            </method>
            <method name="LdapName" type="constructor" line="110">
                <params>
                    <param name="name" type="String"/>
                    <param name="rdns" type="Vector"/>
                    <param name="beg" type="int"/>
                    <param name="end" type="int"/>
                </params>
                <scope line="113"/>
            </method>
            <method name="clone" type="Object" line="119"/>
            <method name="toString" type="String" line="123">
                <scope line="124"/>
                <declaration name="buf" type="StringBuffer" line="128"/>
                <scope line="129">
                    <scope line="130"/>
                    <declaration name="rdn" type="Rdn" line="133"/>
                </scope>
            </method>
            <method name="equals" type="boolean" line="141">
                <params>
                    <param name="obj" type="Object"/>
                </params>
            </method>
            <method name="compareTo" type="int" line="146">
                <params>
                    <param name="obj" type="Object"/>
                </params>
                <comment line="149">
                    check possible shortcuts                    
                </comment>
                <comment line="154">
                    Compare RDNs one by one, lexicographically.                    
                </comment>
                <comment line="157">
                    Compare a single pair of RDNs.                    
                </comment>
                <comment line="166">
                    longer DN wins                    
                </comment>
                <declaration name="that" type="LdapName" line="147"/>
                <scope line="150"/>
                <declaration name="minSize" type="int" line="155"/>
                <scope line="156">
                    <declaration name="rdn1" type="Rdn" line="158"/>
                    <declaration name="rdn2" type="Rdn" line="159"/>
                    <declaration name="diff" type="int" line="161"/>
                    <scope line="162"/>
                </scope>
            </method>
            <method name="hashCode" type="int" line="169">
                <comment line="170">
                    Sum up the hash codes of the components.                    
                </comment>
                <comment line="173">
                    For each RDN...                    
                </comment>
                <declaration name="hash" type="int" line="171"/>
                <scope line="174">
                    <declaration name="rdn" type="Rdn" line="175"/>
                </scope>
            </method>
            <method name="size" type="int" line="181"/>
            <method name="isEmpty" type="boolean" line="185"/>
            <method name="getAll" type="Enumeration" line="189">
                <declaration name="enum_" type="Enumeration" line="190"/>
                <anonymous_class line="192">
                    <method name="hasMoreElements" type="boolean" line="193"/>
                    <method name="nextElement" type="Object" line="196"/>
                </anonymous_class>
            </method>
            <method name="get" type="String" line="202">
                <params>
                    <param name="pos" type="int"/>
                </params>
            </method>
            <method name="getPrefix" type="Name" line="206">
                <params>
                    <param name="pos" type="int"/>
                </params>
            </method>
            <method name="getSuffix" type="Name" line="210">
                <params>
                    <param name="pos" type="int"/>
                </params>
            </method>
            <method name="startsWith" type="boolean" line="214">
                <params>
                    <param name="n" type="Name"/>
                </params>
                <declaration name="len1" type="int" line="215"/>
                <declaration name="len2" type="int" line="216"/>
            </method>
            <method name="endsWith" type="boolean" line="221">
                <params>
                    <param name="n" type="Name"/>
                </params>
                <declaration name="len1" type="int" line="222"/>
                <declaration name="len2" type="int" line="223"/>
            </method>
            <javadoc line="228">
                Controls whether string-values are treated as case-sensitive
                  when the string values within names are compared.  The default
                  behavior is case-insensitive comparison.                
            </javadoc>
            <method name="setValuesCaseSensitive" type="void" line="233">
                <params>
                    <param name="caseSensitive" type="boolean"/>
                </params>
                <comment line="235">
                    clear any cached information                    
                </comment>
                <comment line="239">
                    shouldn&apos;t happen                    
                </comment>
                <scope line="236"/>
                <scope line="238"/>
            </method>
            <method name="matches" type="boolean" line="252">
                <params>
                    <param name="beg" type="int"/>
                    <param name="end" type="int"/>
                    <param name="n" type="Name"/>
                </params>
                <scope line="253">
                    <declaration name="rdn" type="Rdn" line="254"/>
                    <scope line="255">
                        <declaration name="ln" type="LdapName" line="256"/>
                    </scope>
                    <scope line="258">
                        <declaration name="rdnString" type="String" line="259"/>
                        <scope line="260"/>
                        <scope line="262"/>
                    </scope>
                    <scope line="267"/>
                </scope>
            </method>
            <method name="addAll" type="Name" line="274">
                <params>
                    <param name="suffix" type="Name"/>
                </params>
            </method>
            <method name="addAll" type="Name" line="282">
                <params>
                    <param name="pos" type="int"/>
                    <param name="suffix" type="Name"/>
                </params>
                <comment line="296">
                    no longer valid                    
                </comment>
                <scope line="283">
                    <declaration name="s" type="LdapName" line="284"/>
                    <scope line="285"/>
                </scope>
                <scope line="288">
                    <declaration name="comps" type="Enumeration" line="289"/>
                    <scope line="290">
                        <declaration name="p" type="DnParser" line="291"/>
                    </scope>
                </scope>
            </method>
            <method name="add" type="Name" line="300">
                <params>
                    <param name="comp" type="String"/>
                </params>
            </method>
            <method name="add" type="Name" line="304">
                <params>
                    <param name="pos" type="int"/>
                    <param name="comp" type="String"/>
                </params>
                <comment line="307">
                    no longer valid                    
                </comment>
                <declaration name="rdn" type="Rdn" line="305"/>
            </method>
            <method name="remove" type="Object" line="311">
                <params>
                    <param name="pos" type="int"/>
                </params>
                <comment line="314">
                    no longer valid                    
                </comment>
                <declaration name="comp" type="String" line="312"/>
            </method>
            <method name="parse" type="void" line="319"/>
            <method name="isWhitespace" type="boolean" line="326">
                <params>
                    <param name="c" type="char"/>
                </params>
            </method>
            <javadoc line="330">
                Given the value of an attribute, returns a string suitable
                  for inclusion in a DN.  If the value is a string, this is
                  accomplished by using backslash (\) to escape the following
                  characters:
                  &lt;ul&gt;
                  &lt;li&gt;leading and trailing whitespace
                  &lt;li&gt;&lt;pre&gt;, = + &lt; &gt; # ; &quot; \&lt;/pre&gt;
                  &lt;/ul&gt;
                  If the value is a byte array, it is converted to hex
                  notation (such as &quot;#CEB1DF80&quot;).                
            </javadoc>
            <method name="escapeAttributeValue" type="String" line="342">
                <params>
                    <param name="val" type="Object"/>
                </params>
            </method>
            <javadoc line="346">
                Given an attribute value formated according to RFC 2253,
                  returns the unformated value.  Returns a string value as
                  a string, and a binary value as a byte array.                
            </javadoc>
            <method name="unescapeAttributeValue" type="Object" line="351">
                <params>
                    <param name="val" type="String"/>
                </params>
            </method>
            <javadoc line="355">
                Serializes only the unparsed DN, for compactness and to avoid
                  any implementation dependency.                
                <serialdata>
                    The DN string and a boolean indicating whether
                      the values are case sensitive.                    
                </serialdata>
            </javadoc>
            <method name="writeObject" type="void" line="363">
                <params>
                    <param name="s" type="java.io.ObjectOutputStream"/>
                </params>
            </method>
            <method name="readObject" type="void" line="369">
                <params>
                    <param name="s" type="java.io.ObjectInputStream"/>
                </params>
                <comment line="375">
                    shouldn&apos;t happen                    
                </comment>
                <scope line="372"/>
                <scope line="374"/>
            </method>
            <declaration name="serialVersionUID" type="long" line="381"/>
            <class name="DnParser" line="387">
                <comment line="390">
                    DN being parsed                    
                </comment>
                <comment line="391">
                    characters in LDAP name being parsed                    
                </comment>
                <comment line="392">
                    length of &quot;chars&quot;                    
                </comment>
                <comment line="393">
                    index of first unconsumed char in &quot;chars&quot;                    
                </comment>
                <comment line="396">
                    Given an LDAP DN in string form, returns a parser for it.                    
                </comment>
                <comment line="407">
                    Parses the DN, returning a Vector of its RDNs.                    
                </comment>
                <comment line="430">
                    Parses the DN, if it is known to contain a single RDN.                    
                </comment>
                <comment line="441">
                    Parses the next RDN and returns it.  Throws an exception if
                     none is found.  Leading and trailing whitespace is consumed.                    
                </comment>
                <comment line="469">
                    Returns the attribute type that begins at the next unconsumed
                     char.  No leading whitespace is expected.
                     This routine is more generous than RFC 2253.  It accepts
                     attribute types composed of any nonempty combination of Unicode
                     letters, Unicode digits, &apos;.&apos;, &apos;-&apos;, and internal space characters.                    
                </comment>
                <comment line="501">
                    Returns the attribute value that begins at the next unconsumed
                     char.  No leading whitespace is expected.                    
                </comment>
                <comment line="577">
                    Returns true if next unconsumed character is one that terminates
                     a string attribute value.                    
                </comment>
                <comment line="595">
                    A vector of the TypeAndValue elements of this Rdn.
                     It is sorted to facilitate set operations.                    
                </comment>
                <comment line="634">
                    Compare TypeAndValue components one by one, lexicographically.                    
                </comment>
                <comment line="685">
                    value, escaped or quoted                    
                </comment>
                <comment line="689">
                    If non-null, a canonical represention of the value suitable                    
                </comment>
                <comment line="690">
                    for comparison using String.compareTo().                    
                </comment>
                <comment line="737">
                    Returns the type.                    
                </comment>
                <comment line="744">
                    Returns the unescaped value.                    
                </comment>
                <comment line="751">
                    Returns a canonical representation of &quot;value&quot; suitable for
                     comparison using String.compareTo().  If &quot;value&quot; is a string,
                     it is returned with escapes and quotes stripped away, and
                     hex-encoded UTF-8 converted to 16-bit Unicode chars.
                     If value&apos;s case is to be ignored, it is returned in uppercase.
                     If &quot;value&quot; is binary, it is returned in uppercase but
                     otherwise unmodified.                    
                </comment>
                <comment line="777">
                    Given the value of an attribute, returns a string suitable
                     for inclusion in a DN.                    
                </comment>
                <comment line="787">
                    Given the value of a string-valued attribute, returns a
                     string suitable for inclusion in a DN.  This is accomplished by
                     using backslash (\) to escape the following characters:
                          leading and trailing whitespace
                          , = + &lt; &gt; # ; &quot; \                    
                </comment>
                <comment line="824">
                    Given the value of a binary attribute, returns a string
                     suitable for inclusion in a DN (such as &quot;#CEB1DF80&quot;).                    
                </comment>
                <comment line="842">
                    Given an attribute value formated according to RFC 2253,
                     returns the unformated value.  Escapes and quotes are
                     stripped away, and hex-encoded UTF-8 is converted to 16-bit
                     Unicode chars.  Returns a string value as a String, and a
                     binary value as a byte array.                    
                </comment>
                <comment line="929">
                    Given an array of chars (with starting and ending indexes into it)
                     representing bytes encoded as hex-pairs (such as &quot;CEB1DF80&quot;),
                     returns a byte array containing the decoded bytes.                    
                </comment>
                <comment line="952">
                    Given an array of chars (with starting and ending indexes into it),
                     finds the largest prefix consisting of hex-encoded UTF-8 octets,
                     and returns a byte array containing the corresponding UTF-8 octets.
                    
                     Hex-encoded UTF-8 octets look like this:
                          \03\B1\DF\80                    
                </comment>
                <declaration name="name" type="String" line="389"/>
                <declaration name="chars" type="char[]" line="390"/>
                <declaration name="len" type="int" line="391"/>
                <declaration name="cur" type="int" line="392"/>
                <declaration name="valuesCaseSensitive" type="boolean" line="393"/>
                <method name="DnParser" type="constructor" line="399">
                    <params>
                        <param name="name" type="String"/>
                        <param name="valuesCaseSensitive" type="boolean"/>
                    </params>
                </method>
                <method name="getDn" type="Vector" line="409">
                    <comment line="411">
                        leave room for growth                        
                    </comment>
                    <declaration name="rdns" type="Vector" line="411"/>
                    <scope line="413"/>
                    <scope line="418">
                        <scope line="419"/>
                        <scope line="422"/>
                    </scope>
                </method>
                <method name="getRdn" type="Rdn" line="432">
                    <declaration name="rdn" type="Rdn" line="433"/>
                    <scope line="434"/>
                </method>
                <method name="parseRdn" type="Rdn" line="444">
                    <comment line="454">
                        consume &apos;=&apos;                        
                    </comment>
                    <comment line="463">
                        consume &apos;+&apos;                        
                    </comment>
                    <declaration name="rdn" type="Rdn" line="446"/>
                    <scope line="447">
                        <declaration name="attrType" type="String" line="449"/>
                        <scope line="451"/>
                        <declaration name="value" type="String" line="456"/>
                        <scope line="460"/>
                    </scope>
                </method>
                <method name="parseAttrType" type="String" line="475">
                    <comment line="489">
                        Back out any trailing spaces.                        
                    </comment>
                    <declaration name="beg" type="int" line="477"/>
                    <scope line="478">
                        <declaration name="c" type="char" line="479"/>
                        <scope line="483"/>
                        <scope line="485"/>
                    </scope>
                    <scope line="490"/>
                    <scope line="494"/>
                </method>
                <method name="parseAttrValue" type="String" line="504">
                    <scope line="506"/>
                    <scope line="508"/>
                    <scope line="510"/>
                </method>
                <method name="parseBinaryAttrValue" type="String" line="515">
                    <comment line="517">
                        consume &apos;#&apos;                        
                    </comment>
                    <declaration name="beg" type="int" line="516"/>
                    <scope line="519"/>
                </method>
                <method name="parseQuotedAttrValue" type="String" line="525">
                    <comment line="528">
                        consume &apos;&quot;&apos;                        
                    </comment>
                    <comment line="532">
                        consume backslash, then what follows                        
                    </comment>
                    <comment line="536">
                        no closing quote                        
                    </comment>
                    <comment line="539">
                        consume closing quote                        
                    </comment>
                    <declaration name="beg" type="int" line="527"/>
                    <scope line="530">
                        <scope line="531"/>
                    </scope>
                    <scope line="536"/>
                </method>
                <method name="parseStringAttrValue" type="String" line="544">
                    <comment line="547">
                        index of the most recently escaped character                        
                    </comment>
                    <comment line="551">
                        consume backslash, then what follows                        
                    </comment>
                    <comment line="556">
                        &apos;twas backslash followed by nothing                        
                    </comment>
                    <comment line="560">
                        Trim off (unescaped) trailing whitespace.                        
                    </comment>
                    <declaration name="beg" type="int" line="546"/>
                    <declaration name="esc" type="int" line="547"/>
                    <scope line="549">
                        <scope line="550"/>
                    </scope>
                    <scope line="556"/>
                    <declaration name="end" type="int" line="561"/>
                    <scope line="562">
                        <scope line="563"/>
                    </scope>
                </method>
                <method name="consumeWhitespace" type="void" line="570">
                    <scope line="571"/>
                </method>
                <method name="atTerminator" type="boolean" line="580"/>
            </class>
            <class name="Rdn" line="592">
                <comment line="390">
                    DN being parsed                    
                </comment>
                <comment line="391">
                    characters in LDAP name being parsed                    
                </comment>
                <comment line="392">
                    length of &quot;chars&quot;                    
                </comment>
                <comment line="393">
                    index of first unconsumed char in &quot;chars&quot;                    
                </comment>
                <comment line="396">
                    Given an LDAP DN in string form, returns a parser for it.                    
                </comment>
                <comment line="407">
                    Parses the DN, returning a Vector of its RDNs.                    
                </comment>
                <comment line="430">
                    Parses the DN, if it is known to contain a single RDN.                    
                </comment>
                <comment line="441">
                    Parses the next RDN and returns it.  Throws an exception if
                     none is found.  Leading and trailing whitespace is consumed.                    
                </comment>
                <comment line="469">
                    Returns the attribute type that begins at the next unconsumed
                     char.  No leading whitespace is expected.
                     This routine is more generous than RFC 2253.  It accepts
                     attribute types composed of any nonempty combination of Unicode
                     letters, Unicode digits, &apos;.&apos;, &apos;-&apos;, and internal space characters.                    
                </comment>
                <comment line="501">
                    Returns the attribute value that begins at the next unconsumed
                     char.  No leading whitespace is expected.                    
                </comment>
                <comment line="577">
                    Returns true if next unconsumed character is one that terminates
                     a string attribute value.                    
                </comment>
                <comment line="595">
                    A vector of the TypeAndValue elements of this Rdn.
                     It is sorted to facilitate set operations.                    
                </comment>
                <comment line="634">
                    Compare TypeAndValue components one by one, lexicographically.                    
                </comment>
                <comment line="685">
                    value, escaped or quoted                    
                </comment>
                <comment line="689">
                    If non-null, a canonical represention of the value suitable                    
                </comment>
                <comment line="690">
                    for comparison using String.compareTo().                    
                </comment>
                <comment line="737">
                    Returns the type.                    
                </comment>
                <comment line="744">
                    Returns the unescaped value.                    
                </comment>
                <comment line="751">
                    Returns a canonical representation of &quot;value&quot; suitable for
                     comparison using String.compareTo().  If &quot;value&quot; is a string,
                     it is returned with escapes and quotes stripped away, and
                     hex-encoded UTF-8 converted to 16-bit Unicode chars.
                     If value&apos;s case is to be ignored, it is returned in uppercase.
                     If &quot;value&quot; is binary, it is returned in uppercase but
                     otherwise unmodified.                    
                </comment>
                <comment line="777">
                    Given the value of an attribute, returns a string suitable
                     for inclusion in a DN.                    
                </comment>
                <comment line="787">
                    Given the value of a string-valued attribute, returns a
                     string suitable for inclusion in a DN.  This is accomplished by
                     using backslash (\) to escape the following characters:
                          leading and trailing whitespace
                          , = + &lt; &gt; # ; &quot; \                    
                </comment>
                <comment line="824">
                    Given the value of a binary attribute, returns a string
                     suitable for inclusion in a DN (such as &quot;#CEB1DF80&quot;).                    
                </comment>
                <comment line="842">
                    Given an attribute value formated according to RFC 2253,
                     returns the unformated value.  Escapes and quotes are
                     stripped away, and hex-encoded UTF-8 is converted to 16-bit
                     Unicode chars.  Returns a string value as a String, and a
                     binary value as a byte array.                    
                </comment>
                <comment line="929">
                    Given an array of chars (with starting and ending indexes into it)
                     representing bytes encoded as hex-pairs (such as &quot;CEB1DF80&quot;),
                     returns a byte array containing the decoded bytes.                    
                </comment>
                <comment line="952">
                    Given an array of chars (with starting and ending indexes into it),
                     finds the largest prefix consisting of hex-encoded UTF-8 octets,
                     and returns a byte array containing the corresponding UTF-8 octets.
                    
                     Hex-encoded UTF-8 octets look like this:
                          \03\B1\DF\80                    
                </comment>
                <declaration name="tvs" type="Vector" line="598"/>
                <method name="add" type="void" line="600">
                    <params>
                        <param name="tv" type="TypeAndValue"/>
                    </params>
                    <comment line="602">
                        Set i to index of first element greater than tv, or to                        
                    </comment>
                    <comment line="603">
                        tvs.size() if there is none.                        
                    </comment>
                    <comment line="608">
                        tv is a duplicate:  ignore it                        
                    </comment>
                    <declaration name="i" type="int" line="604"/>
                    <scope line="605">
                        <declaration name="diff" type="int" line="606"/>
                        <scope line="607"/>
                        <scope line="609"/>
                    </scope>
                </method>
                <method name="toString" type="String" line="617">
                    <declaration name="buf" type="StringBuffer" line="618"/>
                    <scope line="619">
                        <scope line="620"/>
                    </scope>
                </method>
                <method name="equals" type="boolean" line="628">
                    <params>
                        <param name="obj" type="Object"/>
                    </params>
                </method>
                <method name="compareTo" type="int" line="634">
                    <params>
                        <param name="obj" type="Object"/>
                    </params>
                    <comment line="638">
                        Compare a single pair of type/value pairs.                        
                    </comment>
                    <comment line="645">
                        longer RDN wins                        
                    </comment>
                    <declaration name="that" type="Rdn" line="635"/>
                    <declaration name="minSize" type="int" line="636"/>
                    <scope line="637">
                        <declaration name="tv" type="TypeAndValue" line="639"/>
                        <declaration name="diff" type="int" line="640"/>
                        <scope line="641"/>
                    </scope>
                </method>
                <method name="hashCode" type="int" line="648">
                    <comment line="649">
                        Sum up the hash codes of the components.                        
                    </comment>
                    <comment line="652">
                        For each type/value pair...                        
                    </comment>
                    <declaration name="hash" type="int" line="650"/>
                    <scope line="653"/>
                </method>
                <method name="toAttributes" type="Attributes" line="659">
                    <declaration name="attrs" type="Attributes" line="660"/>
                    <declaration name="tv" type="TypeAndValue" line="661"/>
                    <declaration name="attr" type="Attribute" line="662"/>
                    <scope line="664">
                        <scope line="666"/>
                        <scope line="668"/>
                    </scope>
                </method>
            </class>
            <class name="TypeAndValue" line="681">
                <comment line="390">
                    DN being parsed                    
                </comment>
                <comment line="391">
                    characters in LDAP name being parsed                    
                </comment>
                <comment line="392">
                    length of &quot;chars&quot;                    
                </comment>
                <comment line="393">
                    index of first unconsumed char in &quot;chars&quot;                    
                </comment>
                <comment line="396">
                    Given an LDAP DN in string form, returns a parser for it.                    
                </comment>
                <comment line="407">
                    Parses the DN, returning a Vector of its RDNs.                    
                </comment>
                <comment line="430">
                    Parses the DN, if it is known to contain a single RDN.                    
                </comment>
                <comment line="441">
                    Parses the next RDN and returns it.  Throws an exception if
                     none is found.  Leading and trailing whitespace is consumed.                    
                </comment>
                <comment line="469">
                    Returns the attribute type that begins at the next unconsumed
                     char.  No leading whitespace is expected.
                     This routine is more generous than RFC 2253.  It accepts
                     attribute types composed of any nonempty combination of Unicode
                     letters, Unicode digits, &apos;.&apos;, &apos;-&apos;, and internal space characters.                    
                </comment>
                <comment line="501">
                    Returns the attribute value that begins at the next unconsumed
                     char.  No leading whitespace is expected.                    
                </comment>
                <comment line="577">
                    Returns true if next unconsumed character is one that terminates
                     a string attribute value.                    
                </comment>
                <comment line="595">
                    A vector of the TypeAndValue elements of this Rdn.
                     It is sorted to facilitate set operations.                    
                </comment>
                <comment line="634">
                    Compare TypeAndValue components one by one, lexicographically.                    
                </comment>
                <comment line="685">
                    value, escaped or quoted                    
                </comment>
                <comment line="689">
                    If non-null, a canonical represention of the value suitable                    
                </comment>
                <comment line="690">
                    for comparison using String.compareTo().                    
                </comment>
                <comment line="737">
                    Returns the type.                    
                </comment>
                <comment line="744">
                    Returns the unescaped value.                    
                </comment>
                <comment line="751">
                    Returns a canonical representation of &quot;value&quot; suitable for
                     comparison using String.compareTo().  If &quot;value&quot; is a string,
                     it is returned with escapes and quotes stripped away, and
                     hex-encoded UTF-8 converted to 16-bit Unicode chars.
                     If value&apos;s case is to be ignored, it is returned in uppercase.
                     If &quot;value&quot; is binary, it is returned in uppercase but
                     otherwise unmodified.                    
                </comment>
                <comment line="777">
                    Given the value of an attribute, returns a string suitable
                     for inclusion in a DN.                    
                </comment>
                <comment line="787">
                    Given the value of a string-valued attribute, returns a
                     string suitable for inclusion in a DN.  This is accomplished by
                     using backslash (\) to escape the following characters:
                          leading and trailing whitespace
                          , = + &lt; &gt; # ; &quot; \                    
                </comment>
                <comment line="824">
                    Given the value of a binary attribute, returns a string
                     suitable for inclusion in a DN (such as &quot;#CEB1DF80&quot;).                    
                </comment>
                <comment line="842">
                    Given an attribute value formated according to RFC 2253,
                     returns the unformated value.  Escapes and quotes are
                     stripped away, and hex-encoded UTF-8 is converted to 16-bit
                     Unicode chars.  Returns a string value as a String, and a
                     binary value as a byte array.                    
                </comment>
                <comment line="929">
                    Given an array of chars (with starting and ending indexes into it)
                     representing bytes encoded as hex-pairs (such as &quot;CEB1DF80&quot;),
                     returns a byte array containing the decoded bytes.                    
                </comment>
                <comment line="952">
                    Given an array of chars (with starting and ending indexes into it),
                     finds the largest prefix consisting of hex-encoded UTF-8 octets,
                     and returns a byte array containing the corresponding UTF-8 octets.
                    
                     Hex-encoded UTF-8 octets look like this:
                          \03\B1\DF\80                    
                </comment>
                <declaration name="type" type="String" line="683"/>
                <declaration name="value" type="String" line="684"/>
                <declaration name="binary" type="boolean" line="685"/>
                <declaration name="valueCaseSensitive" type="boolean" line="686"/>
                <declaration name="comparable" type="String" line="690"/>
                <method name="TypeAndValue" type="constructor" line="692">
                    <params>
                        <param name="type" type="String"/>
                        <param name="value" type="String"/>
                        <param name="valueCaseSensitive" type="boolean"/>
                    </params>
                </method>
                <method name="toString" type="String" line="699"/>
                <method name="compareTo" type="int" line="703">
                    <params>
                        <param name="obj" type="Object"/>
                    </params>
                    <comment line="704">
                        NB: Any change here affecting equality must be                        
                    </comment>
                    <comment line="705">
                        reflected in hashCode().                        
                    </comment>
                    <comment line="713">
                        try shortcut                        
                    </comment>
                    <declaration name="that" type="TypeAndValue" line="707"/>
                    <declaration name="diff" type="int" line="709"/>
                    <scope line="710"/>
                    <scope line="713"/>
                </method>
                <method name="equals" type="boolean" line="719">
                    <params>
                        <param name="obj" type="Object"/>
                    </params>
                    <comment line="720">
                        NB:  Any change here must be reflected in hashCode().                        
                    </comment>
                    <scope line="721"/>
                    <declaration name="that" type="TypeAndValue" line="724"/>
                </method>
                <method name="hashCode" type="int" line="730">
                    <comment line="731">
                        If two objects are equal, their hash codes must match.                        
                    </comment>
                </method>
                <method name="getType" type="String" line="739"/>
                <method name="getUnescapedValue" type="Object" line="746"/>
                <method name="getValueComparable" type="String" line="759">
                    <comment line="761">
                        return cached result                        
                    </comment>
                    <comment line="764">
                        cache result                        
                    </comment>
                    <comment line="770">
                        ignore case                        
                    </comment>
                    <scope line="760"/>
                    <scope line="765"/>
                    <scope line="767">
                        <scope line="769"/>
                    </scope>
                </method>
                <method name="escapeValue" type="String" line="780">
                    <params>
                        <param name="val" type="Object"/>
                    </params>
                </method>
                <method name="escapeStringValue" type="String" line="793">
                    <params>
                        <param name="val" type="String"/>
                    </params>
                    <comment line="799">
                        Find leading and trailing whitespace.                        
                    </comment>
                    <comment line="800">
                        index of first char that is not leading whitespace                        
                    </comment>
                    <comment line="806">
                        index of last char that is not trailing whitespace                        
                    </comment>
                    <declaration name="escapees" type="String" line="795"/>
                    <declaration name="chars" type="char[]" line="796"/>
                    <declaration name="buf" type="StringBuffer" line="797"/>
                    <declaration name="lead" type="int" line="800"/>
                    <scope line="801">
                        <scope line="802"/>
                    </scope>
                    <declaration name="trail" type="int" line="806"/>
                    <scope line="807">
                        <scope line="808"/>
                    </scope>
                    <scope line="813">
                        <declaration name="c" type="char" line="814"/>
                        <scope line="815"/>
                    </scope>
                </method>
                <method name="escapeBinaryValue" type="String" line="827">
                    <params>
                        <param name="val" type="byte[]"/>
                    </params>
                    <declaration name="buf" type="StringBuffer" line="829"/>
                    <scope line="832">
                        <declaration name="b" type="byte" line="833"/>
                    </scope>
                </method>
                <method name="unescapeValue" type="Object" line="848">
                    <params>
                        <param name="val" type="String"/>
                    </params>
                    <comment line="854">
                        Trim off leading and trailing whitespace.                        
                    </comment>
                    <comment line="862">
                        Add back the trailing whitespace with a preceeding &apos;\&apos;                        
                    </comment>
                    <comment line="863">
                        (escaped or unescaped) that was taken off in the above                        
                    </comment>
                    <comment line="864">
                        loop. Whether or not to retain this whitespace is                        
                    </comment>
                    <comment line="865">
                        decided below.                        
                    </comment>
                    <comment line="876">
                        Value is binary (eg: &quot;#CEB1DF80&quot;).                        
                    </comment>
                    <comment line="880">
                        Trim off quotes.                        
                    </comment>
                    <comment line="887">
                        index of the last escaped character                        
                    </comment>
                    <comment line="892">
                        skip backslash                        
                    </comment>
                    <comment line="893">
                        snarf escaped char                        
                    </comment>
                    <comment line="897">
                        Convert hex-encoded UTF-8 to 16-bit chars.                        
                    </comment>
                    <comment line="903">
                        shouldn&apos;t happen                        
                    </comment>
                    <comment line="913">
                        snarf unescaped char                        
                    </comment>
                    <comment line="917">
                        Get rid of the unescaped trailing whitespace with the                        
                    </comment>
                    <comment line="918">
                        preceeding &apos;\&apos; character that was previously added back.                        
                    </comment>
                    <declaration name="chars" type="char[]" line="850"/>
                    <declaration name="beg" type="int" line="851"/>
                    <declaration name="end" type="int" line="852"/>
                    <scope line="855"/>
                    <scope line="858"/>
                    <scope line="868"/>
                    <scope line="871"/>
                    <scope line="875"/>
                    <scope line="881"/>
                    <declaration name="buf" type="StringBuffer" line="886"/>
                    <declaration name="esc" type="int" line="887"/>
                    <scope line="889">
                        <scope line="890">
                            <scope line="891"/>
                            <scope line="895">
                                <declaration name="utf8" type="byte[]" line="898"/>
                                <scope line="899">
                                    <scope line="900"/>
                                    <scope line="902"/>
                                </scope>
                                <scope line="906"/>
                            </scope>
                        </scope>
                        <scope line="912"/>
                    </scope>
                    <declaration name="len" type="int" line="919"/>
                    <scope line="920"/>
                </method>
                <method name="decodeHexPairs" type="byte[]" line="933">
                    <params>
                        <param name="chars" type="char[]"/>
                        <param name="beg" type="int"/>
                        <param name="end" type="int"/>
                    </params>
                    <declaration name="bytes" type="byte[]" line="934"/>
                    <scope line="935">
                        <declaration name="hi" type="int" line="936"/>
                        <declaration name="lo" type="int" line="937"/>
                        <scope line="938"/>
                    </scope>
                    <scope line="944"/>
                </method>
                <method name="getUtf8Octets" type="byte[]" line="959">
                    <params>
                        <param name="chars" type="char[]"/>
                        <param name="beg" type="int"/>
                        <param name="end" type="int"/>
                    </params>
                    <comment line="960">
                        allow enough room                        
                    </comment>
                    <comment line="961">
                        index of first unused byte in utf8                        
                    </comment>
                    <declaration name="utf8" type="byte[]" line="960"/>
                    <declaration name="len" type="int" line="961"/>
                    <scope line="964">
                        <declaration name="hi" type="int" line="965"/>
                        <declaration name="lo" type="int" line="966"/>
                        <scope line="967"/>
                    </scope>
                    <scope line="973"/>
                    <scope line="975">
                        <declaration name="res" type="byte[]" line="976"/>
                    </scope>
                </method>
            </class>
        </class>
    </source>