<?xml version="1.0" encoding="UTF-8"?>
    <source package="com.sun.tools.jdi">
        <import package="com.sun.jdi"/>
        <import package="java.util"/>
        <import package="java.util.ArrayList"/>
        <class name="ObjectReferenceImpl" line="33">
            <extends class="ValueImpl"/>
            <comment line="42">
                This is cached only while the VM is suspended                
            </comment>
            <comment line="63">
                Override in subclasses                
            </comment>
            <comment line="86">
                Return the ClassTypeImpl upon which to invoke a method.
                 By default it is our very own referenceType() but subclasses
                 can override.                
            </comment>
            <comment line="103">
                VMListener implementation                
            </comment>
            <comment line="417">
                                
            </comment>
            <comment line="429">
                                
            </comment>
            <implements interface="ObjectReference"/>
            <implements interface="VMListener"/>
            <declaration name="ref" type="long" line="36"/>
            <declaration name="type" type="ReferenceType" line="37"/>
            <declaration name="gcDisableCount" type="int" line="38"/>
            <declaration name="addedListener" type="boolean" line="39"/>
            <class name="Cache" line="42">
                <declaration name="monitorInfo" type="JDWP.ObjectReference.MonitorInfo" line="43"/>
            </class>
            <declaration name="noInitCache" type="Cache" line="46"/>
            <declaration name="markerCache" type="Cache" line="47"/>
            <declaration name="cache" type="Cache" line="48"/>
            <method name="disableCache" type="void" line="50">
                <scope line="51"/>
            </method>
            <method name="enableCache" type="void" line="56">
                <scope line="57"/>
            </method>
            <method name="newCache" type="Cache" line="63"/>
            <method name="getCache" type="Cache" line="67">
                <comment line="72">
                    Set cache now, otherwise newly created objects are
                     not cached until resuspend                    
                </comment>
                <scope line="68">
                    <scope line="69">
                        <scope line="70"/>
                        <scope line="74"/>
                    </scope>
                    <scope line="78"/>
                </scope>
            </method>
            <method name="invokableReferenceType" type="ClassTypeImpl" line="88">
                <params>
                    <param name="method" type="Method"/>
                </params>
            </method>
            <method name="ObjectReferenceImpl" type="constructor" line="92">
                <params>
                    <param name="aVm" type="VirtualMachine"/>
                    <param name="aRef" type="long"/>
                </params>
            </method>
            <method name="description" type="String" line="98"/>
            <method name="vmSuspended" type="boolean" line="105">
                <params>
                    <param name="action" type="VMAction"/>
                </params>
            </method>
            <method name="vmNotSuspended" type="boolean" line="110">
                <params>
                    <param name="action" type="VMAction"/>
                </params>
                <comment line="112">
                    make sure that cache and listener management are synchronized                    
                </comment>
                <comment line="119">
                    If a listener was added (i.e. this is not a
                     ObjectReference that adds a listener on startup),
                     remove it here.                    
                </comment>
                <comment line="125">
                    false says remove                    
                </comment>
                <scope line="112">
                    <scope line="113"/>
                    <scope line="117"/>
                    <scope line="125"/>
                </scope>
            </method>
            <method name="equals" type="boolean" line="131">
                <params>
                    <param name="obj" type="Object"/>
                </params>
                <scope line="132">
                    <declaration name="other" type="ObjectReferenceImpl" line="133"/>
                </scope>
                <scope line="136"/>
            </method>
            <method name="hashCode" type="int" line="141"/>
            <method name="type" type="Type" line="145"/>
            <method name="referenceType" type="ReferenceType" line="149">
                <scope line="150">
                    <scope line="151">
                        <declaration name="rtinfo" type="JDWP.ObjectReference.ReferenceType" line="152"/>
                    </scope>
                    <scope line="156"/>
                </scope>
            </method>
            <method name="getValue" type="Value" line="163">
                <params>
                    <param name="sig" type="Field"/>
                </params>
                <declaration name="list" type="List&lt;Field&gt;" line="164"/>
                <declaration name="map" type="Map" line="166"/>
            </method>
            <method name="getValues" type="Map<Field,Value>" line="170">
                <params>
                    <param name="theFields" type="List<? extends Field>"/>
                </params>
                <comment line="181">
                    Make sure the field is valid                    
                </comment>
                <comment line="184">
                    FIX ME! We need to do some sanity checking
                     here; make sure the field belongs to this
                     object.                    
                </comment>
                <comment line="206">
                                        
                </comment>
                <declaration name="staticFields" type="List&lt;Field&gt;" line="173"/>
                <declaration name="size" type="int" line="174"/>
                <declaration name="instanceFields" type="List&lt;Field&gt;" line="175"/>
                <scope line="177">
                    <declaration name="field" type="Field" line="178"/>
                    <scope line="188"/>
                </scope>
                <declaration name="map" type="Map&lt;Field,Value&gt;" line="193"/>
                <scope line="194"/>
                <scope line="196"/>
                <declaration name="queryFields" type="JDWP.ObjectReference.GetValues.Field[]" line="202"/>
                <scope line="204">
                    <declaration name="field" type="FieldImpl" line="205"/>
                </scope>
                <declaration name="values" type="ValueImpl[]" line="209"/>
                <scope line="210"/>
                <scope line="213"/>
                <scope line="217"/>
                <scope line="221">
                    <declaration name="field" type="FieldImpl" line="222"/>
                </scope>
            </method>
            <method name="setValue" type="void" line="230">
                <params>
                    <param name="field" type="Field"/>
                    <param name="value" type="Value"/>
                </params>
                <comment line="236">
                    Make sure the field is valid                    
                </comment>
                <comment line="255">
                    Validate and convert if necessary                    
                </comment>
                <comment line="264">
                    Since we got this exception,
                     the field type must be a reference type. The value
                     we&apos;re trying to set is null, but if the field&apos;s
                     class has not yet been loaded through the enclosing
                     class loader, then setting to null is essentially a
                     no-op, and we should allow it without an exception.                    
                </comment>
                <scope line="238">
                    <declaration name="type" type="ReferenceType" line="239"/>
                    <scope line="240"/>
                    <scope line="243"/>
                </scope>
                <scope line="249">
                    <declaration name="fvals" type="JDWP.ObjectReference.SetValues.FieldValue[]" line="250"/>
                    <scope line="257"/>
                    <scope line="259"/>
                </scope>
                <scope line="262">
                    <scope line="271"/>
                </scope>
            </method>
            <method name="validateMethodInvocation" type="void" line="279">
                <params>
                    <param name="method" type="Method"/>
                    <param name="options" type="int"/>
                </params>
                <comment line="282">
                    Method must be in this object&apos;s class, a superclass, or
                     implemented interface                    
                </comment>
                <comment line="293">
                    Method must be a non-constructor                    
                </comment>
                <comment line="300">
                    For nonvirtual invokes, method must have a body                    
                </comment>
                <comment line="311">
                    Get the class containing the method that will be invoked.
                     This class is needed only for proper validation of the
                     method argument types.                    
                </comment>
                <comment line="318">
                    No overrides in non-virtual invokes                    
                </comment>
                <comment line="321">
                    For virtual invokes, find any override of the method.
                     Since we are looking for a method with a real body, we
                     don&apos;t need to bother with interfacesabstract methods.                    
                </comment>
                <comment line="328">
                    isAssignableFrom check above guarantees non-null                    
                </comment>
                <comment line="331">
                    The above code is left over from previous versions.
                     We haven&apos;t had time to divine the intent.  jjh, 7312003                    
                </comment>
                <declaration name="declType" type="ReferenceTypeImpl" line="285"/>
                <scope line="286"/>
                <declaration name="clazz" type="ClassTypeImpl" line="290"/>
                <scope line="295"/>
                <scope line="302">
                    <scope line="303"/>
                    <scope line="305"/>
                </scope>
                <declaration name="invokedClass" type="ClassTypeImpl" line="315"/>
                <scope line="316"/>
                <scope line="319">
                    <declaration name="invoker" type="Method" line="325"/>
                </scope>
            </method>
            <method name="sendInvokeCommand" type="PacketStream" line="339">
                <params>
                    <param name="thread" type="ThreadReferenceImpl"/>
                    <param name="refType" type="ClassTypeImpl"/>
                    <param name="method" type="MethodImpl"/>
                    <param name="args" type="ValueImpl[]"/>
                    <param name="options" type="int"/>
                </params>
                <anonymous_class line="341">
                    <method name="send" type="PacketStream" line="342"/>
                </anonymous_class>
                <declaration name="sender" type="CommandSender" line="340"/>
                <declaration name="stream" type="PacketStream" line="350"/>
                <scope line="351"/>
                <scope line="353"/>
            </method>
            <method name="invokeMethod" type="Value" line="364">
                <params>
                    <param name="threadIntf" type="ThreadReference"/>
                    <param name="methodIntf" type="Method"/>
                    <param name="origArguments" type="List<? extends Value>"/>
                    <param name="options" type="int"/>
                </params>
                <comment line="402">
                    There is an implict VM-wide suspend at the conclusion
                     of a normal (non-single-threaded) method invoke                    
                </comment>
                <declaration name="method" type="MethodImpl" line="369"/>
                <declaration name="thread" type="ThreadReferenceImpl" line="370"/>
                <scope line="372">
                    <scope line="373">
                        <declaration name="type" type="ClassType" line="374"/>
                    </scope>
                    <scope line="376"/>
                </scope>
                <declaration name="arguments" type="List&lt;Value&gt;" line="383"/>
                <declaration name="args" type="ValueImpl[]" line="386"/>
                <declaration name="ret" type="JDWP.ObjectReference.InvokeMethod" line="387"/>
                <scope line="388">
                    <declaration name="stream" type="PacketStream" line="389"/>
                </scope>
                <scope line="393">
                    <scope line="394"/>
                    <scope line="396"/>
                </scope>
                <scope line="405"/>
                <scope line="409"/>
                <scope line="411"/>
            </method>
            <method name="disableCollection" type="void" line="417">
                <scope line="418">
                    <scope line="419"/>
                    <scope line="421"/>
                </scope>
            </method>
            <method name="enableCollection" type="void" line="429">
                <comment line="437">
                    If already collected, no harm done, no exception                    
                </comment>
                <scope line="432">
                    <scope line="433"/>
                    <scope line="435">
                        <scope line="437"/>
                    </scope>
                </scope>
            </method>
            <method name="isCollected" type="boolean" line="445">
                <scope line="446"/>
                <scope line="449"/>
            </method>
            <method name="uniqueID" type="long" line="454"/>
            <method name="jdwpMonitorInfo" type="JDWP.ObjectReference.MonitorInfo" line="459">
                <comment line="465">
                    getCache() and addlistener() must be synchronized
                     so that no events are lost.                    
                </comment>
                <comment line="473">
                    Check if there will be something to cache
                     and there is not already a listener                    
                </comment>
                <comment line="476">
                    For other, less numerous objects, this is done
                     in the constructor. Since there can be many
                     ObjectReferences, the VM listener is installed
                     and removed as needed.
                     Listener must be installed before process()                    
                </comment>
                <declaration name="info" type="JDWP.ObjectReference.MonitorInfo" line="460"/>
                <scope line="461">
                    <declaration name="local" type="Cache" line="462"/>
                    <scope line="466">
                        <scope line="469">
                            <scope line="474"/>
                        </scope>
                    </scope>
                    <scope line="486">
                        <scope line="488">
                            <scope line="490"/>
                        </scope>
                    </scope>
                </scope>
                <scope line="496">
                    <scope line="497"/>
                    <scope line="499"/>
                </scope>
            </method>
            <method name="waitingThreads" type="List<ThreadReference>" line="506"/>
            <method name="owningThread" type="ThreadReference" line="510"/>
            <method name="entryCount" type="int" line="514"/>
            <method name="referringObjects" type="List<ObjectReference>" line="519">
                <params>
                    <param name="maxReferrers" type="long"/>
                </params>
                <comment line="533">
                    JDWP can&apos;t currently handle more than this (in mustang)                    
                </comment>
                <scope line="520"/>
                <scope line="525"/>
                <declaration name="intMax" type="int" line="530"/>
                <scope line="534"/>
                <scope line="537"/>
            </method>
            <method name="ref" type="long" line="542"/>
            <method name="isClassObject" type="boolean" line="546">
                <comment line="548">
                    Don&apos;t need to worry about subclasses since java.lang.Class is final.                    
                </comment>
            </method>
            <method name="prepareForAssignmentTo" type="ValueImpl" line="555">
                <params>
                    <param name="destination" type="ValueContainer"/>
                </params>
                <comment line="559">
                    conversion never necessary                    
                </comment>
            </method>
            <method name="validateAssignment" type="void" line="562">
                <params>
                    <param name="destination" type="ValueContainer"/>
                </params>
                <comment line="565">
                    Do these simpler checks before attempting a query of the destination&apos;s
                     type which might cause a confusing ClassNotLoadedException if
                     the destination is primitive or an array.                    
                </comment>
                <comment line="570">
                    TO DO: Centralize JNI signature knowledge                    
                </comment>
                <comment line="584">
                    Validate assignment                    
                </comment>
                <scope line="572"/>
                <scope line="576"/>
                <scope line="579"/>
                <declaration name="destType" type="ReferenceType" line="584"/>
                <declaration name="myType" type="ReferenceTypeImpl" line="585"/>
                <scope line="586">
                    <declaration name="parser" type="JNITypeParser" line="587"/>
                    <declaration name="destTypeName" type="String" line="588"/>
                </scope>
            </method>
            <method name="toString" type="String" line="596"/>
            <method name="typeValueKey" type="byte" line="600"/>
        </class>
    </source>