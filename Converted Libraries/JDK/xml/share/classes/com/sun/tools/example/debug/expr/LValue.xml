<?xml version="1.0" encoding="UTF-8"?>
    <source package="com.sun.tools.example.debug.expr">
        <import package="com.sun.jdi"/>
        <import package="java.util"/>
        <class name="LValue" line="31">
            <comment line="34">
                The JDI Value object for this LValue.  Once we have this Value,                
            </comment>
            <comment line="35">
                we have to remember it since after we return the LValue object                
            </comment>
            <comment line="36">
                to the ExpressionParser, it might decide that it needs                
            </comment>
            <comment line="37">
                the &apos;toString&apos; value for the LValue in which case it will                
            </comment>
            <comment line="38">
                call getMassagedValue to get this toString value.  At that                
            </comment>
            <comment line="39">
                point, we don&apos;t want to call JDI a 2nd time to get the Value                
            </comment>
            <comment line="40">
                for the LValue.  This is especially wrong when the LValue                
            </comment>
            <comment line="41">
                represents a member function.  We would end up calling it                
            </comment>
            <comment line="42">
                a 2nd time.                
            </comment>
            <comment line="43">
                                
            </comment>
            <comment line="44">
                Unfortunately, there are several levels of calls to                
            </comment>
            <comment line="45">
                get/set values in this file.  To minimize confusion,                
            </comment>
            <comment line="46">
                jdiValue is set/tested at the lowest level - right                
            </comment>
            <comment line="47">
                next to the actual calls to JDI methods to get/set the                
            </comment>
            <comment line="48">
                value in the debuggee.                
            </comment>
            <comment line="100">
                Return the Value for this LValue that would be used to concatenate                
            </comment>
            <comment line="101">
                to a String.  IE, if it is an Object, call toString in the debuggee.                
            </comment>
            <comment line="227">
                Return SAME, DIFFERENT or ASSIGNABLE.
                 SAME means each arg type is the same as type of the corr. arg.
                 ASSIGNABLE means that not all the pairs are the same, but
                 for those that aren&apos;t, at least the argType is assignable
                 from the type of the argument value.
                 DIFFERENT means that in at least one pair, the
                 argType is not assignable from the type of the argument value.
                 IE, one is an Apple and the other is an Orange.                
            </comment>
            <comment line="272">
                These is...AssignableTo methods are based on similar code in the JDI                
            </comment>
            <comment line="273">
                implementations of ClassType, ArrayType, and InterfaceType                
            </comment>
            <declaration name="jdiValue" type="Value" line="48"/>
            <method name="getValue" type="Value" line="50"/>
            <method name="setValue0" type="void" line="56"/>
            <method name="invokeWith" type="void" line="60"/>
            <method name="setValue" type="void" line="62">
                <params>
                    <param name="value" type="Value"/>
                </params>
                <scope line="63"/>
                <scope line="65"/>
                <scope line="69"/>
            </method>
            <method name="setValue" type="void" line="76">
                <params>
                    <param name="lval" type="LValue"/>
                </params>
            </method>
            <method name="memberLValue" type="LValue" line="81">
                <params>
                    <param name="frameGetter" type="ExpressionParser.GetFrame"/>
                    <param name="fieldName" type="String"/>
                </params>
                <scope line="82"/>
                <scope line="84"/>
            </method>
            <method name="memberLValue" type="LValue" line="89">
                <params>
                    <param name="fieldName" type="String"/>
                    <param name="thread" type="ThreadReference"/>
                </params>
                <declaration name="val" type="Value" line="91"/>
                <scope line="93"/>
            </method>
            <method name="getMassagedValue" type="Value" line="101">
                <params>
                    <param name="frameGetter" type="ExpressionParser.GetFrame"/>
                </params>
                <comment line="104">
                    If vv is an ObjectReference, then we have to                    
                </comment>
                <comment line="105">
                    do the implicit call to toString().                    
                </comment>
                <declaration name="vv" type="Value" line="102"/>
                <scope line="108">
                    <declaration name="frame" type="StackFrame" line="109"/>
                    <scope line="110"/>
                    <scope line="112"/>
                    <declaration name="thread" type="ThreadReference" line="116"/>
                    <declaration name="toStringMember" type="LValue" line="117"/>
                </scope>
            </method>
            <method name="interiorGetValue" type="Value" line="124">
                <declaration name="value" type="Value" line="125"/>
                <scope line="126"/>
                <scope line="128"/>
                <scope line="131"/>
                <scope line="134"/>
                <scope line="137"/>
            </method>
            <method name="arrayElementLValue" type="LValue" line="145">
                <params>
                    <param name="lval" type="LValue"/>
                </params>
                <declaration name="indexValue" type="Value" line="146"/>
                <declaration name="index" type="int" line="147"/>
                <scope line="151"/>
                <scope line="153"/>
            </method>
            <method name="toString" type="String" line="160">
                <scope line="161"/>
                <scope line="163"/>
            </method>
            <declaration name="STATIC" type="int" line="168"/>
            <declaration name="INSTANCE" type="int" line="169"/>
            <method name="fieldByName" type="Field" line="171">
                <params>
                    <param name="refType" type="ReferenceType"/>
                    <param name="name" type="String"/>
                    <param name="kind" type="int"/>
                </params>
                <comment line="172">
                    TO DO: Note that this currently fails to find superclass
                     or implemented interface fields. This is due to a temporary
                     limititation of RefType.fieldByName. Once that method is
                     fixed, superclass fields will be found.                    
                </comment>
                <comment line="186">
                    System.err.println(&quot;fieldByName: &quot; + refType.name() + &quot; &quot; +
                    name + &quot; &quot; +
                    kind + &quot; &quot; +
                    (field != null));                    
                </comment>
                <declaration name="field" type="Field" line="178"/>
                <scope line="179">
                    <declaration name="isStatic" type="boolean" line="180"/>
                    <scope line="182"/>
                </scope>
            </method>
            <method name="methodsByName" type="List<Method>" line="196">
                <params>
                    <param name="refType" type="ReferenceType"/>
                    <param name="name" type="String"/>
                    <param name="kind" type="int"/>
                </params>
                <declaration name="list" type="List&lt;Method&gt;" line="197"/>
                <declaration name="iter" type="Iterator&lt;Method&gt;" line="198"/>
                <scope line="199">
                    <declaration name="method" type="Method" line="200"/>
                    <declaration name="isStatic" type="boolean" line="201"/>
                    <scope line="203"/>
                </scope>
            </method>
            <declaration name="primitiveTypeNames" type="List&lt;String&gt;" line="210"/>
            <scope line="211"/>
            <declaration name="SAME" type="int" line="223"/>
            <declaration name="ASSIGNABLE" type="int" line="224"/>
            <declaration name="DIFFERENT" type="int" line="225"/>
            <method name="argumentsMatch" type="int" line="236">
                <params>
                    <param name="argTypes" type="List<Type>"/>
                    <param name="arguments" type="List<Value>"/>
                </params>
                <comment line="245">
                    If any pair aren&apos;t the same, change the                    
                </comment>
                <comment line="246">
                    result to ASSIGNABLE.  If any pair aren&apos;t                    
                </comment>
                <comment line="247">
                    assignable, return DIFFERENT                    
                </comment>
                <comment line="252">
                    Null values can be passed to any non-primitive argument                    
                </comment>
                <comment line="256">
                    Else, we will assume that a null value                    
                </comment>
                <comment line="257">
                    exactly matches an object type.                    
                </comment>
                <scope line="237"/>
                <declaration name="typeIter" type="Iterator&lt;Type&gt;" line="241"/>
                <declaration name="valIter" type="Iterator&lt;Value&gt;" line="242"/>
                <declaration name="result" type="int" line="243"/>
                <scope line="248">
                    <declaration name="argType" type="Type" line="249"/>
                    <declaration name="value" type="Value" line="250"/>
                    <scope line="251">
                        <scope line="253"/>
                    </scope>
                    <scope line="259">
                        <scope line="260"/>
                        <scope line="262"/>
                    </scope>
                </scope>
            </method>
            <method name="isComponentAssignable" type="boolean" line="274">
                <params>
                    <param name="fromType" type="Type"/>
                    <param name="toType" type="Type"/>
                </params>
                <comment line="276">
                    Assignment of primitive arrays requires identical                    
                </comment>
                <comment line="277">
                    component types.                    
                </comment>
                <comment line="283">
                    Assignment of object arrays requires availability                    
                </comment>
                <comment line="284">
                    of widening conversion of component types                    
                </comment>
                <scope line="275"/>
                <scope line="280"/>
            </method>
            <method name="isArrayAssignableTo" type="boolean" line="288">
                <params>
                    <param name="fromType" type="ArrayType"/>
                    <param name="toType" type="Type"/>
                </params>
                <comment line="294">
                    One or both component types has not yet been                    
                </comment>
                <comment line="295">
                    loaded =&gt; can&apos;t assign                    
                </comment>
                <comment line="300">
                    Only valid InterfaceType assignee is Cloneable                    
                </comment>
                <comment line="303">
                    Only valid ClassType assignee is Object                    
                </comment>
                <scope line="289">
                    <scope line="290">
                        <declaration name="toComponentType" type="Type" line="291"/>
                    </scope>
                    <scope line="293"/>
                </scope>
                <scope line="299"/>
            </method>
            <method name="isAssignableTo" type="boolean" line="307">
                <params>
                    <param name="fromType" type="Type"/>
                    <param name="toType" type="Type"/>
                </params>
                <comment line="312">
                    If one is boolean, so must be the other.                    
                </comment>
                <comment line="323">
                    Other primitive types are intermixable only with each other.                    
                </comment>
                <comment line="334">
                    neither one is primitive.                    
                </comment>
                <comment line="346">
                    fromType must be an InterfaceType                    
                </comment>
                <scope line="308"/>
                <scope line="313">
                    <scope line="314"/>
                </scope>
                <scope line="319"/>
                <scope line="324">
                    <scope line="325"/>
                </scope>
                <scope line="330"/>
                <scope line="335"/>
                <declaration name="interfaces" type="List&lt;InterfaceType&gt;" line="338"/>
                <scope line="339">
                    <declaration name="superclazz" type="ClassType" line="340"/>
                    <scope line="341"/>
                </scope>
                <scope line="345"/>
                <scope line="349">
                    <scope line="350"/>
                </scope>
            </method>
            <method name="resolveOverload" type="Method" line="359">
                <params>
                    <param name="overloads" type="List<Method>"/>
                    <param name="arguments" type="List<Value>"/>
                </params>
                <comment line="361">
                    If there is only one method to call, we&apos;ll just choose                    
                </comment>
                <comment line="362">
                    that without looking at the args.  If they aren&apos;t right                    
                </comment>
                <comment line="363">
                    the invoke will return a better error message than we                    
                </comment>
                <comment line="364">
                    could generate here.                    
                </comment>
                <comment line="369">
                    Resolving overloads is beyond the scope of this exercise.                    
                </comment>
                <comment line="370">
                    So, we will look for a method that matches exactly the                    
                </comment>
                <comment line="371">
                    types of the arguments.  If we can&apos;t find one, then                    
                </comment>
                <comment line="372">
                    if there is exactly one method whose param types are assignable                    
                </comment>
                <comment line="373">
                    from the arg types, we will use that.  Otherwise,                    
                </comment>
                <comment line="374">
                    it is an error.  We won&apos;t guess which of multiple possible                    
                </comment>
                <comment line="375">
                    methods to call. And, since casts aren&apos;t implemented,                    
                </comment>
                <comment line="376">
                    the user can&apos;t use them to pick a particular overload to call.                    
                </comment>
                <comment line="377">
                    IE, the user is out of luck in this case.                    
                </comment>
                <comment line="385">
                    This probably won&apos;t happen for the                    
                </comment>
                <comment line="386">
                    method that we are really supposed to                    
                </comment>
                <comment line="387">
                    call.                    
                </comment>
                <comment line="397">
                    Else, it is assignable.  Remember it.                    
                </comment>
                <comment line="402">
                    At this point, we didn&apos;t find an exact match,                    
                </comment>
                <comment line="403">
                    but we found one for which the args are assignable.                    
                </comment>
                <comment line="404">
                                        
                </comment>
                <scope line="365"/>
                <declaration name="retVal" type="Method" line="378"/>
                <declaration name="assignableCount" type="int" line="379"/>
                <scope line="380">
                    <declaration name="argTypes" type="List&lt;Type&gt;" line="381"/>
                    <scope line="382"/>
                    <scope line="384"/>
                    <declaration name="compare" type="int" line="390"/>
                    <scope line="391"/>
                    <scope line="394"/>
                </scope>
                <scope line="405">
                    <scope line="406"/>
                </scope>
            </method>
            <class name="LValueLocal" line="414">
                <extends class="LValue"/>
                <comment line="586">
                    Since one can code &quot;int myLen = myArray.length;&quot;,
                     one might expect that these JDI calls would get a Value
                     object for the length of an array in the debugee:
                        Field xxx = ArrayType.fieldByName(&quot;length&quot;)
                        Value lenVal= ArrayReference.getValue(xxx)
                    
                     However, this doesn&apos;t work because the array length isn&apos;t
                     really stored as a field, and can&apos;t be accessed as such
                     via JDI.  Instead, the arrayRef.length() method has to be
                     used.                    
                </comment>
                <declaration name="frame" type="StackFrame" line="415"/>
                <declaration name="var" type="LocalVariable" line="416"/>
                <method name="LValueLocal" type="constructor" line="418">
                    <params>
                        <param name="frame" type="StackFrame"/>
                        <param name="var" type="LocalVariable"/>
                    </params>
                </method>
                <method name="getValue" type="Value" line="424">
                    <scope line="425"/>
                </method>
                <method name="setValue0" type="void" line="433">
                    <params>
                        <param name="val" type="Value"/>
                    </params>
                </method>
                <method name="invokeWith" type="void" line="439">
                    <params>
                        <param name="arguments" type="List<Value>"/>
                    </params>
                </method>
            </class>
            <class name="LValueInstanceMember" line="444">
                <extends class="LValue"/>
                <comment line="586">
                    Since one can code &quot;int myLen = myArray.length;&quot;,
                     one might expect that these JDI calls would get a Value
                     object for the length of an array in the debugee:
                        Field xxx = ArrayType.fieldByName(&quot;length&quot;)
                        Value lenVal= ArrayReference.getValue(xxx)
                    
                     However, this doesn&apos;t work because the array length isn&apos;t
                     really stored as a field, and can&apos;t be accessed as such
                     via JDI.  Instead, the arrayRef.length() method has to be
                     used.                    
                </comment>
                <declaration name="obj" type="ObjectReference" line="445"/>
                <declaration name="thread" type="ThreadReference" line="446"/>
                <declaration name="matchingField" type="Field" line="447"/>
                <declaration name="overloads" type="List&lt;Method&gt;" line="448"/>
                <declaration name="matchingMethod" type="Method" line="449"/>
                <declaration name="methodArguments" type="List&lt;Value&gt;" line="450"/>
                <method name="LValueInstanceMember" type="constructor" line="454">
                    <params>
                        <param name="value" type="Value"/>
                        <param name="memberName" type="String"/>
                        <param name="thread" type="ThreadReference"/>
                    </params>
                    <comment line="462">
                        Can&apos;t tell yet whether this LValue will be accessed as a
                         field or method, so we keep track of all the possibilities                        
                    </comment>
                    <scope line="455"/>
                    <declaration name="refType" type="ReferenceType" line="461"/>
                    <scope line="470"/>
                </method>
                <method name="getValue" type="Value" line="479">
                    <scope line="480"/>
                    <scope line="483">
                        <scope line="484"/>
                    </scope>
                    <scope line="488"/>
                </method>
                <method name="setValue0" type="void" line="496">
                    <params>
                        <param name="val" type="Value"/>
                    </params>
                    <scope line="497"/>
                </method>
                <method name="invokeWith" type="void" line="505">
                    <params>
                        <param name="arguments" type="List<Value>"/>
                    </params>
                    <scope line="506"/>
                </method>
            </class>
            <class name="LValueStaticMember" line="514">
                <extends class="LValue"/>
                <comment line="586">
                    Since one can code &quot;int myLen = myArray.length;&quot;,
                     one might expect that these JDI calls would get a Value
                     object for the length of an array in the debugee:
                        Field xxx = ArrayType.fieldByName(&quot;length&quot;)
                        Value lenVal= ArrayReference.getValue(xxx)
                    
                     However, this doesn&apos;t work because the array length isn&apos;t
                     really stored as a field, and can&apos;t be accessed as such
                     via JDI.  Instead, the arrayRef.length() method has to be
                     used.                    
                </comment>
                <declaration name="refType" type="ReferenceType" line="515"/>
                <declaration name="thread" type="ThreadReference" line="516"/>
                <declaration name="matchingField" type="Field" line="517"/>
                <declaration name="overloads" type="List&lt;Method&gt;" line="518"/>
                <declaration name="matchingMethod" type="Method" line="519"/>
                <declaration name="methodArguments" type="List&lt;Value&gt;" line="520"/>
                <method name="LValueStaticMember" type="constructor" line="524">
                    <params>
                        <param name="refType" type="ReferenceType"/>
                        <param name="memberName" type="String"/>
                        <param name="thread" type="ThreadReference"/>
                    </params>
                    <comment line="527">
                        Can&apos;t tell yet whether this LValue will be accessed as a
                         field or method, so we keep track of all the possibilities                        
                    </comment>
                    <scope line="535"/>
                </method>
                <method name="getValue" type="Value" line="544">
                    <scope line="545"/>
                    <scope line="548"/>
                    <scope line="550">
                        <declaration name="clazz" type="ClassType" line="551"/>
                    </scope>
                    <scope line="553"/>
                </method>
                <method name="setValue0" type="void" line="562">
                    <params>
                        <param name="val" type="Value"/>
                    </params>
                    <scope line="563"/>
                    <scope line="566"/>
                </method>
                <method name="invokeWith" type="void" line="575">
                    <params>
                        <param name="arguments" type="List<Value>"/>
                    </params>
                    <scope line="576"/>
                </method>
            </class>
            <class name="LValueArrayLength" line="584">
                <extends class="LValue"/>
                <comment line="586">
                    Since one can code &quot;int myLen = myArray.length;&quot;,
                     one might expect that these JDI calls would get a Value
                     object for the length of an array in the debugee:
                        Field xxx = ArrayType.fieldByName(&quot;length&quot;)
                        Value lenVal= ArrayReference.getValue(xxx)
                    
                     However, this doesn&apos;t work because the array length isn&apos;t
                     really stored as a field, and can&apos;t be accessed as such
                     via JDI.  Instead, the arrayRef.length() method has to be
                     used.                    
                </comment>
                <declaration name="arrayRef" type="ArrayReference" line="597"/>
                <method name="LValueArrayLength" type="constructor" line="598">
                    <params>
                        <param name="value" type="ArrayReference"/>
                    </params>
                </method>
                <method name="getValue" type="Value" line="603">
                    <scope line="604"/>
                </method>
                <method name="setValue0" type="void" line="611">
                    <params>
                        <param name="value" type="Value"/>
                    </params>
                </method>
                <method name="invokeWith" type="void" line="616">
                    <params>
                        <param name="arguments" type="List<Value>"/>
                    </params>
                </method>
            </class>
            <class name="LValueArrayElement" line="621">
                <extends class="LValue"/>
                <comment line="586">
                    Since one can code &quot;int myLen = myArray.length;&quot;,
                     one might expect that these JDI calls would get a Value
                     object for the length of an array in the debugee:
                        Field xxx = ArrayType.fieldByName(&quot;length&quot;)
                        Value lenVal= ArrayReference.getValue(xxx)
                    
                     However, this doesn&apos;t work because the array length isn&apos;t
                     really stored as a field, and can&apos;t be accessed as such
                     via JDI.  Instead, the arrayRef.length() method has to be
                     used.                    
                </comment>
                <declaration name="array" type="ArrayReference" line="622"/>
                <declaration name="index" type="int" line="623"/>
                <method name="LValueArrayElement" type="constructor" line="625">
                    <params>
                        <param name="value" type="Value"/>
                        <param name="index" type="int"/>
                    </params>
                    <scope line="626"/>
                </method>
                <method name="getValue" type="Value" line="635">
                    <scope line="636"/>
                </method>
                <method name="setValue0" type="void" line="644">
                    <params>
                        <param name="val" type="Value"/>
                    </params>
                </method>
                <method name="invokeWith" type="void" line="650">
                    <params>
                        <param name="arguments" type="List<Value>"/>
                    </params>
                </method>
            </class>
            <class name="LValueConstant" line="655">
                <extends class="LValue"/>
                <comment line="586">
                    Since one can code &quot;int myLen = myArray.length;&quot;,
                     one might expect that these JDI calls would get a Value
                     object for the length of an array in the debugee:
                        Field xxx = ArrayType.fieldByName(&quot;length&quot;)
                        Value lenVal= ArrayReference.getValue(xxx)
                    
                     However, this doesn&apos;t work because the array length isn&apos;t
                     really stored as a field, and can&apos;t be accessed as such
                     via JDI.  Instead, the arrayRef.length() method has to be
                     used.                    
                </comment>
                <declaration name="value" type="Value" line="656"/>
                <method name="LValueConstant" type="constructor" line="658">
                    <params>
                        <param name="value" type="Value"/>
                    </params>
                </method>
                <method name="getValue" type="Value" line="663">
                    <scope line="664"/>
                </method>
                <method name="setValue0" type="void" line="671">
                    <params>
                        <param name="val" type="Value"/>
                    </params>
                </method>
                <method name="invokeWith" type="void" line="676">
                    <params>
                        <param name="arguments" type="List<Value>"/>
                    </params>
                </method>
            </class>
            <method name="make" type="LValue" line="681">
                <params>
                    <param name="vm" type="VirtualMachine"/>
                    <param name="val" type="boolean"/>
                </params>
            </method>
            <method name="make" type="LValue" line="685">
                <params>
                    <param name="vm" type="VirtualMachine"/>
                    <param name="val" type="byte"/>
                </params>
            </method>
            <method name="make" type="LValue" line="689">
                <params>
                    <param name="vm" type="VirtualMachine"/>
                    <param name="val" type="char"/>
                </params>
            </method>
            <method name="make" type="LValue" line="693">
                <params>
                    <param name="vm" type="VirtualMachine"/>
                    <param name="val" type="short"/>
                </params>
            </method>
            <method name="make" type="LValue" line="697">
                <params>
                    <param name="vm" type="VirtualMachine"/>
                    <param name="val" type="int"/>
                </params>
            </method>
            <method name="make" type="LValue" line="701">
                <params>
                    <param name="vm" type="VirtualMachine"/>
                    <param name="val" type="long"/>
                </params>
            </method>
            <method name="make" type="LValue" line="705">
                <params>
                    <param name="vm" type="VirtualMachine"/>
                    <param name="val" type="float"/>
                </params>
            </method>
            <method name="make" type="LValue" line="709">
                <params>
                    <param name="vm" type="VirtualMachine"/>
                    <param name="val" type="double"/>
                </params>
            </method>
            <method name="make" type="LValue" line="713">
                <params>
                    <param name="vm" type="VirtualMachine"/>
                    <param name="val" type="String"/>
                </params>
            </method>
            <method name="makeBoolean" type="LValue" line="717">
                <params>
                    <param name="vm" type="VirtualMachine"/>
                    <param name="token" type="Token"/>
                </params>
            </method>
            <method name="makeCharacter" type="LValue" line="721">
                <params>
                    <param name="vm" type="VirtualMachine"/>
                    <param name="token" type="Token"/>
                </params>
            </method>
            <method name="makeFloat" type="LValue" line="725">
                <params>
                    <param name="vm" type="VirtualMachine"/>
                    <param name="token" type="Token"/>
                </params>
            </method>
            <method name="makeDouble" type="LValue" line="729">
                <params>
                    <param name="vm" type="VirtualMachine"/>
                    <param name="token" type="Token"/>
                </params>
            </method>
            <method name="makeInteger" type="LValue" line="733">
                <params>
                    <param name="vm" type="VirtualMachine"/>
                    <param name="token" type="Token"/>
                </params>
            </method>
            <method name="makeShort" type="LValue" line="737">
                <params>
                    <param name="vm" type="VirtualMachine"/>
                    <param name="token" type="Token"/>
                </params>
            </method>
            <method name="makeLong" type="LValue" line="741">
                <params>
                    <param name="vm" type="VirtualMachine"/>
                    <param name="token" type="Token"/>
                </params>
            </method>
            <method name="makeByte" type="LValue" line="745">
                <params>
                    <param name="vm" type="VirtualMachine"/>
                    <param name="token" type="Token"/>
                </params>
            </method>
            <method name="makeString" type="LValue" line="750">
                <params>
                    <param name="vm" type="VirtualMachine"/>
                    <param name="token" type="Token"/>
                </params>
                <declaration name="len" type="int" line="751"/>
            </method>
            <method name="makeNull" type="LValue" line="756">
                <params>
                    <param name="vm" type="VirtualMachine"/>
                    <param name="token" type="Token"/>
                </params>
            </method>
            <method name="makeThisObject" type="LValue" line="762">
                <params>
                    <param name="vm" type="VirtualMachine"/>
                    <param name="frameGetter" type="ExpressionParser.GetFrame"/>
                    <param name="token" type="Token"/>
                </params>
                <scope line="763"/>
                <scope line="765">
                    <scope line="766">
                        <declaration name="frame" type="StackFrame" line="767"/>
                        <declaration name="thisObject" type="ObjectReference" line="768"/>
                        <scope line="770"/>
                        <scope line="773"/>
                    </scope>
                    <scope line="776"/>
                </scope>
            </method>
            <method name="makeNewObject" type="LValue" line="784">
                <params>
                    <param name="vm" type="VirtualMachine"/>
                    <param name="frameGetter" type="ExpressionParser.GetFrame"/>
                    <param name="className" type="String"/>
                    <param name="arguments" type="List<Value>"/>
                </params>
                <comment line="803">
                    writable                    
                </comment>
                <comment line="823">
                    TO DO: Better error handling                    
                </comment>
                <declaration name="classes" type="List&lt;ReferenceType&gt;" line="785"/>
                <scope line="786"/>
                <scope line="790"/>
                <declaration name="refType" type="ReferenceType" line="794"/>
                <scope line="797"/>
                <declaration name="classType" type="ClassType" line="802"/>
                <declaration name="methods" type="List&lt;Method&gt;" line="803"/>
                <declaration name="iter" type="Iterator&lt;Method&gt;" line="804"/>
                <scope line="805">
                    <declaration name="method" type="Method" line="806"/>
                    <scope line="807"/>
                </scope>
                <declaration name="constructor" type="Method" line="811"/>
                <declaration name="newObject" type="ObjectReference" line="813"/>
                <scope line="814">
                    <declaration name="thread" type="ThreadReference" line="815"/>
                </scope>
                <scope line="817"/>
                <scope line="820"/>
                <scope line="822"/>
            </method>
            <method name="nFields" type="LValue" line="834">
                <params>
                    <param name="lval" type="LValue"/>
                    <param name="izer" type="StringTokenizer"/>
                    <param name="thread" type="ThreadReference"/>
                </params>
                <scope line="835"/>
                <scope line="837"/>
            </method>
            <method name="makeName" type="LValue" line="844">
                <params>
                    <param name="vm" type="VirtualMachine"/>
                    <param name="frameGetter" type="ExpressionParser.GetFrame"/>
                    <param name="name" type="String"/>
                </params>
                <comment line="847">
                    check local variables                    
                </comment>
                <comment line="863">
                    check if it is a field of &apos;this&apos;                    
                </comment>
                <comment line="876">
                    check for class name                    
                </comment>
                <declaration name="izer" type="StringTokenizer" line="845"/>
                <declaration name="first" type="String" line="846"/>
                <scope line="848">
                    <scope line="849">
                        <declaration name="frame" type="StackFrame" line="850"/>
                        <declaration name="thread" type="ThreadReference" line="851"/>
                        <declaration name="var" type="LocalVariable" line="852"/>
                        <scope line="853"/>
                        <scope line="855"/>
                        <scope line="858"/>
                        <scope line="860">
                            <declaration name="thisObject" type="ObjectReference" line="861"/>
                            <scope line="862">
                                <declaration name="thisLValue" type="LValue" line="864"/>
                                <declaration name="fv" type="LValue" line="865"/>
                                <scope line="866"/>
                                <scope line="868"/>
                                <scope line="871"/>
                            </scope>
                        </scope>
                        <scope line="877">
                            <declaration name="classes" type="List&lt;ReferenceType&gt;" line="878"/>
                            <scope line="879">
                                <scope line="880"/>
                                <scope line="883">
                                    <declaration name="refType" type="ReferenceType" line="884"/>
                                    <declaration name="lval" type="LValue" line="885"/>
                                </scope>
                            </scope>
                        </scope>
                    </scope>
                    <scope line="892"/>
                </scope>
            </method>
            <method name="stringValue" type="String" line="900">
                <params>
                    <param name="lval" type="LValue"/>
                    <param name="frameGetter" type="ExpressionParser.GetFrame"/>
                </params>
                <comment line="908">
                    is this correct in all cases?                    
                </comment>
                <declaration name="val" type="Value" line="901"/>
                <scope line="902"/>
                <scope line="905"/>
            </method>
            <method name="booleanOperation" type="LValue" line="913">
                <params>
                    <param name="vm" type="VirtualMachine"/>
                    <param name="token" type="Token"/>
                    <param name="rightL" type="LValue"/>
                    <param name="leftL" type="LValue"/>
                </params>
                <comment line="928">
                    can compare any numeric doubles                    
                </comment>
                <declaration name="op" type="String" line="914"/>
                <declaration name="right" type="Value" line="915"/>
                <declaration name="left" type="Value" line="916"/>
                <scope line="918">
                    <scope line="919"/>
                    <scope line="921"/>
                    <scope line="923"/>
                </scope>
                <declaration name="rr" type="double" line="929"/>
                <declaration name="ll" type="double" line="930"/>
                <declaration name="res" type="boolean" line="931"/>
                <scope line="932"/>
                <scope line="934"/>
                <scope line="936"/>
                <scope line="938"/>
                <scope line="940"/>
                <scope line="942"/>
                <scope line="944"/>
            </method>
            <method name="operation" type="LValue" line="953">
                <params>
                    <param name="vm" type="VirtualMachine"/>
                    <param name="token" type="Token"/>
                    <param name="rightL" type="LValue"/>
                    <param name="leftL" type="LValue"/>
                    <param name="frameGetter" type="ExpressionParser.GetFrame"/>
                </params>
                <comment line="960">
                    If one is an ObjectRef, we will need to invoke                    
                </comment>
                <comment line="961">
                    toString on it, so we need the thread.                    
                </comment>
                <comment line="982">
                    from here on, we know it is a integer kind of type                    
                </comment>
                <declaration name="op" type="String" line="954"/>
                <declaration name="right" type="Value" line="955"/>
                <declaration name="left" type="Value" line="956"/>
                <scope line="958">
                    <scope line="959"/>
                </scope>
                <scope line="967">
                    <scope line="968"/>
                    <scope line="970"/>
                    <scope line="972"/>
                </scope>
                <scope line="978"/>
                <declaration name="primRight" type="PrimitiveValue" line="983"/>
                <declaration name="primLeft" type="PrimitiveValue" line="984"/>
                <scope line="986">
                    <declaration name="rr" type="double" line="987"/>
                    <declaration name="ll" type="double" line="988"/>
                    <declaration name="res" type="double" line="989"/>
                    <scope line="990"/>
                    <scope line="992"/>
                    <scope line="994"/>
                    <scope line="996"/>
                    <scope line="998"/>
                </scope>
                <scope line="1004">
                    <declaration name="rr" type="float" line="1005"/>
                    <declaration name="ll" type="float" line="1006"/>
                    <declaration name="res" type="float" line="1007"/>
                    <scope line="1008"/>
                    <scope line="1010"/>
                    <scope line="1012"/>
                    <scope line="1014"/>
                    <scope line="1016"/>
                </scope>
                <scope line="1022">
                    <declaration name="rr" type="long" line="1023"/>
                    <declaration name="ll" type="long" line="1024"/>
                    <declaration name="res" type="long" line="1025"/>
                    <scope line="1026"/>
                    <scope line="1028"/>
                    <scope line="1030"/>
                    <scope line="1032"/>
                    <scope line="1034"/>
                </scope>
                <scope line="1038">
                    <declaration name="rr" type="int" line="1039"/>
                    <declaration name="ll" type="int" line="1040"/>
                    <declaration name="res" type="int" line="1041"/>
                    <scope line="1042"/>
                    <scope line="1044"/>
                    <scope line="1046"/>
                    <scope line="1048"/>
                    <scope line="1050"/>
                </scope>
            </method>
        </class>
    </source>