<?xml version="1.0" encoding="UTF-8"?>
    <source package="com.sun.tools.jdi">
        <import package="com.sun.jdi"/>
        <import package="com.sun.jdi.request.BreakpointRequest"/>
        <import package="java.util"/>
        <import package="java.lang.ref.WeakReference"/>
        <class name="ThreadReferenceImpl" line="33">
            <extends class="ObjectReferenceImpl"/>
            <comment line="41">
                Some objects can only be created while a thread is suspended and are valid
                 only while the thread remains suspended.  Examples are StackFrameImpl
                 and MonitorInfoImpl.  When the thread resumes, these objects have to be
                 marked as invalid so that their methods can throw
                 InvalidStackFrameException if they are called.  To do this, such objects
                 register themselves as listeners of the associated thread.  When the
                 thread is resumed, its listeners are notified and mark themselves
                 invalid.
                 Also, note that ThreadReferenceImpl itself caches some info that
                 is valid only as long as the thread is suspended.  When the thread
                 is resumed, that cache must be purged.
                 Lastly, note that ThreadReferenceImpl and its super, ObjectReferenceImpl
                 cache some info that is only valid as long as the entire VM is suspended.
                 If _any_ thread is resumed, this cache must be purged.  To handle this,
                 both ThreadReferenceImpl and ObjectReferenceImpl register themselves as
                 VMListeners so that they get notified when all threads are suspended and
                 when any thread is resumed.                
            </comment>
            <comment line="61">
                This is cached for the life of the thread                
            </comment>
            <comment line="64">
                This is cached only while this one thread is suspended.  Each time                
            </comment>
            <comment line="65">
                the thread is resumed, we abandon the current cache object and                
            </comment>
            <comment line="66">
                create a new intialized one.                
            </comment>
            <comment line="79">
                The localCache instance var is set by resetLocalCache to an initialized
                 object as shown above.  This occurs when the ThreadReference
                 object is created, and when the mirrored thread is resumed.
                 The fields are then filled in by the relevant methods as they
                 are called.  A problem can occur if resetLocalCache is called
                 (ie, a resume() is executed) at certain points in the execution
                 of some of these methods - see 6751643.  To avoid this, each
                 method that wants to use this cache must make a local copy of
                 this variable and use that.  This means that each invocation of
                 these methods will use a copy of the cache object that was in
                 effect at the point that the copy was made; if a racy resume
                 occurs, it won&apos;t affect the method&apos;s local copy.  This means that
                 the values returned by these calls may not match the state of
                 the debuggee at the time the caller gets the values.  EG,
                 frameCount() is called and comes up with 5 frames.  But before
                 it returns this, a resume of the debuggee thread is executed in a
                 different debugger thread.  The thread is resumed and running at
                 the time that the value 5 is returned.  Or even worse, the thread
                 could be suspended again and have a different number of frames, eg, 24,
                 but this call will still return 5.                
            </comment>
            <comment line="107">
                This is cached only while all threads in the VM are suspended                
            </comment>
            <comment line="108">
                Yes, someone could change the name of a thread while it is suspended.                
            </comment>
            <comment line="116">
                Listeners - synchronized on vm.state()                
            </comment>
            <comment line="130">
                VMListener implementation                
            </comment>
            <comment line="181">
                Sends a command to the back end which is defined to do an
                 implicit vm-wide resume.                
            </comment>
            <implements interface="ThreadReference"/>
            <implements interface="VMListener"/>
            <declaration name="SUSPEND_STATUS_SUSPENDED" type="int" line="35"/>
            <declaration name="SUSPEND_STATUS_BREAK" type="int" line="36"/>
            <declaration name="suspendedZombieCount" type="int" line="38"/>
            <declaration name="threadGroup" type="ThreadGroupReference" line="61"/>
            <class name="LocalCache" line="66">
                <declaration name="status" type="JDWP.ThreadReference.Status" line="67"/>
                <declaration name="frames" type="List&lt;StackFrame&gt;" line="68"/>
                <declaration name="framesStart" type="int" line="69"/>
                <declaration name="framesLength" type="int" line="70"/>
                <declaration name="frameCount" type="int" line="71"/>
                <declaration name="ownedMonitors" type="List&lt;ObjectReference&gt;" line="72"/>
                <declaration name="ownedMonitorsInfo" type="List&lt;MonitorInfo&gt;" line="73"/>
                <declaration name="contendedMonitor" type="ObjectReference" line="74"/>
                <declaration name="triedCurrentContended" type="boolean" line="75"/>
            </class>
            <declaration name="localCache" type="LocalCache" line="100"/>
            <method name="resetLocalCache" type="void" line="102"/>
            <class name="Cache" line="108">
                <extends class="ObjectReferenceImpl.Cache"/>
                <declaration name="name" type="String" line="109"/>
            </class>
            <method name="newCache" type="ObjectReferenceImpl.Cache" line="111"/>
            <declaration name="listeners" type="List&lt;WeakReference&lt;ThreadListener&gt;&gt;" line="116"/>
            <method name="ThreadReferenceImpl" type="constructor" line="119">
                <params>
                    <param name="aVm" type="VirtualMachine"/>
                    <param name="aRef" type="long"/>
                </params>
            </method>
            <method name="description" type="String" line="125"/>
            <method name="vmNotSuspended" type="boolean" line="132">
                <params>
                    <param name="action" type="VMAction"/>
                </params>
                <comment line="134">
                    all threads are being resumed                    
                </comment>
                <comment line="142">
                    Othewise, only one thread is being resumed:
                       if it is us,
                          we have already done our processThreadAction to notify our
                          listeners when we processed the resume.
                       if it is not us,
                          we don&apos;t want to notify our listeners
                           because we are not being resumed.                    
                </comment>
                <scope line="133">
                    <scope line="135"/>
                </scope>
            </method>
            <javadoc line="154">
                Note that we only cache the name string while the entire VM is suspended
                  because the name can change via Thread.setName arbitrarily while this
                  thread is running.                
            </javadoc>
            <method name="name" type="String" line="159">
                <declaration name="name" type="String" line="160"/>
                <scope line="161">
                    <declaration name="local" type="Cache" line="162"/>
                    <scope line="164"/>
                    <scope line="167">
                        <scope line="170"/>
                    </scope>
                </scope>
                <scope line="174"/>
            </method>
            <method name="sendResumingCommand" type="PacketStream" line="184">
                <params>
                    <param name="sender" type="CommandSender"/>
                </params>
                <scope line="185"/>
            </method>
            <method name="suspend" type="void" line="192">
                <comment line="198">
                    Don&apos;t consider the thread suspended yet. On reply, notifySuspend()                    
                </comment>
                <comment line="199">
                    will be called.                    
                </comment>
                <scope line="193"/>
                <scope line="195"/>
            </method>
            <method name="resume" type="void" line="202">
                <comment line="203">
                    If it&apos;s a zombie, we can just update internal state without
                     going to back end.                    
                </comment>
                <scope line="207"/>
                <declaration name="stream" type="PacketStream" line="212"/>
                <scope line="213"/>
                <scope line="218"/>
                <scope line="220"/>
            </method>
            <method name="suspendCount" type="int" line="225">
                <comment line="226">
                    If it&apos;s a zombie, we maintain the count in the front end.                    
                </comment>
                <scope line="229"/>
                <scope line="233"/>
                <scope line="235"/>
            </method>
            <method name="stop" type="void" line="240">
                <params>
                    <param name="throwable" type="ObjectReference"/>
                </params>
                <comment line="242">
                    Verify that the given object is a Throwable instance                    
                </comment>
                <declaration name="list" type="List" line="243"/>
                <declaration name="throwableClass" type="ClassTypeImpl" line="244"/>
                <scope line="246"/>
                <scope line="250"/>
                <scope line="253"/>
            </method>
            <method name="interrupt" type="void" line="258">
                <scope line="259"/>
                <scope line="261"/>
            </method>
            <method name="jdwpStatus" type="JDWP.ThreadReference.Status" line="266">
                <comment line="273">
                    thread is suspended, we can cache the status.                    
                </comment>
                <declaration name="snapshot" type="LocalCache" line="267"/>
                <declaration name="myStatus" type="JDWP.ThreadReference.Status" line="268"/>
                <scope line="269">
                    <scope line="270">
                        <scope line="272"/>
                    </scope>
                </scope>
                <scope line="277"/>
            </method>
            <method name="status" type="int" line="283"/>
            <method name="isSuspended" type="boolean" line="287"/>
            <method name="isAtBreakpoint" type="boolean" line="292">
                <comment line="293">
                    TO DO: This fails to take filters into account.                    
                </comment>
                <comment line="309">
                    no frames on stack =&gt; not at breakpoint                    
                </comment>
                <comment line="311">
                    Per the javadoc, not suspended =&gt; return false                    
                </comment>
                <scope line="296">
                    <declaration name="frame" type="StackFrame" line="297"/>
                    <declaration name="location" type="Location" line="298"/>
                    <declaration name="requests" type="List" line="299"/>
                    <declaration name="iter" type="Iterator" line="300"/>
                    <scope line="301">
                        <declaration name="request" type="BreakpointRequest" line="302"/>
                        <scope line="303"/>
                    </scope>
                </scope>
                <scope line="308"/>
                <scope line="310"/>
            </method>
            <method name="threadGroup" type="ThreadGroupReference" line="316">
                <comment line="317">
                    Thread group can&apos;t change, so it&apos;s cached once and for all.                    
                </comment>
                <scope line="320">
                    <scope line="321"/>
                    <scope line="324"/>
                </scope>
            </method>
            <method name="frameCount" type="int" line="331">
                <comment line="341">
                                        
                </comment>
                <declaration name="snapshot" type="LocalCache" line="332"/>
                <scope line="333">
                    <scope line="334"/>
                </scope>
                <scope line="338"/>
            </method>
            <method name="frames" type="List<StackFrame>" line="350"/>
            <method name="frame" type="StackFrame" line="354">
                <params>
                    <param name="index" type="int"/>
                </params>
                <declaration name="list" type="List" line="355"/>
            </method>
            <javadoc line="359">
                Is the requested subrange within what has been retrieved?
                  local is known to be non-null.  Should only be called from
                  a sync method.                
            </javadoc>
            <method name="isSubrange" type="boolean" line="365">
                <params>
                    <param name="snapshot" type="LocalCache"/>
                    <param name="start" type="int"/>
                    <param name="length" type="int"/>
                </params>
                <scope line="366"/>
                <scope line="369"/>
                <scope line="372">
                    <scope line="374"/>
                </scope>
            </method>
            <method name="frames" type="List<StackFrame>" line="383">
                <params>
                    <param name="start" type="int"/>
                    <param name="length" type="int"/>
                </params>
                <scope line="384"/>
            </method>
            <javadoc line="391">
                Private version of frames() allows &quot;-1&quot; to specify all
                  remaining frames.                
            </javadoc>
            <method name="privateFrames" type="List<StackFrame>" line="396">
                <params>
                    <param name="start" type="int"/>
                    <param name="length" type="int"/>
                </params>
                <comment line="398">
                    Lock must be held while creating stack frames so if that two threads                    
                </comment>
                <comment line="399">
                    do this at the same time, one won&apos;t clobber the subset created by the other.                    
                </comment>
                <comment line="416">
                    Add to the frame list                    
                </comment>
                <comment line="435">
                                        
                </comment>
                <declaration name="snapshot" type="LocalCache" line="400"/>
                <scope line="401">
                    <scope line="402">
                        <declaration name="jdwpFrames" type="JDWP.ThreadReference.Frames.Frame[]" line="403"/>
                        <declaration name="count" type="int" line="406"/>
                        <scope line="409">
                            <scope line="410"/>
                            <declaration name="frame" type="StackFrame" line="413"/>
                        </scope>
                    </scope>
                    <scope line="422">
                        <declaration name="fromIndex" type="int" line="423"/>
                        <declaration name="toIndex" type="int" line="424"/>
                        <scope line="425"/>
                        <scope line="427"/>
                    </scope>
                </scope>
                <scope line="432"/>
            </method>
            <method name="ownedMonitors" type="List<ObjectReference>" line="443">
                <comment line="459">
                                        
                </comment>
                <declaration name="snapshot" type="LocalCache" line="444"/>
                <scope line="445">
                    <scope line="446">
                        <scope line="450"/>
                    </scope>
                </scope>
                <scope line="456"/>
            </method>
            <method name="currentContendedMonitor" type="ObjectReference" line="469">
                <comment line="487">
                                        
                </comment>
                <declaration name="snapshot" type="LocalCache" line="470"/>
                <scope line="471">
                    <scope line="473">
                        <scope line="478"/>
                    </scope>
                </scope>
                <scope line="484"/>
            </method>
            <method name="ownedMonitorsAndFrames" type="List<MonitorInfo>" line="496">
                <comment line="522">
                                        
                </comment>
                <declaration name="snapshot" type="LocalCache" line="497"/>
                <scope line="498">
                    <scope line="499">
                        <declaration name="minfo" type="JDWP.ThreadReference.OwnedMonitorsStackDepthInfo.monitor[]" line="500"/>
                        <scope line="505">
                            <declaration name="mi" type="JDWP.ThreadReference.OwnedMonitorsStackDepthInfo.monitor" line="506"/>
                            <declaration name="mon" type="MonitorInfo" line="508"/>
                        </scope>
                        <scope line="512"/>
                    </scope>
                </scope>
                <scope line="519"/>
            </method>
            <method name="popFrames" type="void" line="531">
                <params>
                    <param name="frame" type="StackFrame"/>
                </params>
                <comment line="532">
                    Note that interface-wise this functionality belongs                    
                </comment>
                <comment line="533">
                    here in ThreadReference, but implementation-wise it                    
                </comment>
                <comment line="534">
                    belongs in StackFrame, so we just forward it.                    
                </comment>
                <scope line="535"/>
                <scope line="538"/>
            </method>
            <method name="forceEarlyReturn" type="void" line="547">
                <params>
                    <param name="returnValue" type="Value"/>
                </params>
                <scope line="548"/>
                <declaration name="sf" type="StackFrameImpl" line="555"/>
                <scope line="556"/>
                <scope line="558"/>
                <declaration name="meth" type="MethodImpl" line="562"/>
                <declaration name="convertedValue" type="ValueImpl" line="563"/>
                <scope line="566"/>
                <scope line="568"/>
            </method>
            <method name="toString" type="String" line="587"/>
            <method name="typeValueKey" type="byte" line="592"/>
            <method name="addListener" type="void" line="596">
                <params>
                    <param name="listener" type="ThreadListener"/>
                </params>
                <scope line="597"/>
            </method>
            <method name="removeListener" type="void" line="602">
                <params>
                    <param name="listener" type="ThreadListener"/>
                </params>
                <scope line="603">
                    <declaration name="iter" type="Iterator" line="604"/>
                    <scope line="605">
                        <declaration name="ref" type="WeakReference" line="606"/>
                        <scope line="607"/>
                    </scope>
                </scope>
            </method>
            <javadoc line="615">
                Propagate the the thread state change information
                  to registered listeners.
                  Must be entered while synchronized on vm.state()                
            </javadoc>
            <method name="processThreadAction" type="void" line="620">
                <params>
                    <param name="action" type="ThreadAction"/>
                </params>
                <comment line="635">
                    Listener is unreachable; clean up                    
                </comment>
                <comment line="640">
                    Discard our local cache                    
                </comment>
                <scope line="621">
                    <declaration name="iter" type="Iterator" line="622"/>
                    <scope line="623">
                        <declaration name="ref" type="WeakReference" line="624"/>
                        <declaration name="listener" type="ThreadListener" line="625"/>
                        <scope line="626">
                            <scope line="629"/>
                        </scope>
                        <scope line="634"/>
                    </scope>
                </scope>
            </method>
        </class>
    </source>