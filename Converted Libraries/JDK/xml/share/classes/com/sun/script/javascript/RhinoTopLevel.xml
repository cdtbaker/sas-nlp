<?xml version="1.0" encoding="UTF-8"?>
    <source package="com.sun.script.javascript">
        <import package="sun.org.mozilla.javascript.internal"/>
        <import package="javax.script"/>
        <class name="RhinoTopLevel" line="31">
            <extends class="ImporterTopLevel"/>
            <javadoc line="31">
                This class serves as top level scope for Rhino. This class adds
                  3 top level functions (bindings, scope, sync) and two constructors
                  (JSAdapter, JavaAdapter).                
                <author>
                    A. Sundararajan                    
                </author>
                <since>
                    1.6                    
                </since>
            </javadoc>
            <method name="RhinoTopLevel" type="constructor" line="40">
                <params>
                    <param name="cx" type="Context"/>
                    <param name="engine" type="RhinoScriptEngine"/>
                </params>
                <comment line="46">
                    initialize JSAdapter lazily. Reduces footprint &amp; startup time.                    
                </comment>
                <comment line="51">
                    initialize JavaAdapter. We can&apos;t lazy initialize this because
                     lazy initializer attempts to define a new property. But, JavaAdapter
                     is an exisiting property that we overwrite.                    
                </comment>
                <comment line="58">
                    add top level functions                    
                </comment>
                <declaration name="names" type="String" line="58"/>
            </method>
            <javadoc line="63">
                The bindings function takes a JavaScript scope object
                  of type ExternalScriptable and returns the underlying Bindings
                  instance.
                  var page = scope(pageBindings);
                  with (page) {
                  // code that uses page scope
                  }
                  var b = bindings(page);
                  // operate on bindings here.                
            </javadoc>
            <method name="bindings" type="Object" line="76">
                <params>
                    <param name="cx" type="Context"/>
                    <param name="thisObj" type="Scriptable"/>
                    <param name="args" type="Object[]"/>
                    <param name="funObj" type="Function"/>
                </params>
                <scope line="77">
                    <declaration name="arg" type="Object" line="78"/>
                    <scope line="79"/>
                    <scope line="82">
                        <declaration name="ctx" type="ScriptContext" line="83"/>
                        <declaration name="bind" type="Bindings" line="84"/>
                    </scope>
                </scope>
            </method>
            <javadoc line="92">
                The scope function creates a new JavaScript scope object
                  with given Bindings object as backing store. This can be used
                  to create a script scope based on arbitrary Bindings instance.
                  For example, in webapp scenario, a &apos;page&apos; level Bindings instance
                  may be wrapped as a scope and code can be run in JavaScripe &apos;with&apos;
                  statement:
                  var page = scope(pageBindings);
                  with (page) {
                  // code that uses page scope
                  }                
            </javadoc>
            <method name="scope" type="Object" line="106">
                <params>
                    <param name="cx" type="Context"/>
                    <param name="thisObj" type="Scriptable"/>
                    <param name="args" type="Object[]"/>
                    <param name="funObj" type="Function"/>
                </params>
                <scope line="107">
                    <declaration name="arg" type="Object" line="108"/>
                    <scope line="109"/>
                    <scope line="112">
                        <declaration name="ctx" type="ScriptContext" line="113"/>
                        <declaration name="res" type="Scriptable" line="115"/>
                    </scope>
                </scope>
            </method>
            <javadoc line="124">
                The sync function creates a synchronized function (in the sense
                  of a Java synchronized method) from an existing function. The
                  new function synchronizes on the &lt;code&gt;this&lt;/code&gt; object of
                  its invocation.
                  js&gt; var o = { f : sync(function(x) {
                  print(&quot;entry&quot;);
                  Packages.java.lang.Thread.sleep(x1000);
                  print(&quot;exit&quot;);
                  })};
                  js&gt; thread(function() {o.f(5);});
                  entry
                  js&gt; thread(function() {o.f(5);});
                  js&gt;
                  exit
                  entry
                  exit                
            </javadoc>
            <method name="sync" type="Object" line="143">
                <params>
                    <param name="cx" type="Context"/>
                    <param name="thisObj" type="Scriptable"/>
                    <param name="args" type="Object[]"/>
                    <param name="funObj" type="Function"/>
                </params>
                <scope line="144"/>
                <scope line="146"/>
            </method>
            <method name="getScriptEngine" type="RhinoScriptEngine" line="151"/>
            <declaration name="engine" type="RhinoScriptEngine" line="155"/>
        </class>
    </source>