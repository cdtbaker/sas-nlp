<?xml version="1.0" encoding="UTF-8"?>
    <source package="com.sun.media.sound">
        <import package="java.io.File"/>
        <import package="java.io.InputStream"/>
        <import package="java.io.OutputStream"/>
        <import package="java.io.IOException"/>
        <import package="java.io.BufferedOutputStream"/>
        <import package="java.io.DataOutputStream"/>
        <import package="java.io.FileOutputStream"/>
        <import package="java.io.ByteArrayInputStream"/>
        <import package="java.io.ByteArrayOutputStream"/>
        <import package="java.io.RandomAccessFile"/>
        <import package="java.io.SequenceInputStream"/>
        <import package="javax.sound.sampled.AudioFileFormat"/>
        <import package="javax.sound.sampled.AudioInputStream"/>
        <import package="javax.sound.sampled.AudioFormat"/>
        <import package="javax.sound.sampled.AudioSystem"/>
        <class name="AiffFileWriter" line="48">
            <extends class="SunFileWriter"/>
            <comment line="72">
                METHODS TO IMPLEMENT AudioFileWriter                
            </comment>
            <comment line="158">
                -----------------------------------------------------------------------                
            </comment>
            <comment line="410">
                HELPER METHODS                
            </comment>
            <javadoc line="48">
                AIFF file writer.                
                <author>
                    Jan Borgersen                    
                </author>
            </javadoc>
            <declaration name="aiffTypes" type="AudioFileFormat.Type" line="55"/>
            <javadoc line="55">
                AIFF type                
            </javadoc>
            <javadoc line="63">
                Constructs a new AiffFileWriter object.                
            </javadoc>
            <method name="AiffFileWriter" type="constructor" line="66"/>
            <method name="getAudioFileTypes" type="AudioFileFormat.Type[]" line="73">
                <params>
                    <param name="stream" type="AudioInputStream"/>
                </params>
                <comment line="79">
                    make sure we can write this stream                    
                </comment>
                <declaration name="filetypes" type="AudioFileFormat.Type[]" line="75"/>
                <declaration name="format" type="AudioFormat" line="79"/>
                <declaration name="encoding" type="AudioFormat.Encoding" line="80"/>
                <scope line="85"/>
            </method>
            <method name="write" type="int" line="94">
                <params>
                    <param name="stream" type="AudioInputStream"/>
                    <param name="fileType" type="AudioFileFormat.Type"/>
                    <param name="out" type="OutputStream"/>
                </params>
                <comment line="97">
                    $$fb the following check must come first ! Otherwise
                     the next frame length check may throw an IOException and
                     interrupt iterating File Writers. (see bug 4351296)                    
                </comment>
                <comment line="101">
                    throws IllegalArgumentException if not supported                    
                </comment>
                <comment line="104">
                    we must know the total data length to calculate the file length                    
                </comment>
                <declaration name="aiffFileFormat" type="AiffFileFormat" line="101"/>
                <scope line="104"/>
                <declaration name="bytesWritten" type="int" line="108"/>
            </method>
            <method name="write" type="int" line="113">
                <params>
                    <param name="stream" type="AudioInputStream"/>
                    <param name="fileType" type="AudioFileFormat.Type"/>
                    <param name="out" type="File"/>
                </params>
                <comment line="116">
                    throws IllegalArgumentException if not supported                    
                </comment>
                <comment line="119">
                    first write the file without worrying about length fields                    
                </comment>
                <comment line="120">
                    throws IOException                    
                </comment>
                <comment line="125">
                    now, if length fields were not specified, calculate them,
                     open as a random access file, write the appropriate fields,
                     close again....                    
                </comment>
                <comment line="130">
                    $$kk: 10.22.99: jan: please either implement this or throw an exception!
                     $$fb: 2001-07-13: done. Fixes Bug 4479981                    
                </comment>
                <comment line="140">
                    skip FORM magic                    
                </comment>
                <comment line="143">
                    skip aiff2 magic, fver chunk, comm magic, comm size, channel count,                    
                </comment>
                <comment line="145">
                    write frame count                    
                </comment>
                <comment line="147">
                    skip sample size, samplerate, SSND magic                    
                </comment>
                <comment line="150">
                    that&apos;s all                    
                </comment>
                <declaration name="aiffFileFormat" type="AiffFileFormat" line="116"/>
                <declaration name="fos" type="FileOutputStream" line="119"/>
                <declaration name="bos" type="BufferedOutputStream" line="120"/>
                <declaration name="bytesWritten" type="int" line="121"/>
                <scope line="127">
                    <declaration name="ssndBlockSize" type="int" line="131"/>
                    <declaration name="aiffLength" type="int" line="133"/>
                    <declaration name="ssndChunkSize" type="int" line="134"/>
                    <declaration name="dataSize" type="long" line="135"/>
                    <declaration name="numFrames" type="int" line="136"/>
                    <declaration name="raf" type="RandomAccessFile" line="138"/>
                </scope>
            </method>
            <javadoc line="159">
                Returns the AudioFileFormat describing the file that will be written from this AudioInputStream.
                  Throws IllegalArgumentException if not supported.                
            </javadoc>
            <method name="getAudioFileFormat" type="AudioFileFormat" line="163">
                <params>
                    <param name="type" type="AudioFileFormat.Type"/>
                    <param name="stream" type="AudioInputStream"/>
                </params>
                <comment line="197">
                    can&apos;t convert non-8-bit ALAW,ULAW                    
                </comment>
                <comment line="218">
                    AIFF is big endian                    
                </comment>
                <declaration name="format" type="AudioFormat" line="165"/>
                <declaration name="fileFormat" type="AiffFileFormat" line="166"/>
                <declaration name="encoding" type="AudioFormat.Encoding" line="167"/>
                <declaration name="streamFormat" type="AudioFormat" line="169"/>
                <declaration name="streamEncoding" type="AudioFormat.Encoding" line="170"/>
                <declaration name="sampleRate" type="float" line="173"/>
                <declaration name="sampleSizeInBits" type="int" line="174"/>
                <declaration name="channels" type="int" line="175"/>
                <declaration name="frameSize" type="int" line="176"/>
                <declaration name="frameRate" type="float" line="177"/>
                <declaration name="fileSize" type="int" line="178"/>
                <declaration name="convert8to16" type="boolean" line="179"/>
                <scope line="181"/>
                <scope line="186">
                    <scope line="188"/>
                    <scope line="194"/>
                </scope>
                <scope line="199"/>
                <scope line="204"/>
                <scope line="220">
                    <scope line="221"/>
                    <scope line="223"/>
                </scope>
                <scope line="226"/>
            </method>
            <method name="writeAiffFile" type="int" line="239">
                <params>
                    <param name="in" type="InputStream"/>
                    <param name="aiffFileFormat" type="AiffFileFormat"/>
                    <param name="out" type="OutputStream"/>
                </params>
                <declaration name="bytesRead" type="int" line="241"/>
                <declaration name="bytesWritten" type="int" line="242"/>
                <declaration name="fileStream" type="InputStream" line="243"/>
                <declaration name="buffer" type="byte" line="244"/>
                <declaration name="maxLength" type="int" line="245"/>
                <scope line="247">
                    <scope line="248">
                        <scope line="249"/>
                        <scope line="253"/>
                    </scope>
                    <scope line="260"/>
                </scope>
            </method>
            <method name="getFileStream" type="InputStream" line="269">
                <params>
                    <param name="aiffFileFormat" type="AiffFileFormat"/>
                    <param name="audioStream" type="InputStream"/>
                </params>
                <comment line="272">
                    private method ... assumes aiffFileFormat is a supported file format                    
                </comment>
                <comment line="278">
                    $$fb a little bit nicer handling of constants                    
                </comment>
                <comment line="280">
                    int headerSize          = 54;                    
                </comment>
                <comment line="283">
                    int fverChunkSize       = 0;                    
                </comment>
                <comment line="285">
                    int commChunkSize       = 26;                    
                </comment>
                <comment line="289">
                    int ssndOffset                        = headerSize - 16;                    
                </comment>
                <comment line="311">
                    if we need to do any format conversion, do it here....                    
                </comment>
                <comment line="319">
                    $$jb: Note that AIFF samples are ALWAYS signed                    
                </comment>
                <comment line="323">
                    plug in the transcoder to convert to PCM_SIGNED. big endian                    
                </comment>
                <comment line="341">
                    $$fb 2001-07-13: this is probably not what we want:
                         writing PCM when ULAW/ALAW is requested. AIFC is able to write ULAW !                    
                </comment>
                <comment line="344">
                    plug in the transcoder to convert to PCM_SIGNED_BIG_ENDIAN                    
                </comment>
                <comment line="358">
                    Now create an AIFF stream header...                    
                </comment>
                <comment line="362">
                    Write the outer FORM chunk                    
                </comment>
                <comment line="367">
                    Write a FVER chunk - only for AIFC
                    dos.writeInt(FVER_MAGIC);
                    dos.writeInt( (fverChunkSize-8) );
                    dos.writeInt(FVER_TIMESTAMP);                    
                </comment>
                <comment line="372">
                    Write a COMM chunk                    
                </comment>
                <comment line="378">
                    10 bytes                    
                </comment>
                <comment line="380">
                    Only for AIFC
                    dos.writeInt(compCode);
                    dos.writeInt(compCode);
                    dos.writeShort(0);                    
                </comment>
                <comment line="385">
                    Write the SSND chunk header                    
                </comment>
                <comment line="388">
                    ssndOffset and ssndBlockSize set to 0 upon
                     recommendation in &quot;Sound Manager&quot; chapter in
                     &quot;Inside Macintosh Sound&quot;, pp 2-87  (from Babu)                    
                </comment>
                <comment line="391">
                    ssndOffset                    
                </comment>
                <comment line="392">
                    ssndBlockSize                    
                </comment>
                <comment line="394">
                    Concat this with the audioStream and return it                    
                </comment>
                <declaration name="format" type="AudioFormat" line="273"/>
                <declaration name="streamFormat" type="AudioFormat" line="274"/>
                <declaration name="encoding" type="AudioFormat.Encoding" line="275"/>
                <declaration name="headerSize" type="int" line="280"/>
                <declaration name="fverChunkSize" type="int" line="283"/>
                <declaration name="commChunkSize" type="int" line="285"/>
                <declaration name="aiffLength" type="int" line="286"/>
                <declaration name="ssndChunkSize" type="int" line="287"/>
                <declaration name="ssndOffset" type="int" line="289"/>
                <declaration name="channels" type="short" line="290"/>
                <declaration name="sampleSize" type="short" line="291"/>
                <declaration name="ssndBlockSize" type="int" line="292"/>
                <declaration name="numFrames" type="int" line="293"/>
                <declaration name="dataSize" type="long" line="294"/>
                <scope line="295"/>
                <declaration name="sampleFramesPerSecond" type="float" line="300"/>
                <declaration name="compCode" type="int" line="301"/>
                <declaration name="header" type="byte" line="303"/>
                <declaration name="headerStream" type="ByteArrayInputStream" line="304"/>
                <declaration name="baos" type="ByteArrayOutputStream" line="305"/>
                <declaration name="dos" type="DataOutputStream" line="306"/>
                <declaration name="aiffStream" type="SequenceInputStream" line="307"/>
                <declaration name="codedAudioStream" type="InputStream" line="308"/>
                <scope line="312">
                    <scope line="320"/>
                    <scope line="334">
                        <scope line="336"/>
                    </scope>
                </scope>
            </method>
            <declaration name="DOUBLE_MANTISSA_LENGTH" type="int" line="411"/>
            <declaration name="DOUBLE_EXPONENT_LENGTH" type="int" line="412"/>
            <declaration name="DOUBLE_SIGN_MASK" type="long" line="413"/>
            <declaration name="DOUBLE_EXPONENT_MASK" type="long" line="414"/>
            <declaration name="DOUBLE_MANTISSA_MASK" type="long" line="415"/>
            <declaration name="DOUBLE_EXPONENT_OFFSET" type="int" line="416"/>
            <declaration name="EXTENDED_EXPONENT_OFFSET" type="int" line="418"/>
            <declaration name="EXTENDED_MANTISSA_LENGTH" type="int" line="419"/>
            <declaration name="EXTENDED_EXPONENT_LENGTH" type="int" line="420"/>
            <declaration name="EXTENDED_INTEGER_MASK" type="long" line="421"/>
            <javadoc line="423">
                Extended precision IEEE floating-point conversion routine.                
                <argument>
                    DataOutputStream                    
                </argument>
                <argument>
                    double                    
                </argument>
                <exception>
                    IOException                    
                </exception>
            </javadoc>
            <method name="write_ieee_extended" type="void" line="429">
                <params>
                    <param name="dos" type="DataOutputStream"/>
                    <param name="f" type="float"/>
                </params>
                <comment line="431">
                    The special cases NaN, Infinity and Zero are ignored, since
                    they do not represent useful sample rates anyway.
                    Denormalized number aren&apos;t handled, too. Below, there is a cast
                    from float to double. We hope that in this conversion,
                    numbers are normalized. Numbers that cannot be normalized are                    
                </comment>
                <declaration name="doubleBits" type="long" line="436"/>
                <declaration name="sign" type="long" line="438"/>
                <declaration name="doubleExponent" type="long" line="440"/>
                <declaration name="doubleMantissa" type="long" line="442"/>
                <declaration name="extendedExponent" type="long" line="444"/>
                <declaration name="extendedMantissa" type="long" line="446"/>
                <declaration name="extendedSign" type="long" line="448"/>
                <declaration name="extendedBits79To64" type="short" line="449"/>
                <declaration name="extendedBits63To0" type="long" line="450"/>
            </method>
        </class>
    </source>