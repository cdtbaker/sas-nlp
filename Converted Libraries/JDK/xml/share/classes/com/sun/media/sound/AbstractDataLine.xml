<?xml version="1.0" encoding="UTF-8"?>
    <source package="com.sun.media.sound">
        <import package="java.util.Vector"/>
        <import package="javax.sound.sampled.AudioFormat"/>
        <import package="javax.sound.sampled.AudioSystem"/>
        <import package="javax.sound.sampled.Control"/>
        <import package="javax.sound.sampled.DataLine"/>
        <import package="javax.sound.sampled.LineEvent"/>
        <import package="javax.sound.sampled.LineUnavailableException"/>
        <import package="javax.sound.sampled.Mixer"/>
        <class name="AbstractDataLine" line="39">
            <extends class="AbstractLine"/>
            <comment line="47">
                DEFAULTS                
            </comment>
            <comment line="49">
                default format                
            </comment>
            <comment line="52">
                default buffer size in bytes                
            </comment>
            <comment line="55">
                the lock for synchronization                
            </comment>
            <comment line="58">
                STATE                
            </comment>
            <comment line="60">
                current format                
            </comment>
            <comment line="63">
                current buffer size in bytes                
            </comment>
            <comment line="105">
                DATA LINE METHODS                
            </comment>
            <comment line="240">
                $$jb: 12.10.99: The official API for this is isRunning().
                 Per the denied RFE 4297981,
                 the change to isStarted() is technically an unapproved API change.
                 The &apos;started&apos; variable is false when playback of data stops.
                 It is changed throughout the implementation with setStarted().
                 This state is what should be returned by isRunning() in the API.
                 Note that the &apos;running&apos; variable is true between calls to
                 start() and stop().  This state is accessed now through the
                 isStartedRunning() method, defined below.  I have not changed
                 the variable names at this point, since &apos;running&apos; is accessed
                 in MixerSourceLine and MixerClip, and I want to touch as little
                 code as possible to change isStarted() back to isRunning().                
            </comment>
            <comment line="296">
                HELPER METHODS                
            </comment>
            <comment line="404">
                OVERRIDES OF ABSTRACT LINE METHODS                
            </comment>
            <comment line="454">
                IMPLEMENTATIONS OF ABSTRACT LINE ABSTRACE METHODS                
            </comment>
            <comment line="457">
                ABSTRACT METHODS                
            </comment>
            <implements interface="DataLine"/>
            <javadoc line="39">
                AbstractDataLine                
                <author>
                    Kara Kytle                    
                </author>
            </javadoc>
            <declaration name="defaultFormat" type="AudioFormat" line="49"/>
            <declaration name="defaultBufferSize" type="int" line="52"/>
            <declaration name="lock" type="Object" line="55"/>
            <declaration name="format" type="AudioFormat" line="60"/>
            <declaration name="bufferSize" type="int" line="63"/>
            <declaration name="running" type="boolean" line="65"/>
            <declaration name="started" type="boolean" line="66"/>
            <declaration name="active" type="boolean" line="67"/>
            <javadoc line="70">
                Constructs a new AbstractLine.                
            </javadoc>
            <method name="AbstractDataLine" type="constructor" line="73">
                <params>
                    <param name="info" type="DataLine.Info"/>
                    <param name="mixer" type="AbstractMixer"/>
                    <param name="controls" type="Control[]"/>
                </params>
            </method>
            <javadoc line="77">
                Constructs a new AbstractLine.                
            </javadoc>
            <method name="AbstractDataLine" type="constructor" line="80">
                <params>
                    <param name="info" type="DataLine.Info"/>
                    <param name="mixer" type="AbstractMixer"/>
                    <param name="controls" type="Control[]"/>
                    <param name="format" type="AudioFormat"/>
                    <param name="bufferSize" type="int"/>
                </params>
                <comment line="85">
                    record the default values                    
                </comment>
                <comment line="89">
                    default CD-quality                    
                </comment>
                <comment line="95">
                    0.5 seconds buffer                    
                </comment>
                <comment line="99">
                    set the initial values to the defaults                    
                </comment>
                <scope line="85"/>
                <scope line="87"/>
                <scope line="91"/>
                <scope line="93"/>
            </method>
            <method name="open" type="void" line="106">
                <params>
                    <param name="format" type="AudioFormat"/>
                    <param name="bufferSize" type="int"/>
                </params>
                <comment line="108">
                    $$fb 2001-10-09: Bug #4517739: avoiding deadlock by synchronizing to mixer !                    
                </comment>
                <comment line="112">
                    if the line is not currently open, try to open it with this format and buffer size                    
                </comment>
                <comment line="114">
                    make sure that the format is specified correctly
                     $$fb part of fix for 4679187: Clip.open() throws unexpected Exceptions                    
                </comment>
                <comment line="119">
                    reserve mixer resources for this line
                    mixer.open(this, format, bufferSize);                    
                </comment>
                <comment line="124">
                    open the data line.  may throw LineUnavailableException.                    
                </comment>
                <comment line="127">
                    if we succeeded, set the open state to true and send events                    
                </comment>
                <comment line="131">
                    release mixer resources for this line and then throw the exception                    
                </comment>
                <comment line="138">
                    if the line is already open and the requested format differs from the
                     current settings, throw an IllegalStateException
                    $$fb 2002-04-02: fix for 4661602: Buffersize is checked when re-opening line                    
                </comment>
                <comment line="145">
                    $$fb 2002-07-26: allow changing the buffersize of already open lines                    
                </comment>
                <scope line="108">
                    <scope line="112">
                        <scope line="122"/>
                        <scope line="129"/>
                    </scope>
                    <scope line="134">
                        <scope line="140"/>
                        <scope line="145"/>
                    </scope>
                </scope>
            </method>
            <method name="open" type="void" line="155">
                <params>
                    <param name="format" type="AudioFormat"/>
                </params>
            </method>
            <javadoc line="160">
                This implementation always returns 0.                
            </javadoc>
            <method name="available" type="int" line="163"/>
            <javadoc line="168">
                This implementation does nothing.                
            </javadoc>
            <method name="drain" type="void" line="171"/>
            <javadoc line="176">
                This implementation does nothing.                
            </javadoc>
            <method name="flush" type="void" line="179"/>
            <method name="start" type="void" line="184">
                <comment line="186">
                    $$fb 2001-10-09: Bug #4517739: avoiding deadlock by synchronizing to mixer !                    
                </comment>
                <comment line="190">
                    $$kk: 06.06.99: if not open, this doesn&apos;t work....???                    
                </comment>
                <scope line="186">
                    <scope line="190">
                        <scope line="192"/>
                    </scope>
                </scope>
                <scope line="200"/>
            </method>
            <method name="stop" type="void" line="208">
                <comment line="211">
                    $$fb 2001-10-09: Bug #4517739: avoiding deadlock by synchronizing to mixer !                    
                </comment>
                <comment line="215">
                    $$kk: 06.06.99: if not open, this doesn&apos;t work.                    
                </comment>
                <comment line="225">
                    $$kk: 11.10.99: this is not exactly correct, but will probably work                    
                </comment>
                <scope line="211">
                    <scope line="215">
                        <scope line="217">
                            <scope line="225"/>
                        </scope>
                    </scope>
                </scope>
                <scope line="232"/>
            </method>
            <method name="isRunning" type="boolean" line="252"/>
            <method name="isActive" type="boolean" line="256"/>
            <method name="getMicrosecondPosition" type="long" line="261">
                <declaration name="microseconds" type="long" line="263"/>
                <scope line="264"/>
            </method>
            <method name="getFormat" type="AudioFormat" line="271"/>
            <method name="getBufferSize" type="int" line="276"/>
            <javadoc line="280">
                This implementation does NOT change the buffer size                
            </javadoc>
            <method name="setBufferSize" type="int" line="283">
                <params>
                    <param name="newSize" type="int"/>
                </params>
            </method>
            <javadoc line="287">
                This implementation returns AudioSystem.NOT_SPECIFIED.                
            </javadoc>
            <method name="getLevel" type="float" line="290"/>
            <javadoc line="297">
                running is true after start is called and before stop is called,
                  regardless of whether data is actually being presented.                
            </javadoc>
            <method name="isStartedRunning" type="boolean" line="307">
                <comment line="302">
                    $$jb: 12.10.99: calling this method isRunning() conflicts with
                     the official API that was once called isStarted().  Since we
                     use this method throughout the implementation, I am renaming
                     it to isStartedRunning().  This is part of backing out the
                     change denied in RFE 4297981.                    
                </comment>
            </method>
            <javadoc line="311">
                This method sets the active state and generates
                  events if it changes.                
            </javadoc>
            <method name="setActive" type="void" line="315">
                <params>
                    <param name="active" type="boolean"/>
                </params>
                <comment line="320">
                    boolean sendEvents = false;
                    long position = getLongFramePosition();                    
                </comment>
                <comment line="325">
                    if (Printer.debug) Printer.debug(&quot;    AbstractDataLine: setActive: this.active: &quot; + this.active);
                    if (Printer.debug) Printer.debug(&quot;                                 active: &quot; + active);                    
                </comment>
                <comment line="330">
                    sendEvents = true;                    
                </comment>
                <comment line="334">
                    if (Printer.debug) Printer.debug(&quot;                                 this.active: &quot; + this.active);
                    if (Printer.debug) Printer.debug(&quot;                                 sendEvents: &quot; + sendEvents);                    
                </comment>
                <comment line="338">
                    $$kk: 11.19.99: take ACTIVE / INACTIVE / EOM events out;
                     putting them in is technically an API change.
                     do not generate ACTIVE / INACTIVE events for now
                     if (sendEvents) {
                    
                          if (active) {
                                  sendEvents(new LineEvent(this, LineEvent.Type.ACTIVE, position));
                          } else {
                                  sendEvents(new LineEvent(this, LineEvent.Type.INACTIVE, position));
                          }
                    }                    
                </comment>
                <scope line="322">
                    <scope line="327"/>
                </scope>
            </method>
            <javadoc line="350">
                This method sets the started state and generates
                  events if it changes.                
            </javadoc>
            <method name="setStarted" type="void" line="354">
                <params>
                    <param name="started" type="boolean"/>
                </params>
                <comment line="364">
                    if (Printer.debug) Printer.debug(&quot;    AbstractDataLine: setStarted: this.started: &quot; + this.started);
                    if (Printer.debug) Printer.debug(&quot;                                  started: &quot; + started);                    
                </comment>
                <comment line="373">
                    if (Printer.debug) Printer.debug(&quot;                                  this.started: &quot; + this.started);
                    if (Printer.debug) Printer.debug(&quot;                                  sendEvents: &quot; + sendEvents);                    
                </comment>
                <declaration name="sendEvents" type="boolean" line="358"/>
                <declaration name="position" type="long" line="359"/>
                <scope line="361">
                    <scope line="366"/>
                </scope>
                <scope line="375">
                    <scope line="377"/>
                    <scope line="379"/>
                </scope>
            </method>
            <javadoc line="387">
                This method generates a STOP event and sets the started state to false.
                  It is here for historic reasons when an EOM event existed.                
            </javadoc>
            <method name="setEOM" type="void" line="391">
                <comment line="395">
                    $$fb 2002-04-21: sometimes, 2 STOP events are generated.
                     better use setStarted() to send STOP event.                    
                </comment>
            </method>
            <javadoc line="405">
                Try to open the line with the current format and buffer size values.
                  If the line is not open, these will be the defaults.  If the
                  line is open, this should return quietly because the values
                  requested will match the current ones.                
            </javadoc>
            <method name="open" type="void" line="411">
                <comment line="416">
                    this may throw a LineUnavailableException.                    
                </comment>
            </method>
            <javadoc line="421">
                This should also stop the line.  The closed line should not be running or active.
                  After we close the line, we reset the format and buffer size to the defaults.                
            </javadoc>
            <method name="close" type="void" line="425">
                <comment line="427">
                    $$fb 2001-10-09: Bug #4517739: avoiding deadlock by synchronizing to mixer !                    
                </comment>
                <comment line="433">
                    stop                    
                </comment>
                <comment line="436">
                    set the open state to false and send events                    
                </comment>
                <comment line="439">
                    close resources for this line                    
                </comment>
                <comment line="442">
                    release mixer resources for this line                    
                </comment>
                <comment line="445">
                    reset format and buffer size to the defaults                    
                </comment>
                <scope line="427">
                    <scope line="430"/>
                </scope>
            </method>
            <method name="implOpen" type="void" line="458"/>
            <method name="implClose" type="void" line="459"/>
            <method name="implStart" type="void" line="461"/>
            <method name="implStop" type="void" line="462"/>
        </class>
    </source>