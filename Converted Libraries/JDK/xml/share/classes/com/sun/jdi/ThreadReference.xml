<?xml version="1.0" encoding="UTF-8"?>
    <source package="com.sun.jdi">
        <import package="java.util.List"/>
        <interface name="ThreadReference">
            <implements interface="ObjectReference"/>
            <javadoc line="3">
                A thread object from the target VM.
                  A ThreadReference is an {@link ObjectReference} with additional
                  access to thread-specific information from the target VM.                
                <author>
                    Robert Field                    
                </author>
                <author>
                    Gordon Hirsch                    
                </author>
                <author>
                    James McIlree                    
                </author>
                <since>
                    1.3                    
                </since>
            </javadoc>
            <declaration name="THREAD_STATUS_UNKNOWN" type="int" line="13"/>
            <javadoc line="13">
                Thread status is unknown                
            </javadoc>
            <declaration name="THREAD_STATUS_ZOMBIE" type="int" line="17"/>
            <javadoc line="17">
                Thread has completed execution                
            </javadoc>
            <declaration name="THREAD_STATUS_RUNNING" type="int" line="21"/>
            <javadoc line="21">
                Thread is runnable                
            </javadoc>
            <declaration name="THREAD_STATUS_SLEEPING" type="int" line="25"/>
            <javadoc line="25">
                Thread is sleeping - Thread.sleep() or JVM_Sleep() was called                
            </javadoc>
            <declaration name="THREAD_STATUS_MONITOR" type="int" line="29"/>
            <javadoc line="29">
                Thread is waiting on a java monitor                
            </javadoc>
            <declaration name="THREAD_STATUS_WAIT" type="int" line="33"/>
            <javadoc line="33">
                Thread is waiting - Object.wait() or JVM_MonitorWait() was called                
            </javadoc>
            <declaration name="THREAD_STATUS_NOT_STARTED" type="int" line="37"/>
            <javadoc line="37">
                Thread has not yet been started                
            </javadoc>
            <method name="name" type="String" line="41"/>
            <javadoc line="41">
                Returns the name of this thread.                
                <return>
                    the string containing the thread name.                    
                </return>
            </javadoc>
            <method name="suspend" type="void" line="46"/>
            <javadoc line="46">
                Suspends this thread. The thread can be resumed through{@link #resume} or resumed with other threads through{@link VirtualMachine#resume}.
                  &lt;p&gt;
                  Unlike {@link java.lang.Thread#suspend},
                  suspends of both the virtual machine and individual threads are
                  counted. Before a thread will run again, it must be resumed
                  (through {@link #resume} or {@link ThreadReference#resume})
                  the same number of times it has been suspended.
                  &lt;p&gt;
                  Suspending single threads with this method has the same dangers
                  as {@link java.lang.Thread#suspend()}. If the suspended thread
                  holds a monitor needed by another running thread, deadlock is
                  possible in the target VM (at least until the suspended thread
                  is resumed again).
                  &lt;p&gt;
                  The suspended thread is guaranteed to remain suspended until
                  resumed through one of the JDI resume methods mentioned above;
                  the application in the target VM cannot resume the suspended thread
                  through {@link java.lang.Thread#resume}.                
                <throws>
                    VMCannotBeModifiedException if the VirtualMachine is read-only - see {@link VirtualMachine#canBeModified()}.                    
                </throws>
            </javadoc>
            <method name="resume" type="void" line="68"/>
            <javadoc line="68">
                Resumes this thread. If this thread was not previously suspended
                  through {@link #suspend} or through {@link VirtualMachine#suspend},
                  or because of a SUSPEND_ALL or SUSPEND_EVENT_THREAD event, then
                  invoking this method has no effect. Otherwise, the count of pending
                  suspends on this thread is decremented. If it is decremented to 0,
                  the thread will continue to execute.
                  Note: the normal way to resume from an event related suspension is
                  via {@link com.sun.jdi.event.EventSet#resume}.                
                <throws>
                    VMCannotBeModifiedException if the VirtualMachine is read-only - see {@link VirtualMachine#canBeModified()}.                    
                </throws>
            </javadoc>
            <method name="suspendCount" type="int" line="80"/>
            <javadoc line="80">
                Returns the number of pending suspends for this thread. See{@link #suspend} for an explanation of counted suspends.                
                <return>
                    pending suspend count as an integer                    
                </return>
            </javadoc>
            <method name="stop" type="void" line="85"/>
            <javadoc line="85">
                Stops this thread with an asynchronous exception.
                  A debugger thread in the target VM will stop this thread
                  with the given {@link java.lang.Throwable} object.                
                <param>
                    throwable the asynchronous exception to throw.                    
                </param>
                <throws>
                    InvalidTypeException if &lt;code&gt;throwable&lt;/code&gt; is not
                      an instance of java.lang.Throwable in the target VM.                    
                </throws>
                <throws>
                    VMCannotBeModifiedException if the VirtualMachine is read-only - see {@link VirtualMachine#canBeModified()}.                    
                </throws>
                <see>
                    java.lang.Thread#stop(Throwable)                    
                </see>
            </javadoc>
            <method name="interrupt" type="void" line="96"/>
            <javadoc line="96">
                Interrupts this thread unless the thread has been suspended by the
                  debugger.                
                <throws>
                    VMCannotBeModifiedException if the VirtualMachine is read-only - see {@link VirtualMachine#canBeModified()}.                    
                </throws>
                <see>
                    java.lang.Thread#interrupt()                    
                </see>
            </javadoc>
            <method name="status" type="int" line="103"/>
            <javadoc line="103">
                Returns the thread&apos;s status. If the thread is not suspended the
                  thread&apos;s current status is returned. If the thread is suspended, the
                  thread&apos;s status before the suspension is returned (or{@link #THREAD_STATUS_UNKNOWN} if this information is not available.{@link #isSuspended} can be used to determine if the thread has been
                  suspended.                
                <return>
                    one of{@link #THREAD_STATUS_UNKNOWN},{@link #THREAD_STATUS_ZOMBIE},{@link #THREAD_STATUS_RUNNING},{@link #THREAD_STATUS_SLEEPING},{@link #THREAD_STATUS_MONITOR},{@link #THREAD_STATUS_WAIT},{@link #THREAD_STATUS_NOT_STARTED},                    
                </return>
            </javadoc>
            <method name="isSuspended" type="boolean" line="111"/>
            <javadoc line="111">
                Determines whether the thread has been suspended by the
                  the debugger.                
                <return>
                    &lt;code&gt;true&lt;/code&gt; if the thread is currently suspended;
                      &lt;code&gt;false&lt;/code&gt; otherwise.                    
                </return>
            </javadoc>
            <method name="isAtBreakpoint" type="boolean" line="118"/>
            <javadoc line="118">
                Determines whether the thread is suspended at a breakpoint.                
                <return>
                    &lt;code&gt;true&lt;/code&gt; if the thread is currently stopped at
                      a breakpoint; &lt;code&gt;false&lt;/code&gt; otherwise.                    
                </return>
            </javadoc>
            <method name="threadGroup" type="ThreadGroupReference" line="124"/>
            <javadoc line="124">
                Returns this thread&apos;s thread group.                
                <return>
                    a {@link ThreadGroupReference} that mirrors this thread&apos;s
                      thread group in the target VM.                    
                </return>
            </javadoc>
            <method name="frameCount" type="int" line="130"/>
            <javadoc line="130">
                Returns the number of stack frames in the thread&apos;s current
                  call stack.
                  The thread must be suspended (normally through an interruption
                  to the VM) to get this information, and
                  it is only valid until the thread is resumed again.                
                <return>
                    an integer frame count                    
                </return>
                <throws>
                    IncompatibleThreadStateException if the thread is
                      not suspended in the target VM                    
                </throws>
            </javadoc>
            <method name="frames" type="List&lt;StackFrame&gt;" line="141"/>
            <javadoc line="141">
                Returns a List containing each {@link StackFrame} in the
                  thread&apos;s current call stack.
                  The thread must be suspended (normally through an interruption
                  to the VM) to get this information, and
                  it is only valid until the thread is resumed again.                
                <return>
                    a List of {@link StackFrame} with the current frame first
                      followed by each caller&apos;s frame.                    
                </return>
                <throws>
                    IncompatibleThreadStateException if the thread is
                      not suspended in the target VM                    
                </throws>
            </javadoc>
            <method name="frame" type="StackFrame" line="153"/>
            <javadoc line="153">
                Returns the {@link StackFrame} at the given index in the
                  thread&apos;s current call stack. Index 0 retrieves the current
                  frame; higher indices retrieve caller frames.
                  The thread must be suspended (normally through an interruption
                  to the VM) to get this information, and
                  it is only valid until the thread is resumed again.                
                <param>
                    index the desired frame                    
                </param>
                <return>
                    the requested {@link StackFrame}                    
                </return>
                <throws>
                    IncompatibleThreadStateException if the thread is
                      not suspended in the target VM                    
                </throws>
                <throws>
                    java.lang.IndexOutOfBoundsException if the index is greater than
                      or equal to {@link #frameCount} or is negative.                    
                </throws>
            </javadoc>
            <method name="frames" type="List&lt;StackFrame&gt;" line="168"/>
            <javadoc line="168">
                Returns a List containing a range of {@link StackFrame} mirrors
                  from the thread&apos;s current call stack.
                  The thread must be suspended (normally through an interruption
                  to the VM) to get this information, and
                  it is only valid until the thread is resumed again.                
                <param>
                    start the index of the first frame to retrieve.
                      Index 0 represents the current frame.                    
                </param>
                <param>
                    length the number of frames to retrieve                    
                </param>
                <return>
                    a List of {@link StackFrame} with the current frame first
                      followed by each caller&apos;s frame.                    
                </return>
                <throws>
                    IncompatibleThreadStateException if the thread is
                      not suspended in the target VM                    
                </throws>
                <throws>
                    IndexOutOfBoundsException if the specified range is not
                      within the range of stack frame indicies.
                      That is, the exception is thrown if any of the following are true:
                      &lt;pre&gt;    start &amp;lt; 0
                      start &amp;gt;= {@link #frameCount}length &amp;lt; 0
                      (start+length) &amp;gt; {@link #frameCount}&lt;/pre&gt;                    
                </throws>
            </javadoc>
            <method name="ownedMonitors" type="List&lt;ObjectReference&gt;" line="189"/>
            <javadoc line="189">
                Returns a List containing an {@link ObjectReference} for
                  each monitor owned by the thread.
                  A monitor is owned by a thread if it has been entered
                  (via the synchronized statement or entry into a synchronized
                  method) and has not been relinquished through {@link Object#wait}.
                  &lt;p&gt;
                  Not all target virtual machines support this operation.
                  Use {@link VirtualMachine#canGetOwnedMonitorInfo()}to determine if the operation is supported.                
                <return>
                    a List of {@link ObjectReference} objects. The list
                      has zero length if no monitors are owned by this thread.                    
                </return>
                <throws>
                    java.lang.UnsupportedOperationException if
                      the target virtual machine does not support this
                      operation.                    
                </throws>
                <throws>
                    IncompatibleThreadStateException if the thread is
                      not suspended in the target VM                    
                </throws>
            </javadoc>
            <method name="ownedMonitorsAndFrames" type="List&lt;MonitorInfo&gt;" line="207"/>
            <javadoc line="207">
                Returns a List containing a {@link MonitorInfo} object for
                  each monitor owned by the thread.
                  A monitor is owned by a thread if it has been entered
                  (via the synchronized statement or entry into a synchronized
                  method) and has not been relinquished through {@link Object#wait}.
                  &lt;p&gt;
                  Not all target virtual machines support this operation.
                  Use {@link VirtualMachine#canGetMonitorFrameInfo()}to determine if the operation is supported.                
                <return>
                    a List of {@link MonitorInfo} objects. The list
                      has zero length if no monitors are owned by this thread.                    
                </return>
                <throws>
                    java.lang.UnsupportedOperationException if
                      the target virtual machine does not support this
                      operation.                    
                </throws>
                <throws>
                    IncompatibleThreadStateException if the thread is
                      not suspended in the target VM                    
                </throws>
                <since>
                    1.6                    
                </since>
            </javadoc>
            <method name="currentContendedMonitor" type="ObjectReference" line="226"/>
            <javadoc line="226">
                Returns an {@link ObjectReference} for the monitor, if any,
                  for which this thread is currently waiting.
                  The thread can be waiting for a monitor through entry into a
                  synchronized method, the synchronized statement, or{@link Object#wait}.  The {@link #status} method can be used
                  to differentiate between the first two cases and the third.
                  &lt;p&gt;
                  Not all target virtual machines support this operation.
                  Use {@link VirtualMachine#canGetCurrentContendedMonitor()}to determine if the operation is supported.                
                <return>
                    the {@link ObjectReference} corresponding to the
                      contended monitor, or null if it is not waiting for a monitor.                    
                </return>
                <throws>
                    java.lang.UnsupportedOperationException if
                      the target virtual machine does not support this
                      operation.                    
                </throws>
                <throws>
                    IncompatibleThreadStateException if the thread is
                      not suspended in the target VM                    
                </throws>
            </javadoc>
            <method name="popFrames" type="void" line="244"/>
            <javadoc line="244">
                Pop stack frames.
                  &lt;P&gt;
                  All frames up to and including the &lt;CODE&gt;frame&lt;/CODE&gt; are
                  popped off the stack.
                  The frame previous to the parameter &lt;CODE&gt;frame&lt;/CODE&gt;
                  will become the current frame.
                  &lt;P&gt;
                  After this operation, this thread will be
                  suspended at the invoke instruction of the target method
                  that created &lt;CODE&gt;frame&lt;/CODE&gt;.
                  The &lt;CODE&gt;frame&lt;/CODE&gt;&apos;s method can be reentered with a step into
                  the instruction.
                  &lt;P&gt;
                  The operand stack is restored, however, any changes
                  to the arguments that occurred in the called method, remain.
                  For example, if the method &lt;CODE&gt;foo&lt;/CODE&gt;:
                  &lt;PRE&gt;
                  void foo(int x) {
                  System.out.println(&quot;Foo: &quot; + x);
                  x = 4;
                  System.out.println(&quot;pop here&quot;);
                  }
                  &lt;/PRE&gt;
                  was called with &lt;CODE&gt;foo(7)&lt;/CODE&gt; and &lt;CODE&gt;foo&lt;/CODE&gt;
                  is popped at the second &lt;CODE&gt;println&lt;/CODE&gt; and resumed,
                  it will print: &lt;CODE&gt;Foo: 4&lt;/CODE&gt;.
                  &lt;P&gt;
                  Locks acquired by a popped frame are released when it
                  is popped. This applies to synchronized methods that
                  are popped, and to any synchronized blocks within them.
                  &lt;P&gt;
                  Finally blocks are not executed.
                  &lt;P&gt;
                  No aspect of state, other than this thread&apos;s execution point and
                  locks, is affected by this call.  Specifically, the values of
                  fields are unchanged, as are external resources such as
                  I/O streams.  Additionally, the target program might be
                  placed in a state that is impossible with normal program flow;
                  for example, order of lock acquisition might be perturbed.
                  Thus the target program may
                  proceed differently than the user would expect.
                  &lt;P&gt;
                  The specified thread must be suspended.
                  &lt;P&gt;
                  All &lt;code&gt;StackFrame&lt;/code&gt; objects for this thread are
                  invalidated.
                  &lt;P&gt;
                  No events are generated by this method.
                  &lt;P&gt;
                  None of the frames through and including the frame for the caller
                  of &lt;i&gt;frame&lt;/i&gt; may be native.
                  &lt;P&gt;
                  Not all target virtual machines support this operation.
                  Use {@link VirtualMachine#canPopFrames() VirtualMachine.canPopFrames()}to determine if the operation is supported.                
                <param>
                    frame Stack frame to pop.  &lt;CODE&gt;frame&lt;/CODE&gt; is on this
                      thread&apos;s call stack.                    
                </param>
                <throws>
                    java.lang.UnsupportedOperationException if
                      the target virtual machine does not support this
                      operation - see{@link VirtualMachine#canPopFrames() VirtualMachine.canPopFrames()}.                    
                </throws>
                <throws>
                    IncompatibleThreadStateException if this
                      thread is not suspended.                    
                </throws>
                <throws>
                    java.lang.IllegalArgumentException if &lt;CODE&gt;frame&lt;/CODE&gt;
                      is not on this thread&apos;s call stack.                    
                </throws>
                <throws>
                    NativeMethodException if one of the frames that would be
                      popped is that of a native method or if the frame previous to
                      &lt;i&gt;frame&lt;/i&gt; is native.                    
                </throws>
                <throws>
                    InvalidStackFrameException if &lt;CODE&gt;frame&lt;/CODE&gt; has become
                      invalid. Once this thread is resumed, the stack frame is
                      no longer valid.  This exception is also thrown if there are no
                      more frames.                    
                </throws>
                <throws>
                    VMCannotBeModifiedException if the VirtualMachine is read-only - see {@link VirtualMachine#canBeModified()}.                    
                </throws>
                <since>
                    1.4                    
                </since>
            </javadoc>
            <method name="forceEarlyReturn" type="void" line="319"/>
            <javadoc line="319">
                Force a method to return before it reaches a return
                  statement.
                  &lt;p&gt;
                  The method which will return early is referred to as the
                  called method. The called method is the current method (as
                  defined by the Frames section in the Java Virtual Machine
                  Specification) for the specified thread at the time this
                  method is called.
                  &lt;p&gt;
                  The thread must be suspended.
                  The return occurs when execution of Java programming
                  language code is resumed on this thread. Between the call to
                  this method and resumption of thread execution, the
                  state of the stack is undefined.
                  &lt;p&gt;
                  No further instructions are executed in the called
                  method. Specifically, finally blocks are not executed. Note:
                  this can cause inconsistent states in the application.
                  &lt;p&gt;
                  A lock acquired by calling the called method (if it is a
                  synchronized method) and locks acquired by entering
                  synchronized blocks within the called method are
                  released. Note: this does not apply to native locks or
                  java.util.concurrent.locks locks.
                  &lt;p&gt;
                  Events, such as MethodExit, are generated as they would be in
                  a normal return.
                  &lt;p&gt;
                  The called method must be a non-native Java programming
                  language method. Forcing return on a thread with only one
                  frame on the stack causes the thread to exit when resumed.
                  &lt;p&gt;
                  The &lt;code&gt;value&lt;/code&gt; argument is the value that the
                  method is to return.
                  If the return type of the method is void, then value must
                  be a  {@link VoidValue VoidValue}.
                  Object values must be assignment compatible with the method return type
                  (This implies that the method return type must be loaded through the
                  enclosing class&apos;s class loader). Primitive values must be
                  either assignment compatible with the method return type or must be
                  convertible to the variable type without loss of information.
                  See JLS section 5.2 for more information on assignment
                  compatibility.
                  &lt;p&gt;
                  Not all target virtual machines support this operation.
                  Use {@link VirtualMachine#canForceEarlyReturn()}to determine if the operation is supported.                
                <param>
                    value the value the method is to return.                    
                </param>
                <throws>
                    java.lang.UnsupportedOperationException if
                      the target virtual machine does not support this
                      operation - see{@link VirtualMachine#canGetInstanceInfo() canForceEarlyReturn()}                    
                </throws>
                <throws>
                    IncompatibleThreadStateException if this
                      thread is not suspended.                    
                </throws>
                <throws>
                    NativeMethodException if the frame to be returned from
                      is that of a native method.                    
                </throws>
                <throws>
                    InvalidStackFrameException if there are no frames.                    
                </throws>
                <throws>
                    InvalidTypeException if the value&apos;s type does not match
                      the method&apos;s return type.                    
                </throws>
                <throws>
                    ClassNotLoadedException if the method&apos;s return type has not yet
                      been loaded through the appropriate class loader.                    
                </throws>
                <throws>
                    VMCannotBeModifiedException if the VirtualMachine is read-only - see {@link VirtualMachine#canBeModified()}.                    
                </throws>
                <since>
                    1.6                    
                </since>
            </javadoc>
        </interface>
    </source>