<?xml version="1.0" encoding="UTF-8"?>
    <source package="com.sun.imageio.plugins.png">
        <import package="java.awt.Point"/>
        <import package="java.awt.Rectangle"/>
        <import package="java.awt.color.ColorSpace"/>
        <import package="java.awt.image.BufferedImage"/>
        <import package="java.awt.image.DataBuffer"/>
        <import package="java.awt.image.DataBufferByte"/>
        <import package="java.awt.image.DataBufferUShort"/>
        <import package="java.awt.image.Raster"/>
        <import package="java.awt.image.WritableRaster"/>
        <import package="java.io.BufferedInputStream"/>
        <import package="java.io.ByteArrayInputStream"/>
        <import package="java.io.DataInputStream"/>
        <import package="java.io.EOFException"/>
        <import package="java.io.InputStream"/>
        <import package="java.io.IOException"/>
        <import package="java.io.SequenceInputStream"/>
        <import package="java.util.ArrayList"/>
        <import package="java.util.Arrays"/>
        <import package="java.util.Enumeration"/>
        <import package="java.util.Iterator"/>
        <import package="java.util.zip.Inflater"/>
        <import package="java.util.zip.InflaterInputStream"/>
        <import package="javax.imageio.IIOException"/>
        <import package="javax.imageio.ImageReader"/>
        <import package="javax.imageio.ImageReadParam"/>
        <import package="javax.imageio.ImageTypeSpecifier"/>
        <import package="javax.imageio.metadata.IIOMetadata"/>
        <import package="javax.imageio.spi.ImageReaderSpi"/>
        <import package="javax.imageio.stream.ImageInputStream"/>
        <import package="com.sun.imageio.plugins.common.InputStreamAdapter"/>
        <import package="com.sun.imageio.plugins.common.ReaderUtil"/>
        <import package="com.sun.imageio.plugins.common.SubImageInputStream"/>
        <import package="java.io.ByteArrayOutputStream"/>
        <import package="sun.awt.image.ByteInterleavedRaster"/>
        <class name="PNGImageDataEnumeration" line="63">
            <comment line="109">
                Note: The following chunk type constants are autogenerated.  Each
                 one is derived from the ASCII values of its 4-character name.  For
                 example, IHDR_TYPE is calculated as follows:
                            (&apos;I&apos; &lt;&lt; 24) | (&apos;H&apos; &lt;&lt; 16) | (&apos;D&apos; &lt;&lt; 8) | &apos;R&apos;                
            </comment>
            <comment line="116">
                Critical chunks                
            </comment>
            <comment line="122">
                Ancillary chunks                
            </comment>
            <comment line="144">
                The number of bands by PNG color type                
            </comment>
            <comment line="192">
                The number of source pixels processed                
            </comment>
            <comment line="195">
                The total number of pixels in the source image                
            </comment>
            <comment line="776">
                Data filtering methods                
            </comment>
            <comment line="1524">
                Super class implementation uses first element
                 of image types list as raw image type.
                
                 Also, super implementation uses first element of this list
                 as default destination type image read param does not specify
                 anything other.
                
                 However, in case of RGB and RGBA color types, raw image type
                 produces buffered image of custom type. It causes some
                 performance degradation of subsequent rendering operations.
                
                 To resolve this contradiction we put standard image types
                 at the first positions of image types list (to produce standard
                 images by default) and put raw image type (which is custom)
                 at the last position of this list.
                
                 After this changes we should override getRawImageType()
                 to return last element of image types list.                
            </comment>
            <implements interface="Enumeration">
                <type_params>
                    <type_param name="InputStream"/>
                </type_params>
            </implements>
            <declaration name="firstTime" type="boolean" line="65"/>
            <declaration name="stream" type="ImageInputStream" line="66"/>
            <declaration name="length" type="int" line="67"/>
            <method name="PNGImageDataEnumeration" type="constructor" line="70">
                <params>
                    <param name="stream" type="ImageInputStream"/>
                </params>
                <comment line="74">
                    skip chunk type                    
                </comment>
                <declaration name="type" type="int" line="73"/>
            </method>
            <method name="nextElement" type="InputStream" line="76">
                <scope line="77">
                    <declaration name="iis" type="ImageInputStream" line="79"/>
                </scope>
                <scope line="81"/>
            </method>
            <method name="hasMoreElements" type="boolean" line="86">
                <scope line="87"/>
                <scope line="91">
                    <declaration name="crc" type="int" line="92"/>
                    <declaration name="type" type="int" line="94"/>
                    <scope line="95"/>
                    <scope line="97"/>
                </scope>
                <scope line="100"/>
            </method>
        </class>
        <class name="PNGImageReader" line="106">
            <extends class="ImageReader"/>
            <comment line="109">
                Note: The following chunk type constants are autogenerated.  Each
                 one is derived from the ASCII values of its 4-character name.  For
                 example, IHDR_TYPE is calculated as follows:
                            (&apos;I&apos; &lt;&lt; 24) | (&apos;H&apos; &lt;&lt; 16) | (&apos;D&apos; &lt;&lt; 8) | &apos;R&apos;                
            </comment>
            <comment line="116">
                Critical chunks                
            </comment>
            <comment line="122">
                Ancillary chunks                
            </comment>
            <comment line="144">
                The number of bands by PNG color type                
            </comment>
            <comment line="192">
                The number of source pixels processed                
            </comment>
            <comment line="195">
                The total number of pixels in the source image                
            </comment>
            <comment line="776">
                Data filtering methods                
            </comment>
            <comment line="1524">
                Super class implementation uses first element
                 of image types list as raw image type.
                
                 Also, super implementation uses first element of this list
                 as default destination type image read param does not specify
                 anything other.
                
                 However, in case of RGB and RGBA color types, raw image type
                 produces buffered image of custom type. It causes some
                 performance degradation of subsequent rendering operations.
                
                 To resolve this contradiction we put standard image types
                 at the first positions of image types list (to produce standard
                 images by default) and put raw image type (which is custom)
                 at the last position of this list.
                
                 After this changes we should override getRawImageType()
                 to return last element of image types list.                
            </comment>
            <declaration name="IHDR_TYPE" type="int" line="116"/>
            <declaration name="PLTE_TYPE" type="int" line="117"/>
            <declaration name="IDAT_TYPE" type="int" line="118"/>
            <declaration name="IEND_TYPE" type="int" line="119"/>
            <declaration name="bKGD_TYPE" type="int" line="122"/>
            <declaration name="cHRM_TYPE" type="int" line="123"/>
            <declaration name="gAMA_TYPE" type="int" line="124"/>
            <declaration name="hIST_TYPE" type="int" line="125"/>
            <declaration name="iCCP_TYPE" type="int" line="126"/>
            <declaration name="iTXt_TYPE" type="int" line="127"/>
            <declaration name="pHYs_TYPE" type="int" line="128"/>
            <declaration name="sBIT_TYPE" type="int" line="129"/>
            <declaration name="sPLT_TYPE" type="int" line="130"/>
            <declaration name="sRGB_TYPE" type="int" line="131"/>
            <declaration name="tEXt_TYPE" type="int" line="132"/>
            <declaration name="tIME_TYPE" type="int" line="133"/>
            <declaration name="tRNS_TYPE" type="int" line="134"/>
            <declaration name="zTXt_TYPE" type="int" line="135"/>
            <declaration name="PNG_COLOR_GRAY" type="int" line="137"/>
            <declaration name="PNG_COLOR_RGB" type="int" line="138"/>
            <declaration name="PNG_COLOR_PALETTE" type="int" line="139"/>
            <declaration name="PNG_COLOR_GRAY_ALPHA" type="int" line="140"/>
            <declaration name="PNG_COLOR_RGB_ALPHA" type="int" line="141"/>
            <declaration name="inputBandsForColorType" type="int[]" line="144"/>
            <declaration name="PNG_FILTER_NONE" type="int" line="154"/>
            <declaration name="PNG_FILTER_SUB" type="int" line="155"/>
            <declaration name="PNG_FILTER_UP" type="int" line="156"/>
            <declaration name="PNG_FILTER_AVERAGE" type="int" line="157"/>
            <declaration name="PNG_FILTER_PAETH" type="int" line="158"/>
            <declaration name="adam7XOffset" type="int[]" line="160"/>
            <declaration name="adam7YOffset" type="int[]" line="161"/>
            <declaration name="adam7XSubsampling" type="int[]" line="162"/>
            <declaration name="adam7YSubsampling" type="int[]" line="163"/>
            <declaration name="debug" type="boolean" line="165"/>
            <declaration name="stream" type="ImageInputStream" line="167"/>
            <declaration name="gotHeader" type="boolean" line="169"/>
            <declaration name="gotMetadata" type="boolean" line="170"/>
            <declaration name="lastParam" type="ImageReadParam" line="172"/>
            <declaration name="imageStartPosition" type="long" line="174"/>
            <declaration name="sourceRegion" type="Rectangle" line="176"/>
            <declaration name="sourceXSubsampling" type="int" line="177"/>
            <declaration name="sourceYSubsampling" type="int" line="178"/>
            <declaration name="sourceMinProgressivePass" type="int" line="179"/>
            <declaration name="sourceMaxProgressivePass" type="int" line="180"/>
            <declaration name="sourceBands" type="int[]" line="181"/>
            <declaration name="destinationBands" type="int[]" line="182"/>
            <declaration name="destinationOffset" type="Point" line="183"/>
            <declaration name="metadata" type="PNGMetadata" line="185"/>
            <declaration name="pixelStream" type="DataInputStream" line="187"/>
            <declaration name="theImage" type="BufferedImage" line="189"/>
            <declaration name="pixelsDone" type="int" line="192"/>
            <declaration name="totalPixels" type="int" line="195"/>
            <method name="PNGImageReader" type="constructor" line="197">
                <params>
                    <param name="originatingProvider" type="ImageReaderSpi"/>
                </params>
            </method>
            <method name="setInput" type="void" line="203">
                <params>
                    <param name="input" type="Object"/>
                    <param name="seekForwardOnly" type="boolean"/>
                    <param name="ignoreMetadata" type="boolean"/>
                </params>
                <comment line="206">
                    Always works                    
                </comment>
                <comment line="208">
                    Clear all values based on the previous stream contents                    
                </comment>
            </method>
            <method name="readNullTerminatedString" type="String" line="211">
                <params>
                    <param name="charset" type="String"/>
                    <param name="maxLen" type="int"/>
                </params>
                <declaration name="baos" type="ByteArrayOutputStream" line="212"/>
                <declaration name="b" type="int" line="213"/>
                <declaration name="count" type="int" line="214"/>
                <scope line="215"/>
            </method>
            <method name="readHeader" type="void" line="222">
                <comment line="260">
                    Re-use signature array to bulk-read these unsigned byte values                    
                </comment>
                <comment line="268">
                    Skip IHDR CRC                    
                </comment>
                <scope line="223"/>
                <scope line="226"/>
                <scope line="230">
                    <declaration name="signature" type="byte[]" line="231"/>
                    <scope line="241"/>
                    <declaration name="IHDR_length" type="int" line="245"/>
                    <scope line="246"/>
                    <declaration name="IHDR_type" type="int" line="249"/>
                    <scope line="250"/>
                    <declaration name="width" type="int" line="256"/>
                    <declaration name="height" type="int" line="257"/>
                    <declaration name="bitDepth" type="int" line="261"/>
                    <declaration name="colorType" type="int" line="262"/>
                    <declaration name="compressionMethod" type="int" line="263"/>
                    <declaration name="filterMethod" type="int" line="264"/>
                    <declaration name="interlaceMethod" type="int" line="265"/>
                    <scope line="272"/>
                    <scope line="275"/>
                    <scope line="279"/>
                    <scope line="283"/>
                    <scope line="286"/>
                    <scope line="292"/>
                    <scope line="295"/>
                    <scope line="298"/>
                    <scope line="301"/>
                </scope>
                <scope line="314"/>
            </method>
            <method name="parse_PLTE_chunk" type="void" line="319">
                <params>
                    <param name="chunkLength" type="int"/>
                </params>
                <comment line="348">
                    Round array sizes up to 2^2^n                    
                </comment>
                <scope line="320"/>
                <scope line="326"/>
                <declaration name="palette" type="byte[]" line="333"/>
                <declaration name="numEntries" type="int" line="336"/>
                <scope line="337">
                    <declaration name="maxEntries" type="int" line="338"/>
                    <scope line="339"/>
                </scope>
                <declaration name="paletteEntries" type="int" line="348"/>
                <scope line="349"/>
                <scope line="351"/>
                <scope line="353"/>
                <scope line="355"/>
                <declaration name="index" type="int" line="364"/>
                <scope line="365"/>
            </method>
            <method name="parse_bKGD_chunk" type="void" line="372">
                <comment line="381">
                    RGB or RGB_ALPHA                    
                </comment>
                <scope line="373"/>
                <scope line="377"/>
                <scope line="380"/>
            </method>
            <method name="parse_cHRM_chunk" type="void" line="390"/>
            <method name="parse_gAMA_chunk" type="void" line="403">
                <declaration name="gamma" type="int" line="404"/>
            </method>
            <method name="parse_hIST_chunk" type="void" line="412">
                <params>
                    <param name="chunkLength" type="int"/>
                </params>
                <comment line="418">
                    According to PNG specification length of
                     hIST chunk is specified in bytes and
                     hIST chunk consists of 2 byte elements
                     (so we expect length is even).                    
                </comment>
                <scope line="413"/>
            </method>
            <method name="parse_iCCP_chunk" type="void" line="429">
                <params>
                    <param name="chunkLength" type="int"/>
                </params>
                <declaration name="keyword" type="String" line="430"/>
                <declaration name="compressedProfile" type="byte[]" line="435"/>
            </method>
            <method name="parse_iTXt_chunk" type="void" line="443">
                <params>
                    <param name="chunkLength" type="int"/>
                </params>
                <comment line="470">
                    Decompress the text                    
                </comment>
                <declaration name="chunkStart" type="long" line="444"/>
                <declaration name="keyword" type="String" line="446"/>
                <declaration name="compressionFlag" type="int" line="449"/>
                <declaration name="compressionMethod" type="int" line="452"/>
                <declaration name="languageTag" type="String" line="455"/>
                <declaration name="pos" type="long" line="458"/>
                <declaration name="maxLen" type="int" line="459"/>
                <declaration name="translatedKeyword" type="String" line="460"/>
                <declaration name="text" type="String" line="464"/>
                <declaration name="b" type="byte[]" line="466"/>
                <scope line="469"/>
                <scope line="471"/>
            </method>
            <method name="parse_pHYs_chunk" type="void" line="477"/>
            <method name="parse_sBIT_chunk" type="void" line="485">
                <declaration name="colorType" type="int" line="486"/>
                <scope line="488"/>
                <scope line="492"/>
                <scope line="499"/>
            </method>
            <method name="parse_sPLT_chunk" type="void" line="508">
                <params>
                    <param name="chunkLength" type="int"/>
                </params>
                <declaration name="sampleDepth" type="int" line="512"/>
                <declaration name="numEntries" type="int" line="515"/>
                <scope line="522">
                    <scope line="523"/>
                </scope>
                <scope line="530">
                    <scope line="531"/>
                </scope>
                <scope line="538"/>
            </method>
            <method name="parse_sRGB_chunk" type="void" line="545"/>
            <method name="parse_tEXt_chunk" type="void" line="551">
                <params>
                    <param name="chunkLength" type="int"/>
                </params>
                <declaration name="keyword" type="String" line="552"/>
                <declaration name="b" type="byte[]" line="555"/>
            </method>
            <method name="parse_tIME_chunk" type="void" line="560"/>
            <method name="parse_tRNS_chunk" type="void" line="571">
                <params>
                    <param name="chunkLength" type="int"/>
                </params>
                <comment line="581">
                    Alpha table may have fewer entries than RGB palette                    
                </comment>
                <declaration name="colorType" type="int" line="572"/>
                <scope line="573">
                    <scope line="574"/>
                    <declaration name="maxEntries" type="int" line="581"/>
                    <declaration name="numEntries" type="int" line="582"/>
                    <scope line="583"/>
                </scope>
                <scope line="592">
                    <scope line="593"/>
                </scope>
                <scope line="601">
                    <scope line="602"/>
                </scope>
                <scope line="612"/>
            </method>
            <method name="inflate" type="byte[]" line="621">
                <params>
                    <param name="b" type="byte[]"/>
                </params>
                <declaration name="bais" type="InputStream" line="622"/>
                <declaration name="iis" type="InputStream" line="623"/>
                <declaration name="baos" type="ByteArrayOutputStream" line="624"/>
                <declaration name="c" type="int" line="626"/>
                <scope line="627">
                    <scope line="628"/>
                </scope>
                <scope line="631"/>
            </method>
            <method name="parse_zTXt_chunk" type="void" line="637">
                <params>
                    <param name="chunkLength" type="int"/>
                </params>
                <declaration name="keyword" type="String" line="638"/>
                <declaration name="method" type="int" line="641"/>
                <declaration name="b" type="byte[]" line="644"/>
            </method>
            <method name="readMetadata" type="void" line="649">
                <comment line="657">
                    Optimization: We can skip the remaining metadata if the
                     ignoreMetadata flag is set, and only if this is not a palette
                     image (in that case, we need to read the metadata to get the
                     tRNS chunk, which is needed for the getImageTypes() method).                    
                </comment>
                <comment line="671">
                    We&apos;ve reached the image data                    
                </comment>
                <comment line="676">
                    Skip the chunk plus the 4 CRC bytes that follow                    
                </comment>
                <comment line="695">
                    If chunk type is &apos;IDAT&apos;, we&apos;ve reached the image data.                    
                </comment>
                <comment line="745">
                    Read an unknown chunk                    
                </comment>
                <scope line="650"/>
                <declaration name="colorType" type="int" line="662"/>
                <scope line="663">
                    <scope line="664">
                        <scope line="665">
                            <declaration name="chunkLength" type="int" line="666"/>
                            <declaration name="chunkType" type="int" line="667"/>
                            <scope line="669"/>
                            <scope line="674"/>
                        </scope>
                    </scope>
                    <scope line="679"/>
                </scope>
                <scope line="687">
                    <scope line="688">
                        <declaration name="chunkLength" type="int" line="689"/>
                        <declaration name="chunkType" type="int" line="690"/>
                        <declaration name="b" type="byte[]" line="745"/>
                        <declaration name="chunkName" type="StringBuilder" line="748"/>
                        <declaration name="ancillaryBit" type="int" line="754"/>
                        <scope line="755"/>
                        <declaration name="chunkCRC" type="int" line="765"/>
                    </scope>
                </scope>
                <scope line="768"/>
            </method>
            <method name="decodeSubFilter" type="void" line="778">
                <params>
                    <param name="curr" type="byte[]"/>
                    <param name="coff" type="int"/>
                    <param name="count" type="int"/>
                    <param name="bpp" type="int"/>
                </params>
                <scope line="779">
                    <declaration name="val" type="int" line="780"/>
                </scope>
            </method>
            <method name="decodeUpFilter" type="void" line="791">
                <params>
                    <param name="curr" type="byte[]"/>
                    <param name="coff" type="int"/>
                    <param name="prev" type="byte[]"/>
                    <param name="poff" type="int"/>
                    <param name="count" type="int"/>
                </params>
                <scope line="792">
                    <declaration name="raw" type="int" line="793"/>
                    <declaration name="prior" type="int" line="794"/>
                </scope>
            </method>
            <method name="decodeAverageFilter" type="void" line="802">
                <params>
                    <param name="curr" type="byte[]"/>
                    <param name="coff" type="int"/>
                    <param name="prev" type="byte[]"/>
                    <param name="poff" type="int"/>
                    <param name="count" type="int"/>
                    <param name="bpp" type="int"/>
                </params>
                <declaration name="raw" type="int" line="803"/>
                <scope line="805"/>
                <scope line="812"/>
            </method>
            <method name="paethPredictor" type="int" line="821">
                <params>
                    <param name="a" type="int"/>
                    <param name="b" type="int"/>
                    <param name="c" type="int"/>
                </params>
                <declaration name="p" type="int" line="822"/>
                <declaration name="pa" type="int" line="823"/>
                <declaration name="pb" type="int" line="824"/>
                <declaration name="pc" type="int" line="825"/>
                <scope line="827"/>
                <scope line="829"/>
                <scope line="831"/>
            </method>
            <method name="decodePaethFilter" type="void" line="838">
                <params>
                    <param name="curr" type="byte[]"/>
                    <param name="coff" type="int"/>
                    <param name="prev" type="byte[]"/>
                    <param name="poff" type="int"/>
                    <param name="count" type="int"/>
                    <param name="bpp" type="int"/>
                </params>
                <declaration name="raw" type="int" line="839"/>
                <scope line="841"/>
                <scope line="848"/>
            </method>
            <declaration name="bandOffsets" type="int[][]" line="860"/>
            <method name="createRaster" type="WritableRaster" line="870">
                <params>
                    <param name="width" type="int"/>
                    <param name="height" type="int"/>
                    <param name="bands" type="int"/>
                    <param name="scanlineStride" type="int"/>
                    <param name="bitDepth" type="int"/>
                </params>
                <declaration name="dataBuffer" type="DataBuffer" line="872"/>
                <declaration name="ras" type="WritableRaster" line="873"/>
                <declaration name="origin" type="Point" line="874"/>
                <scope line="875"/>
                <scope line="881"/>
                <scope line="889"/>
            </method>
            <method name="skipPass" type="void" line="903">
                <params>
                    <param name="passWidth" type="int"/>
                    <param name="passHeight" type="int"/>
                </params>
                <comment line="912">
                    Read the image row-by-row                    
                </comment>
                <comment line="914">
                    Skip filter byte and the remaining row bytes                    
                </comment>
                <comment line="917">
                    If read has been aborted, just return
                     processReadAborted will be called later                    
                </comment>
                <scope line="904"/>
                <declaration name="inputBands" type="int" line="908"/>
                <declaration name="bytesPerRow" type="int" line="909"/>
                <scope line="912">
                    <scope line="918"/>
                </scope>
            </method>
            <method name="updateImageProgress" type="void" line="924">
                <params>
                    <param name="newPixels" type="int"/>
                </params>
            </method>
            <method name="decodePass" type="void" line="932">
                <params>
                    <param name="passNum" type="int"/>
                    <param name="xStart" type="int"/>
                    <param name="yStart" type="int"/>
                    <param name="xStep" type="int"/>
                    <param name="yStep" type="int"/>
                    <param name="passWidth" type="int"/>
                    <param name="passHeight" type="int"/>
                </params>
                <comment line="945">
                    Determine which pixels will be updated in this pass                    
                </comment>
                <comment line="970">
                    If no pixels need updating, just skip the input data                    
                </comment>
                <comment line="973">
                    Update count of pixels read                    
                </comment>
                <comment line="975">
                    Skip filter byte and the remaining row bytes                    
                </comment>
                <comment line="981">
                    Backwards map from destination pixels
                     (dstX = updateMinX + k*updateXStep)
                     to source pixels (sourceX), and then
                     to offset and skip in passRow (srcX and srcXStep)                    
                </comment>
                <comment line="990">
                    Compute the step factor in the source                    
                </comment>
                <comment line="998">
                    Create a 1-row tall Raster to hold the data                    
                </comment>
                <comment line="1003">
                    Create an array suitable for holding one pixel                    
                </comment>
                <comment line="1022">
                    Handle source and destination bands                    
                </comment>
                <comment line="1037">
                    Determine if all of the relevant output bands have the
                     same bit depth as the source data                    
                </comment>
                <comment line="1049">
                    If the bit depths differ, create a lookup table per band to perform
                     the conversion                    
                </comment>
                <comment line="1066">
                    Limit passRow to relevant area for the case where we
                     will can setRect to copy a contiguous span                    
                </comment>
                <comment line="1080">
                    Decode the (sub)image row-by-row                    
                </comment>
                <comment line="1082">
                    Update count of pixels read                    
                </comment>
                <comment line="1085">
                    Read the filter type byte and a row of data                    
                </comment>
                <comment line="1088">
                    Swap curr and prior                    
                </comment>
                <comment line="1095">
                    TODO - throw a more meaningful exception                    
                </comment>
                <comment line="1121">
                    Copy data into passRow byte by byte                    
                </comment>
                <comment line="1133">
                    True Y position in source                    
                </comment>
                <comment line="1175">
                    If read has been aborted, just return
                     processReadAborted will be called later                    
                </comment>
                <scope line="934"/>
                <declaration name="imRas" type="WritableRaster" line="938"/>
                <declaration name="dstMinX" type="int" line="939"/>
                <declaration name="dstMaxX" type="int" line="940"/>
                <declaration name="dstMinY" type="int" line="941"/>
                <declaration name="dstMaxY" type="int" line="942"/>
                <declaration name="vals" type="int[]" line="945"/>
                <declaration name="updateMinX" type="int" line="955"/>
                <declaration name="updateMinY" type="int" line="956"/>
                <declaration name="updateWidth" type="int" line="957"/>
                <declaration name="updateXStep" type="int" line="958"/>
                <declaration name="updateYStep" type="int" line="959"/>
                <declaration name="bitDepth" type="int" line="961"/>
                <declaration name="inputBands" type="int" line="962"/>
                <declaration name="bytesPerPixel" type="int" line="963"/>
                <declaration name="bytesPerRow" type="int" line="966"/>
                <declaration name="eltsPerRow" type="int" line="967"/>
                <scope line="970">
                    <scope line="971"/>
                </scope>
                <declaration name="sourceX" type="int" line="984"/>
                <declaration name="srcX" type="int" line="987"/>
                <declaration name="srcXStep" type="int" line="990"/>
                <declaration name="byteData" type="byte[]" line="992"/>
                <declaration name="shortData" type="short[]" line="993"/>
                <declaration name="curr" type="byte[]" line="994"/>
                <declaration name="prior" type="byte[]" line="995"/>
                <declaration name="passRow" type="WritableRaster" line="998"/>
                <declaration name="ps" type="int[]" line="1003"/>
                <declaration name="dataBuffer" type="DataBuffer" line="1005"/>
                <declaration name="type" type="int" line="1006"/>
                <scope line="1007"/>
                <scope line="1009"/>
                <scope line="1022"/>
                <scope line="1028"/>
                <declaration name="adjustBitDepths" type="boolean" line="1038"/>
                <declaration name="outputSampleSize" type="int[]" line="1039"/>
                <declaration name="numBands" type="int" line="1040"/>
                <scope line="1041">
                    <scope line="1042"/>
                </scope>
                <declaration name="scale" type="int[][]" line="1050"/>
                <scope line="1051">
                    <declaration name="maxInSample" type="int" line="1052"/>
                    <declaration name="halfMaxInSample" type="int" line="1053"/>
                    <scope line="1055">
                        <declaration name="maxOutSample" type="int" line="1056"/>
                        <scope line="1058"/>
                    </scope>
                </scope>
                <declaration name="useSetRect" type="boolean" line="1067"/>
                <scope line="1072"/>
                <scope line="1080">
                    <declaration name="filter" type="int" line="1085"/>
                    <scope line="1086">
                        <declaration name="tmp" type="byte[]" line="1088"/>
                    </scope>
                    <scope line="1093"/>
                    <scope line="1121"/>
                    <scope line="1123">
                        <declaration name="idx" type="int" line="1124"/>
                        <scope line="1125"/>
                    </scope>
                    <declaration name="sourceY" type="int" line="1133"/>
                    <scope line="1137">
                        <declaration name="dstY" type="int" line="1139"/>
                        <scope line="1141"/>
                        <scope line="1144"/>
                        <scope line="1148"/>
                        <scope line="1150">
                            <declaration name="newSrcX" type="int" line="1151"/>
                            <scope line="1155">
                                <scope line="1158">
                                    <scope line="1159"/>
                                </scope>
                            </scope>
                        </scope>
                        <scope line="1176"/>
                    </scope>
                </scope>
            </method>
            <method name="decodeImage" type="void" line="1186">
                <comment line="1220">
                    If read has been aborted, just return
                     processReadAborted will be called later                    
                </comment>
                <declaration name="width" type="int" line="1187"/>
                <declaration name="height" type="int" line="1188"/>
                <scope line="1195"/>
                <scope line="1197">
                    <scope line="1198">
                        <declaration name="XOffset" type="int" line="1199"/>
                        <declaration name="YOffset" type="int" line="1200"/>
                        <declaration name="XSubsampling" type="int" line="1201"/>
                        <declaration name="YSubsampling" type="int" line="1202"/>
                        <declaration name="xbump" type="int" line="1203"/>
                        <declaration name="ybump" type="int" line="1204"/>
                        <scope line="1206"/>
                        <scope line="1214"/>
                        <scope line="1221"/>
                    </scope>
                </scope>
            </method>
            <method name="readImage" type="void" line="1228">
                <params>
                    <param name="param" type="ImageReadParam"/>
                </params>
                <comment line="1235">
                    Init default values                    
                </comment>
                <comment line="1244">
                    If an ImageReadParam is available, get values from it                    
                </comment>
                <comment line="1265">
                    InflaterInputStream uses an Inflater instance which consumes
                     native (non-GC visible) resources. This is normally implicitly
                     freed when the stream is closed. However since the
                     InflaterInputStream wraps a client-supplied input stream,
                     we cannot close it.
                     But the app may depend on GC finalization to close the stream.
                     Therefore to ensure timely freeing of native resources we
                     explicitly create the Inflater instance and free its resources
                     when we are done with the InflaterInputStream by calling
                     inf.end();                    
                </comment>
                <comment line="1293">
                    At this point the header has been read and we know
                     how many bands are in the image, so perform checking
                     of the read param.                    
                </comment>
                <declaration name="width" type="int" line="1231"/>
                <declaration name="height" type="int" line="1232"/>
                <scope line="1244"/>
                <declaration name="inf" type="Inflater" line="1257"/>
                <scope line="1258">
                    <declaration name="e" type="Enumeration&lt;InputStream&gt;" line="1261"/>
                    <declaration name="is" type="InputStream" line="1262"/>
                    <declaration name="destRegion" type="Rectangle" line="1285"/>
                    <declaration name="colorType" type="int" line="1295"/>
                    <scope line="1302"/>
                    <scope line="1304"/>
                </scope>
                <scope line="1307"/>
                <scope line="1309">
                    <scope line="1310"/>
                </scope>
            </method>
            <method name="getNumImages" type="int" line="1316">
                <params>
                    <param name="allowSearch" type="boolean"/>
                </params>
                <scope line="1317"/>
                <scope line="1320"/>
            </method>
            <method name="getWidth" type="int" line="1327">
                <params>
                    <param name="imageIndex" type="int"/>
                </params>
                <scope line="1328"/>
            </method>
            <method name="getHeight" type="int" line="1337">
                <params>
                    <param name="imageIndex" type="int"/>
                </params>
                <scope line="1338"/>
            </method>
            <method name="getImageTypes" type="Iterator<ImageTypeSpecifier>" line="1349">
                <params>
                    <param name="imageIndex" type="int"/>
                </params>
                <comment line="1376">
                    Packed grayscale                    
                </comment>
                <comment line="1384">
                    some standard types of buffered images
                     which can be used as destination                    
                </comment>
                <comment line="1396">
                    Component R, G, B                    
                </comment>
                <comment line="1410">
                    Need tRNS chunk                    
                </comment>
                <comment line="1412">
                    The PLTE chunk spec says:
                    
                     The number of palette entries must not exceed the range that
                     can be represented in the image bit depth (for example, 2^4 = 16
                     for a bit depth of 4). It is permissible to have fewer entries
                     than the bit depth would allow. In that case, any out-of-range
                     pixel value found in the image data is an error.
                    
                     http:www.libpng.orgpubpngspec1.2PNG-Chunks.html#C.PLTE
                    
                     Consequently, the case when the palette length is smaller than
                     2^bitDepth is legal in the view of PNG spec.
                    
                     However the spec of createIndexed() method demands the exact
                     equality of the palette lengh and number of possible palette
                     entries (2^bitDepth).
                    
                     {@link javax.imageio.ImageTypeSpecifier.html#createIndexed}
                    
                     In order to avoid this contradiction we need to extend the
                     palette arrays to the limit defined by the bitDepth.                    
                </comment>
                <comment line="1457">
                    Alpha from tRNS chunk may have fewer entries than
                     the RGB LUTs from the PLTE chunk; if so, pad with
                     255.                    
                </comment>
                <comment line="1479">
                    Component G, A                    
                </comment>
                <comment line="1493">
                    some standard types of buffered images
                     wich can be used as destination                    
                </comment>
                <comment line="1502">
                    Component R, G, B, A (non-premultiplied)                    
                </comment>
                <scope line="1350"/>
                <declaration name="l" type="ArrayList&lt;ImageTypeSpecifier&gt;" line="1356"/>
                <declaration name="rgb" type="ColorSpace" line="1359"/>
                <declaration name="gray" type="ColorSpace" line="1360"/>
                <declaration name="bandOffsets" type="int[]" line="1361"/>
                <declaration name="bitDepth" type="int" line="1363"/>
                <declaration name="colorType" type="int" line="1364"/>
                <declaration name="dataType" type="int" line="1366"/>
                <scope line="1367"/>
                <scope line="1369"/>
                <scope line="1382"/>
                <declaration name="plength" type="int" line="1435"/>
                <declaration name="red" type="byte[]" line="1437"/>
                <declaration name="green" type="byte[]" line="1438"/>
                <declaration name="blue" type="byte[]" line="1439"/>
                <scope line="1441"/>
                <declaration name="alpha" type="byte[]" line="1459"/>
                <scope line="1460">
                    <scope line="1461"/>
                    <scope line="1463"/>
                </scope>
                <scope line="1491"/>
            </method>
            <method name="getRawImageType" type="ImageTypeSpecifier" line="1544">
                <params>
                    <param name="imageIndex" type="int"/>
                </params>
                <declaration name="types" type="Iterator&lt;ImageTypeSpecifier&gt;" line="1546"/>
                <declaration name="raw" type="ImageTypeSpecifier" line="1547"/>
                <scope line="1548"/>
            </method>
            <method name="getDefaultReadParam" type="ImageReadParam" line="1554"/>
            <method name="getStreamMetadata" type="IIOMetadata" line="1559"/>
            <method name="getImageMetadata" type="IIOMetadata" line="1563">
                <params>
                    <param name="imageIndex" type="int"/>
                </params>
                <scope line="1564"/>
            </method>
            <method name="read" type="BufferedImage" line="1572">
                <params>
                    <param name="imageIndex" type="int"/>
                    <param name="param" type="ImageReadParam"/>
                </params>
                <scope line="1573"/>
            </method>
            <method name="reset" type="void" line="1581"/>
            <method name="resetStreamSettings" type="void" line="1586"/>
        </class>
    </source>