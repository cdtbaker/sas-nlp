<?xml version="1.0" encoding="UTF-8"?>
    <source package="com.sun.beans">
        <import package="java.lang.reflect.Array"/>
        <import package="java.lang.reflect.GenericArrayType"/>
        <import package="java.lang.reflect.ParameterizedType"/>
        <import package="java.lang.reflect.Type"/>
        <import package="java.lang.reflect.TypeVariable"/>
        <import package="java.lang.reflect.WildcardType"/>
        <import package="java.util.HashMap"/>
        <import package="java.util.Map"/>
        <import package="sun.reflect.generics.reflectiveObjects.GenericArrayTypeImpl"/>
        <import package="sun.reflect.generics.reflectiveObjects.ParameterizedTypeImpl"/>
        <class name="TypeResolver" line="12">
            <javadoc line="12">
                This is utility class to resolve types.                
                <since>
                    1.7                    
                </since>
                <author>
                    Eamonn McManus                    
                </author>
                <author>
                    Sergey Malenkov                    
                </author>
            </javadoc>
            <javadoc line="19">
                Replaces the given {@code type} in an inherited method
                  with the actual type it has in the given {@code inClass}.
                  &lt;p&gt;Although type parameters are not inherited by subclasses in the Java
                  language, they &lt;em&gt;are&lt;/em&gt; effectively inherited when using reflection.
                  For example, if you declare an interface like this...&lt;/p&gt;
                  &lt;pre&gt;
                  public interface StringToIntMap extends Map&amp;lt;String,Integer&gt; {}
                  &lt;/pre&gt;
                  &lt;p&gt;...then StringToIntMap.class.getMethods() will show that it has methods
                  like put(K,V) even though StringToIntMap has no type parameters.  The K
                  and V variables are the ones declared by Map, so{@link TypeVariable#getGenericDeclaration()} will return Map.class.&lt;/p&gt;
                  &lt;p&gt;The purpose of this method is to take a Type from a possibly-inherited
                  method and replace it with the correct Type for the inheriting class.
                  So given parameters of K and StringToIntMap.class in the above example,
                  this method will return String.&lt;/p&gt;                
                <param>
                    inClass  the base class used to resolve                    
                </param>
                <param>
                    type     the type to resolve                    
                </param>
                <return>
                    a resolved type                    
                </return>
                <see>
                    #getActualType(Class)                    
                </see>
                <see>
                    #resolve(Type,Type)                    
                </see>
            </javadoc>
            <method name="resolveInClass" type="Type" line="41">
                <params>
                    <param name="inClass" type="Class&lt;?&gt;"/>
                    <param name="type" type="Type"/>
                </params>
            </method>
            <javadoc line="44">
                Replaces all {@code types} in the given array
                  with the actual types they have in the given {@code inClass}.                
                <param>
                    inClass  the base class used to resolve                    
                </param>
                <param>
                    types    the array of types to resolve                    
                </param>
                <return>
                    an array of resolved types                    
                </return>
                <see>
                    #getActualType(Class)                    
                </see>
                <see>
                    #resolve(Type,Type[])                    
                </see>
            </javadoc>
            <method name="resolveInClass" type="Type[]" line="53">
                <params>
                    <param name="inClass" type="Class&lt;?&gt;"/>
                    <param name="types" type="Type[]"/>
                </params>
            </method>
            <javadoc line="56">
                Replaces type variables of the given {@code formal} type
                  with the types they stand for in the given {@code actual} type.
                  &lt;p&gt;A ParameterizedType is a class with type parameters, and the values
                  of those parameters.  For example, Map&amp;lt;K,V&gt; is a generic class, and
                  a corresponding ParameterizedType might look like
                  Map&amp;lt;K=String,V=Integer&gt;.  Given such a ParameterizedType, this method
                  will replace K with String, or List&amp;lt;K&gt; with List&amp;ltString;, or
                  List&amp;lt;? super K&gt; with List&amp;lt;? super String&gt;.&lt;/p&gt;
                  &lt;p&gt;The {@code actual} argument to this method can also be a Class.
                  In this case, either it is equivalent to a ParameterizedType with
                  no parameters (for example, Integer.class), or it is equivalent to
                  a &quot;raw&quot; ParameterizedType (for example, Map.class).  In the latter
                  case, every type parameter declared or inherited by the class is replaced
                  by its &quot;erasure&quot;.  For a type parameter declared as &amp;lt;T&gt;, the erasure
                  is Object.  For a type parameter declared as &amp;lt;T extends Number&gt;,
                  the erasure is Number.&lt;/p&gt;
                  &lt;p&gt;Although type parameters are not inherited by subclasses in the Java
                  language, they &lt;em&gt;are&lt;/em&gt; effectively inherited when using reflection.
                  For example, if you declare an interface like this...&lt;/p&gt;
                  &lt;pre&gt;
                  public interface StringToIntMap extends Map&amp;lt;String,Integer&gt; {}
                  &lt;/pre&gt;
                  &lt;p&gt;...then StringToIntMap.class.getMethods() will show that it has methods
                  like put(K,V) even though StringToIntMap has no type parameters.  The K
                  and V variables are the ones declared by Map, so{@link TypeVariable#getGenericDeclaration()} will return {@link Map Map.class}.&lt;/p&gt;
                  &lt;p&gt;For this reason, this method replaces inherited type parameters too.
                  Therefore if this method is called with {@code actual} being
                  StringToIntMap.class and {@code formal} being the K from Map,
                  it will return {@link String String.class}.&lt;/p&gt;
                  &lt;p&gt;In the case where {@code actual} is a &quot;raw&quot; ParameterizedType, the
                  inherited type parameters will also be replaced by their erasures.
                  The erasure of a Class is the Class itself, so a &quot;raw&quot; subinterface of
                  StringToIntMap will still show the K from Map as String.class.  But
                  in a case like this...
                  &lt;pre&gt;
                  public interface StringToIntListMap extends Map&amp;lt;String,List&amp;lt;Integer&gt;&gt; {}
                  public interface RawStringToIntListMap extends StringToIntListMap {}
                  &lt;/pre&gt;
                  &lt;p&gt;...the V inherited from Map will show up as List&amp;lt;Integer&gt; in
                  StringToIntListMap, but as plain List in RawStringToIntListMap.&lt;/p&gt;                
                <param>
                    actual  the type that supplies bindings for type variables                    
                </param>
                <param>
                    formal  the type where occurrences of the variables
                      in {@code actual} will be replaced by the corresponding bound values                    
                </param>
                <return>
                    a resolved type                    
                </return>
                <see>
                    #TypeResolver(Type)                    
                </see>
                <see>
                    #resolve(Type)                    
                </see>
            </javadoc>
            <method name="resolve" type="Type" line="104">
                <params>
                    <param name="actual" type="Type"/>
                    <param name="formal" type="Type"/>
                </params>
            </method>
            <javadoc line="107">
                Replaces type variables of all formal types in the given array
                  with the types they stand for in the given {@code actual} type.                
                <param>
                    actual   the type that supplies bindings for type variables                    
                </param>
                <param>
                    formals  the array of types to resolve                    
                </param>
                <return>
                    an array of resolved types                    
                </return>
                <see>
                    #TypeResolver(Type)                    
                </see>
                <see>
                    #resolve(Type[])                    
                </see>
            </javadoc>
            <method name="resolve" type="Type[]" line="116">
                <params>
                    <param name="actual" type="Type"/>
                    <param name="formals" type="Type[]"/>
                </params>
            </method>
            <javadoc line="119">
                Converts the given {@code type} to the corresponding class.
                  This method implements the concept of type erasure,
                  that is described in section 4.6 of
                  &lt;cite&gt;The Java&amp;trade; Language Specification&lt;/cite&gt;.                
                <param>
                    type  the array of types to convert                    
                </param>
                <return>
                    a corresponding class                    
                </return>
            </javadoc>
            <method name="erase" type="Class&lt;?&gt;" line="127">
                <params>
                    <param name="type" type="Type"/>
                </params>
                <scope line="128"/>
                <scope line="131">
                    <declaration name="pt" type="ParameterizedType" line="132"/>
                </scope>
                <scope line="135">
                    <declaration name="tv" type="TypeVariable" line="136"/>
                    <declaration name="bounds" type="Type[]" line="137"/>
                </scope>
                <scope line="140">
                    <declaration name="wt" type="WildcardType" line="141"/>
                    <declaration name="bounds" type="Type[]" line="142"/>
                </scope>
                <scope line="145">
                    <declaration name="gat" type="GenericArrayType" line="146"/>
                </scope>
            </method>
            <javadoc line="151">
                Converts all {@code types} in the given array
                  to the corresponding classes.                
                <param>
                    types  the array of types to convert                    
                </param>
                <return>
                    an array of corresponding classes                    
                </return>
                <see>
                    #erase(Type)                    
                </see>
            </javadoc>
            <method name="erase" type="Class[]" line="158">
                <params>
                    <param name="types" type="Type[]"/>
                </params>
                <declaration name="length" type="int" line="159"/>
                <declaration name="classes" type="Class[]" line="160"/>
                <scope line="161"/>
            </method>
            <declaration name="map" type="Map&amp;lt;TypeVariable&amp;lt;?&amp;gt;,Type&amp;gt;" line="166"/>
            <javadoc line="167">
                Constructs the type resolver for the given actual type.                
                <param>
                    actual  the type that supplies bindings for type variables                    
                </param>
                <see>
                    #prepare(Type)                    
                </see>
            </javadoc>
            <method name="TypeResolver" type="constructor" line="172">
                <params>
                    <param name="actual" type="Type"/>
                </params>
            </method>
            <javadoc line="175">
                Fills the map from type parameters
                  to types as seen by the given {@code type}.
                  The method is recursive because the {@code type}inherits mappings from its parent classes and interfaces.
                  The {@code type} can be either a {@link Class Class}or a {@link ParameterizedType ParameterizedType}.
                  If it is a {@link Class Class}, it is either equivalent
                  to a {@link ParameterizedType ParameterizedType} with no parameters,
                  or it represents the erasure of a {@link ParameterizedType ParameterizedType}.                
                <param>
                    type  the next type in the hierarchy                    
                </param>
            </javadoc>
            <method name="prepare" type="void" line="185">
                <params>
                    <param name="type" type="Type"/>
                </params>
            </method>
            <javadoc line="206">
                Replaces the given {@code formal} type
                  with the type it stand for in this type resolver.                
                <param>
                    formal  the array of types to resolve                    
                </param>
                <return>
                    a resolved type                    
                </return>
            </javadoc>
            <method name="resolve" type="Type" line="212">
                <params>
                    <param name="formal" type="Type"/>
                </params>
                <scope line="213"/>
                <scope line="216">
                    <declaration name="comp" type="Type" line="217"/>
                </scope>
                <scope line="221">
                    <declaration name="fpt" type="ParameterizedType" line="222"/>
                    <declaration name="actuals" type="Type[]" line="223"/>
                </scope>
                <scope line="226">
                    <declaration name="fwt" type="WildcardType" line="227"/>
                    <declaration name="upper" type="Type[]" line="228"/>
                    <declaration name="lower" type="Type[]" line="229"/>
                </scope>
                <scope line="232"/>
                <declaration name="actual" type="Type" line="235"/>
                <scope line="236"/>
            </method>
            <javadoc line="242">
                Replaces all formal types in the given array
                  with the types they stand for in this type resolver.                
                <param>
                    formals  the array of types to resolve                    
                </param>
                <return>
                    an array of resolved types                    
                </return>
                <see>
                    #resolve(Type)                    
                </see>
            </javadoc>
            <method name="resolve" type="Type[]" line="249">
                <params>
                    <param name="formals" type="Type[]"/>
                </params>
                <declaration name="length" type="int" line="250"/>
                <declaration name="actuals" type="Type[]" line="251"/>
                <scope line="252"/>
            </method>
            <javadoc line="257">
                Replaces a {@link GenericArrayType GenericArrayType}with plain array class where it is possible.
                  Bug &lt;a href=&quot;http://bugs.sun.com/view_bug.do?bug_id=5041784&quot;&gt;5041784&lt;/a&gt;
                  is that arrays of non-generic type sometimes show up
                  as {@link GenericArrayType GenericArrayType} when using reflection.
                  For example, a {@code String[]} might show up
                  as a {@link GenericArrayType GenericArrayType}where {@link GenericArrayType#getGenericComponentType getGenericComponentType}is {@code String.class}.  This violates the specification,
                  which says that {@link GenericArrayType GenericArrayType}is used when the component type is a type variable or parameterized type.
                  We fit the specification here.                
                <param>
                    type  the type to fix                    
                </param>
                <return>
                    a corresponding type for the generic array type,
                      or the same type as {@code type}                    
                </return>
            </javadoc>
            <method name="fixGenericArray" type="Type" line="270">
                <params>
                    <param name="type" type="Type"/>
                </params>
                <scope line="271">
                    <declaration name="comp" type="Type" line="272"/>
                    <scope line="274"/>
                </scope>
            </method>
            <javadoc line="280">
                Replaces a {@link Class Class} with type parameters
                  with a {@link ParameterizedType ParameterizedType}where every parameter is bound to itself.
                  When calling {@link #resolveInClass} in the context of {@code inClass},
                  we can&apos;t just pass {@code inClass} as the {@code actual} parameter,
                  because if {@code inClass} has type parameters
                  that would be interpreted as accessing the raw type,
                  so we would get unwanted erasure.
                  This is why we bind each parameter to itself.
                  If {@code inClass} does have type parameters and has methods
                  where those parameters appear in the return type or argument types,
                  we will correctly leave those types alone.                
                <param>
                    inClass  the base class used to resolve                    
                </param>
                <return>
                    a parameterized type for the class,
                      or the same class as {@code inClass}                    
                </return>
            </javadoc>
            <method name="getActualType" type="Type" line="296">
                <params>
                    <param name="inClass" type="Class&lt;?&gt;"/>
                </params>
                <declaration name="params" type="Type[]" line="297"/>
            </method>
        </class>
    </source>