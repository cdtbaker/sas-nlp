<?xml version="1.0" encoding="UTF-8"?>
    <source package="com.sun.java.util.jar.pack">
        <import package="com.sun.java.util.jar.pack.Package.Class"/>
        <import package="java.lang.reflect.Modifier"/>
        <import package="java.util.Arrays"/>
        <import package="java.util.Collection"/>
        <import package="com.sun.java.util.jar.pack.Constants"/>
        <class name="Code" line="34">
            <extends class="Attribute.Holder"/>
            <comment line="62">
                The following fields are used directly by the ClassReader, etc.                
            </comment>
            <comment line="72">
                reference relocations, if any are required                
            </comment>
            <comment line="73">
                array of instruction boundaries                
            </comment>
            <comment line="170">
                Since bytecodes are the single largest contributor to                
            </comment>
            <comment line="171">
                package size, it&apos;s worth a little bit of trouble                
            </comment>
            <comment line="172">
                to reduce the per-bytecode memory footprint.                
            </comment>
            <comment line="173">
                In the current scheme, half of the bulk of these arrays                
            </comment>
            <comment line="174">
                due to bytes, and half to shorts.  (Ints are insignificant.)                
            </comment>
            <comment line="175">
                Given an average of 1.8 bytes per instruction, this means                
            </comment>
            <comment line="176">
                instruction boundary arrays are about a 75% overhead--tolerable.                
            </comment>
            <comment line="177">
                (By using bytes, we get 33% savings over just shorts and ints.                
            </comment>
            <comment line="178">
                Using both bytes and shorts gives 66% savings over just ints.)                
            </comment>
            <comment line="350">
                / Fetching values from my own array.                
            </comment>
            <comment line="358">
                TEST CODE ONLY
                private boolean assertBCICodingsOK() {
                boolean ok = true;
                int len = java.lang.reflect.Array.getLength(insnMap);
                int base = 0;
                if (insnMap.getClass().getComponentType() == Byte.TYPE)
                base = Byte.MIN_VALUE;
                if (insnMap.getClass().getComponentType() == Short.TYPE)
                base = Short.MIN_VALUE;
                for (int i = -1, imax = getLength()+1; i &lt;= imax; i++) {
                int bci = i;
                int enc = Math.min(-999, bci-1);
                int dec = enc;
                try {
                enc = encodeBCI(bci);
                dec = decodeBCI(enc);
                } catch (RuntimeException ee) {
                ee.printStackTrace();
                }
                if (dec == bci) {
                System.out.println(&quot;BCI=&quot;+bci+(enc&lt;len?&quot;&quot;:&quot;   &quot;)+&quot; enc=&quot;+enc);
                continue;
                }
                if (ok) {
                for (int q = 0; q &lt;= 1; q++) {
                StringBuffer sb = new StringBuffer();
                sb.append(&quot;bci &quot;+(q==0?&quot;map&quot;:&quot;del&quot;)+&quot;[&quot;+len+&quot;] = {&quot;);
                for (int j = 0; j &lt; len; j++) {
                int mapi = ((Number)java.lang.reflect.Array.get(insnMap, j)).intValue() - base;
                mapi -= jq;
                sb.append(&quot; &quot;+mapi);
                }
                sb.append(&quot; }&quot;);
                System.out.println(&quot; &quot;+sb);
                }
                }
                System.out.println(&quot; BCI=&quot;+bci+&quot; enc=&quot;+enc+&quot; dec=&quot;+dec);
                ok = false;
                }
                return ok;
                }                
            </comment>
            <javadoc line="34">
                Represents a chunk of bytecodes.                
                <author>
                    John Rose                    
                </author>
            </javadoc>
            <declaration name="m" type="Class.Method" line="39"/>
            <method name="Code" type="constructor" line="41">
                <params>
                    <param name="m" type="Class.Method"/>
                </params>
            </method>
            <method name="getMethod" type="Class.Method" line="45"/>
            <method name="thisClass" type="Class" line="48"/>
            <method name="getPackage" type="Package" line="51"/>
            <method name="getCPMap" type="ConstantPool.Entry[]" line="55"/>
            <declaration name="noRefs" type="ConstantPool.Entry[]" line="59"/>
            <declaration name="max_stack" type="int" line="62"/>
            <declaration name="max_locals" type="int" line="63"/>
            <declaration name="handler_class" type="ConstantPool.Entry" line="65"/>
            <declaration name="handler_start" type="int" line="66"/>
            <declaration name="handler_end" type="int" line="67"/>
            <declaration name="handler_catch" type="int" line="68"/>
            <declaration name="bytes" type="byte[]" line="70"/>
            <declaration name="fixups" type="Fixups" line="71"/>
            <declaration name="insnMap" type="Object" line="72"/>
            <method name="getLength" type="int" line="74"/>
            <method name="getMaxStack" type="int" line="76"/>
            <method name="setMaxStack" type="void" line="79">
                <params>
                    <param name="ms" type="int"/>
                </params>
            </method>
            <method name="getMaxNALocals" type="int" line="83">
                <declaration name="argsize" type="int" line="84"/>
            </method>
            <method name="setMaxNALocals" type="void" line="87">
                <params>
                    <param name="ml" type="int"/>
                </params>
                <declaration name="argsize" type="int" line="88"/>
            </method>
            <method name="getHandlerCount" type="int" line="92"/>
            <method name="setHandlerCount" type="void" line="98">
                <params>
                    <param name="h" type="int"/>
                </params>
                <comment line="104">
                    caller must fill these in ASAP                    
                </comment>
                <scope line="99"/>
            </method>
            <method name="setBytes" type="void" line="108">
                <params>
                    <param name="bytes" type="byte[]"/>
                </params>
            </method>
            <method name="setInstructionMap" type="void" line="114">
                <params>
                    <param name="insnMap" type="int[]"/>
                    <param name="mapLen" type="int"/>
                </params>
                <comment line="115">
                    int[] oldMap = null;                    
                </comment>
                <comment line="116">
                    assert((oldMap = getInstructionMap()) != null);                    
                </comment>
                <comment line="118">
                    assert(Arrays.equals(oldMap, getInstructionMap()));                    
                </comment>
            </method>
            <method name="setInstructionMap" type="void" line="120">
                <params>
                    <param name="insnMap" type="int[]"/>
                </params>
            </method>
            <method name="getInstructionMap" type="int[]" line="124"/>
            <method name="addFixups" type="void" line="128">
                <params>
                    <param name="moreFixups" type="Collection"/>
                </params>
                <scope line="129"/>
            </method>
            <method name="trimToSize" type="void" line="136">
                <scope line="137"/>
            </method>
            <method name="visitRefs" type="void" line="145">
                <params>
                    <param name="mode" type="int"/>
                    <param name="refs" type="Collection<ConstantPool.Entry>"/>
                </params>
                <comment line="154">
                    References (to a local cpMap) are embedded in the bytes.                    
                </comment>
                <comment line="165">
                    Handle attribute list:                    
                </comment>
                <declaration name="verbose" type="int" line="146"/>
                <declaration name="cls" type="Class" line="149"/>
                <scope line="151"/>
                <scope line="153">
                    <declaration name="cpMap" type="ConstantPool.Entry[]" line="155"/>
                    <scope line="156">
                        <declaration name="cpref" type="int" line="159"/>
                        <scope line="160"/>
                    </scope>
                </scope>
            </method>
            <declaration name="shrinkMaps" type="boolean" line="178"/>
            <method name="allocateInstructionMap" type="Object" line="180">
                <params>
                    <param name="insnMap" type="int[]"/>
                    <param name="mapLen" type="int"/>
                </params>
                <declaration name="PClimit" type="int" line="181"/>
                <scope line="182">
                    <declaration name="map" type="byte[]" line="183"/>
                    <scope line="184"/>
                </scope>
                <scope line="189">
                    <declaration name="map" type="short[]" line="190"/>
                    <scope line="191"/>
                </scope>
                <scope line="196">
                    <declaration name="map" type="int[]" line="197"/>
                </scope>
            </method>
            <method name="expandInstructionMap" type="int[]" line="202">
                <params>
                    <param name="map0" type="Object"/>
                </params>
                <declaration name="imap" type="int[]" line="203"/>
                <scope line="204">
                    <declaration name="map" type="byte[]" line="205"/>
                    <scope line="207"/>
                </scope>
                <scope line="210">
                    <declaration name="map" type="short[]" line="211"/>
                    <scope line="213"/>
                </scope>
                <scope line="216">
                    <declaration name="map" type="int[]" line="217"/>
                </scope>
            </method>
            <method name="getInsnMap" type="Object" line="223">
                <comment line="224">
                    Build a map of instruction boundaries.                    
                </comment>
                <comment line="233">
                    Make it byte[], short[], or int[] according to the max BCI.                    
                </comment>
                <comment line="235">
                    assert(assertBCICodingsOK());                    
                </comment>
                <scope line="225"/>
                <declaration name="map" type="int[]" line="228"/>
                <declaration name="fillp" type="int" line="229"/>
                <scope line="230"/>
            </method>
            <javadoc line="239">
                Encode the given BCI as an instruction boundary number.
                  For completeness, irregular (non-boundary) BCIs are
                  encoded compactly immediately after the boundary numbers.
                  This encoding is the identity mapping outside 0..length,
                  and it is 1-1 everywhere.  All by itself this technique
                  improved zipped rt.jar compression by 2.6%.                
            </javadoc>
            <method name="encodeBCI" type="int" line="246">
                <params>
                    <param name="bci" type="int"/>
                </params>
                <declaration name="map0" type="Object" line="248"/>
                <declaration name="i" type="int" line="249"/>
                <scope line="250">
                    <declaration name="map" type="byte[]" line="251"/>
                </scope>
                <scope line="254">
                    <declaration name="map" type="short[]" line="255"/>
                </scope>
                <scope line="258">
                    <declaration name="map" type="int[]" line="259"/>
                </scope>
            </method>
            <method name="decodeBCI" type="int" line="269">
                <params>
                    <param name="bciCode" type="int"/>
                </params>
                <comment line="273">
                    len == map.length                    
                </comment>
                <comment line="274">
                    If bciCode &lt; len, result is map[bciCode], the common and fast case.                    
                </comment>
                <comment line="275">
                    Otherwise, let map[i] be the smallest map[*] larger than bci.                    
                </comment>
                <comment line="276">
                    Then, required by the return statement of encodeBCI:                    
                </comment>
                <comment line="277">
                    bciCode == len + bci - i                    
                </comment>
                <comment line="278">
                    Thus:                    
                </comment>
                <comment line="279">
                    bci-i == bciCode-len                    
                </comment>
                <comment line="280">
                    map[i]-adj-i == bciCode-len ; adj in (0..map[i]-map[i-1])                    
                </comment>
                <comment line="281">
                    We can solve this by searching for adjacent entries                    
                </comment>
                <comment line="282">
                    map[i-1], map[i] such that:                    
                </comment>
                <comment line="283">
                    map[i-1]-(i-1) &lt;= bciCode-len &lt; map[i]-i                    
                </comment>
                <comment line="284">
                    This can be approximated by searching map[i] for bciCode and then                    
                </comment>
                <comment line="285">
                    linear searching backward.  Given the right i, we then have:                    
                </comment>
                <comment line="286">
                    bci == bciCode-len + i                    
                </comment>
                <comment line="287">
                    This linear search is at its worst case for indexes in the beginning                    
                </comment>
                <comment line="288">
                    of a large method, but it&apos;s not clear that this is a problem in                    
                </comment>
                <comment line="289">
                    practice, since BCIs are usually on instruction boundaries.                    
                </comment>
                <declaration name="map0" type="Object" line="271"/>
                <declaration name="i" type="int" line="272"/>
                <scope line="290">
                    <declaration name="map" type="byte[]" line="291"/>
                    <declaration name="key" type="int" line="297"/>
                    <scope line="298"/>
                </scope>
                <scope line="301">
                    <declaration name="map" type="short[]" line="302"/>
                    <declaration name="key" type="int" line="308"/>
                    <scope line="309"/>
                </scope>
                <scope line="312">
                    <declaration name="map" type="int[]" line="313"/>
                    <declaration name="key" type="int" line="319"/>
                    <scope line="320"/>
                </scope>
            </method>
            <method name="finishRefs" type="void" line="327">
                <params>
                    <param name="ix" type="ConstantPool.Index"/>
                </params>
                <comment line="332">
                    Code attributes are finished in ClassWriter.writeAttributes.                    
                </comment>
                <scope line="328"/>
            </method>
            <method name="instructionAt" type="Instruction" line="335">
                <params>
                    <param name="pc" type="int"/>
                </params>
            </method>
            <method name="flagsRequireCode" type="boolean" line="339">
                <params>
                    <param name="flags" type="int"/>
                </params>
                <comment line="340">
                    A method&apos;s flags force it to have a Code attribute,                    
                </comment>
                <comment line="341">
                    if the flags are neither native nor abstract.                    
                </comment>
            </method>
            <method name="toString" type="String" line="345"/>
            <method name="getInt" type="int" line="350">
                <params>
                    <param name="pc" type="int"/>
                </params>
            </method>
            <method name="getShort" type="int" line="351">
                <params>
                    <param name="pc" type="int"/>
                </params>
            </method>
            <method name="getByte" type="int" line="352">
                <params>
                    <param name="pc" type="int"/>
                </params>
            </method>
            <method name="setInt" type="void" line="353">
                <params>
                    <param name="pc" type="int"/>
                    <param name="x" type="int"/>
                </params>
            </method>
            <method name="setShort" type="void" line="354">
                <params>
                    <param name="pc" type="int"/>
                    <param name="x" type="int"/>
                </params>
            </method>
            <method name="setByte" type="void" line="355">
                <params>
                    <param name="pc" type="int"/>
                    <param name="x" type="int"/>
                </params>
            </method>
        </class>
    </source>