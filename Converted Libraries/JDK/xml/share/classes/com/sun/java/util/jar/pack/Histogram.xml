<?xml version="1.0" encoding="UTF-8"?>
    <source package="com.sun.java.util.jar.pack">
        <import package="java.io.IOException"/>
        <import package="java.io.InputStream"/>
        <import package="java.io.PrintStream"/>
        <import package="java.util.Arrays"/>
        <class name="Histogram" line="33">
            <comment line="39">
                Compact histogram representation:  4 bytes per distinct value,                
            </comment>
            <comment line="40">
                plus 5 words per distinct count.                
            </comment>
            <comment line="41">
                multi-row matrix {{counti,valueij...}}                
            </comment>
            <comment line="42">
                sum of all counts                
            </comment>
            <comment line="44">
                These are created eagerly also, since that saves work.                
            </comment>
            <comment line="45">
                They cost another 8 bytes per distinct value.                
            </comment>
            <comment line="46">
                unique values, sorted by value                
            </comment>
            <comment line="47">
                counts, same order as values                
            </comment>
            <comment line="378">
                public static
                int[][] makeHistogramMatrix(int[] values) {
                 Make sure they are sorted.
                values = maybeSort(values);
                long[] hist2col = computeHistogram2Col(values);
                int[][] matrix = makeMatrix(hist2col);
                return matrix;
                }                
            </comment>
            <comment line="614">
                / Debug stuff follows.                
            </comment>
            <comment line="664">
                public static
                int[] readValuesFrom(InputStream instr) {
                return readValuesFrom(new InputStreamReader(instr));
                }
                public static
                int[] readValuesFrom(Reader inrdr) {
                inrdr = new BufferedReader(inrdr);
                final StreamTokenizer in = new StreamTokenizer(inrdr);
                final int TT_NOTHING = -99;
                in.commentChar(&apos;#&apos;);
                return readValuesFrom(new Iterator() {
                int token = TT_NOTHING;
                private int getToken() {
                if (token == TT_NOTHING) {
                try {
                token = in.nextToken();
                assert(token != TT_NOTHING);
                } catch (IOException ee) {
                throw new RuntimeException(ee);
                }
                }
                return token;
                }
                public boolean hasNext() {
                return getToken() != StreamTokenizer.TT_EOF;
                }
                public Object next() {
                int ntok = getToken();
                token = TT_NOTHING;
                switch (ntok) {
                case StreamTokenizer.TT_EOF:
                throw new NoSuchElementException();
                case StreamTokenizer.TT_NUMBER:
                return new Integer((int) in.nval);
                default:
                assert(false);
                return null;
                }
                }
                public void remove() {
                throw new UnsupportedOperationException();
                }
                });
                }
                public static
                int[] readValuesFrom(Iterator iter) {
                return readValuesFrom(iter, 0);
                }
                public static
                int[] readValuesFrom(Iterator iter, int initSize) {
                int[] na = new int[Math.max(10, initSize)];
                int np = 0;
                while (iter.hasNext()) {
                Integer val = (Integer) iter.next();
                if (np == na.length) {
                int[] na2 = new int[np2];
                System.arraycopy(na, 0, na2, 0, np);
                na = na2;
                }
                na[np++] = val.intValue();
                }
                if (np != na.length) {
                int[] na2 = new int[np];
                System.arraycopy(na, 0, na2, 0, np);
                na = na2;
                }
                return na;
                }
                
                public static
                Histogram makeByteHistogram(byte[] bytes) {
                try {
                return makeByteHistogram(new ByteArrayInputStream(bytes));
                } catch (IOException ee) {
                throw new RuntimeException(ee);
                }
                }
                
                public static
                void main(String[] av) throws IOException {
                if (av.length &gt; 0 &amp;&amp; av[0].equals(&quot;-r&quot;)) {
                int[] values = new int[Integer.parseInt(av[1])];
                int limit = values.length;
                if (av.length &gt;= 3) {
                limit  = (int)( limit  Double.parseDouble(av[2]) );
                }
                Random rnd = new Random();
                for (int i = 0; i &lt; values.length; i++) {
                values[i] = rnd.nextInt(limit);;
                }
                Histogram rh = new Histogram(values);
                rh.print(&quot;random&quot;, System.out);
                return;
                }
                if (av.length &gt; 0 &amp;&amp; av[0].equals(&quot;-s&quot;)) {
                int[] values = readValuesFrom(System.in);
                Random rnd = new Random();
                for (int i = values.length; --i &gt; 0; ) {
                int j = rnd.nextInt(i+1);
                if (j &lt; i) {
                int tem = values[i];
                values[i] = values[j];
                values[j] = tem;
                }
                }
                for (int i = 0; i &lt; values.length; i++)
                System.out.println(values[i]);
                return;
                }
                if (av.length &gt; 0 &amp;&amp; av[0].equals(&quot;-e&quot;)) {
                 edge cases
                new Histogram(new int[][] {
                {1, 11, 111},
                {0, 123, 456},
                {1, 111, 1111},
                {0, 456, 123},
                {3},
                {},
                {3},
                {2, 22},
                {4}
                }).print(System.out);
                return;
                }
                if (av.length &gt; 0 &amp;&amp; av[0].equals(&quot;-b&quot;)) {
                 edge cases
                Histogram bh = makeByteHistogram(System.in);
                bh.print(&quot;bytes&quot;, System.out);
                return;
                }
                boolean regroup = false;
                if (av.length &gt; 0 &amp;&amp; av[0].equals(&quot;-g&quot;)) {
                regroup = true;
                }
                
                int[] values = readValuesFrom(System.in);
                Histogram h = new Histogram(values);
                if (!regroup)
                h.print(System.out);
                if (regroup) {
                int[] groups = new int[12];
                for (int i = 0; i &lt; groups.length; i++) {
                groups[i] = 1&lt;&lt;i;
                }
                int[][] gm = regroupHistogram(h.getMatrix(), groups);
                Histogram g = new Histogram(gm);
                System.out.println(&quot;h.getBitLength(g) = &quot;+
                h.getBitLength(g.getBitMetric()));
                System.out.println(&quot;g.getBitLength(h) = &quot;+
                g.getBitLength(h.getBitMetric()));
                g.print(&quot;regrouped&quot;, System.out);
                }
                }                
            </comment>
            <javadoc line="33">
                Histogram derived from an integer array of events (int[]).                
                <author>
                    John Rose                    
                </author>
            </javadoc>
            <declaration name="matrix" type="int[][]" line="40"/>
            <declaration name="totalWeight" type="int" line="41"/>
            <declaration name="values" type="int[]" line="45"/>
            <declaration name="counts" type="int[]" line="46"/>
            <declaration name="LOW32" type="long" line="48"/>
            <javadoc line="50">
                Build a histogram given a sequence of values.
                  To save work, the input should be sorted, but need not be.                
            </javadoc>
            <method name="Histogram" type="constructor" line="54">
                <params>
                    <param name="valueSequence" type="int[]"/>
                </params>
                <declaration name="hist2col" type="long[]" line="55"/>
                <declaration name="table" type="int[][]" line="56"/>
            </method>
            <method name="Histogram" type="constructor" line="64">
                <params>
                    <param name="valueSequence" type="int[]"/>
                    <param name="start" type="int"/>
                    <param name="end" type="int"/>
                </params>
            </method>
            <javadoc line="68">
                Build a histogram given a compact matrix of counts and values.                
            </javadoc>
            <method name="Histogram" type="constructor" line="70">
                <params>
                    <param name="matrix" type="int[][]"/>
                </params>
                <comment line="71">
                    sort the rows                    
                </comment>
                <comment line="72">
                    clone and sort                    
                </comment>
                <comment line="86">
                    sort key is value, so put it in the high 32!                    
                </comment>
                <comment line="94">
                    backwards                    
                </comment>
                <comment line="95">
                    backwards                    
                </comment>
                <declaration name="length" type="int" line="74"/>
                <declaration name="weight" type="int" line="75"/>
                <scope line="76">
                    <declaration name="rowLength" type="int" line="77"/>
                </scope>
                <declaration name="hist2col" type="long[]" line="82"/>
                <declaration name="fillp" type="int" line="83"/>
                <scope line="84">
                    <scope line="85"/>
                </scope>
                <declaration name="table" type="int[][]" line="93"/>
            </method>
            <javadoc line="99">
                Histogram of int values, reported compactly as a ragged matrix,
                  indexed by descending frequency rank.
                  &lt;p&gt;
                  Format of matrix:
                  Each row in the matrix begins with an occurrence count,
                  and continues with all int values that occur at that frequency.
                  &lt;pre&gt;
                  int[][] matrix = {
                  { count1, value11, value12, value13, ...  },
                  { count2, value21, value22, ... },
                  ...
                  }
                  &lt;/pre&gt;
                  The first column of the matrix { count1, count2, ... }
                  is sorted in descending order, and contains no duplicates.
                  Each row of the matrix (apart from its first element)
                  is sorted in ascending order, and contains no duplicates.
                  That is, each sequence { valuei1, valuei2, ... } is sorted.                
            </javadoc>
            <method name="getMatrix" type="int[][]" line="119"/>
            <method name="getRowCount" type="int" line="122"/>
            <method name="getRowFrequency" type="int" line="125">
                <params>
                    <param name="rn" type="int"/>
                </params>
            </method>
            <method name="getRowLength" type="int" line="128">
                <params>
                    <param name="rn" type="int"/>
                </params>
            </method>
            <method name="getRowValue" type="int" line="131">
                <params>
                    <param name="rn" type="int"/>
                    <param name="vn" type="int"/>
                </params>
            </method>
            <method name="getRowWeight" type="int" line="134">
                <params>
                    <param name="rn" type="int"/>
                </params>
            </method>
            <method name="getTotalWeight" type="int" line="139"/>
            <method name="getTotalLength" type="int" line="144"/>
            <javadoc line="148">
                Returns an array of all values, sorted.                
            </javadoc>
            <method name="getAllValues" type="int[]" line="150"/>
            <javadoc line="155">
                Returns an array parallel with {@link #getValues},
                  with a frequency for each value.                
            </javadoc>
            <method name="getAllFrequencies" type="int[]" line="159"/>
            <declaration name="log2" type="double" line="163"/>
            <method name="getFrequency" type="int" line="166">
                <params>
                    <param name="value" type="int"/>
                </params>
                <declaration name="pos" type="int" line="167"/>
            </method>
            <method name="getBitLength" type="double" line="174">
                <params>
                    <param name="value" type="int"/>
                </params>
                <declaration name="prob" type="double" line="175"/>
            </method>
            <method name="getRowBitLength" type="double" line="180">
                <params>
                    <param name="rn" type="int"/>
                </params>
                <declaration name="prob" type="double" line="181"/>
            </method>
            <interface name="BitMetric">
                <method name="getBitLength" type="double" line="187"/>
            </interface>
            <declaration name="bitMetric" type="BitMetric" line="189"/>
            <anonymous_class line="189">
                <method name="getBitLength" type="double" line="190">
                    <params>
                        <param name="value" type="int"/>
                    </params>
                </method>
            </anonymous_class>
            <method name="getBitMetric" type="BitMetric" line="194"/>
            <javadoc line="198">
                bit-length is negative entropy:  -H(matrix).                
            </javadoc>
            <method name="getBitLength" type="double" line="200">
                <declaration name="sum" type="double" line="201"/>
                <scope line="202"/>
            </method>
            <javadoc line="209">
                bit-length in to another coding (cross-entropy)                
            </javadoc>
            <method name="getBitLength" type="double" line="211">
                <params>
                    <param name="len" type="BitMetric"/>
                </params>
                <declaration name="sum" type="double" line="212"/>
                <scope line="213">
                    <scope line="214"/>
                </scope>
            </method>
            <method name="round" type="double" line="222">
                <params>
                    <param name="x" type="double"/>
                    <param name="scale" type="double"/>
                </params>
            </method>
            <javadoc line="226">
                Sort rows and columns.
                  Merge adjacent rows with the same key element [0].
                  Make a fresh copy of all of it.                
            </javadoc>
            <method name="normalizeMatrix" type="int[][]" line="230">
                <params>
                    <param name="matrix" type="int[][]"/>
                </params>
                <comment line="251">
                    close it off                    
                </comment>
                <comment line="254">
                    Close off previous run.                    
                </comment>
                <comment line="257">
                    previously visited row                    
                </comment>
                <comment line="261">
                    cloned &amp; consolidated row                    
                </comment>
                <comment line="265">
                    previously visited row                    
                </comment>
                <comment line="273">
                    Detect and squeeze out duplicates.                    
                </comment>
                <comment line="279">
                    Reallocate because of lost duplicates.                    
                </comment>
                <comment line="293">
                    no unfinished business                    
                </comment>
                <comment line="294">
                    Now drop missing rows.                    
                </comment>
                <declaration name="rowMap" type="long[]" line="231"/>
                <scope line="232">
                    <declaration name="count" type="int" line="234"/>
                </scope>
                <declaration name="newMatrix" type="int[][]" line="239"/>
                <declaration name="prevCount" type="int" line="240"/>
                <declaration name="fillp1" type="int" line="241"/>
                <declaration name="fillp2" type="int" line="242"/>
                <scope line="243">
                    <declaration name="row" type="int[]" line="244"/>
                    <scope line="245">
                        <declaration name="rowMapEntry" type="long" line="246"/>
                    </scope>
                    <scope line="250"/>
                    <scope line="253">
                        <declaration name="length" type="int" line="255"/>
                        <scope line="256">
                            <declaration name="row0" type="int[]" line="257"/>
                        </scope>
                        <declaration name="row1" type="int[]" line="261"/>
                        <declaration name="rfillp" type="int" line="263"/>
                        <scope line="264">
                            <declaration name="row0" type="int[]" line="265"/>
                        </scope>
                        <scope line="270">
                            <declaration name="jfillp" type="int" line="272"/>
                            <scope line="274"/>
                            <scope line="278">
                                <declaration name="newRow1" type="int[]" line="280"/>
                            </scope>
                        </scope>
                    </scope>
                </scope>
                <scope line="296"/>
            </method>
            <method name="getRowTitles" type="String[]" line="305">
                <params>
                    <param name="name" type="String"/>
                </params>
                <declaration name="totalUnique" type="int" line="306"/>
                <declaration name="ltotalWeight" type="int" line="307"/>
                <declaration name="histTitles" type="String[]" line="308"/>
                <declaration name="cumWeight" type="int" line="309"/>
                <declaration name="cumUnique" type="int" line="310"/>
                <scope line="311">
                    <declaration name="count" type="int" line="312"/>
                    <declaration name="unique" type="int" line="313"/>
                    <declaration name="weight" type="int" line="314"/>
                    <declaration name="wpct" type="long" line="317"/>
                    <declaration name="upct" type="long" line="318"/>
                    <declaration name="len" type="double" line="319"/>
                </scope>
            </method>
            <javadoc line="330">
                Print a report of this histogram.                
            </javadoc>
            <method name="print" type="void" line="333">
                <params>
                    <param name="out" type="PrintStream"/>
                </params>
            </method>
            <javadoc line="337">
                Print a report of this histogram.                
            </javadoc>
            <method name="print" type="void" line="340">
                <params>
                    <param name="name" type="String"/>
                    <param name="out" type="PrintStream"/>
                </params>
            </method>
            <javadoc line="344">
                Print a report of this histogram.                
            </javadoc>
            <method name="print" type="void" line="347">
                <params>
                    <param name="name" type="String"/>
                    <param name="histTitles" type="String[]"/>
                    <param name="out" type="PrintStream"/>
                </params>
                <declaration name="totalUnique" type="int" line="348"/>
                <declaration name="ltotalWeight" type="int" line="349"/>
                <declaration name="tlen" type="double" line="350"/>
                <declaration name="avgLen" type="double" line="351"/>
                <declaration name="avg" type="double" line="352"/>
                <declaration name="title" type="String" line="353"/>
                <scope line="359"/>
                <scope line="361">
                    <declaration name="buf" type="StringBuffer" line="363"/>
                    <scope line="364">
                        <scope line="367"/>
                    </scope>
                </scope>
            </method>
            <method name="makeMatrix" type="int[][]" line="389">
                <params>
                    <param name="hist2col" type="long[]"/>
                </params>
                <comment line="390">
                    Sort by increasing count, then by increasing value.                    
                </comment>
                <comment line="398">
                    cursor into hist2col (increasing count, value)                    
                </comment>
                <comment line="399">
                    cursor into countHist (increasing count)                    
                </comment>
                <comment line="400">
                    Do a join between hist2col (resorted) and countHist.                    
                </comment>
                <comment line="403">
                    what is the value count?                    
                </comment>
                <comment line="404">
                    # times repeated?                    
                </comment>
                <declaration name="counts" type="int[]" line="392"/>
                <scope line="393"/>
                <declaration name="countHist" type="long[]" line="396"/>
                <declaration name="matrix" type="int[][]" line="397"/>
                <declaration name="histp" type="int" line="398"/>
                <declaration name="countp" type="int" line="399"/>
                <scope line="401">
                    <declaration name="countAndRep" type="long" line="402"/>
                    <declaration name="count" type="int" line="403"/>
                    <declaration name="repeat" type="int" line="404"/>
                    <declaration name="row" type="int[]" line="405"/>
                    <scope line="407">
                        <declaration name="countAndValue" type="long" line="408"/>
                    </scope>
                </scope>
            </method>
            <method name="makeTable" type="int[][]" line="419">
                <params>
                    <param name="hist2col" type="long[]"/>
                </params>
                <comment line="421">
                    Break apart the entries in hist2col.                    
                </comment>
                <comment line="422">
                    table[0] gets values, table[1] gets entries.                    
                </comment>
                <declaration name="table" type="int[][]" line="420"/>
                <scope line="423"/>
            </method>
            <javadoc line="430">
                Simple two-column histogram.  Contains repeated counts.
                  Assumes input is sorted.  Does not sort output columns.
                  &lt;p&gt;
                  Format of result:
                  &lt;pre&gt;
                  long[] hist = {
                  (count1 &lt;&lt; 32) | (value1),
                  (count2 &lt;&lt; 32) | (value2),
                  ...
                  }
                  &lt;/pre&gt;
                  In addition, the sequence {valuei...} is guaranteed to be sorted.
                  Note that resorting this using Arrays.sort() will reorder the
                  entries by increasing count.                
            </javadoc>
            <method name="computeHistogram2Col" type="long[]" line="446">
                <params>
                    <param name="sortedValues" type="int[]"/>
                </params>
                <comment line="456">
                    force a difference                    
                </comment>
                <comment line="463">
                    force a difference at end                    
                </comment>
                <comment line="467">
                    Found a new value.                    
                </comment>
                <comment line="469">
                    Save away previous value.                    
                </comment>
                <comment line="479">
                    Finished the sizing pass.  Allocate the histogram.                    
                </comment>
                <comment line="482">
                    done                    
                </comment>
                <declaration name="hist" type="long[]" line="453"/>
                <scope line="454">
                    <declaration name="prevIndex" type="int" line="455"/>
                    <declaration name="prevValue" type="int" line="456"/>
                    <declaration name="prevCount" type="int" line="457"/>
                    <scope line="458">
                        <declaration name="thisValue" type="int" line="459"/>
                        <scope line="464"/>
                        <scope line="466">
                            <scope line="468"/>
                        </scope>
                    </scope>
                    <scope line="478"/>
                    <scope line="481"/>
                </scope>
            </method>
            <javadoc line="488">
                Regroup the histogram, so that it becomes an approximate histogram
                  whose rows are of the given lengths.
                  If matrix rows must be split, the latter parts (larger values)
                  are placed earlier in the new matrix.
                  If matrix rows are joined, they are resorted into ascending order.
                  In the new histogram, the counts are averaged over row entries.                
            </javadoc>
            <method name="regroupHistogram" type="int[][]" line="496">
                <params>
                    <param name="matrix" type="int[][]"/>
                    <param name="groups" type="int[]"/>
                </params>
                <comment line="527">
                    Fill pointers.                    
                </comment>
                <comment line="528">
                    into matrix                    
                </comment>
                <comment line="534">
                    count of all in new group                    
                </comment>
                <comment line="550">
                    compute average count of new group:                    
                </comment>
                <declaration name="oldEntries" type="long" line="497"/>
                <scope line="498"/>
                <declaration name="newEntries" type="long" line="501"/>
                <scope line="502"/>
                <scope line="505">
                    <declaration name="newlen" type="int" line="506"/>
                    <declaration name="ok" type="long" line="507"/>
                    <scope line="508">
                        <scope line="509">
                            <declaration name="newGroups" type="int[]" line="510"/>
                        </scope>
                    </scope>
                </scope>
                <scope line="519">
                    <declaration name="excess" type="long" line="520"/>
                    <declaration name="newGroups" type="int[]" line="521"/>
                </scope>
                <declaration name="newMatrix" type="int[][]" line="526"/>
                <declaration name="i" type="int" line="528"/>
                <declaration name="jMin" type="int" line="529"/>
                <declaration name="jMax" type="int" line="530"/>
                <scope line="531">
                    <declaration name="groupLength" type="int" line="532"/>
                    <declaration name="group" type="int[]" line="533"/>
                    <declaration name="groupWeight" type="long" line="534"/>
                    <declaration name="njFill" type="int" line="536"/>
                    <scope line="537">
                        <declaration name="len" type="int" line="538"/>
                        <scope line="539"/>
                    </scope>
                </scope>
            </method>
            <method name="makeByteHistogram" type="Histogram" line="559">
                <params>
                    <param name="bytes" type="InputStream"/>
                </params>
                <comment line="567">
                    Build a matrix.                    
                </comment>
                <declaration name="buf" type="byte[]" line="560"/>
                <declaration name="tally" type="int[]" line="561"/>
                <scope line="562">
                    <scope line="563"/>
                </scope>
                <declaration name="matrix" type="int[][]" line="568"/>
                <scope line="569"/>
            </method>
            <javadoc line="576">
                Slice and sort the given input array.                
            </javadoc>
            <method name="sortedSlice" type="int[]" line="578">
                <params>
                    <param name="valueSequence" type="int[]"/>
                    <param name="start" type="int"/>
                    <param name="end" type="int"/>
                </params>
                <scope line="580"/>
                <scope line="582">
                    <declaration name="slice" type="int[]" line="583"/>
                </scope>
            </method>
            <javadoc line="590">
                Tell if an array is sorted.                
            </javadoc>
            <method name="isSorted" type="boolean" line="592">
                <params>
                    <param name="values" type="int[]"/>
                    <param name="from" type="int"/>
                    <param name="strict" type="boolean"/>
                </params>
                <comment line="596">
                    found witness to disorder                    
                </comment>
                <comment line="599">
                    no witness =&gt; sorted                    
                </comment>
                <scope line="593">
                    <scope line="595"/>
                </scope>
            </method>
            <javadoc line="602">
                Clone and sort the array, if not already sorted.                
            </javadoc>
            <method name="maybeSort" type="int[]" line="604">
                <params>
                    <param name="values" type="int[]"/>
                </params>
                <scope line="605"/>
            </method>
            <method name="assertWellFormed" type="boolean" line="615">
                <params>
                    <param name="valueSequence" type="int[]"/>
                </params>
                <comment line="616">
                    Sanity check.
                    int weight = 0;
                    int vlength = 0;
                    for (int i = 0; i &lt; matrix.length; i++) {
                    int vlengthi = (matrix[i].length-1);
                    int count = matrix[i][0];
                    assert(vlengthi &gt; 0);   no empty rows
                    assert(count &gt; 0);   no impossible rows
                    vlength += vlengthi;
                    weight += count  vlengthi;
                    }
                    assert(isSorted(values, 0, true));
                     make sure the counts all add up
                    assert(totalWeight == weight);
                    assert(vlength == values.length);
                    assert(vlength == counts.length);
                    int weight2 = 0;
                    for (int i = 0; i &lt; counts.length; i++) {
                    weight2 += counts[i];
                    }
                    assert(weight2 == weight);
                    int[] revcol1 = new int[matrix.length];  1st matrix colunm
                    for (int i = 0; i &lt; matrix.length; i++) {
                     spot checking:  try a random query on each matrix row
                    assert(matrix[i].length &gt; 1);
                    revcol1[matrix.length-i-1] = matrix[i][0];
                    assert(isSorted(matrix[i], 1, true));
                    int rand = (matrix[i].length+1)  2;
                    int val = matrix[i][rand];
                    int count = matrix[i][0];
                    int pos = Arrays.binarySearch(values, val);
                    assert(values[pos] == val);
                    assert(counts[pos] == matrix[i][0]);
                    if (valueSequence != null) {
                    int count2 = 0;
                    for (int j = 0; j &lt; valueSequence.length; j++) {
                    if (valueSequence[j] == val)  count2++;
                    }
                    assert(count2 == count);
                    }
                    }
                    assert(isSorted(revcol1, 0, true));                    
                </comment>
            </method>
        </class>
    </source>