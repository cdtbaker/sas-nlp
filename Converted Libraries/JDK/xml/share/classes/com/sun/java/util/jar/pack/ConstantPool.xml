<?xml version="1.0" encoding="UTF-8"?>
    <source package="com.sun.java.util.jar.pack">
        <import package="java.util.AbstractList"/>
        <import package="java.util.ArrayList"/>
        <import package="java.util.Arrays"/>
        <import package="java.util.Collection"/>
        <import package="java.util.List"/>
        <import package="java.util.ListIterator"/>
        <import package="java.util.Map"/>
        <import package="java.util.Set"/>
        <import package="com.sun.java.util.jar.pack.Constants"/>
        <class name="ConstantPool" line="38">
            <comment line="45">
                do not instantiate                
            </comment>
            <comment line="104">
                Convenience overloading.                
            </comment>
            <comment line="122">
                Convenience overloading.                
            </comment>
            <comment line="726">
                Handy constants:                
            </comment>
            <comment line="893">
                Index methods.                
            </comment>
            <comment line="1191">
                archive constant pool definition order                
            </comment>
            <javadoc line="38">
                Representation of constant pool entries and indexes.                
                <author>
                    John Rose                    
                </author>
            </javadoc>
            <method name="ConstantPool" type="constructor" line="44"/>
            <method name="verbose" type="int" line="46"/>
            <javadoc line="50">
                Factory for Utf8 string constants.
                  Used for well-known strings like &quot;SourceFile&quot;, &quot;&lt;init&gt;&quot;, etc.
                  Also used to back up more complex constant pool entries, like Class.                
            </javadoc>
            <method name="getUtf8Entry" type="Utf8Entry" line="54">
                <params>
                    <param name="value" type="String"/>
                </params>
                <declaration name="utf8Entries" type="Map&lt;String,Utf8Entry&gt;" line="55"/>
                <declaration name="e" type="Utf8Entry" line="56"/>
                <scope line="57"/>
            </method>
            <javadoc line="63">
                Factory for Class constants.                
            </javadoc>
            <method name="getClassEntry" type="ClassEntry" line="64">
                <params>
                    <param name="name" type="String"/>
                </params>
                <declaration name="classEntries" type="Map&lt;String,ClassEntry&gt;" line="65"/>
                <declaration name="e" type="ClassEntry" line="66"/>
                <scope line="67"/>
            </method>
            <javadoc line="74">
                Factory for literal constants (String, Integer, etc.).                
            </javadoc>
            <method name="getLiteralEntry" type="LiteralEntry" line="75">
                <params>
                    <param name="value" type="Comparable"/>
                </params>
                <declaration name="literalEntries" type="Map&lt;Object,LiteralEntry&gt;" line="76"/>
                <declaration name="e" type="LiteralEntry" line="77"/>
                <scope line="78"/>
            </method>
            <javadoc line="87">
                Factory for literal constants (String, Integer, etc.).                
            </javadoc>
            <method name="getStringEntry" type="StringEntry" line="88">
                <params>
                    <param name="value" type="String"/>
                </params>
            </method>
            <javadoc line="92">
                Factory for signature (type) constants.                
            </javadoc>
            <method name="getSignatureEntry" type="SignatureEntry" line="93">
                <params>
                    <param name="type" type="String"/>
                </params>
                <declaration name="signatureEntries" type="Map&lt;String,SignatureEntry&gt;" line="94"/>
                <declaration name="e" type="SignatureEntry" line="95"/>
                <scope line="96"/>
            </method>
            <method name="getSignatureEntry" type="SignatureEntry" line="104">
                <params>
                    <param name="formRef" type="Utf8Entry"/>
                    <param name="classRefs" type="ClassEntry[]"/>
                </params>
            </method>
            <javadoc line="108">
                Factory for descriptor (name-and-type) constants.                
            </javadoc>
            <method name="getDescriptorEntry" type="DescriptorEntry" line="109">
                <params>
                    <param name="nameRef" type="Utf8Entry"/>
                    <param name="typeRef" type="SignatureEntry"/>
                </params>
                <declaration name="descriptorEntries" type="Map&lt;String,DescriptorEntry&gt;" line="110"/>
                <declaration name="key" type="String" line="111"/>
                <declaration name="e" type="DescriptorEntry" line="112"/>
                <scope line="113"/>
            </method>
            <method name="getDescriptorEntry" type="DescriptorEntry" line="122">
                <params>
                    <param name="nameRef" type="Utf8Entry"/>
                    <param name="typeRef" type="Utf8Entry"/>
                </params>
            </method>
            <javadoc line="126">
                Factory for member reference constants.                
            </javadoc>
            <method name="getMemberEntry" type="MemberEntry" line="127">
                <params>
                    <param name="tag" type="byte"/>
                    <param name="classRef" type="ClassEntry"/>
                    <param name="descRef" type="DescriptorEntry"/>
                </params>
                <declaration name="memberEntries" type="Map&lt;String,MemberEntry&gt;" line="128"/>
                <declaration name="key" type="String" line="129"/>
                <declaration name="e" type="MemberEntry" line="130"/>
                <scope line="131"/>
            </method>
            <class name="Entry" line="141">
                <comment line="145">
                    a CONSTANT_foo code                    
                </comment>
                <comment line="146">
                    cached hashCode                    
                </comment>
                <comment line="165">
                    Equality of Entries is value-based.                    
                </comment>
                <comment line="770">
                    Find index of e in cpMap, or return -1 if none.
                    
                     As a special hack, if flattenSigs, signatures are
                     treated as equivalent entries of cpMap.  This is wrong
                     from a Collection point of view, because contains()
                     reports true for signatures, but the iterator()
                     never produces them!                    
                </comment>
                <comment line="796">
                    Find index of e in cpMap.  Should not return -1.                    
                </comment>
                <comment line="827">
                    internal hash table                    
                </comment>
                <comment line="1082">
                    Given the sequence of all methods of the given name and class,
                     produce the ordinal of this particular given overloading.                    
                </comment>
                <comment line="1099">
                    Inverse of getOverloadingIndex                    
                </comment>
                <implements interface="Comparable"/>
                <javadoc line="141">
                    Entries in the constant pool.                    
                </javadoc>
                <declaration name="tag" type="byte" line="144"/>
                <declaration name="valueHash" type="int" line="145"/>
                <method name="Entry" type="constructor" line="147">
                    <params>
                        <param name="tag" type="byte"/>
                    </params>
                </method>
                <method name="getTag" type="byte" line="151"/>
                <method name="getRef" type="Entry" line="155">
                    <params>
                        <param name="i" type="int"/>
                    </params>
                </method>
                <method name="eq" type="boolean" line="159">
                    <params>
                        <param name="that" type="Entry"/>
                    </params>
                </method>
                <method name="equals" type="boolean" line="165"/>
                <method name="hashCode" type="int" line="166">
                    <scope line="167"/>
                </method>
                <method name="computeValueHash" type="int" line="173"/>
                <method name="compareTo" type="int" line="175"/>
                <method name="superCompareTo" type="int" line="177">
                    <params>
                        <param name="o" type="Object"/>
                    </params>
                    <comment line="185">
                        subclasses must refine this                        
                    </comment>
                    <declaration name="that" type="Entry" line="178"/>
                    <scope line="180"/>
                </method>
                <method name="isDoubleWord" type="boolean" line="187"/>
                <method name="tagMatches" type="boolean" line="191">
                    <params>
                        <param name="tag" type="int"/>
                    </params>
                </method>
                <method name="toString" type="String" line="195">
                    <declaration name="valuePrint" type="String" line="196"/>
                    <scope line="197"/>
                </method>
                <method name="stringValue" type="String" line="204"/>
            </class>
            <class name="Utf8Entry" line="207">
                <extends class="Entry"/>
                <comment line="145">
                    a CONSTANT_foo code                    
                </comment>
                <comment line="146">
                    cached hashCode                    
                </comment>
                <comment line="165">
                    Equality of Entries is value-based.                    
                </comment>
                <comment line="770">
                    Find index of e in cpMap, or return -1 if none.
                    
                     As a special hack, if flattenSigs, signatures are
                     treated as equivalent entries of cpMap.  This is wrong
                     from a Collection point of view, because contains()
                     reports true for signatures, but the iterator()
                     never produces them!                    
                </comment>
                <comment line="796">
                    Find index of e in cpMap.  Should not return -1.                    
                </comment>
                <comment line="827">
                    internal hash table                    
                </comment>
                <comment line="1082">
                    Given the sequence of all methods of the given name and class,
                     produce the ordinal of this particular given overloading.                    
                </comment>
                <comment line="1099">
                    Inverse of getOverloadingIndex                    
                </comment>
                <declaration name="value" type="String" line="209"/>
                <method name="Utf8Entry" type="constructor" line="211">
                    <params>
                        <param name="value" type="String"/>
                    </params>
                    <comment line="215">
                        force computation of valueHash                        
                    </comment>
                </method>
                <method name="computeValueHash" type="int" line="216"/>
                <method name="equals" type="boolean" line="219">
                    <params>
                        <param name="o" type="Object"/>
                    </params>
                    <comment line="221">
                        Use reference equality of interned strings:                        
                    </comment>
                </method>
                <method name="compareTo" type="int" line="224">
                    <params>
                        <param name="o" type="Object"/>
                    </params>
                    <declaration name="x" type="int" line="225"/>
                    <scope line="226"/>
                </method>
                <method name="stringValue" type="String" line="231"/>
            </class>
            <method name="isMemberTag" type="boolean" line="236">
                <params>
                    <param name="tag" type="byte"/>
                </params>
            </method>
            <method name="numberTagOf" type="byte" line="246">
                <params>
                    <param name="value" type="Number"/>
                </params>
            </method>
            <class name="LiteralEntry" line="254">
                <extends class="Entry"/>
                <comment line="145">
                    a CONSTANT_foo code                    
                </comment>
                <comment line="146">
                    cached hashCode                    
                </comment>
                <comment line="165">
                    Equality of Entries is value-based.                    
                </comment>
                <comment line="770">
                    Find index of e in cpMap, or return -1 if none.
                    
                     As a special hack, if flattenSigs, signatures are
                     treated as equivalent entries of cpMap.  This is wrong
                     from a Collection point of view, because contains()
                     reports true for signatures, but the iterator()
                     never produces them!                    
                </comment>
                <comment line="796">
                    Find index of e in cpMap.  Should not return -1.                    
                </comment>
                <comment line="827">
                    internal hash table                    
                </comment>
                <comment line="1082">
                    Given the sequence of all methods of the given name and class,
                     produce the ordinal of this particular given overloading.                    
                </comment>
                <comment line="1099">
                    Inverse of getOverloadingIndex                    
                </comment>
                <method name="LiteralEntry" type="constructor" line="256">
                    <params>
                        <param name="tag" type="byte"/>
                    </params>
                </method>
                <method name="literalValue" type="Comparable" line="260"/>
            </class>
            <class name="NumberEntry" line="263">
                <extends class="LiteralEntry"/>
                <comment line="145">
                    a CONSTANT_foo code                    
                </comment>
                <comment line="146">
                    cached hashCode                    
                </comment>
                <comment line="165">
                    Equality of Entries is value-based.                    
                </comment>
                <comment line="770">
                    Find index of e in cpMap, or return -1 if none.
                    
                     As a special hack, if flattenSigs, signatures are
                     treated as equivalent entries of cpMap.  This is wrong
                     from a Collection point of view, because contains()
                     reports true for signatures, but the iterator()
                     never produces them!                    
                </comment>
                <comment line="796">
                    Find index of e in cpMap.  Should not return -1.                    
                </comment>
                <comment line="827">
                    internal hash table                    
                </comment>
                <comment line="1082">
                    Given the sequence of all methods of the given name and class,
                     produce the ordinal of this particular given overloading.                    
                </comment>
                <comment line="1099">
                    Inverse of getOverloadingIndex                    
                </comment>
                <declaration name="value" type="Number" line="265"/>
                <method name="NumberEntry" type="constructor" line="266">
                    <params>
                        <param name="value" type="Number"/>
                    </params>
                    <comment line="270">
                        force computation of valueHash                        
                    </comment>
                </method>
                <method name="computeValueHash" type="int" line="271"/>
                <method name="equals" type="boolean" line="275">
                    <params>
                        <param name="o" type="Object"/>
                    </params>
                </method>
                <method name="compareTo" type="int" line="280">
                    <params>
                        <param name="o" type="Object"/>
                    </params>
                    <declaration name="x" type="int" line="281"/>
                    <scope line="282"/>
                </method>
                <method name="numberValue" type="Number" line="287"/>
                <method name="literalValue" type="Comparable" line="290"/>
                <method name="stringValue" type="String" line="293"/>
            </class>
            <class name="StringEntry" line="298">
                <extends class="LiteralEntry"/>
                <comment line="145">
                    a CONSTANT_foo code                    
                </comment>
                <comment line="146">
                    cached hashCode                    
                </comment>
                <comment line="165">
                    Equality of Entries is value-based.                    
                </comment>
                <comment line="770">
                    Find index of e in cpMap, or return -1 if none.
                    
                     As a special hack, if flattenSigs, signatures are
                     treated as equivalent entries of cpMap.  This is wrong
                     from a Collection point of view, because contains()
                     reports true for signatures, but the iterator()
                     never produces them!                    
                </comment>
                <comment line="796">
                    Find index of e in cpMap.  Should not return -1.                    
                </comment>
                <comment line="827">
                    internal hash table                    
                </comment>
                <comment line="1082">
                    Given the sequence of all methods of the given name and class,
                     produce the ordinal of this particular given overloading.                    
                </comment>
                <comment line="1099">
                    Inverse of getOverloadingIndex                    
                </comment>
                <declaration name="ref" type="Utf8Entry" line="300"/>
                <method name="getRef" type="Entry" line="301">
                    <params>
                        <param name="i" type="int"/>
                    </params>
                </method>
                <method name="StringEntry" type="constructor" line="303">
                    <params>
                        <param name="ref" type="Entry"/>
                    </params>
                    <comment line="307">
                        force computation of valueHash                        
                    </comment>
                </method>
                <method name="computeValueHash" type="int" line="308"/>
                <method name="equals" type="boolean" line="311">
                    <params>
                        <param name="o" type="Object"/>
                    </params>
                </method>
                <method name="compareTo" type="int" line="315">
                    <params>
                        <param name="o" type="Object"/>
                    </params>
                    <declaration name="x" type="int" line="316"/>
                    <scope line="317"/>
                </method>
                <method name="literalValue" type="Comparable" line="322"/>
                <method name="stringValue" type="String" line="325"/>
            </class>
            <class name="ClassEntry" line="330">
                <extends class="Entry"/>
                <comment line="145">
                    a CONSTANT_foo code                    
                </comment>
                <comment line="146">
                    cached hashCode                    
                </comment>
                <comment line="165">
                    Equality of Entries is value-based.                    
                </comment>
                <comment line="770">
                    Find index of e in cpMap, or return -1 if none.
                    
                     As a special hack, if flattenSigs, signatures are
                     treated as equivalent entries of cpMap.  This is wrong
                     from a Collection point of view, because contains()
                     reports true for signatures, but the iterator()
                     never produces them!                    
                </comment>
                <comment line="796">
                    Find index of e in cpMap.  Should not return -1.                    
                </comment>
                <comment line="827">
                    internal hash table                    
                </comment>
                <comment line="1082">
                    Given the sequence of all methods of the given name and class,
                     produce the ordinal of this particular given overloading.                    
                </comment>
                <comment line="1099">
                    Inverse of getOverloadingIndex                    
                </comment>
                <declaration name="ref" type="Utf8Entry" line="332"/>
                <method name="getRef" type="Entry" line="333">
                    <params>
                        <param name="i" type="int"/>
                    </params>
                </method>
                <method name="computeValueHash" type="int" line="335"/>
                <method name="ClassEntry" type="constructor" line="338">
                    <params>
                        <param name="ref" type="Entry"/>
                    </params>
                    <comment line="342">
                        force computation of valueHash                        
                    </comment>
                </method>
                <method name="equals" type="boolean" line="343">
                    <params>
                        <param name="o" type="Object"/>
                    </params>
                </method>
                <method name="compareTo" type="int" line="347">
                    <params>
                        <param name="o" type="Object"/>
                    </params>
                    <declaration name="x" type="int" line="348"/>
                    <scope line="349"/>
                </method>
                <method name="stringValue" type="String" line="354"/>
            </class>
            <class name="DescriptorEntry" line="359">
                <extends class="Entry"/>
                <comment line="145">
                    a CONSTANT_foo code                    
                </comment>
                <comment line="146">
                    cached hashCode                    
                </comment>
                <comment line="165">
                    Equality of Entries is value-based.                    
                </comment>
                <comment line="770">
                    Find index of e in cpMap, or return -1 if none.
                    
                     As a special hack, if flattenSigs, signatures are
                     treated as equivalent entries of cpMap.  This is wrong
                     from a Collection point of view, because contains()
                     reports true for signatures, but the iterator()
                     never produces them!                    
                </comment>
                <comment line="796">
                    Find index of e in cpMap.  Should not return -1.                    
                </comment>
                <comment line="827">
                    internal hash table                    
                </comment>
                <comment line="1082">
                    Given the sequence of all methods of the given name and class,
                     produce the ordinal of this particular given overloading.                    
                </comment>
                <comment line="1099">
                    Inverse of getOverloadingIndex                    
                </comment>
                <declaration name="nameRef" type="Utf8Entry" line="361"/>
                <declaration name="typeRef" type="SignatureEntry" line="362"/>
                <method name="getRef" type="Entry" line="363">
                    <params>
                        <param name="i" type="int"/>
                    </params>
                </method>
                <method name="DescriptorEntry" type="constructor" line="368">
                    <params>
                        <param name="nameRef" type="Entry"/>
                        <param name="typeRef" type="Entry"/>
                    </params>
                    <comment line="376">
                        force computation of valueHash                        
                    </comment>
                    <scope line="370"/>
                </method>
                <method name="computeValueHash" type="int" line="377">
                    <declaration name="hc2" type="int" line="378"/>
                </method>
                <method name="equals" type="boolean" line="381">
                    <params>
                        <param name="o" type="Object"/>
                    </params>
                    <scope line="382"/>
                    <declaration name="that" type="DescriptorEntry" line="385"/>
                </method>
                <method name="compareTo" type="int" line="389">
                    <params>
                        <param name="o" type="Object"/>
                    </params>
                    <comment line="394">
                        Primary key is typeRef, not nameRef.                        
                    </comment>
                    <declaration name="x" type="int" line="390"/>
                    <scope line="391">
                        <declaration name="that" type="DescriptorEntry" line="392"/>
                    </scope>
                </method>
                <method name="stringValue" type="String" line="400"/>
                <method name="stringValueOf" type="String" line="404">
                    <params>
                        <param name="nameRef" type="Entry"/>
                        <param name="typeRef" type="Entry"/>
                    </params>
                </method>
                <method name="prettyString" type="String" line="408"/>
                <method name="isMethod" type="boolean" line="412"/>
                <method name="getLiteralTag" type="byte" line="416"/>
            </class>
            <class name="MemberEntry" line="421">
                <extends class="Entry"/>
                <comment line="145">
                    a CONSTANT_foo code                    
                </comment>
                <comment line="146">
                    cached hashCode                    
                </comment>
                <comment line="165">
                    Equality of Entries is value-based.                    
                </comment>
                <comment line="770">
                    Find index of e in cpMap, or return -1 if none.
                    
                     As a special hack, if flattenSigs, signatures are
                     treated as equivalent entries of cpMap.  This is wrong
                     from a Collection point of view, because contains()
                     reports true for signatures, but the iterator()
                     never produces them!                    
                </comment>
                <comment line="796">
                    Find index of e in cpMap.  Should not return -1.                    
                </comment>
                <comment line="827">
                    internal hash table                    
                </comment>
                <comment line="1082">
                    Given the sequence of all methods of the given name and class,
                     produce the ordinal of this particular given overloading.                    
                </comment>
                <comment line="1099">
                    Inverse of getOverloadingIndex                    
                </comment>
                <declaration name="classRef" type="ClassEntry" line="423"/>
                <declaration name="descRef" type="DescriptorEntry" line="424"/>
                <method name="getRef" type="Entry" line="425">
                    <params>
                        <param name="i" type="int"/>
                    </params>
                </method>
                <method name="computeValueHash" type="int" line="430">
                    <declaration name="hc2" type="int" line="431"/>
                </method>
                <method name="MemberEntry" type="constructor" line="435">
                    <params>
                        <param name="tag" type="byte"/>
                        <param name="classRef" type="ClassEntry"/>
                        <param name="descRef" type="DescriptorEntry"/>
                    </params>
                    <comment line="441">
                        force computation of valueHash                        
                    </comment>
                </method>
                <method name="equals" type="boolean" line="442">
                    <params>
                        <param name="o" type="Object"/>
                    </params>
                    <scope line="443"/>
                    <declaration name="that" type="MemberEntry" line="446"/>
                </method>
                <method name="compareTo" type="int" line="450">
                    <params>
                        <param name="o" type="Object"/>
                    </params>
                    <comment line="455">
                        Primary key is classRef.                        
                    </comment>
                    <declaration name="x" type="int" line="451"/>
                    <scope line="452">
                        <declaration name="that" type="MemberEntry" line="453"/>
                    </scope>
                </method>
                <method name="stringValue" type="String" line="461"/>
                <method name="stringValueOf" type="String" line="465">
                    <params>
                        <param name="tag" type="byte"/>
                        <param name="classRef" type="ClassEntry"/>
                        <param name="descRef" type="DescriptorEntry"/>
                    </params>
                    <declaration name="pfx" type="String" line="467"/>
                </method>
                <method name="isMethod" type="boolean" line="477"/>
            </class>
            <class name="SignatureEntry" line="482">
                <extends class="Entry"/>
                <comment line="145">
                    a CONSTANT_foo code                    
                </comment>
                <comment line="146">
                    cached hashCode                    
                </comment>
                <comment line="165">
                    Equality of Entries is value-based.                    
                </comment>
                <comment line="770">
                    Find index of e in cpMap, or return -1 if none.
                    
                     As a special hack, if flattenSigs, signatures are
                     treated as equivalent entries of cpMap.  This is wrong
                     from a Collection point of view, because contains()
                     reports true for signatures, but the iterator()
                     never produces them!                    
                </comment>
                <comment line="796">
                    Find index of e in cpMap.  Should not return -1.                    
                </comment>
                <comment line="827">
                    internal hash table                    
                </comment>
                <comment line="1082">
                    Given the sequence of all methods of the given name and class,
                     produce the ordinal of this particular given overloading.                    
                </comment>
                <comment line="1099">
                    Inverse of getOverloadingIndex                    
                </comment>
                <declaration name="formRef" type="Utf8Entry" line="484"/>
                <declaration name="classRefs" type="ClassEntry[]" line="485"/>
                <declaration name="value" type="String" line="486"/>
                <declaration name="asUtf8Entry" type="Utf8Entry" line="487"/>
                <method name="getRef" type="Entry" line="488">
                    <params>
                        <param name="i" type="int"/>
                    </params>
                </method>
                <method name="SignatureEntry" type="constructor" line="492">
                    <params>
                        <param name="value" type="String"/>
                    </params>
                    <comment line="495">
                        always do this                        
                    </comment>
                    <comment line="503">
                        force computation of valueHash                        
                    </comment>
                    <declaration name="parts" type="String[]" line="496"/>
                    <scope line="499"/>
                </method>
                <method name="computeValueHash" type="int" line="504">
                    <comment line="506">
                        force computation of value                        
                    </comment>
                </method>
                <method name="asUtf8Entry" type="Utf8Entry" line="509">
                    <scope line="510"/>
                </method>
                <method name="equals" type="boolean" line="516">
                    <params>
                        <param name="o" type="Object"/>
                    </params>
                </method>
                <method name="compareTo" type="int" line="520">
                    <params>
                        <param name="o" type="Object"/>
                    </params>
                    <declaration name="x" type="int" line="521"/>
                    <scope line="522">
                        <declaration name="that" type="SignatureEntry" line="523"/>
                    </scope>
                </method>
                <method name="stringValue" type="String" line="528">
                    <scope line="529"/>
                </method>
                <method name="stringValueOf" type="String" line="535">
                    <params>
                        <param name="formRef" type="Utf8Entry"/>
                        <param name="classRefs" type="ClassEntry[]"/>
                    </params>
                    <declaration name="parts" type="String[]" line="536"/>
                    <scope line="538"/>
                </method>
                <method name="computeSize" type="int" line="544">
                    <params>
                        <param name="countDoublesTwice" type="boolean"/>
                    </params>
                    <comment line="563">
                        Skip rest of array info.                        
                    </comment>
                    <declaration name="form" type="String" line="545"/>
                    <declaration name="min" type="int" line="546"/>
                    <declaration name="max" type="int" line="547"/>
                    <scope line="548"/>
                    <declaration name="size" type="int" line="552"/>
                    <scope line="553">
                        <scope line="557"/>
                        <scope line="563"/>
                    </scope>
                </method>
                <method name="isMethod" type="boolean" line="577"/>
                <method name="getLiteralTag" type="byte" line="580"/>
                <method name="prettyString" type="String" line="593">
                    <declaration name="s" type="String" line="594"/>
                    <scope line="595"/>
                    <scope line="598"/>
                    <declaration name="i" type="int" line="601"/>
                    <scope line="602"/>
                </method>
            </class>
            <method name="compareSignatures" type="int" line="609">
                <params>
                    <param name="s1" type="String"/>
                    <param name="s2" type="String"/>
                </params>
            </method>
            <method name="compareSignatures" type="int" line="612">
                <params>
                    <param name="s1" type="String"/>
                    <param name="s2" type="String"/>
                    <param name="p1" type="String[]"/>
                    <param name="p2" type="String[]"/>
                </params>
                <comment line="618">
                    fields before methods (because there are fewer of them)                    
                </comment>
                <comment line="623">
                    non-classes before classes (because there are fewer of them)
                    if (p1.length == 1 &amp;&amp; p2.length &gt; 1)  return S1_COMES_FIRST;
                    if (p2.length == 1 &amp;&amp; p1.length &gt; 1)  return S2_COMES_FIRST;
                     all else being equal, use the same comparison as for Utf8 strings
                    return s1.compareTo(s2);                    
                </comment>
                <declaration name="S1_COMES_FIRST" type="int" line="613"/>
                <declaration name="S2_COMES_FIRST" type="int" line="614"/>
                <declaration name="c1" type="char" line="615"/>
                <declaration name="c2" type="char" line="616"/>
                <declaration name="length" type="int" line="630"/>
                <scope line="631">
                    <declaration name="res" type="int" line="632"/>
                </scope>
            </method>
            <method name="countClassParts" type="int" line="639">
                <params>
                    <param name="formRef" type="Utf8Entry"/>
                </params>
                <declaration name="num" type="int" line="640"/>
                <declaration name="s" type="String" line="641"/>
                <scope line="642"/>
            </method>
            <method name="flattenSignature" type="String" line="648">
                <params>
                    <param name="parts" type="String[]"/>
                </params>
                <comment line="666">
                    sig[j++] = &apos;;&apos;;                    
                </comment>
                <declaration name="form" type="String" line="649"/>
                <declaration name="len" type="int" line="651"/>
                <scope line="652"/>
                <declaration name="sig" type="char[]" line="655"/>
                <declaration name="j" type="int" line="656"/>
                <declaration name="k" type="int" line="657"/>
                <scope line="658">
                    <declaration name="ch" type="char" line="659"/>
                    <scope line="661">
                        <declaration name="cls" type="String" line="662"/>
                    </scope>
                </scope>
            </method>
            <method name="skipClassNameChars" type="int" line="673">
                <params>
                    <param name="sig" type="String"/>
                    <param name="i" type="int"/>
                </params>
                <declaration name="len" type="int" line="674"/>
                <scope line="675">
                    <declaration name="ch" type="char" line="676"/>
                </scope>
            </method>
            <method name="structureSignature" type="String[]" line="683">
                <params>
                    <param name="sig" type="String"/>
                </params>
                <comment line="695">
                    keep the semicolon in the form                    
                </comment>
                <comment line="716">
                    keep the semicolon in the form                    
                </comment>
                <comment line="722">
                    assert(flattenSignature(parts).equals(sig));                    
                </comment>
                <declaration name="formLen" type="int" line="686"/>
                <declaration name="nparts" type="int" line="687"/>
                <scope line="688">
                    <declaration name="ch" type="char" line="689"/>
                    <scope line="691">
                        <declaration name="i2" type="int" line="693"/>
                        <declaration name="i3" type="int" line="695"/>
                    </scope>
                </scope>
                <declaration name="form" type="char[]" line="700"/>
                <scope line="701">
                    <declaration name="parts" type="String[]" line="702"/>
                </scope>
                <declaration name="parts" type="String[]" line="705"/>
                <declaration name="j" type="int" line="706"/>
                <declaration name="k" type="int" line="707"/>
                <scope line="708">
                    <declaration name="ch" type="char" line="709"/>
                    <scope line="711">
                        <declaration name="i2" type="int" line="712"/>
                    </scope>
                </scope>
            </method>
            <declaration name="noRefs" type="Entry[]" line="726"/>
            <declaration name="noClassRefs" type="ClassEntry[]" line="727"/>
            <class name="Index" line="729">
                <extends class="AbstractList"/>
                <comment line="145">
                    a CONSTANT_foo code                    
                </comment>
                <comment line="146">
                    cached hashCode                    
                </comment>
                <comment line="165">
                    Equality of Entries is value-based.                    
                </comment>
                <comment line="770">
                    Find index of e in cpMap, or return -1 if none.
                    
                     As a special hack, if flattenSigs, signatures are
                     treated as equivalent entries of cpMap.  This is wrong
                     from a Collection point of view, because contains()
                     reports true for signatures, but the iterator()
                     never produces them!                    
                </comment>
                <comment line="796">
                    Find index of e in cpMap.  Should not return -1.                    
                </comment>
                <comment line="827">
                    internal hash table                    
                </comment>
                <comment line="1082">
                    Given the sequence of all methods of the given name and class,
                     produce the ordinal of this particular given overloading.                    
                </comment>
                <comment line="1099">
                    Inverse of getOverloadingIndex                    
                </comment>
                <javadoc line="729">
                    An Index is a mapping between CP entries and small integers.                    
                </javadoc>
                <declaration name="debugName" type="String" line="732"/>
                <declaration name="cpMap" type="Entry[]" line="733"/>
                <declaration name="flattenSigs" type="boolean" line="734"/>
                <method name="getMap" type="Entry[]" line="735"/>
                <method name="Index" type="constructor" line="738">
                    <params>
                        <param name="debugName" type="String"/>
                    </params>
                </method>
                <method name="Index" type="constructor" line="741">
                    <params>
                        <param name="debugName" type="String"/>
                        <param name="cpMap" type="Entry[]"/>
                    </params>
                </method>
                <method name="setMap" type="void" line="745">
                    <params>
                        <param name="cpMap" type="Entry[]"/>
                    </params>
                </method>
                <method name="Index" type="constructor" line="749">
                    <params>
                        <param name="debugName" type="String"/>
                        <param name="cpMapList" type="Collection<Entry>"/>
                    </params>
                </method>
                <method name="setMap" type="void" line="753">
                    <params>
                        <param name="cpMapList" type="Collection<Entry>"/>
                    </params>
                </method>
                <method name="size" type="int" line="758"/>
                <method name="get" type="Object" line="761">
                    <params>
                        <param name="i" type="int"/>
                    </params>
                </method>
                <method name="getEntry" type="Entry" line="764">
                    <params>
                        <param name="i" type="int"/>
                    </params>
                    <comment line="766">
                        same as get(), with covariant return type                        
                    </comment>
                </method>
                <method name="findIndexOf" type="int" line="776">
                    <params>
                        <param name="e" type="Entry"/>
                    </params>
                    <scope line="777"/>
                    <declaration name="probe" type="int" line="780"/>
                    <scope line="781">
                        <scope line="782">
                            <declaration name="se" type="SignatureEntry" line="783"/>
                        </scope>
                    </scope>
                    <declaration name="index" type="int" line="788"/>
                </method>
                <method name="contains" type="boolean" line="792">
                    <params>
                        <param name="e" type="Entry"/>
                    </params>
                </method>
                <method name="indexOf" type="int" line="796">
                    <params>
                        <param name="e" type="Entry"/>
                    </params>
                    <declaration name="index" type="int" line="797"/>
                    <scope line="798"/>
                </method>
                <method name="contains" type="boolean" line="806">
                    <params>
                        <param name="e" type="Object"/>
                    </params>
                </method>
                <method name="indexOf" type="int" line="809">
                    <params>
                        <param name="e" type="Object"/>
                    </params>
                </method>
                <method name="lastIndexOf" type="int" line="812">
                    <params>
                        <param name="e" type="Object"/>
                    </params>
                </method>
                <method name="assertIsSorted" type="boolean" line="816">
                    <scope line="817">
                        <scope line="818"/>
                    </scope>
                </method>
                <declaration name="indexKey" type="Entry[]" line="827"/>
                <declaration name="indexValue" type="int[]" line="828"/>
                <method name="clearIndex" type="void" line="829"/>
                <method name="findIndexLocation" type="int" line="833">
                    <params>
                        <param name="e" type="Entry"/>
                    </params>
                    <declaration name="size" type="int" line="834"/>
                    <declaration name="hash" type="int" line="835"/>
                    <declaration name="probe" type="int" line="836"/>
                    <declaration name="stride" type="int" line="837"/>
                    <scope line="838">
                        <declaration name="e1" type="Entry" line="839"/>
                    </scope>
                </method>
                <method name="initializeIndex" type="void" line="846">
                    <comment line="861">
                        e has unique index                        
                    </comment>
                    <declaration name="hsize0" type="int" line="849"/>
                    <declaration name="hsize" type="int" line="850"/>
                    <scope line="851"/>
                    <scope line="856">
                        <declaration name="e" type="Entry" line="857"/>
                        <declaration name="probe" type="int" line="859"/>
                    </scope>
                </method>
                <method name="toArray" type="Object[]" line="865">
                    <params>
                        <param name="a" type="Object[]"/>
                    </params>
                    <declaration name="sz" type="int" line="866"/>
                </method>
                <method name="toArray" type="Object[]" line="872"/>
                <method name="clone" type="Object" line="875"/>
                <method name="toString" type="String" line="878"/>
                <method name="dumpString" type="String" line="881">
                    <declaration name="s" type="String" line="882"/>
                    <scope line="884"/>
                </method>
            </class>
            <method name="makeIndex" type="Index" line="895">
                <params>
                    <param name="debugName" type="String"/>
                    <param name="cpMap" type="Entry[]"/>
                </params>
            </method>
            <method name="makeIndex" type="Index" line="900">
                <params>
                    <param name="debugName" type="String"/>
                    <param name="cpMapList" type="Collection<Entry>"/>
                </params>
            </method>
            <javadoc line="904">
                Sort this index (destructively) into canonical order.                
            </javadoc>
            <method name="sort" type="void" line="906">
                <params>
                    <param name="ix" type="Index"/>
                </params>
                <comment line="908">
                    %%% Should move this into class Index.                    
                </comment>
            </method>
            <javadoc line="914">
                Return a set of indexes partitioning these entries.
                  The keys array must of length this.size(), and marks entries.
                  The result array is as long as one plus the largest key value.
                  Entries with a negative key are dropped from the partition.                
            </javadoc>
            <method name="partition" type="Index[]" line="920">
                <params>
                    <param name="ix" type="Index"/>
                    <param name="keys" type="int[]"/>
                </params>
                <comment line="922">
                    %%% Should move this into class Index.                    
                </comment>
                <declaration name="parts" type="List&lt;List&lt;Entry&gt;&gt;" line="922"/>
                <declaration name="cpMap" type="Entry[]" line="923"/>
                <scope line="925">
                    <declaration name="key" type="int" line="926"/>
                    <scope line="928"/>
                    <declaration name="part" type="List&lt;Entry&gt;" line="931"/>
                    <scope line="932"/>
                </scope>
                <declaration name="indexes" type="Index[]" line="937"/>
                <scope line="938">
                    <declaration name="part" type="List&lt;Entry&gt;" line="939"/>
                </scope>
            </method>
            <method name="partitionByTag" type="Index[]" line="947">
                <params>
                    <param name="ix" type="Index"/>
                </params>
                <comment line="949">
                    Partition by tag.                    
                </comment>
                <declaration name="cpMap" type="Entry[]" line="949"/>
                <declaration name="keys" type="int[]" line="950"/>
                <scope line="951">
                    <declaration name="e" type="Entry" line="952"/>
                </scope>
                <declaration name="byTag" type="Index[]" line="955"/>
                <scope line="956"/>
                <scope line="960">
                    <declaration name="longer" type="Index[]" line="961"/>
                </scope>
            </method>
            <class name="IndexGroup" line="968">
                <comment line="145">
                    a CONSTANT_foo code                    
                </comment>
                <comment line="146">
                    cached hashCode                    
                </comment>
                <comment line="165">
                    Equality of Entries is value-based.                    
                </comment>
                <comment line="770">
                    Find index of e in cpMap, or return -1 if none.
                    
                     As a special hack, if flattenSigs, signatures are
                     treated as equivalent entries of cpMap.  This is wrong
                     from a Collection point of view, because contains()
                     reports true for signatures, but the iterator()
                     never produces them!                    
                </comment>
                <comment line="796">
                    Find index of e in cpMap.  Should not return -1.                    
                </comment>
                <comment line="827">
                    internal hash table                    
                </comment>
                <comment line="1082">
                    Given the sequence of all methods of the given name and class,
                     produce the ordinal of this particular given overloading.                    
                </comment>
                <comment line="1099">
                    Inverse of getOverloadingIndex                    
                </comment>
                <javadoc line="968">
                    Coherent group of constant pool indexes.                    
                </javadoc>
                <declaration name="indexUntyped" type="Index" line="971"/>
                <declaration name="indexByTag" type="Index[]" line="972"/>
                <declaration name="untypedFirstIndexByTag" type="int[]" line="973"/>
                <declaration name="totalSize" type="int" line="974"/>
                <declaration name="indexByTagAndClass" type="Index[][]" line="975"/>
                <javadoc line="977">
                    Index of all CP entries of all types, in definition order.                    
                </javadoc>
                <method name="getUntypedIndex" type="Index" line="978">
                    <comment line="981">
                        warm up untypedFirstIndexByTag                        
                    </comment>
                    <scope line="979">
                        <declaration name="cpMap" type="Entry[]" line="981"/>
                        <scope line="982">
                            <declaration name="ix" type="Index" line="983"/>
                            <declaration name="ixLen" type="int" line="985"/>
                            <declaration name="fillp" type="int" line="987"/>
                        </scope>
                    </scope>
                </method>
                <method name="untypedIndexOf" type="int" line="997">
                    <params>
                        <param name="e" type="Entry"/>
                    </params>
                    <scope line="998">
                        <declaration name="fillp" type="int" line="1000"/>
                        <scope line="1001">
                            <declaration name="tag" type="byte" line="1002"/>
                            <declaration name="ix" type="Index" line="1003"/>
                            <declaration name="ixLen" type="int" line="1005"/>
                        </scope>
                    </scope>
                    <declaration name="tag" type="int" line="1012"/>
                    <declaration name="ix" type="Index" line="1013"/>
                    <declaration name="idx" type="int" line="1015"/>
                </method>
                <method name="initIndexByTag" type="void" line="1021">
                    <params>
                        <param name="tag" type="byte"/>
                        <param name="ix" type="Index"/>
                    </params>
                    <comment line="1023">
                        do not init twice                        
                    </comment>
                    <comment line="1026">
                        It must be a homogeneous Entry set.                        
                    </comment>
                    <comment line="1030">
                        Special case:  First Utf8 must always be empty string.                        
                    </comment>
                    <comment line="1034">
                        decache indexes derived from this one:                        
                    </comment>
                    <declaration name="cpMap" type="Entry[]" line="1023"/>
                    <scope line="1024"/>
                    <scope line="1028"/>
                </method>
                <javadoc line="1040">
                    Index of all CP entries of a given tag.                    
                </javadoc>
                <method name="getIndexByTag" type="Index" line="1041">
                    <params>
                        <param name="tag" type="byte"/>
                    </params>
                    <comment line="1048">
                        Make an empty one by default.                        
                    </comment>
                    <scope line="1042"/>
                    <declaration name="ix" type="Index" line="1045"/>
                    <scope line="1046"/>
                </method>
                <javadoc line="1054">
                    Index of all CP entries of a given tag and class.                    
                </javadoc>
                <method name="getMemberIndex" type="Index" line="1055">
                    <params>
                        <param name="tag" type="byte"/>
                        <param name="classRef" type="ClassEntry"/>
                    </params>
                    <comment line="1062">
                        Create the partition now.
                         Divide up all entries of the given tag according to their class.                        
                    </comment>
                    <declaration name="allClasses" type="Index" line="1058"/>
                    <declaration name="perClassIndexes" type="Index[]" line="1059"/>
                    <scope line="1060">
                        <declaration name="allMembers" type="Index" line="1063"/>
                        <declaration name="whichClasses" type="int[]" line="1064"/>
                        <scope line="1065">
                            <declaration name="e" type="MemberEntry" line="1066"/>
                            <declaration name="whichClass" type="int" line="1067"/>
                        </scope>
                        <scope line="1071"/>
                    </scope>
                    <declaration name="whichClass" type="int" line="1077"/>
                </method>
                <method name="getOverloadingIndex" type="int" line="1083">
                    <params>
                        <param name="methodRef" type="MemberEntry"/>
                    </params>
                    <comment line="1093">
                        Found a different overloading.  Increment the ordinal.                        
                    </comment>
                    <declaration name="ix" type="Index" line="1084"/>
                    <declaration name="nameRef" type="Utf8Entry" line="1085"/>
                    <declaration name="ord" type="int" line="1086"/>
                    <scope line="1087">
                        <declaration name="e" type="MemberEntry" line="1088"/>
                    </scope>
                </method>
                <method name="getOverloadingForIndex" type="MemberEntry" line="1099">
                    <params>
                        <param name="tag" type="byte"/>
                        <param name="classRef" type="ClassEntry"/>
                        <param name="name" type="String"/>
                        <param name="which" type="int"/>
                    </params>
                    <declaration name="ix" type="Index" line="1101"/>
                    <declaration name="ord" type="int" line="1102"/>
                    <scope line="1103">
                        <declaration name="e" type="MemberEntry" line="1104"/>
                        <scope line="1105"/>
                    </scope>
                </method>
                <method name="haveNumbers" type="boolean" line="1113">
                    <scope line="1114"/>
                </method>
            </class>
            <javadoc line="1131">
                Close the set cpRefs under the getRef() relation.
                  Also, if flattenSigs, replace all signatures in cpRefs
                  by their equivalent Utf8s.
                  Also, discard null from cpRefs.                
            </javadoc>
            <method name="completeReferencesIn" type="void" line="1137">
                <params>
                    <param name="cpRefs" type="Set<Entry>"/>
                    <param name="flattenSigs" type="boolean"/>
                </params>
                <comment line="1144">
                    pop stack                    
                </comment>
                <comment line="1149">
                    Totally replace e by se.                    
                </comment>
                <comment line="1152">
                    do not descend into the sig                    
                </comment>
                <comment line="1154">
                    Recursively add the refs of e to cpRefs:                    
                </comment>
                <comment line="1158">
                    no more refs in e                    
                </comment>
                <comment line="1159">
                    output the ref                    
                </comment>
                <comment line="1160">
                    push stack, if a new ref                    
                </comment>
                <scope line="1141">
                    <declaration name="e" type="Entry" line="1142"/>
                    <scope line="1145">
                        <declaration name="se" type="SignatureEntry" line="1146"/>
                        <declaration name="ue" type="Utf8Entry" line="1147"/>
                    </scope>
                    <scope line="1154">
                        <declaration name="re" type="Entry" line="1155"/>
                    </scope>
                </scope>
            </method>
            <method name="percent" type="double" line="1164">
                <params>
                    <param name="num" type="int"/>
                    <param name="den" type="int"/>
                </params>
            </method>
            <method name="tagName" type="String" line="1168">
                <params>
                    <param name="tag" type="int"/>
                </params>
                <comment line="1183">
                    pseudo-tags:                    
                </comment>
            </method>
            <declaration name="TAGS_IN_ORDER" type="byte" line="1191"/>
            <declaration name="TAG_ORDER" type="byte" line="1205"/>
            <scope line="1206">
                <scope line="1208"/>
            </scope>
        </class>
    </source>