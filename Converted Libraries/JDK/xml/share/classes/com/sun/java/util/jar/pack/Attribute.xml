<?xml version="1.0" encoding="UTF-8"?>
    <source package="com.sun.java.util.jar.pack">
        <import package="com.sun.java.util.jar.pack.ConstantPool.Entry"/>
        <import package="com.sun.java.util.jar.pack.ConstantPool.Index"/>
        <import package="java.io.ByteArrayOutputStream"/>
        <import package="java.io.IOException"/>
        <import package="java.util.ArrayList"/>
        <import package="java.util.Arrays"/>
        <import package="java.util.Collection"/>
        <import package="java.util.Collections"/>
        <import package="java.util.HashMap"/>
        <import package="java.util.List"/>
        <import package="java.util.Map"/>
        <import package="com.sun.java.util.jar.pack.Constants"/>
        <class name="Attribute" line="41">
            <comment line="50">
                Attribute instance fields.                
            </comment>
            <comment line="52">
                the name and format of this attr                
            </comment>
            <comment line="53">
                the actual bytes                
            </comment>
            <comment line="54">
                reference relocations, if any are required                
            </comment>
            <comment line="112">
                Canonicalized lists of trivial attrs (Deprecated, etc.)
                 are used by trimToSize, in order to reduce footprint
                 of some common cases.  (Note that Code attributes are
                 always zero size.)                
            </comment>
            <comment line="129">
                Find the canonical empty attribute with the given ctype, name, layout.                
            </comment>
            <comment line="146">
                Find canonical empty attribute with given ctype and name,
                 and with the standard layout.                
            </comment>
            <comment line="210">
                Metadata.
                
                 We define metadata using similar layouts
                 for all five kinds of metadata attributes.
                
                 Regular annotations are a counted list of [RSHNH[RUH(1)]][...]
                   pack.method.attribute.RuntimeVisibleAnnotations=[NH[(1)]][RSHNH[RUH(1)]][TB...]
                
                 Parameter annotations are a counted list of regular annotations.
                   pack.method.attribute.RuntimeVisibleParameterAnnotations=[NH[(1)]][NH[(1)]][RSHNH[RUH(1)]][TB...]
                
                 RuntimeInvisible annotations are defined similarly...
                 Non-method annotations are defined similarly...
                
                 Annotation are a simple tagged value [TB...]
                   pack.attribute.method.AnnotationDefault=[TB...]                
            </comment>
            <comment line="413">
                Lightweight interface to hide details of band structure.
                 Also used for testing.                
            </comment>
            <comment line="430">
                Element kinds:                
            </comment>
            <comment line="431">
                B H I SH etc.                
            </comment>
            <comment line="432">
                PH POH etc.                
            </comment>
            <comment line="433">
                OH etc.                
            </comment>
            <comment line="434">
                FH etc.                
            </comment>
            <comment line="435">
                NH[...] etc.                
            </comment>
            <comment line="436">
                RUH, RUNH, KQH, etc.                
            </comment>
            <comment line="437">
                TB(...)[...] etc.                
            </comment>
            <comment line="438">
                (...)[...] etc.                
            </comment>
            <comment line="439">
                (0), (1), etc.                
            </comment>
            <comment line="440">
                [...][...] etc.                
            </comment>
            <comment line="441">
                INT is signed                
            </comment>
            <comment line="442">
                BCI/BCI value is diff&apos;ed w/ previous                
            </comment>
            <comment line="443">
                null REF is expected/allowed                
            </comment>
            <comment line="444">
                call, callable, case is backward                
            </comment>
            <comment line="778">
                / Subroutines for parsing and unparsing:                
            </comment>
            <comment line="1194">
                Parse attribute bytes, putting values into bands.  Returns new pos.
                 Used when reading a class file (local refs resolved with local cpMap).
                 Also used for ad hoc scanning.                
            </comment>
            <comment line="1328">
                Format attribute bytes, drawing values from bands.
                 Used when emptying attribute bands into a package model.
                 (At that point CP refs. are not yet assigned indexes.)                
            </comment>
            <comment line="1435">
                Testing.
                public static void main(String av[]) {
                int maxVal = 12;
                int iters = 0;
                boolean verbose;
                int ap = 0;
                while (ap &lt; av.length) {
                if (!av[ap].startsWith(&quot;-&quot;))  break;
                if (av[ap].startsWith(&quot;-m&quot;))
                maxVal = Integer.parseInt(av[ap].substring(2));
                else if (av[ap].startsWith(&quot;-i&quot;))
                iters = Integer.parseInt(av[ap].substring(2));
                else
                throw new RuntimeException(&quot;Bad option: &quot;+av[ap]);
                ap++;
                }
                verbose = (iters == 0);
                if (iters &lt;= 0)  iters = 1;
                if (ap == av.length) {
                av = new String[] {
                &quot;HH&quot;,          ClassFile.version
                &quot;RUH&quot;,         SourceFile
                &quot;RCHRDNH&quot;,     EnclosingMethod
                &quot;KQH&quot;,         ConstantValue
                &quot;NH[RCH]&quot;,     Exceptions
                &quot;NH[PHH]&quot;,     LineNumberTable
                &quot;NH[PHOHRUHRSHH]&quot;,       LocalVariableTable
                &quot;NH[PHPOHIIH]&quot;,          CharacterRangeTable
                &quot;NH[PHHII]&quot;,             CoverageTable
                &quot;NH[RCHRCNHRUNHFH]&quot;,     InnerClasses
                &quot;HHNI[B]NH[PHPOHPOHRCNH]NH[RUHNI[B]]&quot;,  Code
                &quot;=AnnotationDefault&quot;,
                 Like metadata, but with a compact tag set:
                &quot;[NH[(1)]]&quot;
                +&quot;[NH[(2)]]&quot;
                +&quot;[RSHNH[RUH(3)]]&quot;
                +&quot;[TB(0,1,3)[KIH](2)[KDH](5)[KFH](4)[KJH](7)[RSH](8)[RSHRUH](9)[RUH](10)[(2)](6)[NH[(3)]]()[]]&quot;,
                &quot;&quot;
                };
                ap = 0;
                }
                final int[][] counts = new int[2][3];   int bci ref
                final Entry[] cpMap = new Entry[maxVal+1];
                for (int i = 0; i &lt; cpMap.length; i++) {
                if (i == 0)  continue;   0 =&gt; null
                cpMap[i] = ConstantPool.getLiteralEntry(new Integer(i));
                }
                Class cls = new Package().new Class(&quot;&quot;);
                cls.cpMap = cpMap;
                class TestValueStream extends ValueStream {
                Random rand = new Random(0);
                ArrayList history = new ArrayList();
                int ckidx = 0;
                int maxVal;
                boolean verbose;
                void reset() { history.clear(); ckidx = 0; }
                public int getInt(int bandIndex) {
                counts[0][0]++;
                int value = rand.nextInt(maxVal+1);
                history.add(new Integer(bandIndex));
                history.add(new Integer(value));
                return value;
                }
                public void putInt(int bandIndex, int token) {
                counts[1][0]++;
                if (verbose)
                System.out.print(&quot; &quot;+bandIndex+&quot;:&quot;+token);
                 Make sure this put parallels a previous get:
                int check0 = ((Integer)history.get(ckidx+0)).intValue();
                int check1 = ((Integer)history.get(ckidx+1)).intValue();
                if (check0 != bandIndex || check1 != token) {
                if (!verbose)
                System.out.println(history.subList(0, ckidx));
                System.out.println(&quot;  Should be &quot;+check0+&quot;:&quot;+check1);
                throw new RuntimeException(&quot;Failed test!&quot;);
                }
                ckidx += 2;
                }
                public Entry getRef(int bandIndex) {
                counts[0][2]++;
                int value = getInt(bandIndex);
                if (value &lt; 0 || value &gt; maxVal) {
                System.out.println(&quot;  Unexpected ref code &quot;+value);
                return ConstantPool.getLiteralEntry(new Integer(value));
                }
                return cpMap[value];
                }
                public void putRef(int bandIndex, Entry ref) {
                counts[1][2]++;
                if (ref == null) {
                putInt(bandIndex, 0);
                return;
                }
                Number refValue = null;
                if (ref instanceof ConstantPool.NumberEntry)
                refValue = ((ConstantPool.NumberEntry)ref).numberValue();
                int value;
                if (!(refValue instanceof Integer)) {
                System.out.println(&quot;  Unexpected ref &quot;+ref);
                value = -1;
                } else {
                value = ((Integer)refValue).intValue();
                }
                putInt(bandIndex, value);
                }
                public int encodeBCI(int bci) {
                counts[1][1]++;
                 move LSB to MSB of low byte
                int code = (bci &gt;&gt; 8) &lt;&lt; 8;   keep high bits
                code += (bci &amp; 0xFE) &gt;&gt; 1;
                code += (bci &amp; 0x01) &lt;&lt; 7;
                return code ^ (8&lt;&lt;8);   mark it clearly as coded
                }
                public int decodeBCI(int bciCode) {
                counts[0][1]++;
                bciCode ^= (8&lt;&lt;8);   remove extra mark
                int bci = (bciCode &gt;&gt; 8) &lt;&lt; 8;   keep high bits
                bci += (bciCode &amp; 0x7F) &lt;&lt; 1;
                bci += (bciCode &amp; 0x80) &gt;&gt; 7;
                return bci;
                }
                }
                TestValueStream tts = new TestValueStream();
                tts.maxVal = maxVal;
                tts.verbose = verbose;
                ByteArrayOutputStream buf = new ByteArrayOutputStream();
                for (int i = 0; i &lt; (1 &lt;&lt; 30); i = (i + 1)  5) {
                int ei = tts.encodeBCI(i);
                int di = tts.decodeBCI(ei);
                if (di != i)  System.out.println(&quot;i=&quot;+Integer.toHexString(i)+
                &quot; ei=&quot;+Integer.toHexString(ei)+
                &quot; di=&quot;+Integer.toHexString(di));
                }
                while (iters-- &gt; 0) {
                for (int i = ap; i &lt; av.length; i++) {
                String layout = av[i];
                if (layout.startsWith(&quot;=&quot;)) {
                String name = layout.substring(1);
                for (Iterator j = standardDefs.values().iterator(); j.hasNext(); ) {
                Attribute a = (Attribute) j.next();
                if (a.name().equals(name)) {
                layout = a.layout().layout();
                break;
                }
                }
                if (layout.startsWith(&quot;=&quot;)) {
                System.out.println(&quot;Could not find &quot;+name+&quot; in &quot;+standardDefs.values());
                }
                }
                Layout self = new Layout(0, &quot;Foo&quot;, layout);
                if (verbose) {
                System.out.print(&quot;&quot;+layout+&quot; =&gt; &quot;);
                System.out.println(Arrays.asList(self.elems));
                }
                buf.reset();
                tts.reset();
                Object fixups = self.unparse(tts, buf);
                byte[] bytes = buf.toByteArray();
                 Attach the references to the byte array.
                Fixups.setBytes(fixups, bytes);
                 Patch the references to their frozen values.
                Fixups.finishRefs(fixups, bytes, new Index(&quot;test&quot;, cpMap));
                if (verbose) {
                System.out.print(&quot;  bytes: {&quot;);
                for (int j = 0; j &lt; bytes.length; j++) {
                System.out.print(&quot; &quot;+bytes[j]);
                }
                System.out.println(&quot;}&quot;);
                }
                if (verbose) {
                System.out.print(&quot;  parse: {&quot;);
                }
                self.parse(0, cls, bytes, 0, bytes.length, tts);
                if (verbose) {
                System.out.println(&quot;}&quot;);
                }
                }
                }
                for (int j = 0; j &lt;= 1; j++) {
                System.out.print(&quot;values &quot;+(j==0?&quot;read&quot;:&quot;written&quot;)+&quot;: {&quot;);
                for (int k = 0; k &lt; counts[j].length; k++) {
                System.out.print(&quot; &quot;+counts[j][k]);
                }
                System.out.println(&quot; }&quot;);
                }
                }                
            </comment>
            <implements interface="Comparable"/>
            <javadoc line="41">
                Represents an attribute in a class-file.
                  Takes care to remember where constant pool indexes occur.
                  Implements the &quot;little language&quot; of Pack200 for describing
                  attribute layouts.                
                <author>
                    John Rose                    
                </author>
            </javadoc>
            <declaration name="def" type="Layout" line="51"/>
            <declaration name="bytes" type="byte[]" line="52"/>
            <declaration name="fixups" type="Object" line="53"/>
            <method name="name" type="String" line="55"/>
            <method name="layout" type="Layout" line="56"/>
            <method name="bytes" type="byte[]" line="57"/>
            <method name="size" type="int" line="58"/>
            <method name="getNameRef" type="Entry" line="59"/>
            <method name="Attribute" type="constructor" line="61">
                <params>
                    <param name="old" type="Attribute"/>
                </params>
            </method>
            <method name="Attribute" type="constructor" line="67">
                <params>
                    <param name="def" type="Layout"/>
                    <param name="bytes" type="byte[]"/>
                    <param name="fixups" type="Object"/>
                </params>
            </method>
            <method name="Attribute" type="constructor" line="73">
                <params>
                    <param name="def" type="Layout"/>
                    <param name="bytes" type="byte[]"/>
                </params>
            </method>
            <method name="addContent" type="Attribute" line="77">
                <params>
                    <param name="bytes" type="byte[]"/>
                    <param name="fixups" type="Object"/>
                </params>
                <declaration name="res" type="Attribute" line="81"/>
            </method>
            <method name="addContent" type="Attribute" line="87">
                <params>
                    <param name="bytes" type="byte[]"/>
                </params>
            </method>
            <method name="finishRefs" type="void" line="91">
                <params>
                    <param name="ix" type="Index"/>
                </params>
                <scope line="92"/>
            </method>
            <method name="isCanonical" type="boolean" line="98"/>
            <method name="compareTo" type="int" line="102">
                <params>
                    <param name="o" type="Object"/>
                </params>
                <declaration name="that" type="Attribute" line="103"/>
            </method>
            <declaration name="canonLists" type="Map&lt;List&lt;Attribute&gt;,List&lt;Attribute&gt;&gt;" line="107"/>
            <declaration name="attributes" type="Map&lt;Layout,Attribute&gt;" line="108"/>
            <declaration name="standardDefs" type="Map&lt;Layout,Attribute&gt;" line="109"/>
            <method name="getCanonList" type="List<Attribute>" line="115">
                <params>
                    <param name="al" type="List<Attribute>"/>
                </params>
                <scope line="116">
                    <declaration name="cl" type="List&lt;Attribute&gt;" line="117"/>
                    <scope line="118"/>
                </scope>
            </method>
            <method name="find" type="Attribute" line="129">
                <params>
                    <param name="ctype" type="int"/>
                    <param name="name" type="String"/>
                    <param name="layout" type="String"/>
                </params>
                <declaration name="key" type="Layout" line="130"/>
                <scope line="131">
                    <declaration name="a" type="Attribute" line="132"/>
                    <scope line="133"/>
                </scope>
            </method>
            <method name="keyForLookup" type="Layout" line="141">
                <params>
                    <param name="ctype" type="int"/>
                    <param name="name" type="String"/>
                </params>
            </method>
            <method name="lookup" type="Attribute" line="148">
                <params>
                    <param name="defs" type="Map<Layout,Attribute>"/>
                    <param name="ctype" type="int"/>
                    <param name="name" type="String"/>
                </params>
                <scope line="149"/>
            </method>
            <method name="define" type="Attribute" line="156">
                <params>
                    <param name="defs" type="Map<Layout,Attribute>"/>
                    <param name="ctype" type="int"/>
                    <param name="name" type="String"/>
                    <param name="layout" type="String"/>
                </params>
                <declaration name="a" type="Attribute" line="157"/>
            </method>
            <scope line="162">
                <declaration name="sd" type="Map&lt;Layout,Attribute&gt;" line="163"/>
            </scope>
            <scope line="226">
                <declaration name="mdLayouts" type="String" line="227"/>
                <declaration name="sd" type="Map&lt;Layout,Attribute&gt;" line="259"/>
                <declaration name="defaultLayout" type="String" line="260"/>
                <declaration name="annotationsLayout" type="String" line="261"/>
                <declaration name="paramsLayout" type="String" line="262"/>
                <scope line="263">
                    <scope line="269"/>
                </scope>
            </scope>
            <method name="contextName" type="String" line="280">
                <params>
                    <param name="ctype" type="int"/>
                </params>
            </method>
            <class name="Holder" line="290">
                <comment line="299">
                    We need this abstract method to interpret embedded CP refs.                    
                </comment>
                <comment line="302">
                    defined here for convenience                    
                </comment>
                <comment line="421">
                    Note:  decodeBCI goes w/ getInt/Ref; encodeBCI goes w/ putInt/Ref                    
                </comment>
                <comment line="452">
                    attribute context type, e.g., ATTR_CONTEXT_CODE                    
                </comment>
                <comment line="453">
                    name of attribute                    
                </comment>
                <comment line="454">
                    this kind of attr contains CP refs?                    
                </comment>
                <comment line="455">
                    layout specification                    
                </comment>
                <comment line="456">
                    total number of elems                    
                </comment>
                <comment line="457">
                    tokenization of layout                    
                </comment>
                <comment line="458">
                    canonical instance of this layout                    
                </comment>
                <comment line="840">
                    private                    
                </comment>
                <comment line="848">
                    private                    
                </comment>
                <comment line="1059">
                    private                    
                </comment>
                <comment line="1117">
                    private                    
                </comment>
                <javadoc line="290">
                    Base class for any attributed object (Class, Field, Method, Code).
                      Flags are included because they are used to help transmit the
                      presence of attributes.  That is, flags are a mix of modifier
                      bits and attribute indicators.                    
                </javadoc>
                <method name="getCPMap" type="Entry[]" line="299"/>
                <declaration name="flags" type="int" line="301"/>
                <declaration name="attributes" type="List&lt;Attribute&gt;" line="302"/>
                <method name="attributeSize" type="int" line="304"/>
                <method name="trimToSize" type="void" line="308">
                    <comment line="331">
                        Replace private writable attribute list
                         with only trivial entries by public unique
                         immutable attribute list with the same entries.                        
                    </comment>
                    <scope line="309"/>
                    <scope line="312"/>
                    <scope line="316">
                        <declaration name="al" type="ArrayList&lt;Attribute&gt;" line="317"/>
                        <declaration name="allCanon" type="boolean" line="319"/>
                        <scope line="320">
                            <scope line="321"/>
                            <scope line="324"/>
                        </scope>
                        <scope line="329"/>
                    </scope>
                </method>
                <method name="addAttribute" type="void" line="338">
                    <params>
                        <param name="a" type="Attribute"/>
                    </params>
                    <comment line="343">
                        unfreeze it                        
                    </comment>
                </method>
                <method name="removeAttribute" type="Attribute" line="346">
                    <params>
                        <param name="a" type="Attribute"/>
                    </params>
                    <comment line="351">
                        unfreeze it                        
                    </comment>
                </method>
                <method name="getAttribute" type="Attribute" line="355">
                    <params>
                        <param name="n" type="int"/>
                    </params>
                </method>
                <method name="visitRefs" type="void" line="359">
                    <params>
                        <param name="mode" type="int"/>
                        <param name="refs" type="Collection<Entry>"/>
                    </params>
                    <scope line="361"/>
                </method>
                <declaration name="noAttributes" type="List&lt;Attribute&gt;" line="366"/>
                <method name="getAttributes" type="List<Attribute>" line="368"/>
                <method name="setAttributes" type="void" line="374">
                    <params>
                        <param name="attrList" type="List<Attribute>"/>
                    </params>
                </method>
                <method name="getAttribute" type="Attribute" line="381">
                    <params>
                        <param name="attrName" type="String"/>
                    </params>
                    <scope line="383"/>
                </method>
                <method name="getAttribute" type="Attribute" line="390">
                    <params>
                        <param name="attrDef" type="Layout"/>
                    </params>
                    <scope line="392"/>
                </method>
                <method name="removeAttribute" type="Attribute" line="399">
                    <params>
                        <param name="attrName" type="String"/>
                    </params>
                </method>
                <method name="removeAttribute" type="Attribute" line="403">
                    <params>
                        <param name="attrDef" type="Layout"/>
                    </params>
                </method>
                <method name="strip" type="void" line="407">
                    <params>
                        <param name="attrName" type="String"/>
                    </params>
                </method>
            </class>
            <class name="ValueStream" line="414">
                <comment line="299">
                    We need this abstract method to interpret embedded CP refs.                    
                </comment>
                <comment line="302">
                    defined here for convenience                    
                </comment>
                <comment line="421">
                    Note:  decodeBCI goes w/ getInt/Ref; encodeBCI goes w/ putInt/Ref                    
                </comment>
                <comment line="452">
                    attribute context type, e.g., ATTR_CONTEXT_CODE                    
                </comment>
                <comment line="453">
                    name of attribute                    
                </comment>
                <comment line="454">
                    this kind of attr contains CP refs?                    
                </comment>
                <comment line="455">
                    layout specification                    
                </comment>
                <comment line="456">
                    total number of elems                    
                </comment>
                <comment line="457">
                    tokenization of layout                    
                </comment>
                <comment line="458">
                    canonical instance of this layout                    
                </comment>
                <comment line="840">
                    private                    
                </comment>
                <comment line="848">
                    private                    
                </comment>
                <comment line="1059">
                    private                    
                </comment>
                <comment line="1117">
                    private                    
                </comment>
                <method name="getInt" type="int" line="416">
                    <params>
                        <param name="bandIndex" type="int"/>
                    </params>
                </method>
                <method name="putInt" type="void" line="417">
                    <params>
                        <param name="bandIndex" type="int"/>
                        <param name="value" type="int"/>
                    </params>
                </method>
                <method name="getRef" type="Entry" line="418">
                    <params>
                        <param name="bandIndex" type="int"/>
                    </params>
                </method>
                <method name="putRef" type="void" line="419">
                    <params>
                        <param name="bandIndex" type="int"/>
                        <param name="ref" type="Entry"/>
                    </params>
                </method>
                <method name="decodeBCI" type="int" line="421">
                    <params>
                        <param name="bciCode" type="int"/>
                    </params>
                </method>
                <method name="encodeBCI" type="int" line="422">
                    <params>
                        <param name="bci" type="int"/>
                    </params>
                </method>
                <method name="noteBackCall" type="void" line="423">
                    <params>
                        <param name="whichCallable" type="int"/>
                    </params>
                </method>
                <method name="undef" type="RuntimeException" line="424"/>
            </class>
            <declaration name="EK_INT" type="byte" line="430"/>
            <declaration name="EK_BCI" type="byte" line="431"/>
            <declaration name="EK_BCO" type="byte" line="432"/>
            <declaration name="EK_FLAG" type="byte" line="433"/>
            <declaration name="EK_REPL" type="byte" line="434"/>
            <declaration name="EK_REF" type="byte" line="435"/>
            <declaration name="EK_UN" type="byte" line="436"/>
            <declaration name="EK_CASE" type="byte" line="437"/>
            <declaration name="EK_CALL" type="byte" line="438"/>
            <declaration name="EK_CBLE" type="byte" line="439"/>
            <declaration name="EF_SIGN" type="byte" line="440"/>
            <declaration name="EF_DELTA" type="byte" line="441"/>
            <declaration name="EF_NULL" type="byte" line="442"/>
            <declaration name="EF_BACK" type="byte" line="443"/>
            <declaration name="NO_BAND_INDEX" type="int" line="444"/>
            <class name="Layout" line="446">
                <comment line="299">
                    We need this abstract method to interpret embedded CP refs.                    
                </comment>
                <comment line="302">
                    defined here for convenience                    
                </comment>
                <comment line="421">
                    Note:  decodeBCI goes w/ getInt/Ref; encodeBCI goes w/ putInt/Ref                    
                </comment>
                <comment line="452">
                    attribute context type, e.g., ATTR_CONTEXT_CODE                    
                </comment>
                <comment line="453">
                    name of attribute                    
                </comment>
                <comment line="454">
                    this kind of attr contains CP refs?                    
                </comment>
                <comment line="455">
                    layout specification                    
                </comment>
                <comment line="456">
                    total number of elems                    
                </comment>
                <comment line="457">
                    tokenization of layout                    
                </comment>
                <comment line="458">
                    canonical instance of this layout                    
                </comment>
                <comment line="840">
                    private                    
                </comment>
                <comment line="848">
                    private                    
                </comment>
                <comment line="1059">
                    private                    
                </comment>
                <comment line="1117">
                    private                    
                </comment>
                <implements interface="Comparable"/>
                <javadoc line="446">
                    A &quot;class&quot; of attributes, characterized by a context-type, name
                      and format.  The formats are specified in a &quot;little language&quot;.                    
                </javadoc>
                <declaration name="ctype" type="int" line="451"/>
                <declaration name="name" type="String" line="452"/>
                <declaration name="hasRefs" type="boolean" line="453"/>
                <declaration name="layout" type="String" line="454"/>
                <declaration name="bandCount" type="int" line="455"/>
                <declaration name="elems" type="Element[]" line="456"/>
                <declaration name="canon" type="Attribute" line="457"/>
                <method name="ctype" type="int" line="459"/>
                <method name="name" type="String" line="460"/>
                <method name="layout" type="String" line="461"/>
                <method name="canonicalInstance" type="Attribute" line="462"/>
                <method name="getNameRef" type="Entry" line="464"/>
                <method name="isEmpty" type="boolean" line="468"/>
                <method name="Layout" type="constructor" line="472">
                    <params>
                        <param name="ctype" type="int"/>
                        <param name="name" type="String"/>
                        <param name="layout" type="String"/>
                    </params>
                    <comment line="484">
                        Make the callables now, so they can be linked immediately.                        
                    </comment>
                    <comment line="495">
                        Next fill them in.                        
                    </comment>
                    <comment line="500">
                        System.out.println(Arrays.asList(elems));                        
                    </comment>
                    <comment line="503">
                        simplest way to catch syntax errors...                        
                    </comment>
                    <comment line="506">
                        Some uses do not make a fresh one for each occurrence.
                         For example, if layout == &quot;&quot;, we only need one attr to share.                        
                    </comment>
                    <declaration name="hasCallables" type="boolean" line="477"/>
                    <scope line="478">
                        <scope line="479"/>
                        <scope line="481">
                            <declaration name="bodies" type="String[]" line="482"/>
                            <declaration name="lelems" type="Element[]" line="484"/>
                            <scope line="486">
                                <declaration name="ce" type="Element" line="487"/>
                            </scope>
                            <scope line="495">
                                <declaration name="ce" type="Element" line="496"/>
                            </scope>
                        </scope>
                    </scope>
                    <scope line="501"/>
                </method>
                <method name="Layout" type="constructor" line="509"/>
                <method name="makeKey" type="Layout" line="510">
                    <params>
                        <param name="ctype" type="int"/>
                        <param name="name" type="String"/>
                        <param name="layout" type="String"/>
                    </params>
                    <declaration name="def" type="Layout" line="511"/>
                </method>
                <method name="makeKey" type="Layout" line="518">
                    <params>
                        <param name="ctype" type="int"/>
                        <param name="name" type="String"/>
                    </params>
                </method>
                <method name="addContent" type="Attribute" line="522">
                    <params>
                        <param name="bytes" type="byte[]"/>
                        <param name="fixups" type="Object"/>
                    </params>
                </method>
                <method name="addContent" type="Attribute" line="525">
                    <params>
                        <param name="bytes" type="byte[]"/>
                    </params>
                </method>
                <method name="equals" type="boolean" line="529">
                    <params>
                        <param name="x" type="Object"/>
                    </params>
                </method>
                <method name="equals" type="boolean" line="533">
                    <params>
                        <param name="that" type="Layout"/>
                    </params>
                </method>
                <method name="hashCode" type="int" line="538"/>
                <method name="compareTo" type="int" line="543">
                    <params>
                        <param name="o" type="Object"/>
                    </params>
                    <declaration name="that" type="Layout" line="544"/>
                    <declaration name="r" type="int" line="545"/>
                </method>
                <method name="toString" type="String" line="552">
                    <comment line="555">
                        If -ea, print out more informative strings!                        
                    </comment>
                    <declaration name="str" type="String" line="553"/>
                </method>
                <method name="stringForDebug" type="String" line="558"/>
                <class name="Element" line="562">
                    <comment line="565">
                        spelling in the little language                        
                    </comment>
                    <comment line="566">
                        EF_SIGN, etc.                        
                    </comment>
                    <comment line="567">
                        EK_UINT, etc.                        
                    </comment>
                    <comment line="568">
                        scalar length of element                        
                    </comment>
                    <comment line="569">
                        CONSTANT_String, etc.                        
                    </comment>
                    <comment line="570">
                        which band does this element govern?                        
                    </comment>
                    <comment line="571">
                        extra parameter                        
                    </comment>
                    <comment line="572">
                        extra data (for replications, unions, calls)                        
                    </comment>
                    <declaration name="layout" type="String" line="564"/>
                    <declaration name="flags" type="byte" line="565"/>
                    <declaration name="kind" type="byte" line="566"/>
                    <declaration name="len" type="byte" line="567"/>
                    <declaration name="refKind" type="byte" line="568"/>
                    <declaration name="bandIndex" type="int" line="569"/>
                    <declaration name="value" type="int" line="570"/>
                    <declaration name="body" type="Element[]" line="571"/>
                    <method name="flagTest" type="boolean" line="573">
                        <params>
                            <param name="mask" type="byte"/>
                        </params>
                    </method>
                    <method name="Element" type="constructor" line="575"/>
                    <method name="removeBand" type="void" line="579"/>
                    <method name="hasBand" type="boolean" line="585"/>
                    <method name="toString" type="String" line="588">
                        <comment line="591">
                            If -ea, print out more informative strings!                            
                        </comment>
                        <declaration name="str" type="String" line="589"/>
                    </method>
                    <method name="stringForDebug" type="String" line="594">
                        <declaration name="lbody" type="Element[]" line="595"/>
                    </method>
                </class>
                <method name="hasCallables" type="boolean" line="614"/>
                <declaration name="noElems" type="Element[]" line="617"/>
                <method name="getCallables" type="Element[]" line="618">
                    <comment line="624">
                        no callables at all                        
                    </comment>
                    <scope line="619">
                        <declaration name="nelems" type="Element[]" line="620"/>
                    </scope>
                </method>
                <method name="getEntryPoint" type="Element[]" line="625">
                    <comment line="628">
                        body of first callable                        
                    </comment>
                    <comment line="631">
                        no callables; whole body                        
                    </comment>
                    <scope line="628">
                        <declaration name="nelems" type="Element[]" line="629"/>
                    </scope>
                </method>
                <javadoc line="634">
                    Return a sequence of tokens from the given attribute bytes.
                      Sequence elements will be 1-1 correspondent with my layout tokens.                    
                </javadoc>
                <method name="parse" type="void" line="638">
                    <params>
                        <param name="holder" type="Holder"/>
                        <param name="bytes" type="byte[]"/>
                        <param name="pos" type="int"/>
                        <param name="len" type="int"/>
                        <param name="out" type="ValueStream"/>
                    </params>
                    <declaration name="end" type="int" line="639"/>
                </method>
                <javadoc line="644">
                    Given a sequence of tokens, return the attribute bytes.
                      Sequence elements must be 1-1 correspondent with my layout tokens.
                      The returned object is a cookie for Fixups.finishRefs, which
                      must be used to harden any references into integer indexes.                    
                </javadoc>
                <method name="unparse" type="Object" line="649">
                    <params>
                        <param name="in" type="ValueStream"/>
                        <param name="out" type="ByteArrayOutputStream"/>
                    </params>
                    <comment line="653">
                        return ref-bearing cookie, if any                        
                    </comment>
                    <declaration name="fixups" type="Object[]" line="650"/>
                </method>
                <method name="layoutForPackageMajver" type="String" line="655">
                    <params>
                        <param name="majver" type="int"/>
                    </params>
                    <comment line="658">
                        Disallow layout syntax in the oldest protocol version.                        
                    </comment>
                    <scope line="656"/>
                </method>
            </class>
            <class name="FormatException" line="664">
                <extends class="IOException"/>
                <comment line="299">
                    We need this abstract method to interpret embedded CP refs.                    
                </comment>
                <comment line="302">
                    defined here for convenience                    
                </comment>
                <comment line="421">
                    Note:  decodeBCI goes w/ getInt/Ref; encodeBCI goes w/ putInt/Ref                    
                </comment>
                <comment line="452">
                    attribute context type, e.g., ATTR_CONTEXT_CODE                    
                </comment>
                <comment line="453">
                    name of attribute                    
                </comment>
                <comment line="454">
                    this kind of attr contains CP refs?                    
                </comment>
                <comment line="455">
                    layout specification                    
                </comment>
                <comment line="456">
                    total number of elems                    
                </comment>
                <comment line="457">
                    tokenization of layout                    
                </comment>
                <comment line="458">
                    canonical instance of this layout                    
                </comment>
                <comment line="840">
                    private                    
                </comment>
                <comment line="848">
                    private                    
                </comment>
                <comment line="1059">
                    private                    
                </comment>
                <comment line="1117">
                    private                    
                </comment>
                <declaration name="ctype" type="int" line="666"/>
                <declaration name="name" type="String" line="667"/>
                <declaration name="layout" type="String" line="668"/>
                <method name="FormatException" type="constructor" line="670">
                    <params>
                        <param name="message" type="String"/>
                        <param name="ctype" type="int"/>
                        <param name="name" type="String"/>
                        <param name="layout" type="String"/>
                    </params>
                </method>
                <method name="FormatException" type="constructor" line="678">
                    <params>
                        <param name="message" type="String"/>
                        <param name="ctype" type="int"/>
                        <param name="name" type="String"/>
                    </params>
                </method>
            </class>
            <method name="visitRefs" type="void" line="683">
                <params>
                    <param name="holder" type="Holder"/>
                    <param name="mode" type="int"/>
                    <param name="refs" type="Collection<Entry>"/>
                </params>
                <comment line="688">
                    else the name is owned by the layout, and is processed elsewhere                    
                </comment>
                <comment line="689">
                    quick exit                    
                </comment>
                <comment line="690">
                    quick exit                    
                </comment>
                <comment line="695">
                    References (to a local cpMap) are embedded in the bytes.                    
                </comment>
                <scope line="684"/>
                <scope line="690"/>
                <anonymous_class line="696">
                    <method name="putInt" type="void" line="697">
                        <params>
                            <param name="bandIndex" type="int"/>
                            <param name="value" type="int"/>
                        </params>
                    </method>
                    <method name="putRef" type="void" line="699">
                        <params>
                            <param name="bandIndex" type="int"/>
                            <param name="ref" type="Entry"/>
                        </params>
                    </method>
                    <method name="encodeBCI" type="int" line="702">
                        <params>
                            <param name="bci" type="int"/>
                        </params>
                    </method>
                </anonymous_class>
            </method>
            <method name="parse" type="void" line="708">
                <params>
                    <param name="holder" type="Holder"/>
                    <param name="bytes" type="byte[]"/>
                    <param name="pos" type="int"/>
                    <param name="len" type="int"/>
                    <param name="out" type="ValueStream"/>
                </params>
            </method>
            <method name="unparse" type="Object" line="711">
                <params>
                    <param name="in" type="ValueStream"/>
                    <param name="out" type="ByteArrayOutputStream"/>
                </params>
            </method>
            <method name="toString" type="String" line="715"/>
            <javadoc line="721">
                Remove any informal &quot;pretty printing&quot; from the layout string.
                  Removes blanks and control chars.
                  Removes &apos;#&apos; comments (to end of line).
                  Replaces &apos;\c&apos; by the decimal code of the character c.
                  Replaces &apos;0xNNN&apos; by the decimal code of the hex number NNN.                
            </javadoc>
            <method name="normalizeLayoutString" type="String" line="728">
                <params>
                    <param name="layout" type="String"/>
                </params>
                <comment line="734">
                    Skip whitespace and control chars                    
                </comment>
                <comment line="737">
                    Skip to end of line.                    
                </comment>
                <comment line="744">
                    Map a character reference to its decimal code.                    
                </comment>
                <comment line="747">
                    Map a hex numeral to its decimal code.                    
                </comment>
                <declaration name="buf" type="StringBuilder" line="729"/>
                <scope line="730">
                    <declaration name="ch" type="char" line="731"/>
                    <scope line="732"/>
                    <scope line="735">
                        <declaration name="end1" type="int" line="737"/>
                        <declaration name="end2" type="int" line="738"/>
                    </scope>
                    <scope line="742"/>
                    <scope line="745">
                        <declaration name="start" type="int" line="747"/>
                        <declaration name="end" type="int" line="748"/>
                        <scope line="749">
                            <declaration name="dig" type="int" line="750"/>
                        </scope>
                        <scope line="757">
                            <declaration name="num" type="String" line="758"/>
                        </scope>
                        <scope line="761"/>
                    </scope>
                    <scope line="764"/>
                </scope>
                <declaration name="result" type="String" line="768"/>
                <scope line="769"/>
            </method>
            <javadoc line="779">
                Parse the attribute layout language.
                  &lt;pre&gt;
                  attribute_layout:
                  ( layout_element ) | ( callable )+
                  layout_element:
                  ( integral | replication | union | call | reference )
                  callable:
                  &apos;[&apos; body &apos;]&apos;
                  body:
                  ( layout_element )+
                  integral:
                  ( unsigned_int | signed_int | bc_index | bc_offset | flag )
                  unsigned_int:
                  uint_type
                  signed_int:
                  &apos;S&apos; uint_type
                  any_int:
                  ( unsigned_int | signed_int )
                  bc_index:
                  ( &apos;P&apos; uint_type | &apos;PO&apos; uint_type )
                  bc_offset:
                  &apos;O&apos; any_int
                  flag:
                  &apos;F&apos; uint_type
                  uint_type:
                  ( &apos;B&apos; | &apos;H&apos; | &apos;I&apos; | &apos;V&apos; )
                  replication:
                  &apos;N&apos; uint_type &apos;[&apos; body &apos;]&apos;
                  union:
                  &apos;T&apos; any_int (union_case) &apos;(&apos; &apos;)&apos; &apos;[&apos; (body)? &apos;]&apos;
                  union_case:
                  &apos;(&apos; union_case_tag (&apos;,&apos; union_case_tag) &apos;)&apos; &apos;[&apos; (body)? &apos;]&apos;
                  union_case_tag:
                  ( numeral | numeral &apos;-&apos; numeral )
                  call:
                  &apos;(&apos; numeral &apos;)&apos;
                  reference:
                  reference_type ( &apos;N&apos; )? uint_type
                  reference_type:
                  ( constant_ref | schema_ref | utf8_ref | untyped_ref )
                  constant_ref:
                  ( &apos;KI&apos; | &apos;KJ&apos; | &apos;KF&apos; | &apos;KD&apos; | &apos;KS&apos; | &apos;KQ&apos; )
                  schema_ref:
                  ( &apos;RC&apos; | &apos;RS&apos; | &apos;RD&apos; | &apos;RF&apos; | &apos;RM&apos; | &apos;RI&apos; )
                  utf8_ref:
                  &apos;RU&apos;
                  untyped_ref:
                  &apos;RQ&apos;
                  numeral:
                  &apos;(&apos; (&apos;-&apos;)? (digit)+ &apos;)&apos;
                  digit:
                  ( &apos;0&apos; | &apos;1&apos; | &apos;2&apos; | &apos;3&apos; | &apos;4&apos; | &apos;5&apos; | &apos;6&apos; | &apos;7&apos; | &apos;8&apos; | &apos;9&apos; )
                  &lt;/pre&gt;                
            </javadoc>
            <method name="tokenizeLayout" type="Layout.Element[]" line="840">
                <params>
                    <param name="self" type="Layout"/>
                    <param name="curCble" type="int"/>
                    <param name="layout" type="String"/>
                </params>
                <comment line="840">
                    private                    
                </comment>
                <declaration name="col" type="List&lt;Layout.Element&gt;" line="841"/>
                <declaration name="res" type="Layout.Element[]" line="843"/>
            </method>
            <method name="tokenizeLayout" type="void" line="848">
                <params>
                    <param name="self" type="Layout"/>
                    <param name="curCble" type="int"/>
                    <param name="layout" type="String"/>
                    <param name="col" type="List<Layout.Element>"/>
                </params>
                <comment line="856">
                    System.out.println(&quot;at &quot;+i+&quot;: ...&quot;+layout.substring(i));
                     strip a prefix                    
                </comment>
                <comment line="859">
                    / layout_element: integral                    
                </comment>
                <comment line="860">
                    unsigned_int                    
                </comment>
                <comment line="862">
                    reparse                    
                </comment>
                <comment line="865">
                    signed_int                    
                </comment>
                <comment line="867">
                    reparse                    
                </comment>
                <comment line="870">
                    bc_index                    
                </comment>
                <comment line="873">
                    bc_index: &apos;PO&apos; tokenizeUInt                    
                </comment>
                <comment line="875">
                    must follow P or PO:                    
                </comment>
                <comment line="877">
                    fail                    
                </comment>
                <comment line="878">
                    move forward                    
                </comment>
                <comment line="880">
                    reparse                    
                </comment>
                <comment line="883">
                    bc_offset                    
                </comment>
                <comment line="886">
                    must follow P or PO:                    
                </comment>
                <comment line="888">
                    fail                    
                </comment>
                <comment line="891">
                    flag                    
                </comment>
                <comment line="895">
                    replication: &apos;N&apos; uint &apos;[&apos; elem ... &apos;]&apos;                    
                </comment>
                <comment line="899">
                    fail                    
                </comment>
                <comment line="904">
                    union: &apos;T&apos; any_int union_case* &apos;(&apos; &apos;)&apos; &apos;[&apos; body &apos;]&apos;                    
                </comment>
                <comment line="909">
                    Keep parsing cases until we hit the default case.                    
                </comment>
                <comment line="911">
                    fail                    
                </comment>
                <comment line="917">
                    fail                    
                </comment>
                <comment line="918">
                    Check for duplication.                    
                </comment>
                <comment line="920">
                    missing body, which is legal here                    
                </comment>
                <comment line="932">
                    done with the whole union                    
                </comment>
                <comment line="934">
                    Parse a case string.                    
                </comment>
                <comment line="937">
                    Look for multiple case tags:                    
                </comment>
                <comment line="942">
                    will fail parse                    
                </comment>
                <comment line="944">
                    Check for a case range (new in 1.6).                    
                </comment>
                <comment line="950">
                    fail                    
                </comment>
                <comment line="954">
                    Add a case for each value in value0..value1                    
                </comment>
                <comment line="957">
                    all cases share one body                    
                </comment>
                <comment line="961">
                    &quot;backward case&quot; repeats a body                    
                </comment>
                <comment line="969">
                    done with this case                    
                </comment>
                <comment line="980">
                    Duplicate tag.                    
                </comment>
                <comment line="981">
                    fail                    
                </comment>
                <comment line="985">
                    call: &apos;(&apos; &apos;-&apos;? digit+ &apos;)&apos;                    
                </comment>
                <comment line="996">
                    fail                    
                </comment>
                <comment line="1001">
                    Is it a (recursive) backward call?                    
                </comment>
                <comment line="1003">
                    Yes.  Mark both caller and callee backward.                    
                </comment>
                <comment line="1008">
                    reference_type: constant_ref                    
                </comment>
                <comment line="1017">
                    fail                    
                </comment>
                <comment line="1020">
                    schema_ref                    
                </comment>
                <comment line="1030">
                    utf8_ref                    
                </comment>
                <comment line="1031">
                    untyped_ref                    
                </comment>
                <comment line="1033">
                    fail                    
                </comment>
                <comment line="1036">
                    fail                    
                </comment>
                <comment line="1039">
                    further parsing of refs                    
                </comment>
                <comment line="1041">
                    reference: reference_type -&gt;&lt;- ( &apos;N&apos; )? tokenizeUInt                    
                </comment>
                <comment line="1044">
                    move forward                    
                </comment>
                <comment line="1046">
                    reparse                    
                </comment>
                <comment line="1053">
                    store the new element                    
                </comment>
                <declaration name="prevBCI" type="boolean" line="849"/>
                <scope line="850">
                    <declaration name="start" type="int" line="851"/>
                    <declaration name="body" type="int" line="852"/>
                    <declaration name="e" type="Layout.Element" line="853"/>
                    <declaration name="kind" type="byte" line="854"/>
                    <scope line="871">
                        <scope line="876"/>
                    </scope>
                    <scope line="887"/>
                    <scope line="898"/>
                    <declaration name="cases" type="List&lt;Layout.Element&gt;" line="906"/>
                    <scope line="907">
                        <scope line="910"/>
                        <declaration name="beg" type="int" line="911"/>
                        <declaration name="cstr" type="String" line="913"/>
                        <declaration name="cstrlen" type="int" line="914"/>
                        <scope line="916"/>
                        <declaration name="cbody" type="Layout.Element[]" line="922"/>
                        <scope line="925">
                            <declaration name="ce" type="Layout.Element" line="926"/>
                        </scope>
                        <scope line="932">
                            <declaration name="firstCaseNum" type="boolean" line="934"/>
                            <scope line="935">
                                <declaration name="cstr1" type="String" line="939"/>
                                <declaration name="value0" type="int" line="942"/>
                                <declaration name="dash" type="int" line="944"/>
                                <scope line="945">
                                    <scope line="949"/>
                                </scope>
                                <scope line="950"/>
                                <scope line="954">
                                    <declaration name="ce" type="Layout.Element" line="955"/>
                                </scope>
                                <scope line="967"/>
                            </scope>
                        </scope>
                    </scope>
                    <scope line="976">
                        <declaration name="ce" type="Layout.Element" line="977"/>
                        <scope line="978">
                            <scope line="980"/>
                        </scope>
                    </scope>
                    <declaration name="cstr" type="String" line="988"/>
                    <declaration name="offset" type="int" line="989"/>
                    <declaration name="target" type="int" line="990"/>
                    <scope line="995"/>
                    <declaration name="ce" type="Layout.Element" line="996"/>
                    <scope line="1001"/>
                    <scope line="1016"/>
                    <scope line="1032"/>
                    <scope line="1035"/>
                    <scope line="1039">
                        <scope line="1041"/>
                    </scope>
                </scope>
            </method>
            <method name="splitBodies" type="String[]" line="1059">
                <params>
                    <param name="layout" type="String"/>
                </params>
                <comment line="1062">
                    Parse several independent layout bodies:  &quot;[foo][bar]...[baz]&quot;                    
                </comment>
                <comment line="1065">
                    throw error                    
                </comment>
                <declaration name="bodies" type="List&lt;String&gt;" line="1060"/>
                <scope line="1062">
                    <declaration name="body" type="int" line="1065"/>
                </scope>
                <declaration name="res" type="String[]" line="1069"/>
            </method>
            <method name="skipBody" type="int" line="1074">
                <params>
                    <param name="layout" type="String"/>
                    <param name="i" type="int"/>
                </params>
                <comment line="1078">
                    No empty bodies, please.                    
                </comment>
                <comment line="1080">
                    skip balanced [...[...]...]                    
                </comment>
                <comment line="1087">
                    get before bracket                    
                </comment>
                <comment line="1089">
                    return closing bracket                    
                </comment>
                <scope line="1080"/>
            </method>
            <method name="tokenizeUInt" type="int" line="1091">
                <params>
                    <param name="e" type="Layout.Element"/>
                    <param name="layout" type="String"/>
                    <param name="i" type="int"/>
                </params>
            </method>
            <method name="tokenizeSInt" type="int" line="1102">
                <params>
                    <param name="e" type="Layout.Element"/>
                    <param name="layout" type="String"/>
                    <param name="i" type="int"/>
                </params>
                <scope line="1103"/>
            </method>
            <method name="isDigit" type="boolean" line="1111">
                <params>
                    <param name="c" type="char"/>
                </params>
            </method>
            <javadoc line="1115">
                Find an occurrence of hyphen &apos;-&apos; between two numerals.                
            </javadoc>
            <method name="findCaseDash" type="int" line="1117">
                <params>
                    <param name="layout" type="String"/>
                    <param name="fromIndex" type="int"/>
                </params>
                <comment line="1117">
                    private                    
                </comment>
                <comment line="1119">
                    minimum dash pos                    
                </comment>
                <comment line="1120">
                    maximum dash pos                    
                </comment>
                <comment line="1129">
                    matched /[0-9]--?[0-9]/; return position of dash                    
                </comment>
                <declaration name="lastDash" type="int" line="1119"/>
                <scope line="1120">
                    <declaration name="dash" type="int" line="1121"/>
                    <scope line="1123">
                        <declaration name="afterDash" type="char" line="1124"/>
                        <scope line="1127"/>
                    </scope>
                </scope>
            </method>
            <method name="parseIntBefore" type="int" line="1136">
                <params>
                    <param name="layout" type="String"/>
                    <param name="dash" type="int"/>
                </params>
                <comment line="1144">
                    skip backward over a sign                    
                </comment>
                <declaration name="end" type="int" line="1137"/>
                <declaration name="beg" type="int" line="1138"/>
                <scope line="1139"/>
            </method>
            <method name="parseIntAfter" type="int" line="1149">
                <params>
                    <param name="layout" type="String"/>
                    <param name="dash" type="int"/>
                </params>
                <declaration name="beg" type="int" line="1150"/>
                <declaration name="end" type="int" line="1151"/>
                <declaration name="limit" type="int" line="1152"/>
                <scope line="1154"/>
            </method>
            <javadoc line="1160">
                For compatibility with 1.5 pack, expand 1-5 into 1,2,3,4,5.                
            </javadoc>
            <method name="expandCaseDashNotation" type="String" line="1162">
                <params>
                    <param name="layout" type="String"/>
                </params>
                <comment line="1165">
                    no dashes (the common case)                    
                </comment>
                <comment line="1167">
                    how far have we processed the layout?                    
                </comment>
                <comment line="1169">
                    for each dash, collect everything up to the dash                    
                </comment>
                <comment line="1171">
                    skip the dash                    
                </comment>
                <comment line="1172">
                    then collect intermediate values                    
                </comment>
                <comment line="1176">
                    close off value0 numeral                    
                </comment>
                <comment line="1179">
                    close off i numeral                    
                </comment>
                <comment line="1184">
                    collect the rest                    
                </comment>
                <declaration name="dash" type="int" line="1163"/>
                <declaration name="result" type="StringBuilder" line="1165"/>
                <declaration name="sofar" type="int" line="1166"/>
                <scope line="1167">
                    <declaration name="value0" type="int" line="1172"/>
                    <declaration name="value1" type="int" line="1173"/>
                    <scope line="1176"/>
                </scope>
            </method>
            <scope line="1186"/>
            <method name="parseUsing" type="int" line="1198">
                <params>
                    <param name="elems" type="Layout.Element[]"/>
                    <param name="holder" type="Holder"/>
                    <param name="bytes" type="byte[]"/>
                    <param name="pos" type="int"/>
                    <param name="len" type="int"/>
                    <param name="out" type="ValueStream"/>
                </params>
                <comment line="1203">
                    for calls to parseInt, holds 2nd result                    
                </comment>
                <comment line="1215">
                    PH, POH                    
                </comment>
                <comment line="1220">
                    PH:  transmit R(bci), store bci                    
                </comment>
                <comment line="1223">
                    POH:  transmit D(R(bci)), store bci                    
                </comment>
                <comment line="1230">
                    OH                    
                </comment>
                <comment line="1232">
                    OH:  transmit D(R(bci)), store D(bci)                    
                </comment>
                <comment line="1253">
                    already transmitted the scalar value                    
                </comment>
                <comment line="1261">
                    already transmitted the scalar value                    
                </comment>
                <comment line="1263">
                    Adjust band offset if it is a backward call.                    
                </comment>
                <comment line="1269">
                    no additional scalar value to transmit                    
                </comment>
                <comment line="1275">
                    N.B. global null reference is -1                    
                </comment>
                <comment line="1280">
                    Cf. ClassReader.readSignatureRef.                    
                </comment>
                <declaration name="prevBCI" type="int" line="1199"/>
                <declaration name="prevRBCI" type="int" line="1200"/>
                <declaration name="end" type="int" line="1201"/>
                <declaration name="buf" type="int[]" line="1202"/>
                <scope line="1203">
                    <declaration name="e" type="Layout.Element" line="1204"/>
                    <declaration name="bandIndex" type="int" line="1205"/>
                    <declaration name="value" type="int" line="1206"/>
                    <declaration name="BCI" type="int" line="1207"/>
                    <scope line="1218"/>
                    <scope line="1221"/>
                    <scope line="1249"/>
                    <declaration name="ce" type="Layout.Element" line="1257"/>
                    <declaration name="localRef" type="int" line="1271"/>
                    <declaration name="globalRef" type="Entry" line="1272"/>
                    <scope line="1273"/>
                    <scope line="1275">
                        <scope line="1278">
                            <declaration name="typeName" type="String" line="1280"/>
                        </scope>
                        <scope line="1282"/>
                        <scope line="1285"/>
                    </scope>
                </scope>
            </method>
            <method name="matchCase" type="Layout.Element" line="1298">
                <params>
                    <param name="e" type="Layout.Element"/>
                    <param name="value" type="int"/>
                </params>
                <declaration name="lastj" type="int" line="1300"/>
                <scope line="1301">
                    <declaration name="ce" type="Layout.Element" line="1302"/>
                </scope>
            </method>
            <method name="parseInt" type="int" line="1311">
                <params>
                    <param name="e" type="Layout.Element"/>
                    <param name="bytes" type="byte[]"/>
                    <param name="pos" type="int"/>
                    <param name="buf" type="int[]"/>
                </params>
                <comment line="1315">
                    Read in big-endian order:                    
                </comment>
                <comment line="1320">
                    sign-extend subword value                    
                </comment>
                <declaration name="value" type="int" line="1312"/>
                <declaration name="loBits" type="int" line="1313"/>
                <scope line="1315"/>
                <scope line="1318">
                    <declaration name="hiBits" type="int" line="1320"/>
                </scope>
            </method>
            <method name="unparseUsing" type="void" line="1332">
                <params>
                    <param name="elems" type="Layout.Element[]"/>
                    <param name="fixups" type="Object[]"/>
                    <param name="in" type="ValueStream"/>
                    <param name="out" type="ByteArrayOutputStream"/>
                </params>
                <comment line="1340">
                    &quot;RBCI&quot; is R(BCI), BCI&apos;s coded representation                    
                </comment>
                <comment line="1346">
                    PH, POH                    
                </comment>
                <comment line="1349">
                    PH:  transmit R(bci), store bci                    
                </comment>
                <comment line="1352">
                    POH:  transmit D(R(bci)), store bci                    
                </comment>
                <comment line="1361">
                    OH                    
                </comment>
                <comment line="1364">
                    OH:  transmit D(R(bci)), store D(bci)                    
                </comment>
                <comment line="1398">
                    It&apos;s a one-element array, really an lvalue.                    
                </comment>
                <comment line="1401">
                    placeholder for fixups                    
                </comment>
                <comment line="1403">
                    fixed null value                    
                </comment>
                <declaration name="prevBCI" type="int" line="1333"/>
                <declaration name="prevRBCI" type="int" line="1334"/>
                <scope line="1335">
                    <declaration name="e" type="Layout.Element" line="1336"/>
                    <declaration name="bandIndex" type="int" line="1337"/>
                    <declaration name="value" type="int" line="1338"/>
                    <declaration name="BCI" type="int" line="1339"/>
                    <scope line="1347"/>
                    <scope line="1350"/>
                    <scope line="1378"/>
                    <declaration name="ce" type="Layout.Element" line="1385"/>
                    <declaration name="globalRef" type="Entry" line="1394"/>
                    <declaration name="localRef" type="int" line="1395"/>
                    <scope line="1396"/>
                    <scope line="1401"/>
                </scope>
            </method>
            <method name="unparseInt" type="void" line="1412">
                <params>
                    <param name="e" type="Layout.Element"/>
                    <param name="value" type="int"/>
                    <param name="out" type="ByteArrayOutputStream"/>
                </params>
                <comment line="1416">
                    It is not stored at all (&apos;V&apos; layout).                    
                </comment>
                <comment line="1429">
                    Write in big-endian order:                    
                </comment>
                <declaration name="loBits" type="int" line="1413"/>
                <scope line="1414"/>
                <scope line="1418">
                    <declaration name="hiBits" type="int" line="1419"/>
                    <declaration name="codedValue" type="int" line="1420"/>
                </scope>
                <scope line="1429"/>
            </method>
        </class>
    </source>