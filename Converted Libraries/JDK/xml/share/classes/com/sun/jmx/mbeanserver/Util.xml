<?xml version="1.0" encoding="UTF-8"?>
    <source package="com.sun.jmx.mbeanserver">
        <import package="java.util.ArrayList"/>
        <import package="java.util.Arrays"/>
        <import package="java.util.Collection"/>
        <import package="java.util.Collections"/>
        <import package="java.util.Comparator"/>
        <import package="java.util.HashMap"/>
        <import package="java.util.HashSet"/>
        <import package="java.util.IdentityHashMap"/>
        <import package="java.util.LinkedHashMap"/>
        <import package="java.util.List"/>
        <import package="java.util.Map"/>
        <import package="java.util.Set"/>
        <import package="java.util.SortedMap"/>
        <import package="java.util.TreeMap"/>
        <import package="javax.management.MalformedObjectNameException"/>
        <import package="javax.management.ObjectName"/>
        <class name="Util" line="45">
            <comment line="100">
                This method can be used by code that is deliberately violating the
                 allowed checked casts.  Rather than marking the whole method containing
                 the code with @SuppressWarnings, you can use a call to this method for
                 the exact place where you need to escape the constraints.  Typically
                 you will &quot;import static&quot; this method and then write either
                    X x = cast(y);
                 or, if that doesn&apos;t work (e.g. X is a type variable)
                    Util.&lt;X&gt;cast(y);                
            </comment>
            <method name="newObjectName" type="ObjectName" line="46">
                <params>
                    <param name="string" type="String"/>
                </params>
                <scope line="47"/>
                <scope line="49"/>
            </method>
            <method name="newMap" type="Map<K,V>" line="54"/>
            <method name="newSynchronizedMap" type="Map<K,V>" line="58"/>
            <method name="newIdentityHashMap" type="IdentityHashMap<K,V>" line="62"/>
            <method name="newSynchronizedIdentityHashMap" type="Map<K,V>" line="66">
                <declaration name="map" type="Map&lt;K,V&gt;" line="67"/>
            </method>
            <method name="newSortedMap" type="SortedMap<K,V>" line="71"/>
            <method name="newSortedMap" type="SortedMap<K,V>" line="75">
                <params>
                    <param name="comp" type="Comparator<? super K>"/>
                </params>
            </method>
            <method name="newInsertionOrderMap" type="Map<K,V>" line="79"/>
            <method name="newSet" type="Set<E>" line="83"/>
            <method name="newSet" type="Set<E>" line="87">
                <params>
                    <param name="c" type="Collection<E>"/>
                </params>
            </method>
            <method name="newList" type="List<E>" line="91"/>
            <method name="newList" type="List<E>" line="95">
                <params>
                    <param name="c" type="Collection<E>"/>
                </params>
            </method>
            <method name="cast" type="T" line="109">
                <params>
                    <param name="x" type="Object"/>
                </params>
            </method>
            <javadoc line="113">
                Computes a descriptor hashcode from its names and values.                
                <param>
                    names  the sorted array of descriptor names.                    
                </param>
                <param>
                    values the array of descriptor values.                    
                </param>
                <return>
                    a hash code value, as described in {@link #hashCode(Descriptor)}                    
                </return>
            </javadoc>
            <method name="hashCode" type="int" line="119">
                <params>
                    <param name="names" type="String[]"/>
                    <param name="values" type="Object[]"/>
                </params>
                <comment line="130">
                    hashcode of a list containing just v is                    
                </comment>
                <comment line="131">
                    v.hashCode() + 31, see List.hashCode()                    
                </comment>
                <declaration name="hash" type="int" line="120"/>
                <scope line="121">
                    <declaration name="v" type="Object" line="122"/>
                    <declaration name="h" type="int" line="123"/>
                    <scope line="124"/>
                    <scope line="126"/>
                    <scope line="128"/>
                    <scope line="132"/>
                </scope>
            </method>
            <javadoc line="140">
                Match a part of a string against a shell-style pattern.
                  The only pattern characters recognized are &lt;code&gt;?&lt;/code&gt;,
                  standing for any one character,
                  and &lt;code&gt;&lt;/code&gt;, standing for any string of
                  characters, including the empty string. For instance,{@code wildmatch(&quot;sandwich&quot;,&quot;sa?dch&quot;,1,4,1,4)} will match{@code &quot;and&quot;} against {@code &quot;a?d&quot;}.                
                <param>
                    str  the string containing the sequence to match.                    
                </param>
                <param>
                    pat  a string containing a pattern to match the sub string
                      against.                    
                </param>
                <param>
                    stri   the index in the string at which matching should begin.                    
                </param>
                <param>
                    strend the index in the string at which the matching should
                      end.                    
                </param>
                <param>
                    pati   the index in the pattern at which matching should begin.                    
                </param>
                <param>
                    patend the index in the pattern at which the matching should
                      end.                    
                </param>
                <return>
                    true if and only if the string matches the pattern.                    
                </return>
            </javadoc>
            <method name="wildmatch" type="boolean" line="179">
                <params>
                    <param name="str" type="String"/>
                    <param name="pat" type="String"/>
                    <param name="stri" type="int"/>
                    <param name="strend" type="int"/>
                    <param name="pati" type="int"/>
                    <param name="patend" type="int"/>
                </params>
                <comment line="160">
                    The algorithm is a classical one.  We advance pointers in
                    parallel through str and pat.  If we encounter a star in pat,
                    we remember its position and continue advancing.  If at any
                    stage we get a mismatch between str and pat, we look to see if
                    there is a remembered star.  If not, we fail.  If so, we
                    retreat pat to just past that star and str to the position
                    after the last one we tried, and we let the match advance
                    again.
                    
                    Even though there is only one remembered star position, the
                    algorithm works when there are several stars in the pattern.
                    When we encounter the second star, we forget the first one.
                    This is OK, because if we get to the second star in ABC
                    (where A etc are arbitrary strings), we have already seen AXB.
                    We&apos;re therefore setting up a match of C against the remainder
                    of the string, which will match if that remainder looks like
                    YC, so the whole string looks like AXBYC.                    
                </comment>
                <comment line="181">
                    System.out.println(&quot;matching &quot;+pat.substring(pati,patend)+                    
                </comment>
                <comment line="182">
                    &quot; against &quot;+str.substring(stri, strend));                    
                </comment>
                <comment line="183">
                    index for backtrack if &quot;*&quot; attempt fails                    
                </comment>
                <comment line="184">
                    index for backtrack if &quot;*&quot; attempt fails, +1                    
                </comment>
                <comment line="188">
                    On each pass through this loop, we either advance pati,
                    or we backtrack pati and advance starstri.  Since starstri                    
                </comment>
                <comment line="217">
                    Mismatched, can we backtrack to a &quot;*&quot;?                    
                </comment>
                <comment line="221">
                    Retry the match one position later in str                    
                </comment>
                <declaration name="starstri" type="int" line="183"/>
                <declaration name="starpati" type="int" line="184"/>
                <scope line="191">
                    <scope line="192">
                        <declaration name="patc" type="char" line="193"/>
                        <scope line="207"/>
                    </scope>
                </scope>
            </method>
            <javadoc line="228">
                Match a string against a shell-style pattern.  The only pattern
                  characters recognized are &lt;code&gt;?&lt;/code&gt;, standing for any one
                  character, and &lt;code&gt;&lt;/code&gt;, standing for any string of
                  characters, including the empty string.                
                <param>
                    str the string to match.                    
                </param>
                <param>
                    pat the pattern to match the string against.                    
                </param>
                <return>
                    true if and only if the string matches the pattern.                    
                </return>
            </javadoc>
            <method name="wildmatch" type="boolean" line="238">
                <params>
                    <param name="str" type="String"/>
                    <param name="pat" type="String"/>
                </params>
            </method>
        </class>
    </source>