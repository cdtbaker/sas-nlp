<?xml version="1.0" encoding="UTF-8"?>
    <source package="com.sun.jmx.mbeanserver">
        <import package="com.sun.jmx.mbeanserver.Util"/>
        <import package="java.lang.ref.WeakReference"/>
        <import package="java.lang.reflect.Array"/>
        <import package="java.lang.reflect.Constructor"/>
        <import package="java.lang.reflect.InvocationTargetException"/>
        <import package="java.lang.reflect.Method"/>
        <import package="java.lang.reflect.Type"/>
        <import package="java.util.Arrays"/>
        <import package="java.util.List"/>
        <import package="java.util.WeakHashMap"/>
        <import package="javax.management.Descriptor"/>
        <import package="javax.management.ImmutableDescriptor"/>
        <import package="javax.management.IntrospectionException"/>
        <import package="javax.management.InvalidAttributeValueException"/>
        <import package="javax.management.MBeanAttributeInfo"/>
        <import package="javax.management.MBeanConstructorInfo"/>
        <import package="javax.management.MBeanException"/>
        <import package="javax.management.MBeanInfo"/>
        <import package="javax.management.MBeanNotificationInfo"/>
        <import package="javax.management.MBeanOperationInfo"/>
        <import package="javax.management.NotCompliantMBeanException"/>
        <import package="javax.management.NotificationBroadcaster"/>
        <import package="javax.management.ReflectionException"/>
        <class name="MBeanIntrospector" line="55">
            <type_params>
                <type_param name="M"/>
            </type_params>
            <comment line="67">
                Using a type parameter &lt;M&gt; allows us to deal with the fact that
                 Method and ConvertingMethod have no useful common ancestor, on
                 which we could call getName, getGenericReturnType, etc.  A simpler approach
                 would be to wrap every Method in an object that does have a common
                 ancestor with ConvertingMethod.  But that would mean an extra object
                 for every Method in every Standard MBean interface.                
            </comment>
            <comment line="370">
                Looking up the MBeanInfo for a given base class (implementation class)
                 is complicated by the fact that we may use the same base class with
                 several different explicit MBean interfaces via the
                 javax.management.StandardMBean class.  It is further complicated
                 by the fact that we have to be careful not to retain a strong reference
                 to any Class object for fear we would prevent a ClassLoader from being
                 garbage-collected.  So we have a first lookup from the base class
                 to a map for each interface that base class might specify giving
                 the MBeanInfo constructed for that base class and interface.                
            </comment>
            <javadoc line="55">
                An introspector for MBeans of a certain type.  There is one instance
                  of this class for Standard MBeans, and one for every MXBeanMappingFactory;
                  these two cases correspond to the two concrete subclasses of this abstract
                  class.                
                <param>
                    &lt;M&gt;
                       the representation of methods for this kind of MBean:
                      Method for Standard MBeans, ConvertingMethod for MXBeans.                    
                </param>
                <since>
                    1.6                    
                </since>
            </javadoc>
            <class name="PerInterfaceMap" line="75">
                <type_params>
                    <type_param name="M"/>
                </type_params>
                <extends class="WeakHashMap">
                    <type_params>
                        <type_param name="Class<?>"/>
                        <type_param name="WeakReference<PerInterface<M>>"/>
                    </type_params>
                </extends>
                <comment line="133">
                    It would be cleaner if the type of the cookie were a
                     type parameter to this class, but that would involve a lot of
                     messy type parameter propagation just to avoid a couple of casts.                    
                </comment>
                <comment line="253">
                    If the value is of the wrong type for the method we are about to
                     invoke, we are supposed to throw an InvalidAttributeValueException.
                     Rather than making the check always, we invoke the method, then
                     if it throws an exception we check the type to see if that was
                     what caused the exception.  The assumption is that an exception
                     from an invalid type will arise before any user method is ever
                     called (either in reflection or in OpenConverter).                    
                </comment>
            </class>
            <method name="getPerInterfaceMap" type="PerInterfaceMap<M>" line="78"/>
            <javadoc line="78">
                The map from interface to PerInterface for this type of MBean.                
            </javadoc>
            <method name="getMBeanInfoMap" type="MBeanInfoMap" line="80"/>
            <javadoc line="80">
                The map from concrete implementation class and interface to
                  MBeanInfo for this type of MBean.                
            </javadoc>
            <method name="getAnalyzer" type="MBeanAnalyzer<M>" line="86"/>
            <javadoc line="86">
                Make an interface analyzer for this type of MBean.                
            </javadoc>
            <method name="isMXBean" type="boolean" line="90"/>
            <javadoc line="90">
                True if MBeans with this kind of introspector are MXBeans.                
            </javadoc>
            <method name="mFrom" type="M" line="93"/>
            <javadoc line="93">
                Find the M corresponding to the given Method.                
            </javadoc>
            <method name="getName" type="String" line="96"/>
            <javadoc line="96">
                Get the name of this method.                
            </javadoc>
            <method name="getGenericReturnType" type="Type" line="99"/>
            <javadoc line="99">
                Get the return type of this method.  This is the return type
                  of a method in a Java interface, so for MXBeans it is the
                  declared Java type, not the mapped Open Type.                
            </javadoc>
            <method name="getGenericParameterTypes" type="Type[]" line="106"/>
            <javadoc line="106">
                Get the parameter types of this method in the Java interface
                  it came from.                
            </javadoc>
            <method name="getSignature" type="String[]" line="112"/>
            <javadoc line="112">
                Get the signature of this method as a caller would have to supply
                  it in MBeanServer.invoke.  For MXBeans, the named types will be
                  the mapped Open Types for the parameters.                
            </javadoc>
            <method name="checkMethod" type="void" line="119"/>
            <javadoc line="119">
                Check that this method is valid.  For example, a method in an
                  MXBean interface is not valid if one of its parameters cannot be
                  mapped to an Open Type.                
            </javadoc>
            <method name="invokeM2" type="Object" line="126"/>
            <javadoc line="126">
                Invoke the method with the given target and arguments.                
                <param>
                    cookie Additional information about the target.  For an
                      MXBean, this is the MXBeanLookup associated with the MXBean.                    
                </param>
            </javadoc>
            <method name="validParameter" type="boolean" line="141"/>
            <javadoc line="141">
                Test whether the given value is valid for the given parameter of this
                  M.                
            </javadoc>
            <method name="getMBeanAttributeInfo" type="MBeanAttributeInfo" line="148"/>
            <javadoc line="148">
                Construct an MBeanAttributeInfo for the given attribute based on the
                  given getter and setter.  One but not both of the getter and setter
                  may be null.                
            </javadoc>
            <method name="getMBeanOperationInfo" type="MBeanOperationInfo" line="155"/>
            <javadoc line="155">
                Construct an MBeanOperationInfo for the given operation based on
                  the M it was derived from.                
            </javadoc>
            <method name="getBasicMBeanDescriptor" type="Descriptor" line="162"/>
            <javadoc line="162">
                Get a Descriptor containing fields that MBeans of this kind will
                  always have.  For example, MXBeans will always have &quot;mxbean=true&quot;.                
            </javadoc>
            <method name="getMBeanDescriptor" type="Descriptor" line="168"/>
            <javadoc line="168">
                Get a Descriptor containing additional fields beyond the ones
                  from getBasicMBeanDescriptor that MBeans whose concrete class
                  is resourceClass will always have.                
            </javadoc>
            <javadoc line="175">
                Get the methods to be analyzed to build the MBean interface.                
            </javadoc>
            <method name="getMethods" type="List<Method>" line="178">
                <params>
                    <param name="mbeanType" type="Class<?>"/>
                </params>
            </method>
            <method name="getPerInterface" type="PerInterface<M>" line="183">
                <params>
                    <param name="mbeanInterface" type="Class<?>"/>
                </params>
                <declaration name="map" type="PerInterfaceMap&lt;M&gt;" line="184"/>
                <scope line="185">
                    <declaration name="wr" type="WeakReference&lt;PerInterface&lt;M&gt;&gt;" line="186"/>
                    <declaration name="pi" type="PerInterface&lt;M&gt;" line="187"/>
                    <scope line="188">
                        <scope line="189">
                            <declaration name="analyzer" type="MBeanAnalyzer&lt;M&gt;" line="190"/>
                            <declaration name="mbeanInfo" type="MBeanInfo" line="191"/>
                        </scope>
                        <scope line="197"/>
                    </scope>
                </scope>
            </method>
            <javadoc line="205">
                Make the MBeanInfo skeleton for the given MBean interface using
                  the given analyzer.  This will never be the MBeanInfo of any real
                  MBean (because the getClassName() must be a concrete class), but
                  its MBeanAttributeInfo[] and MBeanOperationInfo[] can be inserted
                  into such an MBeanInfo, and its Descriptor can be the basis for
                  the MBeanInfo&apos;s Descriptor.                
            </javadoc>
            <method name="makeInterfaceMBeanInfo" type="MBeanInfo" line="214">
                <params>
                    <param name="mbeanInterface" type="Class<?>"/>
                    <param name="analyzer" type="MBeanAnalyzer<M>"/>
                </params>
                <declaration name="maker" type="MBeanInfoMaker" line="215"/>
                <declaration name="description" type="String" line="217"/>
            </method>
            <javadoc line="222">
                True if the given getter and setter are consistent.                
            </javadoc>
            <method name="consistent" type="boolean" line="223">
                <params>
                    <param name="getter" type="M"/>
                    <param name="setter" type="M"/>
                </params>
            </method>
            <javadoc line="228">
                Invoke the given M on the given target with the given args and cookie.
                  Wrap exceptions appropriately.                
            </javadoc>
            <method name="invokeM" type="Object" line="233">
                <params>
                    <param name="m" type="M"/>
                    <param name="target" type="Object"/>
                    <param name="args" type="Object[]"/>
                    <param name="cookie" type="Object"/>
                </params>
                <comment line="239">
                    not reached                    
                </comment>
                <comment line="243">
                    We do not catch and wrap RuntimeException or Error,
                     because we&apos;re in a DynamicMBean, so the logic for DynamicMBeans
                     will do the wrapping.                    
                </comment>
                <scope line="234"/>
                <scope line="236"/>
                <scope line="239"/>
            </method>
            <javadoc line="248">
                Invoke the given setter on the given target with the given argument
                  and cookie.  Wrap exceptions appropriately.                
            </javadoc>
            <method name="invokeSetter" type="void" line="263">
                <params>
                    <param name="name" type="String"/>
                    <param name="setter" type="M"/>
                    <param name="target" type="Object"/>
                    <param name="arg" type="Object"/>
                    <param name="cookie" type="Object"/>
                </params>
                <comment line="253">
                    If the value is of the wrong type for the method we are about to
                     invoke, we are supposed to throw an InvalidAttributeValueException.
                     Rather than making the check always, we invoke the method, then
                     if it throws an exception we check the type to see if that was
                     what caused the exception.  The assumption is that an exception
                     from an invalid type will arise before any user method is ever
                     called (either in reflection or in OpenConverter).                    
                </comment>
                <scope line="264"/>
                <scope line="266"/>
                <scope line="268"/>
                <scope line="271"/>
            </method>
            <method name="maybeInvalidParameter" type="void" line="279">
                <params>
                    <param name="name" type="String"/>
                    <param name="setter" type="M"/>
                    <param name="arg" type="Object"/>
                    <param name="cookie" type="Object"/>
                </params>
                <scope line="280">
                    <declaration name="msg" type="String" line="281"/>
                </scope>
            </method>
            <method name="isValidParameter" type="boolean" line="287">
                <params>
                    <param name="m" type="Method"/>
                    <param name="value" type="Object"/>
                    <param name="paramNo" type="int"/>
                </params>
                <comment line="291">
                    Following is expensive but we only call this method to determine
                     if an exception is due to an incompatible parameter type.
                     Plain old c.isInstance doesn&apos;t work for primitive types.                    
                </comment>
                <declaration name="c" type="Class&lt;?&gt;" line="288"/>
                <scope line="289">
                    <declaration name="a" type="Object" line="293"/>
                </scope>
                <scope line="296"/>
            </method>
            <method name="unwrapInvocationTargetException" type="void" line="303">
                <params>
                    <param name="e" type="InvocationTargetException"/>
                </params>
                <declaration name="t" type="Throwable" line="304"/>
            </method>
            <class name="MBeanInfoMaker" line="314">
                <comment line="133">
                    It would be cleaner if the type of the cookie were a
                     type parameter to this class, but that would involve a lot of
                     messy type parameter propagation just to avoid a couple of casts.                    
                </comment>
                <comment line="253">
                    If the value is of the wrong type for the method we are about to
                     invoke, we are supposed to throw an InvalidAttributeValueException.
                     Rather than making the check always, we invoke the method, then
                     if it throws an exception we check the type to see if that was
                     what caused the exception.  The assumption is that an exception
                     from an invalid type will arise before any user method is ever
                     called (either in reflection or in OpenConverter).                    
                </comment>
                <implements interface="MBeanAnalyzer.MBeanVisitor">
                    <type_params>
                        <type_param name="M"/>
                    </type_params>
                </implements>
                <javadoc line="314">
                    A visitor that constructs the per-interface MBeanInfo.                    
                </javadoc>
                <method name="visitAttribute" type="void" line="320">
                    <params>
                        <param name="attributeName" type="String"/>
                        <param name="getter" type="M"/>
                        <param name="setter" type="M"/>
                    </params>
                    <declaration name="mbai" type="MBeanAttributeInfo" line="321"/>
                </method>
                <method name="visitOperation" type="void" line="328">
                    <params>
                        <param name="operationName" type="String"/>
                        <param name="operation" type="M"/>
                    </params>
                    <declaration name="mboi" type="MBeanOperationInfo" line="329"/>
                </method>
                <javadoc line="335">
                    Make an MBeanInfo based on the attributes and operations
                      found in the interface.                    
                </javadoc>
                <method name="makeMBeanInfo" type="MBeanInfo" line="338">
                    <params>
                        <param name="mbeanInterface" type="Class<?>"/>
                        <param name="description" type="String"/>
                    </params>
                    <declaration name="attrArray" type="MBeanAttributeInfo[]" line="339"/>
                    <declaration name="opArray" type="MBeanOperationInfo[]" line="341"/>
                    <declaration name="interfaceClassName" type="String" line="343"/>
                    <declaration name="classNameDescriptor" type="Descriptor" line="345"/>
                    <declaration name="mbeanDescriptor" type="Descriptor" line="347"/>
                    <declaration name="annotatedDescriptor" type="Descriptor" line="348"/>
                    <declaration name="descriptor" type="Descriptor" line="350"/>
                </method>
                <declaration name="attrs" type="List&lt;MBeanAttributeInfo&gt;" line="365"/>
                <declaration name="ops" type="List&lt;MBeanOperationInfo&gt;" line="366"/>
            </class>
            <class name="MBeanInfoMap" line="380">
                <extends class="WeakHashMap">
                    <type_params>
                        <type_param name="Class<?>"/>
                        <type_param name="WeakHashMap<Class<?>,MBeanInfo>"/>
                    </type_params>
                </extends>
                <comment line="133">
                    It would be cleaner if the type of the cookie were a
                     type parameter to this class, but that would involve a lot of
                     messy type parameter propagation just to avoid a couple of casts.                    
                </comment>
                <comment line="253">
                    If the value is of the wrong type for the method we are about to
                     invoke, we are supposed to throw an InvalidAttributeValueException.
                     Rather than making the check always, we invoke the method, then
                     if it throws an exception we check the type to see if that was
                     what caused the exception.  The assumption is that an exception
                     from an invalid type will arise before any user method is ever
                     called (either in reflection or in OpenConverter).                    
                </comment>
            </class>
            <javadoc line="384">
                Return the MBeanInfo for the given resource, based on the given
                  per-interface data.                
            </javadoc>
            <method name="getMBeanInfo" type="MBeanInfo" line="388">
                <params>
                    <param name="resource" type="Object"/>
                    <param name="perInterface" type="PerInterface<M>"/>
                </params>
                <declaration name="mbi" type="MBeanInfo" line="389"/>
                <declaration name="notifs" type="MBeanNotificationInfo[]" line="391"/>
                <scope line="394"/>
            </method>
            <javadoc line="405">
                Return the basic MBeanInfo for resources of the given class and
                  per-interface data.  This MBeanInfo might not be the final MBeanInfo
                  for instances of the class, because if the class is a
                  NotificationBroadcaster then each instance gets to decide what
                  MBeanNotificationInfo[] to put in its own MBeanInfo.                
            </javadoc>
            <method name="getClassMBeanInfo" type="MBeanInfo" line="413">
                <params>
                    <param name="resourceClass" type="Class<?>"/>
                    <param name="perInterface" type="PerInterface<M>"/>
                </params>
                <declaration name="map" type="MBeanInfoMap" line="414"/>
                <scope line="415">
                    <declaration name="intfMap" type="WeakHashMap&lt;Class&lt;?&gt;,MBeanInfo&gt;" line="416"/>
                    <scope line="417"/>
                    <declaration name="intfClass" type="Class&lt;?&gt;" line="421"/>
                    <declaration name="mbi" type="MBeanInfo" line="422"/>
                    <scope line="423">
                        <declaration name="imbi" type="MBeanInfo" line="424"/>
                        <declaration name="descriptor" type="Descriptor" line="425"/>
                    </scope>
                </scope>
            </method>
            <method name="findNotifications" type="MBeanNotificationInfo[]" line="441">
                <params>
                    <param name="moi" type="Object"/>
                </params>
                <declaration name="mbn" type="MBeanNotificationInfo[]" line="444"/>
                <declaration name="result" type="MBeanNotificationInfo[]" line="448"/>
                <scope line="450">
                    <declaration name="ni" type="MBeanNotificationInfo" line="451"/>
                </scope>
            </method>
            <method name="findConstructors" type="MBeanConstructorInfo[]" line="459">
                <params>
                    <param name="c" type="Class<?>"/>
                </params>
                <declaration name="cons" type="Constructor&lt;?&gt;[]" line="460"/>
                <declaration name="mbc" type="MBeanConstructorInfo[]" line="461"/>
                <scope line="462">
                    <declaration name="descr" type="String" line="463"/>
                </scope>
            </method>
        </class>
    </source>