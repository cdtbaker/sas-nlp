<?xml version="1.0" encoding="UTF-8"?>
    <source package="com.sun.jmx.snmp.agent">
        <import package="java.io.Serializable"/>
        <import package="java.util.Hashtable"/>
        <import package="java.util.Enumeration"/>
        <import package="java.util.Vector"/>
        <import package="com.sun.jmx.snmp.SnmpOid"/>
        <import package="com.sun.jmx.snmp.SnmpValue"/>
        <import package="com.sun.jmx.snmp.SnmpVarBind"/>
        <import package="com.sun.jmx.snmp.SnmpStatusException"/>
        <import package="com.sun.jmx.snmp.agent.SnmpMibOid"/>
        <import package="com.sun.jmx.snmp.agent.SnmpMibNode"/>
        <class name="SnmpMibGroup" line="47">
            <extends class="SnmpMibOid"/>
            <comment line="64">
                We will register the OID arcs leading to subgroups in this hashtable.                
            </comment>
            <comment line="65">
                So for each arc in varList, if the arc is also in subgroups, it leads                
            </comment>
            <comment line="66">
                to a subgroup, if it is not in subgroup, it leads either to a table                
            </comment>
            <comment line="67">
                or to a variable.                
            </comment>
            <comment line="124">
                -------------------------------------------------------------------                
            </comment>
            <comment line="125">
                We use a hashtable (subgroup) in order to determine whether an                
            </comment>
            <comment line="126">
                OID arc leads to a subgroup. This implementation can be changed if                
            </comment>
            <comment line="127">
                needed...                
            </comment>
            <comment line="128">
                For instance, the subclass could provide a generated isNestedArc()                
            </comment>
            <comment line="129">
                method in which the subgroup OID arcs would be hardcoded.                
            </comment>
            <comment line="130">
                However, the generic approach was prefered because at this time                
            </comment>
            <comment line="131">
                groups and subgroups are dynamically registered in the MIB.                
            </comment>
            <comment line="132">
                                
            </comment>
            <comment line="241">
                --------------------------------------------------------------------                
            </comment>
            <comment line="242">
                If we reach this node, we are below the root OID, so we just                
            </comment>
            <comment line="243">
                return.                
            </comment>
            <comment line="244">
                --------------------------------------------------------------------                
            </comment>
            <comment line="249">
                -------------------------------------------------------------------                
            </comment>
            <comment line="250">
                PACKAGE METHODS                
            </comment>
            <comment line="251">
                -------------------------------------------------------------------                
            </comment>
            <comment line="253">
                -------------------------------------------------------------------                
            </comment>
            <comment line="254">
                This method can also be overriden in a subclass to provide a                
            </comment>
            <comment line="255">
                different implementation of the isNestedArc() method.                
            </comment>
            <comment line="256">
                =&gt; if isNestedArc() is hardcoded, then registerSubArc() becomes                
            </comment>
            <comment line="257">
                useless and can become empty.                
            </comment>
            <comment line="273">
                -------------------------------------------------------------------                
            </comment>
            <comment line="274">
                The SnmpMibOid algorithm relies on the fact that for every arc                
            </comment>
            <comment line="275">
                registered in varList, there is a corresponding node at the same                
            </comment>
            <comment line="276">
                position in children.                
            </comment>
            <comment line="277">
                So the trick is to register a null node in children for each variable                
            </comment>
            <comment line="278">
                in varList, so that the real subgroup nodes can be inserted at the                
            </comment>
            <comment line="279">
                correct location.                
            </comment>
            <comment line="280">
                registerObject() should be called for each scalar object and each                
            </comment>
            <comment line="281">
                table arc by the generated subclass.                
            </comment>
            <comment line="302">
                -------------------------------------------------------------------                
            </comment>
            <comment line="303">
                registerNode() will be called at runtime when nested groups are                
            </comment>
            <comment line="304">
                registered in the MIB. So we do know that this method will only                
            </comment>
            <comment line="305">
                be called to register nested-groups.                
            </comment>
            <comment line="306">
                We trap registerNode() in order to call registerSubArc()                
            </comment>
            <comment line="326">
                -------------------------------------------------------------------                
            </comment>
            <comment line="327">
                see comments in SnmpMibNode                
            </comment>
            <comment line="328">
                -------------------------------------------------------------------                
            </comment>
            <comment line="385">
                -------------------------------------------------------------------                
            </comment>
            <comment line="386">
                See comments in SnmpMibNode.                
            </comment>
            <comment line="387">
                -------------------------------------------------------------------                
            </comment>
            <implements interface="Serializable"/>
            <javadoc line="47">
                Represents a node in an SNMP MIB which corresponds to a group.
                  This class allows subnodes to be registered below a group, providing
                  support for nested groups. The subnodes are registered at run time
                  when registering the nested groups in the global MIB OID tree.
                  &lt;P&gt;
                  This class is used by the class generated by &lt;CODE&gt;mibgen&lt;/CODE&gt;.
                  You should not need to use this class directly.
                  &lt;p&gt;&lt;b&gt;This API is a Sun Microsystems internal API  and is subject
                  to change without notice.&lt;/b&gt;&lt;/p&gt;                
            </javadoc>
            <declaration name="subgroups" type="Hashtable&lt;Long,Long&gt;" line="67"/>
            <method name="isTable" type="boolean" line="69"/>
            <javadoc line="69">
                Tells whether the given arc identifies a table in this group.                
                <param>
                    arc An OID arc.                    
                </param>
                <return>
                    <CODE>true</CODE> if `arc' leads to a table.                    
                </return>
            </javadoc>
            <method name="isVariable" type="boolean" line="78"/>
            <javadoc line="78">
                Tells whether the given arc identifies a variable (scalar object) in
                  this group.                
                <param>
                    arc An OID arc.                    
                </param>
                <return>
                    <CODE>true</CODE> if `arc' leads to a variable.                    
                </return>
            </javadoc>
            <method name="isReadable" type="boolean" line="88"/>
            <javadoc line="88">
                Tells whether the given arc identifies a readable scalar object in
                  this group.                
                <param>
                    arc An OID arc.                    
                </param>
                <return>
                    <CODE>true</CODE> if `arc' leads to a readable variable.                    
                </return>
            </javadoc>
            <method name="getTable" type="SnmpMibTable" line="99"/>
            <javadoc line="99">
                Gets the table identified by the given `arc&apos;.                
                <param>
                    arc An OID arc.                    
                </param>
                <return>
                    The <CODE>SnmpMibTable</CODE> identified by `arc', or
                      <CODE>null</CODE> if `arc' does not identify any table.                    
                </return>
            </javadoc>
            <javadoc line="109">
                Checks whether the given OID arc identifies a variable (scalar
                  object).                
                <exception>
                    If the given `arc' does not identify any variable in this
                      group, throws an SnmpStatusException.                    
                </exception>
            </javadoc>
            <method name="validateVarId" type="void" line="117">
                <params>
                    <param name="arc" type="long"/>
                    <param name="userData" type="Object"/>
                </params>
            </method>
            <javadoc line="132">
                Tell whether the given OID arc identifies a sub-tree
                  leading to a nested SNMP sub-group. This method is used internally.
                  You shouldn&apos;t need to call it directly.                
                <param>
                    arc An OID arc.                    
                </param>
                <return>
                    <CODE>true</CODE> if the given OID arc identifies a subtree
                      leading to a nested SNMP sub-group.                    
                </return>
            </javadoc>
            <method name="isNestedArc" type="boolean" line="143">
                <params>
                    <param name="arc" type="long"/>
                </params>
                <comment line="146">
                    if the arc is registered in the hashtable,                    
                </comment>
                <comment line="147">
                    it leads to a subgroup.                    
                </comment>
                <declaration name="obj" type="Object" line="145"/>
            </method>
            <method name="get" type="void" line="151"/>
            <javadoc line="151">
                Generic handling of the &lt;CODE&gt;get&lt;/CODE&gt; operation.
                  &lt;p&gt;The actual implementation of this method will be generated
                  by mibgen. Usually, this implementation only delegates the
                  job to some other provided runtime class, which knows how to
                  access the MBean. The current toolkit thus provides two
                  implementations:
                  &lt;ul&gt;&lt;li&gt;The standard implementation will directly access the
                  MBean through a java reference,&lt;/li&gt;
                  &lt;li&gt;The generic implementation will access the MBean through
                  the MBean server.&lt;/li&gt;
                  &lt;/ul&gt;
                  &lt;p&gt;Both implementations rely upon specific - and distinct, set of
                  mibgen generated methods.
                  &lt;p&gt; You can override this method if you need to implement some
                  specific policies for minimizing the accesses made to some remote
                  underlying resources.
                  &lt;p&gt;                
                <param>
                    req   The sub-request that must be handled by this node.                    
                </param>
                <param>
                    depth The depth reached in the OID tree.                    
                </param>
                <exception>
                    SnmpStatusException An error occurred while accessing
                      the MIB node.                    
                </exception>
            </javadoc>
            <method name="set" type="void" line="180"/>
            <javadoc line="180">
                Generic handling of the &lt;CODE&gt;set&lt;/CODE&gt; operation.
                  &lt;p&gt;The actual implementation of this method will be generated
                  by mibgen. Usually, this implementation only delegates the
                  job to some other provided runtime class, which knows how to
                  access the MBean. The current toolkit thus provides two
                  implementations:
                  &lt;ul&gt;&lt;li&gt;The standard implementation will directly access the
                  MBean through a java reference,&lt;/li&gt;
                  &lt;li&gt;The generic implementation will access the MBean through
                  the MBean server.&lt;/li&gt;
                  &lt;/ul&gt;
                  &lt;p&gt;Both implementations rely upon specific - and distinct, set of
                  mibgen generated methods.
                  &lt;p&gt; You can override this method if you need to implement some
                  specific policies for minimizing the accesses made to some remote
                  underlying resources.
                  &lt;p&gt;                
                <param>
                    req   The sub-request that must be handled by this node.                    
                </param>
                <param>
                    depth The depth reached in the OID tree.                    
                </param>
                <exception>
                    SnmpStatusException An error occurred while accessing
                      the MIB node.                    
                </exception>
            </javadoc>
            <method name="check" type="void" line="209"/>
            <javadoc line="209">
                Generic handling of the &lt;CODE&gt;check&lt;/CODE&gt; operation.
                  &lt;p&gt;The actual implementation of this method will be generated
                  by mibgen. Usually, this implementation only delegates the
                  job to some other provided runtime class, which knows how to
                  access the MBean. The current toolkit thus provides two
                  implementations:
                  &lt;ul&gt;&lt;li&gt;The standard implementation will directly access the
                  MBean through a java reference,&lt;/li&gt;
                  &lt;li&gt;The generic implementation will access the MBean through
                  the MBean server.&lt;/li&gt;
                  &lt;/ul&gt;
                  &lt;p&gt;Both implementations rely upon specific - and distinct, set of
                  mibgen generated methods.
                  &lt;p&gt; You can override this method if you need to implement some
                  specific policies for minimizing the accesses made to some remote
                  underlying resources, or if you need to implement some consistency
                  checks between the different values provided in the varbind list.
                  &lt;p&gt;                
                <param>
                    req   The sub-request that must be handled by this node.                    
                </param>
                <param>
                    depth The depth reached in the OID tree.                    
                </param>
                <exception>
                    SnmpStatusException An error occurred while accessing
                      the MIB node.                    
                </exception>
            </javadoc>
            <method name="getRootOid" type="void" line="244">
                <params>
                    <param name="result" type="Vector"/>
                </params>
            </method>
            <javadoc line="257">
                Register an OID arc that identifies a sub-tree
                  leading to a nested SNMP sub-group. This method is used internally.
                  You shouldn&apos;t ever call it directly.                
                <param>
                    arc An OID arc.                    
                </param>
            </javadoc>
            <method name="registerNestedArc" type="void" line="265">
                <params>
                    <param name="arc" type="long"/>
                </params>
                <comment line="268">
                    registers the arc in the hashtable.                    
                </comment>
                <declaration name="obj" type="Long" line="266"/>
            </method>
            <javadoc line="281">
                Register an OID arc that identifies a scalar object or a table.
                  This method is used internally. You shouldn&apos;t ever call it directly.                
                <param>
                    arc An OID arc.                    
                </param>
            </javadoc>
            <method name="registerObject" type="void" line="289">
                <params>
                    <param name="arc" type="long"/>
                </params>
                <comment line="291">
                    this will register the variable in both varList and children                    
                </comment>
                <comment line="292">
                    The node registered in children will be null, so that the parent                    
                </comment>
                <comment line="293">
                    algorithm will behave as if no node were registered. This is a                    
                </comment>
                <comment line="294">
                    trick that makes the parent algorithm behave as if only subgroups                    
                </comment>
                <comment line="295">
                    were registered in varList and children.                    
                </comment>
                <declaration name="oid" type="long[]" line="296"/>
            </method>
            <javadoc line="306">
                Register a child node of this node in the OID tree.
                  This method is used internally. You shouldn&apos;t ever call it directly.                
                <param>
                    oid The oid of the node being registered.                    
                </param>
                <param>
                    cursor The position reached in the oid.                    
                </param>
                <param>
                    node The node being registered.                    
                </param>
            </javadoc>
            <method name="registerNode" type="void" line="316">
                <params>
                    <param name="oid" type="long[]"/>
                    <param name="cursor" type="int"/>
                    <param name="node" type="SnmpMibNode"/>
                </params>
                <comment line="320">
                    if we get here, then it means we are registering a subgroup.                    
                </comment>
                <comment line="321">
                    We will thus register the sub arc in the subgroups hashtable.                    
                </comment>
            </method>
            <method name="findHandlingNode" type="void" line="331">
                <params>
                    <param name="varbind" type="SnmpVarBind"/>
                    <param name="oid" type="long[]"/>
                    <param name="depth" type="int"/>
                    <param name="handlers" type="SnmpRequestTree"/>
                </params>
                <comment line="342">
                    Nothing is left... the oid is not valid                    
                </comment>
                <comment line="349">
                    This arc leads to a subgroup: delegates the search to the                    
                </comment>
                <comment line="350">
                    method defined in SnmpMibOid                    
                </comment>
                <comment line="354">
                    This arc leads to a table: forward the search to the table.                    
                </comment>
                <comment line="356">
                    Gets the table                    
                </comment>
                <comment line="359">
                    Forward the search to the table                    
                </comment>
                <comment line="363">
                    If it&apos;s not a variable, throws an exception                    
                </comment>
                <comment line="366">
                    The trailing .0 is missing in the OID                    
                </comment>
                <comment line="370">
                    There are too many arcs left in the OID (there should remain                    
                </comment>
                <comment line="371">
                    a single trailing .0)                    
                </comment>
                <comment line="375">
                    The last trailing arc is not .0                    
                </comment>
                <comment line="379">
                    It&apos;s one of our variable, register this node.                    
                </comment>
                <declaration name="length" type="int" line="333"/>
                <declaration name="node" type="SnmpMibNode" line="334"/>
                <declaration name="data" type="Object" line="339"/>
                <scope line="341"/>
                <declaration name="arc" type="long" line="346"/>
                <scope line="348"/>
                <scope line="353">
                    <declaration name="table" type="SnmpMibTable" line="357"/>
                </scope>
                <scope line="362"/>
            </method>
            <method name="findNextHandlingNode" type="long[]" line="390">
                <params>
                    <param name="varbind" type="SnmpVarBind"/>
                    <param name="oid" type="long[]"/>
                    <param name="pos" type="int"/>
                    <param name="depth" type="int"/>
                    <param name="handlers" type="SnmpRequestTree"/>
                    <param name="checker" type="AcmChecker"/>
                </params>
                <comment line="396">
                    This should be considered as a genErr, but we do not want to                    
                </comment>
                <comment line="397">
                    abort the whole request, so we&apos;re going to throw                    
                </comment>
                <comment line="398">
                    a noSuchObject...                    
                </comment>
                <comment line="399">
                                        
                </comment>
                <comment line="406">
                    The generic case where the end of the OID has been reached is                    
                </comment>
                <comment line="407">
                    handled in the superclass                    
                </comment>
                <comment line="408">
                    XXX Revisit: this works but it is somewhat convoluted. Just setting                    
                </comment>
                <comment line="409">
                    arc to -1 would work too.                    
                </comment>
                <comment line="414">
                    Ok, we&apos;ve got the arc.                    
                </comment>
                <comment line="419">
                    We have a recursive logic. Should we have a loop instead?                    
                </comment>
                <comment line="423">
                    If the arc identifies a table, then we need to forward                    
                </comment>
                <comment line="424">
                    the search to the table.                    
                </comment>
                <comment line="426">
                    Gets the table identified by `arc&apos;                    
                </comment>
                <comment line="429">
                    Forward to the table                    
                </comment>
                <comment line="440">
                    Build up the leaf OID                    
                </comment>
                <comment line="444">
                    If the arc identifies a readable variable, then two cases:                    
                </comment>
                <comment line="447">
                    The end of the OID is reached, so we return the leaf                    
                </comment>
                <comment line="448">
                    corresponding to the variable identified by `arc&apos;                    
                </comment>
                <comment line="450">
                    Build up the OID                    
                </comment>
                <comment line="451">
                    result = new SnmpOid(0);                    
                </comment>
                <comment line="452">
                    result.insert((int)arc);                    
                </comment>
                <comment line="466">
                    Registers this node                    
                </comment>
                <comment line="471">
                    The end of the OID is not yet reached, so we must return                    
                </comment>
                <comment line="472">
                    the next leaf following the variable identified by `arc&apos;.                    
                </comment>
                <comment line="473">
                    We cannot return the variable because whatever follows in                    
                </comment>
                <comment line="474">
                    the OID will be greater or equals to 0, and 0 identifies                    
                </comment>
                <comment line="475">
                    the variable itself - so we have indeed to return the                    
                </comment>
                <comment line="476">
                    next object.                    
                </comment>
                <comment line="477">
                    So we do nothing, because this case is handled at the                    
                </comment>
                <comment line="478">
                    end of the if ... else if ... else ... block.                    
                </comment>
                <comment line="481">
                    Now if the arc leads to a subgroup, we delegate the                    
                </comment>
                <comment line="482">
                    search to the child, just as done in SnmpMibNode.                    
                </comment>
                <comment line="483">
                                        
                </comment>
                <comment line="485">
                    get the child ( = nested arc node).                    
                </comment>
                <comment line="486">
                                        
                </comment>
                <comment line="503">
                    The oid is not valid, we will throw an exception in order                    
                </comment>
                <comment line="504">
                    to try with the next valid identifier...                    
                </comment>
                <comment line="505">
                                        
                </comment>
                <comment line="509">
                    We didn&apos;t find anything at the given arc, so we&apos;re going                    
                </comment>
                <comment line="510">
                    to try with the next valid arc                    
                </comment>
                <comment line="511">
                                        
                </comment>
                <declaration name="length" type="int" line="392"/>
                <declaration name="node" type="SnmpMibNode" line="393"/>
                <declaration name="data" type="Object" line="402"/>
                <declaration name="pduVersion" type="int" line="403"/>
                <declaration name="arc" type="long" line="415"/>
                <declaration name="result" type="long[]" line="417"/>
                <scope line="420">
                    <scope line="422">
                        <declaration name="table" type="SnmpMibTable" line="427"/>
                        <scope line="431"/>
                        <scope line="435"/>
                        <scope line="437"/>
                    </scope>
                    <scope line="443">
                        <scope line="446">
                            <scope line="458"/>
                            <scope line="460"/>
                            <scope line="462"/>
                        </scope>
                    </scope>
                    <scope line="480">
                        <declaration name="child" type="SnmpMibNode" line="487"/>
                        <scope line="489">
                            <scope line="491"/>
                            <scope line="497"/>
                        </scope>
                    </scope>
                </scope>
                <scope line="508">
                    <declaration name="newOid" type="long[]" line="512"/>
                </scope>
            </method>
        </class>
    </source>