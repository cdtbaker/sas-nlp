<?xml version="1.0" encoding="UTF-8"?>
    <source package="com.sun.jmx.snmp.agent">
        <import package="java.io.Serializable"/>
        <import package="java.util.Hashtable"/>
        <import package="java.util.Enumeration"/>
        <import package="java.util.Vector"/>
        <import package="com.sun.jmx.snmp.SnmpOid"/>
        <import package="com.sun.jmx.snmp.SnmpValue"/>
        <import package="com.sun.jmx.snmp.SnmpVarBind"/>
        <import package="com.sun.jmx.snmp.SnmpStatusException"/>
        <import package="com.sun.jmx.snmp.agent.SnmpMibOid"/>
        <import package="com.sun.jmx.snmp.agent.SnmpMibNode"/>
        <class name="SnmpMibGroup" line="47">
            <extends class="SnmpMibOid"/>
            <comment line="64">
                We will register the OID arcs leading to subgroups in this hashtable.
                 So for each arc in varList, if the arc is also in subgroups, it leads
                 to a subgroup, if it is not in subgroup, it leads either to a table
                 or to a variable.                
            </comment>
            <comment line="124">
                -------------------------------------------------------------------
                 We use a hashtable (subgroup) in order to determine whether an
                 OID arc leads to a subgroup. This implementation can be changed if
                 needed...
                 For instance, the subclass could provide a generated isNestedArc()
                 method in which the subgroup OID arcs would be hardcoded.
                 However, the generic approach was prefered because at this time
                 groups and subgroups are dynamically registered in the MIB.                
            </comment>
            <comment line="241">
                --------------------------------------------------------------------
                 If we reach this node, we are below the root OID, so we just
                 return.
                 --------------------------------------------------------------------                
            </comment>
            <comment line="249">
                -------------------------------------------------------------------
                 PACKAGE METHODS
                 -------------------------------------------------------------------                
            </comment>
            <comment line="253">
                -------------------------------------------------------------------
                 This method can also be overriden in a subclass to provide a
                 different implementation of the isNestedArc() method.
                 =&gt; if isNestedArc() is hardcoded, then registerSubArc() becomes
                    useless and can become empty.                
            </comment>
            <comment line="273">
                -------------------------------------------------------------------
                 The SnmpMibOid algorithm relies on the fact that for every arc
                 registered in varList, there is a corresponding node at the same
                 position in children.
                 So the trick is to register a null node in children for each variable
                 in varList, so that the real subgroup nodes can be inserted at the
                 correct location.
                 registerObject() should be called for each scalar object and each
                 table arc by the generated subclass.                
            </comment>
            <comment line="302">
                -------------------------------------------------------------------
                 registerNode() will be called at runtime when nested groups are
                 registered in the MIB. So we do know that this method will only
                 be called to register nested-groups.
                 We trap registerNode() in order to call registerSubArc()                
            </comment>
            <comment line="326">
                -------------------------------------------------------------------
                 see comments in SnmpMibNode
                 -------------------------------------------------------------------                
            </comment>
            <comment line="385">
                -------------------------------------------------------------------
                 See comments in SnmpMibNode.
                 -------------------------------------------------------------------                
            </comment>
            <implements interface="Serializable"/>
            <javadoc line="47">
                Represents a node in an SNMP MIB which corresponds to a group.
                  This class allows subnodes to be registered below a group, providing
                  support for nested groups. The subnodes are registered at run time
                  when registering the nested groups in the global MIB OID tree.
                  &lt;P&gt;
                  This class is used by the class generated by &lt;CODE&gt;mibgen&lt;/CODE&gt;.
                  You should not need to use this class directly.
                  &lt;p&gt;&lt;b&gt;This API is a Sun Microsystems internal API  and is subject
                  to change without notice.&lt;/b&gt;&lt;/p&gt;                
            </javadoc>
            <declaration name="subgroups" type="Hashtable&lt;Long,Long&gt;" line="67"/>
            <method name="isTable" type="boolean" line="69"/>
            <javadoc line="69">
                Tells whether the given arc identifies a table in this group.                
                <param>
                    arc An OID arc.                    
                </param>
                <return>
                    <CODE>true</CODE> if `arc' leads to a table.                    
                </return>
            </javadoc>
            <method name="isVariable" type="boolean" line="78"/>
            <javadoc line="78">
                Tells whether the given arc identifies a variable (scalar object) in
                  this group.                
                <param>
                    arc An OID arc.                    
                </param>
                <return>
                    <CODE>true</CODE> if `arc' leads to a variable.                    
                </return>
            </javadoc>
            <method name="isReadable" type="boolean" line="88"/>
            <javadoc line="88">
                Tells whether the given arc identifies a readable scalar object in
                  this group.                
                <param>
                    arc An OID arc.                    
                </param>
                <return>
                    <CODE>true</CODE> if `arc' leads to a readable variable.                    
                </return>
            </javadoc>
            <method name="getTable" type="SnmpMibTable" line="99"/>
            <javadoc line="99">
                Gets the table identified by the given `arc&apos;.                
                <param>
                    arc An OID arc.                    
                </param>
                <return>
                    The <CODE>SnmpMibTable</CODE> identified by `arc', or
                      <CODE>null</CODE> if `arc' does not identify any table.                    
                </return>
            </javadoc>
            <javadoc line="109">
                Checks whether the given OID arc identifies a variable (scalar
                  object).                
                <exception>
                    If the given `arc' does not identify any variable in this
                      group, throws an SnmpStatusException.                    
                </exception>
            </javadoc>
            <method name="validateVarId" type="void" line="117">
                <params>
                    <param name="arc" type="long"/>
                    <param name="userData" type="Object"/>
                </params>
            </method>
            <javadoc line="132">
                Tell whether the given OID arc identifies a sub-tree
                  leading to a nested SNMP sub-group. This method is used internally.
                  You shouldn&apos;t need to call it directly.                
                <param>
                    arc An OID arc.                    
                </param>
                <return>
                    <CODE>true</CODE> if the given OID arc identifies a subtree
                      leading to a nested SNMP sub-group.                    
                </return>
            </javadoc>
            <method name="isNestedArc" type="boolean" line="143">
                <params>
                    <param name="arc" type="long"/>
                </params>
                <comment line="147">
                    if the arc is registered in the hashtable,
                     it leads to a subgroup.                    
                </comment>
                <declaration name="obj" type="Object" line="145"/>
            </method>
            <method name="get" type="void" line="151"/>
            <javadoc line="151">
                Generic handling of the &lt;CODE&gt;get&lt;/CODE&gt; operation.
                  &lt;p&gt;The actual implementation of this method will be generated
                  by mibgen. Usually, this implementation only delegates the
                  job to some other provided runtime class, which knows how to
                  access the MBean. The current toolkit thus provides two
                  implementations:
                  &lt;ul&gt;&lt;li&gt;The standard implementation will directly access the
                  MBean through a java reference,&lt;/li&gt;
                  &lt;li&gt;The generic implementation will access the MBean through
                  the MBean server.&lt;/li&gt;
                  &lt;/ul&gt;
                  &lt;p&gt;Both implementations rely upon specific - and distinct, set of
                  mibgen generated methods.
                  &lt;p&gt; You can override this method if you need to implement some
                  specific policies for minimizing the accesses made to some remote
                  underlying resources.
                  &lt;p&gt;                
                <param>
                    req   The sub-request that must be handled by this node.                    
                </param>
                <param>
                    depth The depth reached in the OID tree.                    
                </param>
                <exception>
                    SnmpStatusException An error occurred while accessing
                      the MIB node.                    
                </exception>
            </javadoc>
            <method name="set" type="void" line="180"/>
            <javadoc line="180">
                Generic handling of the &lt;CODE&gt;set&lt;/CODE&gt; operation.
                  &lt;p&gt;The actual implementation of this method will be generated
                  by mibgen. Usually, this implementation only delegates the
                  job to some other provided runtime class, which knows how to
                  access the MBean. The current toolkit thus provides two
                  implementations:
                  &lt;ul&gt;&lt;li&gt;The standard implementation will directly access the
                  MBean through a java reference,&lt;/li&gt;
                  &lt;li&gt;The generic implementation will access the MBean through
                  the MBean server.&lt;/li&gt;
                  &lt;/ul&gt;
                  &lt;p&gt;Both implementations rely upon specific - and distinct, set of
                  mibgen generated methods.
                  &lt;p&gt; You can override this method if you need to implement some
                  specific policies for minimizing the accesses made to some remote
                  underlying resources.
                  &lt;p&gt;                
                <param>
                    req   The sub-request that must be handled by this node.                    
                </param>
                <param>
                    depth The depth reached in the OID tree.                    
                </param>
                <exception>
                    SnmpStatusException An error occurred while accessing
                      the MIB node.                    
                </exception>
            </javadoc>
            <method name="check" type="void" line="209"/>
            <javadoc line="209">
                Generic handling of the &lt;CODE&gt;check&lt;/CODE&gt; operation.
                  &lt;p&gt;The actual implementation of this method will be generated
                  by mibgen. Usually, this implementation only delegates the
                  job to some other provided runtime class, which knows how to
                  access the MBean. The current toolkit thus provides two
                  implementations:
                  &lt;ul&gt;&lt;li&gt;The standard implementation will directly access the
                  MBean through a java reference,&lt;/li&gt;
                  &lt;li&gt;The generic implementation will access the MBean through
                  the MBean server.&lt;/li&gt;
                  &lt;/ul&gt;
                  &lt;p&gt;Both implementations rely upon specific - and distinct, set of
                  mibgen generated methods.
                  &lt;p&gt; You can override this method if you need to implement some
                  specific policies for minimizing the accesses made to some remote
                  underlying resources, or if you need to implement some consistency
                  checks between the different values provided in the varbind list.
                  &lt;p&gt;                
                <param>
                    req   The sub-request that must be handled by this node.                    
                </param>
                <param>
                    depth The depth reached in the OID tree.                    
                </param>
                <exception>
                    SnmpStatusException An error occurred while accessing
                      the MIB node.                    
                </exception>
            </javadoc>
            <method name="getRootOid" type="void" line="244">
                <params>
                    <param name="result" type="Vector"/>
                </params>
            </method>
            <javadoc line="257">
                Register an OID arc that identifies a sub-tree
                  leading to a nested SNMP sub-group. This method is used internally.
                  You shouldn&apos;t ever call it directly.                
                <param>
                    arc An OID arc.                    
                </param>
            </javadoc>
            <method name="registerNestedArc" type="void" line="265">
                <params>
                    <param name="arc" type="long"/>
                </params>
                <comment line="269">
                    registers the arc in the hashtable.                    
                </comment>
                <declaration name="obj" type="Long" line="266"/>
            </method>
            <javadoc line="281">
                Register an OID arc that identifies a scalar object or a table.
                  This method is used internally. You shouldn&apos;t ever call it directly.                
                <param>
                    arc An OID arc.                    
                </param>
            </javadoc>
            <method name="registerObject" type="void" line="289">
                <params>
                    <param name="arc" type="long"/>
                </params>
                <comment line="292">
                    this will register the variable in both varList and children
                     The node registered in children will be null, so that the parent
                     algorithm will behave as if no node were registered. This is a
                     trick that makes the parent algorithm behave as if only subgroups
                     were registered in varList and children.                    
                </comment>
                <declaration name="oid" type="long[]" line="296"/>
            </method>
            <javadoc line="306">
                Register a child node of this node in the OID tree.
                  This method is used internally. You shouldn&apos;t ever call it directly.                
                <param>
                    oid The oid of the node being registered.                    
                </param>
                <param>
                    cursor The position reached in the oid.                    
                </param>
                <param>
                    node The node being registered.                    
                </param>
            </javadoc>
            <method name="registerNode" type="void" line="316">
                <params>
                    <param name="oid" type="long[]"/>
                    <param name="cursor" type="int"/>
                    <param name="node" type="SnmpMibNode"/>
                </params>
                <comment line="321">
                    if we get here, then it means we are registering a subgroup.
                     We will thus register the sub arc in the subgroups hashtable.                    
                </comment>
            </method>
            <method name="findHandlingNode" type="void" line="331">
                <params>
                    <param name="varbind" type="SnmpVarBind"/>
                    <param name="oid" type="long[]"/>
                    <param name="depth" type="int"/>
                    <param name="handlers" type="SnmpRequestTree"/>
                </params>
                <comment line="343">
                    Nothing is left... the oid is not valid                    
                </comment>
                <comment line="350">
                    This arc leads to a subgroup: delegates the search to the
                     method defined in SnmpMibOid                    
                </comment>
                <comment line="355">
                    This arc leads to a table: forward the search to the table.                    
                </comment>
                <comment line="357">
                    Gets the table                    
                </comment>
                <comment line="360">
                    Forward the search to the table                    
                </comment>
                <comment line="364">
                    If it&apos;s not a variable, throws an exception                    
                </comment>
                <comment line="367">
                    The trailing .0 is missing in the OID                    
                </comment>
                <comment line="371">
                    There are too many arcs left in the OID (there should remain
                     a single trailing .0)                    
                </comment>
                <comment line="376">
                    The last trailing arc is not .0                    
                </comment>
                <comment line="380">
                    It&apos;s one of our variable, register this node.                    
                </comment>
                <declaration name="length" type="int" line="333"/>
                <declaration name="node" type="SnmpMibNode" line="334"/>
                <declaration name="data" type="Object" line="339"/>
                <scope line="341"/>
                <declaration name="arc" type="long" line="346"/>
                <scope line="348"/>
                <scope line="353">
                    <declaration name="table" type="SnmpMibTable" line="357"/>
                </scope>
                <scope line="362"/>
            </method>
            <method name="findNextHandlingNode" type="long[]" line="390">
                <params>
                    <param name="varbind" type="SnmpVarBind"/>
                    <param name="oid" type="long[]"/>
                    <param name="pos" type="int"/>
                    <param name="depth" type="int"/>
                    <param name="handlers" type="SnmpRequestTree"/>
                    <param name="checker" type="AcmChecker"/>
                </params>
                <comment line="397">
                    This should be considered as a genErr, but we do not want to
                     abort the whole request, so we&apos;re going to throw
                     a noSuchObject...                    
                </comment>
                <comment line="407">
                    The generic case where the end of the OID has been reached is
                     handled in the superclass
                     XXX Revisit: this works but it is somewhat convoluted. Just setting
                                  arc to -1 would work too.                    
                </comment>
                <comment line="415">
                    Ok, we&apos;ve got the arc.                    
                </comment>
                <comment line="420">
                    We have a recursive logic. Should we have a loop instead?                    
                </comment>
                <comment line="424">
                    If the arc identifies a table, then we need to forward
                     the search to the table.                    
                </comment>
                <comment line="427">
                    Gets the table identified by `arc&apos;                    
                </comment>
                <comment line="430">
                    Forward to the table                    
                </comment>
                <comment line="441">
                    Build up the leaf OID                    
                </comment>
                <comment line="445">
                    If the arc identifies a readable variable, then two cases:                    
                </comment>
                <comment line="448">
                    The end of the OID is reached, so we return the leaf
                     corresponding to the variable identified by `arc&apos;                    
                </comment>
                <comment line="451">
                    Build up the OID
                     result = new SnmpOid(0);
                     result.insert((int)arc);                    
                </comment>
                <comment line="467">
                    Registers this node                    
                </comment>
                <comment line="472">
                    The end of the OID is not yet reached, so we must return
                     the next leaf following the variable identified by `arc&apos;.
                     We cannot return the variable because whatever follows in
                     the OID will be greater or equals to 0, and 0 identifies
                     the variable itself - so we have indeed to return the
                     next object.
                     So we do nothing, because this case is handled at the
                     end of the if ... else if ... else ... block.                    
                </comment>
                <comment line="482">
                    Now if the arc leads to a subgroup, we delegate the
                     search to the child, just as done in SnmpMibNode.                    
                </comment>
                <comment line="486">
                    get the child ( = nested arc node).                    
                </comment>
                <comment line="504">
                    The oid is not valid, we will throw an exception in order
                     to try with the next valid identifier...                    
                </comment>
                <comment line="510">
                    We didn&apos;t find anything at the given arc, so we&apos;re going
                     to try with the next valid arc                    
                </comment>
                <declaration name="length" type="int" line="392"/>
                <declaration name="node" type="SnmpMibNode" line="393"/>
                <declaration name="data" type="Object" line="402"/>
                <declaration name="pduVersion" type="int" line="403"/>
                <declaration name="arc" type="long" line="415"/>
                <declaration name="result" type="long[]" line="417"/>
                <scope line="420">
                    <scope line="422">
                        <declaration name="table" type="SnmpMibTable" line="427"/>
                        <scope line="431"/>
                        <scope line="435"/>
                        <scope line="437"/>
                    </scope>
                    <scope line="443">
                        <scope line="446">
                            <scope line="458"/>
                            <scope line="460"/>
                            <scope line="462"/>
                        </scope>
                    </scope>
                    <scope line="480">
                        <declaration name="child" type="SnmpMibNode" line="487"/>
                        <scope line="489">
                            <scope line="491"/>
                            <scope line="497"/>
                        </scope>
                    </scope>
                </scope>
                <scope line="508">
                    <declaration name="newOid" type="long[]" line="512"/>
                </scope>
            </method>
        </class>
    </source>