<?xml version="1.0" encoding="UTF-8"?>
    <source package="com.sun.jmx.mbeanserver">
        <import package="java.io.InvalidObjectException"/>
        <import package="java.lang.reflect.Type"/>
        <import package="javax.management.openmbean.OpenDataException"/>
        <import package="javax.management.openmbean.OpenType"/>
        <class name="MXBeanMapping" line="33">
            <javadoc line="33">
                &lt;p&gt;A custom mapping between Java types and Open types for use in MXBeans.
                  To define such a mapping, subclass this class and define at least the{@link #fromOpenValue fromOpenValue} and {@link #toOpenValue toOpenValue}methods, and optionally the {@link #checkReconstructible} method.
                  Then either use an {@link MXBeanMappingClass} annotation on your custom
                  Java types, or include this MXBeanMapping in an{@link MXBeanMappingFactory}.&lt;/p&gt;
                  &lt;p&gt;For example, suppose we have a class {@code MyLinkedList}, which looks
                  like this:&lt;/p&gt;
                  &lt;pre&gt;
                  public class MyLinkedList {
                  public MyLinkedList(String name, MyLinkedList next) {...}
                  public String getName() {...}
                  public MyLinkedList getNext() {...}
                  }
                  &lt;/pre&gt;
                  &lt;p&gt;This is not a valid type for MXBeans, because it contains a
                  self-referential property &quot;next&quot; defined by the {@code getNext()}method.  MXBeans do not support recursive types.  So we would like
                  to specify a mapping for {@code MyLinkedList} explicitly. When an
                  MXBean interface contains {@code MyLinkedList}, that will be mapped
                  into a {@code String[]}, which is a valid Open Type.&lt;/p&gt;
                  &lt;p&gt;To define this mapping, we first subclass {@code MXBeanMapping}:&lt;/p&gt;
                  &lt;pre&gt;
                  public class MyLinkedListMapping extends MXBeanMapping {
                  public MyLinkedListMapping(Type type) throws OpenDataException {
                  super(MyLinkedList.class, ArrayType.getArrayType(SimpleType.STRING));
                  if (type != MyLinkedList.class)
                  throw new OpenDataException(&quot;Mapping only valid for MyLinkedList&quot;);
                  }{@literal @Override}public Object fromOpenValue(Object openValue) throws InvalidObjectException {
                  String[] array = (String[]) openValue;
                  MyLinkedList list = null;
                  for (int i = array.length - 1; i &amp;gt;= 0; i--)
                  list = new MyLinkedList(array[i], list);
                  return list;
                  }{@literal @Override}public Object toOpenValue(Object javaValue) throws OpenDataException {
                  ArrayList&amp;lt;String&amp;gt; array = new ArrayList&amp;lt;String&amp;gt;();
                  for (MyLinkedList list = (MyLinkedList) javaValue; list != null;
                  list = list.getNext())
                  array.add(list.getName());
                  return array.toArray(new String[0]);
                  }
                  }
                  &lt;/pre&gt;
                  &lt;p&gt;The call to the superclass constructor specifies what the
                  original Java type is ({@code MyLinkedList.class}) and what Open
                  Type it is mapped to ({@codeArrayType.getArrayType(SimpleType.STRING)}). The {@codefromOpenValue} method says how we go from the Open Type ({@codeString[]}) to the Java type ({@code MyLinkedList}), and the {@codetoOpenValue} method says how we go from the Java type to the Open
                  Type.&lt;/p&gt;
                  &lt;p&gt;With this mapping defined, we can annotate the {@code MyLinkedList}class appropriately:&lt;/p&gt;
                  &lt;pre&gt;{@literal @MXBeanMappingClass}(MyLinkedListMapping.class)
                  public class MyLinkedList {...}
                  &lt;/pre&gt;
                  &lt;p&gt;Now we can use {@code MyLinkedList} in an MXBean interface and it
                  will work.&lt;/p&gt;
                  &lt;p&gt;If we are unable to modify the {@code MyLinkedList} class,
                  we can define an {@link MXBeanMappingFactory}.  See the documentation
                  of that class for further details.&lt;/p&gt;                
                <see>
                    <a href="../MXBean.html#custom">MXBean specification, section
                      "Custom MXBean type mappings"</a>                    
                </see>
            </javadoc>
            <declaration name="javaType" type="Type" line="118"/>
            <declaration name="openType" type="OpenType&lt;?&gt;" line="119"/>
            <declaration name="openClass" type="Class&lt;?&gt;" line="120"/>
            <javadoc line="122">
                &lt;p&gt;Construct a mapping between the given Java type and the given
                  Open Type.&lt;/p&gt;                
                <param>
                    javaType the Java type (for example, {@code MyLinkedList}).                    
                </param>
                <param>
                    openType the Open Type (for example, {@codeArrayType.getArrayType(SimpleType.STRING)})                    
                </param>
                <throws>
                    NullPointerException if either argument is null.                    
                </throws>
            </javadoc>
            <method name="MXBeanMapping" type="constructor" line="132">
                <params>
                    <param name="javaType" type="Type"/>
                    <param name="openType" type="OpenType<?>"/>
                </params>
            </method>
            <javadoc line="140">
                &lt;p&gt;The Java type that was supplied to the constructor.&lt;/p&gt;                
                <return>
                    the Java type that was supplied to the constructor.                    
                </return>
            </javadoc>
            <method name="getJavaType" type="Type" line="144"/>
            <javadoc line="148">
                &lt;p&gt;The Open Type that was supplied to the constructor.&lt;/p&gt;                
                <return>
                    the Open Type that was supplied to the constructor.                    
                </return>
            </javadoc>
            <method name="getOpenType" type="OpenType<?>" line="152"/>
            <javadoc line="156">
                &lt;p&gt;The Java class that corresponds to instances of the{@linkplain #getOpenType() Open Type} for this mapping.&lt;/p&gt;                
                <return>
                    the Java class that corresponds to instances of the
                      Open Type for this mapping.                    
                </return>
                <see>
                    OpenType#getClassName                    
                </see>
            </javadoc>
            <method name="getOpenClass" type="Class<?>" line="163"/>
            <method name="makeOpenClass" type="Class<?>" line="167">
                <params>
                    <param name="javaType" type="Type"/>
                    <param name="openType" type="OpenType<?>"/>
                </params>
                <comment line="174">
                    should not happen                    
                </comment>
                <scope line="170">
                    <declaration name="className" type="String" line="171"/>
                </scope>
                <scope line="173"/>
            </method>
            <method name="fromOpenValue" type="Object" line="178"/>
            <javadoc line="178">
                &lt;p&gt;Convert an instance of the Open Type into the Java type.                
                <param>
                    openValue the value to be converted.                    
                </param>
                <return>
                    the converted value.                    
                </return>
                <throws>
                    InvalidObjectException if the value cannot be converted.                    
                </throws>
            </javadoc>
            <method name="toOpenValue" type="Object" line="187"/>
            <javadoc line="187">
                &lt;p&gt;Convert an instance of the Java type into the Open Type.                
                <param>
                    javaValue the value to be converted.                    
                </param>
                <return>
                    the converted value.                    
                </return>
                <throws>
                    OpenDataException if the value cannot be converted.                    
                </throws>
            </javadoc>
            <javadoc line="197">
                &lt;p&gt;Throw an appropriate InvalidObjectException if we will not
                  be able to convert back from the open data to the original Java
                  object.  The {@link #fromOpenValue fromOpenValue} throws an
                  exception if a given open data value cannot be converted.  This
                  method throws an exception if &lt;em&gt;no&lt;/em&gt; open data values can
                  be converted.  The default implementation of this method never
                  throws an exception.  Subclasses can override it as
                  appropriate.&lt;/p&gt;                
                <throws>
                    InvalidObjectException if {@code fromOpenValue} will throw
                      an exception no matter what its argument is.                    
                </throws>
            </javadoc>
            <method name="checkReconstructible" type="void" line="209"/>
        </class>
    </source>