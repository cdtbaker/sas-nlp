<?xml version="1.0" encoding="UTF-8"?>
    <source package="com.sun.jmx.mbeanserver">
        <import package="com.sun.jmx.mbeanserver.Util"/>
        <import package="java.lang.reflect.Method"/>
        <import package="java.util.Arrays"/>
        <import package="java.util.Comparator"/>
        <import package="java.util.List"/>
        <import package="java.util.Map"/>
        <import package="java.util.Set"/>
        <import package="javax.management.NotCompliantMBeanException"/>
        <class name="MBeanAnalyzer" line="38">
            <type_params>
                <type_param name="M"/>
            </type_params>
            <comment line="78">
                                
            </comment>
            <comment line="80">
                                
            </comment>
            <comment line="120">
                Introspect the mbeanInterface and initialize this object&apos;s maps.                
            </comment>
            <comment line="228">
                Eliminate methods that are overridden with a covariant return type.
                Reflection will return both the original and the overriding method
                but only the overriding one is of interest.  We return the methods
                in the same order they arrived in.  This isn&apos;t required by the spec
                but existing code may depend on it and users may be used to seeing
                operations or attributes appear in a particular order.
                
                Because of the way this method works, if the same Method appears
                more than once in the given List then it will be completely deleted!                
            </comment>
            <javadoc line="38">
                &lt;p&gt;An analyzer for a given MBean interface.  The analyzer can
                  be for Standard MBeans or MXBeans, depending on the MBeanIntrospector
                  passed at construction.
                  &lt;p&gt;The analyzer can
                  visit the attributes and operations of the interface, calling
                  a caller-supplied visitor method for each one.&lt;/p&gt;                
                <param>
                    &lt;M&gt;
                       Method or ConvertingMethod according as this is a
                      Standard MBean or an MXBean.                    
                </param>
                <since>
                    1.6                    
                </since>
            </javadoc>
            <interface name="MBeanVisitor">
                <type_params>
                    <type_param name="M"/>
                </type_params>
                <comment line="94">
                    Currently it&apos;s two different but equivalent objects.  This only
                     really impacts proxy generation.  For MBean creation, the
                     cached PerInterface object for an MBean interface means that
                     an analyzer will not be recreated for a second MBean using the
                     same interface.                    
                </comment>
                <method name="visitAttribute" type="void" line="55"/>
                <method name="visitOperation" type="void" line="58"/>
            </interface>
            <method name="visit" type="void" line="62">
                <params>
                    <param name="visitor" type="MBeanVisitor<M>"/>
                </params>
                <comment line="64">
                    visit attributes                    
                </comment>
                <comment line="71">
                    visit operations                    
                </comment>
                <scope line="64">
                    <declaration name="name" type="String" line="65"/>
                    <declaration name="am" type="AttrMethods&lt;M&gt;" line="66"/>
                </scope>
                <scope line="71"/>
            </method>
            <declaration name="opMap" type="Map&lt;String,List&lt;M&gt;&gt;" line="78"/>
            <declaration name="attrMap" type="Map&lt;String,AttrMethods&lt;M&gt;&gt;" line="80"/>
            <class name="AttrMethods" line="82">
                <type_params>
                    <type_param name="M"/>
                </type_params>
                <comment line="94">
                    Currently it&apos;s two different but equivalent objects.  This only
                     really impacts proxy generation.  For MBean creation, the
                     cached PerInterface object for an MBean interface means that
                     an analyzer will not be recreated for a second MBean using the
                     same interface.                    
                </comment>
                <declaration name="getter" type="M" line="83"/>
                <declaration name="setter" type="M" line="84"/>
            </class>
            <javadoc line="87">
                &lt;p&gt;Return an MBeanAnalyzer for the given MBean interface and
                  MBeanIntrospector.  Calling this method twice with the same
                  parameters may return the same object or two different but
                  equivalent objects.                
            </javadoc>
            <method name="analyzer" type="MBeanAnalyzer<M>" line="100">
                <params>
                    <param name="mbeanType" type="Class<?>"/>
                    <param name="introspector" type="MBeanIntrospector<M>"/>
                </params>
                <comment line="94">
                    Currently it&apos;s two different but equivalent objects.  This only
                     really impacts proxy generation.  For MBean creation, the
                     cached PerInterface object for an MBean interface means that
                     an analyzer will not be recreated for a second MBean using the
                     same interface.                    
                </comment>
            </method>
            <method name="MBeanAnalyzer" type="constructor" line="106">
                <params>
                    <param name="mbeanType" type="Class<?>"/>
                    <param name="introspector" type="MBeanIntrospector<M>"/>
                </params>
                <scope line="107"/>
                <scope line="112"/>
                <scope line="114"/>
            </method>
            <method name="initMaps" type="void" line="122">
                <params>
                    <param name="mbeanType" type="Class<?>"/>
                    <param name="introspector" type="MBeanIntrospector<M>"/>
                </params>
                <comment line="127">
                    Run through the methods to detect inconsistencies and to enable                    
                </comment>
                <comment line="144">
                    It&apos;s a getter
                     Check we don&apos;t have both isX and getX                    
                </comment>
                <comment line="161">
                    It&apos;s a setter                    
                </comment>
                <comment line="174">
                    It&apos;s an operation                    
                </comment>
                <comment line="182">
                                        
                </comment>
                <declaration name="methods1" type="List&lt;Method&gt;" line="123"/>
                <declaration name="methods" type="List&lt;Method&gt;" line="124"/>
                <scope line="128">
                    <declaration name="name" type="String" line="129"/>
                    <declaration name="nParams" type="int" line="130"/>
                    <declaration name="cm" type="M" line="132"/>
                    <declaration name="attrName" type="String" line="134"/>
                    <scope line="142">
                        <declaration name="am" type="AttrMethods&lt;M&gt;" line="145"/>
                        <scope line="148">
                            <scope line="149">
                                <declaration name="msg" type="String" line="150"/>
                            </scope>
                        </scope>
                    </scope>
                    <scope line="159">
                        <declaration name="am" type="AttrMethods&lt;M&gt;" line="162"/>
                        <scope line="165">
                            <declaration name="msg" type="String" line="166"/>
                        </scope>
                    </scope>
                    <scope line="172">
                        <declaration name="cms" type="List&lt;M&gt;" line="174"/>
                    </scope>
                </scope>
                <scope line="182">
                    <declaration name="am" type="AttrMethods&lt;M&gt;" line="183"/>
                    <scope line="184">
                        <declaration name="msg" type="String" line="185"/>
                    </scope>
                </scope>
            </method>
            <class name="MethodOrder" line="192">
                <comment line="94">
                    Currently it&apos;s two different but equivalent objects.  This only
                     really impacts proxy generation.  For MBean creation, the
                     cached PerInterface object for an MBean interface means that
                     an analyzer will not be recreated for a second MBean using the
                     same interface.                    
                </comment>
                <implements interface="Comparator">
                    <type_params>
                        <type_param name="Method"/>
                    </type_params>
                </implements>
                <javadoc line="192">
                    A comparator that defines a total order so that methods have the
                      same name and identical signatures appear next to each others.
                      The methods are sorted in such a way that methods which
                      override each other will sit next to each other, with the
                      overridden method first - e.g. Object getFoo() is placed before
                      Integer getFoo(). This makes it possible to determine whether
                      a method overrides another one simply by looking at the method(s)
                      that precedes it in the list. (see eliminateCovariantMethods).                    
                </javadoc>
                <method name="compare" type="int" line="203">
                    <params>
                        <param name="a" type="Method"/>
                        <param name="b" type="Method"/>
                    </params>
                    <comment line="219">
                        Super type comes first: Object, Number, Integer                        
                    </comment>
                    <comment line="222">
                        could assert bret.isAssignableFrom(aret)                        
                    </comment>
                    <declaration name="cmp" type="int" line="204"/>
                    <declaration name="aparams" type="Class&lt;?&gt;[]" line="206"/>
                    <declaration name="bparams" type="Class&lt;?&gt;[]" line="207"/>
                    <scope line="210"/>
                    <declaration name="aret" type="Class&lt;?&gt;" line="214"/>
                    <declaration name="bret" type="Class&lt;?&gt;" line="215"/>
                </method>
                <declaration name="instance" type="MethodOrder" line="223"/>
            </class>
            <method name="eliminateCovariantMethods" type="List<Method>" line="238">
                <params>
                    <param name="startMethods" type="List<Method>"/>
                </params>
                <comment line="240">
                    We are assuming that you never have very many methods with the
                     same name, so it is OK to use algorithms that are quadratic
                     in the number of methods with the same name.                    
                </comment>
                <comment line="252">
                    Methods that don&apos;t have the same name can&apos;t override each other                    
                </comment>
                <comment line="255">
                    Methods that have the same name and same signature override
                     each other. In that case, the second method overrides the first,
                     due to the way we have sorted them in MethodOrder.                    
                </comment>
                <declaration name="len" type="int" line="243"/>
                <declaration name="sorted" type="Method[]" line="244"/>
                <declaration name="overridden" type="Set&lt;Method&gt;" line="246"/>
                <scope line="247">
                    <declaration name="m0" type="Method" line="248"/>
                    <declaration name="m1" type="Method" line="249"/>
                    <scope line="258"/>
                </scope>
                <declaration name="methods" type="List&lt;Method&gt;" line="264"/>
            </method>
        </class>
    </source>