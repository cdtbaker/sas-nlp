<?xml version="1.0" encoding="UTF-8"?>
    <source package="com.sun.jmx.remote.security">
        <import package="java.io.FileInputStream"/>
        <import package="java.io.IOException"/>
        <import package="java.security.AccessControlContext"/>
        <import package="java.security.AccessController"/>
        <import package="java.security.Principal"/>
        <import package="java.security.PrivilegedAction"/>
        <import package="java.util.ArrayList"/>
        <import package="java.util.HashMap"/>
        <import package="java.util.Iterator"/>
        <import package="java.util.List"/>
        <import package="java.util.Map"/>
        <import package="java.util.Properties"/>
        <import package="java.util.Set"/>
        <import package="java.util.StringTokenizer"/>
        <import package="java.util.regex.Pattern"/>
        <import package="javax.management.MBeanServer"/>
        <import package="javax.management.ObjectName"/>
        <import package="javax.security.auth.Subject"/>
        <class name="MBeanServerFileAccessController" line="47">
            <extends class="MBeanServerAccessController"/>
            <javadoc line="47">
                &lt;p&gt;An object of this class implements the MBeanServerAccessController
                  interface and, for each of its methods, calls an appropriate checking
                  method and then forwards the request to a wrapped MBeanServer object.
                  The checking method may throw a SecurityException if the operation is
                  not allowed; in this case the request is not forwarded to the
                  wrapped object.&lt;/p&gt;
                  &lt;p&gt;This class implements the {@link #checkRead()}, {@link #checkWrite()},{@link #checkCreate(String)}, and {@link #checkUnregister(ObjectName)}methods based on an access level properties file containing username/access
                  level pairs. The set of username/access level pairs is passed either as a
                  filename which denotes a properties file on disk, or directly as an instance
                  of the {@link Properties} class.  In both cases, the name of each property
                  represents a username, and the value of the property is the associated access
                  level.  Thus, any given username either does not exist in the properties or
                  has exactly one access level. The same access level can be shared by several
                  usernames.&lt;/p&gt;
                  &lt;p&gt;The supported access level values are {@code readonly} and{@code readwrite}.  The {@code readwrite} access level can be
                  qualified by one or more &lt;i&gt;clauses&lt;/i&gt;, where each clause looks
                  like &lt;code&gt;create &lt;i&gt;classNamePattern&lt;/i&gt;&lt;/code&gt; or {@codeunregister}.  For example:&lt;/p&gt;
                  &lt;pre&gt;
                  monitorRole  readonly
                  controlRole  readwrite \
                  create javax.management.timer.,javax.management.monitor. \
                  unregister
                  &lt;/pre&gt;
                  &lt;p&gt;(The continuation lines with {@code \} come from the parser for
                  Properties files.)&lt;/p&gt;                
            </javadoc>
            <declaration name="READONLY" type="String" line="85"/>
            <declaration name="READWRITE" type="String" line="86"/>
            <declaration name="CREATE" type="String" line="88"/>
            <declaration name="UNREGISTER" type="String" line="89"/>
            <class name="Access" line="93">
                <comment line="402">
                    pseudo-codepoint &quot;end of string&quot;                    
                </comment>
                <comment line="407">
                    just for better error messages                    
                </comment>
                <comment line="408">
                    the string we&apos;re parsing                    
                </comment>
                <comment line="409">
                    s.length()                    
                </comment>
                <comment line="412">
                    At any point, either c is s.codePointAt(i), or i == len and                    
                </comment>
                <comment line="413">
                    c is EOS.  We use int rather than char because it is conceivable                    
                </comment>
                <comment line="414">
                    (if unlikely) that a classname in a create clause might contain                    
                </comment>
                <comment line="415">
                    &quot;supplementary characters&quot;, the ones that don&apos;t fit in the original                    
                </comment>
                <comment line="416">
                    16 bits for Unicode.                    
                </comment>
                <comment line="508">
                    Advance c and i to the next character, unless already at EOS.                    
                </comment>
                <declaration name="write" type="boolean" line="94"/>
                <declaration name="createPatterns" type="String[]" line="95"/>
                <declaration name="unregister" type="boolean" line="96"/>
                <method name="Access" type="constructor" line="98">
                    <params>
                        <param name="write" type="boolean"/>
                        <param name="unregister" type="boolean"/>
                        <param name="createPatternList" type="List<String>"/>
                    </params>
                    <declaration name="npats" type="int" line="100"/>
                </method>
                <declaration name="NO_STRINGS" type="String[]" line="108"/>
            </class>
            <javadoc line="111">
                &lt;p&gt;Create a new MBeanServerAccessController that forwards all the
                  MBeanServer requests to the MBeanServer set by invoking the {@link #setMBeanServer} method after doing access checks based on read and
                  write permissions.&lt;/p&gt;
                  &lt;p&gt;This instance is initialized from the specified properties file.&lt;/p&gt;                
                <param>
                    accessFileName name of the file which denotes a properties
                      file on disk containing the username/access level entries.                    
                </param>
                <exception>
                    IOException if the file does not exist, is a
                      directory rather than a regular file, or for some other
                      reason cannot be opened for reading.                    
                </exception>
                <exception>
                    IllegalArgumentException if any of the supplied access
                      level values differs from "readonly" or "readwrite".                    
                </exception>
            </javadoc>
            <method name="MBeanServerFileAccessController" type="constructor" line="130">
                <params>
                    <param name="accessFileName" type="String"/>
                </params>
                <declaration name="props" type="Properties" line="133"/>
            </method>
            <javadoc line="137">
                &lt;p&gt;Create a new MBeanServerAccessController that forwards all the
                  MBeanServer requests to &lt;code&gt;mbs&lt;/code&gt; after doing access checks
                  based on read and write permissions.&lt;/p&gt;
                  &lt;p&gt;This instance is initialized from the specified properties file.&lt;/p&gt;                
                <param>
                    accessFileName name of the file which denotes a properties
                      file on disk containing the username/access level entries.                    
                </param>
                <param>
                    mbs the MBeanServer object to which requests will be forwarded.                    
                </param>
                <exception>
                    IOException if the file does not exist, is a
                      directory rather than a regular file, or for some other
                      reason cannot be opened for reading.                    
                </exception>
                <exception>
                    IllegalArgumentException if any of the supplied access
                      level values differs from "readonly" or "readwrite".                    
                </exception>
            </javadoc>
            <method name="MBeanServerFileAccessController" type="constructor" line="158">
                <params>
                    <param name="accessFileName" type="String"/>
                    <param name="mbs" type="MBeanServer"/>
                </params>
            </method>
            <javadoc line="163">
                &lt;p&gt;Create a new MBeanServerAccessController that forwards all the
                  MBeanServer requests to the MBeanServer set by invoking the {@link #setMBeanServer} method after doing access checks based on read and
                  write permissions.&lt;/p&gt;
                  &lt;p&gt;This instance is initialized from the specified properties
                  instance.  This constructor makes a copy of the properties
                  instance and it is the copy that is consulted to check the
                  username and access level of an incoming connection. The
                  original properties object can be modified without affecting
                  the copy. If the {@link #refresh} method is then called, the
                  &lt;code&gt;MBeanServerFileAccessController&lt;/code&gt; will make a new
                  copy of the properties object at that time.&lt;/p&gt;                
                <param>
                    accessFileProps properties list containing the username/access
                      level entries.                    
                </param>
                <exception>
                    IllegalArgumentException if <code>accessFileProps</code> is
                      <code>null</code> or if any of the supplied access level values differs
                      from "readonly" or "readwrite".                    
                </exception>
            </javadoc>
            <method name="MBeanServerFileAccessController" type="constructor" line="186">
                <params>
                    <param name="accessFileProps" type="Properties"/>
                </params>
            </method>
            <javadoc line="194">
                &lt;p&gt;Create a new MBeanServerAccessController that forwards all the
                  MBeanServer requests to the MBeanServer set by invoking the {@link #setMBeanServer} method after doing access checks based on read and
                  write permissions.&lt;/p&gt;
                  &lt;p&gt;This instance is initialized from the specified properties
                  instance.  This constructor makes a copy of the properties
                  instance and it is the copy that is consulted to check the
                  username and access level of an incoming connection. The
                  original properties object can be modified without affecting
                  the copy. If the {@link #refresh} method is then called, the
                  &lt;code&gt;MBeanServerFileAccessController&lt;/code&gt; will make a new
                  copy of the properties object at that time.&lt;/p&gt;                
                <param>
                    accessFileProps properties list containing the username/access
                      level entries.                    
                </param>
                <param>
                    mbs the MBeanServer object to which requests will be forwarded.                    
                </param>
                <exception>
                    IllegalArgumentException if <code>accessFileProps</code> is
                      <code>null</code> or if any of the supplied access level values differs
                      from "readonly" or "readwrite".                    
                </exception>
            </javadoc>
            <method name="MBeanServerFileAccessController" type="constructor" line="220">
                <params>
                    <param name="accessFileProps" type="Properties"/>
                    <param name="mbs" type="MBeanServer"/>
                </params>
            </method>
            <javadoc line="225">
                Check if the caller can do read operations. This method does
                  nothing if so, otherwise throws SecurityException.                
            </javadoc>
            <method name="checkRead" type="void" line="230"/>
            <javadoc line="234">
                Check if the caller can do write operations.  This method does
                  nothing if so, otherwise throws SecurityException.                
            </javadoc>
            <method name="checkWrite" type="void" line="239"/>
            <javadoc line="243">
                Check if the caller can create MBeans or instances of the given class.
                  This method does nothing if so, otherwise throws SecurityException.                
            </javadoc>
            <method name="checkCreate" type="void" line="248">
                <params>
                    <param name="className" type="String"/>
                </params>
            </method>
            <javadoc line="252">
                Check if the caller can do unregister operations.  This method does
                  nothing if so, otherwise throws SecurityException.                
            </javadoc>
            <method name="checkUnregister" type="void" line="257">
                <params>
                    <param name="name" type="ObjectName"/>
                </params>
            </method>
            <javadoc line="261">
                &lt;p&gt;Refresh the set of username/access level entries.&lt;/p&gt;
                  &lt;p&gt;If this instance was created using the{@link #MBeanServerFileAccessController(String)} or{@link #MBeanServerFileAccessController(String,MBeanServer)}constructors to specify a file from which the entries are read,
                  the file is re-read.&lt;/p&gt;
                  &lt;p&gt;If this instance was created using the{@link #MBeanServerFileAccessController(Properties)} or{@link #MBeanServerFileAccessController(Properties,MBeanServer)}constructors then a new copy of the &lt;code&gt;Properties&lt;/code&gt; object
                  is made.&lt;/p&gt;                
                <exception>
                    IOException if the file does not exist, is a
                      directory rather than a regular file, or for some other
                      reason cannot be opened for reading.                    
                </exception>
                <exception>
                    IllegalArgumentException if any of the supplied access
                      level values differs from "readonly" or "readwrite".                    
                </exception>
            </javadoc>
            <method name="refresh" type="void" line="283">
                <declaration name="props" type="Properties" line="284"/>
            </method>
            <method name="propertiesFromFile" type="Properties" line="293">
                <params>
                    <param name="fname" type="String"/>
                </params>
                <declaration name="fin" type="FileInputStream" line="294"/>
                <scope line="295">
                    <declaration name="p" type="Properties" line="296"/>
                </scope>
                <scope line="299"/>
            </method>
            <method name="checkAccess" type="void" line="304">
                <params>
                    <param name="requiredAccess" type="AccessType"/>
                    <param name="arg" type="String"/>
                </params>
                <comment line="312">
                                        
                </comment>
                <comment line="322">
                    all access entries imply read                    
                </comment>
                <comment line="346">
                    Add some more information to help people with deployments that                    
                </comment>
                <comment line="347">
                    worked before we required explicit create clauses. We&apos;re not giving                    
                </comment>
                <comment line="348">
                    any information to the bad guys, other than that the access control                    
                </comment>
                <comment line="349">
                    is based on a file, which they could have worked out from the stack                    
                </comment>
                <comment line="350">
                    trace anyway.                    
                </comment>
                <declaration name="acc" type="AccessControlContext" line="305"/>
                <anonymous_class line="307">
                    <method name="run" type="Subject" line="308"/>
                </anonymous_class>
                <declaration name="s" type="Subject" line="306"/>
                <declaration name="principals" type="Set" line="313"/>
                <declaration name="newPropertyValue" type="String" line="314"/>
                <scope line="315">
                    <declaration name="p" type="Principal" line="316"/>
                    <declaration name="access" type="Access" line="317"/>
                    <scope line="318">
                        <declaration name="ok" type="boolean" line="319"/>
                    </scope>
                </scope>
                <declaration name="se" type="SecurityException" line="344"/>
                <scope line="351">
                    <declaration name="se2" type="SecurityException" line="352"/>
                </scope>
            </method>
            <method name="checkCreateAccess" type="boolean" line="360">
                <params>
                    <param name="access" type="Access"/>
                    <param name="className" type="String"/>
                </params>
                <scope line="361"/>
            </method>
            <method name="classNameMatch" type="boolean" line="368">
                <params>
                    <param name="pattern" type="String"/>
                    <param name="className" type="String"/>
                </params>
                <comment line="369">
                    We studiously avoided regexes when parsing the properties file,                    
                </comment>
                <comment line="370">
                    because that is done whenever the VM is started with the                    
                </comment>
                <comment line="371">
                    appropriate -Dcom.sun.management options, even if nobody ever                    
                </comment>
                <comment line="372">
                    creates an MBean.  We don&apos;t want to incur the overhead of loading                    
                </comment>
                <comment line="373">
                    all the regex code whenever those options are specified, but if we                    
                </comment>
                <comment line="374">
                    get as far as here then the VM is already running and somebody is                    
                </comment>
                <comment line="375">
                    doing the very unusual operation of remotely creating an MBean.                    
                </comment>
                <comment line="376">
                    Because that operation is so unusual, we don&apos;t try to optimize                    
                </comment>
                <comment line="377">
                    by hand-matching or by caching compiled Pattern objects.                    
                </comment>
                <declaration name="sb" type="StringBuilder" line="378"/>
                <declaration name="stok" type="StringTokenizer" line="379"/>
                <scope line="380">
                    <declaration name="tok" type="String" line="381"/>
                </scope>
            </method>
            <method name="parseProperties" type="void" line="390">
                <params>
                    <param name="props" type="Properties"/>
                </params>
                <scope line="392">
                    <declaration name="identity" type="String" line="393"/>
                    <declaration name="accessString" type="String" line="394"/>
                    <declaration name="access" type="Access" line="395"/>
                </scope>
            </method>
            <class name="Parser" line="400">
                <comment line="402">
                    pseudo-codepoint &quot;end of string&quot;                    
                </comment>
                <comment line="407">
                    just for better error messages                    
                </comment>
                <comment line="408">
                    the string we&apos;re parsing                    
                </comment>
                <comment line="409">
                    s.length()                    
                </comment>
                <comment line="412">
                    At any point, either c is s.codePointAt(i), or i == len and                    
                </comment>
                <comment line="413">
                    c is EOS.  We use int rather than char because it is conceivable                    
                </comment>
                <comment line="414">
                    (if unlikely) that a classname in a create clause might contain                    
                </comment>
                <comment line="415">
                    &quot;supplementary characters&quot;, the ones that don&apos;t fit in the original                    
                </comment>
                <comment line="416">
                    16 bits for Unicode.                    
                </comment>
                <comment line="508">
                    Advance c and i to the next character, unless already at EOS.                    
                </comment>
                <declaration name="EOS" type="int" line="401"/>
                <scope line="402"/>
                <declaration name="identity" type="String" line="406"/>
                <declaration name="s" type="String" line="407"/>
                <declaration name="len" type="int" line="408"/>
                <declaration name="i" type="int" line="409"/>
                <declaration name="c" type="int" line="410"/>
                <method name="Parser" type="constructor" line="417">
                    <params>
                        <param name="identity" type="String"/>
                        <param name="s" type="String"/>
                    </params>
                </method>
                <method name="parseAccess" type="Access" line="428">
                    <params>
                        <param name="identity" type="String"/>
                        <param name="s" type="String"/>
                    </params>
                </method>
                <method name="parseAccess" type="Access" line="432">
                    <declaration name="type" type="String" line="434"/>
                    <declaration name="access" type="Access" line="435"/>
                    <scope line="440"/>
                </method>
                <method name="parseReadWrite" type="Access" line="449">
                    <declaration name="createClasses" type="List&lt;String&gt;" line="450"/>
                    <declaration name="unregister" type="boolean" line="451"/>
                    <scope line="452">
                        <declaration name="type" type="String" line="456"/>
                    </scope>
                </method>
                <method name="parseCreate" type="void" line="467">
                    <params>
                        <param name="createClasses" type="List<String>"/>
                    </params>
                    <scope line="468"/>
                </method>
                <method name="parseClassName" type="String" line="479">
                    <comment line="480">
                        We don&apos;t check that classname components begin with suitable                        
                    </comment>
                    <comment line="481">
                        characters (so we accept 1.2.3 for example).  This means that                        
                    </comment>
                    <comment line="482">
                        there are only two states, which we can call dotOK and !dotOK                        
                    </comment>
                    <comment line="483">
                        according as a dot (.) is legal or not.  Initially we&apos;re in                        
                    </comment>
                    <comment line="484">
                        !dotOK since a classname can&apos;t start with a dot; after a dot                        
                    </comment>
                    <comment line="485">
                        we&apos;re in !dotOK again; and after any other characters we&apos;re in                        
                    </comment>
                    <comment line="486">
                        dotOK.  The classname is only accepted if we end in dotOK,                        
                    </comment>
                    <comment line="487">
                        so we reject an empty name or a name that ends with a dot.                        
                    </comment>
                    <declaration name="start" type="int" line="488"/>
                    <declaration name="dotOK" type="boolean" line="489"/>
                    <scope line="490">
                        <scope line="491"/>
                    </scope>
                    <declaration name="className" type="String" line="501"/>
                </method>
                <method name="next" type="void" line="508">
                    <scope line="509"/>
                </method>
                <method name="skipSpace" type="void" line="518"/>
                <method name="parseWord" type="String" line="523">
                    <declaration name="start" type="int" line="527"/>
                    <declaration name="word" type="String" line="530"/>
                </method>
                <method name="syntax" type="IllegalArgumentException" line="535">
                    <params>
                        <param name="msg" type="String"/>
                    </params>
                </method>
            </class>
            <declaration name="accessMap" type="Map&lt;String,Access&gt;" line="541"/>
            <declaration name="originalProps" type="Properties" line="542"/>
            <declaration name="accessFileName" type="String" line="543"/>
        </class>
    </source>