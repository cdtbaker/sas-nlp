<?xml version="1.0" encoding="UTF-8"?>
    <source package="com.sun.jmx.mbeanserver">
        <import package="com.sun.jmx.mbeanserver.Util"/>
        <import package="java.lang.ref.Reference"/>
        <import package="java.lang.ref.ReferenceQueue"/>
        <import package="java.lang.ref.WeakReference"/>
        <import package="java.util.Map"/>
        <class name="WeakIdentityHashMap" line="37">
            <type_params>
                <type_param name="K"/>
                <type_param name="V"/>
            </type_params>
            <comment line="52">
                The approach
                 is to wrap each key in a WeakReference and use the wrapped value as
                 a key in an ordinary HashMap.  The WeakReference has to be a
                 subclass IdentityWeakReference (IWR) where two IWRs are equal if
                 they refer to the same object.  This enables us to find the entry
                 again.                
            </comment>
            <javadoc line="37">
                &lt;p&gt;A map where keys are compared using identity comparison (like
                  IdentityHashMap) but where the presence of an object as a key in
                  the map does not prevent it being garbage collected (like
                  WeakHashMap).  This class does not implement the Map interface
                  because it is difficult to ensure correct semantics for iterators
                  over the entrySet().&lt;/p&gt;
                  &lt;p&gt;Because we do not implement Map, we do not copy the questionable
                  interface where you can call get(k) or remove(k) for any type of k,
                  which of course can only have an effect if k is of type K.&lt;/p&gt;
                  &lt;p&gt;This map does not support null keys.&lt;/p&gt;                
            </javadoc>
            <method name="WeakIdentityHashMap" type="constructor" line="60"/>
            <method name="make" type="WeakIdentityHashMap<K,V>" line="62"/>
            <method name="get" type="V" line="66">
                <params>
                    <param name="key" type="K"/>
                </params>
                <declaration name="keyref" type="WeakReference&lt;K&gt;" line="68"/>
            </method>
            <method name="put" type="V" line="72">
                <params>
                    <param name="key" type="K"/>
                    <param name="value" type="V"/>
                </params>
                <declaration name="keyref" type="WeakReference&lt;K&gt;" line="76"/>
            </method>
            <method name="remove" type="V" line="80">
                <params>
                    <param name="key" type="K"/>
                </params>
                <declaration name="keyref" type="WeakReference&lt;K&gt;" line="82"/>
            </method>
            <method name="expunge" type="void" line="86">
                <declaration name="ref" type="Reference&lt;? extends K&gt;" line="87"/>
            </method>
            <method name="makeReference" type="WeakReference<K>" line="92">
                <params>
                    <param name="referent" type="K"/>
                </params>
            </method>
            <method name="makeReference" type="WeakReference<K>" line="96">
                <params>
                    <param name="referent" type="K"/>
                    <param name="q" type="ReferenceQueue<K>"/>
                </params>
            </method>
            <class name="IdentityWeakReference" line="100">
                <type_params>
                    <type_param name="T"/>
                </type_params>
                <extends class="WeakReference">
                    <type_params>
                        <type_param name="T"/>
                    </type_params>
                </extends>
                <javadoc line="100">
                    WeakReference where equals and hashCode are based on the
                      referent.  More precisely, two objects are equal if they are
                      identical or if they both have the same non-null referent.  The
                      hashCode is the value the original referent had.  Even if the
                      referent is cleared, the hashCode remains.  Thus, objects of
                      this class can be used as keys in hash-based maps and sets.                    
                </javadoc>
                <method name="IdentityWeakReference" type="constructor" line="109">
                    <params>
                        <param name="o" type="T"/>
                    </params>
                </method>
                <method name="IdentityWeakReference" type="constructor" line="113">
                    <params>
                        <param name="o" type="T"/>
                        <param name="q" type="ReferenceQueue<T>"/>
                    </params>
                </method>
                <method name="equals" type="boolean" line="118">
                    <params>
                        <param name="o" type="Object"/>
                    </params>
                    <declaration name="wr" type="IdentityWeakReference&lt;?&gt;" line="123"/>
                    <declaration name="got" type="Object" line="124"/>
                </method>
                <method name="hashCode" type="int" line="128"/>
                <declaration name="hashCode" type="int" line="132"/>
            </class>
            <declaration name="map" type="Map&lt;WeakReference&lt;K&gt;,V&gt;" line="135"/>
            <declaration name="refQueue" type="ReferenceQueue&lt;K&gt;" line="136"/>
        </class>
    </source>