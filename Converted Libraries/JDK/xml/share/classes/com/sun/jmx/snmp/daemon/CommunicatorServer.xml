<?xml version="1.0" encoding="UTF-8"?>
    <source package="com.sun.jmx.snmp.daemon">
        <import package="java.io.ObjectInputStream"/>
        <import package="java.io.IOException"/>
        <import package="java.net.InetAddress"/>
        <import package="java.util.Enumeration"/>
        <import package="java.util.logging.Level"/>
        <import package="java.util.Vector"/>
        <import package="java.util.NoSuchElementException"/>
        <import package="javax.management.MBeanServer"/>
        <import package="javax.management.MBeanRegistration"/>
        <import package="javax.management.ObjectName"/>
        <import package="javax.management.NotificationListener"/>
        <import package="javax.management.NotificationFilter"/>
        <import package="javax.management.NotificationBroadcaster"/>
        <import package="javax.management.NotificationBroadcasterSupport"/>
        <import package="javax.management.MBeanNotificationInfo"/>
        <import package="javax.management.AttributeChangeNotification"/>
        <import package="javax.management.ListenerNotFoundException"/>
        <import package="javax.management.loading.ClassLoaderRepository"/>
        <import package="javax.management.MBeanServerFactory"/>
        <import package="com.sun.jmx.defaults.JmxProperties.SNMP_ADAPTOR_LOGGER"/>
        <import package="javax.management.remote.MBeanServerForwarder"/>
        <class name="CommunicatorServer" line="23">
            <implements interface="Runnable"/>
            <implements interface="MBeanRegistration"/>
            <implements interface="NotificationBroadcaster"/>
            <implements interface="CommunicatorServerMBean"/>
            <javadoc line="23">
                Defines generic behavior for the server part of a connector or an adaptor.
                  Most connectors or adaptors extend &lt;CODE&gt;CommunicatorServer&lt;/CODE&gt;
                  and inherit this behavior. Connectors or adaptors that do not fit into
                  this model do not extend &lt;CODE&gt;CommunicatorServer&lt;/CODE&gt;.
                  &lt;p&gt;
                  A &lt;CODE&gt;CommunicatorServer&lt;/CODE&gt; is an active object, it listens for
                  client requests  and processes them in its own thread. When necessary, a
                  &lt;CODE&gt;CommunicatorServer&lt;/CODE&gt; creates other threads to process multiple
                  requests concurrently.
                  &lt;p&gt;
                  A &lt;CODE&gt;CommunicatorServer&lt;/CODE&gt; object can be stopped by calling the
                  &lt;CODE&gt;stop&lt;/CODE&gt; method. When it is stopped, the
                  &lt;CODE&gt;CommunicatorServer&lt;/CODE&gt; no longer listens to client requests and
                  no longer holds any thread or communication resources.
                  It can be started again by calling the &lt;CODE&gt;start&lt;/CODE&gt; method.
                  &lt;p&gt;
                  A &lt;CODE&gt;CommunicatorServer&lt;/CODE&gt; has a &lt;CODE&gt;State&lt;/CODE&gt; attribute
                  which reflects its  activity.
                  &lt;p&gt;
                  &lt;TABLE&gt;
                  &lt;TR&gt;&lt;TH&gt;CommunicatorServer&lt;/TH&gt;      &lt;TH&gt;State&lt;/TH&gt;&lt;/TR&gt;
                  &lt;TR&gt;&lt;TD&gt;&lt;CODE&gt;stopped&lt;/CODE&gt;&lt;/TD&gt;    &lt;TD&gt;&lt;CODE&gt;OFFLINE&lt;/CODE&gt;&lt;/TD&gt;&lt;/TR&gt;
                  &lt;TR&gt;&lt;TD&gt;&lt;CODE&gt;starting&lt;/CODE&gt;&lt;/TD&gt;    &lt;TD&gt;&lt;CODE&gt;STARTING&lt;/CODE&gt;&lt;/TD&gt;&lt;/TR&gt;
                  &lt;TR&gt;&lt;TD&gt;&lt;CODE&gt;running&lt;/CODE&gt;&lt;/TD&gt;     &lt;TD&gt;&lt;CODE&gt;ONLINE&lt;/CODE&gt;&lt;/TD&gt;&lt;/TR&gt;
                  &lt;TR&gt;&lt;TD&gt;&lt;CODE&gt;stopping&lt;/CODE&gt;&lt;/TD&gt;     &lt;TD&gt;&lt;CODE&gt;STOPPING&lt;/CODE&gt;&lt;/TD&gt;&lt;/TR&gt;
                  &lt;/TABLE&gt;
                  &lt;p&gt;
                  The &lt;CODE&gt;STARTING&lt;/CODE&gt; state marks the transition
                  from &lt;CODE&gt;OFFLINE&lt;/CODE&gt; to &lt;CODE&gt;ONLINE&lt;/CODE&gt;.
                  &lt;p&gt;
                  The &lt;CODE&gt;STOPPING&lt;/CODE&gt; state marks the transition from
                  &lt;CODE&gt;ONLINE&lt;/CODE&gt; to &lt;CODE&gt;OFFLINE&lt;/CODE&gt;. This occurs when the
                  &lt;CODE&gt;CommunicatorServer&lt;/CODE&gt; is finishing or interrupting active
                  requests.
                  &lt;p&gt;
                  When a &lt;CODE&gt;CommunicatorServer&lt;/CODE&gt; is unregistered from the MBeanServer,
                  it is stopped automatically.
                  &lt;p&gt;
                  When the value of the &lt;CODE&gt;State&lt;/CODE&gt; attribute changes the
                  &lt;CODE&gt;CommunicatorServer&lt;/CODE&gt; sends a
                  &lt;tt&gt;{@link javax.management.AttributeChangeNotification}&lt;/tt&gt; to the
                  registered listeners, if any.
                  &lt;p&gt;&lt;b&gt;This API is a Sun Microsystems internal API  and is subject
                  to change without notice.&lt;/b&gt;&lt;/p&gt;                
            </javadoc>
            <declaration name="ONLINE" type="int" line="70"/>
            <javadoc line="70">
                Represents an &lt;CODE&gt;ONLINE&lt;/CODE&gt; state.                
            </javadoc>
            <declaration name="OFFLINE" type="int" line="74"/>
            <javadoc line="74">
                Represents an &lt;CODE&gt;OFFLINE&lt;/CODE&gt; state.                
            </javadoc>
            <declaration name="STOPPING" type="int" line="78"/>
            <javadoc line="78">
                Represents a &lt;CODE&gt;STOPPING&lt;/CODE&gt; state.                
            </javadoc>
            <declaration name="STARTING" type="int" line="82"/>
            <javadoc line="82">
                Represents a &lt;CODE&gt;STARTING&lt;/CODE&gt; state.                
            </javadoc>
            <declaration name="SNMP_TYPE" type="int" line="86"/>
            <javadoc line="86">
                Indicates that it is an SNMP connector type.                
            </javadoc>
            <declaration name="state" type="int" line="90"/>
            <javadoc line="90">
                The state of the connector server.                
            </javadoc>
            <declaration name="objectName" type="ObjectName" line="94"/>
            <javadoc line="94">
                The object name of the connector server.                
                <serial>
                                        
                </serial>
            </javadoc>
            <declaration name="topMBS" type="MBeanServer" line="99"/>
            <declaration name="bottomMBS" type="MBeanServer" line="100"/>
            <declaration name="dbgTag" type="String" line="101"/>
            <javadoc line="101">
                                
            </javadoc>
            <declaration name="maxActiveClientCount" type="int" line="104"/>
            <javadoc line="104">
                The maximum number of clients that the CommunicatorServer can
                  process concurrently.                
                <serial>
                                        
                </serial>
            </javadoc>
            <declaration name="servedClientCount" type="int" line="110"/>
            <javadoc line="110">
                                
            </javadoc>
            <declaration name="host" type="String" line="113"/>
            <javadoc line="113">
                The host name used by this CommunicatorServer.                
                <serial>
                                        
                </serial>
            </javadoc>
            <declaration name="port" type="int" line="118"/>
            <javadoc line="118">
                The port number used by this CommunicatorServer.                
                <serial>
                                        
                </serial>
            </javadoc>
            <declaration name="stateLock" type="Object" line="123"/>
            <declaration name="clientHandlerVector" type="Vector&lt;ClientHandler&gt;" line="124"/>
            <declaration name="fatherThread" type="Thread" line="125"/>
            <declaration name="mainThread" type="Thread" line="126"/>
            <declaration name="stopRequested" type="boolean" line="127"/>
            <declaration name="interrupted" type="boolean" line="128"/>
            <declaration name="startException" type="Exception" line="129"/>
            <declaration name="notifCount" type="long" line="130"/>
            <declaration name="notifBroadcaster" type="NotificationBroadcasterSupport" line="131"/>
            <declaration name="notifInfos" type="MBeanNotificationInfo[]" line="132"/>
            <javadoc line="133">
                Instantiates a &lt;CODE&gt;CommunicatorServer&lt;/CODE&gt;.                
                <param>
                    connectorType Indicates the connector type. Possible values are:
                      SNMP_TYPE.                    
                </param>
                <exception>
                    <CODE>java.lang.IllegalArgumentException</CODE>
                      This connector type is not correct.                    
                </exception>
            </javadoc>
            <method name="CommunicatorServer" type="constructor" line="140">
                <params>
                    <param name="connectorType" type="int"/>
                </params>
            </method>
            <method name="createMainThread" type="Thread" line="149"/>
            <javadoc line="152">
                Starts this &lt;CODE&gt;CommunicatorServer&lt;/CODE&gt;.
                  &lt;p&gt;
                  Has no effect if this &lt;CODE&gt;CommunicatorServer&lt;/CODE&gt; is
                  &lt;CODE&gt;ONLINE&lt;/CODE&gt; or &lt;CODE&gt;STOPPING&lt;/CODE&gt;.                
                <param>
                    timeout Time in ms to wait for the connector to start.
                      If <code>timeout</code> is positive, wait for at most
                      the specified time. An infinite timeout can be specified
                      by passing a <code>timeout</code> value equals
                      <code>Long.MAX_VALUE</code>. In that case the method
                      will wait until the connector starts or fails to start.
                      If timeout is negative or zero, returns as soon as possible
                      without waiting.                    
                </param>
                <exception>
                    CommunicationException if the connectors fails to start.                    
                </exception>
                <exception>
                    InterruptedException if the thread is interrupted or the
                      timeout expires.                    
                </exception>
            </javadoc>
            <method name="start" type="void" line="169">
                <params>
                    <param name="timeout" type="long"/>
                </params>
                <declaration name="start" type="boolean" line="170"/>
                <scope line="171">
                    <scope line="172"/>
                    <scope line="176"/>
                </scope>
                <scope line="183">
                    <scope line="184"/>
                </scope>
                <scope line="189"/>
            </method>
            <javadoc line="196">
                Starts this &lt;CODE&gt;CommunicatorServer&lt;/CODE&gt;.
                  &lt;p&gt;
                  Has no effect if this &lt;CODE&gt;CommunicatorServer&lt;/CODE&gt; is
                  &lt;CODE&gt;ONLINE&lt;/CODE&gt; or &lt;CODE&gt;STOPPING&lt;/CODE&gt;.                
            </javadoc>
            <method name="start" type="void" line="202">
                <scope line="203"/>
                <scope line="206">
                    <scope line="207"/>
                </scope>
            </method>
            <javadoc line="212">
                Stops this &lt;CODE&gt;CommunicatorServer&lt;/CODE&gt;.
                  &lt;p&gt;
                  Has no effect if this &lt;CODE&gt;CommunicatorServer&lt;/CODE&gt; is
                  &lt;CODE&gt;OFFLINE&lt;/CODE&gt; or  &lt;CODE&gt;STOPPING&lt;/CODE&gt;.                
            </javadoc>
            <method name="stop" type="void" line="218">
                <scope line="219">
                    <scope line="220">
                        <scope line="221"/>
                    </scope>
                    <scope line="227"/>
                    <scope line="231"/>
                </scope>
                <scope line="236"/>
                <scope line="240"/>
            </method>
            <javadoc line="244">
                Tests whether the &lt;CODE&gt;CommunicatorServer&lt;/CODE&gt; is active.                
                <return>
                    True if connector is <CODE>ONLINE</CODE>; false otherwise.                    
                </return>
            </javadoc>
            <method name="isActive" type="boolean" line="248">
                <scope line="249"/>
            </method>
            <javadoc line="253">
                &lt;p&gt;Waits until either the State attribute of this MBean equals the
                  specified &lt;VAR&gt;wantedState&lt;/VAR&gt; parameter,
                  or the specified  &lt;VAR&gt;timeOut&lt;/VAR&gt; has elapsed.
                  The method &lt;CODE&gt;waitState&lt;/CODE&gt; returns with a boolean value
                  indicating whether the specified &lt;VAR&gt;wantedState&lt;/VAR&gt; parameter
                  equals the value of this MBean&apos;s State attribute at the time the method
                  terminates.&lt;/p&gt;
                  &lt;p&gt;Two special cases for the &lt;VAR&gt;timeOut&lt;/VAR&gt; parameter value are:&lt;/p&gt;
                  &lt;UL&gt;&lt;LI&gt; if &lt;VAR&gt;timeOut&lt;/VAR&gt; is negative then &lt;CODE&gt;waitState&lt;/CODE&gt;
                  returns immediately (i.e. does not wait at all),&lt;/LI&gt;
                  &lt;LI&gt; if &lt;VAR&gt;timeOut&lt;/VAR&gt; equals zero then &lt;CODE&gt;waitState&lt;/CODE&gt;
                  waits untill the value of this MBean&apos;s State attribute
                  is the same as the &lt;VAR&gt;wantedState&lt;/VAR&gt; parameter (i.e. will wait
                  indefinitely if this condition is never met).&lt;/LI&gt;&lt;/UL&gt;                
                <param>
                    wantedState The value of this MBean's State attribute to wait
                      for. <VAR>wantedState</VAR> can be one of:
                      <ul>
                      <li><CODE>CommunicatorServer.OFFLINE</CODE>,</li>
                      <li><CODE>CommunicatorServer.ONLINE</CODE>,</li>
                      <li><CODE>CommunicatorServer.STARTING</CODE>,</li>
                      <li><CODE>CommunicatorServer.STOPPING</CODE>.</li>
                      </ul>                    
                </param>
                <param>
                    timeOut The maximum time to wait for, in milliseconds,
                      if positive.
                      Infinite time out if 0, or no waiting at all if negative.                    
                </param>
                <return>
                    true if the value of this MBean's State attribute is the
                      same as the <VAR>wantedState</VAR> parameter; false otherwise.                    
                </return>
            </javadoc>
            <method name="waitState" type="boolean" line="282">
                <params>
                    <param name="wantedState" type="int"/>
                    <param name="timeOut" type="long"/>
                </params>
                <scope line="283"/>
                <declaration name="endTime" type="long" line="286"/>
                <scope line="288">
                    <scope line="289">
                        <scope line="290">
                            <scope line="291"/>
                        </scope>
                        <scope line="296">
                            <scope line="297">
                                <scope line="298">
                                    <declaration name="toWait" type="long" line="299"/>
                                    <scope line="300">
                                        <scope line="301"/>
                                    </scope>
                                </scope>
                                <scope line="308"/>
                            </scope>
                            <scope line="312">
                                <scope line="313"/>
                            </scope>
                        </scope>
                    </scope>
                    <scope line="320"/>
                </scope>
            </method>
            <javadoc line="326">
                &lt;p&gt;Waits until the communicator is started or timeout expires.                
                <param>
                    timeout Time in ms to wait for the connector to start.
                      If <code>timeout</code> is positive, wait for at most
                      the specified time. An infinite timeout can be specified
                      by passing a <code>timeout</code> value equals
                      <code>Long.MAX_VALUE</code>. In that case the method
                      will wait until the connector starts or fails to start.
                      If timeout is negative or zero, returns as soon as possible
                      without waiting.                    
                </param>
                <exception>
                    CommunicationException if the connectors fails to start.                    
                </exception>
                <exception>
                    InterruptedException if the thread is interrupted or the
                      timeout expires.                    
                </exception>
            </javadoc>
            <method name="waitForStart" type="void" line="340">
                <params>
                    <param name="timeout" type="long"/>
                </params>
                <scope line="341"/>
                <declaration name="startTime" type="long" line="344"/>
                <scope line="345">
                    <scope line="346">
                        <declaration name="elapsed" type="long" line="347"/>
                        <declaration name="remainingTime" type="long" line="348"/>
                        <scope line="349">
                            <scope line="350"/>
                        </scope>
                        <scope line="355"/>
                        <scope line="358">
                            <scope line="359"/>
                        </scope>
                    </scope>
                    <scope line="365">
                        <scope line="366"/>
                    </scope>
                    <scope line="371"/>
                    <scope line="374"/>
                    <scope line="377"/>
                    <scope line="380"/>
                </scope>
            </method>
            <javadoc line="385">
                Gets the state of this &lt;CODE&gt;CommunicatorServer&lt;/CODE&gt; as an integer.                
                <return>
                    <CODE>ONLINE</CODE>, <CODE>OFFLINE</CODE>,
                      <CODE>STARTING</CODE> or <CODE>STOPPING</CODE>.                    
                </return>
            </javadoc>
            <method name="getState" type="int" line="390">
                <scope line="391"/>
            </method>
            <javadoc line="395">
                Gets the state of this &lt;CODE&gt;CommunicatorServer&lt;/CODE&gt; as a string.                
                <return>
                    One of the strings "ONLINE", "OFFLINE", "STARTING" or
                      "STOPPING".                    
                </return>
            </javadoc>
            <method name="getStateString" type="String" line="400"/>
            <javadoc line="403">
                Gets the host name used by this &lt;CODE&gt;CommunicatorServer&lt;/CODE&gt;.                
                <return>
                    The host name used by this <CODE>CommunicatorServer</CODE>.                    
                </return>
            </javadoc>
            <method name="getHost" type="String" line="407">
                <scope line="408"/>
                <scope line="411"/>
            </method>
            <javadoc line="416">
                Gets the port number used by this &lt;CODE&gt;CommunicatorServer&lt;/CODE&gt;.                
                <return>
                    The port number used by this <CODE>CommunicatorServer</CODE>.                    
                </return>
            </javadoc>
            <method name="getPort" type="int" line="420">
                <scope line="421"/>
            </method>
            <javadoc line="425">
                Sets the port number used by this &lt;CODE&gt;CommunicatorServer&lt;/CODE&gt;.                
                <param>
                    port The port number used by this
                      <CODE>CommunicatorServer</CODE>.                    
                </param>
                <exception>
                    java.lang.IllegalStateException This method has been invoked
                      while the communicator was ONLINE or STARTING.                    
                </exception>
            </javadoc>
            <method name="setPort" type="void" line="432">
                <params>
                    <param name="port" type="int"/>
                </params>
                <scope line="433"/>
            </method>
            <method name="getProtocol" type="String" line="439"/>
            <javadoc line="439">
                Gets the protocol being used by this &lt;CODE&gt;CommunicatorServer&lt;/CODE&gt;.                
                <return>
                    The protocol as a string.                    
                </return>
            </javadoc>
            <javadoc line="444">
                Gets the number of clients that have been processed by this
                  &lt;CODE&gt;CommunicatorServer&lt;/CODE&gt;  since its creation.                
                <return>
                    The number of clients handled by this
                      <CODE>CommunicatorServer</CODE>
                      since its creation. This counter is not reset by the
                      <CODE>stop</CODE> method.                    
                </return>
            </javadoc>
            <method name="getServedClientCount" type="int" line="452"/>
            <javadoc line="455">
                Gets the number of clients currently being processed by this
                  &lt;CODE&gt;CommunicatorServer&lt;/CODE&gt;.                
                <return>
                    The number of clients currently being processed by this
                      <CODE>CommunicatorServer</CODE>.                    
                </return>
            </javadoc>
            <method name="getActiveClientCount" type="int" line="461">
                <declaration name="result" type="int" line="462"/>
            </method>
            <javadoc line="465">
                Gets the maximum number of clients that this
                  &lt;CODE&gt;CommunicatorServer&lt;/CODE&gt; can  process concurrently.                
                <return>
                    The maximum number of clients that this
                      <CODE>CommunicatorServer</CODE> can
                      process concurrently.                    
                </return>
            </javadoc>
            <method name="getMaxActiveClientCount" type="int" line="472"/>
            <javadoc line="475">
                Sets the maximum number of clients this
                  &lt;CODE&gt;CommunicatorServer&lt;/CODE&gt; can process concurrently.                
                <param>
                    c The number of clients.                    
                </param>
                <exception>
                    java.lang.IllegalStateException This method has been invoked
                      while the communicator was ONLINE or STARTING.                    
                </exception>
            </javadoc>
            <method name="setMaxActiveClientCount" type="void" line="482">
                <params>
                    <param name="c" type="int"/>
                </params>
                <scope line="483">
                    <scope line="484"/>
                </scope>
            </method>
            <javadoc line="490">
                For SNMP Runtime internal use only.                
            </javadoc>
            <method name="notifyClientHandlerCreated" type="void" line="493">
                <params>
                    <param name="h" type="ClientHandler"/>
                </params>
            </method>
            <javadoc line="496">
                For SNMP Runtime internal use only.                
            </javadoc>
            <method name="notifyClientHandlerDeleted" type="void" line="499">
                <params>
                    <param name="h" type="ClientHandler"/>
                </params>
            </method>
            <javadoc line="503">
                The number of times the communicator server will attempt
                  to bind before giving up.                
            </javadoc>
            <method name="getBindTries" type="int" line="507"/>
            <javadoc line="510">
                The delay, in ms, during which the communicator server will sleep before
                  attempting to bind again.                
            </javadoc>
            <method name="getBindSleepTime" type="long" line="514"/>
            <javadoc line="517">
                For SNMP Runtime internal use only.
                  &lt;p&gt;
                  The &lt;CODE&gt;run&lt;/CODE&gt; method executed by this connector&apos;s main thread.                
            </javadoc>
            <method name="run" type="void" line="522">
                <declaration name="i" type="int" line="523"/>
                <declaration name="success" type="boolean" line="524"/>
                <scope line="525">
                    <declaration name="bindRetries" type="int" line="526"/>
                    <declaration name="sleepTime" type="long" line="527"/>
                    <scope line="528">
                        <scope line="529"/>
                        <scope line="533">
                            <scope line="535"/>
                            <scope line="538"/>
                        </scope>
                    </scope>
                    <scope line="543"/>
                </scope>
                <scope line="547">
                    <scope line="548"/>
                    <scope line="551"/>
                    <scope line="555"/>
                </scope>
                <scope line="561">
                    <scope line="563"/>
                    <scope line="566"/>
                    <scope line="572"/>
                </scope>
                <scope line="576">
                    <scope line="577"/>
                </scope>
                <scope line="582">
                    <scope line="583"/>
                </scope>
                <scope line="588">
                    <scope line="589"/>
                    <scope line="593">
                        <scope line="597"/>
                    </scope>
                    <scope line="601">
                        <scope line="602"/>
                    </scope>
                </scope>
            </method>
            <method name="doError" type="void" line="609"/>
            <javadoc line="609">
                                
            </javadoc>
            <method name="doBind" type="void" line="612"/>
            <javadoc line="612">
                                
            </javadoc>
            <method name="doReceive" type="void" line="615"/>
            <javadoc line="615">
                &lt;CODE&gt;doReceive()&lt;/CODE&gt; should block until a client is available.
                  If this method throws an exception, &lt;CODE&gt;doProcess()&lt;/CODE&gt; is not
                  called but &lt;CODE&gt;doUnbind()&lt;/CODE&gt; is called then &lt;CODE&gt;run()&lt;/CODE&gt;
                  stops.                
            </javadoc>
            <method name="doProcess" type="void" line="622"/>
            <javadoc line="622">
                &lt;CODE&gt;doProcess()&lt;/CODE&gt; is called after &lt;CODE&gt;doReceive()&lt;/CODE&gt;:
                  it should process the requests of the incoming client.
                  If it throws an exception, &lt;CODE&gt;doUnbind()&lt;/CODE&gt; is called and
                  &lt;CODE&gt;run()&lt;/CODE&gt; stops.                
            </javadoc>
            <method name="doUnbind" type="void" line="629"/>
            <javadoc line="629">
                &lt;CODE&gt;doUnbind()&lt;/CODE&gt; is called whenever the connector goes
                  &lt;CODE&gt;OFFLINE&lt;/CODE&gt;, except if &lt;CODE&gt;doBind()&lt;/CODE&gt; has thrown an
                  exception.                
            </javadoc>
            <javadoc line="635">
                Get the &lt;code&gt;MBeanServer&lt;/code&gt; object to which incoming requests are
                  sent.  This is either the MBean server in which this connector is
                  registered, or an &lt;code&gt;MBeanServerForwarder&lt;/code&gt; leading to that
                  server.                
            </javadoc>
            <method name="getMBeanServer" type="MBeanServer" line="641"/>
            <javadoc line="644">
                Set the &lt;code&gt;MBeanServer&lt;/code&gt; object to which incoming
                  requests are sent.  This must be either the MBean server in
                  which this connector is registered, or an
                  &lt;code&gt;MBeanServerForwarder&lt;/code&gt; leading to that server.  An
                  &lt;code&gt;MBeanServerForwarder&lt;/code&gt; &lt;code&gt;mbsf&lt;/code&gt; leads to an
                  MBean server &lt;code&gt;mbs&lt;/code&gt; if
                  &lt;code&gt;mbsf.getMBeanServer()&lt;/code&gt; is either &lt;code&gt;mbs&lt;/code&gt;
                  or an &lt;code&gt;MBeanServerForwarder&lt;/code&gt; leading to
                  &lt;code&gt;mbs&lt;/code&gt;.                
                <exception>
                    IllegalArgumentException if <code>newMBS</code> is neither
                      the MBean server in which this connector is registered nor an
                      <code>MBeanServerForwarder</code> leading to that server.                    
                </exception>
                <exception>
                    IllegalStateException This method has been invoked
                      while the communicator was ONLINE or STARTING.                    
                </exception>
            </javadoc>
            <method name="setMBeanServer" type="void" line="660">
                <params>
                    <param name="newMBS" type="MBeanServer"/>
                </params>
                <scope line="661"/>
                <declaration name="error" type="String" line="664"/>
                <declaration name="seenMBS" type="Vector&lt;MBeanServer&gt;" line="665"/>
                <scope line="666"/>
            </method>
            <javadoc line="673">
                For internal use only.                
            </javadoc>
            <method name="getObjectName" type="ObjectName" line="676"/>
            <javadoc line="679">
                For internal use only.                
            </javadoc>
            <method name="changeState" type="void" line="682">
                <params>
                    <param name="newState" type="int"/>
                </params>
                <declaration name="oldState" type="int" line="683"/>
                <scope line="684"/>
            </method>
            <javadoc line="692">
                Returns the string used in debug traces.                
            </javadoc>
            <method name="makeDebugTag" type="String" line="695"/>
            <javadoc line="698">
                Returns the string used to name the connector thread.                
            </javadoc>
            <method name="makeThreadName" type="String" line="701">
                <declaration name="result" type="String" line="702"/>
            </method>
            <javadoc line="707">
                This method blocks if there are too many active clients.
                  Call to &lt;CODE&gt;wait()&lt;/CODE&gt; is terminated when a client handler
                  thread calls &lt;CODE&gt;notifyClientHandlerDeleted(this)&lt;/CODE&gt; ;                
            </javadoc>
            <method name="waitIfTooManyClients" type="void" line="712">
                <scope line="713">
                    <scope line="714"/>
                </scope>
            </method>
            <javadoc line="720">
                This method blocks until there is no more active client.                
            </javadoc>
            <method name="waitClientTermination" type="void" line="723">
                <declaration name="s" type="int" line="724"/>
                <scope line="725">
                    <scope line="726"/>
                </scope>
                <scope line="730">
                    <scope line="731"/>
                    <scope line="734">
                        <scope line="735"/>
                    </scope>
                </scope>
                <scope line="740">
                    <scope line="741"/>
                </scope>
            </method>
            <javadoc line="746">
                Call &lt;CODE&gt;interrupt()&lt;/CODE&gt; on each pending client.                
            </javadoc>
            <method name="terminateAllClient" type="void" line="749">
                <declaration name="s" type="int" line="750"/>
                <scope line="751">
                    <scope line="752"/>
                </scope>
                <declaration name="handlers" type="ClientHandler[]" line="756"/>
                <scope line="757">
                    <scope line="758"/>
                    <scope line="761">
                        <scope line="762"/>
                    </scope>
                </scope>
            </method>
            <javadoc line="768">
                Controls the way the CommunicatorServer service is deserialized.                
            </javadoc>
            <method name="readObject" type="void" line="771">
                <params>
                    <param name="stream" type="ObjectInputStream"/>
                </params>
            </method>
            <javadoc line="785">
                Adds a listener for the notifications emitted by this
                  CommunicatorServer.
                  There is only one type of notifications sent by the CommunicatorServer:
                  they are &lt;tt&gt;{@link javax.management.AttributeChangeNotification}&lt;/tt&gt;,
                  sent when the &lt;tt&gt;State&lt;/tt&gt; attribute of this CommunicatorServer
                  changes.                
                <param>
                    listener The listener object which will handle the emitted
                      notifications.                    
                </param>
                <param>
                    filter The filter object. If filter is null, no filtering
                      will be performed before handling notifications.                    
                </param>
                <param>
                    handback An object which will be sent back unchanged to the
                      listener when a notification is emitted.                    
                </param>
                <exception>
                    IllegalArgumentException Listener parameter is null.                    
                </exception>
            </javadoc>
            <method name="addNotificationListener" type="void" line="800">
                <params>
                    <param name="listener" type="NotificationListener"/>
                    <param name="filter" type="NotificationFilter"/>
                    <param name="handback" type="Object"/>
                </params>
                <scope line="801"/>
            </method>
            <javadoc line="806">
                Removes the specified listener from this CommunicatorServer.
                  Note that if the listener has been registered with different
                  handback objects or notification filters, all entries corresponding
                  to the listener will be removed.                
                <param>
                    listener The listener object to be removed.                    
                </param>
                <exception>
                    ListenerNotFoundException The listener is not registered.                    
                </exception>
            </javadoc>
            <method name="removeNotificationListener" type="void" line="814">
                <params>
                    <param name="listener" type="NotificationListener"/>
                </params>
                <scope line="815"/>
            </method>
            <javadoc line="820">
                Returns an array of MBeanNotificationInfo objects describing
                  the notification types sent by this CommunicatorServer.
                  There is only one type of notifications sent by the CommunicatorServer:
                  it is &lt;tt&gt;{@link javax.management.AttributeChangeNotification}&lt;/tt&gt;,
                  sent when the &lt;tt&gt;State&lt;/tt&gt; attribute of this CommunicatorServer
                  changes.                
            </javadoc>
            <method name="getNotificationInfo" type="MBeanNotificationInfo[]" line="828">
                <scope line="829">
                    <declaration name="notifTypes" type="String[]" line="831"/>
                </scope>
            </method>
            <javadoc line="836">
                                
            </javadoc>
            <method name="sendStateChangeNotification" type="void" line="838">
                <params>
                    <param name="oldState" type="int"/>
                    <param name="newState" type="int"/>
                </params>
                <declaration name="oldStateString" type="String" line="839"/>
                <declaration name="newStateString" type="String" line="840"/>
                <declaration name="message" type="String" line="841"/>
                <declaration name="notif" type="AttributeChangeNotification" line="843"/>
                <scope line="844"/>
            </method>
            <javadoc line="849">
                                
            </javadoc>
            <method name="getStringForState" type="String" line="851">
                <params>
                    <param name="s" type="int"/>
                </params>
            </method>
            <javadoc line="865">
                Preregister method of connector.                
                <param>
                    server The <CODE>MBeanServer</CODE> in which the MBean will
                      be registered.                    
                </param>
                <param>
                    name The object name of the MBean.                    
                </param>
                <return>
                    The name of the MBean registered.                    
                </return>
                <exception>
                    java.langException This exception should be caught by
                      the <CODE>MBeanServer</CODE> and re-thrown
                      as an <CODE>MBeanRegistrationException</CODE>.                    
                </exception>
            </javadoc>
            <method name="preRegister" type="ObjectName" line="875">
                <params>
                    <param name="server" type="MBeanServer"/>
                    <param name="name" type="ObjectName"/>
                </params>
                <scope line="877">
                    <scope line="878"/>
                </scope>
            </method>
            <javadoc line="886">
                @param registrationDone Indicates whether or not the MBean has been
                  successfully registered in the &lt;CODE&gt;MBeanServer&lt;/CODE&gt;.
                  The value false means that the registration phase has failed.                
            </javadoc>
            <method name="postRegister" type="void" line="891">
                <params>
                    <param name="registrationDone" type="Boolean"/>
                </params>
                <scope line="892">
                    <scope line="893"/>
                </scope>
            </method>
            <javadoc line="898">
                Stop the connector.                
                <exception>
                    java.langException This exception should be caught by
                      the <CODE>MBeanServer</CODE> and re-thrown
                      as an <CODE>MBeanRegistrationException</CODE>.                    
                </exception>
            </javadoc>
            <method name="preDeregister" type="void" line="904">
                <scope line="905"/>
                <declaration name="cstate" type="int" line="909"/>
                <scope line="910"/>
            </method>
            <javadoc line="914">
                Do nothing.                
            </javadoc>
            <method name="postDeregister" type="void" line="917"/>
            <javadoc line="919">
                Load a class using the default loader repository                
            </javadoc>
            <method name="loadClass" type="Class" line="922">
                <params>
                    <param name="className" type="String"/>
                </params>
                <scope line="923"/>
                <scope line="926">
                    <declaration name="clr" type="ClassLoaderRepository" line="927"/>
                </scope>
            </method>
        </class>
    </source>