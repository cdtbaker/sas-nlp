<?xml version="1.0" encoding="UTF-8"?>
    <source package="com.sun.jmx.snmp.daemon">
        <import package="java.io.ObjectInputStream"/>
        <import package="java.io.IOException"/>
        <import package="java.net.InetAddress"/>
        <import package="java.util.Enumeration"/>
        <import package="java.util.logging.Level"/>
        <import package="java.util.Vector"/>
        <import package="java.util.NoSuchElementException"/>
        <import package="javax.management.MBeanServer"/>
        <import package="javax.management.MBeanRegistration"/>
        <import package="javax.management.ObjectName"/>
        <import package="javax.management.NotificationListener"/>
        <import package="javax.management.NotificationFilter"/>
        <import package="javax.management.NotificationBroadcaster"/>
        <import package="javax.management.NotificationBroadcasterSupport"/>
        <import package="javax.management.MBeanNotificationInfo"/>
        <import package="javax.management.AttributeChangeNotification"/>
        <import package="javax.management.ListenerNotFoundException"/>
        <import package="javax.management.loading.ClassLoaderRepository"/>
        <import package="javax.management.MBeanServerFactory"/>
        <import package="com.sun.jmx.defaults.JmxProperties.SNMP_ADAPTOR_LOGGER"/>
        <import package="javax.management.remote.MBeanServerForwarder"/>
        <class name="CommunicatorServer" line="67">
            <comment line="120">
                States of a CommunicatorServer                
            </comment>
            <comment line="144">
                Types of connectors.                
            </comment>
            <comment line="148">
                Indicates that it is an RMI connector type.                
            </comment>
            <comment line="151">
                public static final int RMI_TYPE = 1 ;                
            </comment>
            <comment line="153">
                Indicates that it is an HTTP connector type.                
            </comment>
            <comment line="156">
                public static final int HTTP_TYPE = 2 ;                
            </comment>
            <comment line="158">
                Indicates that it is an HTML connector type.                
            </comment>
            <comment line="161">
                public static final int HTML_TYPE = 3 ;                
            </comment>
            <comment line="168">
                Indicates that it is an HTTPS connector type.                
            </comment>
            <comment line="171">
                public static final int HTTPS_TYPE = 5 ;                
            </comment>
            <comment line="173">
                Package variables                
            </comment>
            <comment line="219">
                Private fields                
            </comment>
            <comment line="223">
                This object controls access to the &quot;state&quot; and &quot;interrupted&quot; variables.
                If held at the same time as the lock on &quot;this&quot;, the &quot;this&quot; lock must                
            </comment>
            <comment line="238">
                Notifs count, broadcaster and info                
            </comment>
            <comment line="884">
                To be defined by the subclass.
                
                 Each method below is called by run() and must be subclassed.
                 If the method sends an exception (Communication or Interrupt), this
                 will end up the run() method and switch the connector offline.
                
                 If it is a CommunicationException, run() will call
                       Debug.printException().
                
                 All these methods should propagate the InterruptedException to inform
                 run() that the connector must be switch OFFLINE.
                
                
                
                 doBind() should do all what is needed before calling doReceive().
                 If doBind() throws an exception, doUnbind() is not to be called
                 and run() ends up.                
            </comment>
            <comment line="988">
                To be called by the subclass if needed                
            </comment>
            <comment line="1167">
                NotificationBroadcaster                
            </comment>
            <comment line="1291">
                MBeanRegistration                
            </comment>
            <implements interface="Runnable"/>
            <implements interface="MBeanRegistration"/>
            <implements interface="NotificationBroadcaster"/>
            <implements interface="CommunicatorServerMBean"/>
            <javadoc line="67">
                Defines generic behavior for the server part of a connector or an adaptor.
                  Most connectors or adaptors extend &lt;CODE&gt;CommunicatorServer&lt;/CODE&gt;
                  and inherit this behavior. Connectors or adaptors that do not fit into
                  this model do not extend &lt;CODE&gt;CommunicatorServer&lt;/CODE&gt;.
                  &lt;p&gt;
                  A &lt;CODE&gt;CommunicatorServer&lt;/CODE&gt; is an active object, it listens for
                  client requests  and processes them in its own thread. When necessary, a
                  &lt;CODE&gt;CommunicatorServer&lt;/CODE&gt; creates other threads to process multiple
                  requests concurrently.
                  &lt;p&gt;
                  A &lt;CODE&gt;CommunicatorServer&lt;/CODE&gt; object can be stopped by calling the
                  &lt;CODE&gt;stop&lt;/CODE&gt; method. When it is stopped, the
                  &lt;CODE&gt;CommunicatorServer&lt;/CODE&gt; no longer listens to client requests and
                  no longer holds any thread or communication resources.
                  It can be started again by calling the &lt;CODE&gt;start&lt;/CODE&gt; method.
                  &lt;p&gt;
                  A &lt;CODE&gt;CommunicatorServer&lt;/CODE&gt; has a &lt;CODE&gt;State&lt;/CODE&gt; attribute
                  which reflects its  activity.
                  &lt;p&gt;
                  &lt;TABLE&gt;
                  &lt;TR&gt;&lt;TH&gt;CommunicatorServer&lt;/TH&gt;      &lt;TH&gt;State&lt;/TH&gt;&lt;/TR&gt;
                  &lt;TR&gt;&lt;TD&gt;&lt;CODE&gt;stopped&lt;/CODE&gt;&lt;/TD&gt;    &lt;TD&gt;&lt;CODE&gt;OFFLINE&lt;/CODE&gt;&lt;/TD&gt;&lt;/TR&gt;
                  &lt;TR&gt;&lt;TD&gt;&lt;CODE&gt;starting&lt;/CODE&gt;&lt;/TD&gt;    &lt;TD&gt;&lt;CODE&gt;STARTING&lt;/CODE&gt;&lt;/TD&gt;&lt;/TR&gt;
                  &lt;TR&gt;&lt;TD&gt;&lt;CODE&gt;running&lt;/CODE&gt;&lt;/TD&gt;     &lt;TD&gt;&lt;CODE&gt;ONLINE&lt;/CODE&gt;&lt;/TD&gt;&lt;/TR&gt;
                  &lt;TR&gt;&lt;TD&gt;&lt;CODE&gt;stopping&lt;/CODE&gt;&lt;/TD&gt;     &lt;TD&gt;&lt;CODE&gt;STOPPING&lt;/CODE&gt;&lt;/TD&gt;&lt;/TR&gt;
                  &lt;/TABLE&gt;
                  &lt;p&gt;
                  The &lt;CODE&gt;STARTING&lt;/CODE&gt; state marks the transition
                  from &lt;CODE&gt;OFFLINE&lt;/CODE&gt; to &lt;CODE&gt;ONLINE&lt;/CODE&gt;.
                  &lt;p&gt;
                  The &lt;CODE&gt;STOPPING&lt;/CODE&gt; state marks the transition from
                  &lt;CODE&gt;ONLINE&lt;/CODE&gt; to &lt;CODE&gt;OFFLINE&lt;/CODE&gt;. This occurs when the
                  &lt;CODE&gt;CommunicatorServer&lt;/CODE&gt; is finishing or interrupting active
                  requests.
                  &lt;p&gt;
                  When a &lt;CODE&gt;CommunicatorServer&lt;/CODE&gt; is unregistered from the MBeanServer,
                  it is stopped automatically.
                  &lt;p&gt;
                  When the value of the &lt;CODE&gt;State&lt;/CODE&gt; attribute changes the
                  &lt;CODE&gt;CommunicatorServer&lt;/CODE&gt; sends a
                  &lt;tt&gt;{@link javax.management.AttributeChangeNotification}&lt;/tt&gt; to the
                  registered listeners, if any.
                  &lt;p&gt;&lt;b&gt;This API is a Sun Microsystems internal API  and is subject
                  to change without notice.&lt;/b&gt;&lt;/p&gt;                
            </javadoc>
            <declaration name="ONLINE" type="int" line="123"/>
            <javadoc line="123">
                Represents an &lt;CODE&gt;ONLINE&lt;/CODE&gt; state.                
            </javadoc>
            <declaration name="OFFLINE" type="int" line="128"/>
            <javadoc line="128">
                Represents an &lt;CODE&gt;OFFLINE&lt;/CODE&gt; state.                
            </javadoc>
            <declaration name="STOPPING" type="int" line="133"/>
            <javadoc line="133">
                Represents a &lt;CODE&gt;STOPPING&lt;/CODE&gt; state.                
            </javadoc>
            <declaration name="STARTING" type="int" line="138"/>
            <javadoc line="138">
                Represents a &lt;CODE&gt;STARTING&lt;/CODE&gt; state.                
            </javadoc>
            <declaration name="SNMP_TYPE" type="int" line="162"/>
            <javadoc line="162">
                Indicates that it is an SNMP connector type.                
            </javadoc>
            <declaration name="state" type="int" line="176"/>
            <javadoc line="176">
                The state of the connector server.                
            </javadoc>
            <declaration name="objectName" type="ObjectName" line="181"/>
            <javadoc line="181">
                The object name of the connector server.                
                <serial>
                                        
                </serial>
            </javadoc>
            <declaration name="topMBS" type="MBeanServer" line="187"/>
            <declaration name="bottomMBS" type="MBeanServer" line="188"/>
            <declaration name="dbgTag" type="String" line="190"/>
            <javadoc line="190">
                                
            </javadoc>
            <declaration name="maxActiveClientCount" type="int" line="194"/>
            <javadoc line="194">
                The maximum number of clients that the CommunicatorServer can
                  process concurrently.                
                <serial>
                                        
                </serial>
            </javadoc>
            <declaration name="servedClientCount" type="int" line="201"/>
            <javadoc line="201">
                                
            </javadoc>
            <declaration name="host" type="String" line="205"/>
            <javadoc line="205">
                The host name used by this CommunicatorServer.                
                <serial>
                                        
                </serial>
            </javadoc>
            <declaration name="port" type="int" line="211"/>
            <javadoc line="211">
                The port number used by this CommunicatorServer.                
                <serial>
                                        
                </serial>
            </javadoc>
            <declaration name="stateLock" type="Object" line="225"/>
            <declaration name="clientHandlerVector" type="Vector&lt;ClientHandler&gt;" line="227"/>
            <declaration name="fatherThread" type="Thread" line="230"/>
            <declaration name="mainThread" type="Thread" line="231"/>
            <declaration name="stopRequested" type="boolean" line="233"/>
            <declaration name="interrupted" type="boolean" line="234"/>
            <declaration name="startException" type="Exception" line="235"/>
            <declaration name="notifCount" type="long" line="238"/>
            <declaration name="notifBroadcaster" type="NotificationBroadcasterSupport" line="239"/>
            <declaration name="notifInfos" type="MBeanNotificationInfo[]" line="241"/>
            <javadoc line="244">
                Instantiates a &lt;CODE&gt;CommunicatorServer&lt;/CODE&gt;.                
                <param>
                    connectorType Indicates the connector type. Possible values are:
                      SNMP_TYPE.                    
                </param>
                <exception>
                    &lt;CODE&gt;java.lang.IllegalArgumentException&lt;/CODE&gt;
                      This connector type is not correct.                    
                </exception>
            </javadoc>
            <method name="CommunicatorServer" type="constructor" line="254">
                <params>
                    <param name="connectorType" type="int"/>
                </params>
                <comment line="258">
                    No op. int Type deciding debugging removed.                    
                </comment>
            </method>
            <method name="createMainThread" type="Thread" line="265"/>
            <javadoc line="269">
                Starts this &lt;CODE&gt;CommunicatorServer&lt;/CODE&gt;.
                  &lt;p&gt;
                  Has no effect if this &lt;CODE&gt;CommunicatorServer&lt;/CODE&gt; is
                  &lt;CODE&gt;ONLINE&lt;/CODE&gt; or &lt;CODE&gt;STOPPING&lt;/CODE&gt;.                
                <param>
                    timeout Time in ms to wait for the connector to start.
                      If &lt;code&gt;timeout&lt;/code&gt; is positive, wait for at most
                      the specified time. An infinite timeout can be specified
                      by passing a &lt;code&gt;timeout&lt;/code&gt; value equals
                      &lt;code&gt;Long.MAX_VALUE&lt;/code&gt;. In that case the method
                      will wait until the connector starts or fails to start.
                      If timeout is negative or zero, returns as soon as possible
                      without waiting.                    
                </param>
                <exception>
                    CommunicationException if the connectors fails to start.                    
                </exception>
                <exception>
                    InterruptedException if the thread is interrupted or the
                      timeout expires.                    
                </exception>
            </javadoc>
            <method name="start" type="void" line="287">
                <params>
                    <param name="timeout" type="long"/>
                </params>
                <comment line="293">
                    Fix for bug 4352451:
                         &quot;java.net.BindException: Address in use&quot;.                    
                </comment>
                <declaration name="start" type="boolean" line="288"/>
                <scope line="290">
                    <scope line="291"/>
                    <scope line="297"/>
                </scope>
                <scope line="305">
                    <scope line="306"/>
                </scope>
                <scope line="313"/>
            </method>
            <javadoc line="325">
                Starts this &lt;CODE&gt;CommunicatorServer&lt;/CODE&gt;.
                  &lt;p&gt;
                  Has no effect if this &lt;CODE&gt;CommunicatorServer&lt;/CODE&gt; is
                  &lt;CODE&gt;ONLINE&lt;/CODE&gt; or &lt;CODE&gt;STOPPING&lt;/CODE&gt;.                
            </javadoc>
            <method name="start" type="void" line="331">
                <comment line="336">
                    cannot happen because of `0&apos;                    
                </comment>
                <scope line="332"/>
                <scope line="334">
                    <scope line="336"/>
                </scope>
            </method>
            <javadoc line="343">
                Stops this &lt;CODE&gt;CommunicatorServer&lt;/CODE&gt;.
                  &lt;p&gt;
                  Has no effect if this &lt;CODE&gt;CommunicatorServer&lt;/CODE&gt; is
                  &lt;CODE&gt;OFFLINE&lt;/CODE&gt; or  &lt;CODE&gt;STOPPING&lt;/CODE&gt;.                
            </javadoc>
            <method name="stop" type="void" line="349">
                <comment line="360">
                    Stop the connector thread                    
                </comment>
                <comment line="374">
                    Call terminate on each active client handler                    
                </comment>
                <comment line="383">
                    ----------------------
                     changeState
                     ----------------------                    
                </comment>
                <scope line="350">
                    <scope line="351">
                        <scope line="352"/>
                    </scope>
                    <scope line="362"/>
                    <scope line="367"/>
                </scope>
                <scope line="376"/>
                <scope line="385"/>
            </method>
            <javadoc line="391">
                Tests whether the &lt;CODE&gt;CommunicatorServer&lt;/CODE&gt; is active.                
                <return>
                    True if connector is &lt;CODE&gt;ONLINE&lt;/CODE&gt;; false otherwise.                    
                </return>
            </javadoc>
            <method name="isActive" type="boolean" line="396">
                <scope line="397"/>
            </method>
            <javadoc line="402">
                &lt;p&gt;Waits until either the State attribute of this MBean equals the
                  specified &lt;VAR&gt;wantedState&lt;/VAR&gt; parameter,
                  or the specified  &lt;VAR&gt;timeOut&lt;/VAR&gt; has elapsed.
                  The method &lt;CODE&gt;waitState&lt;/CODE&gt; returns with a boolean value
                  indicating whether the specified &lt;VAR&gt;wantedState&lt;/VAR&gt; parameter
                  equals the value of this MBean&apos;s State attribute at the time the method
                  terminates.&lt;/p&gt;
                  &lt;p&gt;Two special cases for the &lt;VAR&gt;timeOut&lt;/VAR&gt; parameter value are:&lt;/p&gt;
                  &lt;UL&gt;&lt;LI&gt; if &lt;VAR&gt;timeOut&lt;/VAR&gt; is negative then &lt;CODE&gt;waitState&lt;/CODE&gt;
                  returns immediately (i.e. does not wait at all),&lt;/LI&gt;
                  &lt;LI&gt; if &lt;VAR&gt;timeOut&lt;/VAR&gt; equals zero then &lt;CODE&gt;waitState&lt;/CODE&gt;
                  waits untill the value of this MBean&apos;s State attribute
                  is the same as the &lt;VAR&gt;wantedState&lt;/VAR&gt; parameter (i.e. will wait
                  indefinitely if this condition is never met).&lt;/LI&gt;&lt;/UL&gt;                
                <param>
                    wantedState The value of this MBean&apos;s State attribute to wait
                      for. &lt;VAR&gt;wantedState&lt;/VAR&gt; can be one of:
                      &lt;ul&gt;
                      &lt;li&gt;&lt;CODE&gt;CommunicatorServer.OFFLINE&lt;/CODE&gt;,&lt;/li&gt;
                      &lt;li&gt;&lt;CODE&gt;CommunicatorServer.ONLINE&lt;/CODE&gt;,&lt;/li&gt;
                      &lt;li&gt;&lt;CODE&gt;CommunicatorServer.STARTING&lt;/CODE&gt;,&lt;/li&gt;
                      &lt;li&gt;&lt;CODE&gt;CommunicatorServer.STOPPING&lt;/CODE&gt;.&lt;/li&gt;
                      &lt;/ul&gt;                    
                </param>
                <param>
                    timeOut The maximum time to wait for, in milliseconds,
                      if positive.
                      Infinite time out if 0, or no waiting at all if negative.                    
                </param>
                <return>
                    true if the value of this MBean&apos;s State attribute is the
                      same as the &lt;VAR&gt;wantedState&lt;/VAR&gt; parameter; false otherwise.                    
                </return>
            </javadoc>
            <method name="waitState" type="boolean" line="434">
                <params>
                    <param name="wantedState" type="int"/>
                    <param name="timeOut" type="long"/>
                </params>
                <comment line="466">
                    timeOut == 0                    
                </comment>
                <scope line="435"/>
                <declaration name="endTime" type="long" line="441"/>
                <scope line="445">
                    <scope line="446">
                        <scope line="447">
                            <scope line="448"/>
                        </scope>
                        <scope line="453">
                            <scope line="454">
                                <scope line="455">
                                    <declaration name="toWait" type="long" line="456"/>
                                    <scope line="457">
                                        <scope line="458"/>
                                    </scope>
                                </scope>
                                <scope line="465"/>
                            </scope>
                            <scope line="468">
                                <scope line="469"/>
                            </scope>
                        </scope>
                    </scope>
                    <scope line="477"/>
                </scope>
            </method>
            <javadoc line="485">
                &lt;p&gt;Waits until the communicator is started or timeout expires.                
                <param>
                    timeout Time in ms to wait for the connector to start.
                      If &lt;code&gt;timeout&lt;/code&gt; is positive, wait for at most
                      the specified time. An infinite timeout can be specified
                      by passing a &lt;code&gt;timeout&lt;/code&gt; value equals
                      &lt;code&gt;Long.MAX_VALUE&lt;/code&gt;. In that case the method
                      will wait until the connector starts or fails to start.
                      If timeout is negative or zero, returns as soon as possible
                      without waiting.                    
                </param>
                <exception>
                    CommunicationException if the connectors fails to start.                    
                </exception>
                <exception>
                    InterruptedException if the thread is interrupted or the
                      timeout expires.                    
                </exception>
            </javadoc>
            <method name="waitForStart" type="void" line="503">
                <params>
                    <param name="timeout" type="long"/>
                </params>
                <comment line="515">
                    Time elapsed since startTime...                    
                </comment>
                <comment line="519">
                    wait for timeout - elapsed.
                     A timeout of Long.MAX_VALUE is equivalent to something
                     like 292271023 years - which is pretty close to
                     forever as far as we are concerned ;-)                    
                </comment>
                <comment line="526">
                    If remainingTime is negative, the timeout has elapsed.                    
                </comment>
                <comment line="536">
                    We&apos;re going to wait until someone notifies on the
                     the stateLock object, or until the timeout expires,
                     or until the thread is interrupted.                    
                </comment>
                <comment line="548">
                    If we are now ONLINE, then no need to rethrow the
                     exception... we&apos;re simply going to exit the while
                     loop. Otherwise, throw the InterruptedException.                    
                </comment>
                <comment line="556">
                    We&apos;re no longer in STARTING state                    
                </comment>
                <comment line="559">
                    OK, we&apos;re started, everything went fine, just return                    
                </comment>
                <comment line="567">
                    There was some exception during the starting phase.
                     Cast and throw...                    
                </comment>
                <comment line="572">
                    There was some exception during the starting phase.
                     Cast and throw...                    
                </comment>
                <comment line="577">
                    There was some exception during the starting phase.
                     Wrap and throw...                    
                </comment>
                <comment line="584">
                    We&apos;re not ONLINE, and there&apos;s no exception...
                     Something went wrong but we don&apos;t know what...                    
                </comment>
                <scope line="504"/>
                <declaration name="startTime" type="long" line="510"/>
                <scope line="512">
                    <scope line="513">
                        <declaration name="elapsed" type="long" line="516"/>
                        <declaration name="remainingTime" type="long" line="523"/>
                        <scope line="527">
                            <scope line="528"/>
                        </scope>
                        <scope line="539"/>
                        <scope line="541">
                            <scope line="542"/>
                        </scope>
                    </scope>
                    <scope line="557">
                        <scope line="560"/>
                    </scope>
                    <scope line="565"/>
                    <scope line="570"/>
                    <scope line="575"/>
                    <scope line="582"/>
                </scope>
            </method>
            <javadoc line="592">
                Gets the state of this &lt;CODE&gt;CommunicatorServer&lt;/CODE&gt; as an integer.                
                <return>
                    &lt;CODE&gt;ONLINE&lt;/CODE&gt;, &lt;CODE&gt;OFFLINE&lt;/CODE&gt;,
                      &lt;CODE&gt;STARTING&lt;/CODE&gt; or &lt;CODE&gt;STOPPING&lt;/CODE&gt;.                    
                </return>
            </javadoc>
            <method name="getState" type="int" line="598">
                <scope line="599"/>
            </method>
            <javadoc line="604">
                Gets the state of this &lt;CODE&gt;CommunicatorServer&lt;/CODE&gt; as a string.                
                <return>
                    One of the strings &quot;ONLINE&quot;, &quot;OFFLINE&quot;, &quot;STARTING&quot; or
                      &quot;STOPPING&quot;.                    
                </return>
            </javadoc>
            <method name="getStateString" type="String" line="610"/>
            <javadoc line="614">
                Gets the host name used by this &lt;CODE&gt;CommunicatorServer&lt;/CODE&gt;.                
                <return>
                    The host name used by this &lt;CODE&gt;CommunicatorServer&lt;/CODE&gt;.                    
                </return>
            </javadoc>
            <method name="getHost" type="String" line="619">
                <scope line="620"/>
                <scope line="622"/>
            </method>
            <javadoc line="628">
                Gets the port number used by this &lt;CODE&gt;CommunicatorServer&lt;/CODE&gt;.                
                <return>
                    The port number used by this &lt;CODE&gt;CommunicatorServer&lt;/CODE&gt;.                    
                </return>
            </javadoc>
            <method name="getPort" type="int" line="633">
                <scope line="634"/>
            </method>
            <javadoc line="639">
                Sets the port number used by this &lt;CODE&gt;CommunicatorServer&lt;/CODE&gt;.                
                <param>
                    port The port number used by this
                      &lt;CODE&gt;CommunicatorServer&lt;/CODE&gt;.                    
                </param>
                <exception>
                    java.lang.IllegalStateException This method has been invoked
                      while the communicator was ONLINE or STARTING.                    
                </exception>
            </javadoc>
            <method name="setPort" type="void" line="648">
                <params>
                    <param name="port" type="int"/>
                </params>
                <scope line="649"/>
            </method>
            <method name="getProtocol" type="String" line="658"/>
            <javadoc line="658">
                Gets the protocol being used by this &lt;CODE&gt;CommunicatorServer&lt;/CODE&gt;.                
                <return>
                    The protocol as a string.                    
                </return>
            </javadoc>
            <javadoc line="664">
                Gets the number of clients that have been processed by this
                  &lt;CODE&gt;CommunicatorServer&lt;/CODE&gt;  since its creation.                
                <return>
                    The number of clients handled by this
                      &lt;CODE&gt;CommunicatorServer&lt;/CODE&gt;
                      since its creation. This counter is not reset by the
                      &lt;CODE&gt;stop&lt;/CODE&gt; method.                    
                </return>
            </javadoc>
            <method name="getServedClientCount" type="int" line="673"/>
            <javadoc line="677">
                Gets the number of clients currently being processed by this
                  &lt;CODE&gt;CommunicatorServer&lt;/CODE&gt;.                
                <return>
                    The number of clients currently being processed by this
                      &lt;CODE&gt;CommunicatorServer&lt;/CODE&gt;.                    
                </return>
            </javadoc>
            <method name="getActiveClientCount" type="int" line="684">
                <declaration name="result" type="int" line="685"/>
            </method>
            <javadoc line="689">
                Gets the maximum number of clients that this
                  &lt;CODE&gt;CommunicatorServer&lt;/CODE&gt; can  process concurrently.                
                <return>
                    The maximum number of clients that this
                      &lt;CODE&gt;CommunicatorServer&lt;/CODE&gt; can
                      process concurrently.                    
                </return>
            </javadoc>
            <method name="getMaxActiveClientCount" type="int" line="697"/>
            <javadoc line="701">
                Sets the maximum number of clients this
                  &lt;CODE&gt;CommunicatorServer&lt;/CODE&gt; can process concurrently.                
                <param>
                    c The number of clients.                    
                </param>
                <exception>
                    java.lang.IllegalStateException This method has been invoked
                      while the communicator was ONLINE or STARTING.                    
                </exception>
            </javadoc>
            <method name="setMaxActiveClientCount" type="void" line="711">
                <params>
                    <param name="c" type="int"/>
                </params>
                <scope line="712">
                    <scope line="713"/>
                </scope>
            </method>
            <javadoc line="721">
                For SNMP Runtime internal use only.                
            </javadoc>
            <method name="notifyClientHandlerCreated" type="void" line="724">
                <params>
                    <param name="h" type="ClientHandler"/>
                </params>
            </method>
            <javadoc line="728">
                For SNMP Runtime internal use only.                
            </javadoc>
            <method name="notifyClientHandlerDeleted" type="void" line="731">
                <params>
                    <param name="h" type="ClientHandler"/>
                </params>
            </method>
            <javadoc line="736">
                The number of times the communicator server will attempt
                  to bind before giving up.                
            </javadoc>
            <method name="getBindTries" type="int" line="740"/>
            <javadoc line="744">
                The delay, in ms, during which the communicator server will sleep before
                  attempting to bind again.                
            </javadoc>
            <method name="getBindSleepTime" type="long" line="748"/>
            <javadoc line="752">
                For SNMP Runtime internal use only.
                  &lt;p&gt;
                  The &lt;CODE&gt;run&lt;/CODE&gt; method executed by this connector&apos;s main thread.                
            </javadoc>
            <method name="run" type="void" line="757">
                <comment line="760">
                    Fix jaw.00667.B
                     It seems that the init of &quot;i&quot; and &quot;success&quot;
                     need to be done outside the &quot;try&quot; clause...
                     A bug in Java 2 production release ?                    
                </comment>
                <comment line="768">
                    ----------------------
                     Bind
                     ----------------------                    
                </comment>
                <comment line="772">
                    Fix for bug 4352451: &quot;java.net.BindException: Address in use&quot;.                    
                </comment>
                <comment line="778">
                    Try socket connection.                    
                </comment>
                <comment line="791">
                    Retry last time to get correct exception.                    
                </comment>
                <comment line="794">
                    Try socket connection.                    
                </comment>
                <comment line="817">
                    ----------------------
                     State change
                     ----------------------                    
                </comment>
                <comment line="826">
                    ----------------------
                     Main loop
                     ----------------------                    
                </comment>
                <comment line="858">
                    ----------------------
                     unBind
                     ----------------------                    
                </comment>
                <declaration name="i" type="int" line="764"/>
                <declaration name="success" type="boolean" line="765"/>
                <scope line="770">
                    <declaration name="bindRetries" type="int" line="773"/>
                    <declaration name="sleepTime" type="long" line="774"/>
                    <scope line="775">
                        <scope line="776"/>
                        <scope line="781">
                            <scope line="783"/>
                            <scope line="785"/>
                        </scope>
                    </scope>
                    <scope line="792"/>
                </scope>
                <scope line="798">
                    <scope line="799"/>
                    <scope line="803"/>
                    <scope line="807"/>
                </scope>
                <scope line="815">
                    <scope line="820"/>
                    <scope line="828"/>
                    <scope line="834"/>
                </scope>
                <scope line="839">
                    <scope line="840"/>
                </scope>
                <scope line="845">
                    <scope line="846"/>
                </scope>
                <scope line="851">
                    <scope line="852"/>
                    <scope line="860">
                        <scope line="864"/>
                    </scope>
                    <scope line="868">
                        <scope line="869"/>
                    </scope>
                </scope>
            </method>
            <method name="doError" type="void" line="879"/>
            <javadoc line="879">
                                
            </javadoc>
            <method name="doBind" type="void" line="903"/>
            <javadoc line="903">
                                
            </javadoc>
            <method name="doReceive" type="void" line="908"/>
            <javadoc line="908">
                &lt;CODE&gt;doReceive()&lt;/CODE&gt; should block until a client is available.
                  If this method throws an exception, &lt;CODE&gt;doProcess()&lt;/CODE&gt; is not
                  called but &lt;CODE&gt;doUnbind()&lt;/CODE&gt; is called then &lt;CODE&gt;run()&lt;/CODE&gt;
                  stops.                
            </javadoc>
            <method name="doProcess" type="void" line="917"/>
            <javadoc line="917">
                &lt;CODE&gt;doProcess()&lt;/CODE&gt; is called after &lt;CODE&gt;doReceive()&lt;/CODE&gt;:
                  it should process the requests of the incoming client.
                  If it throws an exception, &lt;CODE&gt;doUnbind()&lt;/CODE&gt; is called and
                  &lt;CODE&gt;run()&lt;/CODE&gt; stops.                
            </javadoc>
            <method name="doUnbind" type="void" line="926"/>
            <javadoc line="926">
                &lt;CODE&gt;doUnbind()&lt;/CODE&gt; is called whenever the connector goes
                  &lt;CODE&gt;OFFLINE&lt;/CODE&gt;, except if &lt;CODE&gt;doBind()&lt;/CODE&gt; has thrown an
                  exception.                
            </javadoc>
            <javadoc line="934">
                Get the &lt;code&gt;MBeanServer&lt;/code&gt; object to which incoming requests are
                  sent.  This is either the MBean server in which this connector is
                  registered, or an &lt;code&gt;MBeanServerForwarder&lt;/code&gt; leading to that
                  server.                
            </javadoc>
            <method name="getMBeanServer" type="MBeanServer" line="940"/>
            <javadoc line="944">
                Set the &lt;code&gt;MBeanServer&lt;/code&gt; object to which incoming
                  requests are sent.  This must be either the MBean server in
                  which this connector is registered, or an
                  &lt;code&gt;MBeanServerForwarder&lt;/code&gt; leading to that server.  An
                  &lt;code&gt;MBeanServerForwarder&lt;/code&gt; &lt;code&gt;mbsf&lt;/code&gt; leads to an
                  MBean server &lt;code&gt;mbs&lt;/code&gt; if
                  &lt;code&gt;mbsf.getMBeanServer()&lt;/code&gt; is either &lt;code&gt;mbs&lt;/code&gt;
                  or an &lt;code&gt;MBeanServerForwarder&lt;/code&gt; leading to
                  &lt;code&gt;mbs&lt;/code&gt;.                
                <exception>
                    IllegalArgumentException if &lt;code&gt;newMBS&lt;/code&gt; is neither
                      the MBean server in which this connector is registered nor an
                      &lt;code&gt;MBeanServerForwarder&lt;/code&gt; leading to that server.                    
                </exception>
                <exception>
                    IllegalStateException This method has been invoked
                      while the communicator was ONLINE or STARTING.                    
                </exception>
            </javadoc>
            <method name="setMBeanServer" type="void" line="963">
                <params>
                    <param name="newMBS" type="MBeanServer"/>
                </params>
                <scope line="964"/>
                <declaration name="error" type="String" line="969"/>
                <declaration name="seenMBS" type="Vector&lt;MBeanServer&gt;" line="973"/>
                <scope line="976"/>
            </method>
            <javadoc line="990">
                For internal use only.                
            </javadoc>
            <method name="getObjectName" type="ObjectName" line="993"/>
            <javadoc line="997">
                For internal use only.                
            </javadoc>
            <method name="changeState" type="void" line="1000">
                <params>
                    <param name="newState" type="int"/>
                </params>
                <declaration name="oldState" type="int" line="1001"/>
                <scope line="1002"/>
            </method>
            <javadoc line="1012">
                Returns the string used in debug traces.                
            </javadoc>
            <method name="makeDebugTag" type="String" line="1015"/>
            <javadoc line="1019">
                Returns the string used to name the connector thread.                
            </javadoc>
            <method name="makeThreadName" type="String" line="1022">
                <declaration name="result" type="String" line="1023"/>
            </method>
            <javadoc line="1033">
                This method blocks if there are too many active clients.
                  Call to &lt;CODE&gt;wait()&lt;/CODE&gt; is terminated when a client handler
                  thread calls &lt;CODE&gt;notifyClientHandlerDeleted(this)&lt;/CODE&gt; ;                
            </javadoc>
            <method name="waitIfTooManyClients" type="void" line="1039">
                <scope line="1040">
                    <scope line="1041"/>
                </scope>
            </method>
            <javadoc line="1049">
                This method blocks until there is no more active client.                
            </javadoc>
            <method name="waitClientTermination" type="void" line="1052">
                <comment line="1063">
                    The ClientHandler will remove themselves from the
                     clientHandlerVector at the end of their run() method, by
                     calling notifyClientHandlerDeleted().
                     Since the clientHandlerVector is modified by the ClientHandler
                     threads we must avoid using Enumeration or Iterator to loop
                     over this array. We must also take care of NoSuchElementException
                     which could be thrown if the last ClientHandler removes itself
                     between the call to clientHandlerVector.isEmpty() and the call
                     to clientHandlerVector.firstElement().
                     What we *MUST NOT DO* is locking the clientHandlerVector, because
                     this would most probably cause a deadlock.                    
                </comment>
                <declaration name="s" type="int" line="1053"/>
                <scope line="1054">
                    <scope line="1055"/>
                </scope>
                <scope line="1074">
                    <scope line="1075"/>
                    <scope line="1077">
                        <scope line="1078"/>
                    </scope>
                </scope>
                <scope line="1085">
                    <scope line="1086"/>
                </scope>
            </method>
            <javadoc line="1093">
                Call &lt;CODE&gt;interrupt()&lt;/CODE&gt; on each pending client.                
            </javadoc>
            <method name="terminateAllClient" type="void" line="1096">
                <comment line="1106">
                    The ClientHandler will remove themselves from the
                     clientHandlerVector at the end of their run() method, by
                     calling notifyClientHandlerDeleted().
                     Since the clientHandlerVector is modified by the ClientHandler
                     threads we must avoid using Enumeration or Iterator to loop
                     over this array.
                     We cannot use the same logic here than in waitClientTermination()
                     because there is no guarantee that calling interrupt() on the
                     ClientHandler will actually terminate the ClientHandler.
                     Since we do not want to wait for the actual ClientHandler
                     termination, we cannot simply loop over the array until it is
                     empty (this might result in calling interrupt() endlessly on
                     the same client handler. So what we do is simply take a snapshot
                     copy of the vector and loop over the copy.
                     What we *MUST NOT DO* is locking the clientHandlerVector, because
                     this would most probably cause a deadlock.                    
                </comment>
                <declaration name="s" type="int" line="1097"/>
                <scope line="1098">
                    <scope line="1099"/>
                </scope>
                <declaration name="handlers" type="ClientHandler[]" line="1122"/>
                <scope line="1124">
                    <scope line="1125"/>
                    <scope line="1127">
                        <scope line="1128"/>
                    </scope>
                </scope>
            </method>
            <javadoc line="1138">
                Controls the way the CommunicatorServer service is deserialized.                
            </javadoc>
            <method name="readObject" type="void" line="1142">
                <params>
                    <param name="stream" type="ObjectInputStream"/>
                </params>
                <comment line="1145">
                    Call the default deserialization of the object.                    
                </comment>
                <comment line="1149">
                    Call the specific initialization for the CommunicatorServer service.
                     This is for transient structures to be initialized to specific
                     default values.                    
                </comment>
            </method>
            <javadoc line="1170">
                Adds a listener for the notifications emitted by this
                  CommunicatorServer.
                  There is only one type of notifications sent by the CommunicatorServer:
                  they are &lt;tt&gt;{@link javax.management.AttributeChangeNotification}&lt;/tt&gt;,
                  sent when the &lt;tt&gt;State&lt;/tt&gt; attribute of this CommunicatorServer
                  changes.                
                <param>
                    listener The listener object which will handle the emitted
                      notifications.                    
                </param>
                <param>
                    filter The filter object. If filter is null, no filtering
                      will be performed before handling notifications.                    
                </param>
                <param>
                    handback An object which will be sent back unchanged to the
                      listener when a notification is emitted.                    
                </param>
                <exception>
                    IllegalArgumentException Listener parameter is null.                    
                </exception>
            </javadoc>
            <method name="addNotificationListener" type="void" line="1190">
                <params>
                    <param name="listener" type="NotificationListener"/>
                    <param name="filter" type="NotificationFilter"/>
                    <param name="handback" type="Object"/>
                </params>
                <scope line="1192"/>
            </method>
            <javadoc line="1200">
                Removes the specified listener from this CommunicatorServer.
                  Note that if the listener has been registered with different
                  handback objects or notification filters, all entries corresponding
                  to the listener will be removed.                
                <param>
                    listener The listener object to be removed.                    
                </param>
                <exception>
                    ListenerNotFoundException The listener is not registered.                    
                </exception>
            </javadoc>
            <method name="removeNotificationListener" type="void" line="1211">
                <params>
                    <param name="listener" type="NotificationListener"/>
                </params>
                <scope line="1213"/>
            </method>
            <javadoc line="1220">
                Returns an array of MBeanNotificationInfo objects describing
                  the notification types sent by this CommunicatorServer.
                  There is only one type of notifications sent by the CommunicatorServer:
                  it is &lt;tt&gt;{@link javax.management.AttributeChangeNotification}&lt;/tt&gt;,
                  sent when the &lt;tt&gt;State&lt;/tt&gt; attribute of this CommunicatorServer
                  changes.                
            </javadoc>
            <method name="getNotificationInfo" type="MBeanNotificationInfo[]" line="1228">
                <comment line="1231">
                    Initialize notifInfos on first call to getNotificationInfo()                    
                </comment>
                <scope line="1232">
                    <declaration name="notifTypes" type="String[]" line="1234"/>
                </scope>
            </method>
            <javadoc line="1245">
                                
            </javadoc>
            <method name="sendStateChangeNotification" type="void" line="1248">
                <params>
                    <param name="oldState" type="int"/>
                    <param name="newState" type="int"/>
                </params>
                <comment line="1261">
                    source                    
                </comment>
                <comment line="1262">
                    sequence number                    
                </comment>
                <comment line="1263">
                    time stamp                    
                </comment>
                <comment line="1264">
                    message                    
                </comment>
                <comment line="1265">
                    attribute name                    
                </comment>
                <comment line="1266">
                    attribute type                    
                </comment>
                <comment line="1267">
                    old value                    
                </comment>
                <comment line="1268">
                    new value                    
                </comment>
                <declaration name="oldStateString" type="String" line="1250"/>
                <declaration name="newStateString" type="String" line="1251"/>
                <declaration name="message" type="String" line="1252"/>
                <declaration name="notif" type="AttributeChangeNotification" line="1259"/>
                <scope line="1268"/>
            </method>
            <javadoc line="1276">
                                
            </javadoc>
            <method name="getStringForState" type="String" line="1279">
                <params>
                    <param name="s" type="int"/>
                </params>
            </method>
            <javadoc line="1294">
                Preregister method of connector.                
                <param>
                    server The &lt;CODE&gt;MBeanServer&lt;/CODE&gt; in which the MBean will
                      be registered.                    
                </param>
                <param>
                    name The object name of the MBean.                    
                </param>
                <return>
                    The name of the MBean registered.                    
                </return>
                <exception>
                    java.langException This exception should be caught by
                      the &lt;CODE&gt;MBeanServer&lt;/CODE&gt; and re-thrown
                      as an &lt;CODE&gt;MBeanRegistrationException&lt;/CODE&gt;.                    
                </exception>
            </javadoc>
            <method name="preRegister" type="ObjectName" line="1308">
                <params>
                    <param name="server" type="MBeanServer"/>
                    <param name="name" type="ObjectName"/>
                </params>
                <scope line="1310">
                    <scope line="1311"/>
                </scope>
            </method>
            <javadoc line="1322">
                @param registrationDone Indicates whether or not the MBean has been
                  successfully registered in the &lt;CODE&gt;MBeanServer&lt;/CODE&gt;.
                  The value false means that the registration phase has failed.                
            </javadoc>
            <method name="postRegister" type="void" line="1328">
                <params>
                    <param name="registrationDone" type="Boolean"/>
                </params>
                <scope line="1329">
                    <scope line="1330"/>
                </scope>
            </method>
            <javadoc line="1336">
                Stop the connector.                
                <exception>
                    java.langException This exception should be caught by
                      the &lt;CODE&gt;MBeanServer&lt;/CODE&gt; and re-thrown
                      as an &lt;CODE&gt;MBeanRegistrationException&lt;/CODE&gt;.                    
                </exception>
            </javadoc>
            <method name="preDeregister" type="void" line="1343">
                <scope line="1344"/>
                <declaration name="cstate" type="int" line="1348"/>
                <scope line="1349"/>
            </method>
            <javadoc line="1354">
                Do nothing.                
            </javadoc>
            <method name="postDeregister" type="void" line="1357"/>
            <javadoc line="1360">
                Load a class using the default loader repository                
            </javadoc>
            <method name="loadClass" type="Class" line="1364">
                <params>
                    <param name="className" type="String"/>
                </params>
                <scope line="1365"/>
                <scope line="1367">
                    <declaration name="clr" type="ClassLoaderRepository" line="1368"/>
                </scope>
            </method>
        </class>
    </source>