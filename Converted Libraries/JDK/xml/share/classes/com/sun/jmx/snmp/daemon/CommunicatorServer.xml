<?xml version="1.0" encoding="UTF-8"?>
    <source package="com.sun.jmx.snmp.daemon">
        <import package="java.io.ObjectInputStream"/>
        <import package="java.io.IOException"/>
        <import package="java.net.InetAddress"/>
        <import package="java.util.Enumeration"/>
        <import package="java.util.logging.Level"/>
        <import package="java.util.Vector"/>
        <import package="java.util.NoSuchElementException"/>
        <import package="javax.management.MBeanServer"/>
        <import package="javax.management.MBeanRegistration"/>
        <import package="javax.management.ObjectName"/>
        <import package="javax.management.NotificationListener"/>
        <import package="javax.management.NotificationFilter"/>
        <import package="javax.management.NotificationBroadcaster"/>
        <import package="javax.management.NotificationBroadcasterSupport"/>
        <import package="javax.management.MBeanNotificationInfo"/>
        <import package="javax.management.AttributeChangeNotification"/>
        <import package="javax.management.ListenerNotFoundException"/>
        <import package="javax.management.loading.ClassLoaderRepository"/>
        <import package="javax.management.MBeanServerFactory"/>
        <import package="com.sun.jmx.defaults.JmxProperties.SNMP_ADAPTOR_LOGGER"/>
        <import package="javax.management.remote.MBeanServerForwarder"/>
        <class name="CommunicatorServer" line="67">
            <comment line="120">
                                
            </comment>
            <comment line="121">
                States of a CommunicatorServer                
            </comment>
            <comment line="122">
                                
            </comment>
            <comment line="144">
                                
            </comment>
            <comment line="145">
                Types of connectors.                
            </comment>
            <comment line="146">
                                
            </comment>
            <comment line="148">
                Indicates that it is an RMI connector type.                
            </comment>
            <comment line="151">
                public static final int RMI_TYPE = 1 ;                
            </comment>
            <comment line="153">
                Indicates that it is an HTTP connector type.                
            </comment>
            <comment line="156">
                public static final int HTTP_TYPE = 2 ;                
            </comment>
            <comment line="158">
                Indicates that it is an HTML connector type.                
            </comment>
            <comment line="161">
                public static final int HTML_TYPE = 3 ;                
            </comment>
            <comment line="168">
                Indicates that it is an HTTPS connector type.                
            </comment>
            <comment line="171">
                public static final int HTTPS_TYPE = 5 ;                
            </comment>
            <comment line="173">
                                
            </comment>
            <comment line="174">
                Package variables                
            </comment>
            <comment line="175">
                                
            </comment>
            <comment line="219">
                                
            </comment>
            <comment line="220">
                Private fields                
            </comment>
            <comment line="221">
                                
            </comment>
            <comment line="223">
                This object controls access to the &quot;state&quot; and &quot;interrupted&quot; variables.
                If held at the same time as the lock on &quot;this&quot;, the &quot;this&quot; lock must                
            </comment>
            <comment line="238">
                Notifs count, broadcaster and info                
            </comment>
            <comment line="884">
                                
            </comment>
            <comment line="885">
                To be defined by the subclass.                
            </comment>
            <comment line="886">
                                
            </comment>
            <comment line="887">
                Each method below is called by run() and must be subclassed.                
            </comment>
            <comment line="888">
                If the method sends an exception (Communication or Interrupt), this                
            </comment>
            <comment line="889">
                will end up the run() method and switch the connector offline.                
            </comment>
            <comment line="890">
                                
            </comment>
            <comment line="891">
                If it is a CommunicationException, run() will call                
            </comment>
            <comment line="892">
                Debug.printException().                
            </comment>
            <comment line="893">
                                
            </comment>
            <comment line="894">
                All these methods should propagate the InterruptedException to inform                
            </comment>
            <comment line="895">
                run() that the connector must be switch OFFLINE.                
            </comment>
            <comment line="896">
                                
            </comment>
            <comment line="897">
                                
            </comment>
            <comment line="898">
                                
            </comment>
            <comment line="899">
                doBind() should do all what is needed before calling doReceive().                
            </comment>
            <comment line="900">
                If doBind() throws an exception, doUnbind() is not to be called                
            </comment>
            <comment line="901">
                and run() ends up.                
            </comment>
            <comment line="902">
                                
            </comment>
            <comment line="988">
                                
            </comment>
            <comment line="989">
                To be called by the subclass if needed                
            </comment>
            <comment line="990">
                                
            </comment>
            <comment line="1167">
                                
            </comment>
            <comment line="1168">
                NotificationBroadcaster                
            </comment>
            <comment line="1169">
                                
            </comment>
            <comment line="1291">
                                
            </comment>
            <comment line="1292">
                MBeanRegistration                
            </comment>
            <comment line="1293">
                                
            </comment>
            <implements interface="Runnable"/>
            <implements interface="MBeanRegistration"/>
            <implements interface="NotificationBroadcaster"/>
            <implements interface="CommunicatorServerMBean"/>
            <javadoc line="67">
                Defines generic behavior for the server part of a connector or an adaptor.
                  Most connectors or adaptors extend &lt;CODE&gt;CommunicatorServer&lt;/CODE&gt;
                  and inherit this behavior. Connectors or adaptors that do not fit into
                  this model do not extend &lt;CODE&gt;CommunicatorServer&lt;/CODE&gt;.
                  &lt;p&gt;
                  A &lt;CODE&gt;CommunicatorServer&lt;/CODE&gt; is an active object, it listens for
                  client requests  and processes them in its own thread. When necessary, a
                  &lt;CODE&gt;CommunicatorServer&lt;/CODE&gt; creates other threads to process multiple
                  requests concurrently.
                  &lt;p&gt;
                  A &lt;CODE&gt;CommunicatorServer&lt;/CODE&gt; object can be stopped by calling the
                  &lt;CODE&gt;stop&lt;/CODE&gt; method. When it is stopped, the
                  &lt;CODE&gt;CommunicatorServer&lt;/CODE&gt; no longer listens to client requests and
                  no longer holds any thread or communication resources.
                  It can be started again by calling the &lt;CODE&gt;start&lt;/CODE&gt; method.
                  &lt;p&gt;
                  A &lt;CODE&gt;CommunicatorServer&lt;/CODE&gt; has a &lt;CODE&gt;State&lt;/CODE&gt; attribute
                  which reflects its  activity.
                  &lt;p&gt;
                  &lt;TABLE&gt;
                  &lt;TR&gt;&lt;TH&gt;CommunicatorServer&lt;/TH&gt;      &lt;TH&gt;State&lt;/TH&gt;&lt;/TR&gt;
                  &lt;TR&gt;&lt;TD&gt;&lt;CODE&gt;stopped&lt;/CODE&gt;&lt;/TD&gt;    &lt;TD&gt;&lt;CODE&gt;OFFLINE&lt;/CODE&gt;&lt;/TD&gt;&lt;/TR&gt;
                  &lt;TR&gt;&lt;TD&gt;&lt;CODE&gt;starting&lt;/CODE&gt;&lt;/TD&gt;    &lt;TD&gt;&lt;CODE&gt;STARTING&lt;/CODE&gt;&lt;/TD&gt;&lt;/TR&gt;
                  &lt;TR&gt;&lt;TD&gt;&lt;CODE&gt;running&lt;/CODE&gt;&lt;/TD&gt;     &lt;TD&gt;&lt;CODE&gt;ONLINE&lt;/CODE&gt;&lt;/TD&gt;&lt;/TR&gt;
                  &lt;TR&gt;&lt;TD&gt;&lt;CODE&gt;stopping&lt;/CODE&gt;&lt;/TD&gt;     &lt;TD&gt;&lt;CODE&gt;STOPPING&lt;/CODE&gt;&lt;/TD&gt;&lt;/TR&gt;
                  &lt;/TABLE&gt;
                  &lt;p&gt;
                  The &lt;CODE&gt;STARTING&lt;/CODE&gt; state marks the transition
                  from &lt;CODE&gt;OFFLINE&lt;/CODE&gt; to &lt;CODE&gt;ONLINE&lt;/CODE&gt;.
                  &lt;p&gt;
                  The &lt;CODE&gt;STOPPING&lt;/CODE&gt; state marks the transition from
                  &lt;CODE&gt;ONLINE&lt;/CODE&gt; to &lt;CODE&gt;OFFLINE&lt;/CODE&gt;. This occurs when the
                  &lt;CODE&gt;CommunicatorServer&lt;/CODE&gt; is finishing or interrupting active
                  requests.
                  &lt;p&gt;
                  When a &lt;CODE&gt;CommunicatorServer&lt;/CODE&gt; is unregistered from the MBeanServer,
                  it is stopped automatically.
                  &lt;p&gt;
                  When the value of the &lt;CODE&gt;State&lt;/CODE&gt; attribute changes the
                  &lt;CODE&gt;CommunicatorServer&lt;/CODE&gt; sends a
                  &lt;tt&gt;{@link javax.management.AttributeChangeNotification}&lt;/tt&gt; to the
                  registered listeners, if any.
                  &lt;p&gt;&lt;b&gt;This API is a Sun Microsystems internal API  and is subject
                  to change without notice.&lt;/b&gt;&lt;/p&gt;                
            </javadoc>
            <declaration name="ONLINE" type="int" line="123"/>
            <javadoc line="123">
                Represents an &lt;CODE&gt;ONLINE&lt;/CODE&gt; state.                
            </javadoc>
            <declaration name="OFFLINE" type="int" line="128"/>
            <javadoc line="128">
                Represents an &lt;CODE&gt;OFFLINE&lt;/CODE&gt; state.                
            </javadoc>
            <declaration name="STOPPING" type="int" line="133"/>
            <javadoc line="133">
                Represents a &lt;CODE&gt;STOPPING&lt;/CODE&gt; state.                
            </javadoc>
            <declaration name="STARTING" type="int" line="138"/>
            <javadoc line="138">
                Represents a &lt;CODE&gt;STARTING&lt;/CODE&gt; state.                
            </javadoc>
            <declaration name="SNMP_TYPE" type="int" line="162"/>
            <javadoc line="162">
                Indicates that it is an SNMP connector type.                
            </javadoc>
            <declaration name="state" type="int" line="176"/>
            <javadoc line="176">
                The state of the connector server.                
            </javadoc>
            <declaration name="objectName" type="ObjectName" line="181"/>
            <javadoc line="181">
                The object name of the connector server.                
                <serial>
                                        
                </serial>
            </javadoc>
            <declaration name="topMBS" type="MBeanServer" line="187"/>
            <declaration name="bottomMBS" type="MBeanServer" line="188"/>
            <declaration name="dbgTag" type="String" line="190"/>
            <javadoc line="190">
                                
            </javadoc>
            <declaration name="maxActiveClientCount" type="int" line="194"/>
            <javadoc line="194">
                The maximum number of clients that the CommunicatorServer can
                  process concurrently.                
                <serial>
                                        
                </serial>
            </javadoc>
            <declaration name="servedClientCount" type="int" line="201"/>
            <javadoc line="201">
                                
            </javadoc>
            <declaration name="host" type="String" line="205"/>
            <javadoc line="205">
                The host name used by this CommunicatorServer.                
                <serial>
                                        
                </serial>
            </javadoc>
            <declaration name="port" type="int" line="211"/>
            <javadoc line="211">
                The port number used by this CommunicatorServer.                
                <serial>
                                        
                </serial>
            </javadoc>
            <declaration name="stateLock" type="Object" line="225"/>
            <declaration name="clientHandlerVector" type="Vector&lt;ClientHandler&gt;" line="227"/>
            <declaration name="fatherThread" type="Thread" line="230"/>
            <declaration name="mainThread" type="Thread" line="231"/>
            <declaration name="stopRequested" type="boolean" line="233"/>
            <declaration name="interrupted" type="boolean" line="234"/>
            <declaration name="startException" type="Exception" line="235"/>
            <declaration name="notifCount" type="long" line="238"/>
            <declaration name="notifBroadcaster" type="NotificationBroadcasterSupport" line="239"/>
            <declaration name="notifInfos" type="MBeanNotificationInfo[]" line="241"/>
            <javadoc line="244">
                Instantiates a &lt;CODE&gt;CommunicatorServer&lt;/CODE&gt;.                
                <param>
                    connectorType Indicates the connector type. Possible values are:
                      SNMP_TYPE.                    
                </param>
                <exception>
                    <CODE>java.lang.IllegalArgumentException</CODE>
                      This connector type is not correct.                    
                </exception>
            </javadoc>
            <method name="CommunicatorServer" type="constructor" line="254">
                <params>
                    <param name="connectorType" type="int"/>
                </params>
                <comment line="257">
                    No op. int Type deciding debugging removed.                    
                </comment>
            </method>
            <method name="createMainThread" type="Thread" line="265"/>
            <javadoc line="269">
                Starts this &lt;CODE&gt;CommunicatorServer&lt;/CODE&gt;.
                  &lt;p&gt;
                  Has no effect if this &lt;CODE&gt;CommunicatorServer&lt;/CODE&gt; is
                  &lt;CODE&gt;ONLINE&lt;/CODE&gt; or &lt;CODE&gt;STOPPING&lt;/CODE&gt;.                
                <param>
                    timeout Time in ms to wait for the connector to start.
                      If <code>timeout</code> is positive, wait for at most
                      the specified time. An infinite timeout can be specified
                      by passing a <code>timeout</code> value equals
                      <code>Long.MAX_VALUE</code>. In that case the method
                      will wait until the connector starts or fails to start.
                      If timeout is negative or zero, returns as soon as possible
                      without waiting.                    
                </param>
                <exception>
                    CommunicationException if the connectors fails to start.                    
                </exception>
                <exception>
                    InterruptedException if the thread is interrupted or the
                      timeout expires.                    
                </exception>
            </javadoc>
            <method name="start" type="void" line="287">
                <params>
                    <param name="timeout" type="long"/>
                </params>
                <comment line="292">
                    Fix for bug 4352451:                    
                </comment>
                <comment line="293">
                    &quot;java.net.BindException: Address in use&quot;.                    
                </comment>
                <declaration name="start" type="boolean" line="288"/>
                <scope line="290">
                    <scope line="291"/>
                    <scope line="297"/>
                </scope>
                <scope line="305">
                    <scope line="306"/>
                </scope>
                <scope line="313"/>
            </method>
            <javadoc line="325">
                Starts this &lt;CODE&gt;CommunicatorServer&lt;/CODE&gt;.
                  &lt;p&gt;
                  Has no effect if this &lt;CODE&gt;CommunicatorServer&lt;/CODE&gt; is
                  &lt;CODE&gt;ONLINE&lt;/CODE&gt; or &lt;CODE&gt;STOPPING&lt;/CODE&gt;.                
            </javadoc>
            <method name="start" type="void" line="331">
                <comment line="335">
                    cannot happen because of `0&apos;                    
                </comment>
                <scope line="332"/>
                <scope line="334">
                    <scope line="336"/>
                </scope>
            </method>
            <javadoc line="343">
                Stops this &lt;CODE&gt;CommunicatorServer&lt;/CODE&gt;.
                  &lt;p&gt;
                  Has no effect if this &lt;CODE&gt;CommunicatorServer&lt;/CODE&gt; is
                  &lt;CODE&gt;OFFLINE&lt;/CODE&gt; or  &lt;CODE&gt;STOPPING&lt;/CODE&gt;.                
            </javadoc>
            <method name="stop" type="void" line="349">
                <comment line="359">
                                        
                </comment>
                <comment line="360">
                    Stop the connector thread                    
                </comment>
                <comment line="361">
                                        
                </comment>
                <comment line="373">
                                        
                </comment>
                <comment line="374">
                    Call terminate on each active client handler                    
                </comment>
                <comment line="375">
                                        
                </comment>
                <comment line="382">
                    ----------------------                    
                </comment>
                <comment line="383">
                    changeState                    
                </comment>
                <comment line="384">
                    ----------------------                    
                </comment>
                <scope line="350">
                    <scope line="351">
                        <scope line="352"/>
                    </scope>
                    <scope line="362"/>
                    <scope line="367"/>
                </scope>
                <scope line="376"/>
                <scope line="385"/>
            </method>
            <javadoc line="391">
                Tests whether the &lt;CODE&gt;CommunicatorServer&lt;/CODE&gt; is active.                
                <return>
                    True if connector is <CODE>ONLINE</CODE>; false otherwise.                    
                </return>
            </javadoc>
            <method name="isActive" type="boolean" line="396">
                <scope line="397"/>
            </method>
            <javadoc line="402">
                &lt;p&gt;Waits until either the State attribute of this MBean equals the
                  specified &lt;VAR&gt;wantedState&lt;/VAR&gt; parameter,
                  or the specified  &lt;VAR&gt;timeOut&lt;/VAR&gt; has elapsed.
                  The method &lt;CODE&gt;waitState&lt;/CODE&gt; returns with a boolean value
                  indicating whether the specified &lt;VAR&gt;wantedState&lt;/VAR&gt; parameter
                  equals the value of this MBean&apos;s State attribute at the time the method
                  terminates.&lt;/p&gt;
                  &lt;p&gt;Two special cases for the &lt;VAR&gt;timeOut&lt;/VAR&gt; parameter value are:&lt;/p&gt;
                  &lt;UL&gt;&lt;LI&gt; if &lt;VAR&gt;timeOut&lt;/VAR&gt; is negative then &lt;CODE&gt;waitState&lt;/CODE&gt;
                  returns immediately (i.e. does not wait at all),&lt;/LI&gt;
                  &lt;LI&gt; if &lt;VAR&gt;timeOut&lt;/VAR&gt; equals zero then &lt;CODE&gt;waitState&lt;/CODE&gt;
                  waits untill the value of this MBean&apos;s State attribute
                  is the same as the &lt;VAR&gt;wantedState&lt;/VAR&gt; parameter (i.e. will wait
                  indefinitely if this condition is never met).&lt;/LI&gt;&lt;/UL&gt;                
                <param>
                    wantedState The value of this MBean's State attribute to wait
                      for. <VAR>wantedState</VAR> can be one of:
                      <ul>
                      <li><CODE>CommunicatorServer.OFFLINE</CODE>,</li>
                      <li><CODE>CommunicatorServer.ONLINE</CODE>,</li>
                      <li><CODE>CommunicatorServer.STARTING</CODE>,</li>
                      <li><CODE>CommunicatorServer.STOPPING</CODE>.</li>
                      </ul>                    
                </param>
                <param>
                    timeOut The maximum time to wait for, in milliseconds,
                      if positive.
                      Infinite time out if 0, or no waiting at all if negative.                    
                </param>
                <return>
                    true if the value of this MBean's State attribute is the
                      same as the <VAR>wantedState</VAR> parameter; false otherwise.                    
                </return>
            </javadoc>
            <method name="waitState" type="boolean" line="434">
                <params>
                    <param name="wantedState" type="int"/>
                    <param name="timeOut" type="long"/>
                </params>
                <comment line="465">
                    timeOut == 0                    
                </comment>
                <scope line="435"/>
                <declaration name="endTime" type="long" line="441"/>
                <scope line="445">
                    <scope line="446">
                        <scope line="447">
                            <scope line="448"/>
                        </scope>
                        <scope line="453">
                            <scope line="454">
                                <scope line="455">
                                    <declaration name="toWait" type="long" line="456"/>
                                    <scope line="457">
                                        <scope line="458"/>
                                    </scope>
                                </scope>
                                <scope line="465"/>
                            </scope>
                            <scope line="468">
                                <scope line="469"/>
                            </scope>
                        </scope>
                    </scope>
                    <scope line="477"/>
                </scope>
            </method>
            <javadoc line="485">
                &lt;p&gt;Waits until the communicator is started or timeout expires.                
                <param>
                    timeout Time in ms to wait for the connector to start.
                      If <code>timeout</code> is positive, wait for at most
                      the specified time. An infinite timeout can be specified
                      by passing a <code>timeout</code> value equals
                      <code>Long.MAX_VALUE</code>. In that case the method
                      will wait until the connector starts or fails to start.
                      If timeout is negative or zero, returns as soon as possible
                      without waiting.                    
                </param>
                <exception>
                    CommunicationException if the connectors fails to start.                    
                </exception>
                <exception>
                    InterruptedException if the thread is interrupted or the
                      timeout expires.                    
                </exception>
            </javadoc>
            <method name="waitForStart" type="void" line="503">
                <params>
                    <param name="timeout" type="long"/>
                </params>
                <comment line="514">
                    Time elapsed since startTime...                    
                </comment>
                <comment line="515">
                                        
                </comment>
                <comment line="518">
                    wait for timeout - elapsed.                    
                </comment>
                <comment line="519">
                    A timeout of Long.MAX_VALUE is equivalent to something                    
                </comment>
                <comment line="520">
                    like 292271023 years - which is pretty close to                    
                </comment>
                <comment line="521">
                    forever as far as we are concerned ;-)                    
                </comment>
                <comment line="522">
                                        
                </comment>
                <comment line="525">
                    If remainingTime is negative, the timeout has elapsed.                    
                </comment>
                <comment line="526">
                                        
                </comment>
                <comment line="535">
                    We&apos;re going to wait until someone notifies on the                    
                </comment>
                <comment line="536">
                    the stateLock object, or until the timeout expires,                    
                </comment>
                <comment line="537">
                    or until the thread is interrupted.                    
                </comment>
                <comment line="538">
                                        
                </comment>
                <comment line="547">
                    If we are now ONLINE, then no need to rethrow the                    
                </comment>
                <comment line="548">
                    exception... we&apos;re simply going to exit the while                    
                </comment>
                <comment line="549">
                    loop. Otherwise, throw the InterruptedException.                    
                </comment>
                <comment line="550">
                                        
                </comment>
                <comment line="555">
                    We&apos;re no longer in STARTING state                    
                </comment>
                <comment line="556">
                                        
                </comment>
                <comment line="558">
                    OK, we&apos;re started, everything went fine, just return                    
                </comment>
                <comment line="559">
                                        
                </comment>
                <comment line="566">
                    There was some exception during the starting phase.                    
                </comment>
                <comment line="567">
                    Cast and throw...                    
                </comment>
                <comment line="568">
                                        
                </comment>
                <comment line="571">
                    There was some exception during the starting phase.                    
                </comment>
                <comment line="572">
                    Cast and throw...                    
                </comment>
                <comment line="573">
                                        
                </comment>
                <comment line="576">
                    There was some exception during the starting phase.                    
                </comment>
                <comment line="577">
                    Wrap and throw...                    
                </comment>
                <comment line="578">
                                        
                </comment>
                <comment line="583">
                    We&apos;re not ONLINE, and there&apos;s no exception...                    
                </comment>
                <comment line="584">
                    Something went wrong but we don&apos;t know what...                    
                </comment>
                <comment line="585">
                                        
                </comment>
                <scope line="504"/>
                <declaration name="startTime" type="long" line="510"/>
                <scope line="512">
                    <scope line="513">
                        <declaration name="elapsed" type="long" line="516"/>
                        <declaration name="remainingTime" type="long" line="523"/>
                        <scope line="527">
                            <scope line="528"/>
                        </scope>
                        <scope line="539"/>
                        <scope line="541">
                            <scope line="542"/>
                        </scope>
                    </scope>
                    <scope line="557">
                        <scope line="560"/>
                    </scope>
                    <scope line="565"/>
                    <scope line="570"/>
                    <scope line="575"/>
                    <scope line="582"/>
                </scope>
            </method>
            <javadoc line="592">
                Gets the state of this &lt;CODE&gt;CommunicatorServer&lt;/CODE&gt; as an integer.                
                <return>
                    <CODE>ONLINE</CODE>, <CODE>OFFLINE</CODE>,
                      <CODE>STARTING</CODE> or <CODE>STOPPING</CODE>.                    
                </return>
            </javadoc>
            <method name="getState" type="int" line="598">
                <scope line="599"/>
            </method>
            <javadoc line="604">
                Gets the state of this &lt;CODE&gt;CommunicatorServer&lt;/CODE&gt; as a string.                
                <return>
                    One of the strings "ONLINE", "OFFLINE", "STARTING" or
                      "STOPPING".                    
                </return>
            </javadoc>
            <method name="getStateString" type="String" line="610"/>
            <javadoc line="614">
                Gets the host name used by this &lt;CODE&gt;CommunicatorServer&lt;/CODE&gt;.                
                <return>
                    The host name used by this <CODE>CommunicatorServer</CODE>.                    
                </return>
            </javadoc>
            <method name="getHost" type="String" line="619">
                <scope line="620"/>
                <scope line="622"/>
            </method>
            <javadoc line="628">
                Gets the port number used by this &lt;CODE&gt;CommunicatorServer&lt;/CODE&gt;.                
                <return>
                    The port number used by this <CODE>CommunicatorServer</CODE>.                    
                </return>
            </javadoc>
            <method name="getPort" type="int" line="633">
                <scope line="634"/>
            </method>
            <javadoc line="639">
                Sets the port number used by this &lt;CODE&gt;CommunicatorServer&lt;/CODE&gt;.                
                <param>
                    port The port number used by this
                      <CODE>CommunicatorServer</CODE>.                    
                </param>
                <exception>
                    java.lang.IllegalStateException This method has been invoked
                      while the communicator was ONLINE or STARTING.                    
                </exception>
            </javadoc>
            <method name="setPort" type="void" line="648">
                <params>
                    <param name="port" type="int"/>
                </params>
                <scope line="649"/>
            </method>
            <method name="getProtocol" type="String" line="658"/>
            <javadoc line="658">
                Gets the protocol being used by this &lt;CODE&gt;CommunicatorServer&lt;/CODE&gt;.                
                <return>
                    The protocol as a string.                    
                </return>
            </javadoc>
            <javadoc line="664">
                Gets the number of clients that have been processed by this
                  &lt;CODE&gt;CommunicatorServer&lt;/CODE&gt;  since its creation.                
                <return>
                    The number of clients handled by this
                      <CODE>CommunicatorServer</CODE>
                      since its creation. This counter is not reset by the
                      <CODE>stop</CODE> method.                    
                </return>
            </javadoc>
            <method name="getServedClientCount" type="int" line="673"/>
            <javadoc line="677">
                Gets the number of clients currently being processed by this
                  &lt;CODE&gt;CommunicatorServer&lt;/CODE&gt;.                
                <return>
                    The number of clients currently being processed by this
                      <CODE>CommunicatorServer</CODE>.                    
                </return>
            </javadoc>
            <method name="getActiveClientCount" type="int" line="684">
                <declaration name="result" type="int" line="685"/>
            </method>
            <javadoc line="689">
                Gets the maximum number of clients that this
                  &lt;CODE&gt;CommunicatorServer&lt;/CODE&gt; can  process concurrently.                
                <return>
                    The maximum number of clients that this
                      <CODE>CommunicatorServer</CODE> can
                      process concurrently.                    
                </return>
            </javadoc>
            <method name="getMaxActiveClientCount" type="int" line="697"/>
            <javadoc line="701">
                Sets the maximum number of clients this
                  &lt;CODE&gt;CommunicatorServer&lt;/CODE&gt; can process concurrently.                
                <param>
                    c The number of clients.                    
                </param>
                <exception>
                    java.lang.IllegalStateException This method has been invoked
                      while the communicator was ONLINE or STARTING.                    
                </exception>
            </javadoc>
            <method name="setMaxActiveClientCount" type="void" line="711">
                <params>
                    <param name="c" type="int"/>
                </params>
                <scope line="712">
                    <scope line="713"/>
                </scope>
            </method>
            <javadoc line="721">
                For SNMP Runtime internal use only.                
            </javadoc>
            <method name="notifyClientHandlerCreated" type="void" line="724">
                <params>
                    <param name="h" type="ClientHandler"/>
                </params>
            </method>
            <javadoc line="728">
                For SNMP Runtime internal use only.                
            </javadoc>
            <method name="notifyClientHandlerDeleted" type="void" line="731">
                <params>
                    <param name="h" type="ClientHandler"/>
                </params>
            </method>
            <javadoc line="736">
                The number of times the communicator server will attempt
                  to bind before giving up.                
            </javadoc>
            <method name="getBindTries" type="int" line="740"/>
            <javadoc line="744">
                The delay, in ms, during which the communicator server will sleep before
                  attempting to bind again.                
            </javadoc>
            <method name="getBindSleepTime" type="long" line="748"/>
            <javadoc line="752">
                For SNMP Runtime internal use only.
                  &lt;p&gt;
                  The &lt;CODE&gt;run&lt;/CODE&gt; method executed by this connector&apos;s main thread.                
            </javadoc>
            <method name="run" type="void" line="757">
                <comment line="759">
                    Fix jaw.00667.B                    
                </comment>
                <comment line="760">
                    It seems that the init of &quot;i&quot; and &quot;success&quot;                    
                </comment>
                <comment line="761">
                    need to be done outside the &quot;try&quot; clause...                    
                </comment>
                <comment line="762">
                    A bug in Java 2 production release ?                    
                </comment>
                <comment line="763">
                                        
                </comment>
                <comment line="767">
                    ----------------------                    
                </comment>
                <comment line="768">
                    Bind                    
                </comment>
                <comment line="769">
                    ----------------------                    
                </comment>
                <comment line="771">
                    Fix for bug 4352451: &quot;java.net.BindException: Address in use&quot;.                    
                </comment>
                <comment line="772">
                                        
                </comment>
                <comment line="777">
                    Try socket connection.                    
                </comment>
                <comment line="778">
                                        
                </comment>
                <comment line="790">
                    Retry last time to get correct exception.                    
                </comment>
                <comment line="791">
                                        
                </comment>
                <comment line="793">
                    Try socket connection.                    
                </comment>
                <comment line="794">
                                        
                </comment>
                <comment line="816">
                    ----------------------                    
                </comment>
                <comment line="817">
                    State change                    
                </comment>
                <comment line="818">
                    ----------------------                    
                </comment>
                <comment line="825">
                    ----------------------                    
                </comment>
                <comment line="826">
                    Main loop                    
                </comment>
                <comment line="827">
                    ----------------------                    
                </comment>
                <comment line="857">
                    ----------------------                    
                </comment>
                <comment line="858">
                    unBind                    
                </comment>
                <comment line="859">
                    ----------------------                    
                </comment>
                <declaration name="i" type="int" line="764"/>
                <declaration name="success" type="boolean" line="765"/>
                <scope line="770">
                    <declaration name="bindRetries" type="int" line="773"/>
                    <declaration name="sleepTime" type="long" line="774"/>
                    <scope line="775">
                        <scope line="776"/>
                        <scope line="781">
                            <scope line="783"/>
                            <scope line="785"/>
                        </scope>
                    </scope>
                    <scope line="792"/>
                </scope>
                <scope line="798">
                    <scope line="799"/>
                    <scope line="803"/>
                    <scope line="807"/>
                </scope>
                <scope line="815">
                    <scope line="820"/>
                    <scope line="828"/>
                    <scope line="834"/>
                </scope>
                <scope line="839">
                    <scope line="840"/>
                </scope>
                <scope line="845">
                    <scope line="846"/>
                </scope>
                <scope line="851">
                    <scope line="852"/>
                    <scope line="860">
                        <scope line="864"/>
                    </scope>
                    <scope line="868">
                        <scope line="869"/>
                    </scope>
                </scope>
            </method>
            <method name="doError" type="void" line="879"/>
            <javadoc line="879">
                                
            </javadoc>
            <method name="doBind" type="void" line="903"/>
            <javadoc line="903">
                                
            </javadoc>
            <method name="doReceive" type="void" line="908"/>
            <javadoc line="908">
                &lt;CODE&gt;doReceive()&lt;/CODE&gt; should block until a client is available.
                  If this method throws an exception, &lt;CODE&gt;doProcess()&lt;/CODE&gt; is not
                  called but &lt;CODE&gt;doUnbind()&lt;/CODE&gt; is called then &lt;CODE&gt;run()&lt;/CODE&gt;
                  stops.                
            </javadoc>
            <method name="doProcess" type="void" line="917"/>
            <javadoc line="917">
                &lt;CODE&gt;doProcess()&lt;/CODE&gt; is called after &lt;CODE&gt;doReceive()&lt;/CODE&gt;:
                  it should process the requests of the incoming client.
                  If it throws an exception, &lt;CODE&gt;doUnbind()&lt;/CODE&gt; is called and
                  &lt;CODE&gt;run()&lt;/CODE&gt; stops.                
            </javadoc>
            <method name="doUnbind" type="void" line="926"/>
            <javadoc line="926">
                &lt;CODE&gt;doUnbind()&lt;/CODE&gt; is called whenever the connector goes
                  &lt;CODE&gt;OFFLINE&lt;/CODE&gt;, except if &lt;CODE&gt;doBind()&lt;/CODE&gt; has thrown an
                  exception.                
            </javadoc>
            <javadoc line="934">
                Get the &lt;code&gt;MBeanServer&lt;/code&gt; object to which incoming requests are
                  sent.  This is either the MBean server in which this connector is
                  registered, or an &lt;code&gt;MBeanServerForwarder&lt;/code&gt; leading to that
                  server.                
            </javadoc>
            <method name="getMBeanServer" type="MBeanServer" line="940"/>
            <javadoc line="944">
                Set the &lt;code&gt;MBeanServer&lt;/code&gt; object to which incoming
                  requests are sent.  This must be either the MBean server in
                  which this connector is registered, or an
                  &lt;code&gt;MBeanServerForwarder&lt;/code&gt; leading to that server.  An
                  &lt;code&gt;MBeanServerForwarder&lt;/code&gt; &lt;code&gt;mbsf&lt;/code&gt; leads to an
                  MBean server &lt;code&gt;mbs&lt;/code&gt; if
                  &lt;code&gt;mbsf.getMBeanServer()&lt;/code&gt; is either &lt;code&gt;mbs&lt;/code&gt;
                  or an &lt;code&gt;MBeanServerForwarder&lt;/code&gt; leading to
                  &lt;code&gt;mbs&lt;/code&gt;.                
                <exception>
                    IllegalArgumentException if <code>newMBS</code> is neither
                      the MBean server in which this connector is registered nor an
                      <code>MBeanServerForwarder</code> leading to that server.                    
                </exception>
                <exception>
                    IllegalStateException This method has been invoked
                      while the communicator was ONLINE or STARTING.                    
                </exception>
            </javadoc>
            <method name="setMBeanServer" type="void" line="963">
                <params>
                    <param name="newMBS" type="MBeanServer"/>
                </params>
                <scope line="964"/>
                <declaration name="error" type="String" line="969"/>
                <declaration name="seenMBS" type="Vector&lt;MBeanServer&gt;" line="973"/>
                <scope line="976"/>
            </method>
            <javadoc line="990">
                For internal use only.                
            </javadoc>
            <method name="getObjectName" type="ObjectName" line="993"/>
            <javadoc line="997">
                For internal use only.                
            </javadoc>
            <method name="changeState" type="void" line="1000">
                <params>
                    <param name="newState" type="int"/>
                </params>
                <declaration name="oldState" type="int" line="1001"/>
                <scope line="1002"/>
            </method>
            <javadoc line="1012">
                Returns the string used in debug traces.                
            </javadoc>
            <method name="makeDebugTag" type="String" line="1015"/>
            <javadoc line="1019">
                Returns the string used to name the connector thread.                
            </javadoc>
            <method name="makeThreadName" type="String" line="1022">
                <declaration name="result" type="String" line="1023"/>
            </method>
            <javadoc line="1033">
                This method blocks if there are too many active clients.
                  Call to &lt;CODE&gt;wait()&lt;/CODE&gt; is terminated when a client handler
                  thread calls &lt;CODE&gt;notifyClientHandlerDeleted(this)&lt;/CODE&gt; ;                
            </javadoc>
            <method name="waitIfTooManyClients" type="void" line="1039">
                <scope line="1040">
                    <scope line="1041"/>
                </scope>
            </method>
            <javadoc line="1049">
                This method blocks until there is no more active client.                
            </javadoc>
            <method name="waitClientTermination" type="void" line="1052">
                <comment line="1062">
                    The ClientHandler will remove themselves from the                    
                </comment>
                <comment line="1063">
                    clientHandlerVector at the end of their run() method, by                    
                </comment>
                <comment line="1064">
                    calling notifyClientHandlerDeleted().                    
                </comment>
                <comment line="1065">
                    Since the clientHandlerVector is modified by the ClientHandler                    
                </comment>
                <comment line="1066">
                    threads we must avoid using Enumeration or Iterator to loop                    
                </comment>
                <comment line="1067">
                    over this array. We must also take care of NoSuchElementException                    
                </comment>
                <comment line="1068">
                    which could be thrown if the last ClientHandler removes itself                    
                </comment>
                <comment line="1069">
                    between the call to clientHandlerVector.isEmpty() and the call                    
                </comment>
                <comment line="1070">
                    to clientHandlerVector.firstElement().                    
                </comment>
                <comment line="1071">
                    What we *MUST NOT DO* is locking the clientHandlerVector, because                    
                </comment>
                <comment line="1072">
                    this would most probably cause a deadlock.                    
                </comment>
                <comment line="1073">
                                        
                </comment>
                <declaration name="s" type="int" line="1053"/>
                <scope line="1054">
                    <scope line="1055"/>
                </scope>
                <scope line="1074">
                    <scope line="1075"/>
                    <scope line="1077">
                        <scope line="1078"/>
                    </scope>
                </scope>
                <scope line="1085">
                    <scope line="1086"/>
                </scope>
            </method>
            <javadoc line="1093">
                Call &lt;CODE&gt;interrupt()&lt;/CODE&gt; on each pending client.                
            </javadoc>
            <method name="terminateAllClient" type="void" line="1096">
                <comment line="1105">
                    The ClientHandler will remove themselves from the                    
                </comment>
                <comment line="1106">
                    clientHandlerVector at the end of their run() method, by                    
                </comment>
                <comment line="1107">
                    calling notifyClientHandlerDeleted().                    
                </comment>
                <comment line="1108">
                    Since the clientHandlerVector is modified by the ClientHandler                    
                </comment>
                <comment line="1109">
                    threads we must avoid using Enumeration or Iterator to loop                    
                </comment>
                <comment line="1110">
                    over this array.                    
                </comment>
                <comment line="1111">
                    We cannot use the same logic here than in waitClientTermination()                    
                </comment>
                <comment line="1112">
                    because there is no guarantee that calling interrupt() on the                    
                </comment>
                <comment line="1113">
                    ClientHandler will actually terminate the ClientHandler.                    
                </comment>
                <comment line="1114">
                    Since we do not want to wait for the actual ClientHandler                    
                </comment>
                <comment line="1115">
                    termination, we cannot simply loop over the array until it is                    
                </comment>
                <comment line="1116">
                    empty (this might result in calling interrupt() endlessly on                    
                </comment>
                <comment line="1117">
                    the same client handler. So what we do is simply take a snapshot                    
                </comment>
                <comment line="1118">
                    copy of the vector and loop over the copy.                    
                </comment>
                <comment line="1119">
                    What we *MUST NOT DO* is locking the clientHandlerVector, because                    
                </comment>
                <comment line="1120">
                    this would most probably cause a deadlock.                    
                </comment>
                <comment line="1121">
                                        
                </comment>
                <declaration name="s" type="int" line="1097"/>
                <scope line="1098">
                    <scope line="1099"/>
                </scope>
                <declaration name="handlers" type="ClientHandler[]" line="1122"/>
                <scope line="1124">
                    <scope line="1125"/>
                    <scope line="1127">
                        <scope line="1128"/>
                    </scope>
                </scope>
            </method>
            <javadoc line="1138">
                Controls the way the CommunicatorServer service is deserialized.                
            </javadoc>
            <method name="readObject" type="void" line="1142">
                <params>
                    <param name="stream" type="ObjectInputStream"/>
                </params>
                <comment line="1144">
                    Call the default deserialization of the object.                    
                </comment>
                <comment line="1145">
                                        
                </comment>
                <comment line="1148">
                    Call the specific initialization for the CommunicatorServer service.                    
                </comment>
                <comment line="1149">
                    This is for transient structures to be initialized to specific                    
                </comment>
                <comment line="1150">
                    default values.                    
                </comment>
                <comment line="1151">
                                        
                </comment>
            </method>
            <javadoc line="1170">
                Adds a listener for the notifications emitted by this
                  CommunicatorServer.
                  There is only one type of notifications sent by the CommunicatorServer:
                  they are &lt;tt&gt;{@link javax.management.AttributeChangeNotification}&lt;/tt&gt;,
                  sent when the &lt;tt&gt;State&lt;/tt&gt; attribute of this CommunicatorServer
                  changes.                
                <param>
                    listener The listener object which will handle the emitted
                      notifications.                    
                </param>
                <param>
                    filter The filter object. If filter is null, no filtering
                      will be performed before handling notifications.                    
                </param>
                <param>
                    handback An object which will be sent back unchanged to the
                      listener when a notification is emitted.                    
                </param>
                <exception>
                    IllegalArgumentException Listener parameter is null.                    
                </exception>
            </javadoc>
            <method name="addNotificationListener" type="void" line="1190">
                <params>
                    <param name="listener" type="NotificationListener"/>
                    <param name="filter" type="NotificationFilter"/>
                    <param name="handback" type="Object"/>
                </params>
                <scope line="1192"/>
            </method>
            <javadoc line="1200">
                Removes the specified listener from this CommunicatorServer.
                  Note that if the listener has been registered with different
                  handback objects or notification filters, all entries corresponding
                  to the listener will be removed.                
                <param>
                    listener The listener object to be removed.                    
                </param>
                <exception>
                    ListenerNotFoundException The listener is not registered.                    
                </exception>
            </javadoc>
            <method name="removeNotificationListener" type="void" line="1211">
                <params>
                    <param name="listener" type="NotificationListener"/>
                </params>
                <scope line="1213"/>
            </method>
            <javadoc line="1220">
                Returns an array of MBeanNotificationInfo objects describing
                  the notification types sent by this CommunicatorServer.
                  There is only one type of notifications sent by the CommunicatorServer:
                  it is &lt;tt&gt;{@link javax.management.AttributeChangeNotification}&lt;/tt&gt;,
                  sent when the &lt;tt&gt;State&lt;/tt&gt; attribute of this CommunicatorServer
                  changes.                
            </javadoc>
            <method name="getNotificationInfo" type="MBeanNotificationInfo[]" line="1228">
                <comment line="1230">
                    Initialize notifInfos on first call to getNotificationInfo()                    
                </comment>
                <comment line="1231">
                                        
                </comment>
                <scope line="1232">
                    <declaration name="notifTypes" type="String[]" line="1234"/>
                </scope>
            </method>
            <javadoc line="1245">
                                
            </javadoc>
            <method name="sendStateChangeNotification" type="void" line="1248">
                <params>
                    <param name="oldState" type="int"/>
                    <param name="newState" type="int"/>
                </params>
                <comment line="1260">
                    source                    
                </comment>
                <comment line="1261">
                    sequence number                    
                </comment>
                <comment line="1262">
                    time stamp                    
                </comment>
                <comment line="1263">
                    message                    
                </comment>
                <comment line="1264">
                    attribute name                    
                </comment>
                <comment line="1265">
                    attribute type                    
                </comment>
                <comment line="1266">
                    old value                    
                </comment>
                <comment line="1267">
                    new value                    
                </comment>
                <declaration name="oldStateString" type="String" line="1250"/>
                <declaration name="newStateString" type="String" line="1251"/>
                <declaration name="message" type="String" line="1252"/>
                <declaration name="notif" type="AttributeChangeNotification" line="1259"/>
                <scope line="1268"/>
            </method>
            <javadoc line="1276">
                                
            </javadoc>
            <method name="getStringForState" type="String" line="1279">
                <params>
                    <param name="s" type="int"/>
                </params>
            </method>
            <javadoc line="1294">
                Preregister method of connector.                
                <param>
                    server The <CODE>MBeanServer</CODE> in which the MBean will
                      be registered.                    
                </param>
                <param>
                    name The object name of the MBean.                    
                </param>
                <return>
                    The name of the MBean registered.                    
                </return>
                <exception>
                    java.langException This exception should be caught by
                      the <CODE>MBeanServer</CODE> and re-thrown
                      as an <CODE>MBeanRegistrationException</CODE>.                    
                </exception>
            </javadoc>
            <method name="preRegister" type="ObjectName" line="1308">
                <params>
                    <param name="server" type="MBeanServer"/>
                    <param name="name" type="ObjectName"/>
                </params>
                <scope line="1310">
                    <scope line="1311"/>
                </scope>
            </method>
            <javadoc line="1322">
                @param registrationDone Indicates whether or not the MBean has been
                  successfully registered in the &lt;CODE&gt;MBeanServer&lt;/CODE&gt;.
                  The value false means that the registration phase has failed.                
            </javadoc>
            <method name="postRegister" type="void" line="1328">
                <params>
                    <param name="registrationDone" type="Boolean"/>
                </params>
                <scope line="1329">
                    <scope line="1330"/>
                </scope>
            </method>
            <javadoc line="1336">
                Stop the connector.                
                <exception>
                    java.langException This exception should be caught by
                      the <CODE>MBeanServer</CODE> and re-thrown
                      as an <CODE>MBeanRegistrationException</CODE>.                    
                </exception>
            </javadoc>
            <method name="preDeregister" type="void" line="1343">
                <scope line="1344"/>
                <declaration name="cstate" type="int" line="1348"/>
                <scope line="1349"/>
            </method>
            <javadoc line="1354">
                Do nothing.                
            </javadoc>
            <method name="postDeregister" type="void" line="1357"/>
            <javadoc line="1360">
                Load a class using the default loader repository                
            </javadoc>
            <method name="loadClass" type="Class" line="1364">
                <params>
                    <param name="className" type="String"/>
                </params>
                <scope line="1365"/>
                <scope line="1367">
                    <declaration name="clr" type="ClassLoaderRepository" line="1368"/>
                </scope>
            </method>
        </class>
    </source>