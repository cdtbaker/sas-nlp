<?xml version="1.0" encoding="UTF-8"?>
    <source package="com.sun.jmx.mbeanserver">
        <import package="javax.management.openmbean"/>
        <import package="com.sun.jmx.mbeanserver.MXBeanMapping"/>
        <import package="com.sun.jmx.mbeanserver.DefaultMXBeanMappingFactory"/>
        <import package="java.lang.reflect.Type"/>
        <class name="MXBeanMappingFactory" line="6">
            <javadoc line="6">
                &lt;p&gt;Defines how types are mapped for a given MXBean or set of MXBeans.
                  An {@code MXBeanMappingFactory} can be specified either through the{@link MXBeanMappingFactoryClass} annotation, or through the{@link javax.management.JMX.MBeanOptions JMX.MBeanOptions} argument to a{@link javax.management.StandardMBean StandardMBean} constructor or MXBean
                  proxy.&lt;/p&gt;
                  &lt;p&gt;An {@code MXBeanMappingFactory} must return an {@code MXBeanMapping}for any Java type that appears in the MXBeans that the factory is being
                  used for.  Usually it does that by handling any custom types, and
                  forwarding everything else to the {@linkplain #DEFAULT default mapping
                  factory}.&lt;/p&gt;
                  &lt;p&gt;Consider the {@code MyLinkedList} example from the {@link MXBeanMapping}documentation.  If we are unable to change the {@code MyLinkedList} class
                  to add an {@link MXBeanMappingClass} annotation, we could achieve the same
                  effect by defining {@code MyLinkedListMappingFactory} as follows:&lt;/p&gt;
                  &lt;pre&gt;
                  public class MyLinkedListMappingFactory extends MXBeanMappingFactory {
                  public MyLinkedListMappingFactory() {}
                  public MXBeanMapping mappingForType(Type t, MXBeanMappingFactory f)
                  throws OpenDataException {
                  if (t == MyLinkedList.class)
                  return new MyLinkedListMapping(t);
                  else
                  return MXBeanMappingFactory.DEFAULT.mappingForType(t, f);
                  }
                  }
                  &lt;/pre&gt;
                  &lt;p&gt;The mapping factory handles only the {@code MyLinkedList} class.
                  Every other type is forwarded to the default mapping factory.
                  This includes types such as {@code MyLinkedList[]} and{@code List&lt;MyLinkedList&gt;}; the default mapping factory will recursively
                  invoke {@code MyLinkedListMappingFactory} to map the contained{@code MyLinkedList} type.&lt;/p&gt;
                  &lt;p&gt;Once we have defined {@code MyLinkedListMappingFactory}, we can use
                  it in an MXBean interface like this:&lt;/p&gt;
                  &lt;pre&gt;{@literal @MXBeanMappingFactoryClass}(MyLinkedListMappingFactory.class)
                  public interface SomethingMXBean {
                  public MyLinkedList getSomething();
                  }
                  &lt;/pre&gt;
                  &lt;p&gt;Alternatively we can annotate the package that {@code SomethingMXBean}appears in, or we can supply the factory to a {@link javax.management.StandardMBean StandardMBean} constructor or MXBean
                  proxy.&lt;/p&gt;                
                <see>
                    <a href="../MXBean.html#custom">MXBean specification, section
                      "Custom MXBean type mappings"</a>                    
                </see>
            </javadoc>
            <javadoc line="46">
                &lt;p&gt;Construct an instance of this class.&lt;/p&gt;                
            </javadoc>
            <method name="MXBeanMappingFactory" type="constructor" line="49"/>
            <declaration name="DEFAULT" type="MXBeanMappingFactory" line="51"/>
            <javadoc line="51">
                &lt;p&gt;Mapping factory that applies the default rules for MXBean
                  mappings, as described in the &lt;a
                  href=&quot;../MXBean.html#MXBean-spec&quot;&gt;MXBean specification&lt;/a&gt;.&lt;/p&gt;                
            </javadoc>
            <method name="mappingForType" type="MXBeanMapping" line="57"/>
            <javadoc line="57">
                &lt;p&gt;Return the mapping for the given Java type.  Typically, a
                  mapping factory will return mappings for types it handles, and
                  forward other types to another mapping factory, most often
                  the {@linkplain #DEFAULT default one}.&lt;/p&gt;                
                <param>
                    t the Java type to be mapped.                    
                </param>
                <param>
                    f the original mapping factory that was consulted to do
                      the mapping.  A mapping factory should pass this parameter intact
                      if it forwards a type to another mapping factory.  In the example,
                      this is how {@code MyLinkedListMappingFactory} works for types
                      like {@code MyLinkedList[]} and {@code List<MyLinkedList>}.                    
                </param>
                <return>
                    the mapping for the given type.                    
                </return>
                <throws>
                    OpenDataException if this type cannot be mapped.  This
                      exception is appropriate if the factory is supposed to handle
                      all types of this sort (for example, all linked lists), but
                      cannot handle this particular type.                    
                </throws>
            </javadoc>
        </class>
    </source>