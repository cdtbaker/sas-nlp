<?xml version="1.0" encoding="UTF-8"?>
    <source package="com.sun.security.sasl.gsskerb">
        <import package="java.io.IOException"/>
        <import package="java.util.Map"/>
        <import package="java.util.logging.Logger"/>
        <import package="java.util.logging.Level"/>
        <import package="javax.security.sasl"/>
        <import package="javax.security.auth.callback.CallbackHandler"/>
        <import package="org.ietf.jgss"/>
        <class name="GssKrb5Client" line="9">
            <extends class="GssKrb5Base"/>
            <implements interface="SaslClient"/>
            <javadoc line="9">
                Implements the GSSAPI SASL client mechanism for Kerberos V5.
                  (&lt;A HREF=&quot;http://www.ietf.org/rfc/rfc2222.txt&quot;&gt;RFC 2222&lt;/A&gt;,
                  &lt;a HREF=&quot;http://www.ietf.org/internet-drafts/draft-ietf-cat-sasl-gssapi-04.txt&quot;&gt;draft-ietf-cat-sasl-gssapi-04.txt&lt;/a&gt;).
                  It uses the Java Bindings for GSSAPI
                  (&lt;A HREF=&quot;http://www.ietf.org/rfc/rfc2853.txt&quot;&gt;RFC 2853&lt;/A&gt;)
                  for getting GSSAPI/Kerberos V5 support.
                  The client/server interactions are:
                  C0: bind (GSSAPI, initial response)
                  S0: sasl-bind-in-progress, challenge 1 (output of accept_sec_context or [])
                  C1: bind (GSSAPI, response 1 (output of init_sec_context or []))
                  S1: sasl-bind-in-progress challenge 2 (security layer, server max recv size)
                  C2: bind (GSSAPI, response 2 (security layer, client max recv size, authzid))
                  S2: bind success response
                  Expects the client&apos;s credentials to be supplied from the
                  javax.security.sasl.credentials property or from the thread&apos;s Subject.
                  Otherwise the underlying KRB5 mech will attempt to acquire Kerberos creds
                  by logging into Kerberos (via default TextCallbackHandler).
                  These creds will be used for exchange with server.
                  Required callbacks: none.
                  Environment properties that affect behavior of implementation:
                  javax.security.sasl.qop
                  - quality of protection; list of auth, auth-int, auth-conf; default is &quot;auth&quot;
                  javax.security.sasl.maxbuf
                  - max receive buffer size; default is 65536
                  javax.security.sasl.sendmaxbuffer
                  - max send buffer size; default is 65536; (min with server max recv size)
                  javax.security.sasl.server.authentication
                  - &quot;true&quot; means require mutual authentication; default is &quot;false&quot;
                  javax.security.sasl.credentials
                  - an {@link org.ietf.jgss.GSSCredential} used for delegated authentication.                
                <author>
                    Rosanna Lee                    
                </author>
            </javadoc>
            <declaration name="MY_CLASS_NAME" type="String" line="43"/>
            <declaration name="finalHandshake" type="boolean" line="44"/>
            <declaration name="mutual" type="boolean" line="45"/>
            <declaration name="authzID" type="byte[]" line="46"/>
            <javadoc line="47">
                Creates a SASL mechanism with client credentials that it needs
                  to participate in GSS-API/Kerberos v5 authentication exchange
                  with the server.                
            </javadoc>
            <method name="GssKrb5Client" type="constructor" line="52">
                <params>
                    <param name="authzID" type="String"/>
                    <param name="protocol" type="String"/>
                    <param name="serverName" type="String"/>
                    <param name="props" type="Map"/>
                    <param name="cbh" type="CallbackHandler"/>
                </params>
                <declaration name="service" type="String" line="54"/>
                <scope line="56">
                    <declaration name="mgr" type="GSSManager" line="57"/>
                    <declaration name="acceptorName" type="GSSName" line="58"/>
                    <declaration name="credentials" type="GSSCredential" line="59"/>
                    <scope line="60">
                        <declaration name="prop" type="Object" line="61"/>
                        <scope line="62"/>
                    </scope>
                    <scope line="68"/>
                    <scope line="71">
                        <declaration name="prop" type="String" line="72"/>
                        <scope line="73"/>
                    </scope>
                </scope>
                <scope line="81"/>
                <scope line="84">
                    <scope line="85"/>
                    <scope line="88"/>
                </scope>
            </method>
            <method name="hasInitialResponse" type="boolean" line="93"/>
            <javadoc line="96">
                Processes the challenge data.
                  The server sends a challenge data using which the client must
                  process using GSS_Init_sec_context.
                  As per RFC 2222, when GSS_S_COMPLETE is returned, we do
                  an extra handshake to determine the negotiated security protection
                  and buffer sizes.                
                <param>
                    challengeData A non-null byte array containing the
                      challenge data from the server.                    
                </param>
                <return>
                    A non-null byte array containing the response to be
                      sent to the server.                    
                </return>
            </javadoc>
            <method name="evaluateChallenge" type="byte[]" line="108">
                <params>
                    <param name="challengeData" type="byte[]"/>
                </params>
                <scope line="109"/>
                <scope line="112"/>
                <scope line="115">
                    <scope line="116">
                        <declaration name="gssOutToken" type="byte[]" line="117"/>
                        <scope line="118"/>
                        <scope line="122">
                            <scope line="124"/>
                        </scope>
                    </scope>
                    <scope line="130"/>
                </scope>
            </method>
            <method name="doFinalHandshake" type="byte[]" line="135">
                <params>
                    <param name="challengeData" type="byte[]"/>
                </params>
                <scope line="136">
                    <scope line="137"/>
                    <scope line="140"/>
                    <declaration name="gssOutToken" type="byte[]" line="143"/>
                    <scope line="144">
                        <scope line="145"/>
                    </scope>
                    <declaration name="selectedQop" type="byte" line="150"/>
                    <scope line="151"/>
                    <scope line="154"/>
                    <scope line="158"/>
                    <declaration name="srvMaxBufSize" type="int" line="161"/>
                    <scope line="164"/>
                    <declaration name="len" type="int" line="167"/>
                    <scope line="168"/>
                    <declaration name="gssInToken" type="byte[]" line="171"/>
                    <scope line="173"/>
                    <scope line="177"/>
                    <scope line="181"/>
                    <scope line="185"/>
                </scope>
                <scope line="192"/>
            </method>
        </class>
    </source>