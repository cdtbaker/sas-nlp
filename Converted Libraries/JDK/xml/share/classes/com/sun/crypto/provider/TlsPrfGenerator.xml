<?xml version="1.0" encoding="UTF-8"?>
    <source package="com.sun.crypto.provider">
        <import package="java.util.Arrays"/>
        <import package="java.security"/>
        <import package="java.security.spec.AlgorithmParameterSpec"/>
        <import package="javax.crypto"/>
        <import package="javax.crypto.spec.SecretKeySpec"/>
        <import package="sun.security.internal.spec.TlsPrfParameterSpec"/>
        <class name="TlsPrfGenerator" line="38">
            <extends class="KeyGeneratorSpi"/>
            <comment line="51">
                magic constants and utility functions, also used by other files                
            </comment>
            <comment line="52">
                in this package                
            </comment>
            <comment line="73">
                TLS HMAC &quot;inner&quot; and &quot;outer&quot; padding.  This isn&apos;t a function
                 of the digest algorithm.                
            </comment>
            <comment line="82">
                SSL3 magic mix constants (&quot;A&quot;, &quot;BB&quot;, &quot;CCC&quot;, ...)                
            </comment>
            <comment line="111">
                PRF implementation                
            </comment>
            <comment line="258">
                @param digest the MessageDigest to produce the HMAC
                 @param hmacSize the HMAC size
                 @param secret the secret
                 @param secOff the offset into the secret
                 @param secLen the secret length
                 @param label the label
                 @param seed the seed
                 @param output the output array                
            </comment>
            <javadoc line="38">
                KeyGenerator implementation for the TLS PRF function.
                  &lt;p&gt;
                  This class duplicates the HMAC functionality (RFC 2104) with
                  performance optimizations (e.g. XOR&apos;ing keys with padding doesn&apos;t
                  need to be redone for each HMAC operation).                
                <author>
                    Andreas Sterbenz                    
                </author>
                <since>
                    1.6                    
                </since>
            </javadoc>
            <declaration name="B0" type="byte[]" line="53"/>
            <declaration name="LABEL_MASTER_SECRET" type="byte[]" line="55"/>
            <declaration name="LABEL_KEY_EXPANSION" type="byte[]" line="58"/>
            <declaration name="LABEL_CLIENT_WRITE_KEY" type="byte[]" line="61"/>
            <declaration name="LABEL_SERVER_WRITE_KEY" type="byte[]" line="65"/>
            <declaration name="LABEL_IV_BLOCK" type="byte[]" line="69"/>
            <declaration name="HMAC_ipad64" type="byte[]" line="76"/>
            <declaration name="HMAC_ipad128" type="byte[]" line="77"/>
            <declaration name="HMAC_opad64" type="byte[]" line="78"/>
            <declaration name="HMAC_opad128" type="byte[]" line="79"/>
            <declaration name="SSL3_CONST" type="byte[][]" line="82"/>
            <method name="genPad" type="byte[]" line="84">
                <params>
                    <param name="b" type="byte"/>
                    <param name="count" type="int"/>
                </params>
                <declaration name="padding" type="byte[]" line="85"/>
            </method>
            <method name="concat" type="byte[]" line="90">
                <params>
                    <param name="b1" type="byte[]"/>
                    <param name="b2" type="byte[]"/>
                </params>
                <declaration name="n1" type="int" line="91"/>
                <declaration name="n2" type="int" line="92"/>
                <declaration name="b" type="byte[]" line="93"/>
            </method>
            <method name="genConst" type="byte[][]" line="99">
                <declaration name="n" type="int" line="100"/>
                <declaration name="arr" type="byte[][]" line="101"/>
                <scope line="102">
                    <declaration name="b" type="byte[]" line="103"/>
                </scope>
            </method>
            <declaration name="MSG" type="String" line="112"/>
            <declaration name="spec" type="TlsPrfParameterSpec" line="115"/>
            <method name="TlsPrfGenerator" type="constructor" line="117"/>
            <method name="engineInit" type="void" line="120">
                <params>
                    <param name="random" type="SecureRandom"/>
                </params>
            </method>
            <method name="engineInit" type="void" line="125">
                <params>
                    <param name="params" type="AlgorithmParameterSpec"/>
                    <param name="random" type="SecureRandom"/>
                </params>
                <scope line="126"/>
                <declaration name="key" type="SecretKey" line="130"/>
                <scope line="131"/>
            </method>
            <method name="engineInit" type="void" line="137">
                <params>
                    <param name="keysize" type="int"/>
                    <param name="random" type="SecureRandom"/>
                </params>
            </method>
            <method name="engineGenerateKey0" type="SecretKey" line="141">
                <params>
                    <param name="tls12" type="boolean"/>
                </params>
                <scope line="142"/>
                <declaration name="key" type="SecretKey" line="146"/>
                <declaration name="secret" type="byte[]" line="147"/>
                <scope line="148">
                    <declaration name="labelBytes" type="byte[]" line="149"/>
                    <declaration name="n" type="int" line="150"/>
                    <declaration name="prfBytes" type="byte[]" line="151"/>
                </scope>
                <scope line="157"/>
                <scope line="159"/>
            </method>
            <method name="doTLS12PRF" type="byte[]" line="167">
                <params>
                    <param name="secret" type="byte[]"/>
                    <param name="labelBytes" type="byte[]"/>
                    <param name="seed" type="byte[]"/>
                    <param name="outputLength" type="int"/>
                    <param name="prfHash" type="String"/>
                    <param name="prfHashLength" type="int"/>
                    <param name="prfBlockSize" type="int"/>
                </params>
                <scope line="168"/>
                <declaration name="prfMD" type="MessageDigest" line="171"/>
            </method>
            <method name="doTLS12PRF" type="byte[]" line="179">
                <params>
                    <param name="secret" type="byte[]"/>
                    <param name="labelBytes" type="byte[]"/>
                    <param name="seed" type="byte[]"/>
                    <param name="outputLength" type="int"/>
                    <param name="mdPRF" type="MessageDigest"/>
                    <param name="mdPRFLen" type="int"/>
                    <param name="mdPRFBlockSize" type="int"/>
                </params>
                <comment line="185">
                    If we have a long secret, digest it first.                    
                </comment>
                <comment line="207">
                    P_HASH(Secret, label + seed)                    
                </comment>
                <scope line="181"/>
                <scope line="186"/>
                <declaration name="output" type="byte[]" line="190"/>
                <declaration name="ipad" type="byte[]" line="191"/>
                <declaration name="opad" type="byte[]" line="192"/>
            </method>
            <method name="doTLS10PRF" type="byte[]" line="216">
                <params>
                    <param name="secret" type="byte[]"/>
                    <param name="labelBytes" type="byte[]"/>
                    <param name="seed" type="byte[]"/>
                    <param name="outputLength" type="int"/>
                </params>
                <declaration name="md5" type="MessageDigest" line="217"/>
                <declaration name="sha" type="MessageDigest" line="218"/>
            </method>
            <method name="doTLS10PRF" type="byte[]" line="224">
                <params>
                    <param name="secret" type="byte[]"/>
                    <param name="labelBytes" type="byte[]"/>
                    <param name="seed" type="byte[]"/>
                    <param name="outputLength" type="int"/>
                    <param name="md5" type="MessageDigest"/>
                    <param name="sha" type="MessageDigest"/>
                </params>
                <comment line="225">
                    Split the secret into two halves S1 and S2 of same length.
                     S1 is taken from the first half of the secret, S2 from the
                     second half.
                     Their length is created by rounding up the length of the
                     overall secret divided by two; thus, if the original secret
                     is an odd number of bytes long, the last byte of S1 will be
                     the same as the first byte of S2.
                    
                     Note: Instead of creating S1 and S2, we determine the offset into
                     the overall secret where S2 starts.                    
                </comment>
                <comment line="246">
                    P_MD5(S1, label + seed)                    
                </comment>
                <comment line="250">
                    P_SHA-1(S2, label + seed)                    
                </comment>
                <scope line="238"/>
                <declaration name="off" type="int" line="241"/>
                <declaration name="seclen" type="int" line="242"/>
                <declaration name="output" type="byte[]" line="244"/>
            </method>
            <method name="expand" type="void" line="269">
                <params>
                    <param name="digest" type="MessageDigest"/>
                    <param name="hmacSize" type="int"/>
                    <param name="secret" type="byte[]"/>
                    <param name="secOff" type="int"/>
                    <param name="secLen" type="int"/>
                    <param name="label" type="byte[]"/>
                    <param name="seed" type="byte[]"/>
                    <param name="output" type="byte[]"/>
                    <param name="pad1" type="byte[]"/>
                    <param name="pad2" type="byte[]"/>
                </params>
                <comment line="270">
                    modify the padding used, by XORing the key into our copy of that
                     padding.  That&apos;s to avoid doing that for each HMAC computation.                    
                </comment>
                <comment line="282">
                    compute:
                    
                         P_hash(secret, seed) = HMAC_hash(secret, A(1) + seed) +
                                                HMAC_hash(secret, A(2) + seed) +
                                                HMAC_hash(secret, A(3) + seed) + ...
                     A() is defined as:
                    
                         A(0) = seed
                         A(i) = HMAC_hash(secret, A(i-1))                    
                </comment>
                <comment line="296">
                    compute A() ...                    
                </comment>
                <comment line="299">
                    inner digest                    
                </comment>
                <comment line="309">
                    outer digest                    
                </comment>
                <comment line="317">
                    compute HMAC_hash() ...                    
                </comment>
                <comment line="320">
                    inner digest                    
                </comment>
                <comment line="327">
                    outer digest                    
                </comment>
                <scope line="274"/>
                <declaration name="tmp" type="byte[]" line="279"/>
                <declaration name="aBytes" type="byte[]" line="280"/>
                <declaration name="remaining" type="int" line="293"/>
                <declaration name="ofs" type="int" line="294"/>
                <scope line="295">
                    <scope line="301"/>
                    <scope line="304"/>
                    <scope line="312"/>
                    <declaration name="k" type="int" line="332"/>
                    <scope line="333"/>
                </scope>
            </method>
            <class name="V12" line="340">
                <extends class="TlsPrfGenerator"/>
                <javadoc line="340">
                    A KeyGenerator implementation that supports TLS 1.2.
                      &lt;p&gt;
                      TLS 1.2 uses a different hash algorithm than 1.0/1.1 for the PRF
                      calculations.  As of 2010, there is no PKCS11-level support for TLS
                      1.2 PRF calculations, and no known OS&apos;s have an internal variant
                      we could use.  Therefore for TLS 1.2, we are updating JSSE to request
                      a different provider algorithm:  &quot;SunTls12Prf&quot;.  If we reused the
                      name &quot;SunTlsPrf&quot;, the PKCS11 provider would need be updated to
                      fail correctly when presented with the wrong version number
                      (via Provider.Service.supportsParameters()), and add the
                      appropriate supportsParamters() checks into KeyGenerators (not
                      currently there).                    
                </javadoc>
                <method name="engineGenerateKey" type="SecretKey" line="355"/>
            </class>
            <class name="V10" line="360">
                <extends class="TlsPrfGenerator"/>
                <javadoc line="360">
                    A KeyGenerator implementation that supports TLS 1.0/1.1.                    
                </javadoc>
                <method name="engineGenerateKey" type="SecretKey" line="364"/>
            </class>
        </class>
    </source>