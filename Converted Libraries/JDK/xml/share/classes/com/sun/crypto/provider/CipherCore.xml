<?xml version="1.0" encoding="UTF-8"?>
    <source package="com.sun.crypto.provider">
        <import package="java.util.Locale"/>
        <import package="java.security"/>
        <import package="java.security.spec"/>
        <import package="javax.crypto"/>
        <import package="javax.crypto.spec"/>
        <import package="javax.crypto.BadPaddingException"/>
        <class name="CipherCore" line="8">
            <javadoc line="8">
                This class represents the symmetric algorithms in its various modes
                  (&lt;code&gt;ECB&lt;/code&gt;, &lt;code&gt;CFB&lt;/code&gt;, &lt;code&gt;OFB&lt;/code&gt;, &lt;code&gt;CBC&lt;/code&gt;,
                  &lt;code&gt;PCBC&lt;/code&gt;, &lt;code&gt;CTR&lt;/code&gt;, and &lt;code&gt;CTS&lt;/code&gt;) and
                  padding schemes (&lt;code&gt;PKCS5Padding&lt;/code&gt;, &lt;code&gt;NoPadding&lt;/code&gt;,
                  &lt;code&gt;ISO10126Padding&lt;/code&gt;).                
                <author>
                    Gigi Ankeny                    
                </author>
                <author>
                    Jan Luehe                    
                </author>
                <see>
                    ElectronicCodeBook                    
                </see>
                <see>
                    CipherFeedback                    
                </see>
                <see>
                    OutputFeedback                    
                </see>
                <see>
                    CipherBlockChaining                    
                </see>
                <see>
                    PCBC                    
                </see>
                <see>
                    CounterMode                    
                </see>
                <see>
                    CipherTextStealing                    
                </see>
            </javadoc>
            <declaration name="buffer" type="byte[]" line="25"/>
            <declaration name="blockSize" type="int" line="26"/>
            <declaration name="unitBytes" type="int" line="27"/>
            <declaration name="buffered" type="int" line="28"/>
            <declaration name="minBytes" type="int" line="29"/>
            <declaration name="diffBlocksize" type="int" line="30"/>
            <declaration name="padding" type="Padding" line="31"/>
            <declaration name="cipher" type="FeedbackCipher" line="32"/>
            <declaration name="cipherMode" type="int" line="33"/>
            <declaration name="decrypting" type="boolean" line="34"/>
            <declaration name="ECB_MODE" type="int" line="35"/>
            <declaration name="CBC_MODE" type="int" line="36"/>
            <declaration name="CFB_MODE" type="int" line="37"/>
            <declaration name="OFB_MODE" type="int" line="38"/>
            <declaration name="PCBC_MODE" type="int" line="39"/>
            <declaration name="CTR_MODE" type="int" line="40"/>
            <declaration name="CTS_MODE" type="int" line="41"/>
            <javadoc line="42">
                Creates an instance of CipherCore with default ECB mode and
                  PKCS5Padding.                
            </javadoc>
            <method name="CipherCore" type="constructor" line="46">
                <params>
                    <param name="impl" type="SymmetricCipher"/>
                    <param name="blkSize" type="int"/>
                </params>
            </method>
            <javadoc line="54">
                Sets the mode of this cipher.                
                <param>
                    mode the cipher mode                    
                </param>
                <exception>
                    NoSuchAlgorithmException if the requested cipher mode does
                      not exist                    
                </exception>
            </javadoc>
            <method name="setMode" type="void" line="60">
                <params>
                    <param name="mode" type="String"/>
                </params>
                <declaration name="modeUpperCase" type="String" line="62"/>
                <scope line="63"/>
                <declaration name="rawImpl" type="SymmetricCipher" line="66"/>
                <scope line="67"/>
                <scope line="71"/>
                <scope line="77"/>
                <scope line="83"/>
                <scope line="88"/>
                <scope line="93"/>
                <scope line="97"/>
            </method>
            <method name="getNumOfUnit" type="int" line="101">
                <params>
                    <param name="mode" type="String"/>
                    <param name="offset" type="int"/>
                    <param name="blockSize" type="int"/>
                </params>
                <declaration name="result" type="int" line="102"/>
                <scope line="103">
                    <declaration name="numInt" type="int" line="104"/>
                    <scope line="105">
                        <declaration name="num" type="Integer" line="106"/>
                    </scope>
                    <scope line="110"/>
                    <scope line="113"/>
                </scope>
            </method>
            <javadoc line="119">
                Sets the padding mechanism of this cipher.                
                <param>
                    padding the padding mechanism                    
                </param>
                <exception>
                    NoSuchPaddingException if the requested padding mechanism
                      does not exist                    
                </exception>
            </javadoc>
            <method name="setPadding" type="void" line="125">
                <params>
                    <param name="paddingScheme" type="String"/>
                </params>
                <scope line="126"/>
                <scope line="129"/>
                <scope line="132"/>
                <scope line="135"/>
                <scope line="138"/>
            </method>
            <javadoc line="143">
                Returns the length in bytes that an output buffer would need to be in
                  order to hold the result of the next &lt;code&gt;update&lt;/code&gt; or
                  &lt;code&gt;doFinal&lt;/code&gt; operation, given the input length
                  &lt;code&gt;inputLen&lt;/code&gt; (in bytes).
                  &lt;p&gt;This call takes into account any unprocessed (buffered) data from a
                  previous &lt;code&gt;update&lt;/code&gt; call, and padding.
                  &lt;p&gt;The actual output length of the next &lt;code&gt;update&lt;/code&gt; or
                  &lt;code&gt;doFinal&lt;/code&gt; call may be smaller than the length returned by
                  this method.                
                <param>
                    inputLen the input length (in bytes)                    
                </param>
                <return>
                    the required output buffer size (in bytes)                    
                </return>
            </javadoc>
            <method name="getOutputSize" type="int" line="156">
                <params>
                    <param name="inputLen" type="int"/>
                </params>
                <declaration name="totalLen" type="int" line="157"/>
                <scope line="160"/>
                <scope line="164"/>
            </method>
            <javadoc line="168">
                Returns the initialization vector (IV) in a new buffer.
                  &lt;p&gt;This is useful in the case where a random IV has been created
                  (see &lt;a href = &quot;#init&quot;&gt;init&lt;/a&gt;),
                  or in the context of password-based encryption or
                  decryption, where the IV is derived from a user-provided password.                
                <return>
                    the initialization vector in a new buffer, or null if the
                      underlying algorithm does not use an IV, or if the IV has not yet
                      been set.                    
                </return>
            </javadoc>
            <method name="getIV" type="byte[]" line="178">
                <declaration name="iv" type="byte[]" line="179"/>
            </method>
            <javadoc line="182">
                Returns the parameters used with this cipher.
                  &lt;p&gt;The returned parameters may be the same that were used to initialize
                  this cipher, or may contain the default set of parameters or a set of
                  randomly generated parameters used by the underlying cipher
                  implementation (provided that the underlying cipher implementation
                  uses a default set of parameters or creates new parameters if it needs
                  parameters but was not initialized with any).                
                <return>
                    the parameters used with this cipher, or null if this cipher
                      does not use any parameters.                    
                </return>
            </javadoc>
            <method name="getParameters" type="AlgorithmParameters" line="193">
                <params>
                    <param name="algName" type="String"/>
                </params>
                <declaration name="params" type="AlgorithmParameters" line="194"/>
                <declaration name="iv" type="byte[]" line="196"/>
                <scope line="197">
                    <declaration name="ivSpec" type="AlgorithmParameterSpec" line="198"/>
                    <scope line="199">
                        <declaration name="rawImpl" type="RC2Crypt" line="200"/>
                    </scope>
                    <scope line="203"/>
                    <scope line="206"/>
                    <scope line="209"/>
                    <scope line="212"/>
                    <scope line="215"/>
                    <scope line="218"/>
                </scope>
            </method>
            <javadoc line="224">
                Initializes this cipher with a key and a source of randomness.
                  &lt;p&gt;The cipher is initialized for one of the following four operations:
                  encryption, decryption, key wrapping or key unwrapping, depending on
                  the value of &lt;code&gt;opmode&lt;/code&gt;.
                  &lt;p&gt;If this cipher requires an initialization vector (IV), it will get
                  it from &lt;code&gt;random&lt;/code&gt;.
                  This behaviour should only be used in encryption or key wrapping
                  mode, however.
                  When initializing a cipher that requires an IV for decryption or
                  key unwrapping, the IV
                  (same IV that was used for encryption or key wrapping) must be provided
                  explicitly as a
                  parameter, in order to get the correct result.
                  &lt;p&gt;This method also cleans existing buffer and other related state
                  information.                
                <param>
                    opmode the operation mode of this cipher (this is one of
                      the following:
                      <code>ENCRYPT_MODE</code>, <code>DECRYPT_MODE</code>,
                      <code>WRAP_MODE</code> or <code>UNWRAP_MODE</code>)                    
                </param>
                <param>
                    key the secret key                    
                </param>
                <param>
                    random the source of randomness                    
                </param>
                <exception>
                    InvalidKeyException if the given key is inappropriate for
                      initializing this cipher                    
                </exception>
            </javadoc>
            <method name="init" type="void" line="249">
                <params>
                    <param name="opmode" type="int"/>
                    <param name="key" type="Key"/>
                    <param name="random" type="SecureRandom"/>
                </params>
                <scope line="250"/>
                <scope line="253"/>
            </method>
            <javadoc line="257">
                Initializes this cipher with a key, a set of
                  algorithm parameters, and a source of randomness.
                  &lt;p&gt;The cipher is initialized for one of the following four operations:
                  encryption, decryption, key wrapping or key unwrapping, depending on
                  the value of &lt;code&gt;opmode&lt;/code&gt;.
                  &lt;p&gt;If this cipher (including its underlying feedback or padding scheme)
                  requires any random bytes, it will get them from &lt;code&gt;random&lt;/code&gt;.                
                <param>
                    opmode the operation mode of this cipher (this is one of
                      the following:
                      <code>ENCRYPT_MODE</code>, <code>DECRYPT_MODE</code>,
                      <code>WRAP_MODE</code> or <code>UNWRAP_MODE</code>)                    
                </param>
                <param>
                    key the encryption key                    
                </param>
                <param>
                    params the algorithm parameters                    
                </param>
                <param>
                    random the source of randomness                    
                </param>
                <exception>
                    InvalidKeyException if the given key is inappropriate for
                      initializing this cipher                    
                </exception>
                <exception>
                    InvalidAlgorithmParameterException if the given algorithm
                      parameters are inappropriate for this cipher                    
                </exception>
            </javadoc>
            <method name="init" type="void" line="277">
                <params>
                    <param name="opmode" type="int"/>
                    <param name="key" type="Key"/>
                    <param name="params" type="AlgorithmParameterSpec"/>
                    <param name="random" type="SecureRandom"/>
                </params>
                <declaration name="keyBytes" type="byte[]" line="279"/>
                <declaration name="ivBytes" type="byte[]" line="280"/>
                <scope line="281"/>
                <scope line="284">
                    <scope line="286"/>
                </scope>
                <scope line="290">
                    <scope line="292"/>
                </scope>
                <scope line="296"/>
                <scope line="299">
                    <scope line="300"/>
                </scope>
                <scope line="304">
                    <scope line="305"/>
                    <scope line="308"/>
                </scope>
                <declaration name="algorithm" type="String" line="316"/>
            </method>
            <method name="init" type="void" line="319">
                <params>
                    <param name="opmode" type="int"/>
                    <param name="key" type="Key"/>
                    <param name="params" type="AlgorithmParameters"/>
                    <param name="random" type="SecureRandom"/>
                </params>
                <declaration name="ivSpec" type="IvParameterSpec" line="320"/>
                <scope line="321">
                    <scope line="322"/>
                    <scope line="325"/>
                </scope>
            </method>
            <javadoc line="331">
                Return the key bytes of the specified key. Throw an InvalidKeyException
                  if the key is not usable.                
            </javadoc>
            <method name="getKeyBytes" type="byte[]" line="335">
                <params>
                    <param name="key" type="Key"/>
                </params>
                <scope line="336"/>
                <scope line="339"/>
                <declaration name="keyBytes" type="byte[]" line="342"/>
                <scope line="343"/>
            </method>
            <javadoc line="348">
                Continues a multiple-part encryption or decryption operation
                  (depending on how this cipher was initialized), processing another data
                  part.
                  &lt;p&gt;The first &lt;code&gt;inputLen&lt;/code&gt; bytes in the &lt;code&gt;input&lt;/code&gt;
                  buffer, starting at &lt;code&gt;inputOffset&lt;/code&gt;, are processed, and the
                  result is stored in a new buffer.                
                <param>
                    input the input buffer                    
                </param>
                <param>
                    inputOffset the offset in <code>input</code> where the input
                      starts                    
                </param>
                <param>
                    inputLen the input length                    
                </param>
                <return>
                    the new buffer with the result                    
                </return>
                <exception>
                    IllegalStateException if this cipher is in a wrong state
                      (e.g., has not been initialized)                    
                </exception>
            </javadoc>
            <method name="update" type="byte[]" line="363">
                <params>
                    <param name="input" type="byte[]"/>
                    <param name="inputOffset" type="int"/>
                    <param name="inputLen" type="int"/>
                </params>
                <declaration name="output" type="byte[]" line="364"/>
                <declaration name="out" type="byte[]" line="365"/>
                <scope line="366">
                    <declaration name="len" type="int" line="368"/>
                    <scope line="369"/>
                    <scope line="372"/>
                </scope>
                <scope line="377"/>
            </method>
            <javadoc line="381">
                Continues a multiple-part encryption or decryption operation
                  (depending on how this cipher was initialized), processing another data
                  part.
                  &lt;p&gt;The first &lt;code&gt;inputLen&lt;/code&gt; bytes in the &lt;code&gt;input&lt;/code&gt;
                  buffer, starting at &lt;code&gt;inputOffset&lt;/code&gt;, are processed, and the
                  result is stored in the &lt;code&gt;output&lt;/code&gt; buffer, starting at
                  &lt;code&gt;outputOffset&lt;/code&gt;.                
                <param>
                    input the input buffer                    
                </param>
                <param>
                    inputOffset the offset in <code>input</code> where the input
                      starts                    
                </param>
                <param>
                    inputLen the input length                    
                </param>
                <param>
                    output the buffer for the result                    
                </param>
                <param>
                    outputOffset the offset in <code>output</code> where the result
                      is stored                    
                </param>
                <return>
                    the number of bytes stored in <code>output</code>                    
                </return>
                <exception>
                    ShortBufferException if the given output buffer is too small
                      to hold the result                    
                </exception>
            </javadoc>
            <method name="update" type="int" line="400">
                <params>
                    <param name="input" type="byte[]"/>
                    <param name="inputOffset" type="int"/>
                    <param name="inputLen" type="int"/>
                    <param name="output" type="byte[]"/>
                    <param name="outputOffset" type="int"/>
                </params>
                <declaration name="len" type="int" line="401"/>
                <scope line="402"/>
                <scope line="406"/>
                <scope line="409">
                    <declaration name="in" type="byte[]" line="410"/>
                    <declaration name="inputConsumed" type="int" line="411"/>
                    <declaration name="bufferedConsumed" type="int" line="412"/>
                    <scope line="413"/>
                    <scope line="417"/>
                    <scope line="420"/>
                    <scope line="423"/>
                    <scope line="426"/>
                    <scope line="429"/>
                    <scope line="437"/>
                </scope>
                <scope line="441"/>
            </method>
            <javadoc line="447">
                Encrypts or decrypts data in a single-part operation,
                  or finishes a multiple-part operation.
                  The data is encrypted or decrypted, depending on how this cipher was
                  initialized.
                  &lt;p&gt;The first &lt;code&gt;inputLen&lt;/code&gt; bytes in the &lt;code&gt;input&lt;/code&gt;
                  buffer, starting at &lt;code&gt;inputOffset&lt;/code&gt;, and any input bytes that
                  may have been buffered during a previous &lt;code&gt;update&lt;/code&gt; operation,
                  are processed, with padding (if requested) being applied.
                  The result is stored in a new buffer.
                  &lt;p&gt;The cipher is reset to its initial state (uninitialized) after this
                  call.                
                <param>
                    input the input buffer                    
                </param>
                <param>
                    inputOffset the offset in <code>input</code> where the input
                      starts                    
                </param>
                <param>
                    inputLen the input length                    
                </param>
                <return>
                    the new buffer with the result                    
                </return>
                <exception>
                    IllegalBlockSizeException if this cipher is a block cipher,
                      no padding has been requested (only in encryption mode), and the total
                      input length of the data processed by this cipher is not a multiple of
                      block size                    
                </exception>
                <exception>
                    BadPaddingException if this cipher is in decryption mode,
                      and (un)padding has been requested, but the decrypted data is not
                      bounded by the appropriate padding bytes                    
                </exception>
            </javadoc>
            <method name="doFinal" type="byte[]" line="472">
                <params>
                    <param name="input" type="byte[]"/>
                    <param name="inputOffset" type="int"/>
                    <param name="inputLen" type="int"/>
                </params>
                <declaration name="output" type="byte[]" line="473"/>
                <declaration name="out" type="byte[]" line="474"/>
                <scope line="475">
                    <declaration name="len" type="int" line="477"/>
                    <scope line="478"/>
                    <scope line="482"/>
                </scope>
                <scope line="486"/>
            </method>
            <javadoc line="490">
                Encrypts or decrypts data in a single-part operation,
                  or finishes a multiple-part operation.
                  The data is encrypted or decrypted, depending on how this cipher was
                  initialized.
                  &lt;p&gt;The first &lt;code&gt;inputLen&lt;/code&gt; bytes in the &lt;code&gt;input&lt;/code&gt;
                  buffer, starting at &lt;code&gt;inputOffset&lt;/code&gt;, and any input bytes that
                  may have been buffered during a previous &lt;code&gt;update&lt;/code&gt; operation,
                  are processed, with padding (if requested) being applied.
                  The result is stored in the &lt;code&gt;output&lt;/code&gt; buffer, starting at
                  &lt;code&gt;outputOffset&lt;/code&gt;.
                  &lt;p&gt;The cipher is reset to its initial state (uninitialized) after this
                  call.                
                <param>
                    input the input buffer                    
                </param>
                <param>
                    inputOffset the offset in <code>input</code> where the input
                      starts                    
                </param>
                <param>
                    inputLen the input length                    
                </param>
                <param>
                    output the buffer for the result                    
                </param>
                <param>
                    outputOffset the offset in <code>output</code> where the result
                      is stored                    
                </param>
                <return>
                    the number of bytes stored in <code>output</code>                    
                </return>
                <exception>
                    IllegalBlockSizeException if this cipher is a block cipher,
                      no padding has been requested (only in encryption mode), and the total
                      input length of the data processed by this cipher is not a multiple of
                      block size                    
                </exception>
                <exception>
                    ShortBufferException if the given output buffer is too small
                      to hold the result                    
                </exception>
                <exception>
                    BadPaddingException if this cipher is in decryption mode,
                      and (un)padding has been requested, but the decrypted data is not
                      bounded by the appropriate padding bytes                    
                </exception>
            </javadoc>
            <method name="doFinal" type="int" line="521">
                <params>
                    <param name="input" type="byte[]"/>
                    <param name="inputOffset" type="int"/>
                    <param name="inputLen" type="int"/>
                    <param name="output" type="byte[]"/>
                    <param name="outputOffset" type="int"/>
                </params>
                <declaration name="totalLen" type="int" line="522"/>
                <declaration name="paddedLen" type="int" line="523"/>
                <declaration name="paddingLen" type="int" line="524"/>
                <scope line="525">
                    <scope line="526"/>
                    <scope line="529"/>
                </scope>
                <scope line="533"/>
                <scope line="536"/>
                <scope line="540"/>
                <declaration name="outputCapacity" type="int" line="543"/>
                <scope line="544"/>
                <declaration name="finalBuf" type="byte[]" line="547"/>
                <declaration name="finalOffset" type="int" line="548"/>
                <scope line="549">
                    <scope line="552"/>
                    <scope line="555"/>
                    <scope line="558"/>
                </scope>
                <scope line="562">
                    <scope line="563"/>
                    <declaration name="outWithPadding" type="byte[]" line="566"/>
                    <scope line="568">
                        <declaration name="padStart" type="int" line="569"/>
                        <scope line="570"/>
                    </scope>
                    <scope line="575"/>
                    <scope line="579"/>
                </scope>
                <scope line="583"/>
                <scope line="588"/>
            </method>
            <method name="finalNoPadding" type="int" line="593">
                <params>
                    <param name="in" type="byte[]"/>
                    <param name="inOff" type="int"/>
                    <param name="out" type="byte[]"/>
                    <param name="outOff" type="int"/>
                    <param name="len" type="int"/>
                </params>
                <scope line="595">
                    <scope line="596"/>
                    <scope line="599"/>
                </scope>
                <scope line="603"/>
                <scope line="606"/>
            </method>
            <javadoc line="611">
                Wrap a key.                
                <param>
                    key the key to be wrapped.                    
                </param>
                <return>
                    the wrapped key.                    
                </return>
                <exception>
                    IllegalBlockSizeException if this cipher is a block
                      cipher, no padding has been requested, and the length of the
                      encoding of the key to be wrapped is not a
                      multiple of the block size.                    
                </exception>
                <exception>
                    InvalidKeyException if it is impossible or unsafe to
                      wrap the key with this cipher (e.g., a hardware protected key is
                      being passed to a software only cipher).                    
                </exception>
            </javadoc>
            <method name="wrap" type="byte[]" line="623">
                <params>
                    <param name="key" type="Key"/>
                </params>
                <declaration name="result" type="byte[]" line="624"/>
                <scope line="625">
                    <declaration name="encodedKey" type="byte[]" line="626"/>
                    <scope line="627"/>
                </scope>
                <scope line="632"/>
            </method>
            <javadoc line="636">
                Unwrap a previously wrapped key.                
                <param>
                    wrappedKey the key to be unwrapped.                    
                </param>
                <param>
                    wrappedKeyAlgorithm the algorithm the wrapped key is for.                    
                </param>
                <param>
                    wrappedKeyType the type of the wrapped key.
                      This is one of <code>Cipher.SECRET_KEY</code>,
                      <code>Cipher.PRIVATE_KEY</code>, or <code>Cipher.PUBLIC_KEY</code>.                    
                </param>
                <return>
                    the unwrapped key.                    
                </return>
                <exception>
                    NoSuchAlgorithmException if no installed providers
                      can create keys of type <code>wrappedKeyType</code> for the
                      <code>wrappedKeyAlgorithm</code>.                    
                </exception>
                <exception>
                    InvalidKeyException if <code>wrappedKey</code> does not
                      represent a wrapped key of type <code>wrappedKeyType</code> for
                      the <code>wrappedKeyAlgorithm</code>.                    
                </exception>
            </javadoc>
            <method name="unwrap" type="Key" line="651">
                <params>
                    <param name="wrappedKey" type="byte[]"/>
                    <param name="wrappedKeyAlgorithm" type="String"/>
                    <param name="wrappedKeyType" type="int"/>
                </params>
                <declaration name="encodedKey" type="byte[]" line="652"/>
                <scope line="653"/>
                <scope line="656"/>
                <scope line="659"/>
            </method>
        </class>
    </source>