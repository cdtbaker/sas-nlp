<?xml version="1.0" encoding="UTF-8"?>
    <source package="java.lang">
        <import package="java.util.WeakHashMap"/>
        <import package="java.util.concurrent.atomic.AtomicInteger"/>
        <class name="ClassValue" line="31">
            <type_params>
                <type_param name="T"/>
            </type_params>
            <comment line="168">
                / Implementation...                
            </comment>
            <comment line="169">
                FIXME: Use a data structure here similar that of ThreadLocal (7030453).                
            </comment>
            <comment line="199">
                Replace this map by a per-class slot.                
            </comment>
            <javadoc line="31">
                Lazily associate a computed value with (potentially) every type.
                  For example, if a dynamic language needs to construct a message dispatch
                  table for each class encountered at a message send call site,
                  it can use a {@code ClassValue} to cache information needed to
                  perform the message send quickly, for each class encountered.                
                <author>
                    John Rose, JSR 292 EG                    
                </author>
                <since>
                    1.7                    
                </since>
            </javadoc>
            <javadoc line="41">
                Sole constructor.  (For invocation by subclass constructors, typically
                  implicit.)                
            </javadoc>
            <method name="ClassValue" type="constructor" line="45"/>
            <method name="computeValue" type="T" line="48"/>
            <javadoc line="48">
                Computes the given class&apos;s derived value for this {@code ClassValue}.
                  &lt;p&gt;
                  This method will be invoked within the first thread that accesses
                  the value with the {@link #get get} method.
                  &lt;p&gt;
                  Normally, this method is invoked at most once per class,
                  but it may be invoked again if there has been a call to{@link #remove remove}.
                  &lt;p&gt;
                  If this method throws an exception, the corresponding call to {@code get}will terminate abnormally with that exception, and no class value will be recorded.                
                <param>
                    type the type whose class value must be computed                    
                </param>
                <return>
                    the newly computed value associated with this {@code ClassValue}, for the given class or interface                    
                </return>
                <see>
                    #get                    
                </see>
                <see>
                    #remove                    
                </see>
            </javadoc>
            <javadoc line="68">
                Returns the value for the given class.
                  If no value has yet been computed, it is obtained by
                  an invocation of the {@link #computeValue computeValue} method.
                  &lt;p&gt;
                  The actual installation of the value on the class
                  is performed atomically.
                  At that point, if several racing threads have
                  computed values, one is chosen, and returned to
                  all the racing threads.
                  &lt;p&gt;
                  The {@code type} parameter is typically a class, but it may be any type,
                  such as an interface, a primitive type (like {@code int.class}), or {@code void.class}.
                  &lt;p&gt;
                  In the absence of {@code remove} calls, a class value has a simple
                  state diagram:  uninitialized and initialized.
                  When {@code remove} calls are made,
                  the rules for value observation are more complex.
                  See the documentation for {@link #remove remove} for more information.                
                <param>
                    type the type whose class value must be computed or retrieved                    
                </param>
                <return>
                    the current value associated with this {@code ClassValue}, for the given class or interface                    
                </return>
                <throws>
                    NullPointerException if the argument is null                    
                </throws>
                <see>
                    #remove                    
                </see>
                <see>
                    #computeValue                    
                </see>
            </javadoc>
            <method name="get" type="T" line="94">
                <params>
                    <param name="type" type="Class<?>"/>
                </params>
                <declaration name="map" type="ClassValueMap" line="95"/>
                <scope line="96">
                    <declaration name="x" type="Object" line="97"/>
                    <scope line="98"/>
                </scope>
            </method>
            <javadoc line="105">
                Removes the associated value for the given class.
                  If this value is subsequently {@linkplain #get read} for the same class,
                  its value will be reinitialized by invoking its {@link #computeValue computeValue} method.
                  This may result in an additional invocation of the{@code computeValue} method for the given class.
                  &lt;p&gt;
                  In order to explain the interaction between {@code get} and {@code remove} calls,
                  we must model the state transitions of a class value to take into account
                  the alternation between uninitialized and initialized states.
                  To do this, number these states sequentially from zero, and note that
                  uninitialized (or removed) states are numbered with even numbers,
                  while initialized (or re-initialized) states have odd numbers.
                  &lt;p&gt;
                  When a thread {@code T} removes a class value in state {@code 2N},
                  nothing happens, since the class value is already uninitialized.
                  Otherwise, the state is advanced atomically to {@code 2N+1}.
                  &lt;p&gt;
                  When a thread {@code T} queries a class value in state {@code 2N},
                  the thread first attempts to initialize the class value to state {@code 2N+1}by invoking {@code computeValue} and installing the resulting value.
                  &lt;p&gt;
                  When {@code T} attempts to install the newly computed value,
                  if the state is still at {@code 2N}, the class value will be initialized
                  with the computed value, advancing it to state {@code 2N+1}.
                  &lt;p&gt;
                  Otherwise, whether the new state is even or odd,{@code T} will discard the newly computed value
                  and retry the {@code get} operation.
                  &lt;p&gt;
                  Discarding and retrying is an important proviso,
                  since otherwise {@code T} could potentially install
                  a disastrously stale value.  For example:
                  &lt;ul&gt;
                  &lt;li&gt;{@code T} calls {@code CV.get(C)} and sees state {@code 2N}&lt;li&gt;{@code T} quickly computes a time-dependent value {@code V0} and gets ready to install it
                  &lt;li&gt;{@code T} is hit by an unlucky paging or scheduling event, and goes to sleep for a long time
                  &lt;li&gt;...meanwhile, {@code T2} also calls {@code CV.get(C)} and sees state {@code 2N}&lt;li&gt;{@code T2} quickly computes a similar time-dependent value {@code V1} and installs it on {@code CV.get(C)}&lt;li&gt;{@code T2} (or a third thread) then calls {@code CV.remove(C)}, undoing {@code T2}&apos;s work
                  &lt;li&gt; the previous actions of {@code T2} are repeated several times
                  &lt;li&gt; also, the relevant computed values change over time: {@code V1}, {@code V2}, ...
                  &lt;li&gt;...meanwhile, {@code T} wakes up and attempts to install {@code V0}; &lt;em&gt;this must fail&lt;/em&gt;
                  &lt;/ul&gt;
                  We can assume in the above scenario that {@code CV.computeValue} uses locks to properly
                  observe the time-dependent states as it computes {@code V1}, etc.
                  This does not remove the threat of a stale value, since there is a window of time
                  between the return of {@code computeValue} in {@code T} and the installation
                  of the the new value.  No user synchronization is possible during this time.                
                <param>
                    type the type whose class value must be removed                    
                </param>
                <throws>
                    NullPointerException if the argument is null                    
                </throws>
            </javadoc>
            <method name="remove" type="void" line="158">
                <params>
                    <param name="type" type="Class<?>"/>
                </params>
                <declaration name="map" type="ClassValueMap" line="159"/>
                <scope line="160">
                    <scope line="161"/>
                </scope>
            </method>
            <declaration name="STORE_BARRIER" type="AtomicInteger" line="170"/>
            <javadoc line="172">
                Slow path for {@link #get}.                
            </javadoc>
            <method name="setComputedValue" type="T" line="173">
                <params>
                    <param name="type" type="Class<?>"/>
                </params>
                <comment line="180">
                    All stores pending from computeValue are completed.                    
                </comment>
                <comment line="182">
                    Warm up the table with a null entry.                    
                </comment>
                <comment line="186">
                    All stores pending from table expansion are completed.                    
                </comment>
                <comment line="189">
                    One might fear a possible race condition here                    
                </comment>
                <comment line="190">
                    if the code for map.put has flushed the write                    
                </comment>
                <comment line="191">
                    to map.table[*] before the writes to the Map.Entry                    
                </comment>
                <comment line="192">
                    are done.  This is not possible, since we have                    
                </comment>
                <comment line="193">
                    warmed up the table with an empty entry.                    
                </comment>
                <declaration name="map" type="ClassValueMap" line="174"/>
                <scope line="175"/>
                <declaration name="value" type="T" line="178"/>
                <scope line="181"/>
                <scope line="187"/>
            </method>
            <declaration name="ROOT" type="WeakHashMap&lt;Class&lt;?&gt;,ClassValueMap&gt;" line="199"/>
            <method name="getMap" type="ClassValueMap" line="202">
                <params>
                    <param name="type" type="Class<?>"/>
                </params>
                <comment line="203">
                    test for null                    
                </comment>
            </method>
            <method name="initializeMap" type="ClassValueMap" line="207">
                <params>
                    <param name="type" type="Class<?>"/>
                </params>
                <scope line="208">
                    <declaration name="map" type="ClassValueMap" line="209"/>
                </scope>
            </method>
            <class name="ClassValueMap" line="216">
                <extends class="WeakHashMap">
                    <type_params>
                        <type_param name="ClassValue"/>
                        <type_param name="Object"/>
                    </type_params>
                </extends>
                <javadoc line="217">
                    Make sure this table contains an Entry for the given key, even if it is empty.                    
                </javadoc>
                <method name="preInitializeEntry" type="void" line="218">
                    <params>
                        <param name="key" type="ClassValue"/>
                    </params>
                </method>
                <javadoc line="222">
                    Make sure this table contains a non-empty Entry for the given key.                    
                </javadoc>
                <method name="initializeEntry" type="Object" line="223">
                    <params>
                        <param name="key" type="ClassValue"/>
                        <param name="value" type="Object"/>
                    </params>
                    <declaration name="prior" type="Object" line="224"/>
                    <scope line="225"/>
                </method>
                <method name="maskNull" type="Object" line="232">
                    <params>
                        <param name="x" type="Object"/>
                    </params>
                </method>
                <method name="unmaskNull" type="Object" line="235">
                    <params>
                        <param name="x" type="Object"/>
                    </params>
                </method>
            </class>
        </class>
    </source>