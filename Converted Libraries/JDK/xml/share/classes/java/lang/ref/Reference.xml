<?xml version="1.0" encoding="UTF-8"?>
    <source package="java.lang.ref">
        <import package="sun.misc.Cleaner"/>
        <class name="Reference" line="31">
            <type_params>
                <type_param name="T"/>
            </type_params>
            <comment line="44">
                A Reference instance is in one of four possible internal states:
                
                     Active: Subject to special treatment by the garbage collector.  Some
                     time after the collector detects that the reachability of the
                     referent has changed to the appropriate state, it changes the
                     instance&apos;s state to either Pending or Inactive, depending upon
                     whether or not the instance was registered with a queue when it was
                     created.  In the former case it also adds the instance to the
                     pending-Reference list.  Newly-created instances are Active.
                
                     Pending: An element of the pending-Reference list, waiting to be
                     enqueued by the Reference-handler thread.  Unregistered instances
                     are never in this state.
                
                     Enqueued: An element of the queue with which the instance was
                     registered when it was created.  When an instance is removed from
                     its ReferenceQueue, it is made Inactive.  Unregistered instances are
                     never in this state.
                
                     Inactive: Nothing more to do.  Once an instance becomes Inactive its
                     state will never change again.
                
                 The state is encoded in the queue and next fields as follows:
                
                     Active: queue = ReferenceQueue with which instance is registered, or
                     ReferenceQueue.NULL if it was not registered with a queue; next =
                     null.
                
                     Pending: queue = ReferenceQueue with which instance is registered;
                     next = Following instance in queue, or this if at end of list.
                
                     Enqueued: queue = ReferenceQueue.ENQUEUED; next = Following instance
                     in queue, or this if at end of list.
                
                     Inactive: queue = ReferenceQueue.NULL; next = this.
                
                 With this scheme the collector need only examine the next field in order
                 to determine whether a Reference instance requires special treatment: If
                 the next field is null then the instance is active; if it is non-null,
                 then the collector should treat the instance normally.
                
                 To ensure that concurrent collector can discover active Reference
                 objects without interfering with application threads that may apply
                 the enqueue() method to those objects, collectors should link
                 discovered objects through the discovered field.                
            </comment>
            <comment line="91">
                                
            </comment>
            <comment line="96">
                                
            </comment>
            <comment line="99">
                Object used to synchronize with the garbage collector.  The collector
                 must acquire this lock at the beginning of each collection cycle.  It is
                 therefore critical that any code holding this lock complete as quickly
                 as possible, allocate no new objects, and avoid calling user code.                
            </comment>
            <comment line="108">
                List of References waiting to be enqueued.  The collector adds
                 References to this list, while the Reference-handler thread removes
                 them.  This list is protected by the above lock object.                
            </comment>
            <comment line="114">
                High-priority thread to enqueue pending References                
            </comment>
            <comment line="167">
                                
            </comment>
            <comment line="193">
                                
            </comment>
            <comment line="228">
                                
            </comment>
            <javadoc line="31">
                Abstract base class for reference objects.  This class defines the
                  operations common to all reference objects.  Because reference objects are
                  implemented in close cooperation with the garbage collector, this class may
                  not be subclassed directly.                
                <author>
                    Mark Reinhold                    
                </author>
                <since>
                    1.2                    
                </since>
            </javadoc>
            <declaration name="referent" type="T" line="90"/>
            <declaration name="queue" type="ReferenceQueue&lt;? super T&gt;" line="92"/>
            <declaration name="next" type="Reference" line="94"/>
            <declaration name="discovered" type="Reference&lt;T&gt;" line="95"/>
            <class name="Lock" line="103"/>
            <declaration name="lock" type="Lock" line="104"/>
            <declaration name="pending" type="Reference" line="111"/>
            <class name="ReferenceHandler" line="115">
                <extends class="Thread"/>
                <method name="ReferenceHandler" type="constructor" line="117">
                    <params>
                        <param name="g" type="ThreadGroup"/>
                        <param name="name" type="String"/>
                    </params>
                </method>
                <method name="run" type="void" line="121">
                    <comment line="139">
                        Fast path for cleaners                        
                    </comment>
                    <scope line="122">
                        <declaration name="r" type="Reference" line="124"/>
                        <scope line="125">
                            <scope line="126">
                                <declaration name="rn" type="Reference" line="128"/>
                            </scope>
                            <scope line="131">
                                <scope line="132"/>
                                <scope line="134"/>
                            </scope>
                        </scope>
                        <scope line="140"/>
                        <declaration name="q" type="ReferenceQueue" line="145"/>
                    </scope>
                </method>
            </class>
            <scope line="151">
                <declaration name="tg" type="ThreadGroup" line="152"/>
                <declaration name="handler" type="Thread" line="156"/>
            </scope>
            <javadoc line="168">
                Returns this reference object&apos;s referent.  If this reference object has
                  been cleared, either by the program or by the garbage collector, then
                  this method returns &lt;code&gt;null&lt;/code&gt;.                
                <return>
                    The object to which this reference refers, or
                      <code>null</code> if this reference object has been cleared                    
                </return>
            </javadoc>
            <method name="get" type="T" line="176"/>
            <javadoc line="180">
                Clears this reference object.  Invoking this method will not cause this
                  object to be enqueued.
                  &lt;p&gt; This method is invoked only by Java code; when the garbage collector
                  clears references it does so directly, without invoking this method.                
            </javadoc>
            <method name="clear" type="void" line="187"/>
            <javadoc line="194">
                Tells whether or not this reference object has been enqueued, either by
                  the program or by the garbage collector.  If this reference object was
                  not registered with a queue when it was created, then this method will
                  always return &lt;code&gt;false&lt;/code&gt;.                
                <return>
                    <code>true</code> if and only if this reference object has
                      been enqueued                    
                </return>
            </javadoc>
            <method name="isEnqueued" type="boolean" line="203">
                <comment line="204">
                    In terms of the internal states, this predicate actually tests                    
                </comment>
                <scope line="206"/>
            </method>
            <javadoc line="211">
                Adds this reference object to the queue with which it is registered,
                  if any.
                  &lt;p&gt; This method is invoked only by Java code; when the garbage collector
                  enqueues references it does so directly, without invoking this method.                
                <return>
                    <code>true</code> if this reference object was successfully
                      enqueued; <code>false</code> if it was already enqueued or if
                      it was not registered with a queue when it was created                    
                </return>
            </javadoc>
            <method name="enqueue" type="boolean" line="222"/>
            <method name="Reference" type="constructor" line="229">
                <params>
                    <param name="referent" type="T"/>
                </params>
            </method>
            <method name="Reference" type="constructor" line="233">
                <params>
                    <param name="referent" type="T"/>
                    <param name="queue" type="ReferenceQueue<? super T>"/>
                </params>
            </method>
        </class>
    </source>