<?xml version="1.0" encoding="UTF-8"?>
    <source package="java.lang">
        <import package="sun.misc.FloatingDecimal"/>
        <import package="sun.misc.FpUtils"/>
        <import package="sun.misc.FloatConsts"/>
        <import package="sun.misc.DoubleConsts"/>
        <class name="Float" line="33">
            <extends class="Number"/>
            <comment line="80">
                3.4028235e+38f                
            </comment>
            <comment line="90">
                1.17549435E-38f                
            </comment>
            <comment line="98">
                1.4e-45f                
            </comment>
            <implements interface="Comparable">
                <type_params>
                    <type_param name="Float"/>
                </type_params>
            </implements>
            <javadoc line="33">
                The {@code Float} class wraps a value of primitive type{@code float} in an object. An object of type{@code Float} contains a single field whose type is{@code float}.
                  &lt;p&gt;In addition, this class provides several methods for converting a{@code float} to a {@code String} and a{@code String} to a {@code float}, as well as other
                  constants and methods useful when dealing with a{@code float}.                
                <author>
                    Lee Boynton                    
                </author>
                <author>
                    Arthur van Hoff                    
                </author>
                <author>
                    Joseph D. Darcy                    
                </author>
                <since>
                    JDK1.0                    
                </since>
            </javadoc>
            <declaration name="POSITIVE_INFINITY" type="float" line="51"/>
            <javadoc line="51">
                A constant holding the positive infinity of type{@code float}. It is equal to the value returned by{@code Float.intBitsToFloat(0x7f800000)}.                
            </javadoc>
            <declaration name="NEGATIVE_INFINITY" type="float" line="58"/>
            <javadoc line="58">
                A constant holding the negative infinity of type{@code float}. It is equal to the value returned by{@code Float.intBitsToFloat(0xff800000)}.                
            </javadoc>
            <declaration name="NaN" type="float" line="65"/>
            <javadoc line="65">
                A constant holding a Not-a-Number (NaN) value of type{@code float}.  It is equivalent to the value returned by{@code Float.intBitsToFloat(0x7fc00000)}.                
            </javadoc>
            <declaration name="MAX_VALUE" type="float" line="72"/>
            <javadoc line="72">
                A constant holding the largest positive finite value of type{@code float}, (2-2&lt;sup&gt;-23&lt;/sup&gt;)&amp;middot;2&lt;sup&gt;127&lt;/sup&gt;.
                  It is equal to the hexadecimal floating-point literal{@code 0x1.fffffeP+127f} and also equal to{@code Float.intBitsToFloat(0x7f7fffff)}.                
            </javadoc>
            <declaration name="MIN_NORMAL" type="float" line="81"/>
            <javadoc line="81">
                A constant holding the smallest positive normal value of type{@code float}, 2&lt;sup&gt;-126&lt;/sup&gt;.  It is equal to the
                  hexadecimal floating-point literal {@code 0x1.0p-126f} and also
                  equal to {@code Float.intBitsToFloat(0x00800000)}.                
                <since>
                    1.6                    
                </since>
            </javadoc>
            <declaration name="MIN_VALUE" type="float" line="91"/>
            <javadoc line="91">
                A constant holding the smallest positive nonzero value of type{@code float}, 2&lt;sup&gt;-149&lt;/sup&gt;. It is equal to the
                  hexadecimal floating-point literal {@code 0x0.000002P-126f}and also equal to {@code Float.intBitsToFloat(0x1)}.                
            </javadoc>
            <declaration name="MAX_EXPONENT" type="int" line="99"/>
            <javadoc line="99">
                Maximum exponent a finite {@code float} variable may have.  It
                  is equal to the value returned by {@codeMath.getExponent(Float.MAX_VALUE)}.                
                <since>
                    1.6                    
                </since>
            </javadoc>
            <declaration name="MIN_EXPONENT" type="int" line="108"/>
            <javadoc line="108">
                Minimum exponent a normalized {@code float} variable may have.
                  It is equal to the value returned by {@codeMath.getExponent(Float.MIN_NORMAL)}.                
                <since>
                    1.6                    
                </since>
            </javadoc>
            <declaration name="SIZE" type="int" line="117"/>
            <javadoc line="117">
                The number of bits used to represent a {@code float} value.                
                <since>
                    1.5                    
                </since>
            </javadoc>
            <declaration name="TYPE" type="Class&lt;Float&gt;" line="124"/>
            <javadoc line="124">
                The {@code Class} instance representing the primitive type{@code float}.                
                <since>
                    JDK1.1                    
                </since>
            </javadoc>
            <javadoc line="132">
                Returns a string representation of the {@code float}argument. All characters mentioned below are ASCII characters.
                  &lt;ul&gt;
                  &lt;li&gt;If the argument is NaN, the result is the string
                  &quot;{@code NaN}&quot;.
                  &lt;li&gt;Otherwise, the result is a string that represents the sign and
                  magnitude (absolute value) of the argument. If the sign is
                  negative, the first character of the result is
                  &apos;{@code -}&apos; (&lt;code&gt;&apos;&amp;#92;u002D&apos;&lt;/code&gt;); if the sign is
                  positive, no sign character appears in the result. As for
                  the magnitude &lt;i&gt;m&lt;/i&gt;:
                  &lt;ul&gt;
                  &lt;li&gt;If &lt;i&gt;m&lt;/i&gt; is infinity, it is represented by the characters{@code &quot;Infinity&quot;}; thus, positive infinity produces
                  the result {@code &quot;Infinity&quot;} and negative infinity
                  produces the result {@code &quot;-Infinity&quot;}.
                  &lt;li&gt;If &lt;i&gt;m&lt;/i&gt; is zero, it is represented by the characters{@code &quot;0.0&quot;}; thus, negative zero produces the result{@code &quot;-0.0&quot;} and positive zero produces the result{@code &quot;0.0&quot;}.
                  &lt;li&gt; If &lt;i&gt;m&lt;/i&gt; is greater than or equal to 10&lt;sup&gt;-3&lt;/sup&gt; but
                  less than 10&lt;sup&gt;7&lt;/sup&gt;, then it is represented as the
                  integer part of &lt;i&gt;m&lt;/i&gt;, in decimal form with no leading
                  zeroes, followed by &apos;{@code .}&apos;
                  (&lt;code&gt;&apos;&amp;#92;u002E&apos;&lt;/code&gt;), followed by one or more
                  decimal digits representing the fractional part of
                  &lt;i&gt;m&lt;/i&gt;.
                  &lt;li&gt; If &lt;i&gt;m&lt;/i&gt; is less than 10&lt;sup&gt;-3&lt;/sup&gt; or greater than or
                  equal to 10&lt;sup&gt;7&lt;/sup&gt;, then it is represented in
                  so-called &quot;computerized scientific notation.&quot; Let &lt;i&gt;n&lt;/i&gt;
                  be the unique integer such that 10&lt;sup&gt;&lt;i&gt;n&lt;/i&gt; &lt;/sup&gt;&amp;le;
                  &lt;i&gt;m&lt;/i&gt; {@literal &lt;} 10&lt;sup&gt;&lt;i&gt;n&lt;/i&gt;+1&lt;/sup&gt;; then let &lt;i&gt;a&lt;/i&gt;
                  be the mathematically exact quotient of &lt;i&gt;m&lt;/i&gt; and
                  10&lt;sup&gt;&lt;i&gt;n&lt;/i&gt;&lt;/sup&gt; so that 1 &amp;le; &lt;i&gt;a&lt;/i&gt; {@literal &lt;} 10.
                  The magnitude is then represented as the integer part of
                  &lt;i&gt;a&lt;/i&gt;, as a single decimal digit, followed by
                  &apos;{@code .}&apos; (&lt;code&gt;&apos;&amp;#92;u002E&apos;&lt;/code&gt;), followed by
                  decimal digits representing the fractional part of
                  &lt;i&gt;a&lt;/i&gt;, followed by the letter &apos;{@code E}&apos;
                  (&lt;code&gt;&apos;&amp;#92;u0045&apos;&lt;/code&gt;), followed by a representation
                  of &lt;i&gt;n&lt;/i&gt; as a decimal integer, as produced by the
                  method {@link java.lang.Integer#toString(int)}.
                  &lt;/ul&gt;
                  &lt;/ul&gt;
                  How many digits must be printed for the fractional part of
                  &lt;i&gt;m&lt;/i&gt; or &lt;i&gt;a&lt;/i&gt;? There must be at least one digit
                  to represent the fractional part, and beyond that as many, but
                  only as many, more digits as are needed to uniquely distinguish
                  the argument value from adjacent values of type{@code float}. That is, suppose that &lt;i&gt;x&lt;/i&gt; is the
                  exact mathematical value represented by the decimal
                  representation produced by this method for a finite nonzero
                  argument &lt;i&gt;f&lt;/i&gt;. Then &lt;i&gt;f&lt;/i&gt; must be the {@code float}value nearest to &lt;i&gt;x&lt;/i&gt;; or, if two {@code float} values are
                  equally close to &lt;i&gt;x&lt;/i&gt;, then &lt;i&gt;f&lt;/i&gt; must be one of
                  them and the least significant bit of the significand of
                  &lt;i&gt;f&lt;/i&gt; must be {@code 0}.
                  &lt;p&gt;To create localized string representations of a floating-point
                  value, use subclasses of {@link java.text.NumberFormat}.                
                <param>
                    f   the float to be converted.                    
                </param>
                <return>
                    a string representation of the argument.                    
                </return>
            </javadoc>
            <method name="toString" type="String" line="198">
                <params>
                    <param name="f" type="float"/>
                </params>
            </method>
            <javadoc line="202">
                Returns a hexadecimal string representation of the{@code float} argument. All characters mentioned below are
                  ASCII characters.
                  &lt;ul&gt;
                  &lt;li&gt;If the argument is NaN, the result is the string
                  &quot;{@code NaN}&quot;.
                  &lt;li&gt;Otherwise, the result is a string that represents the sign and
                  magnitude (absolute value) of the argument. If the sign is negative,
                  the first character of the result is &apos;{@code -}&apos;
                  (&lt;code&gt;&apos;&amp;#92;u002D&apos;&lt;/code&gt;); if the sign is positive, no sign character
                  appears in the result. As for the magnitude &lt;i&gt;m&lt;/i&gt;:
                  &lt;ul&gt;
                  &lt;li&gt;If &lt;i&gt;m&lt;/i&gt; is infinity, it is represented by the string{@code &quot;Infinity&quot;}; thus, positive infinity produces the
                  result {@code &quot;Infinity&quot;} and negative infinity produces
                  the result {@code &quot;-Infinity&quot;}.
                  &lt;li&gt;If &lt;i&gt;m&lt;/i&gt; is zero, it is represented by the string{@code &quot;0x0.0p0&quot;}; thus, negative zero produces the result{@code &quot;-0x0.0p0&quot;} and positive zero produces the result{@code &quot;0x0.0p0&quot;}.
                  &lt;li&gt;If &lt;i&gt;m&lt;/i&gt; is a {@code float} value with a
                  normalized representation, substrings are used to represent the
                  significand and exponent fields.  The significand is
                  represented by the characters {@code &quot;0x1.&quot;}followed by a lowercase hexadecimal representation of the rest
                  of the significand as a fraction.  Trailing zeros in the
                  hexadecimal representation are removed unless all the digits
                  are zero, in which case a single zero is used. Next, the
                  exponent is represented by {@code &quot;p&quot;} followed
                  by a decimal string of the unbiased exponent as if produced by
                  a call to {@link Integer#toString(int) Integer.toString} on the
                  exponent value.
                  &lt;li&gt;If &lt;i&gt;m&lt;/i&gt; is a {@code float} value with a subnormal
                  representation, the significand is represented by the
                  characters {@code &quot;0x0.&quot;} followed by a
                  hexadecimal representation of the rest of the significand as a
                  fraction.  Trailing zeros in the hexadecimal representation are
                  removed. Next, the exponent is represented by{@code &quot;p-126&quot;}.  Note that there must be at
                  least one nonzero digit in a subnormal significand.
                  &lt;/ul&gt;
                  &lt;/ul&gt;
                  &lt;table border&gt;
                  &lt;caption&gt;&lt;h3&gt;Examples&lt;/h3&gt;&lt;/caption&gt;
                  &lt;tr&gt;&lt;th&gt;Floating-point Value&lt;/th&gt;&lt;th&gt;Hexadecimal String&lt;/th&gt;
                  &lt;tr&gt;&lt;td&gt;{@code 1.0}&lt;/td&gt; &lt;td&gt;{@code 0x1.0p0}&lt;/td&gt;
                  &lt;tr&gt;&lt;td&gt;{@code -1.0}&lt;/td&gt;        &lt;td&gt;{@code -0x1.0p0}&lt;/td&gt;
                  &lt;tr&gt;&lt;td&gt;{@code 2.0}&lt;/td&gt; &lt;td&gt;{@code 0x1.0p1}&lt;/td&gt;
                  &lt;tr&gt;&lt;td&gt;{@code 3.0}&lt;/td&gt; &lt;td&gt;{@code 0x1.8p1}&lt;/td&gt;
                  &lt;tr&gt;&lt;td&gt;{@code 0.5}&lt;/td&gt; &lt;td&gt;{@code 0x1.0p-1}&lt;/td&gt;
                  &lt;tr&gt;&lt;td&gt;{@code 0.25}&lt;/td&gt;        &lt;td&gt;{@code 0x1.0p-2}&lt;/td&gt;
                  &lt;tr&gt;&lt;td&gt;{@code Float.MAX_VALUE}&lt;/td&gt;
                  &lt;td&gt;{@code 0x1.fffffep127}&lt;/td&gt;
                  &lt;tr&gt;&lt;td&gt;{@code Minimum Normal Value}&lt;/td&gt;
                  &lt;td&gt;{@code 0x1.0p-126}&lt;/td&gt;
                  &lt;tr&gt;&lt;td&gt;{@code Maximum Subnormal Value}&lt;/td&gt;
                  &lt;td&gt;{@code 0x0.fffffep-126}&lt;/td&gt;
                  &lt;tr&gt;&lt;td&gt;{@code Float.MIN_VALUE}&lt;/td&gt;
                  &lt;td&gt;{@code 0x0.000002p-126}&lt;/td&gt;
                  &lt;/table&gt;                
                <param>
                    f   the {@code float} to be converted.                    
                </param>
                <return>
                    a hex string representation of the argument.                    
                </return>
                <since>
                    1.5                    
                </since>
                <author>
                    Joseph D. Darcy                    
                </author>
            </javadoc>
            <method name="toHexString" type="String" line="276">
                <params>
                    <param name="f" type="float"/>
                </params>
                <comment line="278">
                    float subnormal                    
                </comment>
                <comment line="279">
                    Adjust exponent to create subnormal double, then                    
                </comment>
                <comment line="280">
                    replace subnormal double exponent with subnormal float                    
                </comment>
                <comment line="281">
                    exponent                    
                </comment>
                <comment line="283">
                                        
                </comment>
                <comment line="288">
                    double string will be the same as float string                    
                </comment>
                <scope line="278">
                    <declaration name="s" type="String" line="282"/>
                </scope>
            </method>
            <javadoc line="292">
                Returns a {@code Float} object holding the{@code float} value represented by the argument string{@code s}.
                  &lt;p&gt;If {@code s} is {@code null}, then a{@code NullPointerException} is thrown.
                  &lt;p&gt;Leading and trailing whitespace characters in {@code s}are ignored.  Whitespace is removed as if by the {@link String#trim} method; that is, both ASCII space and control
                  characters are removed. The rest of {@code s} should
                  constitute a &lt;i&gt;FloatValue&lt;/i&gt; as described by the lexical
                  syntax rules:
                  &lt;blockquote&gt;
                  &lt;dl&gt;
                  &lt;dt&gt;&lt;i&gt;FloatValue:&lt;/i&gt;
                  &lt;dd&gt;&lt;i&gt;Sign&lt;sub&gt;opt&lt;/sub&gt;&lt;/i&gt; {@code NaN}&lt;dd&gt;&lt;i&gt;Sign&lt;sub&gt;opt&lt;/sub&gt;&lt;/i&gt; {@code Infinity}&lt;dd&gt;&lt;i&gt;Sign&lt;sub&gt;opt&lt;/sub&gt; FloatingPointLiteral&lt;/i&gt;
                  &lt;dd&gt;&lt;i&gt;Sign&lt;sub&gt;opt&lt;/sub&gt; HexFloatingPointLiteral&lt;/i&gt;
                  &lt;dd&gt;&lt;i&gt;SignedInteger&lt;/i&gt;
                  &lt;/dl&gt;
                  &lt;p&gt;
                  &lt;dl&gt;
                  &lt;dt&gt;&lt;i&gt;HexFloatingPointLiteral&lt;/i&gt;:
                  &lt;dd&gt; &lt;i&gt;HexSignificand BinaryExponent FloatTypeSuffix&lt;sub&gt;opt&lt;/sub&gt;&lt;/i&gt;
                  &lt;/dl&gt;
                  &lt;p&gt;
                  &lt;dl&gt;
                  &lt;dt&gt;&lt;i&gt;HexSignificand:&lt;/i&gt;
                  &lt;dd&gt;&lt;i&gt;HexNumeral&lt;/i&gt;
                  &lt;dd&gt;&lt;i&gt;HexNumeral&lt;/i&gt; {@code .}&lt;dd&gt;{@code 0x} &lt;i&gt;HexDigits&lt;sub&gt;opt&lt;/sub&gt;
                  &lt;/i&gt;{@code .}&lt;i&gt; HexDigits&lt;/i&gt;
                  &lt;dd&gt;{@code 0X}&lt;i&gt; HexDigits&lt;sub&gt;opt&lt;/sub&gt;
                  &lt;/i&gt;{@code .} &lt;i&gt;HexDigits&lt;/i&gt;
                  &lt;/dl&gt;
                  &lt;p&gt;
                  &lt;dl&gt;
                  &lt;dt&gt;&lt;i&gt;BinaryExponent:&lt;/i&gt;
                  &lt;dd&gt;&lt;i&gt;BinaryExponentIndicator SignedInteger&lt;/i&gt;
                  &lt;/dl&gt;
                  &lt;p&gt;
                  &lt;dl&gt;
                  &lt;dt&gt;&lt;i&gt;BinaryExponentIndicator:&lt;/i&gt;
                  &lt;dd&gt;{@code p}&lt;dd&gt;{@code P}&lt;/dl&gt;
                  &lt;/blockquote&gt;
                  where &lt;i&gt;Sign&lt;/i&gt;, &lt;i&gt;FloatingPointLiteral&lt;/i&gt;,
                  &lt;i&gt;HexNumeral&lt;/i&gt;, &lt;i&gt;HexDigits&lt;/i&gt;, &lt;i&gt;SignedInteger&lt;/i&gt; and
                  &lt;i&gt;FloatTypeSuffix&lt;/i&gt; are as defined in the lexical structure
                  sections of
                  &lt;cite&gt;The Java&amp;trade; Language Specification&lt;/cite&gt;,
                  except that underscores are not accepted between digits.
                  If {@code s} does not have the form of
                  a &lt;i&gt;FloatValue&lt;/i&gt;, then a {@code NumberFormatException}is thrown. Otherwise, {@code s} is regarded as
                  representing an exact decimal value in the usual
                  &quot;computerized scientific notation&quot; or as an exact
                  hexadecimal value; this exact numerical value is then
                  conceptually converted to an &quot;infinitely precise&quot;
                  binary value that is then rounded to type {@code float}by the usual round-to-nearest rule of IEEE 754 floating-point
                  arithmetic, which includes preserving the sign of a zero
                  value.
                  Note that the round-to-nearest rule also implies overflow and
                  underflow behaviour; if the exact value of {@code s} is large
                  enough in magnitude (greater than or equal to ({@link #MAX_VALUE} + {@link Math#ulp(float) ulp(MAX_VALUE)}/2),
                  rounding to {@code float} will result in an infinity and if the
                  exact value of {@code s} is small enough in magnitude (less
                  than or equal to {@link #MIN_VALUE}/2), rounding to float will
                  result in a zero.
                  Finally, after rounding a {@code Float} object representing
                  this {@code float} value is returned.
                  &lt;p&gt;To interpret localized string representations of a
                  floating-point value, use subclasses of {@link java.text.NumberFormat}.
                  &lt;p&gt;Note that trailing format specifiers, specifiers that
                  determine the type of a floating-point literal
                  ({@code 1.0f} is a {@code float} value;{@code 1.0d} is a {@code double} value), do
                  &lt;em&gt;not&lt;/em&gt; influence the results of this method.  In other
                  words, the numerical value of the input string is converted
                  directly to the target floating-point type.  In general, the
                  two-step sequence of conversions, string to {@code double}followed by {@code double} to {@code float}, is
                  &lt;em&gt;not&lt;/em&gt; equivalent to converting a string directly to{@code float}.  For example, if first converted to an
                  intermediate {@code double} and then to{@code float}, the string&lt;br&gt;{@code &quot;1.00000017881393421514957253748434595763683319091796875001d&quot;}&lt;br&gt;
                  results in the {@code float} value{@code 1.0000002f}; if the string is converted directly to{@code float}, &lt;code&gt;1.000000&lt;b&gt;1&lt;/b&gt;f&lt;/code&gt; results.
                  &lt;p&gt;To avoid calling this method on an invalid string and having
                  a {@code NumberFormatException} be thrown, the documentation
                  for {@link Double#valueOf Double.valueOf} lists a regular
                  expression which can be used to screen the input.                
                <param>
                    s   the string to be parsed.                    
                </param>
                <return>
                    a {@code Float} object holding the value
                      represented by the {@code String} argument.                    
                </return>
                <throws>
                    NumberFormatException  if the string does not contain a
                      parsable number.                    
                </throws>
            </javadoc>
            <method name="valueOf" type="Float" line="416">
                <params>
                    <param name="s" type="String"/>
                </params>
            </method>
            <javadoc line="420">
                Returns a {@code Float} instance representing the specified{@code float} value.
                  If a new {@code Float} instance is not required, this method
                  should generally be used in preference to the constructor{@link #Float(float)}, as this method is likely to yield
                  significantly better space and time performance by caching
                  frequently requested values.                
                <param>
                    f a float value.                    
                </param>
                <return>
                    a {@code Float} instance representing {@code f}.                    
                </return>
                <since>
                    1.5                    
                </since>
            </javadoc>
            <method name="valueOf" type="Float" line="433">
                <params>
                    <param name="f" type="float"/>
                </params>
            </method>
            <javadoc line="437">
                Returns a new {@code float} initialized to the value
                  represented by the specified {@code String}, as performed
                  by the {@code valueOf} method of class {@code Float}.                
                <param>
                    s the string to be parsed.                    
                </param>
                <return>
                    the {@code float} value represented by the string
                      argument.                    
                </return>
                <throws>
                    NullPointerException  if the string is null                    
                </throws>
                <throws>
                    NumberFormatException if the string does not contain a
                      parsable {@code float}.                    
                </throws>
                <see>
                    java.lang.Float#valueOf(String)                    
                </see>
                <since>
                    1.2                    
                </since>
            </javadoc>
            <method name="parseFloat" type="float" line="451">
                <params>
                    <param name="s" type="String"/>
                </params>
            </method>
            <javadoc line="455">
                Returns {@code true} if the specified number is a
                  Not-a-Number (NaN) value, {@code false} otherwise.                
                <param>
                    v   the value to be tested.                    
                </param>
                <return>
                    {@code true} if the argument is NaN;{@code false} otherwise.                    
                </return>
            </javadoc>
            <method name="isNaN" type="boolean" line="463">
                <params>
                    <param name="v" type="float"/>
                </params>
            </method>
            <javadoc line="467">
                Returns {@code true} if the specified number is infinitely
                  large in magnitude, {@code false} otherwise.                
                <param>
                    v   the value to be tested.                    
                </param>
                <return>
                    {@code true} if the argument is positive infinity or
                      negative infinity; {@code false} otherwise.                    
                </return>
            </javadoc>
            <method name="isInfinite" type="boolean" line="475">
                <params>
                    <param name="v" type="float"/>
                </params>
            </method>
            <declaration name="value" type="float" line="479"/>
            <javadoc line="479">
                The value of the Float.                
                <serial>
                                        
                </serial>
            </javadoc>
            <javadoc line="486">
                Constructs a newly allocated {@code Float} object that
                  represents the primitive {@code float} argument.                
                <param>
                    value   the value to be represented by the {@code Float}.                    
                </param>
            </javadoc>
            <method name="Float" type="constructor" line="492">
                <params>
                    <param name="value" type="float"/>
                </params>
            </method>
            <javadoc line="496">
                Constructs a newly allocated {@code Float} object that
                  represents the argument converted to type {@code float}.                
                <param>
                    value   the value to be represented by the {@code Float}.                    
                </param>
            </javadoc>
            <method name="Float" type="constructor" line="502">
                <params>
                    <param name="value" type="double"/>
                </params>
            </method>
            <javadoc line="506">
                Constructs a newly allocated {@code Float} object that
                  represents the floating-point value of type {@code float}represented by the string. The string is converted to a{@code float} value as if by the {@code valueOf} method.                
                <param>
                    s   a string to be converted to a {@code Float}.                    
                </param>
                <throws>
                    NumberFormatException  if the string does not contain a
                      parsable number.                    
                </throws>
                <see>
                    java.lang.Float#valueOf(java.lang.String)                    
                </see>
            </javadoc>
            <method name="Float" type="constructor" line="517">
                <params>
                    <param name="s" type="String"/>
                </params>
                <comment line="518">
                    REMIND: this is inefficient                    
                </comment>
            </method>
            <javadoc line="522">
                Returns {@code true} if this {@code Float} value is a
                  Not-a-Number (NaN), {@code false} otherwise.                
                <return>
                    {@code true} if the value represented by this object is
                      NaN; {@code false} otherwise.                    
                </return>
            </javadoc>
            <method name="isNaN" type="boolean" line="529"/>
            <javadoc line="533">
                Returns {@code true} if this {@code Float} value is
                  infinitely large in magnitude, {@code false} otherwise.                
                <return>
                    {@code true} if the value represented by this object is
                      positive infinity or negative infinity;{@code false} otherwise.                    
                </return>
            </javadoc>
            <method name="isInfinite" type="boolean" line="541"/>
            <javadoc line="545">
                Returns a string representation of this {@code Float} object.
                  The primitive {@code float} value represented by this object
                  is converted to a {@code String} exactly as if by the method{@code toString} of one argument.                
                <return>
                    a {@code String} representation of this object.                    
                </return>
                <see>
                    java.lang.Float#toString(float)                    
                </see>
            </javadoc>
            <method name="toString" type="String" line="554"/>
            <javadoc line="558">
                Returns the value of this {@code Float} as a {@code byte} (by
                  casting to a {@code byte}).                
                <return>
                    the {@code float} value represented by this object
                      converted to type {@code byte}                    
                </return>
            </javadoc>
            <method name="byteValue" type="byte" line="565"/>
            <javadoc line="569">
                Returns the value of this {@code Float} as a {@code short} (by
                  casting to a {@code short}).                
                <return>
                    the {@code float} value represented by this object
                      converted to type {@code short}                    
                </return>
                <since>
                    JDK1.1                    
                </since>
            </javadoc>
            <method name="shortValue" type="short" line="577"/>
            <javadoc line="581">
                Returns the value of this {@code Float} as an {@code int} (by
                  casting to type {@code int}).                
                <return>
                    the {@code float} value represented by this object
                      converted to type {@code int}                    
                </return>
            </javadoc>
            <method name="intValue" type="int" line="588"/>
            <javadoc line="592">
                Returns value of this {@code Float} as a {@code long} (by
                  casting to type {@code long}).                
                <return>
                    the {@code float} value represented by this object
                      converted to type {@code long}                    
                </return>
            </javadoc>
            <method name="longValue" type="long" line="599"/>
            <javadoc line="603">
                Returns the {@code float} value of this {@code Float} object.                
                <return>
                    the {@code float} value represented by this object                    
                </return>
            </javadoc>
            <method name="floatValue" type="float" line="608"/>
            <javadoc line="612">
                Returns the {@code double} value of this {@code Float} object.                
                <return>
                    the {@code float} value represented by this
                      object is converted to type {@code double} and the
                      result of the conversion is returned.                    
                </return>
            </javadoc>
            <method name="doubleValue" type="double" line="619"/>
            <javadoc line="623">
                Returns a hash code for this {@code Float} object. The
                  result is the integer bit representation, exactly as produced
                  by the method {@link #floatToIntBits(float)}, of the primitive{@code float} value represented by this {@code Float}object.                
                <return>
                    a hash code value for this object.                    
                </return>
            </javadoc>
            <method name="hashCode" type="int" line="632"/>
            <javadoc line="636">
                Compares this object against the specified object.  The result
                  is {@code true} if and only if the argument is not{@code null} and is a {@code Float} object that
                  represents a {@code float} with the same value as the{@code float} represented by this object. For this
                  purpose, two {@code float} values are considered to be the
                  same if and only if the method {@link #floatToIntBits(float)}returns the identical {@code int} value when applied to
                  each.
                  &lt;p&gt;Note that in most cases, for two instances of class{@code Float}, {@code f1} and {@code f2}, the value
                  of {@code f1.equals(f2)} is {@code true} if and only if
                  &lt;blockquote&gt;&lt;pre&gt;
                  f1.floatValue() == f2.floatValue()
                  &lt;/pre&gt;&lt;/blockquote&gt;
                  &lt;p&gt;also has the value {@code true}. However, there are two exceptions:
                  &lt;ul&gt;
                  &lt;li&gt;If {@code f1} and {@code f2} both represent{@code Float.NaN}, then the {@code equals} method returns{@code true}, even though {@code Float.NaN==Float.NaN}has the value {@code false}.
                  &lt;li&gt;If {@code f1} represents {@code +0.0f} while{@code f2} represents {@code -0.0f}, or vice
                  versa, the {@code equal} test has the value{@code false}, even though {@code 0.0f==-0.0f}has the value {@code true}.
                  &lt;/ul&gt;
                  This definition allows hash tables to operate properly.                
                <param>
                    obj the object to be compared                    
                </param>
                <return>
                    {@code true} if the objects are the same;{@code false} otherwise.                    
                </return>
                <see>
                    java.lang.Float#floatToIntBits(float)                    
                </see>
            </javadoc>
            <method name="equals" type="boolean" line="676">
                <params>
                    <param name="obj" type="Object"/>
                </params>
            </method>
            <javadoc line="681">
                Returns a representation of the specified floating-point value
                  according to the IEEE 754 floating-point &quot;single format&quot; bit
                  layout.
                  &lt;p&gt;Bit 31 (the bit that is selected by the mask{@code 0x80000000}) represents the sign of the floating-point
                  number.
                  Bits 30-23 (the bits that are selected by the mask{@code 0x7f800000}) represent the exponent.
                  Bits 22-0 (the bits that are selected by the mask{@code 0x007fffff}) represent the significand (sometimes called
                  the mantissa) of the floating-point number.
                  &lt;p&gt;If the argument is positive infinity, the result is{@code 0x7f800000}.
                  &lt;p&gt;If the argument is negative infinity, the result is{@code 0xff800000}.
                  &lt;p&gt;If the argument is NaN, the result is {@code 0x7fc00000}.
                  &lt;p&gt;In all cases, the result is an integer that, when given to the{@link #intBitsToFloat(int)} method, will produce a floating-point
                  value the same as the argument to {@code floatToIntBits}(except all NaN values are collapsed to a single
                  &quot;canonical&quot; NaN value).                
                <param>
                    value   a floating-point number.                    
                </param>
                <return>
                    the bits that represent the floating-point number.                    
                </return>
            </javadoc>
            <method name="floatToIntBits" type="int" line="712">
                <params>
                    <param name="value" type="float"/>
                </params>
                <comment line="714">
                    Check for NaN based on values of bit fields, maximum                    
                </comment>
                <comment line="715">
                    exponent and nonzero significand.                    
                </comment>
                <declaration name="result" type="int" line="713"/>
            </method>
            <method name="floatToRawIntBits" type="int" line="723"/>
            <javadoc line="723">
                Returns a representation of the specified floating-point value
                  according to the IEEE 754 floating-point &quot;single format&quot; bit
                  layout, preserving Not-a-Number (NaN) values.
                  &lt;p&gt;Bit 31 (the bit that is selected by the mask{@code 0x80000000}) represents the sign of the floating-point
                  number.
                  Bits 30-23 (the bits that are selected by the mask{@code 0x7f800000}) represent the exponent.
                  Bits 22-0 (the bits that are selected by the mask{@code 0x007fffff}) represent the significand (sometimes called
                  the mantissa) of the floating-point number.
                  &lt;p&gt;If the argument is positive infinity, the result is{@code 0x7f800000}.
                  &lt;p&gt;If the argument is negative infinity, the result is{@code 0xff800000}.
                  &lt;p&gt;If the argument is NaN, the result is the integer representing
                  the actual NaN value.  Unlike the {@code floatToIntBits}method, {@code floatToRawIntBits} does not collapse all the
                  bit patterns encoding a NaN to a single &quot;canonical&quot;
                  NaN value.
                  &lt;p&gt;In all cases, the result is an integer that, when given to the{@link #intBitsToFloat(int)} method, will produce a
                  floating-point value the same as the argument to{@code floatToRawIntBits}.                
                <param>
                    value   a floating-point number.                    
                </param>
                <return>
                    the bits that represent the floating-point number.                    
                </return>
                <since>
                    1.3                    
                </since>
            </javadoc>
            <method name="intBitsToFloat" type="float" line="760"/>
            <javadoc line="760">
                Returns the {@code float} value corresponding to a given
                  bit representation.
                  The argument is considered to be a representation of a
                  floating-point value according to the IEEE 754 floating-point
                  &quot;single format&quot; bit layout.
                  &lt;p&gt;If the argument is {@code 0x7f800000}, the result is positive
                  infinity.
                  &lt;p&gt;If the argument is {@code 0xff800000}, the result is negative
                  infinity.
                  &lt;p&gt;If the argument is any value in the range{@code 0x7f800001} through {@code 0x7fffffff} or in
                  the range {@code 0xff800001} through{@code 0xffffffff}, the result is a NaN.  No IEEE 754
                  floating-point operation provided by Java can distinguish
                  between two NaN values of the same type with different bit
                  patterns.  Distinct values of NaN are only distinguishable by
                  use of the {@code Float.floatToRawIntBits} method.
                  &lt;p&gt;In all other cases, let &lt;i&gt;s&lt;/i&gt;, &lt;i&gt;e&lt;/i&gt;, and &lt;i&gt;m&lt;/i&gt; be three
                  values that can be computed from the argument:
                  &lt;blockquote&gt;&lt;pre&gt;
                  int s = ((bits &amp;gt;&amp;gt; 31) == 0) ? 1 : -1;
                  int e = ((bits &amp;gt;&amp;gt; 23) &amp; 0xff);
                  int m = (e == 0) ?
                  (bits &amp; 0x7fffff) &amp;lt;&amp;lt; 1 :
                  (bits &amp; 0x7fffff) | 0x800000;
                  &lt;/pre&gt;&lt;/blockquote&gt;
                  Then the floating-point result equals the value of the mathematical
                  expression &lt;i&gt;s&lt;/i&gt;&amp;middot;&lt;i&gt;m&lt;/i&gt;&amp;middot;2&lt;sup&gt;&lt;i&gt;e&lt;/i&gt;-150&lt;/sup&gt;.
                  &lt;p&gt;Note that this method may not be able to return a{@code float} NaN with exactly same bit pattern as the{@code int} argument.  IEEE 754 distinguishes between two
                  kinds of NaNs, quiet NaNs and &lt;i&gt;signaling NaNs&lt;/i&gt;.  The
                  differences between the two kinds of NaN are generally not
                  visible in Java.  Arithmetic operations on signaling NaNs turn
                  them into quiet NaNs with a different, but often similar, bit
                  pattern.  However, on some processors merely copying a
                  signaling NaN also performs that conversion.  In particular,
                  copying a signaling NaN to return it to the calling method may
                  perform this conversion.  So {@code intBitsToFloat} may
                  not be able to return a {@code float} with a signaling NaN
                  bit pattern.  Consequently, for some {@code int} values,{@code floatToRawIntBits(intBitsToFloat(start))} may
                  &lt;i&gt;not&lt;/i&gt; equal {@code start}.  Moreover, which
                  particular bit patterns represent signaling NaNs is platform
                  dependent; although all NaN bit patterns, quiet or signaling,
                  must be in the NaN range identified above.                
                <param>
                    bits   an integer.                    
                </param>
                <return>
                    the {@code float} floating-point value with the same bit
                      pattern.                    
                </return>
            </javadoc>
            <javadoc line="821">
                Compares two {@code Float} objects numerically.  There are
                  two ways in which comparisons performed by this method differ
                  from those performed by the Java language numerical comparison
                  operators ({@code &lt;, &lt;=, ==, &gt;=, &gt;}) when
                  applied to primitive {@code float} values:
                  &lt;ul&gt;&lt;li&gt;{@code Float.NaN} is considered by this method to
                  be equal to itself and greater than all other{@code float} values
                  (including {@code Float.POSITIVE_INFINITY}).
                  &lt;li&gt;{@code 0.0f} is considered by this method to be greater
                  than {@code -0.0f}.
                  &lt;/ul&gt;
                  This ensures that the &lt;i&gt;natural ordering&lt;/i&gt; of {@code Float}objects imposed by this method is &lt;i&gt;consistent with equals&lt;/i&gt;.                
                <param>
                    anotherFloat   the {@code Float} to be compared.                    
                </param>
                <return>
                    the value {@code 0} if {@code anotherFloat} is
                      numerically equal to this {@code Float}; a value
                      less than {@code 0} if this {@code Float}is numerically less than {@code anotherFloat};
                      and a value greater than {@code 0} if this{@code Float} is numerically greater than{@code anotherFloat}.                    
                </return>
                <since>
                    1.2                    
                </since>
                <see>
                    Comparable#compareTo(Object)                    
                </see>
            </javadoc>
            <method name="compareTo" type="int" line="853">
                <params>
                    <param name="anotherFloat" type="Float"/>
                </params>
            </method>
            <javadoc line="857">
                Compares the two specified {@code float} values. The sign
                  of the integer value returned is the same as that of the
                  integer that would be returned by the call:
                  &lt;pre&gt;
                  new Float(f1).compareTo(new Float(f2))
                  &lt;/pre&gt;                
                <param>
                    f1        the first {@code float} to compare.                    
                </param>
                <param>
                    f2        the second {@code float} to compare.                    
                </param>
                <return>
                    the value {@code 0} if {@code f1} is
                      numerically equal to {@code f2}; a value less than{@code 0} if {@code f1} is numerically less than{@code f2}; and a value greater than {@code 0}if {@code f1} is numerically greater than{@code f2}.                    
                </return>
                <since>
                    1.4                    
                </since>
            </javadoc>
            <method name="compare" type="int" line="875">
                <params>
                    <param name="f1" type="float"/>
                    <param name="f2" type="float"/>
                </params>
                <comment line="877">
                    Neither val is NaN, thisVal is smaller                    
                </comment>
                <comment line="879">
                    Neither val is NaN, thisVal is larger                    
                </comment>
                <comment line="881">
                    Cannot use floatToRawIntBits because of possibility of NaNs.                    
                </comment>
                <comment line="885">
                    Values are equal                    
                </comment>
                <comment line="886">
                    (-0.0, 0.0) or (!NaN, NaN)                    
                </comment>
                <comment line="887">
                    (0.0, -0.0) or (NaN, !NaN)                    
                </comment>
                <declaration name="thisBits" type="int" line="882"/>
                <declaration name="anotherBits" type="int" line="883"/>
            </method>
            <declaration name="serialVersionUID" type="long" line="890"/>
            <javadoc line="890">
                use serialVersionUID from JDK 1.0.2 for interoperability                
            </javadoc>
        </class>
    </source>