<?xml version="1.0" encoding="UTF-8"?>
    <source package="java.lang.reflect">
        <import package="sun.reflect.MethodAccessor"/>
        <import package="sun.reflect.Reflection"/>
        <import package="sun.reflect.generics.repository.MethodRepository"/>
        <import package="sun.reflect.generics.factory.CoreReflectionFactory"/>
        <import package="sun.reflect.generics.factory.GenericsFactory"/>
        <import package="sun.reflect.generics.scope.MethodScope"/>
        <import package="sun.reflect.annotation.AnnotationType"/>
        <import package="sun.reflect.annotation.AnnotationParser"/>
        <import package="java.lang.annotation.Annotation"/>
        <import package="java.lang.annotation.AnnotationFormatError"/>
        <import package="java.nio.ByteBuffer"/>
        <import package="java.util.Map"/>
        <class name="Method" line="41">
            <extends class="AccessibleObject"/>
            <comment line="67">
                This is guaranteed to be interned by the VM in the 1.4
                 reflection implementation                
            </comment>
            <comment line="74">
                Generics and annotations support                
            </comment>
            <comment line="76">
                generic info repository; lazily initialized                
            </comment>
            <comment line="82">
                For sharing of MethodAccessors. This branching structure is
                 currently only two levels deep (i.e., one root Method and
                 potentially many Method objects pointing to it.)                
            </comment>
            <comment line="87">
                Generics infrastructure                
            </comment>
            <comment line="91">
                Accessor for factory                
            </comment>
            <comment line="97">
                Accessor for generic info repository                
            </comment>
            <comment line="642">
                NOTE that there is no synchronization used here. It is correct
                 (though not efficient) to generate more than one MethodAccessor
                 for a given Method. However, avoiding synchronization will
                 probably make the implementation more scalable.                
            </comment>
            <comment line="662">
                Returns MethodAccessor for this Method object, not looking up
                 the chain to the root                
            </comment>
            <comment line="668">
                Sets the MethodAccessor for this Method object and
                 (recursively) its root                
            </comment>
            <implements interface="GenericDeclaration"/>
            <implements interface="Member"/>
            <javadoc line="41">
                A {@code Method} provides information about, and access to, a single method
                  on a class or interface.  The reflected method may be a class method
                  or an instance method (including an abstract method).
                  &lt;p&gt;A {@code Method} permits widening conversions to occur when matching the
                  actual parameters to invoke with the underlying method&apos;s formal
                  parameters, but it throws an {@code IllegalArgumentException} if a
                  narrowing conversion would occur.                
                <see>
                    Member                    
                </see>
                <see>
                    java.lang.Class                    
                </see>
                <see>
                    java.lang.Class#getMethods()                    
                </see>
                <see>
                    java.lang.Class#getMethod(String,Class[])                    
                </see>
                <see>
                    java.lang.Class#getDeclaredMethods()                    
                </see>
                <see>
                    java.lang.Class#getDeclaredMethod(String,Class[])                    
                </see>
                <author>
                    Kenneth Russell                    
                </author>
                <author>
                    Nakul Saraiya                    
                </author>
            </javadoc>
            <declaration name="clazz" type="Class&lt;?&gt;" line="64"/>
            <declaration name="slot" type="int" line="65"/>
            <declaration name="name" type="String" line="68"/>
            <declaration name="returnType" type="Class&lt;?&gt;" line="69"/>
            <declaration name="parameterTypes" type="Class&lt;?&gt;[]" line="70"/>
            <declaration name="exceptionTypes" type="Class&lt;?&gt;[]" line="71"/>
            <declaration name="modifiers" type="int" line="72"/>
            <declaration name="signature" type="String" line="74"/>
            <declaration name="genericInfo" type="MethodRepository" line="76"/>
            <declaration name="annotations" type="byte[]" line="77"/>
            <declaration name="parameterAnnotations" type="byte[]" line="78"/>
            <declaration name="annotationDefault" type="byte[]" line="79"/>
            <declaration name="methodAccessor" type="MethodAccessor" line="80"/>
            <declaration name="root" type="Method" line="84"/>
            <method name="getGenericSignature" type="String" line="88"/>
            <method name="getFactory" type="GenericsFactory" line="91">
                <comment line="93">
                    create scope and factory                    
                </comment>
            </method>
            <method name="getGenericInfo" type="MethodRepository" line="97">
                <comment line="99">
                    lazily initialize repository if necessary                    
                </comment>
                <comment line="101">
                    create and cache generic info repository                    
                </comment>
                <comment line="105">
                    return cached repository                    
                </comment>
                <scope line="99"/>
            </method>
            <javadoc line="107">
                Package-private constructor used by ReflectAccess to enable
                  instantiation of these objects in Java code from the java.lang
                  package via sun.reflect.LangReflectAccess.                
            </javadoc>
            <method name="Method" type="constructor" line="123">
                <params>
                    <param name="declaringClass" type="Class<?>"/>
                    <param name="name" type="String"/>
                    <param name="parameterTypes" type="Class<?>[]"/>
                    <param name="returnType" type="Class<?>"/>
                    <param name="checkedExceptions" type="Class<?>[]"/>
                    <param name="modifiers" type="int"/>
                    <param name="slot" type="int"/>
                    <param name="signature" type="String"/>
                    <param name="annotations" type="byte[]"/>
                    <param name="parameterAnnotations" type="byte[]"/>
                    <param name="annotationDefault" type="byte[]"/>
                </params>
            </method>
            <javadoc line="137">
                Package-private routine (exposed to java.lang.Class via
                  ReflectAccess) which returns a copy of this Method. The copy&apos;s
                  &quot;root&quot; field points to this Method.                
            </javadoc>
            <method name="copy" type="Method" line="142">
                <comment line="144">
                    This routine enables sharing of MethodAccessor objects
                     among Method objects which refer to the same underlying
                     method in the VM. (All of this contortion is only necessary
                     because of the &quot;accessibility&quot; bit in AccessibleObject,
                     which implicitly requires that new java.lang.reflect
                     objects be fabricated for each reflective call on Class
                     objects.)                    
                </comment>
                <comment line="155">
                    Might as well eagerly propagate this if already present                    
                </comment>
                <declaration name="res" type="Method" line="150"/>
            </method>
            <javadoc line="159">
                Returns the {@code Class} object representing the class or interface
                  that declares the method represented by this {@code Method} object.                
            </javadoc>
            <method name="getDeclaringClass" type="Class<?>" line="163"/>
            <javadoc line="167">
                Returns the name of the method represented by this {@code Method}object, as a {@code String}.                
            </javadoc>
            <method name="getName" type="String" line="171"/>
            <javadoc line="175">
                Returns the Java language modifiers for the method represented
                  by this {@code Method} object, as an integer. The {@code Modifier} class should
                  be used to decode the modifiers.                
                <see>
                    Modifier                    
                </see>
            </javadoc>
            <method name="getModifiers" type="int" line="182"/>
            <javadoc line="186">
                Returns an array of {@code TypeVariable} objects that represent the
                  type variables declared by the generic declaration represented by this{@code GenericDeclaration} object, in declaration order.  Returns an
                  array of length 0 if the underlying generic declaration declares no type
                  variables.                
                <return>
                    an array of {@code TypeVariable} objects that represent
                      the type variables declared by this generic declaration                    
                </return>
                <throws>
                    GenericSignatureFormatError if the generic
                      signature of this generic declaration does not conform to
                      the format specified in
                      &lt;cite&gt;The Java&amp;trade; Virtual Machine Specification&lt;/cite&gt;                    
                </throws>
                <since>
                    1.5                    
                </since>
            </javadoc>
            <method name="getTypeParameters" type="TypeVariable<Method>[]" line="201"/>
            <javadoc line="208">
                Returns a {@code Class} object that represents the formal return type
                  of the method represented by this {@code Method} object.                
                <return>
                    the return type for the method this object represents                    
                </return>
            </javadoc>
            <method name="getReturnType" type="Class<?>" line="214"/>
            <javadoc line="218">
                Returns a {@code Type} object that represents the formal return
                  type of the method represented by this {@code Method} object.
                  &lt;p&gt;If the return type is a parameterized type,
                  the {@code Type} object returned must accurately reflect
                  the actual type parameters used in the source code.
                  &lt;p&gt;If the return type is a type variable or a parameterized type, it
                  is created. Otherwise, it is resolved.                
                <return>
                    a {@code Type} object that represents the formal return
                      type of the underlying  method                    
                </return>
                <throws>
                    GenericSignatureFormatErrorif the generic method signature does not conform to the format
                      specified in
                      &lt;cite&gt;The Java&amp;trade; Virtual Machine Specification&lt;/cite&gt;                    
                </throws>
                <throws>
                    TypeNotPresentException if the underlying method&apos;s
                      return type refers to a non-existent type declaration                    
                </throws>
                <throws>
                    MalformedParameterizedTypeException if the
                      underlying method&apos;s return typed refers to a parameterized
                      type that cannot be instantiated for any reason                    
                </throws>
                <since>
                    1.5                    
                </since>
            </javadoc>
            <method name="getGenericReturnType" type="Type" line="242">
                <scope line="243"/>
                <scope line="245"/>
            </method>
            <javadoc line="249">
                Returns an array of {@code Class} objects that represent the formal
                  parameter types, in declaration order, of the method
                  represented by this {@code Method} object.  Returns an array of length
                  0 if the underlying method takes no parameters.                
                <return>
                    the parameter types for the method this object
                      represents                    
                </return>
            </javadoc>
            <method name="getParameterTypes" type="Class<?>[]" line="258"/>
            <javadoc line="262">
                Returns an array of {@code Type} objects that represent the formal
                  parameter types, in declaration order, of the method represented by
                  this {@code Method} object. Returns an array of length 0 if the
                  underlying method takes no parameters.
                  &lt;p&gt;If a formal parameter type is a parameterized type,
                  the {@code Type} object returned for it must accurately reflect
                  the actual type parameters used in the source code.
                  &lt;p&gt;If a formal parameter type is a type variable or a parameterized
                  type, it is created. Otherwise, it is resolved.                
                <return>
                    an array of Types that represent the formal
                      parameter types of the underlying method, in declaration order                    
                </return>
                <throws>
                    GenericSignatureFormatErrorif the generic method signature does not conform to the format
                      specified in
                      &lt;cite&gt;The Java&amp;trade; Virtual Machine Specification&lt;/cite&gt;                    
                </throws>
                <throws>
                    TypeNotPresentException if any of the parameter
                      types of the underlying method refers to a non-existent type
                      declaration                    
                </throws>
                <throws>
                    MalformedParameterizedTypeException if any of
                      the underlying method&apos;s parameter types refer to a parameterized
                      type that cannot be instantiated for any reason                    
                </throws>
                <since>
                    1.5                    
                </since>
            </javadoc>
            <method name="getGenericParameterTypes" type="Type[]" line="289"/>
            <javadoc line="297">
                Returns an array of {@code Class} objects that represent
                  the types of the exceptions declared to be thrown
                  by the underlying method
                  represented by this {@code Method} object.  Returns an array of length
                  0 if the method declares no exceptions in its {@code throws} clause.                
                <return>
                    the exception types declared as being thrown by the
                      method this object represents                    
                </return>
            </javadoc>
            <method name="getExceptionTypes" type="Class<?>[]" line="307"/>
            <javadoc line="311">
                Returns an array of {@code Type} objects that represent the
                  exceptions declared to be thrown by this {@code Method} object.
                  Returns an array of length 0 if the underlying method declares
                  no exceptions in its {@code throws} clause.
                  &lt;p&gt;If an exception type is a type variable or a parameterized
                  type, it is created. Otherwise, it is resolved.                
                <return>
                    an array of Types that represent the exception types
                      thrown by the underlying method                    
                </return>
                <throws>
                    GenericSignatureFormatErrorif the generic method signature does not conform to the format
                      specified in
                      &lt;cite&gt;The Java&amp;trade; Virtual Machine Specification&lt;/cite&gt;                    
                </throws>
                <throws>
                    TypeNotPresentException if the underlying method&apos;s{@code throws} clause refers to a non-existent type declaration                    
                </throws>
                <throws>
                    MalformedParameterizedTypeException if
                      the underlying method&apos;s {@code throws} clause refers to a
                      parameterized type that cannot be instantiated for any reason                    
                </throws>
                <since>
                    1.5                    
                </since>
            </javadoc>
            <method name="getGenericExceptionTypes" type="Type[]" line="333">
                <declaration name="result" type="Type[]" line="334"/>
            </method>
            <javadoc line="342">
                Compares this {@code Method} against the specified object.  Returns
                  true if the objects are the same.  Two {@code Methods} are the same if
                  they were declared by the same class and have the same name
                  and formal parameter types and return type.                
            </javadoc>
            <method name="equals" type="boolean" line="348">
                <params>
                    <param name="obj" type="Object"/>
                </params>
                <comment line="356">
                                        
                </comment>
                <scope line="349">
                    <declaration name="other" type="Method" line="350"/>
                    <scope line="352">
                        <declaration name="params1" type="Class&lt;?&gt;[]" line="356"/>
                        <declaration name="params2" type="Class&lt;?&gt;[]" line="357"/>
                        <scope line="358">
                            <scope line="359"/>
                        </scope>
                    </scope>
                </scope>
            </method>
            <javadoc line="370">
                Returns a hashcode for this {@code Method}.  The hashcode is computed
                  as the exclusive-or of the hashcodes for the underlying
                  method&apos;s declaring class name and the method&apos;s name.                
            </javadoc>
            <method name="hashCode" type="int" line="375"/>
            <javadoc line="379">
                Returns a string describing this {@code Method}.  The string is
                  formatted as the method access modifiers, if any, followed by
                  the method return type, followed by a space, followed by the
                  class declaring the method, followed by a period, followed by
                  the method name, followed by a parenthesized, comma-separated
                  list of the method&apos;s formal parameter types. If the method
                  throws checked exceptions, the parameter list is followed by a
                  space, followed by the word throws followed by a
                  comma-separated list of the thrown exception types.
                  For example:
                  &lt;pre&gt;
                  public boolean java.lang.Object.equals(java.lang.Object)
                  &lt;/pre&gt;
                  &lt;p&gt;The access modifiers are placed in canonical order as
                  specified by &quot;The Java Language Specification&quot;.  This is{@code public}, {@code protected} or {@code private} first,
                  and then other modifiers in the following order:{@code abstract}, {@code static}, {@code final},{@code synchronized}, {@code native}, {@code strictfp}.                
            </javadoc>
            <method name="toString" type="String" line="401">
                <comment line="412">
                    avoid clone                    
                </comment>
                <comment line="419">
                    avoid clone                    
                </comment>
                <scope line="402">
                    <declaration name="sb" type="StringBuilder" line="403"/>
                    <declaration name="mod" type="int" line="404"/>
                    <scope line="405"/>
                    <declaration name="params" type="Class&lt;?&gt;[]" line="411"/>
                    <scope line="412"/>
                    <declaration name="exceptions" type="Class&lt;?&gt;[]" line="418"/>
                    <scope line="419">
                        <scope line="421"/>
                    </scope>
                </scope>
                <scope line="428"/>
            </method>
            <javadoc line="433">
                Returns a string describing this {@code Method}, including
                  type parameters.  The string is formatted as the method access
                  modifiers, if any, followed by an angle-bracketed
                  comma-separated list of the method&apos;s type parameters, if any,
                  followed by the method&apos;s generic return type, followed by a
                  space, followed by the class declaring the method, followed by
                  a period, followed by the method name, followed by a
                  parenthesized, comma-separated list of the method&apos;s generic
                  formal parameter types.
                  If this method was declared to take a variable number of
                  arguments, instead of denoting the last parameter as
                  &quot;&lt;tt&gt;&lt;i&gt;Type&lt;/i&gt;[]&lt;/tt&gt;&quot;, it is denoted as
                  &quot;&lt;tt&gt;&lt;i&gt;Type&lt;/i&gt;...&lt;/tt&gt;&quot;.
                  A space is used to separate access modifiers from one another
                  and from the type parameters or return type.  If there are no
                  type parameters, the type parameter list is elided; if the type
                  parameter list is present, a space separates the list from the
                  class name.  If the method is declared to throw exceptions, the
                  parameter list is followed by a space, followed by the word
                  throws followed by a comma-separated list of the generic thrown
                  exception types.  If there are no type parameters, the type
                  parameter list is elided.
                  &lt;p&gt;The access modifiers are placed in canonical order as
                  specified by &quot;The Java Language Specification&quot;.  This is{@code public}, {@code protected} or {@code private} first,
                  and then other modifiers in the following order:{@code abstract}, {@code static}, {@code final},{@code synchronized}, {@code native}, {@code strictfp}.                
                <return>
                    a string describing this {@code Method},
                      include type parameters                    
                </return>
                <since>
                    1.5                    
                </since>
            </javadoc>
            <method name="toGenericString" type="String" line="471">
                <comment line="486">
                    Class objects can&apos;t occur here; no need to test
                     and call Class.getName().                    
                </comment>
                <comment line="506">
                    replace T[] with T...                    
                </comment>
                <scope line="472">
                    <declaration name="sb" type="StringBuilder" line="473"/>
                    <declaration name="mod" type="int" line="474"/>
                    <scope line="475"/>
                    <declaration name="typeparms" type="TypeVariable&lt;?&gt;[]" line="478"/>
                    <scope line="479">
                        <declaration name="first" type="boolean" line="480"/>
                        <scope line="482"/>
                    </scope>
                    <declaration name="genRetType" type="Type" line="493"/>
                    <declaration name="params" type="Type[]" line="500"/>
                    <scope line="501">
                        <declaration name="param" type="String" line="502"/>
                    </scope>
                    <declaration name="exceptions" type="Type[]" line="512"/>
                    <scope line="513">
                        <scope line="515"/>
                    </scope>
                </scope>
                <scope line="524"/>
            </method>
            <javadoc line="529">
                Invokes the underlying method represented by this {@code Method}object, on the specified object with the specified parameters.
                  Individual parameters are automatically unwrapped to match
                  primitive formal parameters, and both primitive and reference
                  parameters are subject to method invocation conversions as
                  necessary.
                  &lt;p&gt;If the underlying method is static, then the specified {@code obj}argument is ignored. It may be null.
                  &lt;p&gt;If the number of formal parameters required by the underlying method is
                  0, the supplied {@code args} array may be of length 0 or null.
                  &lt;p&gt;If the underlying method is an instance method, it is invoked
                  using dynamic method lookup as documented in The Java Language
                  Specification, Second Edition, section 15.12.4.4; in particular,
                  overriding based on the runtime type of the target object will occur.
                  &lt;p&gt;If the underlying method is static, the class that declared
                  the method is initialized if it has not already been initialized.
                  &lt;p&gt;If the method completes normally, the value it returns is
                  returned to the caller of invoke; if the value has a primitive
                  type, it is first appropriately wrapped in an object. However,
                  if the value has the type of an array of a primitive type, the
                  elements of the array are &lt;i&gt;not&lt;/i&gt; wrapped in objects; in
                  other words, an array of primitive type is returned.  If the
                  underlying method return type is void, the invocation returns
                  null.                
                <param>
                    obj  the object the underlying method is invoked from                    
                </param>
                <param>
                    args the arguments used for the method call                    
                </param>
                <return>
                    the result of dispatching the method represented by
                      this object on {@code obj} with parameters{@code args}                    
                </return>
                <exception>
                    IllegalAccessException    if this {@code Method} object
                      is enforcing Java language access control and the underlying
                      method is inaccessible.                    
                </exception>
                <exception>
                    IllegalArgumentException  if the method is an
                      instance method and the specified object argument
                      is not an instance of the class or interface
                      declaring the underlying method (or of a subclass
                      or implementor thereof); if the number of actual
                      and formal parameters differ; if an unwrapping
                      conversion for primitive arguments fails; or if,
                      after possible unwrapping, a parameter value
                      cannot be converted to the corresponding formal
                      parameter type by a method invocation conversion.                    
                </exception>
                <exception>
                    InvocationTargetException if the underlying method
                      throws an exception.                    
                </exception>
                <exception>
                    NullPointerException      if the specified object is null
                      and the method is an instance method.                    
                </exception>
                <exception>
                    ExceptionInInitializerError if the initialization
                      provoked by this method fails.                    
                </exception>
            </javadoc>
            <method name="invoke" type="Object" line="589">
                <params>
                    <param name="obj" type="Object"/>
                    <param name="args" type="Object"/>
                </params>
                <comment line="598">
                    read volatile                    
                </comment>
                <scope line="590">
                    <scope line="591">
                        <declaration name="caller" type="Class&lt;?&gt;" line="592"/>
                    </scope>
                </scope>
                <declaration name="ma" type="MethodAccessor" line="597"/>
                <scope line="598"/>
            </method>
            <javadoc line="604">
                Returns {@code true} if this method is a bridge
                  method; returns {@code false} otherwise.                
                <return>
                    true if and only if this method is a bridge
                      method as defined by the Java Language Specification.                    
                </return>
                <since>
                    1.5                    
                </since>
            </javadoc>
            <method name="isBridge" type="boolean" line="612"/>
            <javadoc line="616">
                Returns {@code true} if this method was declared to take
                  a variable number of arguments; returns {@code false}otherwise.                
                <return>
                    {@code true} if an only if this method was declared to
                      take a variable number of arguments.                    
                </return>
                <since>
                    1.5                    
                </since>
            </javadoc>
            <method name="isVarArgs" type="boolean" line="625"/>
            <javadoc line="629">
                Returns {@code true} if this method is a synthetic
                  method; returns {@code false} otherwise.                
                <return>
                    true if and only if this method is a synthetic
                      method as defined by the Java Language Specification.                    
                </return>
                <since>
                    1.5                    
                </since>
            </javadoc>
            <method name="isSynthetic" type="boolean" line="637"/>
            <method name="acquireMethodAccessor" type="MethodAccessor" line="645">
                <comment line="647">
                    First check to see if one has been created yet, and take it
                     if so                    
                </comment>
                <comment line="654">
                    Otherwise fabricate one and propagate it up to the root                    
                </comment>
                <declaration name="tmp" type="MethodAccessor" line="648"/>
                <scope line="650"/>
                <scope line="652"/>
            </method>
            <method name="getMethodAccessor" type="MethodAccessor" line="663"/>
            <method name="setMethodAccessor" type="void" line="669">
                <params>
                    <param name="accessor" type="MethodAccessor"/>
                </params>
                <comment line="672">
                    Propagate up                    
                </comment>
                <scope line="672"/>
            </method>
            <javadoc line="677">
                @throws NullPointerException {@inheritDoc}                
                <since>
                    1.5                    
                </since>
            </javadoc>
            <method name="getAnnotation" type="T" line="681">
                <params>
                    <param name="annotationClass" type="Class<T>"/>
                </params>
            </method>
            <javadoc line="688">
                @since 1.5                
            </javadoc>
            <method name="getDeclaredAnnotations" type="Annotation[]" line="691"/>
            <declaration name="declaredAnnotations" type="Map&lt;Class&lt;? extends Annotation&gt;,Annotation&gt;" line="695"/>
            <method name="declaredAnnotations" type="Map<Class<? extends Annotation>,Annotation>" line="697">
                <scope line="698"/>
            </method>
            <javadoc line="707">
                Returns the default value for the annotation member represented by
                  this {@code Method} instance.  If the member is of a primitive type,
                  an instance of the corresponding wrapper type is returned. Returns
                  null if no default is associated with the member, or if the method
                  instance does not represent a declared member of an annotation type.                
                <return>
                    the default value for the annotation member represented
                      by this {@code Method} instance.                    
                </return>
                <throws>
                    TypeNotPresentException if the annotation is of type{@link Class} and no definition can be found for the
                      default class value.                    
                </throws>
                <since>
                    1.5                    
                </since>
            </javadoc>
            <method name="getDefaultValue" type="Object" line="721">
                <declaration name="memberType" type="Class&lt;?&gt;" line="724"/>
                <declaration name="result" type="Object" line="726"/>
            </method>
            <javadoc line="736">
                Returns an array of arrays that represent the annotations on the formal
                  parameters, in declaration order, of the method represented by
                  this {@code Method} object. (Returns an array of length zero if the
                  underlying method is parameterless.  If the method has one or more
                  parameters, a nested array of length zero is returned for each parameter
                  with no annotations.) The annotation objects contained in the returned
                  arrays are serializable.  The caller of this method is free to modify
                  the returned arrays; it will have no effect on the arrays returned to
                  other callers.                
                <return>
                    an array of arrays that represent the annotations on the formal
                      parameters, in declaration order, of the method represented by this
                      Method object                    
                </return>
                <since>
                    1.5                    
                </since>
            </javadoc>
            <method name="getParameterAnnotations" type="Annotation[][]" line="752">
                <declaration name="numParameters" type="int" line="753"/>
                <declaration name="result" type="Annotation[][]" line="757"/>
            </method>
        </class>
    </source>