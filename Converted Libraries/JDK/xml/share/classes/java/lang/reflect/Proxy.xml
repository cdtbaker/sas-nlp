<?xml version="1.0" encoding="UTF-8"?>
    <source package="java.lang.reflect">
        <import package="java.lang.ref.Reference"/>
        <import package="java.lang.ref.WeakReference"/>
        <import package="java.util.Arrays"/>
        <import package="java.util.Collections"/>
        <import package="java.util.HashMap"/>
        <import package="java.util.HashSet"/>
        <import package="java.util.Map"/>
        <import package="java.util.Set"/>
        <import package="java.util.List"/>
        <import package="java.util.WeakHashMap"/>
        <import package="sun.misc.ProxyGenerator"/>
        <class name="Proxy" line="13">
            <implements interface="java.io.Serializable"/>
            <javadoc line="13">
                {@code Proxy} provides static methods for creating dynamic proxy
                  classes and instances, and it is also the superclass of all
                  dynamic proxy classes created by those methods.
                  &lt;p&gt;To create a proxy for some interface {@code Foo}:
                  &lt;pre&gt;
                  InvocationHandler handler = new MyInvocationHandler(...);
                  Class proxyClass = Proxy.getProxyClass(
                  Foo.class.getClassLoader(), new Class[] { Foo.class });
                  Foo f = (Foo) proxyClass.
                  getConstructor(new Class[] { InvocationHandler.class }).
                  newInstance(new Object[] { handler });
                  &lt;/pre&gt;
                  or more simply:
                  &lt;pre&gt;
                  Foo f = (Foo) Proxy.newProxyInstance(Foo.class.getClassLoader(),
                  new Class[] { Foo.class },
                  handler);
                  &lt;/pre&gt;
                  &lt;p&gt;A &lt;i&gt;dynamic proxy class&lt;/i&gt; (simply referred to as a &lt;i&gt;proxy
                  class&lt;/i&gt; below) is a class that implements a list of interfaces
                  specified at runtime when the class is created, with behavior as
                  described below.
                  A &lt;i&gt;proxy interface&lt;/i&gt; is such an interface that is implemented
                  by a proxy class.
                  A &lt;i&gt;proxy instance&lt;/i&gt; is an instance of a proxy class.
                  Each proxy instance has an associated &lt;i&gt;invocation handler&lt;/i&gt;
                  object, which implements the interface {@link InvocationHandler}.
                  A method invocation on a proxy instance through one of its proxy
                  interfaces will be dispatched to the {@link InvocationHandler#invokeinvoke} method of the instance&apos;s invocation handler, passing the proxy
                  instance, a {@code java.lang.reflect.Method} object identifying
                  the method that was invoked, and an array of type {@code Object}containing the arguments.  The invocation handler processes the
                  encoded method invocation as appropriate and the result that it
                  returns will be returned as the result of the method invocation on
                  the proxy instance.
                  &lt;p&gt;A proxy class has the following properties:
                  &lt;ul&gt;
                  &lt;li&gt;Proxy classes are public, final, and not abstract.
                  &lt;li&gt;The unqualified name of a proxy class is unspecified.  The space
                  of class names that begin with the string {@code &quot;$Proxy&quot;}should be, however, reserved for proxy classes.
                  &lt;li&gt;A proxy class extends {@code java.lang.reflect.Proxy}.
                  &lt;li&gt;A proxy class implements exactly the interfaces specified at its
                  creation, in the same order.
                  &lt;li&gt;If a proxy class implements a non-public interface, then it will
                  be defined in the same package as that interface.  Otherwise, the
                  package of a proxy class is also unspecified.  Note that package
                  sealing will not prevent a proxy class from being successfully defined
                  in a particular package at runtime, and neither will classes already
                  defined by the same class loader and the same package with particular
                  signers.
                  &lt;li&gt;Since a proxy class implements all of the interfaces specified at
                  its creation, invoking {@code getInterfaces} on its{@code Class} object will return an array containing the same
                  list of interfaces (in the order specified at its creation), invoking{@code getMethods} on its {@code Class} object will return
                  an array of {@code Method} objects that include all of the
                  methods in those interfaces, and invoking {@code getMethod} will
                  find methods in the proxy interfaces as would be expected.
                  &lt;li&gt;The {@link Proxy#isProxyClass Proxy.isProxyClass} method will
                  return true if it is passed a proxy class-- a class returned by{@code Proxy.getProxyClass} or the class of an object returned by{@code Proxy.newProxyInstance}-- and false otherwise.
                  &lt;li&gt;The {@code java.security.ProtectionDomain} of a proxy class
                  is the same as that of system classes loaded by the bootstrap class
                  loader, such as {@code java.lang.Object}, because the code for a
                  proxy class is generated by trusted system code.  This protection
                  domain will typically be granted{@code java.security.AllPermission}.
                  &lt;li&gt;Each proxy class has one public constructor that takes one argument,
                  an implementation of the interface {@link InvocationHandler}, to set
                  the invocation handler for a proxy instance.  Rather than having to use
                  the reflection API to access the public constructor, a proxy instance
                  can be also be created by calling the {@link Proxy#newProxyInstanceProxy} method, which combines the actions of calling{@link Proxy#getProxyClass Proxy.getProxyClass} with invoking the
                  constructor with an invocation handler.
                  &lt;/ul&gt;
                  &lt;p&gt;A proxy instance has the following properties:
                  &lt;ul&gt;
                  &lt;li&gt;Given a proxy instance {@code proxy} and one of the
                  interfaces implemented by its proxy class {@code Foo}, the
                  following expression will return true:
                  &lt;pre&gt;{@code proxy instanceof Foo}&lt;/pre&gt;
                  and the following cast operation will succeed (rather than throwing
                  a {@code ClassCastException}):
                  &lt;pre&gt;{@code (Foo) proxy}&lt;/pre&gt;
                  &lt;li&gt;Each proxy instance has an associated invocation handler, the one
                  that was passed to its constructor.  The static{@link Proxy#getInvocationHandler Proxy.getInvocationHandler} method
                  will return the invocation handler associated with the proxy instance
                  passed as its argument.
                  &lt;li&gt;An interface method invocation on a proxy instance will be
                  encoded and dispatched to the invocation handler&apos;s {@link InvocationHandler#invoke invoke} method as described in the
                  documentation for that method.
                  &lt;li&gt;An invocation of the {@code hashCode},{@code equals}, or {@code toString} methods declared in{@code java.lang.Object} on a proxy instance will be encoded and
                  dispatched to the invocation handler&apos;s {@code invoke} method in
                  the same manner as interface method invocations are encoded and
                  dispatched, as described above.  The declaring class of the{@code Method} object passed to {@code invoke} will be{@code java.lang.Object}.  Other public methods of a proxy
                  instance inherited from {@code java.lang.Object} are not
                  overridden by a proxy class, so invocations of those methods behave
                  like they do for instances of {@code java.lang.Object}.
                  &lt;/ul&gt;
                  &lt;h3&gt;Methods Duplicated in Multiple Proxy Interfaces&lt;/h3&gt;
                  &lt;p&gt;When two or more interfaces of a proxy class contain a method with
                  the same name and parameter signature, the order of the proxy class&apos;s
                  interfaces becomes significant.  When such a &lt;i&gt;duplicate method&lt;/i&gt;
                  is invoked on a proxy instance, the {@code Method} object passed
                  to the invocation handler will not necessarily be the one whose
                  declaring class is assignable from the reference type of the interface
                  that the proxy&apos;s method was invoked through.  This limitation exists
                  because the corresponding method implementation in the generated proxy
                  class cannot determine which interface it was invoked through.
                  Therefore, when a duplicate method is invoked on a proxy instance,
                  the {@code Method} object for the method in the foremost interface
                  that contains the method (either directly or inherited through a
                  superinterface) in the proxy class&apos;s list of interfaces is passed to
                  the invocation handler&apos;s {@code invoke} method, regardless of the
                  reference type through which the method invocation occurred.
                  &lt;p&gt;If a proxy interface contains a method with the same name and
                  parameter signature as the {@code hashCode}, {@code equals},
                  or {@code toString} methods of {@code java.lang.Object},
                  when such a method is invoked on a proxy instance, the{@code Method} object passed to the invocation handler will have{@code java.lang.Object} as its declaring class.  In other words,
                  the public, non-final methods of {@code java.lang.Object}logically precede all of the proxy interfaces for the determination of
                  which {@code Method} object to pass to the invocation handler.
                  &lt;p&gt;Note also that when a duplicate method is dispatched to an
                  invocation handler, the {@code invoke} method may only throw
                  checked exception types that are assignable to one of the exception
                  types in the {@code throws} clause of the method in &lt;i&gt;all&lt;/i&gt; of
                  the proxy interfaces that it can be invoked through.  If the{@code invoke} method throws a checked exception that is not
                  assignable to any of the exception types declared by the method in one
                  of the proxy interfaces that it can be invoked through, then an
                  unchecked {@code UndeclaredThrowableException} will be thrown by
                  the invocation on the proxy instance.  This restriction means that not
                  all of the exception types returned by invoking{@code getExceptionTypes} on the {@code Method} object
                  passed to the {@code invoke} method can necessarily be thrown
                  successfully by the {@code invoke} method.                
                <author>
                    Peter Jones                    
                </author>
                <see>
                    InvocationHandler                    
                </see>
                <since>
                    1.3                    
                </since>
            </javadoc>
            <declaration name="serialVersionUID" type="long" line="146"/>
            <declaration name="proxyClassNamePrefix" type="String" line="147"/>
            <javadoc line="147">
                prefix for all proxy class names                
            </javadoc>
            <declaration name="constructorParams" type="Class[]" line="151"/>
            <javadoc line="151">
                parameter types of a proxy class constructor                
            </javadoc>
            <declaration name="loaderToCache" type="Map&lt;ClassLoader,Map&lt;List&lt;String&gt;,Object&gt;&gt;" line="155"/>
            <javadoc line="155">
                maps a class loader to the proxy class cache for that loader                
            </javadoc>
            <declaration name="pendingGenerationMarker" type="Object" line="159"/>
            <javadoc line="159">
                marks that a particular proxy class is currently being generated                
            </javadoc>
            <declaration name="nextUniqueNumber" type="long" line="163"/>
            <javadoc line="163">
                next number to use for generation of unique proxy class names                
            </javadoc>
            <declaration name="nextUniqueNumberLock" type="Object" line="167"/>
            <declaration name="proxyClasses" type="Map&lt;Class&lt;?&gt;,Void&gt;" line="168"/>
            <javadoc line="168">
                set of all generated proxy classes, for isProxyClass implementation                
            </javadoc>
            <declaration name="h" type="InvocationHandler" line="172"/>
            <javadoc line="172">
                the invocation handler for this proxy instance.                
                <serial>
                                        
                </serial>
            </javadoc>
            <javadoc line="177">
                Prohibits instantiation.                
            </javadoc>
            <method name="Proxy" type="constructor" line="180"/>
            <javadoc line="182">
                Constructs a new {@code Proxy} instance from a subclass
                  (typically, a dynamic proxy class) with the specified value
                  for its invocation handler.                
                <param>
                    h the invocation handler for this proxy instance                    
                </param>
            </javadoc>
            <method name="Proxy" type="constructor" line="188">
                <params>
                    <param name="h" type="InvocationHandler"/>
                </params>
            </method>
            <javadoc line="191">
                Returns the {@code java.lang.Class} object for a proxy class
                  given a class loader and an array of interfaces.  The proxy class
                  will be defined by the specified class loader and will implement
                  all of the supplied interfaces.  If a proxy class for the same
                  permutation of interfaces has already been defined by the class
                  loader, then the existing proxy class will be returned; otherwise,
                  a proxy class for those interfaces will be generated dynamically
                  and defined by the class loader.
                  &lt;p&gt;There are several restrictions on the parameters that may be
                  passed to {@code Proxy.getProxyClass}:
                  &lt;ul&gt;
                  &lt;li&gt;All of the {@code Class} objects in the{@code interfaces} array must represent interfaces, not
                  classes or primitive types.
                  &lt;li&gt;No two elements in the {@code interfaces} array may
                  refer to identical {@code Class} objects.
                  &lt;li&gt;All of the interface types must be visible by name through the
                  specified class loader.  In other words, for class loader{@code cl} and every interface {@code i}, the following
                  expression must be true:
                  &lt;pre&gt;
                  Class.forName(i.getName(), false, cl) == i
                  &lt;/pre&gt;
                  &lt;li&gt;All non-public interfaces must be in the same package;
                  otherwise, it would not be possible for the proxy class to
                  implement all of the interfaces, regardless of what package it is
                  defined in.
                  &lt;li&gt;For any set of member methods of the specified interfaces
                  that have the same signature:
                  &lt;ul&gt;
                  &lt;li&gt;If the return type of any of the methods is a primitive
                  type or void, then all of the methods must have that same
                  return type.
                  &lt;li&gt;Otherwise, one of the methods must have a return type that
                  is assignable to all of the return types of the rest of the
                  methods.
                  &lt;/ul&gt;
                  &lt;li&gt;The resulting proxy class must not exceed any limits imposed
                  on classes by the virtual machine.  For example, the VM may limit
                  the number of interfaces that a class may implement to 65535; in
                  that case, the size of the {@code interfaces} array must not
                  exceed 65535.
                  &lt;/ul&gt;
                  &lt;p&gt;If any of these restrictions are violated,{@code Proxy.getProxyClass} will throw an{@code IllegalArgumentException}.  If the {@code interfaces}array argument or any of its elements are {@code null}, a{@code NullPointerException} will be thrown.
                  &lt;p&gt;Note that the order of the specified proxy interfaces is
                  significant: two requests for a proxy class with the same combination
                  of interfaces but in a different order will result in two distinct
                  proxy classes.                
                <param>
                    loader the class loader to define the proxy class                    
                </param>
                <param>
                    interfaces the list of interfaces for the proxy class
                      to implement                    
                </param>
                <return>
                    a proxy class that is defined in the specified class loader
                      and that implements the specified interfaces                    
                </return>
                <throws>
                    IllegalArgumentException if any of the restrictions on the
                      parameters that may be passed to {@code getProxyClass}are violated                    
                </throws>
                <throws>
                    NullPointerException if the {@code interfaces} array
                      argument or any of its elements are {@code null}                    
                </throws>
            </javadoc>
            <method name="getProxyClass" type="Class<?>" line="248">
                <params>
                    <param name="loader" type="ClassLoader"/>
                    <param name="interfaces" type="Class<?>"/>
                </params>
                <scope line="249"/>
                <declaration name="proxyClass" type="Class&lt;?&gt;" line="252"/>
                <declaration name="interfaceNames" type="String[]" line="253"/>
                <declaration name="interfaceSet" type="Set&lt;Class&lt;?&gt;&gt;" line="254"/>
                <scope line="255">
                    <declaration name="interfaceName" type="String" line="256"/>
                    <declaration name="interfaceClass" type="Class&lt;?&gt;" line="257"/>
                    <scope line="258"/>
                    <scope line="261"/>
                    <scope line="263"/>
                    <scope line="266"/>
                    <scope line="269"/>
                </scope>
                <declaration name="key" type="List&lt;String&gt;" line="275"/>
                <declaration name="cache" type="Map&lt;List&lt;String&gt;,Object&gt;" line="276"/>
                <scope line="277">
                    <scope line="279"/>
                </scope>
                <scope line="284">
                    <scope line="285">
                        <declaration name="value" type="Object" line="286"/>
                        <scope line="287"/>
                        <scope line="290"/>
                        <scope line="293">
                            <scope line="294"/>
                            <scope line="297"/>
                        </scope>
                        <scope line="301"/>
                    </scope>
                </scope>
                <scope line="308">
                    <declaration name="proxyPkg" type="String" line="309"/>
                    <scope line="310">
                        <declaration name="flags" type="int" line="311"/>
                        <scope line="312">
                            <declaration name="name" type="String" line="313"/>
                            <declaration name="n" type="int" line="314"/>
                            <declaration name="pkg" type="String" line="315"/>
                            <scope line="316"/>
                            <scope line="319"/>
                        </scope>
                    </scope>
                    <scope line="324"/>
                    <scope line="327">
                        <declaration name="num" type="long" line="328"/>
                        <scope line="329"/>
                        <declaration name="proxyName" type="String" line="332"/>
                        <declaration name="proxyClassFile" type="byte[]" line="333"/>
                        <scope line="334"/>
                        <scope line="337"/>
                    </scope>
                </scope>
                <scope line="343">
                    <scope line="344">
                        <scope line="345"/>
                        <scope line="348"/>
                    </scope>
                </scope>
            </method>
            <javadoc line="356">
                Returns an instance of a proxy class for the specified interfaces
                  that dispatches method invocations to the specified invocation
                  handler.  This method is equivalent to:
                  &lt;pre&gt;
                  Proxy.getProxyClass(loader, interfaces).
                  getConstructor(new Class[] { InvocationHandler.class }).
                  newInstance(new Object[] { handler });
                  &lt;/pre&gt;
                  &lt;p&gt;{@code Proxy.newProxyInstance} throws{@code IllegalArgumentException} for the same reasons that{@code Proxy.getProxyClass} does.                
                <param>
                    loader the class loader to define the proxy class                    
                </param>
                <param>
                    interfaces the list of interfaces for the proxy class
                      to implement                    
                </param>
                <param>
                    h the invocation handler to dispatch method invocations to                    
                </param>
                <return>
                    a proxy instance with the specified invocation handler of a
                      proxy class that is defined by the specified class loader
                      and that implements the specified interfaces                    
                </return>
                <throws>
                    IllegalArgumentException if any of the restrictions on the
                      parameters that may be passed to {@code getProxyClass}are violated                    
                </throws>
                <throws>
                    NullPointerException if the {@code interfaces} array
                      argument or any of its elements are {@code null}, or
                      if the invocation handler, {@code h}, is{@code null}                    
                </throws>
            </javadoc>
            <method name="newProxyInstance" type="Object" line="379">
                <params>
                    <param name="loader" type="ClassLoader"/>
                    <param name="interfaces" type="Class<?>[]"/>
                    <param name="h" type="InvocationHandler"/>
                </params>
                <scope line="380"/>
                <declaration name="cl" type="Class&lt;?&gt;" line="383"/>
                <scope line="384">
                    <declaration name="cons" type="Constructor" line="385"/>
                </scope>
                <scope line="388"/>
                <scope line="391"/>
                <scope line="394"/>
                <scope line="397"/>
            </method>
            <javadoc line="401">
                Returns true if and only if the specified class was dynamically
                  generated to be a proxy class using the {@code getProxyClass}method or the {@code newProxyInstance} method.
                  &lt;p&gt;The reliability of this method is important for the ability
                  to use it to make security decisions, so its implementation should
                  not just test if the class in question extends {@code Proxy}.                
                <param>
                    cl the class to test                    
                </param>
                <return>
                    {@code true} if the class is a proxy class and{@code false} otherwise                    
                </return>
                <throws>
                    NullPointerException if {@code cl} is {@code null}                    
                </throws>
            </javadoc>
            <method name="isProxyClass" type="boolean" line="411">
                <params>
                    <param name="cl" type="Class<?>"/>
                </params>
                <scope line="412"/>
            </method>
            <javadoc line="417">
                Returns the invocation handler for the specified proxy instance.                
                <param>
                    proxy the proxy instance to return the invocation handler for                    
                </param>
                <return>
                    the invocation handler for the proxy instance                    
                </return>
                <throws>
                    IllegalArgumentException if the argument is not a
                      proxy instance                    
                </throws>
            </javadoc>
            <method name="getInvocationHandler" type="InvocationHandler" line="424">
                <params>
                    <param name="proxy" type="Object"/>
                </params>
                <scope line="425"/>
                <declaration name="p" type="Proxy" line="428"/>
            </method>
            <method name="defineClass0" type="Class" line="431"/>
        </class>
    </source>