<?xml version="1.0" encoding="UTF-8"?>
    <source package="java.lang.reflect">
        <import package="sun.reflect.ConstructorAccessor"/>
        <import package="sun.reflect.Reflection"/>
        <import package="sun.reflect.generics.repository.ConstructorRepository"/>
        <import package="sun.reflect.generics.factory.CoreReflectionFactory"/>
        <import package="sun.reflect.generics.factory.GenericsFactory"/>
        <import package="sun.reflect.generics.scope.ConstructorScope"/>
        <import package="java.lang.annotation.Annotation"/>
        <import package="java.util.Map"/>
        <import package="sun.reflect.annotation.AnnotationParser"/>
        <import package="java.lang.annotation.AnnotationFormatError"/>
        <import package="java.lang.reflect.Modifier"/>
        <class name="Constructor" line="40">
            <type_params>
                <type_param name="T"/>
            </type_params>
            <extends class="AccessibleObject"/>
            <comment line="71">
                Generics and annotations support                
            </comment>
            <comment line="73">
                generic info repository; lazily initialized                
            </comment>
            <comment line="78">
                Generics infrastructure
                 Accessor for factory                
            </comment>
            <comment line="85">
                Accessor for generic info repository                
            </comment>
            <comment line="98">
                For sharing of ConstructorAccessors. This branching structure
                 is currently only two levels deep (i.e., one root Constructor
                 and potentially many Constructor objects pointing to it.)                
            </comment>
            <comment line="555">
                NOTE that there is no synchronization used here. It is correct
                 (though not efficient) to generate more than one
                 ConstructorAccessor for a given Constructor. However, avoiding
                 synchronization will probably make the implementation more
                 scalable.                
            </comment>
            <comment line="576">
                Returns ConstructorAccessor for this Constructor object, not
                 looking up the chain to the root                
            </comment>
            <comment line="582">
                Sets the ConstructorAccessor for this Constructor object and
                 (recursively) its root                
            </comment>
            <implements interface="GenericDeclaration"/>
            <implements interface="Member"/>
            <javadoc line="40">
                {@code Constructor} provides information about, and access to, a single
                  constructor for a class.
                  &lt;p&gt;{@code Constructor} permits widening conversions to occur when matching the
                  actual parameters to newInstance() with the underlying
                  constructor&apos;s formal parameters, but throws an{@code IllegalArgumentException} if a narrowing conversion would occur.                
                <param>
                    <T>
                       the class in which the constructor is declared                    
                </param>
                <see>
                    Member                    
                </see>
                <see>
                    java.lang.Class                    
                </see>
                <see>
                    java.lang.Class#getConstructors()                    
                </see>
                <see>
                    java.lang.Class#getConstructor(Class[])                    
                </see>
                <see>
                    java.lang.Class#getDeclaredConstructors()                    
                </see>
                <author>
                    Kenneth Russell                    
                </author>
                <author>
                    Nakul Saraiya                    
                </author>
            </javadoc>
            <declaration name="clazz" type="Class&lt;T&gt;" line="65"/>
            <declaration name="slot" type="int" line="66"/>
            <declaration name="parameterTypes" type="Class&lt;?&gt;[]" line="67"/>
            <declaration name="exceptionTypes" type="Class&lt;?&gt;[]" line="68"/>
            <declaration name="modifiers" type="int" line="69"/>
            <declaration name="signature" type="String" line="71"/>
            <declaration name="genericInfo" type="ConstructorRepository" line="73"/>
            <declaration name="annotations" type="byte[]" line="74"/>
            <declaration name="parameterAnnotations" type="byte[]" line="75"/>
            <method name="getFactory" type="GenericsFactory" line="79">
                <comment line="81">
                    create scope and factory                    
                </comment>
            </method>
            <method name="getGenericInfo" type="ConstructorRepository" line="85">
                <comment line="87">
                    lazily initialize repository if necessary                    
                </comment>
                <comment line="89">
                    create and cache generic info repository                    
                </comment>
                <comment line="94">
                    return cached repository                    
                </comment>
                <scope line="87"/>
            </method>
            <declaration name="constructorAccessor" type="ConstructorAccessor" line="96"/>
            <declaration name="root" type="Constructor&lt;T&gt;" line="100"/>
            <javadoc line="102">
                Package-private constructor used by ReflectAccess to enable
                  instantiation of these objects in Java code from the java.lang
                  package via sun.reflect.LangReflectAccess.                
            </javadoc>
            <method name="Constructor" type="constructor" line="115">
                <params>
                    <param name="declaringClass" type="Class<T>"/>
                    <param name="parameterTypes" type="Class<?>[]"/>
                    <param name="checkedExceptions" type="Class<?>[]"/>
                    <param name="modifiers" type="int"/>
                    <param name="slot" type="int"/>
                    <param name="signature" type="String"/>
                    <param name="annotations" type="byte[]"/>
                    <param name="parameterAnnotations" type="byte[]"/>
                </params>
            </method>
            <javadoc line="126">
                Package-private routine (exposed to java.lang.Class via
                  ReflectAccess) which returns a copy of this Constructor. The copy&apos;s
                  &quot;root&quot; field points to this Constructor.                
            </javadoc>
            <method name="copy" type="Constructor<T>" line="131">
                <comment line="133">
                    This routine enables sharing of ConstructorAccessor objects
                     among Constructor objects which refer to the same underlying
                     method in the VM. (All of this contortion is only necessary
                     because of the &quot;accessibility&quot; bit in AccessibleObject,
                     which implicitly requires that new java.lang.reflect
                     objects be fabricated for each reflective call on Class
                     objects.)                    
                </comment>
                <comment line="147">
                    Might as well eagerly propagate this if already present                    
                </comment>
                <declaration name="res" type="Constructor&lt;T&gt;" line="139"/>
            </method>
            <javadoc line="151">
                Returns the {@code Class} object representing the class that declares
                  the constructor represented by this {@code Constructor} object.                
            </javadoc>
            <method name="getDeclaringClass" type="Class<T>" line="155"/>
            <javadoc line="159">
                Returns the name of this constructor, as a string.  This is
                  the binary name of the constructor&apos;s declaring class.                
            </javadoc>
            <method name="getName" type="String" line="163"/>
            <javadoc line="167">
                Returns the Java language modifiers for the constructor
                  represented by this {@code Constructor} object, as an integer. The{@code Modifier} class should be used to decode the modifiers.                
                <see>
                    Modifier                    
                </see>
            </javadoc>
            <method name="getModifiers" type="int" line="174"/>
            <javadoc line="178">
                Returns an array of {@code TypeVariable} objects that represent the
                  type variables declared by the generic declaration represented by this{@code GenericDeclaration} object, in declaration order.  Returns an
                  array of length 0 if the underlying generic declaration declares no type
                  variables.                
                <return>
                    an array of {@code TypeVariable} objects that represent
                      the type variables declared by this generic declaration                    
                </return>
                <throws>
                    GenericSignatureFormatError if the generic
                      signature of this generic declaration does not conform to
                      the format specified in
                      <cite>The Java&trade; Virtual Machine Specification</cite>                    
                </throws>
                <since>
                    1.5                    
                </since>
            </javadoc>
            <method name="getTypeParameters" type="TypeVariable<Constructor<T>>[]" line="193">
                <scope line="194"/>
            </method>
            <javadoc line="201">
                Returns an array of {@code Class} objects that represent the formal
                  parameter types, in declaration order, of the constructor
                  represented by this {@code Constructor} object.  Returns an array of
                  length 0 if the underlying constructor takes no parameters.                
                <return>
                    the parameter types for the constructor this object
                      represents                    
                </return>
            </javadoc>
            <method name="getParameterTypes" type="Class<?>[]" line="210"/>
            <javadoc line="215">
                Returns an array of {@code Type} objects that represent the formal
                  parameter types, in declaration order, of the method represented by
                  this {@code Constructor} object. Returns an array of length 0 if the
                  underlying method takes no parameters.
                  &lt;p&gt;If a formal parameter type is a parameterized type,
                  the {@code Type} object returned for it must accurately reflect
                  the actual type parameters used in the source code.
                  &lt;p&gt;If a formal parameter type is a type variable or a parameterized
                  type, it is created. Otherwise, it is resolved.                
                <return>
                    an array of {@code Type}s that represent the formal
                      parameter types of the underlying method, in declaration order                    
                </return>
                <throws>
                    GenericSignatureFormatErrorif the generic method signature does not conform to the format
                      specified in
                      <cite>The Java&trade; Virtual Machine Specification</cite>                    
                </throws>
                <throws>
                    TypeNotPresentException if any of the parameter
                      types of the underlying method refers to a non-existent type
                      declaration                    
                </throws>
                <throws>
                    MalformedParameterizedTypeException if any of
                      the underlying method's parameter types refer to a parameterized
                      type that cannot be instantiated for any reason                    
                </throws>
                <since>
                    1.5                    
                </since>
            </javadoc>
            <method name="getGenericParameterTypes" type="Type[]" line="242"/>
            <javadoc line="250">
                Returns an array of {@code Class} objects that represent the types
                  of exceptions declared to be thrown by the underlying constructor
                  represented by this {@code Constructor} object.  Returns an array of
                  length 0 if the constructor declares no exceptions in its {@code throws} clause.                
                <return>
                    the exception types declared as being thrown by the
                      constructor this object represents                    
                </return>
            </javadoc>
            <method name="getExceptionTypes" type="Class<?>[]" line="259"/>
            <javadoc line="264">
                Returns an array of {@code Type} objects that represent the
                  exceptions declared to be thrown by this {@code Constructor} object.
                  Returns an array of length 0 if the underlying method declares
                  no exceptions in its {@code throws} clause.
                  &lt;p&gt;If an exception type is a type variable or a parameterized
                  type, it is created. Otherwise, it is resolved.                
                <return>
                    an array of Types that represent the exception types
                      thrown by the underlying method                    
                </return>
                <throws>
                    GenericSignatureFormatErrorif the generic method signature does not conform to the format
                      specified in
                      <cite>The Java&trade; Virtual Machine Specification</cite>                    
                </throws>
                <throws>
                    TypeNotPresentException if the underlying method's{@code throws} clause refers to a non-existent type declaration                    
                </throws>
                <throws>
                    MalformedParameterizedTypeException if
                      the underlying method's {@code throws} clause refers to a
                      parameterized type that cannot be instantiated for any reason                    
                </throws>
                <since>
                    1.5                    
                </since>
            </javadoc>
            <method name="getGenericExceptionTypes" type="Type[]" line="286">
                <declaration name="result" type="Type[]" line="287"/>
            </method>
            <javadoc line="295">
                Compares this {@code Constructor} against the specified object.
                  Returns true if the objects are the same.  Two {@code Constructor} objects are
                  the same if they were declared by the same class and have the
                  same formal parameter types.                
            </javadoc>
            <method name="equals" type="boolean" line="301">
                <params>
                    <param name="obj" type="Object"/>
                </params>
                <comment line="306">
                                        
                </comment>
                <scope line="302">
                    <declaration name="other" type="Constructor&lt;?&gt;" line="303"/>
                    <scope line="304">
                        <declaration name="params1" type="Class&lt;?&gt;[]" line="306"/>
                        <declaration name="params2" type="Class&lt;?&gt;[]" line="307"/>
                        <scope line="308">
                            <scope line="309"/>
                        </scope>
                    </scope>
                </scope>
            </method>
            <javadoc line="320">
                Returns a hashcode for this {@code Constructor}. The hashcode is
                  the same as the hashcode for the underlying constructor&apos;s
                  declaring class name.                
            </javadoc>
            <method name="hashCode" type="int" line="325"/>
            <javadoc line="329">
                Returns a string describing this {@code Constructor}.  The string is
                  formatted as the constructor access modifiers, if any,
                  followed by the fully-qualified name of the declaring class,
                  followed by a parenthesized, comma-separated list of the
                  constructor&apos;s formal parameter types.  For example:
                  &lt;pre&gt;
                  public java.util.Hashtable(int,float)
                  &lt;/pre&gt;
                  &lt;p&gt;The only possible modifiers for constructors are the access
                  modifiers {@code public}, {@code protected} or{@code private}.  Only one of these may appear, or none if the
                  constructor has default (package) access.                
            </javadoc>
            <method name="toString" type="String" line="344">
                <comment line="354">
                    avoid clone                    
                </comment>
                <comment line="361">
                    avoid clone                    
                </comment>
                <scope line="345">
                    <declaration name="sb" type="StringBuffer" line="346"/>
                    <declaration name="mod" type="int" line="347"/>
                    <scope line="348"/>
                    <declaration name="params" type="Class&lt;?&gt;[]" line="353"/>
                    <scope line="354"/>
                    <declaration name="exceptions" type="Class&lt;?&gt;[]" line="360"/>
                    <scope line="361">
                        <scope line="363"/>
                    </scope>
                </scope>
                <scope line="370"/>
            </method>
            <javadoc line="375">
                Returns a string describing this {@code Constructor},
                  including type parameters.  The string is formatted as the
                  constructor access modifiers, if any, followed by an
                  angle-bracketed comma separated list of the constructor&apos;s type
                  parameters, if any, followed by the fully-qualified name of the
                  declaring class, followed by a parenthesized, comma-separated
                  list of the constructor&apos;s generic formal parameter types.
                  If this constructor was declared to take a variable number of
                  arguments, instead of denoting the last parameter as
                  &quot;&lt;tt&gt;&lt;i&gt;Type&lt;/i&gt;[]&lt;/tt&gt;&quot;, it is denoted as
                  &quot;&lt;tt&gt;&lt;i&gt;Type&lt;/i&gt;...&lt;/tt&gt;&quot;.
                  A space is used to separate access modifiers from one another
                  and from the type parameters or return type.  If there are no
                  type parameters, the type parameter list is elided; if the type
                  parameter list is present, a space separates the list from the
                  class name.  If the constructor is declared to throw
                  exceptions, the parameter list is followed by a space, followed
                  by the word &quot;{@code throws}&quot; followed by a
                  comma-separated list of the thrown exception types.
                  &lt;p&gt;The only possible modifiers for constructors are the access
                  modifiers {@code public}, {@code protected} or{@code private}.  Only one of these may appear, or none if the
                  constructor has default (package) access.                
                <return>
                    a string describing this {@code Constructor},
                      include type parameters                    
                </return>
                <since>
                    1.5                    
                </since>
            </javadoc>
            <method name="toGenericString" type="String" line="408">
                <comment line="423">
                    Class objects can&apos;t occur here; no need to test
                     and call Class.getName().                    
                </comment>
                <comment line="437">
                    replace T[] with T...                    
                </comment>
                <scope line="409">
                    <declaration name="sb" type="StringBuilder" line="410"/>
                    <declaration name="mod" type="int" line="411"/>
                    <scope line="412"/>
                    <declaration name="typeparms" type="TypeVariable&lt;?&gt;[]" line="415"/>
                    <scope line="416">
                        <declaration name="first" type="boolean" line="417"/>
                        <scope line="419"/>
                    </scope>
                    <declaration name="params" type="Type[]" line="431"/>
                    <scope line="432">
                        <declaration name="param" type="String" line="433"/>
                    </scope>
                    <declaration name="exceptions" type="Type[]" line="443"/>
                    <scope line="444">
                        <scope line="446"/>
                    </scope>
                </scope>
                <scope line="455"/>
            </method>
            <javadoc line="460">
                Uses the constructor represented by this {@code Constructor} object to
                  create and initialize a new instance of the constructor&apos;s
                  declaring class, with the specified initialization parameters.
                  Individual parameters are automatically unwrapped to match
                  primitive formal parameters, and both primitive and reference
                  parameters are subject to method invocation conversions as necessary.
                  &lt;p&gt;If the number of formal parameters required by the underlying constructor
                  is 0, the supplied {@code initargs} array may be of length 0 or null.
                  &lt;p&gt;If the constructor&apos;s declaring class is an inner class in a
                  non-static context, the first argument to the constructor needs
                  to be the enclosing instance; see section 15.9.3 of
                  &lt;cite&gt;The Java&amp;trade; Language Specification&lt;/cite&gt;.
                  &lt;p&gt;If the required access and argument checks succeed and the
                  instantiation will proceed, the constructor&apos;s declaring class
                  is initialized if it has not already been initialized.
                  &lt;p&gt;If the constructor completes normally, returns the newly
                  created and initialized instance.                
                <param>
                    initargs array of objects to be passed as arguments to
                      the constructor call; values of primitive types are wrapped in
                      a wrapper object of the appropriate type (e.g. a {@code float}in a {@link java.lang.Float Float})                    
                </param>
                <return>
                    a new object created by calling the constructor
                      this object represents                    
                </return>
                <exception>
                    IllegalAccessException    if this {@code Constructor} object
                      is enforcing Java language access control and the underlying
                      constructor is inaccessible.                    
                </exception>
                <exception>
                    IllegalArgumentException  if the number of actual
                      and formal parameters differ; if an unwrapping
                      conversion for primitive arguments fails; or if,
                      after possible unwrapping, a parameter value
                      cannot be converted to the corresponding formal
                      parameter type by a method invocation conversion; if
                      this constructor pertains to an enum type.                    
                </exception>
                <exception>
                    InstantiationException    if the class that declares the
                      underlying constructor represents an abstract class.                    
                </exception>
                <exception>
                    InvocationTargetException if the underlying constructor
                      throws an exception.                    
                </exception>
                <exception>
                    ExceptionInInitializerError if the initialization provoked
                      by this method fails.                    
                </exception>
            </javadoc>
            <method name="newInstance" type="T" line="511">
                <params>
                    <param name="initargs" type="Object"/>
                </params>
                <comment line="522">
                    read volatile                    
                </comment>
                <scope line="512">
                    <scope line="513">
                        <declaration name="caller" type="Class&lt;?&gt;" line="514"/>
                    </scope>
                </scope>
                <declaration name="ca" type="ConstructorAccessor" line="521"/>
                <scope line="522"/>
            </method>
            <javadoc line="528">
                Returns {@code true} if this constructor was declared to take
                  a variable number of arguments; returns {@code false}otherwise.                
                <return>
                    {@code true} if an only if this constructor was declared to
                      take a variable number of arguments.                    
                </return>
                <since>
                    1.5                    
                </since>
            </javadoc>
            <method name="isVarArgs" type="boolean" line="537"/>
            <javadoc line="541">
                Returns {@code true} if this constructor is a synthetic
                  constructor; returns {@code false} otherwise.                
                <return>
                    true if and only if this constructor is a synthetic
                      constructor as defined by
                      <cite>The Java&trade; Language Specification</cite>.                    
                </return>
                <since>
                    1.5                    
                </since>
            </javadoc>
            <method name="isSynthetic" type="boolean" line="550"/>
            <method name="acquireConstructorAccessor" type="ConstructorAccessor" line="559">
                <comment line="561">
                    First check to see if one has been created yet, and take it
                     if so.                    
                </comment>
                <comment line="568">
                    Otherwise fabricate one and propagate it up to the root                    
                </comment>
                <declaration name="tmp" type="ConstructorAccessor" line="562"/>
                <scope line="564"/>
                <scope line="566"/>
            </method>
            <method name="getConstructorAccessor" type="ConstructorAccessor" line="577"/>
            <method name="setConstructorAccessor" type="void" line="583">
                <params>
                    <param name="accessor" type="ConstructorAccessor"/>
                </params>
                <comment line="586">
                    Propagate up                    
                </comment>
                <scope line="586"/>
            </method>
            <method name="getSlot" type="int" line="591"/>
            <method name="getSignature" type="String" line="595"/>
            <method name="getRawAnnotations" type="byte[]" line="599"/>
            <method name="getRawParameterAnnotations" type="byte[]" line="603"/>
            <javadoc line="607">
                @throws NullPointerException {@inheritDoc}                
                <since>
                    1.5                    
                </since>
            </javadoc>
            <method name="getAnnotation" type="T" line="611">
                <params>
                    <param name="annotationClass" type="Class<T>"/>
                </params>
            </method>
            <javadoc line="618">
                @since 1.5                
            </javadoc>
            <method name="getDeclaredAnnotations" type="Annotation[]" line="621"/>
            <declaration name="declaredAnnotations" type="Map&lt;Class&lt;? extends Annotation&gt;,Annotation&gt;" line="625"/>
            <method name="declaredAnnotations" type="Map<Class<? extends Annotation>,Annotation>" line="627">
                <scope line="628"/>
            </method>
            <javadoc line="637">
                Returns an array of arrays that represent the annotations on the formal
                  parameters, in declaration order, of the method represented by
                  this {@code Constructor} object. (Returns an array of length zero if the
                  underlying method is parameterless.  If the method has one or more
                  parameters, a nested array of length zero is returned for each parameter
                  with no annotations.) The annotation objects contained in the returned
                  arrays are serializable.  The caller of this method is free to modify
                  the returned arrays; it will have no effect on the arrays returned to
                  other callers.                
                <return>
                    an array of arrays that represent the annotations on the formal
                      parameters, in declaration order, of the method represented by this
                      Constructor object                    
                </return>
                <since>
                    1.5                    
                </since>
            </javadoc>
            <method name="getParameterAnnotations" type="Annotation[][]" line="653">
                <comment line="669">
                    Can&apos;t do reliable parameter counting                    
                </comment>
                <comment line="671">
                    top-level                    
                </comment>
                <comment line="672">
                    Check for the enclosing instance parameter for
                     non-static member classes                    
                </comment>
                <declaration name="numParameters" type="int" line="654"/>
                <declaration name="result" type="Annotation[][]" line="658"/>
                <scope line="663">
                    <declaration name="declaringClass" type="Class&lt;?&gt;" line="664"/>
                    <scope line="669">
                        <scope line="675"/>
                    </scope>
                </scope>
            </method>
        </class>
    </source>