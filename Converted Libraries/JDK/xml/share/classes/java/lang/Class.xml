<?xml version="1.0" encoding="UTF-8"?>
    <source package="java.lang">
        <import package="java.lang.reflect.Array"/>
        <import package="java.lang.reflect.GenericArrayType"/>
        <import package="java.lang.reflect.Member"/>
        <import package="java.lang.reflect.Field"/>
        <import package="java.lang.reflect.Method"/>
        <import package="java.lang.reflect.Constructor"/>
        <import package="java.lang.reflect.GenericDeclaration"/>
        <import package="java.lang.reflect.Modifier"/>
        <import package="java.lang.reflect.Type"/>
        <import package="java.lang.reflect.TypeVariable"/>
        <import package="java.lang.reflect.InvocationTargetException"/>
        <import package="java.lang.ref.SoftReference"/>
        <import package="java.io.InputStream"/>
        <import package="java.io.ObjectStreamField"/>
        <import package="java.security.AccessController"/>
        <import package="java.security.PrivilegedAction"/>
        <import package="java.util.ArrayList"/>
        <import package="java.util.Arrays"/>
        <import package="java.util.Collection"/>
        <import package="java.util.HashSet"/>
        <import package="java.util.Iterator"/>
        <import package="java.util.List"/>
        <import package="java.util.LinkedList"/>
        <import package="java.util.LinkedHashSet"/>
        <import package="java.util.Set"/>
        <import package="java.util.Map"/>
        <import package="java.util.HashMap"/>
        <import package="sun.misc.Unsafe"/>
        <import package="sun.reflect.ConstantPool"/>
        <import package="sun.reflect.Reflection"/>
        <import package="sun.reflect.ReflectionFactory"/>
        <import package="sun.reflect.SignatureIterator"/>
        <import package="sun.reflect.generics.factory.CoreReflectionFactory"/>
        <import package="sun.reflect.generics.factory.GenericsFactory"/>
        <import package="sun.reflect.generics.repository.ClassRepository"/>
        <import package="sun.reflect.generics.repository.MethodRepository"/>
        <import package="sun.reflect.generics.repository.ConstructorRepository"/>
        <import package="sun.reflect.generics.scope.ClassScope"/>
        <import package="sun.security.util.SecurityConstants"/>
        <import package="java.lang.annotation.Annotation"/>
        <import package="sun.reflect.annotation"/>
        <class name="Class" line="70">
            <type_params>
                <type_param name="T"/>
            </type_params>
            <comment line="130">
                Constructor. Only the Java Virtual Machine creates Class
                 objects.                
            </comment>
            <comment line="576">
                cache the name to reduce the number of calls into the VM                
            </comment>
            <comment line="620">
                Package-private to allow ClassLoader access                
            </comment>
            <comment line="2154">
                Return the Virtual Machine&apos;s Class object for the named
                 primitive type.                
            </comment>
            <comment line="2161">
                Check if client is allowed to access members.  If access is denied,
                 throw a SecurityException.
                
                 Be very careful not to change the stack depth of this checkMemberAccess
                 call for security reasons.
                 See java.lang.SecurityManager.checkMemberAccess.
                
                 &lt;p&gt; Default policy: allow all clients access with normal Java access
                 control.                
            </comment>
            <comment line="2225">
                Intermediate results for getFields and getMethods                
            </comment>
            <comment line="2229">
                Incremented by the VM on each call to JVM TI RedefineClasses()
                 that redefines this class or a superclass.                
            </comment>
            <comment line="2233">
                Value of classRedefinedCount when we last cleared the cached values
                 that are sensitive to class redefinition.                
            </comment>
            <comment line="2237">
                Clears cached values that might possibly have been obsoleted by
                 a class redefinition.                
            </comment>
            <comment line="2255">
                Generic signature handling                
            </comment>
            <comment line="2258">
                Generic info repository; lazily initialized                
            </comment>
            <comment line="2261">
                accessor for factory                
            </comment>
            <comment line="2267">
                accessor for generic info repository                
            </comment>
            <comment line="2278">
                Annotations handling                
            </comment>
            <comment line="2283">
                java.lang.reflect.Field handling                
            </comment>
            <comment line="2289">
                Returns an array of &quot;root&quot; fields. These Field objects must NOT
                 be propagated to the outside world, but must instead be copied
                 via ReflectionFactory.copyField.                
            </comment>
            <comment line="2320">
                Returns an array of &quot;root&quot; fields. These Field objects must NOT
                 be propagated to the outside world, but must instead be copied
                 via ReflectionFactory.copyField.                
            </comment>
            <comment line="2376">
                java.lang.reflect.Constructor handling                
            </comment>
            <comment line="2382">
                Returns an array of &quot;root&quot; constructors. These Constructor
                 objects must NOT be propagated to the outside world, but must
                 instead be copied via ReflectionFactory.copyConstructor.                
            </comment>
            <comment line="2417">
                java.lang.reflect.Method handling                
            </comment>
            <comment line="2423">
                Returns an array of &quot;root&quot; methods. These Method objects must NOT
                 be propagated to the outside world, but must instead be copied
                 via ReflectionFactory.copyMethod.                
            </comment>
            <comment line="2545">
                Returns an array of &quot;root&quot; methods. These Method objects must NOT
                 be propagated to the outside world, but must instead be copied
                 via ReflectionFactory.copyMethod.                
            </comment>
            <comment line="2610">
                Helpers for fetchers of one field, method, or constructor                
            </comment>
            <comment line="2725">
                Other helpers and base implementation                
            </comment>
            <comment line="2863">
                Retrieves the desired assertion status of this class from the VM                
            </comment>
            <comment line="2882">
                Fetches the factory for reflective objects                
            </comment>
            <comment line="2893">
                To be able to query system properties as soon as they&apos;re available                
            </comment>
            <comment line="3082">
                Annotations cache                
            </comment>
            <comment line="3107">
                Annotation types cache their internal (AnnotationType) form                
            </comment>
            <implements interface="java.io.Serializable"/>
            <implements interface="java.lang.reflect.GenericDeclaration"/>
            <implements interface="java.lang.reflect.Type"/>
            <implements interface="java.lang.reflect.AnnotatedElement"/>
            <javadoc line="70">
                Instances of the class {@code Class} represent classes and
                  interfaces in a running Java application.  An enum is a kind of
                  class and an annotation is a kind of interface.  Every array also
                  belongs to a class that is reflected as a {@code Class} object
                  that is shared by all arrays with the same element type and number
                  of dimensions.  The primitive Java types ({@code boolean},{@code byte}, {@code char}, {@code short},{@code int}, {@code long}, {@code float}, and{@code double}), and the keyword {@code void} are also
                  represented as {@code Class} objects.
                  &lt;p&gt; {@code Class} has no public constructor. Instead {@code Class}objects are constructed automatically by the Java Virtual Machine as classes
                  are loaded and by calls to the {@code defineClass} method in the class
                  loader.
                  &lt;p&gt; The following example uses a {@code Class} object to print the
                  class name of an object:
                  &lt;p&gt; &lt;blockquote&gt;&lt;pre&gt;
                  void printClassName(Object obj) {
                  System.out.println(&quot;The class of &quot; + obj +
                  &quot; is &quot; + obj.getClass().getName());
                  }
                  &lt;/pre&gt;&lt;/blockquote&gt;
                  &lt;p&gt; It is also possible to get the {@code Class} object for a named
                  type (or for void) using a class literal.  See Section 15.8.2 of
                  &lt;cite&gt;The Java&amp;trade; Language Specification&lt;/cite&gt;.
                  For example:
                  &lt;p&gt; &lt;blockquote&gt;{@code System.out.println(&quot;The name of class Foo is: &quot;+Foo.class.getName());}&lt;/blockquote&gt;                
                <param>
                    <T>
                       the type of the class modeled by this {@code Class}object.  For example, the type of {@code String.class} is {@codeClass<String>}.  Use {@code Class<?>} if the class being modeled is
                      unknown.                    
                </param>
                <author>
                    unascribed                    
                </author>
                <see>
                    java.lang.ClassLoader#defineClass(byte[],int,int)                    
                </see>
                <since>
                    JDK1.0                    
                </since>
            </javadoc>
            <declaration name="ANNOTATION" type="int" line="120"/>
            <declaration name="ENUM" type="int" line="121"/>
            <declaration name="SYNTHETIC" type="int" line="122"/>
            <method name="registerNatives" type="void" line="124"/>
            <scope line="125"/>
            <method name="Class" type="constructor" line="133"/>
            <javadoc line="136">
                Converts the object to a string. The string representation is the
                  string &quot;class&quot; or &quot;interface&quot;, followed by a space, and then by the
                  fully qualified name of the class in the format returned by{@code getName}.  If this {@code Class} object represents a
                  primitive type, this method returns the name of the primitive type.  If
                  this {@code Class} object represents void this method returns
                  &quot;void&quot;.                
                <return>
                    a string representation of this class object.                    
                </return>
            </javadoc>
            <method name="toString" type="String" line="147"/>
            <javadoc line="153">
                Returns the {@code Class} object associated with the class or
                  interface with the given string name.  Invoking this method is
                  equivalent to:
                  &lt;blockquote&gt;{@code Class.forName(className, true, currentLoader)}&lt;/blockquote&gt;
                  where {@code currentLoader} denotes the defining class loader of
                  the current class.
                  &lt;p&gt; For example, the following code fragment returns the
                  runtime {@code Class} descriptor for the class named{@code java.lang.Thread}:
                  &lt;blockquote&gt;{@code Class t = Class.forName(&quot;java.lang.Thread&quot;)}&lt;/blockquote&gt;
                  &lt;p&gt;
                  A call to {@code forName(&quot;X&quot;)} causes the class named{@code X} to be initialized.                
                <param>
                    className   the fully qualified name of the desired class.                    
                </param>
                <return>
                    the {@code Class} object for the class with the
                      specified name.                    
                </return>
                <exception>
                    LinkageError if the linkage fails                    
                </exception>
                <exception>
                    ExceptionInInitializerError if the initialization provoked
                      by this method fails                    
                </exception>
                <exception>
                    ClassNotFoundException if the class cannot be located                    
                </exception>
            </javadoc>
            <method name="forName" type="Class<?>" line="185">
                <params>
                    <param name="className" type="String"/>
                </params>
            </method>
            <javadoc line="190">
                Returns the {@code Class} object associated with the class or
                  interface with the given string name, using the given class loader.
                  Given the fully qualified name for a class or interface (in the same
                  format returned by {@code getName}) this method attempts to
                  locate, load, and link the class or interface.  The specified class
                  loader is used to load the class or interface.  If the parameter{@code loader} is null, the class is loaded through the bootstrap
                  class loader.  The class is initialized only if the{@code initialize} parameter is {@code true} and if it has
                  not been initialized earlier.
                  &lt;p&gt; If {@code name} denotes a primitive type or void, an attempt
                  will be made to locate a user-defined class in the unnamed package whose
                  name is {@code name}. Therefore, this method cannot be used to
                  obtain any of the {@code Class} objects representing primitive
                  types or void.
                  &lt;p&gt; If {@code name} denotes an array class, the component type of
                  the array class is loaded but not initialized.
                  &lt;p&gt; For example, in an instance method the expression:
                  &lt;blockquote&gt;{@code Class.forName(&quot;Foo&quot;)}&lt;/blockquote&gt;
                  is equivalent to:
                  &lt;blockquote&gt;{@code Class.forName(&quot;Foo&quot;, true, this.getClass().getClassLoader())}&lt;/blockquote&gt;
                  Note that this method throws errors related to loading, linking or
                  initializing as specified in Sections 12.2, 12.3 and 12.4 of &lt;em&gt;The
                  Java Language Specification&lt;/em&gt;.
                  Note that this method does not check whether the requested class
                  is accessible to its caller.
                  &lt;p&gt; If the {@code loader} is {@code null}, and a security
                  manager is present, and the caller&apos;s class loader is not null, then this
                  method calls the security manager&apos;s {@code checkPermission} method
                  with a {@code RuntimePermission(&quot;getClassLoader&quot;)} permission to
                  ensure it&apos;s ok to access the bootstrap class loader.                
                <param>
                    name       fully qualified name of the desired class                    
                </param>
                <param>
                    initialize whether the class must be initialized                    
                </param>
                <param>
                    loader     class loader from which the class must be loaded                    
                </param>
                <return>
                    class object representing the desired class                    
                </return>
                <exception>
                    LinkageError if the linkage fails                    
                </exception>
                <exception>
                    ExceptionInInitializerError if the initialization provoked
                      by this method fails                    
                </exception>
                <exception>
                    ClassNotFoundException if the class cannot be located by
                      the specified class loader                    
                </exception>
                <see>
                    java.lang.Class#forName(String)                    
                </see>
                <see>
                    java.lang.ClassLoader                    
                </see>
                <since>
                    1.2                    
                </since>
            </javadoc>
            <method name="forName" type="Class<?>" line="253">
                <params>
                    <param name="name" type="String"/>
                    <param name="initialize" type="boolean"/>
                    <param name="loader" type="ClassLoader"/>
                </params>
                <scope line="254">
                    <declaration name="sm" type="SecurityManager" line="255"/>
                    <scope line="256">
                        <declaration name="ccl" type="ClassLoader" line="257"/>
                        <scope line="258"/>
                    </scope>
                </scope>
            </method>
            <method name="forName0" type="Class<?>" line="267"/>
            <javadoc line="267">
                Called after security checks have been made.                
            </javadoc>
            <javadoc line="272">
                Creates a new instance of the class represented by this {@code Class}object.  The class is instantiated as if by a {@code new}expression with an empty argument list.  The class is initialized if it
                  has not already been initialized.
                  &lt;p&gt;Note that this method propagates any exception thrown by the
                  nullary constructor, including a checked exception.  Use of
                  this method effectively bypasses the compile-time exception
                  checking that would otherwise be performed by the compiler.
                  The {@link java.lang.reflect.Constructor#newInstance(java.lang.Object...)Constructor.newInstance} method avoids this problem by wrapping
                  any exception thrown by the constructor in a (checked) {@link java.lang.reflect.InvocationTargetException}.                
                <return>
                    a newly allocated instance of the class represented by this
                      object.                    
                </return>
                <exception>
                    IllegalAccessException  if the class or its nullary
                      constructor is not accessible.                    
                </exception>
                <exception>
                    InstantiationExceptionif this {@code Class} represents an abstract class,
                      an interface, an array class, a primitive type, or void;
                      or if the class has no nullary constructor;
                      or if the instantiation fails for some other reason.                    
                </exception>
                <exception>
                    ExceptionInInitializerError if the initialization
                      provoked by this method fails.                    
                </exception>
                <exception>
                    SecurityExceptionIf a security manager, <i>s</i>, is present and any of the
                      following conditions is met:
                      <ul>
                      <li> invocation of{@link SecurityManager#checkMemberAccesss.checkMemberAccess(this, Member.PUBLIC)} denies
                      creation of new instances of this class
                      <li> the caller's class loader is not the same as or an
                      ancestor of the class loader for the current class and
                      invocation of {@link SecurityManager#checkPackageAccesss.checkPackageAccess()} denies access to the package
                      of this class
                      </ul>                    
                </exception>
            </javadoc>
            <method name="newInstance" type="T" line="321">
                <scope line="322"/>
            </method>
            <method name="newInstance0" type="T" line="330">
                <comment line="332">
                    NOTE: the following code may not be strictly correct under
                     the current Java memory model.                    
                </comment>
                <comment line="335">
                    Constructor lookup                    
                </comment>
                <comment line="345">
                    Disable accessibility checks on the constructor
                     since we have to do the security check here anyway
                     (the stack depth is wrong for the Constructor&apos;s
                     security check to work)                    
                </comment>
                <comment line="362">
                    Security check (same as in java.lang.reflect.Constructor)                    
                </comment>
                <comment line="371">
                    Run constructor                    
                </comment>
                <comment line="376">
                    Not reached                    
                </comment>
                <scope line="335">
                    <scope line="336"/>
                    <scope line="341">
                        <declaration name="empty" type="Class&lt;?&gt;[]" line="342"/>
                        <declaration name="c" type="Constructor&lt;T&gt;" line="343"/>
                        <anonymous_class line="349">
                            <method name="run" type="Void" line="350"/>
                        </anonymous_class>
                    </scope>
                    <scope line="356"/>
                </scope>
                <declaration name="tmpConstructor" type="Constructor&lt;T&gt;" line="360"/>
                <declaration name="modifiers" type="int" line="362"/>
                <scope line="363">
                    <declaration name="caller" type="Class&lt;?&gt;" line="364"/>
                    <scope line="365"/>
                </scope>
                <scope line="371"/>
                <scope line="373"/>
            </method>
            <declaration name="cachedConstructor" type="Constructor&lt;T&gt;" line="379"/>
            <declaration name="newInstanceCallerCache" type="Class&lt;?&gt;" line="380"/>
            <method name="isInstance" type="boolean" line="383"/>
            <javadoc line="383">
                Determines if the specified {@code Object} is assignment-compatible
                  with the object represented by this {@code Class}.  This method is
                  the dynamic equivalent of the Java language {@code instanceof}operator. The method returns {@code true} if the specified{@code Object} argument is non-null and can be cast to the
                  reference type represented by this {@code Class} object without
                  raising a {@code ClassCastException.} It returns {@code false}otherwise.
                  &lt;p&gt; Specifically, if this {@code Class} object represents a
                  declared class, this method returns {@code true} if the specified{@code Object} argument is an instance of the represented class (or
                  of any of its subclasses); it returns {@code false} otherwise. If
                  this {@code Class} object represents an array class, this method
                  returns {@code true} if the specified {@code Object} argument
                  can be converted to an object of the array class by an identity
                  conversion or by a widening reference conversion; it returns{@code false} otherwise. If this {@code Class} object
                  represents an interface, this method returns {@code true} if the
                  class or any superclass of the specified {@code Object} argument
                  implements this interface; it returns {@code false} otherwise. If
                  this {@code Class} object represents a primitive type, this method
                  returns {@code false}.                
                <param>
                    obj the object to check                    
                </param>
                <return>
                    true if {@code obj} is an instance of this class                    
                </return>
                <since>
                    JDK1.1                    
                </since>
            </javadoc>
            <method name="isAssignableFrom" type="boolean" line="416"/>
            <javadoc line="416">
                Determines if the class or interface represented by this{@code Class} object is either the same as, or is a superclass or
                  superinterface of, the class or interface represented by the specified{@code Class} parameter. It returns {@code true} if so;
                  otherwise it returns {@code false}. If this {@code Class}object represents a primitive type, this method returns{@code true} if the specified {@code Class} parameter is
                  exactly this {@code Class} object; otherwise it returns{@code false}.
                  &lt;p&gt; Specifically, this method tests whether the type represented by the
                  specified {@code Class} parameter can be converted to the type
                  represented by this {@code Class} object via an identity conversion
                  or via a widening reference conversion. See &lt;em&gt;The Java Language
                  Specification&lt;/em&gt;, sections 5.1.1 and 5.1.4 , for details.                
                <param>
                    cls the {@code Class} object to be checked                    
                </param>
                <return>
                    the {@code boolean} value indicating whether objects of the
                      type {@code cls} can be assigned to objects of this class                    
                </return>
                <exception>
                    NullPointerException if the specified Class parameter is
                      null.                    
                </exception>
                <since>
                    JDK1.1                    
                </since>
            </javadoc>
            <method name="isInterface" type="boolean" line="443"/>
            <javadoc line="443">
                Determines if the specified {@code Class} object represents an
                  interface type.                
                <return>
                    {@code true} if this object represents an interface;{@code false} otherwise.                    
                </return>
            </javadoc>
            <method name="isArray" type="boolean" line="453"/>
            <javadoc line="453">
                Determines if this {@code Class} object represents an array class.                
                <return>
                    {@code true} if this object represents an array class;{@code false} otherwise.                    
                </return>
                <since>
                    JDK1.1                    
                </since>
            </javadoc>
            <method name="isPrimitive" type="boolean" line="463"/>
            <javadoc line="463">
                Determines if the specified {@code Class} object represents a
                  primitive type.
                  &lt;p&gt; There are nine predefined {@code Class} objects to represent
                  the eight primitive types and void.  These are created by the Java
                  Virtual Machine, and have the same names as the primitive types that
                  they represent, namely {@code boolean}, {@code byte},{@code char}, {@code short}, {@code int},{@code long}, {@code float}, and {@code double}.
                  &lt;p&gt; These objects may only be accessed via the following public static
                  final variables, and are the only {@code Class} objects for which
                  this method returns {@code true}.                
                <return>
                    true if and only if this class represents a primitive type                    
                </return>
                <see>
                    java.lang.Boolean#TYPE                    
                </see>
                <see>
                    java.lang.Character#TYPE                    
                </see>
                <see>
                    java.lang.Byte#TYPE                    
                </see>
                <see>
                    java.lang.Short#TYPE                    
                </see>
                <see>
                    java.lang.Integer#TYPE                    
                </see>
                <see>
                    java.lang.Long#TYPE                    
                </see>
                <see>
                    java.lang.Float#TYPE                    
                </see>
                <see>
                    java.lang.Double#TYPE                    
                </see>
                <see>
                    java.lang.Void#TYPE                    
                </see>
                <since>
                    JDK1.1                    
                </since>
            </javadoc>
            <javadoc line="493">
                Returns true if this {@code Class} object represents an annotation
                  type.  Note that if this method returns true, {@link #isInterface()}would also return true, as all annotation types are also interfaces.                
                <return>
                    {@code true} if this class object represents an annotation
                      type; {@code false} otherwise                    
                </return>
                <since>
                    1.5                    
                </since>
            </javadoc>
            <method name="isAnnotation" type="boolean" line="502"/>
            <javadoc line="506">
                Returns {@code true} if this class is a synthetic class;
                  returns {@code false} otherwise.                
                <return>
                    {@code true} if and only if this class is a synthetic class as
                      defined by the Java Language Specification.                    
                </return>
                <since>
                    1.5                    
                </since>
            </javadoc>
            <method name="isSynthetic" type="boolean" line="513"/>
            <javadoc line="517">
                Returns the  name of the entity (class, interface, array class,
                  primitive type, or void) represented by this {@code Class} object,
                  as a {@code String}.
                  &lt;p&gt; If this class object represents a reference type that is not an
                  array type then the binary name of the class is returned, as specified
                  by
                  &lt;cite&gt;The Java&amp;trade; Language Specification&lt;/cite&gt;.
                  &lt;p&gt; If this class object represents a primitive type or void, then the
                  name returned is a {@code String} equal to the Java language
                  keyword corresponding to the primitive type or void.
                  &lt;p&gt; If this class object represents a class of arrays, then the internal
                  form of the name consists of the name of the element type preceded by
                  one or more &apos;{@code [}&apos; characters representing the depth of the array
                  nesting.  The encoding of element type names is as follows:
                  &lt;blockquote&gt;&lt;table summary=&quot;Element types and encodings&quot;&gt;
                  &lt;tr&gt;&lt;th&gt; Element Type &lt;th&gt; &amp;nbsp;&amp;nbsp;&amp;nbsp; &lt;th&gt; Encoding
                  &lt;tr&gt;&lt;td&gt; boolean      &lt;td&gt; &amp;nbsp;&amp;nbsp;&amp;nbsp; &lt;td align=center&gt; Z
                  &lt;tr&gt;&lt;td&gt; byte         &lt;td&gt; &amp;nbsp;&amp;nbsp;&amp;nbsp; &lt;td align=center&gt; B
                  &lt;tr&gt;&lt;td&gt; char         &lt;td&gt; &amp;nbsp;&amp;nbsp;&amp;nbsp; &lt;td align=center&gt; C
                  &lt;tr&gt;&lt;td&gt; class or interface
                  &lt;td&gt; &amp;nbsp;&amp;nbsp;&amp;nbsp; &lt;td align=center&gt; L&lt;i&gt;classname&lt;/i&gt;;
                  &lt;tr&gt;&lt;td&gt; double       &lt;td&gt; &amp;nbsp;&amp;nbsp;&amp;nbsp; &lt;td align=center&gt; D
                  &lt;tr&gt;&lt;td&gt; float        &lt;td&gt; &amp;nbsp;&amp;nbsp;&amp;nbsp; &lt;td align=center&gt; F
                  &lt;tr&gt;&lt;td&gt; int          &lt;td&gt; &amp;nbsp;&amp;nbsp;&amp;nbsp; &lt;td align=center&gt; I
                  &lt;tr&gt;&lt;td&gt; long         &lt;td&gt; &amp;nbsp;&amp;nbsp;&amp;nbsp; &lt;td align=center&gt; J
                  &lt;tr&gt;&lt;td&gt; short        &lt;td&gt; &amp;nbsp;&amp;nbsp;&amp;nbsp; &lt;td align=center&gt; S
                  &lt;/table&gt;&lt;/blockquote&gt;
                  &lt;p&gt; The class or interface name &lt;i&gt;classname&lt;/i&gt; is the binary name of
                  the class specified above.
                  &lt;p&gt; Examples:
                  &lt;blockquote&gt;&lt;pre&gt;
                  String.class.getName()
                  returns &quot;java.lang.String&quot;
                  byte.class.getName()
                  returns &quot;byte&quot;
                  (new Object[3]).getClass().getName()
                  returns &quot;[Ljava.lang.Object;&quot;
                  (new int[3][4][5][6][7][8][9]).getClass().getName()
                  returns &quot;[[[[[[[I&quot;
                  &lt;/pre&gt;&lt;/blockquote&gt;                
                <return>
                    the name of the class or interface
                      represented by this object.                    
                </return>
            </javadoc>
            <method name="getName" type="String" line="568">
                <declaration name="name" type="String" line="569"/>
            </method>
            <declaration name="name" type="String" line="576"/>
            <method name="getName0" type="String" line="577"/>
            <javadoc line="579">
                Returns the class loader for the class.  Some implementations may use
                  null to represent the bootstrap class loader. This method will return
                  null in such implementations if this class was loaded by the bootstrap
                  class loader.
                  &lt;p&gt; If a security manager is present, and the caller&apos;s class loader is
                  not null and the caller&apos;s class loader is not the same as or an ancestor of
                  the class loader for the class whose class loader is requested, then
                  this method calls the security manager&apos;s {@code checkPermission}method with a {@code RuntimePermission(&quot;getClassLoader&quot;)}permission to ensure it&apos;s ok to access the class loader for the class.
                  &lt;p&gt;If this object
                  represents a primitive type or void, null is returned.                
                <return>
                    the class loader that loaded the class or interface
                      represented by this object.                    
                </return>
                <throws>
                    SecurityExceptionif a security manager exists and its{@code checkPermission} method denies
                      access to the class loader for the class.                    
                </throws>
                <see>
                    java.lang.ClassLoader                    
                </see>
                <see>
                    SecurityManager#checkPermission                    
                </see>
                <see>
                    java.lang.RuntimePermission                    
                </see>
            </javadoc>
            <method name="getClassLoader" type="ClassLoader" line="605">
                <declaration name="cl" type="ClassLoader" line="606"/>
                <declaration name="sm" type="SecurityManager" line="609"/>
                <scope line="610">
                    <declaration name="ccl" type="ClassLoader" line="611"/>
                    <scope line="612"/>
                </scope>
            </method>
            <method name="getClassLoader0" type="ClassLoader" line="620"/>
            <javadoc line="623">
                Returns an array of {@code TypeVariable} objects that represent the
                  type variables declared by the generic declaration represented by this{@code GenericDeclaration} object, in declaration order.  Returns an
                  array of length 0 if the underlying generic declaration declares no type
                  variables.                
                <return>
                    an array of {@code TypeVariable} objects that represent
                      the type variables declared by this generic declaration                    
                </return>
                <throws>
                    java.lang.reflect.GenericSignatureFormatError if the generic
                      signature of this generic declaration does not conform to
                      the format specified in
                      <cite>The Java&trade; Virtual Machine Specification</cite>                    
                </throws>
                <since>
                    1.5                    
                </since>
            </javadoc>
            <method name="getTypeParameters" type="TypeVariable<Class<T>>[]" line="638"/>
            <method name="getSuperclass" type="Class<? super T>" line="646"/>
            <javadoc line="646">
                Returns the {@code Class} representing the superclass of the entity
                  (class, interface, primitive type or void) represented by this{@code Class}.  If this {@code Class} represents either the{@code Object} class, an interface, a primitive type, or void, then
                  null is returned.  If this object represents an array class then the{@code Class} object representing the {@code Object} class is
                  returned.                
                <return>
                    the superclass of the class represented by this object.                    
                </return>
            </javadoc>
            <javadoc line="660">
                Returns the {@code Type} representing the direct superclass of
                  the entity (class, interface, primitive type or void) represented by
                  this {@code Class}.
                  &lt;p&gt;If the superclass is a parameterized type, the {@code Type}object returned must accurately reflect the actual type
                  parameters used in the source code. The parameterized type
                  representing the superclass is created if it had not been
                  created before. See the declaration of {@link java.lang.reflect.ParameterizedType ParameterizedType} for the
                  semantics of the creation process for parameterized types.  If
                  this {@code Class} represents either the {@code Object}class, an interface, a primitive type, or void, then null is
                  returned.  If this object represents an array class then the{@code Class} object representing the {@code Object} class is
                  returned.                
                <throws>
                    java.lang.reflect.GenericSignatureFormatError if the generic
                      class signature does not conform to the format specified in
                      <cite>The Java&trade; Virtual Machine Specification</cite>                    
                </throws>
                <throws>
                    TypeNotPresentException if the generic superclass
                      refers to a non-existent type declaration                    
                </throws>
                <throws>
                    java.lang.reflect.MalformedParameterizedTypeException if the
                      generic superclass refers to a parameterized type that cannot be
                      instantiated  for any reason                    
                </throws>
                <return>
                    the superclass of the class represented by this object                    
                </return>
                <since>
                    1.5                    
                </since>
            </javadoc>
            <method name="getGenericSuperclass" type="Type" line="689">
                <comment line="692">
                    Historical irregularity:
                     Generic signature marks interfaces with superclass = Object
                     but this API returns null for interfaces                    
                </comment>
                <scope line="690"/>
            </method>
            <javadoc line="701">
                Gets the package for this class.  The class loader of this class is used
                  to find the package.  If the class was loaded by the bootstrap class
                  loader the set of packages loaded from CLASSPATH is searched to find the
                  package of the class. Null is returned if no package object was created
                  by the class loader of this class.
                  &lt;p&gt; Packages have attributes for versions and specifications only if the
                  information was defined in the manifests that accompany the classes, and
                  if the class loader created the package instance with the attributes
                  from the manifest.                
                <return>
                    the package of the class, or null if no package
                      information is available from the archive or codebase.                    
                </return>
            </javadoc>
            <method name="getPackage" type="Package" line="716"/>
            <method name="getInterfaces" type="Class<?>[]" line="721"/>
            <javadoc line="721">
                Determines the interfaces implemented by the class or interface
                  represented by this object.
                  &lt;p&gt; If this object represents a class, the return value is an array
                  containing objects representing all interfaces implemented by the
                  class. The order of the interface objects in the array corresponds to
                  the order of the interface names in the {@code implements} clause
                  of the declaration of the class represented by this object. For
                  example, given the declaration:
                  &lt;blockquote&gt;{@code} class Shimmer implements FloorWax, DessertTopping 
                  ... }}
                  &lt;/blockquote&gt;
                  suppose the value of {@code s} is an instance of{@code Shimmer}; the value of the expression:
                  &lt;blockquote&gt;{@code s.getClass().getInterfaces()[0]}&lt;/blockquote&gt;
                  is the {@code Class} object that represents interface{@code FloorWax}; and the value of:
                  &lt;blockquote&gt;{@code s.getClass().getInterfaces()[1]}&lt;/blockquote&gt;
                  is the {@code Class} object that represents interface{@code DessertTopping}.
                  &lt;p&gt; If this object represents an interface, the array contains objects
                  representing all interfaces extended by the interface. The order of the
                  interface objects in the array corresponds to the order of the interface
                  names in the {@code extends} clause of the declaration of the
                  interface represented by this object.
                  &lt;p&gt; If this object represents a class or interface that implements no
                  interfaces, the method returns an array of length 0.
                  &lt;p&gt; If this object represents a primitive type or void, the method
                  returns an array of length 0.                
                <return>
                    an array of interfaces implemented by this class.                    
                </return>
            </javadoc>
            <javadoc line="763">
                Returns the {@code Type}s representing the interfaces
                  directly implemented by the class or interface represented by
                  this object.
                  &lt;p&gt;If a superinterface is a parameterized type, the{@code Type} object returned for it must accurately reflect
                  the actual type parameters used in the source code. The
                  parameterized type representing each superinterface is created
                  if it had not been created before. See the declaration of{@link java.lang.reflect.ParameterizedType ParameterizedType}for the semantics of the creation process for parameterized
                  types.
                  &lt;p&gt; If this object represents a class, the return value is an
                  array containing objects representing all interfaces
                  implemented by the class. The order of the interface objects in
                  the array corresponds to the order of the interface names in
                  the {@code implements} clause of the declaration of the class
                  represented by this object.  In the case of an array class, the
                  interfaces {@code Cloneable} and {@code Serializable} are
                  returned in that order.
                  &lt;p&gt;If this object represents an interface, the array contains
                  objects representing all interfaces directly extended by the
                  interface.  The order of the interface objects in the array
                  corresponds to the order of the interface names in the{@code extends} clause of the declaration of the interface
                  represented by this object.
                  &lt;p&gt;If this object represents a class or interface that
                  implements no interfaces, the method returns an array of length
                  0.
                  &lt;p&gt;If this object represents a primitive type or void, the
                  method returns an array of length 0.                
                <throws>
                    java.lang.reflect.GenericSignatureFormatErrorif the generic class signature does not conform to the format
                      specified in
                      <cite>The Java&trade; Virtual Machine Specification</cite>                    
                </throws>
                <throws>
                    TypeNotPresentException if any of the generic
                      superinterfaces refers to a non-existent type declaration                    
                </throws>
                <throws>
                    java.lang.reflect.MalformedParameterizedTypeExceptionif any of the generic superinterfaces refer to a parameterized
                      type that cannot be instantiated for any reason                    
                </throws>
                <return>
                    an array of interfaces implemented by this class                    
                </return>
                <since>
                    1.5                    
                </since>
            </javadoc>
            <method name="getGenericInterfaces" type="Type[]" line="812"/>
            <method name="getComponentType" type="Class<?>" line="820"/>
            <javadoc line="820">
                Returns the {@code Class} representing the component type of an
                  array.  If this class does not represent an array class this method
                  returns null.                
                <return>
                    the {@code Class} representing the component type of this
                      class if this class is an array                    
                </return>
                <see>
                    java.lang.reflect.Array                    
                </see>
                <since>
                    JDK1.1                    
                </since>
            </javadoc>
            <method name="getModifiers" type="int" line="833"/>
            <javadoc line="833">
                Returns the Java language modifiers for this class or interface, encoded
                  in an integer. The modifiers consist of the Java Virtual Machine&apos;s
                  constants for {@code public}, {@code protected},{@code private}, {@code final}, {@code static},{@code abstract} and {@code interface}; they should be decoded
                  using the methods of class {@code Modifier}.
                  &lt;p&gt; If the underlying class is an array class, then its{@code public}, {@code private} and {@code protected}modifiers are the same as those of its component type.  If this{@code Class} represents a primitive type or void, its{@code public} modifier is always {@code true}, and its{@code protected} and {@code private} modifiers are always{@code false}. If this object represents an array class, a
                  primitive type or void, then its {@code final} modifier is always{@code true} and its interface modifier is always{@code false}. The values of its other modifiers are not determined
                  by this specification.
                  &lt;p&gt; The modifier encodings are defined in &lt;em&gt;The Java Virtual Machine
                  Specification&lt;/em&gt;, table 4.1.                
                <return>
                    the {@code int} representing the modifiers for this class                    
                </return>
                <see>
                    java.lang.reflect.Modifier                    
                </see>
                <since>
                    JDK1.1                    
                </since>
            </javadoc>
            <method name="getSigners" type="Object[]" line="863"/>
            <javadoc line="863">
                Gets the signers of this class.                
                <return>
                    the signers of this class, or null if there are no signers.  In
                      particular, this method returns null if this object represents
                      a primitive type or void.                    
                </return>
                <since>
                    JDK1.1                    
                </since>
            </javadoc>
            <method name="setSigners" type="void" line="874"/>
            <javadoc line="874">
                Set the signers of this class.                
            </javadoc>
            <javadoc line="880">
                If this {@code Class} object represents a local or anonymous
                  class within a method, returns a {@link java.lang.reflect.Method Method} object representing the
                  immediately enclosing method of the underlying class. Returns{@code null} otherwise.
                  In particular, this method returns {@code null} if the underlying
                  class is a local or anonymous class immediately enclosed by a type
                  declaration, instance initializer or static initializer.                
                <return>
                    the immediately enclosing method of the underlying class, if
                      that class is a local or anonymous class; otherwise {@code null}.                    
                </return>
                <since>
                    1.5                    
                </since>
            </javadoc>
            <method name="getEnclosingMethod" type="Method" line="895">
                <comment line="911">
                    Convert Types to Classes; returned types *should*
                     be class objects since the methodDescriptor&apos;s used
                     don&apos;t have generics information                    
                </comment>
                <comment line="917">
                    Loop over all declared methods; match method name,
                     number of and type of parameters, and return
                     type.  Matching return type is also necessary
                     because of covariant returns, etc.                    
                </comment>
                <comment line="935">
                    finally, check return type                    
                </comment>
                <declaration name="enclosingInfo" type="EnclosingMethodInfo" line="896"/>
                <scope line="900">
                    <declaration name="typeInfo" type="MethodRepository" line="904"/>
                    <declaration name="returnType" type="Class&lt;?&gt;" line="906"/>
                    <declaration name="parameterTypes" type="Type[]" line="907"/>
                    <declaration name="parameterClasses" type="Class&lt;?&gt;[]" line="908"/>
                    <scope line="922">
                        <scope line="923">
                            <declaration name="candidateParamClasses" type="Class&lt;?&gt;[]" line="924"/>
                            <scope line="925">
                                <declaration name="matches" type="boolean" line="926"/>
                                <scope line="927">
                                    <scope line="928"/>
                                </scope>
                                <scope line="934"/>
                            </scope>
                        </scope>
                    </scope>
                </scope>
            </method>
            <method name="getEnclosingMethod0" type="Object[]" line="946"/>
            <method name="getEnclosingMethodInfo" type="EnclosingMethodInfo" line="948">
                <declaration name="enclosingInfo" type="Object[]" line="949"/>
                <scope line="952"/>
            </method>
            <class name="EnclosingMethodInfo" line="957">
                <comment line="2217">
                    Caches for certain reflective results                    
                </comment>
                <declaration name="enclosingClass" type="Class&lt;?&gt;" line="958"/>
                <declaration name="name" type="String" line="959"/>
                <declaration name="descriptor" type="String" line="960"/>
                <method name="EnclosingMethodInfo" type="constructor" line="962">
                    <params>
                        <param name="enclosingInfo" type="Object[]"/>
                    </params>
                    <comment line="967">
                        The array is expected to have three elements:                        
                    </comment>
                    <comment line="969">
                        the immediately enclosing class                        
                    </comment>
                    <comment line="973">
                        the immediately enclosing method or constructor&apos;s
                         name (can be null).                        
                    </comment>
                    <comment line="977">
                        the immediately enclosing method or constructor&apos;s
                         descriptor (null iff name is).                        
                    </comment>
                    <scope line="965"/>
                    <scope line="980"/>
                </method>
                <method name="isPartial" type="boolean" line="985"/>
                <method name="isConstructor" type="boolean" line="989"/>
                <method name="isMethod" type="boolean" line="991"/>
                <method name="getEnclosingClass" type="Class<?>" line="993"/>
                <method name="getName" type="String" line="995"/>
                <method name="getDescriptor" type="String" line="997"/>
            </class>
            <method name="toClass" type="Class<?>" line="1001">
                <params>
                    <param name="o" type="Type"/>
                </params>
            </method>
            <javadoc line="1009">
                If this {@code Class} object represents a local or anonymous
                  class within a constructor, returns a {@link java.lang.reflect.Constructor Constructor} object representing
                  the immediately enclosing constructor of the underlying
                  class. Returns {@code null} otherwise.  In particular, this
                  method returns {@code null} if the underlying class is a local
                  or anonymous class immediately enclosed by a type declaration,
                  instance initializer or static initializer.                
                <return>
                    the immediately enclosing constructor of the underlying class, if
                      that class is a local or anonymous class; otherwise {@code null}.                    
                </return>
                <since>
                    1.5                    
                </since>
            </javadoc>
            <method name="getEnclosingConstructor" type="Constructor<?>" line="1023">
                <comment line="1038">
                    Convert Types to Classes; returned types *should*
                     be class objects since the methodDescriptor&apos;s used
                     don&apos;t have generics information                    
                </comment>
                <comment line="1044">
                    Loop over all declared constructors; match number
                     of and type of parameters.                    
                </comment>
                <declaration name="enclosingInfo" type="EnclosingMethodInfo" line="1024"/>
                <scope line="1028">
                    <declaration name="typeInfo" type="ConstructorRepository" line="1032"/>
                    <declaration name="parameterTypes" type="Type[]" line="1034"/>
                    <declaration name="parameterClasses" type="Class&lt;?&gt;[]" line="1035"/>
                    <scope line="1047">
                        <declaration name="candidateParamClasses" type="Class&lt;?&gt;[]" line="1048"/>
                        <scope line="1049">
                            <declaration name="matches" type="boolean" line="1050"/>
                            <scope line="1051">
                                <scope line="1052"/>
                            </scope>
                        </scope>
                    </scope>
                </scope>
            </method>
            <method name="getDeclaringClass" type="Class<?>" line="1068"/>
            <javadoc line="1068">
                If the class or interface represented by this {@code Class} object
                  is a member of another class, returns the {@code Class} object
                  representing the class in which it was declared.  This method returns
                  null if this class or interface is not a member of any other class.  If
                  this {@code Class} object represents an array class, a primitive
                  type, or void,then this method returns null.                
                <return>
                    the declaring class for this class                    
                </return>
                <since>
                    JDK1.1                    
                </since>
            </javadoc>
            <javadoc line="1082">
                Returns the immediately enclosing class of the underlying
                  class.  If the underlying class is a top level class this
                  method returns {@code null}.                
                <return>
                    the immediately enclosing class of the underlying class                    
                </return>
                <since>
                    1.5                    
                </since>
            </javadoc>
            <method name="getEnclosingClass" type="Class<?>" line="1089">
                <comment line="1091">
                    There are five kinds of classes (or interfaces):
                     a) Top level classes
                     b) Nested classes (static member classes)
                     c) Inner classes (non-static member classes)
                     d) Local classes (named classes declared within a method)
                     e) Anonymous classes                    
                </comment>
                <comment line="1099">
                    JVM Spec 4.8.6: A class must have an EnclosingMethod
                     attribute if and only if it is a local class or an
                     anonymous class.                    
                </comment>
                <comment line="1105">
                    This is a top level or a nested class or an inner class (a, b, or c)                    
                </comment>
                <comment line="1109">
                    This is a local class or an anonymous class (d or e)                    
                </comment>
                <declaration name="enclosingInfo" type="EnclosingMethodInfo" line="1101"/>
                <scope line="1103"/>
                <scope line="1106">
                    <declaration name="enclosingClass" type="Class&lt;?&gt;" line="1107"/>
                </scope>
            </method>
            <javadoc line="1116">
                Returns the simple name of the underlying class as given in the
                  source code. Returns an empty string if the underlying class is
                  anonymous.
                  &lt;p&gt;The simple name of an array is the simple name of the
                  component type with &quot;[]&quot; appended.  In particular the simple
                  name of an array whose component type is anonymous is &quot;[]&quot;.                
                <return>
                    the simple name of the underlying class                    
                </return>
                <since>
                    1.5                    
                </since>
            </javadoc>
            <method name="getSimpleName" type="String" line="1128">
                <comment line="1134">
                    top level class                    
                </comment>
                <comment line="1136">
                    strip the package name                    
                </comment>
                <comment line="1138">
                    According to JLS3 &quot;Binary Compatibility&quot; (13.1) the binary
                     name of non-package classes (not top level) is the binary
                     name of the immediately enclosing class followed by a &apos;$&apos; followed by:
                     (for nested and inner classes): the simple name.
                     (for local classes): 1 or more digits followed by the simple name.
                     (for anonymous classes): 1 or more digits.                    
                </comment>
                <comment line="1145">
                    Since getSimpleBinaryName() will strip the binary name of
                     the immediatly enclosing class, we are now looking at a
                     string that matches the regular expression &quot;\$[0-9]*&quot;
                     followed by a simple name (considering the simple of an
                     anonymous class to be the empty string).                    
                </comment>
                <comment line="1151">
                    Remove leading &quot;\$[0-9]*&quot; from the name                    
                </comment>
                <comment line="1158">
                    Eventually, this is the empty string iff this is an anonymous class                    
                </comment>
                <declaration name="simpleName" type="String" line="1132"/>
                <scope line="1133"/>
                <declaration name="length" type="int" line="1151"/>
                <declaration name="index" type="int" line="1154"/>
            </method>
            <javadoc line="1161">
                Character.isDigit answers {@code true} to some non-ascii
                  digits.  This one does not.                
            </javadoc>
            <method name="isAsciiDigit" type="boolean" line="1165">
                <params>
                    <param name="c" type="char"/>
                </params>
            </method>
            <javadoc line="1169">
                Returns the canonical name of the underlying class as
                  defined by the Java Language Specification.  Returns null if
                  the underlying class does not have a canonical name (i.e., if
                  it is a local or anonymous class or an array whose component
                  type does not have a canonical name).                
                <return>
                    the canonical name of the underlying class if it exists, and{@code null} otherwise.                    
                </return>
                <since>
                    1.5                    
                </since>
            </javadoc>
            <method name="getCanonicalName" type="String" line="1179">
                <comment line="1191">
                    top level class                    
                </comment>
                <scope line="1180">
                    <declaration name="canonicalName" type="String" line="1181"/>
                </scope>
                <declaration name="enclosingClass" type="Class&lt;?&gt;" line="1189"/>
                <scope line="1190"/>
                <scope line="1192">
                    <declaration name="enclosingName" type="String" line="1193"/>
                </scope>
            </method>
            <javadoc line="1200">
                Returns {@code true} if and only if the underlying class
                  is an anonymous class.                
                <return>
                    {@code true} if and only if this class is an anonymous class.                    
                </return>
                <since>
                    1.5                    
                </since>
            </javadoc>
            <method name="isAnonymousClass" type="boolean" line="1207"/>
            <javadoc line="1211">
                Returns {@code true} if and only if the underlying class
                  is a local class.                
                <return>
                    {@code true} if and only if this class is a local class.                    
                </return>
                <since>
                    1.5                    
                </since>
            </javadoc>
            <method name="isLocalClass" type="boolean" line="1218"/>
            <javadoc line="1222">
                Returns {@code true} if and only if the underlying class
                  is a member class.                
                <return>
                    {@code true} if and only if this class is a member class.                    
                </return>
                <since>
                    1.5                    
                </since>
            </javadoc>
            <method name="isMemberClass" type="boolean" line="1229"/>
            <javadoc line="1233">
                Returns the &quot;simple binary name&quot; of the underlying class, i.e.,
                  the binary name without the leading enclosing class name.
                  Returns {@code null} if the underlying class is a top level
                  class.                
            </javadoc>
            <method name="getSimpleBinaryName" type="String" line="1239">
                <comment line="1242">
                    top level class                    
                </comment>
                <comment line="1244">
                    Otherwise, strip the enclosing class&apos; name                    
                </comment>
                <declaration name="enclosingClass" type="Class&lt;?&gt;" line="1240"/>
                <scope line="1244"/>
                <scope line="1246"/>
            </method>
            <javadoc line="1251">
                Returns {@code true} if this is a local class or an anonymous
                  class.  Returns {@code false} otherwise.                
            </javadoc>
            <method name="isLocalOrAnonymousClass" type="boolean" line="1255">
                <comment line="1257">
                    JVM Spec 4.8.6: A class must have an EnclosingMethod
                     attribute if and only if it is a local class or an
                     anonymous class.                    
                </comment>
            </method>
            <javadoc line="1262">
                Returns an array containing {@code Class} objects representing all
                  the public classes and interfaces that are members of the class
                  represented by this {@code Class} object.  This includes public
                  class and interface members inherited from superclasses and public class
                  and interface members declared by the class.  This method returns an
                  array of length 0 if this {@code Class} object has no public member
                  classes or interfaces.  This method also returns an array of length 0 if
                  this {@code Class} object represents a primitive type, an array
                  class, or void.                
                <return>
                    the array of {@code Class} objects representing the public
                      members of this class                    
                </return>
                <exception>
                    SecurityExceptionIf a security manager, <i>s</i>, is present and any of the
                      following conditions is met:
                      <ul>
                      <li> invocation of{@link SecurityManager#checkMemberAccesss.checkMemberAccess(this, Member.PUBLIC)} method
                      denies access to the classes within this class
                      <li> the caller's class loader is not the same as or an
                      ancestor of the class loader for the current class and
                      invocation of {@link SecurityManager#checkPackageAccesss.checkPackageAccess()} denies access to the package
                      of this class
                      </ul>                    
                </exception>
                <since>
                    JDK1.1                    
                </since>
            </javadoc>
            <method name="getClasses" type="Class<?>[]" line="1296">
                <comment line="1298">
                    be very careful not to change the stack depth of this
                     checkMemberAccess call for security reasons
                     see java.lang.SecurityManager.checkMemberAccess                    
                </comment>
                <comment line="1303">
                    Privileged so this implementation can look at DECLARED classes,
                     something the caller might not have privilege to do.  The code here
                     is allowed to look at DECLARED classes because (1) it does not hand
                     out anything other than public members and (2) public member access
                     has already been ok&apos;d by the SecurityManager.                    
                </comment>
                <anonymous_class line="1309">
                    <method name="run" type="Class[]" line="1310">
                        <declaration name="list" type="List&lt;Class&lt;?&gt;&gt;" line="1311"/>
                        <declaration name="currentClass" type="Class&lt;?&gt;" line="1312"/>
                        <scope line="1313">
                            <declaration name="members" type="Class&lt;?&gt;[]" line="1314"/>
                            <scope line="1315">
                                <scope line="1316"/>
                            </scope>
                        </scope>
                    </method>
                </anonymous_class>
            </method>
            <javadoc line="1328">
                Returns an array containing {@code Field} objects reflecting all
                  the accessible public fields of the class or interface represented by
                  this {@code Class} object.  The elements in the array returned are
                  not sorted and are not in any particular order.  This method returns an
                  array of length 0 if the class or interface has no accessible public
                  fields, or if it represents an array class, a primitive type, or void.
                  &lt;p&gt; Specifically, if this {@code Class} object represents a class,
                  this method returns the public fields of this class and of all its
                  superclasses.  If this {@code Class} object represents an
                  interface, this method returns the fields of this interface and of all
                  its superinterfaces.
                  &lt;p&gt; The implicit length field for array class is not reflected by this
                  method. User code should use the methods of class {@code Array} to
                  manipulate arrays.
                  &lt;p&gt; See &lt;em&gt;The Java Language Specification&lt;/em&gt;, sections 8.2 and 8.3.                
                <return>
                    the array of {@code Field} objects representing the
                      public fields                    
                </return>
                <exception>
                    SecurityExceptionIf a security manager, <i>s</i>, is present and any of the
                      following conditions is met:
                      <ul>
                      <li> invocation of{@link SecurityManager#checkMemberAccesss.checkMemberAccess(this, Member.PUBLIC)} denies
                      access to the fields within this class
                      <li> the caller's class loader is not the same as or an
                      ancestor of the class loader for the current class and
                      invocation of {@link SecurityManager#checkPackageAccesss.checkPackageAccess()} denies access to the package
                      of this class
                      </ul>                    
                </exception>
                <since>
                    JDK1.1                    
                </since>
            </javadoc>
            <method name="getFields" type="Field[]" line="1371">
                <comment line="1373">
                    be very careful not to change the stack depth of this
                     checkMemberAccess call for security reasons
                     see java.lang.SecurityManager.checkMemberAccess                    
                </comment>
            </method>
            <javadoc line="1380">
                Returns an array containing {@code Method} objects reflecting all
                  the public &lt;em&gt;member&lt;/em&gt; methods of the class or interface represented
                  by this {@code Class} object, including those declared by the class
                  or interface and those inherited from superclasses and
                  superinterfaces.  Array classes return all the (public) member methods
                  inherited from the {@code Object} class.  The elements in the array
                  returned are not sorted and are not in any particular order.  This
                  method returns an array of length 0 if this {@code Class} object
                  represents a class or interface that has no public member methods, or if
                  this {@code Class} object represents a primitive type or void.
                  &lt;p&gt; The class initialization method {@code &lt;clinit&gt;} is not
                  included in the returned array. If the class declares multiple public
                  member methods with the same parameter types, they are all included in
                  the returned array.
                  &lt;p&gt; See &lt;em&gt;The Java Language Specification&lt;/em&gt;, sections 8.2 and 8.4.                
                <return>
                    the array of {@code Method} objects representing the
                      public methods of this class                    
                </return>
                <exception>
                    SecurityExceptionIf a security manager, <i>s</i>, is present and any of the
                      following conditions is met:
                      <ul>
                      <li> invocation of{@link SecurityManager#checkMemberAccesss.checkMemberAccess(this, Member.PUBLIC)} denies
                      access to the methods within this class
                      <li> the caller's class loader is not the same as or an
                      ancestor of the class loader for the current class and
                      invocation of {@link SecurityManager#checkPackageAccesss.checkPackageAccess()} denies access to the package
                      of this class
                      </ul>                    
                </exception>
                <since>
                    JDK1.1                    
                </since>
            </javadoc>
            <method name="getMethods" type="Method[]" line="1422">
                <comment line="1424">
                    be very careful not to change the stack depth of this
                     checkMemberAccess call for security reasons
                     see java.lang.SecurityManager.checkMemberAccess                    
                </comment>
            </method>
            <javadoc line="1431">
                Returns an array containing {@code Constructor} objects reflecting
                  all the public constructors of the class represented by this{@code Class} object.  An array of length 0 is returned if the
                  class has no public constructors, or if the class is an array class, or
                  if the class reflects a primitive type or void.
                  Note that while this method returns an array of {@codeConstructor&lt;T&gt;} objects (that is an array of constructors from
                  this class), the return type of this method is {@codeConstructor&lt;?&gt;[]} and &lt;em&gt;not&lt;/em&gt; {@code Constructor&lt;T&gt;[]} as
                  might be expected.  This less informative return type is
                  necessary since after being returned from this method, the
                  array could be modified to hold {@code Constructor} objects for
                  different classes, which would violate the type guarantees of{@code Constructor&lt;T&gt;[]}.                
                <return>
                    the array of {@code Constructor} objects representing the
                      public constructors of this class                    
                </return>
                <exception>
                    SecurityExceptionIf a security manager, <i>s</i>, is present and any of the
                      following conditions is met:
                      <ul>
                      <li> invocation of{@link SecurityManager#checkMemberAccesss.checkMemberAccess(this, Member.PUBLIC)} denies
                      access to the constructors within this class
                      <li> the caller's class loader is not the same as or an
                      ancestor of the class loader for the current class and
                      invocation of {@link SecurityManager#checkPackageAccesss.checkPackageAccess()} denies access to the package
                      of this class
                      </ul>                    
                </exception>
                <since>
                    JDK1.1                    
                </since>
            </javadoc>
            <method name="getConstructors" type="Constructor<?>[]" line="1471">
                <comment line="1473">
                    be very careful not to change the stack depth of this
                     checkMemberAccess call for security reasons
                     see java.lang.SecurityManager.checkMemberAccess                    
                </comment>
            </method>
            <javadoc line="1480">
                Returns a {@code Field} object that reflects the specified public
                  member field of the class or interface represented by this{@code Class} object. The {@code name} parameter is a{@code String} specifying the simple name of the desired field.
                  &lt;p&gt; The field to be reflected is determined by the algorithm that
                  follows.  Let C be the class represented by this object:
                  &lt;OL&gt;
                  &lt;LI&gt; If C declares a public field with the name specified, that is the
                  field to be reflected.&lt;/LI&gt;
                  &lt;LI&gt; If no field was found in step 1 above, this algorithm is applied
                  recursively to each direct superinterface of C. The direct
                  superinterfaces are searched in the order they were declared.&lt;/LI&gt;
                  &lt;LI&gt; If no field was found in steps 1 and 2 above, and C has a
                  superclass S, then this algorithm is invoked recursively upon S.
                  If C has no superclass, then a {@code NoSuchFieldException}is thrown.&lt;/LI&gt;
                  &lt;/OL&gt;
                  &lt;p&gt; See &lt;em&gt;The Java Language Specification&lt;/em&gt;, sections 8.2 and 8.3.                
                <param>
                    name the field name                    
                </param>
                <return>
                    the {@code Field} object of this class specified by{@code name}                    
                </return>
                <exception>
                    NoSuchFieldException if a field with the specified name is
                      not found.                    
                </exception>
                <exception>
                    NullPointerException if {@code name} is {@code null}                    
                </exception>
                <exception>
                    SecurityExceptionIf a security manager, <i>s</i>, is present and any of the
                      following conditions is met:
                      <ul>
                      <li> invocation of{@link SecurityManager#checkMemberAccesss.checkMemberAccess(this, Member.PUBLIC)} denies
                      access to the field
                      <li> the caller's class loader is not the same as or an
                      ancestor of the class loader for the current class and
                      invocation of {@link SecurityManager#checkPackageAccesss.checkPackageAccess()} denies access to the package
                      of this class
                      </ul>                    
                </exception>
                <since>
                    JDK1.1                    
                </since>
            </javadoc>
            <method name="getField" type="Field" line="1530">
                <params>
                    <param name="name" type="String"/>
                </params>
                <comment line="1532">
                    be very careful not to change the stack depth of this
                     checkMemberAccess call for security reasons
                     see java.lang.SecurityManager.checkMemberAccess                    
                </comment>
                <declaration name="field" type="Field" line="1535"/>
                <scope line="1536"/>
            </method>
            <javadoc line="1543">
                Returns a {@code Method} object that reflects the specified public
                  member method of the class or interface represented by this{@code Class} object. The {@code name} parameter is a{@code String} specifying the simple name of the desired method. The{@code parameterTypes} parameter is an array of {@code Class}objects that identify the method&apos;s formal parameter types, in declared
                  order. If {@code parameterTypes} is {@code null}, it is
                  treated as if it were an empty array.
                  &lt;p&gt; If the {@code name} is &quot;{@code &lt;init&gt;};&quot;or &quot;{@code &lt;clinit&gt;}&quot; a{@code NoSuchMethodException} is raised. Otherwise, the method to
                  be reflected is determined by the algorithm that follows.  Let C be the
                  class represented by this object:
                  &lt;OL&gt;
                  &lt;LI&gt; C is searched for any &lt;I&gt;matching methods&lt;/I&gt;. If no matching
                  method is found, the algorithm of step 1 is invoked recursively on
                  the superclass of C.&lt;/LI&gt;
                  &lt;LI&gt; If no method was found in step 1 above, the superinterfaces of C
                  are searched for a matching method. If any such method is found, it
                  is reflected.&lt;/LI&gt;
                  &lt;/OL&gt;
                  To find a matching method in a class C:&amp;nbsp; If C declares exactly one
                  public method with the specified name and exactly the same formal
                  parameter types, that is the method reflected. If more than one such
                  method is found in C, and one of these methods has a return type that is
                  more specific than any of the others, that method is reflected;
                  otherwise one of the methods is chosen arbitrarily.
                  &lt;p&gt;Note that there may be more than one matching method in a
                  class because while the Java language forbids a class to
                  declare multiple methods with the same signature but different
                  return types, the Java virtual machine does not.  This
                  increased flexibility in the virtual machine can be used to
                  implement various language features.  For example, covariant
                  returns can be implemented with {@linkplain java.lang.reflect.Method#isBridge bridge methods}; the bridge
                  method and the method being overridden would have the same
                  signature but different return types.
                  &lt;p&gt; See &lt;em&gt;The Java Language Specification&lt;/em&gt;, sections 8.2 and 8.4.                
                <param>
                    name the name of the method                    
                </param>
                <param>
                    parameterTypes the list of parameters                    
                </param>
                <return>
                    the {@code Method} object that matches the specified{@code name} and {@code parameterTypes}                    
                </return>
                <exception>
                    NoSuchMethodException if a matching method is not found
                      or if the name is "&lt;init&gt;"or "&lt;clinit&gt;".                    
                </exception>
                <exception>
                    NullPointerException if {@code name} is {@code null}                    
                </exception>
                <exception>
                    SecurityExceptionIf a security manager, <i>s</i>, is present and any of the
                      following conditions is met:
                      <ul>
                      <li> invocation of{@link SecurityManager#checkMemberAccesss.checkMemberAccess(this, Member.PUBLIC)} denies
                      access to the method
                      <li> the caller's class loader is not the same as or an
                      ancestor of the class loader for the current class and
                      invocation of {@link SecurityManager#checkPackageAccesss.checkPackageAccess()} denies access to the package
                      of this class
                      </ul>                    
                </exception>
                <since>
                    JDK1.1                    
                </since>
            </javadoc>
            <method name="getMethod" type="Method" line="1615">
                <params>
                    <param name="name" type="String"/>
                    <param name="parameterTypes" type="Class<?>"/>
                </params>
                <comment line="1617">
                    be very careful not to change the stack depth of this
                     checkMemberAccess call for security reasons
                     see java.lang.SecurityManager.checkMemberAccess                    
                </comment>
                <declaration name="method" type="Method" line="1620"/>
                <scope line="1621"/>
            </method>
            <javadoc line="1628">
                Returns a {@code Constructor} object that reflects the specified
                  public constructor of the class represented by this {@code Class}object. The {@code parameterTypes} parameter is an array of{@code Class} objects that identify the constructor&apos;s formal
                  parameter types, in declared order.
                  If this {@code Class} object represents an inner class
                  declared in a non-static context, the formal parameter types
                  include the explicit enclosing instance as the first parameter.
                  &lt;p&gt; The constructor to reflect is the public constructor of the class
                  represented by this {@code Class} object whose formal parameter
                  types match those specified by {@code parameterTypes}.                
                <param>
                    parameterTypes the parameter array                    
                </param>
                <return>
                    the {@code Constructor} object of the public constructor that
                      matches the specified {@code parameterTypes}                    
                </return>
                <exception>
                    NoSuchMethodException if a matching method is not found.                    
                </exception>
                <exception>
                    SecurityExceptionIf a security manager, <i>s</i>, is present and any of the
                      following conditions is met:
                      <ul>
                      <li> invocation of{@link SecurityManager#checkMemberAccesss.checkMemberAccess(this, Member.PUBLIC)} denies
                      access to the constructor
                      <li> the caller's class loader is not the same as or an
                      ancestor of the class loader for the current class and
                      invocation of {@link SecurityManager#checkPackageAccesss.checkPackageAccess()} denies access to the package
                      of this class
                      </ul>                    
                </exception>
                <since>
                    JDK1.1                    
                </since>
            </javadoc>
            <method name="getConstructor" type="Constructor<T>" line="1669">
                <params>
                    <param name="parameterTypes" type="Class<?>"/>
                </params>
                <comment line="1671">
                    be very careful not to change the stack depth of this
                     checkMemberAccess call for security reasons
                     see java.lang.SecurityManager.checkMemberAccess                    
                </comment>
            </method>
            <javadoc line="1678">
                Returns an array of {@code Class} objects reflecting all the
                  classes and interfaces declared as members of the class represented by
                  this {@code Class} object. This includes public, protected, default
                  (package) access, and private classes and interfaces declared by the
                  class, but excludes inherited classes and interfaces.  This method
                  returns an array of length 0 if the class declares no classes or
                  interfaces as members, or if this {@code Class} object represents a
                  primitive type, an array class, or void.                
                <return>
                    the array of {@code Class} objects representing all the
                      declared members of this class                    
                </return>
                <exception>
                    SecurityExceptionIf a security manager, <i>s</i>, is present and any of the
                      following conditions is met:
                      <ul>
                      <li> invocation of{@link SecurityManager#checkMemberAccesss.checkMemberAccess(this, Member.DECLARED)} denies
                      access to the declared classes within this class
                      <li> the caller's class loader is not the same as or an
                      ancestor of the class loader for the current class and
                      invocation of {@link SecurityManager#checkPackageAccesss.checkPackageAccess()} denies access to the package
                      of this class
                      </ul>                    
                </exception>
                <since>
                    JDK1.1                    
                </since>
            </javadoc>
            <method name="getDeclaredClasses" type="Class<?>[]" line="1711">
                <comment line="1713">
                    be very careful not to change the stack depth of this
                     checkMemberAccess call for security reasons
                     see java.lang.SecurityManager.checkMemberAccess                    
                </comment>
            </method>
            <javadoc line="1720">
                Returns an array of {@code Field} objects reflecting all the fields
                  declared by the class or interface represented by this{@code Class} object. This includes public, protected, default
                  (package) access, and private fields, but excludes inherited fields.
                  The elements in the array returned are not sorted and are not in any
                  particular order.  This method returns an array of length 0 if the class
                  or interface declares no fields, or if this {@code Class} object
                  represents a primitive type, an array class, or void.
                  &lt;p&gt; See &lt;em&gt;The Java Language Specification&lt;/em&gt;, sections 8.2 and 8.3.                
                <return>
                    the array of {@code Field} objects representing all the
                      declared fields of this class                    
                </return>
                <exception>
                    SecurityExceptionIf a security manager, <i>s</i>, is present and any of the
                      following conditions is met:
                      <ul>
                      <li> invocation of{@link SecurityManager#checkMemberAccesss.checkMemberAccess(this, Member.DECLARED)} denies
                      access to the declared fields within this class
                      <li> the caller's class loader is not the same as or an
                      ancestor of the class loader for the current class and
                      invocation of {@link SecurityManager#checkPackageAccesss.checkPackageAccess()} denies access to the package
                      of this class
                      </ul>                    
                </exception>
                <since>
                    JDK1.1                    
                </since>
            </javadoc>
            <method name="getDeclaredFields" type="Field[]" line="1755">
                <comment line="1757">
                    be very careful not to change the stack depth of this
                     checkMemberAccess call for security reasons
                     see java.lang.SecurityManager.checkMemberAccess                    
                </comment>
            </method>
            <javadoc line="1764">
                Returns an array of {@code Method} objects reflecting all the
                  methods declared by the class or interface represented by this{@code Class} object. This includes public, protected, default
                  (package) access, and private methods, but excludes inherited methods.
                  The elements in the array returned are not sorted and are not in any
                  particular order.  This method returns an array of length 0 if the class
                  or interface declares no methods, or if this {@code Class} object
                  represents a primitive type, an array class, or void.  The class
                  initialization method {@code &lt;clinit&gt;} is not included in the
                  returned array. If the class declares multiple public member methods
                  with the same parameter types, they are all included in the returned
                  array.
                  &lt;p&gt; See &lt;em&gt;The Java Language Specification&lt;/em&gt;, section 8.2.                
                <return>
                    the array of {@code Method} objects representing all the
                      declared methods of this class                    
                </return>
                <exception>
                    SecurityExceptionIf a security manager, <i>s</i>, is present and any of the
                      following conditions is met:
                      <ul>
                      <li> invocation of{@link SecurityManager#checkMemberAccesss.checkMemberAccess(this, Member.DECLARED)} denies
                      access to the declared methods within this class
                      <li> the caller's class loader is not the same as or an
                      ancestor of the class loader for the current class and
                      invocation of {@link SecurityManager#checkPackageAccesss.checkPackageAccess()} denies access to the package
                      of this class
                      </ul>                    
                </exception>
                <since>
                    JDK1.1                    
                </since>
            </javadoc>
            <method name="getDeclaredMethods" type="Method[]" line="1803">
                <comment line="1805">
                    be very careful not to change the stack depth of this
                     checkMemberAccess call for security reasons
                     see java.lang.SecurityManager.checkMemberAccess                    
                </comment>
            </method>
            <javadoc line="1812">
                Returns an array of {@code Constructor} objects reflecting all the
                  constructors declared by the class represented by this{@code Class} object. These are public, protected, default
                  (package) access, and private constructors.  The elements in the array
                  returned are not sorted and are not in any particular order.  If the
                  class has a default constructor, it is included in the returned array.
                  This method returns an array of length 0 if this {@code Class}object represents an interface, a primitive type, an array class, or
                  void.
                  &lt;p&gt; See &lt;em&gt;The Java Language Specification&lt;/em&gt;, section 8.2.                
                <return>
                    the array of {@code Constructor} objects representing all the
                      declared constructors of this class                    
                </return>
                <exception>
                    SecurityExceptionIf a security manager, <i>s</i>, is present and any of the
                      following conditions is met:
                      <ul>
                      <li> invocation of{@link SecurityManager#checkMemberAccesss.checkMemberAccess(this, Member.DECLARED)} denies
                      access to the declared constructors within this class
                      <li> the caller's class loader is not the same as or an
                      ancestor of the class loader for the current class and
                      invocation of {@link SecurityManager#checkPackageAccesss.checkPackageAccess()} denies access to the package
                      of this class
                      </ul>                    
                </exception>
                <since>
                    JDK1.1                    
                </since>
            </javadoc>
            <method name="getDeclaredConstructors" type="Constructor<?>[]" line="1848">
                <comment line="1850">
                    be very careful not to change the stack depth of this
                     checkMemberAccess call for security reasons
                     see java.lang.SecurityManager.checkMemberAccess                    
                </comment>
            </method>
            <javadoc line="1857">
                Returns a {@code Field} object that reflects the specified declared
                  field of the class or interface represented by this {@code Class}object. The {@code name} parameter is a {@code String} that
                  specifies the simple name of the desired field.  Note that this method
                  will not reflect the {@code length} field of an array class.                
                <param>
                    name the name of the field                    
                </param>
                <return>
                    the {@code Field} object for the specified field in this
                      class                    
                </return>
                <exception>
                    NoSuchFieldException if a field with the specified name is
                      not found.                    
                </exception>
                <exception>
                    NullPointerException if {@code name} is {@code null}                    
                </exception>
                <exception>
                    SecurityExceptionIf a security manager, <i>s</i>, is present and any of the
                      following conditions is met:
                      <ul>
                      <li> invocation of{@link SecurityManager#checkMemberAccesss.checkMemberAccess(this, Member.DECLARED)} denies
                      access to the declared field
                      <li> the caller's class loader is not the same as or an
                      ancestor of the class loader for the current class and
                      invocation of {@link SecurityManager#checkPackageAccesss.checkPackageAccess()} denies access to the package
                      of this class
                      </ul>                    
                </exception>
                <since>
                    JDK1.1                    
                </since>
            </javadoc>
            <method name="getDeclaredField" type="Field" line="1892">
                <params>
                    <param name="name" type="String"/>
                </params>
                <comment line="1894">
                    be very careful not to change the stack depth of this
                     checkMemberAccess call for security reasons
                     see java.lang.SecurityManager.checkMemberAccess                    
                </comment>
                <declaration name="field" type="Field" line="1897"/>
                <scope line="1898"/>
            </method>
            <javadoc line="1905">
                Returns a {@code Method} object that reflects the specified
                  declared method of the class or interface represented by this{@code Class} object. The {@code name} parameter is a{@code String} that specifies the simple name of the desired
                  method, and the {@code parameterTypes} parameter is an array of{@code Class} objects that identify the method&apos;s formal parameter
                  types, in declared order.  If more than one method with the same
                  parameter types is declared in a class, and one of these methods has a
                  return type that is more specific than any of the others, that method is
                  returned; otherwise one of the methods is chosen arbitrarily.  If the
                  name is &quot;&amp;lt;init&amp;gt;&quot;or &quot;&amp;lt;clinit&amp;gt;&quot; a {@code NoSuchMethodException}is raised.                
                <param>
                    name the name of the method                    
                </param>
                <param>
                    parameterTypes the parameter array                    
                </param>
                <return>
                    the {@code Method} object for the method of this class
                      matching the specified name and parameters                    
                </return>
                <exception>
                    NoSuchMethodException if a matching method is not found.                    
                </exception>
                <exception>
                    NullPointerException if {@code name} is {@code null}                    
                </exception>
                <exception>
                    SecurityExceptionIf a security manager, <i>s</i>, is present and any of the
                      following conditions is met:
                      <ul>
                      <li> invocation of{@link SecurityManager#checkMemberAccesss.checkMemberAccess(this, Member.DECLARED)} denies
                      access to the declared method
                      <li> the caller's class loader is not the same as or an
                      ancestor of the class loader for the current class and
                      invocation of {@link SecurityManager#checkPackageAccesss.checkPackageAccess()} denies access to the package
                      of this class
                      </ul>                    
                </exception>
                <since>
                    JDK1.1                    
                </since>
            </javadoc>
            <method name="getDeclaredMethod" type="Method" line="1947">
                <params>
                    <param name="name" type="String"/>
                    <param name="parameterTypes" type="Class<?>"/>
                </params>
                <comment line="1949">
                    be very careful not to change the stack depth of this
                     checkMemberAccess call for security reasons
                     see java.lang.SecurityManager.checkMemberAccess                    
                </comment>
                <declaration name="method" type="Method" line="1952"/>
                <scope line="1953"/>
            </method>
            <javadoc line="1960">
                Returns a {@code Constructor} object that reflects the specified
                  constructor of the class or interface represented by this{@code Class} object.  The {@code parameterTypes} parameter is
                  an array of {@code Class} objects that identify the constructor&apos;s
                  formal parameter types, in declared order.
                  If this {@code Class} object represents an inner class
                  declared in a non-static context, the formal parameter types
                  include the explicit enclosing instance as the first parameter.                
                <param>
                    parameterTypes the parameter array                    
                </param>
                <return>
                    The {@code Constructor} object for the constructor with the
                      specified parameter list                    
                </return>
                <exception>
                    NoSuchMethodException if a matching method is not found.                    
                </exception>
                <exception>
                    SecurityExceptionIf a security manager, <i>s</i>, is present and any of the
                      following conditions is met:
                      <ul>
                      <li> invocation of{@link SecurityManager#checkMemberAccesss.checkMemberAccess(this, Member.DECLARED)} denies
                      access to the declared constructor
                      <li> the caller's class loader is not the same as or an
                      ancestor of the class loader for the current class and
                      invocation of {@link SecurityManager#checkPackageAccesss.checkPackageAccess()} denies access to the package
                      of this class
                      </ul>                    
                </exception>
                <since>
                    JDK1.1                    
                </since>
            </javadoc>
            <method name="getDeclaredConstructor" type="Constructor<T>" line="1997">
                <params>
                    <param name="parameterTypes" type="Class<?>"/>
                </params>
                <comment line="1999">
                    be very careful not to change the stack depth of this
                     checkMemberAccess call for security reasons
                     see java.lang.SecurityManager.checkMemberAccess                    
                </comment>
            </method>
            <javadoc line="2005">
                Finds a resource with a given name.  The rules for searching resources
                  associated with a given class are implemented by the defining{@linkplain ClassLoader class loader} of the class.  This method
                  delegates to this object&apos;s class loader.  If this object was loaded by
                  the bootstrap class loader, the method delegates to {@link ClassLoader#getSystemResourceAsStream}.
                  &lt;p&gt; Before delegation, an absolute resource name is constructed from the
                  given resource name using this algorithm:
                  &lt;ul&gt;
                  &lt;li&gt; If the {@code name} begins with a {@code &apos;/&apos;}(&lt;tt&gt;&apos;&amp;#92;u002f&apos;&lt;/tt&gt;), then the absolute name of the resource is the
                  portion of the {@code name} following the {@code &apos;/&apos;}.
                  &lt;li&gt; Otherwise, the absolute name is of the following form:
                  &lt;blockquote&gt;{@code modified_package_name/name}&lt;/blockquote&gt;
                  &lt;p&gt; Where the {@code modified_package_name} is the package name of this
                  object with {@code &apos;/&apos;} substituted for {@code &apos;.&apos;}(&lt;tt&gt;&apos;&amp;#92;u002e&apos;&lt;/tt&gt;).
                  &lt;/ul&gt;                
                <param>
                    name name of the desired resource                    
                </param>
                <return>
                    A {@link java.io.InputStream} object or {@code null} if
                      no resource with this name is found                    
                </return>
                <throws>
                    NullPointerException If {@code name} is {@code null}                    
                </throws>
                <since>
                    JDK1.1                    
                </since>
            </javadoc>
            <method name="getResourceAsStream" type="InputStream" line="2040">
                <params>
                    <param name="name" type="String"/>
                </params>
                <comment line="2045">
                    A system class.                    
                </comment>
                <declaration name="cl" type="ClassLoader" line="2042"/>
                <scope line="2043"/>
            </method>
            <javadoc line="2050">
                Finds a resource with a given name.  The rules for searching resources
                  associated with a given class are implemented by the defining{@linkplain ClassLoader class loader} of the class.  This method
                  delegates to this object&apos;s class loader.  If this object was loaded by
                  the bootstrap class loader, the method delegates to {@link ClassLoader#getSystemResource}.
                  &lt;p&gt; Before delegation, an absolute resource name is constructed from the
                  given resource name using this algorithm:
                  &lt;ul&gt;
                  &lt;li&gt; If the {@code name} begins with a {@code &apos;/&apos;}(&lt;tt&gt;&apos;&amp;#92;u002f&apos;&lt;/tt&gt;), then the absolute name of the resource is the
                  portion of the {@code name} following the {@code &apos;/&apos;}.
                  &lt;li&gt; Otherwise, the absolute name is of the following form:
                  &lt;blockquote&gt;{@code modified_package_name/name}&lt;/blockquote&gt;
                  &lt;p&gt; Where the {@code modified_package_name} is the package name of this
                  object with {@code &apos;/&apos;} substituted for {@code &apos;.&apos;}(&lt;tt&gt;&apos;&amp;#92;u002e&apos;&lt;/tt&gt;).
                  &lt;/ul&gt;                
                <param>
                    name name of the desired resource                    
                </param>
                <return>
                    A  {@link java.net.URL} object or {@code null} if no
                      resource with this name is found                    
                </return>
                <since>
                    JDK1.1                    
                </since>
            </javadoc>
            <method name="getResource" type="java.net.URL" line="2084">
                <params>
                    <param name="name" type="String"/>
                </params>
                <comment line="2089">
                    A system class.                    
                </comment>
                <declaration name="cl" type="ClassLoader" line="2086"/>
                <scope line="2087"/>
            </method>
            <declaration name="allPermDomain" type="java.security.ProtectionDomain" line="2096"/>
            <javadoc line="2096">
                protection domain returned when the internal domain is null                
            </javadoc>
            <javadoc line="2100">
                Returns the {@code ProtectionDomain} of this class.  If there is a
                  security manager installed, this method first calls the security
                  manager&apos;s {@code checkPermission} method with a{@code RuntimePermission(&quot;getProtectionDomain&quot;)} permission to
                  ensure it&apos;s ok to get the{@code ProtectionDomain}.                
                <return>
                    the ProtectionDomain of this class                    
                </return>
                <throws>
                    SecurityExceptionif a security manager exists and its{@code checkPermission} method doesn't allow
                      getting the ProtectionDomain.                    
                </throws>
                <see>
                    java.security.ProtectionDomain                    
                </see>
                <see>
                    SecurityManager#checkPermission                    
                </see>
                <see>
                    java.lang.RuntimePermission                    
                </see>
                <since>
                    1.2                    
                </since>
            </javadoc>
            <method name="getProtectionDomain" type="java.security.ProtectionDomain" line="2120">
                <declaration name="sm" type="SecurityManager" line="2121"/>
                <scope line="2122"/>
                <declaration name="pd" type="java.security.ProtectionDomain" line="2125"/>
                <scope line="2126">
                    <scope line="2127">
                        <declaration name="perms" type="java.security.Permissions" line="2128"/>
                    </scope>
                </scope>
            </method>
            <method name="getProtectionDomain0" type="java.security.ProtectionDomain" line="2140"/>
            <javadoc line="2140">
                Returns the ProtectionDomain of this class.                
            </javadoc>
            <method name="setProtectionDomain0" type="void" line="2146"/>
            <javadoc line="2146">
                Set the ProtectionDomain for this class. Called by
                  ClassLoader.defineClass.                
            </javadoc>
            <method name="getPrimitiveClass" type="Class" line="2157"/>
            <method name="checkMemberAccess" type="void" line="2171">
                <params>
                    <param name="which" type="int"/>
                    <param name="ccl" type="ClassLoader"/>
                </params>
                <declaration name="s" type="SecurityManager" line="2172"/>
                <scope line="2173">
                    <declaration name="cl" type="ClassLoader" line="2175"/>
                    <scope line="2177">
                        <declaration name="name" type="String" line="2178"/>
                        <declaration name="i" type="int" line="2179"/>
                        <scope line="2180"/>
                    </scope>
                </scope>
            </method>
            <javadoc line="2187">
                Add a package name prefix if the name is not absolute Remove leading &quot;/&quot;
                  if name is absolute                
            </javadoc>
            <method name="resolveName" type="String" line="2191">
                <params>
                    <param name="name" type="String"/>
                </params>
                <scope line="2192"/>
                <scope line="2195">
                    <declaration name="c" type="Class&lt;?&gt;" line="2196"/>
                    <scope line="2197"/>
                    <declaration name="baseName" type="String" line="2200"/>
                    <declaration name="index" type="int" line="2201"/>
                    <scope line="2202"/>
                </scope>
                <scope line="2206"/>
            </method>
            <declaration name="useCaches" type="boolean" line="2212"/>
            <javadoc line="2212">
                Reflection support.                
            </javadoc>
            <declaration name="declaredFields" type="SoftReference&lt;Field[]&gt;" line="2218"/>
            <declaration name="publicFields" type="SoftReference&lt;Field[]&gt;" line="2219"/>
            <declaration name="declaredMethods" type="SoftReference&lt;Method[]&gt;" line="2220"/>
            <declaration name="publicMethods" type="SoftReference&lt;Method[]&gt;" line="2221"/>
            <declaration name="declaredConstructors" type="SoftReference&lt;Constructor&lt;T&gt;[]&gt;" line="2222"/>
            <declaration name="publicConstructors" type="SoftReference&lt;Constructor&lt;T&gt;[]&gt;" line="2223"/>
            <declaration name="declaredPublicFields" type="SoftReference&lt;Field[]&gt;" line="2225"/>
            <declaration name="declaredPublicMethods" type="SoftReference&lt;Method[]&gt;" line="2226"/>
            <declaration name="classRedefinedCount" type="int" line="2230"/>
            <declaration name="lastRedefinedCount" type="int" line="2234"/>
            <method name="clearCachesOnClassRedefinition" type="void" line="2238">
                <comment line="2246">
                    Use of &quot;volatile&quot; (and synchronization by caller in the case
                     of annotations) ensures that no thread sees the update to
                     lastRedefinedCount before seeing the caches cleared.
                     We do not guard against brief windows during which multiple
                     threads might redundantly work to fill an empty cache.                    
                </comment>
                <scope line="2239"/>
            </method>
            <method name="getGenericSignature" type="String" line="2255"/>
            <declaration name="genericInfo" type="ClassRepository" line="2258"/>
            <method name="getFactory" type="GenericsFactory" line="2261">
                <comment line="2263">
                    create scope and factory                    
                </comment>
            </method>
            <method name="getGenericInfo" type="ClassRepository" line="2267">
                <comment line="2269">
                    lazily initialize repository if necessary                    
                </comment>
                <comment line="2271">
                    create and cache generic info repository                    
                </comment>
                <comment line="2275">
                    return cached repository                    
                </comment>
                <scope line="2269"/>
            </method>
            <method name="getRawAnnotations" type="byte[]" line="2278"/>
            <method name="getConstantPool" type="ConstantPool" line="2280"/>
            <method name="privateGetDeclaredFields" type="Field[]" line="2291">
                <params>
                    <param name="publicOnly" type="boolean"/>
                </params>
                <comment line="2308">
                    No cached value available; request value from VM                    
                </comment>
                <declaration name="res" type="Field[]" line="2293"/>
                <scope line="2294">
                    <scope line="2296">
                        <scope line="2297"/>
                    </scope>
                    <scope line="2300">
                        <scope line="2301"/>
                    </scope>
                </scope>
                <scope line="2309">
                    <scope line="2310"/>
                    <scope line="2312"/>
                </scope>
            </method>
            <method name="privateGetPublicFields" type="Field[]" line="2322">
                <params>
                    <param name="traversedInterfaces" type="Set<Class<?>>"/>
                </params>
                <comment line="2334">
                    No cached value available; compute value recursively.
                     Traverse in correct order for getField().                    
                </comment>
                <comment line="2341">
                    Local fields                    
                </comment>
                <comment line="2345">
                    Direct superinterfaces, recursively                    
                </comment>
                <comment line="2353">
                    Direct superclass, recursively                    
                </comment>
                <declaration name="res" type="Field[]" line="2324"/>
                <scope line="2325">
                    <scope line="2327"/>
                </scope>
                <declaration name="fields" type="List&lt;Field&gt;" line="2335"/>
                <scope line="2336"/>
                <declaration name="tmp" type="Field[]" line="2341"/>
                <scope line="2345">
                    <scope line="2346"/>
                </scope>
                <scope line="2353">
                    <declaration name="c" type="Class&lt;?&gt;" line="2354"/>
                    <scope line="2355"/>
                </scope>
                <scope line="2362"/>
            </method>
            <method name="addAll" type="void" line="2368">
                <params>
                    <param name="c" type="Collection<Field>"/>
                    <param name="o" type="Field[]"/>
                </params>
                <scope line="2369"/>
            </method>
            <method name="privateGetDeclaredConstructors" type="Constructor<T>[]" line="2384">
                <params>
                    <param name="publicOnly" type="boolean"/>
                </params>
                <comment line="2401">
                    No cached value available; request value from VM                    
                </comment>
                <declaration name="res" type="Constructor&lt;T&gt;[]" line="2386"/>
                <scope line="2387">
                    <scope line="2389">
                        <scope line="2390"/>
                    </scope>
                    <scope line="2393">
                        <scope line="2394"/>
                    </scope>
                </scope>
                <scope line="2401"/>
                <scope line="2403"/>
                <scope line="2406">
                    <scope line="2407"/>
                    <scope line="2409"/>
                </scope>
            </method>
            <method name="privateGetDeclaredMethods" type="Method[]" line="2425">
                <params>
                    <param name="publicOnly" type="boolean"/>
                </params>
                <comment line="2442">
                    No cached value available; request value from VM                    
                </comment>
                <declaration name="res" type="Method[]" line="2427"/>
                <scope line="2428">
                    <scope line="2430">
                        <scope line="2431"/>
                    </scope>
                    <scope line="2434">
                        <scope line="2435"/>
                    </scope>
                </scope>
                <scope line="2443">
                    <scope line="2444"/>
                    <scope line="2446"/>
                </scope>
            </method>
            <class name="MethodArray" line="2453">
                <comment line="2217">
                    Caches for certain reflective results                    
                </comment>
                <declaration name="methods" type="Method[]" line="2454"/>
                <declaration name="length" type="int" line="2455"/>
                <method name="MethodArray" type="constructor" line="2457"/>
                <method name="add" type="void" line="2462">
                    <params>
                        <param name="m" type="Method"/>
                    </params>
                    <scope line="2463"/>
                </method>
                <method name="addAll" type="void" line="2469">
                    <params>
                        <param name="ma" type="Method[]"/>
                    </params>
                    <scope line="2470"/>
                </method>
                <method name="addAll" type="void" line="2475">
                    <params>
                        <param name="ma" type="MethodArray"/>
                    </params>
                    <scope line="2476"/>
                </method>
                <method name="addIfNotPresent" type="void" line="2481">
                    <params>
                        <param name="newMethod" type="Method"/>
                    </params>
                    <scope line="2482">
                        <declaration name="m" type="Method" line="2483"/>
                        <scope line="2484"/>
                    </scope>
                </method>
                <method name="addAllIfNotPresent" type="void" line="2491">
                    <params>
                        <param name="newMethods" type="MethodArray"/>
                    </params>
                    <scope line="2492">
                        <declaration name="m" type="Method" line="2493"/>
                        <scope line="2494"/>
                    </scope>
                </method>
                <method name="length" type="int" line="2500"/>
                <method name="get" type="Method" line="2504">
                    <params>
                        <param name="i" type="int"/>
                    </params>
                </method>
                <method name="removeByNameAndSignature" type="void" line="2508">
                    <params>
                        <param name="toRemove" type="Method"/>
                    </params>
                    <scope line="2509">
                        <declaration name="m" type="Method" line="2510"/>
                        <scope line="2515"/>
                    </scope>
                </method>
                <method name="compactAndTrim" type="void" line="2521">
                    <comment line="2524">
                        Get rid of null slots                        
                    </comment>
                    <declaration name="newPos" type="int" line="2522"/>
                    <scope line="2524">
                        <declaration name="m" type="Method" line="2525"/>
                        <scope line="2526">
                            <scope line="2527"/>
                        </scope>
                    </scope>
                    <scope line="2533"/>
                </method>
                <method name="getArray" type="Method[]" line="2538"/>
            </class>
            <method name="privateGetPublicMethods" type="Method[]" line="2547">
                <comment line="2559">
                    No cached value available; compute value recursively.
                     Start by fetching public declared methods                    
                </comment>
                <comment line="2566">
                    Now recur over superclass and direct superinterfaces.
                     Go over superinterfaces first so we can more easily filter
                     out concrete implementations inherited from superclasses at
                     the end.                    
                </comment>
                <comment line="2580">
                    Filter out concrete implementations of any
                     interface methods                    
                </comment>
                <comment line="2588">
                    Insert superclass&apos;s inherited methods before
                     superinterfaces&apos; to satisfy getMethod&apos;s search
                     order                    
                </comment>
                <comment line="2595">
                    Filter out all local methods from inherited ones                    
                </comment>
                <declaration name="res" type="Method[]" line="2549"/>
                <scope line="2550">
                    <scope line="2552"/>
                </scope>
                <declaration name="methods" type="MethodArray" line="2560"/>
                <scope line="2561">
                    <declaration name="tmp" type="Method[]" line="2562"/>
                </scope>
                <declaration name="inheritedMethods" type="MethodArray" line="2569"/>
                <declaration name="interfaces" type="Class&lt;?&gt;[]" line="2570"/>
                <scope line="2571"/>
                <scope line="2574">
                    <declaration name="c" type="Class&lt;?&gt;" line="2575"/>
                    <scope line="2576">
                        <declaration name="supers" type="MethodArray" line="2577"/>
                        <scope line="2581">
                            <declaration name="m" type="Method" line="2582"/>
                            <scope line="2583"/>
                        </scope>
                    </scope>
                </scope>
                <scope line="2595">
                    <declaration name="m" type="Method" line="2596"/>
                </scope>
                <scope line="2602"/>
            </method>
            <method name="searchFields" type="Field" line="2613">
                <params>
                    <param name="fields" type="Field[]"/>
                    <param name="name" type="String"/>
                </params>
                <declaration name="internedName" type="String" line="2614"/>
                <scope line="2615">
                    <scope line="2616"/>
                </scope>
            </method>
            <method name="getField0" type="Field" line="2623">
                <params>
                    <param name="name" type="String"/>
                </params>
                <comment line="2625">
                    Note: the intent is that the search algorithm this routine
                     uses be equivalent to the ordering imposed by
                     privateGetPublicFields(). It fetches only the declared
                     public fields for each class, however, to reduce the number
                     of Field objects which have to be created for the common
                     case where the field being requested is declared in the
                     class which is being queried.                    
                </comment>
                <comment line="2633">
                    Search declared public fields                    
                </comment>
                <comment line="2637">
                    Direct superinterfaces, recursively                    
                </comment>
                <comment line="2645">
                    Direct superclass, recursively                    
                </comment>
                <declaration name="res" type="Field" line="2631"/>
                <scope line="2633"/>
                <declaration name="interfaces" type="Class&lt;?&gt;[]" line="2637"/>
                <scope line="2638">
                    <declaration name="c" type="Class&lt;?&gt;" line="2639"/>
                    <scope line="2640"/>
                </scope>
                <scope line="2645">
                    <declaration name="c" type="Class&lt;?&gt;" line="2646"/>
                    <scope line="2647">
                        <scope line="2648"/>
                    </scope>
                </scope>
            </method>
            <method name="searchMethods" type="Method" line="2659">
                <params>
                    <param name="methods" type="Method[]"/>
                    <param name="name" type="String"/>
                    <param name="parameterTypes" type="Class<?>[]"/>
                </params>
                <declaration name="res" type="Method" line="2660"/>
                <declaration name="internedName" type="String" line="2661"/>
                <scope line="2662">
                    <declaration name="m" type="Method" line="2663"/>
                </scope>
            </method>
            <method name="getMethod0" type="Method" line="2675">
                <params>
                    <param name="name" type="String"/>
                    <param name="parameterTypes" type="Class<?>[]"/>
                </params>
                <comment line="2677">
                    Note: the intent is that the search algorithm this routine
                     uses be equivalent to the ordering imposed by
                     privateGetPublicMethods(). It fetches only the declared
                     public methods for each class, however, to reduce the
                     number of Method objects which have to be created for the
                     common case where the method being requested is declared in
                     the class which is being queried.                    
                </comment>
                <comment line="2685">
                    Search declared public methods                    
                </comment>
                <comment line="2691">
                    Search superclass&apos;s methods                    
                </comment>
                <comment line="2700">
                    Search superinterfaces&apos; methods                    
                </comment>
                <comment line="2708">
                    Not found                    
                </comment>
                <declaration name="res" type="Method" line="2683"/>
                <scope line="2687"/>
                <scope line="2691">
                    <declaration name="c" type="Class&lt;? super T&gt;" line="2692"/>
                    <scope line="2693">
                        <scope line="2694"/>
                    </scope>
                </scope>
                <declaration name="interfaces" type="Class&lt;?&gt;[]" line="2700"/>
                <scope line="2701">
                    <declaration name="c" type="Class&lt;?&gt;" line="2702"/>
                    <scope line="2703"/>
                </scope>
            </method>
            <method name="getConstructor0" type="Constructor<T>" line="2713">
                <params>
                    <param name="parameterTypes" type="Class<?>[]"/>
                    <param name="which" type="int"/>
                </params>
                <declaration name="constructors" type="Constructor&lt;T&gt;[]" line="2714"/>
                <scope line="2715">
                    <scope line="2717"/>
                </scope>
            </method>
            <method name="arrayContentsEq" type="boolean" line="2728">
                <params>
                    <param name="a1" type="Object[]"/>
                    <param name="a2" type="Object[]"/>
                </params>
                <scope line="2729"/>
                <scope line="2733"/>
                <scope line="2737"/>
                <scope line="2741">
                    <scope line="2742"/>
                </scope>
            </method>
            <method name="copyFields" type="Field[]" line="2750">
                <params>
                    <param name="arg" type="Field[]"/>
                </params>
                <declaration name="out" type="Field[]" line="2751"/>
                <declaration name="fact" type="ReflectionFactory" line="2752"/>
                <scope line="2753"/>
            </method>
            <method name="copyMethods" type="Method[]" line="2759">
                <params>
                    <param name="arg" type="Method[]"/>
                </params>
                <declaration name="out" type="Method[]" line="2760"/>
                <declaration name="fact" type="ReflectionFactory" line="2761"/>
                <scope line="2762"/>
            </method>
            <method name="copyConstructors" type="Constructor<U>[]" line="2768">
                <params>
                    <param name="arg" type="Constructor<U>[]"/>
                </params>
                <declaration name="out" type="Constructor&lt;U&gt;[]" line="2769"/>
                <declaration name="fact" type="ReflectionFactory" line="2770"/>
                <scope line="2771"/>
            </method>
            <method name="getDeclaredFields0" type="Field[]" line="2777"/>
            <method name="getDeclaredMethods0" type="Method[]" line="2778"/>
            <method name="getDeclaredConstructors0" type="Constructor<T>[]" line="2779"/>
            <method name="getDeclaredClasses0" type="Class<?>[]" line="2780"/>
            <method name="argumentTypesToString" type="String" line="2782">
                <params>
                    <param name="argTypes" type="Class<?>[]"/>
                </params>
                <declaration name="buf" type="StringBuilder" line="2783"/>
                <scope line="2785">
                    <scope line="2786">
                        <scope line="2787"/>
                        <declaration name="c" type="Class&lt;?&gt;" line="2790"/>
                    </scope>
                </scope>
            </method>
            <declaration name="serialVersionUID" type="long" line="2798"/>
            <javadoc line="2798">
                use serialVersionUID from JDK 1.1 for interoperability                
            </javadoc>
            <declaration name="serialPersistentFields" type="ObjectStreamField[]" line="2802"/>
            <javadoc line="2802">
                Class Class is special cased within the Serialization Stream Protocol.
                  A Class instance is written initially into an ObjectOutputStream in the
                  following format:
                  &lt;pre&gt;{@code TC_CLASS} ClassDescriptor
                  A ClassDescriptor is a special cased serialization of
                  a {@code java.io.ObjectStreamClass} instance.
                  &lt;/pre&gt;
                  A new handle is generated for the initial time the class descriptor
                  is written into the stream. Future references to the class descriptor
                  are written as references to the initial class descriptor instance.                
                <see>
                    java.io.ObjectStreamClass                    
                </see>
            </javadoc>
            <javadoc line="2822">
                Returns the assertion status that would be assigned to this
                  class if it were to be initialized at the time this method is invoked.
                  If this class has had its assertion status set, the most recent
                  setting will be returned; otherwise, if any package default assertion
                  status pertains to this class, the most recent setting for the most
                  specific pertinent package default assertion status is returned;
                  otherwise, if this class is not a system class (i.e., it has a
                  class loader) its class loader&apos;s default assertion status is returned;
                  otherwise, the system class default assertion status is returned.
                  &lt;p&gt;
                  Few programmers will have any need for this method; it is provided
                  for the benefit of the JRE itself.  (It allows a class to determine at
                  the time that it is initialized whether assertions should be enabled.)
                  Note that this method is not guaranteed to return the actual
                  assertion status that was (or will be) associated with the specified
                  class when it was (or will be) initialized.                
                <return>
                    the desired assertion status of the specified class.                    
                </return>
                <see>
                    java.lang.ClassLoader#setClassAssertionStatus                    
                </see>
                <see>
                    java.lang.ClassLoader#setPackageAssertionStatus                    
                </see>
                <see>
                    java.lang.ClassLoader#setDefaultAssertionStatus                    
                </see>
                <since>
                    1.4                    
                </since>
            </javadoc>
            <method name="desiredAssertionStatus" type="boolean" line="2846">
                <comment line="2849">
                    If the loader is null this is a system class, so ask the VM                    
                </comment>
                <comment line="2853">
                    If the classloader has been initialized with the assertion
                     directives, ask it. Otherwise, ask the VM.                    
                </comment>
                <declaration name="loader" type="ClassLoader" line="2847"/>
                <scope line="2854">
                    <scope line="2855"/>
                </scope>
            </method>
            <method name="desiredAssertionStatus0" type="boolean" line="2863"/>
            <javadoc line="2865">
                Returns true if and only if this class was declared as an enum in the
                  source code.                
                <return>
                    true if and only if this class was declared as an enum in the
                      source code                    
                </return>
                <since>
                    1.5                    
                </since>
            </javadoc>
            <method name="isEnum" type="boolean" line="2873">
                <comment line="2875">
                    An enum must both directly extend java.lang.Enum and have
                     the ENUM bit set; classes for specialized enum constants
                     don&apos;t do the former.                    
                </comment>
            </method>
            <method name="getReflectionFactory" type="ReflectionFactory" line="2882">
                <scope line="2883"/>
            </method>
            <declaration name="reflectionFactory" type="ReflectionFactory" line="2890"/>
            <declaration name="initted" type="boolean" line="2893"/>
            <method name="checkInitted" type="void" line="2894">
                <comment line="2899">
                    Tests to ensure the system properties table is fully
                     initialized. This is needed because reflection code is
                     called very early in the initialization process (before
                     command-line arguments have been parsed and therefore
                     these user-settable properties installed.) We assume that
                     if System.out is non-null then the System class has been
                     fully initialized and that the bulk of the startup code
                     has been run.                    
                </comment>
                <comment line="2909">
                    java.lang.System not yet fully initialized                    
                </comment>
                <anonymous_class line="2896">
                    <method name="run" type="Void" line="2897">
                        <comment line="2899">
                            Tests to ensure the system properties table is fully
                             initialized. This is needed because reflection code is
                             called very early in the initialization process (before
                             command-line arguments have been parsed and therefore
                             these user-settable properties installed.) We assume that
                             if System.out is non-null then the System class has been
                             fully initialized and that the bulk of the startup code
                             has been run.                            
                        </comment>
                        <comment line="2909">
                            java.lang.System not yet fully initialized                            
                        </comment>
                        <scope line="2907"/>
                        <declaration name="val" type="String" line="2912"/>
                        <scope line="2914"/>
                    </method>
                </anonymous_class>
            </method>
            <javadoc line="2924">
                Returns the elements of this enum class or null if this
                  Class object does not represent an enum type.                
                <return>
                    an array containing the values comprising the enum class
                      represented by this Class object in the order they're
                      declared, or null if this Class object does not
                      represent an enum type                    
                </return>
                <since>
                    1.5                    
                </since>
            </javadoc>
            <method name="getEnumConstants" type="T[]" line="2934">
                <declaration name="values" type="T[]" line="2935"/>
            </method>
            <javadoc line="2939">
                Returns the elements of this enum class or null if this
                  Class object does not represent an enum type;
                  identical to getEnumConstants except that the result is
                  uncloned, cached, and shared by all callers.                
            </javadoc>
            <method name="getEnumConstantsShared" type="T[]" line="2945">
                <comment line="2960">
                    These can happen when users concoct enum-like classes
                     that don&apos;t comply with the enum spec.                    
                </comment>
                <scope line="2946">
                    <scope line="2948">
                        <declaration name="values" type="Method" line="2949"/>
                        <anonymous_class line="2951">
                            <method name="run" type="Void" line="2952"/>
                        </anonymous_class>
                    </scope>
                    <scope line="2961"/>
                    <scope line="2962"/>
                    <scope line="2963"/>
                </scope>
            </method>
            <declaration name="enumConstants" type="T[]" line="2967"/>
            <javadoc line="2969">
                Returns a map from simple name to enum constant.  This package-private
                  method is used internally by Enum to implement
                  public static &lt;T extends Enum&lt;T&gt;&gt; T valueOf(Class&lt;T&gt;, String)
                  efficiently.  Note that the map is returned by this method is
                  created lazily on first use.  Typically it won&apos;t ever get created.                
            </javadoc>
            <method name="enumConstantDirectory" type="Map<String,T>" line="2976">
                <scope line="2977">
                    <declaration name="universe" type="T[]" line="2978"/>
                    <declaration name="m" type="Map&lt;String,T&gt;" line="2982"/>
                </scope>
            </method>
            <declaration name="enumConstantDirectory" type="Map&lt;String,T&gt;" line="2989"/>
            <javadoc line="2991">
                Casts an object to the class or interface represented
                  by this {@code Class} object.                
                <param>
                    obj the object to be cast                    
                </param>
                <return>
                    the object after casting, or null if obj is null                    
                </return>
                <throws>
                    ClassCastException if the object is not
                      null and is not assignable to the type T.                    
                </throws>
                <since>
                    1.5                    
                </since>
            </javadoc>
            <method name="cast" type="T" line="3003">
                <params>
                    <param name="obj" type="Object"/>
                </params>
            </method>
            <method name="cannotCastMsg" type="String" line="3009">
                <params>
                    <param name="obj" type="Object"/>
                </params>
            </method>
            <javadoc line="3013">
                Casts this {@code Class} object to represent a subclass of the class
                  represented by the specified class object.  Checks that that the cast
                  is valid, and throws a {@code ClassCastException} if it is not.  If
                  this method succeeds, it always returns a reference to this class object.
                  &lt;p&gt;This method is useful when a client needs to &quot;narrow&quot; the type of
                  a {@code Class} object to pass it to an API that restricts the{@code Class} objects that it is willing to accept.  A cast would
                  generate a compile-time warning, as the correctness of the cast
                  could not be checked at runtime (because generic types are implemented
                  by erasure).                
                <return>
                    this {@code Class} object, cast to represent a subclass of
                      the specified class object.                    
                </return>
                <throws>
                    ClassCastException if this {@code Class} object does not
                      represent a subclass of the specified class (here "subclass" includes
                      the class itself).                    
                </throws>
                <since>
                    1.5                    
                </since>
            </javadoc>
            <method name="asSubclass" type="Class<? extends U>" line="3033">
                <params>
                    <param name="clazz" type="Class<U>"/>
                </params>
            </method>
            <javadoc line="3040">
                @throws NullPointerException {@inheritDoc}                
                <since>
                    1.5                    
                </since>
            </javadoc>
            <method name="getAnnotation" type="A" line="3044">
                <params>
                    <param name="annotationClass" type="Class<A>"/>
                </params>
            </method>
            <javadoc line="3052">
                @throws NullPointerException {@inheritDoc}                
                <since>
                    1.5                    
                </since>
            </javadoc>
            <method name="isAnnotationPresent" type="boolean" line="3057">
                <params>
                    <param name="annotationClass" type="Class<? extends Annotation>"/>
                </params>
            </method>
            <javadoc line="3065">
                @since 1.5                
            </javadoc>
            <method name="getAnnotations" type="Annotation[]" line="3068"/>
            <javadoc line="3073">
                @since 1.5                
            </javadoc>
            <method name="getDeclaredAnnotations" type="Annotation[]" line="3076"/>
            <declaration name="annotations" type="Map&lt;Class&lt;? extends Annotation&gt;,Annotation&gt;" line="3082"/>
            <declaration name="declaredAnnotations" type="Map&lt;Class&lt;? extends Annotation&gt;,Annotation&gt;" line="3083"/>
            <method name="initAnnotationsIfNecessary" type="void" line="3085">
                <declaration name="superClass" type="Class&lt;?&gt;" line="3091"/>
                <scope line="3092"/>
                <scope line="3094">
                    <scope line="3097">
                        <declaration name="annotationClass" type="Class&lt;? extends Annotation&gt;" line="3098"/>
                    </scope>
                </scope>
            </method>
            <declaration name="annotationType" type="AnnotationType" line="3108"/>
            <method name="setAnnotationType" type="void" line="3110">
                <params>
                    <param name="type" type="AnnotationType"/>
                </params>
            </method>
            <method name="getAnnotationType" type="AnnotationType" line="3114"/>
        </class>
    </source>