<?xml version="1.0" encoding="UTF-8"?>
    <source package="java.lang.invoke">
        <import package="sun.invoke.util.Wrapper"/>
        <import package="java.util.Arrays"/>
        <import package="java.util.Collections"/>
        <import package="java.util.HashMap"/>
        <import package="java.util.List"/>
        <import package="sun.invoke.util.BytecodeDescriptor"/>
        <import package="java.lang.invoke.MethodHandleStatics"/>
        <class name="MethodType" line="36">
            <comment line="86">
                {rtype, {ptype...}}                
            </comment>
            <comment line="88">
                The rtype and ptypes fields define the structural identity of the method type:                
            </comment>
            <comment line="92">
                The remaining fields are caches of various sorts:                
            </comment>
            <comment line="93">
                erased form, plus cached data about primitives                
            </comment>
            <comment line="94">
                alternative wrapped/unwrapped version                
            </comment>
            <comment line="95">
                cache of handy higher-order adapters                
            </comment>
            <comment line="107">
                                
            </comment>
            <comment line="108">
                                
            </comment>
            <comment line="109">
                                
            </comment>
            <comment line="639">
                                
            </comment>
            <comment line="652">
                                
            </comment>
            <comment line="705">
                / Queries which have to do with the bytecode architecture                
            </comment>
            <comment line="721">
                                
            </comment>
            <comment line="822">
                / Serialization.                
            </comment>
            <comment line="898">
                Support for resetting final fields while deserializing                
            </comment>
            <implements interface="java.io.Serializable"/>
            <javadoc line="36">
                A method type represents the arguments and return type accepted and
                  returned by a method handle, or the arguments and return type passed
                  and expected  by a method handle caller.  Method types must be properly
                  matched between a method handle and all its callers,
                  and the JVM&apos;s operations enforce this matching at, specifically
                  during calls to {@link MethodHandle#invokeExact MethodHandle.invokeExact}and {@link MethodHandle#invoke MethodHandle.invoke}, and during execution
                  of {@code invokedynamic} instructions.
                  &lt;p&gt;
                  The structure is a return type accompanied by any number of parameter types.
                  The types (primitive, {@code void}, and reference) are represented by {@link Class} objects.
                  (For ease of exposition, we treat {@code void} as if it were a type.
                  In fact, it denotes the absence of a return type.)
                  &lt;p&gt;
                  All instances of {@code MethodType} are immutable.
                  Two instances are completely interchangeable if they compare equal.
                  Equality depends on pairwise correspondence of the return and parameter types and on nothing else.
                  &lt;p&gt;
                  This type can be created only by factory methods.
                  All factory methods may cache values, though caching is not guaranteed.
                  Some factory methods are static, while others are virtual methods which
                  modify precursor method types, e.g., by changing a selected parameter.
                  &lt;p&gt;
                  Factory methods which operate on groups of parameter types
                  are systematically presented in two versions, so that both Java arrays and
                  Java lists can be used to work with groups of parameter types.
                  The query methods {@code parameterArray} and {@code parameterList}also provide a choice between arrays and lists.
                  &lt;p&gt;{@code MethodType} objects are sometimes derived from bytecode instructions
                  such as {@code invokedynamic}, specifically from the type descriptor strings associated
                  with the instructions in a class file&apos;s constant pool.
                  &lt;p&gt;
                  Like classes and strings, method types can also be represented directly
                  in a class file&apos;s constant pool as constants.
                  A method type may be loaded by an {@code ldc} instruction which refers
                  to a suitable {@code CONSTANT_MethodType} constant pool entry.
                  The entry refers to a {@code CONSTANT_Utf8} spelling for the descriptor string.
                  For more details, see the &lt;a href=&quot;package-summary.html#mtcon&quot;&gt;package summary&lt;/a&gt;.
                  &lt;p&gt;
                  When the JVM materializes a {@code MethodType} from a descriptor string,
                  all classes named in the descriptor must be accessible, and will be loaded.
                  (But the classes need not be initialized, as is the case with a {@code CONSTANT_Class}.)
                  This loading may occur at any time before the {@code MethodType} object is first derived.                
                <author>
                    John Rose, JSR 292 EG                    
                </author>
            </javadoc>
            <declaration name="serialVersionUID" type="long" line="85"/>
            <declaration name="rtype" type="Class&lt;?&gt;" line="88"/>
            <declaration name="ptypes" type="Class&lt;?&gt;[]" line="89"/>
            <declaration name="form" type="MethodTypeForm" line="92"/>
            <declaration name="wrapAlt" type="MethodType" line="93"/>
            <declaration name="invokers" type="Invokers" line="94"/>
            <javadoc line="96">
                Check the given parameters for validity and store them into the final fields.                
            </javadoc>
            <method name="MethodType" type="constructor" line="99">
                <params>
                    <param name="rtype" type="Class<?>"/>
                    <param name="ptypes" type="Class<?>[]"/>
                </params>
            </method>
            <method name="form" type="MethodTypeForm" line="106"/>
            <method name="rtype" type="Class<?>" line="107"/>
            <method name="ptypes" type="Class<?>[]" line="108"/>
            <method name="checkRtype" type="void" line="110">
                <params>
                    <param name="rtype" type="Class<?>"/>
                </params>
                <comment line="112">
                    null check                    
                </comment>
            </method>
            <method name="checkPtype" type="int" line="113">
                <params>
                    <param name="ptype" type="Class<?>"/>
                </params>
                <comment line="115">
                    NPE                    
                </comment>
            </method>
            <javadoc line="120">
                Return number of extra slots (count of long/double args).                
            </javadoc>
            <method name="checkPtypes" type="int" line="121">
                <params>
                    <param name="ptypes" type="Class<?>[]"/>
                </params>
                <declaration name="slots" type="int" line="122"/>
                <scope line="123"/>
            </method>
            <method name="checkSlotCount" type="void" line="129">
                <params>
                    <param name="count" type="int"/>
                </params>
            </method>
            <method name="newIndexOutOfBoundsException" type="IndexOutOfBoundsException" line="133">
                <params>
                    <param name="num" type="Object"/>
                </params>
            </method>
            <declaration name="internTable" type="HashMap&lt;MethodType,MethodType&gt;" line="138"/>
            <declaration name="NO_PTYPES" type="Class&lt;?&gt;[]" line="141"/>
            <javadoc line="143">
                Finds or creates an instance of the given method type.                
                <param>
                    rtype  the return type                    
                </param>
                <param>
                    ptypes the parameter types                    
                </param>
                <return>
                    a method type with the given components                    
                </return>
                <throws>
                    NullPointerException if {@code rtype} or {@code ptypes} or any element of {@code ptypes} is null                    
                </throws>
                <throws>
                    IllegalArgumentException if any element of {@code ptypes} is {@code void.class}                    
                </throws>
            </javadoc>
            <method name="methodType" type="MethodType" line="152">
                <params>
                    <param name="rtype" type="Class<?>"/>
                    <param name="ptypes" type="Class<?>[]"/>
                </params>
            </method>
            <javadoc line="156">
                Finds or creates a method type with the given components.
                  Convenience method for {@link #methodType(java.lang.Class,java.lang.Class[]) methodType}.                
                <return>
                    a method type with the given components                    
                </return>
                <throws>
                    NullPointerException if {@code rtype} or {@code ptypes} or any element of {@code ptypes} is null                    
                </throws>
                <throws>
                    IllegalArgumentException if any element of {@code ptypes} is {@code void.class}                    
                </throws>
            </javadoc>
            <method name="methodType" type="MethodType" line="164">
                <params>
                    <param name="rtype" type="Class<?>"/>
                    <param name="ptypes" type="List<Class<?>>"/>
                </params>
                <comment line="166">
                    random List impl. could return evil ptypes array                    
                </comment>
                <declaration name="notrust" type="boolean" line="165"/>
            </method>
            <method name="listToArray" type="Class<?>[]" line="169">
                <params>
                    <param name="ptypes" type="List<Class<?>>"/>
                </params>
                <comment line="171">
                    sanity check the size before the toArray call, since size might be huge                    
                </comment>
            </method>
            <javadoc line="175">
                Finds or creates a method type with the given components.
                  Convenience method for {@link #methodType(java.lang.Class,java.lang.Class[]) methodType}.
                  The leading parameter type is prepended to the remaining array.                
                <return>
                    a method type with the given components                    
                </return>
                <throws>
                    NullPointerException if {@code rtype} or {@code ptype0} or {@code ptypes} or any element of {@code ptypes} is null                    
                </throws>
                <throws>
                    IllegalArgumentException if {@code ptype0} or {@code ptypes} or any element of {@code ptypes} is {@code void.class}                    
                </throws>
            </javadoc>
            <method name="methodType" type="MethodType" line="184">
                <params>
                    <param name="rtype" type="Class<?>"/>
                    <param name="ptype0" type="Class<?>"/>
                    <param name="ptypes" type="Class<?>"/>
                </params>
                <declaration name="ptypes1" type="Class&lt;?&gt;[]" line="185"/>
            </method>
            <javadoc line="191">
                Finds or creates a method type with the given components.
                  Convenience method for {@link #methodType(java.lang.Class,java.lang.Class[]) methodType}.
                  The resulting method has no parameter types.                
                <return>
                    a method type with the given return value                    
                </return>
                <throws>
                    NullPointerException if {@code rtype} is null                    
                </throws>
            </javadoc>
            <method name="methodType" type="MethodType" line="199">
                <params>
                    <param name="rtype" type="Class<?>"/>
                </params>
            </method>
            <javadoc line="203">
                Finds or creates a method type with the given components.
                  Convenience method for {@link #methodType(java.lang.Class,java.lang.Class[]) methodType}.
                  The resulting method has the single given parameter type.                
                <return>
                    a method type with the given return value and parameter type                    
                </return>
                <throws>
                    NullPointerException if {@code rtype} or {@code ptype0} is null                    
                </throws>
                <throws>
                    IllegalArgumentException if {@code ptype0} is {@code void.class}                    
                </throws>
            </javadoc>
            <method name="methodType" type="MethodType" line="212">
                <params>
                    <param name="rtype" type="Class<?>"/>
                    <param name="ptype0" type="Class<?>"/>
                </params>
            </method>
            <javadoc line="216">
                Finds or creates a method type with the given components.
                  Convenience method for {@link #methodType(java.lang.Class,java.lang.Class[]) methodType}.
                  The resulting method has the same parameter types as {@code ptypes},
                  and the specified return type.                
                <throws>
                    NullPointerException if {@code rtype} or {@code ptypes} is null                    
                </throws>
            </javadoc>
            <method name="methodType" type="MethodType" line="224">
                <params>
                    <param name="rtype" type="Class<?>"/>
                    <param name="ptypes" type="MethodType"/>
                </params>
            </method>
            <javadoc line="228">
                Sole factory method to find or create an interned method type.                
                <param>
                    rtype desired return type                    
                </param>
                <param>
                    ptypes desired parameter types                    
                </param>
                <param>
                    trusted whether the ptypes can be used without cloning                    
                </param>
                <return>
                    the unique method type of the desired structure                    
                </return>
            </javadoc>
            <method name="makeImpl" type="MethodType" line="236">
                <params>
                    <param name="rtype" type="Class<?>"/>
                    <param name="ptypes" type="Class<?>[]"/>
                    <param name="trusted" type="boolean"/>
                </params>
                <comment line="236">
                                        
                </comment>
                <comment line="249">
                    defensively copy the array passed in by the user                    
                </comment>
                <comment line="251">
                    promote the object to the Real Thing, and reprobe                    
                </comment>
                <comment line="255">
                    This is a principal (erased) type; show it to the JVM.                    
                </comment>
                <scope line="237"/>
                <declaration name="mt1" type="MethodType" line="240"/>
                <declaration name="mt0" type="MethodType" line="241"/>
                <scope line="242"/>
                <declaration name="form" type="MethodTypeForm" line="251"/>
                <scope line="253"/>
                <scope line="257"/>
            </method>
            <declaration name="objectOnlyTypes" type="MethodType[]" line="266"/>
            <javadoc line="268">
                Finds or creates a method type whose components are {@code Object} with an optional trailing {@code Object[]} array.
                  Convenience method for {@link #methodType(java.lang.Class,java.lang.Class[]) methodType}.
                  All parameters and the return type will be {@code Object},
                  except the final array parameter if any, which will be {@code Object[]}.                
                <param>
                    objectArgCount number of parameters (excluding the final array parameter if any)                    
                </param>
                <param>
                    finalArray whether there will be a trailing array parameter, of type {@code Object[]}                    
                </param>
                <return>
                    a generally applicable method type, for all calls of the given fixed argument count and a collected array of further arguments                    
                </return>
                <throws>
                    IllegalArgumentException if {@code objectArgCount} is negative or greater than 255 (or 254, if {@code finalArray} is true)                    
                </throws>
                <see>
                    #genericMethodType(int)                    
                </see>
            </javadoc>
            <method name="genericMethodType" type="MethodType" line="280">
                <params>
                    <param name="objectArgCount" type="int"/>
                    <param name="finalArray" type="boolean"/>
                </params>
                <comment line="295">
                    cache it here also!                    
                </comment>
                <declaration name="mt" type="MethodType" line="281"/>
                <declaration name="ivarargs" type="int" line="283"/>
                <declaration name="ootIndex" type="int" line="284"/>
                <scope line="285"/>
                <declaration name="ptypes" type="Class&lt;?&gt;[]" line="289"/>
                <scope line="293"/>
            </method>
            <javadoc line="299">
                Finds or creates a method type whose components are all {@code Object}.
                  Convenience method for {@link #methodType(java.lang.Class,java.lang.Class[]) methodType}.
                  All parameters and the return type will be Object.                
                <param>
                    objectArgCount number of parameters                    
                </param>
                <return>
                    a generally applicable method type, for all calls of the given argument count                    
                </return>
                <throws>
                    IllegalArgumentException if {@code objectArgCount} is negative or greater than 255                    
                </throws>
                <see>
                    #genericMethodType(int,boolean)                    
                </see>
            </javadoc>
            <method name="genericMethodType" type="MethodType" line="309">
                <params>
                    <param name="objectArgCount" type="int"/>
                </params>
            </method>
            <javadoc line="313">
                Finds or creates a method type with a single different parameter type.
                  Convenience method for {@link #methodType(java.lang.Class,java.lang.Class[]) methodType}.                
                <param>
                    num    the index (zero-based) of the parameter type to change                    
                </param>
                <param>
                    nptype a new parameter type to replace the old one with                    
                </param>
                <return>
                    the same type, except with the selected parameter changed                    
                </return>
                <throws>
                    IndexOutOfBoundsException if {@code num} is not a valid index into {@code parameterArray()}                    
                </throws>
                <throws>
                    IllegalArgumentException if {@code nptype} is {@code void.class}                    
                </throws>
                <throws>
                    NullPointerException if {@code nptype} is null                    
                </throws>
            </javadoc>
            <method name="changeParameterType" type="MethodType" line="323">
                <params>
                    <param name="num" type="int"/>
                    <param name="nptype" type="Class<?>"/>
                </params>
                <declaration name="nptypes" type="Class&lt;?&gt;[]" line="326"/>
            </method>
            <javadoc line="331">
                Finds or creates a method type with additional parameter types.
                  Convenience method for {@link #methodType(java.lang.Class,java.lang.Class[]) methodType}.                
                <param>
                    num    the position (zero-based) of the inserted parameter type(s)                    
                </param>
                <param>
                    ptypesToInsert zero or more new parameter types to insert into the parameter list                    
                </param>
                <return>
                    the same type, except with the selected parameter(s) inserted                    
                </return>
                <throws>
                    IndexOutOfBoundsException if {@code num} is negative or greater than {@code parameterCount()}                    
                </throws>
                <throws>
                    IllegalArgumentException if any element of {@code ptypesToInsert} is {@code void.class}or if the resulting method type would have more than 255 parameter slots                    
                </throws>
                <throws>
                    NullPointerException if {@code ptypesToInsert} or any of its elements is null                    
                </throws>
            </javadoc>
            <method name="insertParameterTypes" type="MethodType" line="342">
                <params>
                    <param name="num" type="int"/>
                    <param name="ptypesToInsert" type="Class<?>"/>
                </params>
                <declaration name="len" type="int" line="343"/>
                <declaration name="ins" type="int" line="346"/>
                <declaration name="ilen" type="int" line="348"/>
                <declaration name="nptypes" type="Class&lt;?&gt;[]" line="350"/>
            </method>
            <javadoc line="356">
                Finds or creates a method type with additional parameter types.
                  Convenience method for {@link #methodType(java.lang.Class,java.lang.Class[]) methodType}.                
                <param>
                    ptypesToInsert zero or more new parameter types to insert after the end of the parameter list                    
                </param>
                <return>
                    the same type, except with the selected parameter(s) appended                    
                </return>
                <throws>
                    IllegalArgumentException if any element of {@code ptypesToInsert} is {@code void.class}or if the resulting method type would have more than 255 parameter slots                    
                </throws>
                <throws>
                    NullPointerException if {@code ptypesToInsert} or any of its elements is null                    
                </throws>
            </javadoc>
            <method name="appendParameterTypes" type="MethodType" line="365">
                <params>
                    <param name="ptypesToInsert" type="Class<?>"/>
                </params>
            </method>
            <javadoc line="369">
                Finds or creates a method type with additional parameter types.
                  Convenience method for {@link #methodType(java.lang.Class,java.lang.Class[]) methodType}.                
                <param>
                    num    the position (zero-based) of the inserted parameter type(s)                    
                </param>
                <param>
                    ptypesToInsert zero or more new parameter types to insert into the parameter list                    
                </param>
                <return>
                    the same type, except with the selected parameter(s) inserted                    
                </return>
                <throws>
                    IndexOutOfBoundsException if {@code num} is negative or greater than {@code parameterCount()}                    
                </throws>
                <throws>
                    IllegalArgumentException if any element of {@code ptypesToInsert} is {@code void.class}or if the resulting method type would have more than 255 parameter slots                    
                </throws>
                <throws>
                    NullPointerException if {@code ptypesToInsert} or any of its elements is null                    
                </throws>
            </javadoc>
            <method name="insertParameterTypes" type="MethodType" line="380">
                <params>
                    <param name="num" type="int"/>
                    <param name="ptypesToInsert" type="List<Class<?>>"/>
                </params>
            </method>
            <javadoc line="384">
                Finds or creates a method type with additional parameter types.
                  Convenience method for {@link #methodType(java.lang.Class,java.lang.Class[]) methodType}.                
                <param>
                    ptypesToInsert zero or more new parameter types to insert after the end of the parameter list                    
                </param>
                <return>
                    the same type, except with the selected parameter(s) appended                    
                </return>
                <throws>
                    IllegalArgumentException if any element of {@code ptypesToInsert} is {@code void.class}or if the resulting method type would have more than 255 parameter slots                    
                </throws>
                <throws>
                    NullPointerException if {@code ptypesToInsert} or any of its elements is null                    
                </throws>
            </javadoc>
            <method name="appendParameterTypes" type="MethodType" line="393">
                <params>
                    <param name="ptypesToInsert" type="List<Class<?>>"/>
                </params>
            </method>
            <javadoc line="397">
                Finds or creates a method type with some parameter types omitted.
                  Convenience method for {@link #methodType(java.lang.Class,java.lang.Class[]) methodType}.                
                <param>
                    start  the index (zero-based) of the first parameter type to remove                    
                </param>
                <param>
                    end    the index (greater than {@code start}) of the first parameter type after not to remove                    
                </param>
                <return>
                    the same type, except with the selected parameter(s) removed                    
                </return>
                <throws>
                    IndexOutOfBoundsException if {@code start} is negative or greater than {@code parameterCount()}or if {@code end} is negative or greater than {@code parameterCount()}or if {@code start} is greater than {@code end}                    
                </throws>
            </javadoc>
            <method name="dropParameterTypes" type="MethodType" line="407">
                <params>
                    <param name="start" type="int"/>
                    <param name="end" type="int"/>
                </params>
                <comment line="416">
                    drop all parameters                    
                </comment>
                <comment line="419">
                    drop initial parameter(s)                    
                </comment>
                <comment line="424">
                    drop trailing parameter(s)                    
                </comment>
                <declaration name="len" type="int" line="408"/>
                <declaration name="nptypes" type="Class&lt;?&gt;[]" line="412"/>
                <scope line="413">
                    <scope line="414"/>
                    <scope line="417"/>
                </scope>
                <scope line="421">
                    <scope line="422"/>
                    <scope line="425">
                        <declaration name="tail" type="int" line="426"/>
                    </scope>
                </scope>
            </method>
            <javadoc line="434">
                Finds or creates a method type with a different return type.
                  Convenience method for {@link #methodType(java.lang.Class,java.lang.Class[]) methodType}.                
                <param>
                    nrtype a return parameter type to replace the old one with                    
                </param>
                <return>
                    the same type, except with the return type change                    
                </return>
                <throws>
                    NullPointerException if {@code nrtype} is null                    
                </throws>
            </javadoc>
            <method name="changeReturnType" type="MethodType" line="441">
                <params>
                    <param name="nrtype" type="Class<?>"/>
                </params>
            </method>
            <javadoc line="446">
                Reports if this type contains a primitive argument or return value.
                  The return type {@code void} counts as a primitive.                
                <return>
                    true if any of the types are primitives                    
                </return>
            </javadoc>
            <method name="hasPrimitives" type="boolean" line="451"/>
            <javadoc line="455">
                Reports if this type contains a wrapper argument or return value.
                  Wrappers are types which box primitive values, such as {@link Integer}.
                  The reference type {@code java.lang.Void} counts as a wrapper,
                  if it occurs as a return type.                
                <return>
                    true if any of the types are wrappers                    
                </return>
            </javadoc>
            <method name="hasWrappers" type="boolean" line="462"/>
            <javadoc line="466">
                Erases all reference types to {@code Object}.
                  Convenience method for {@link #methodType(java.lang.Class,java.lang.Class[]) methodType}.
                  All primitive types (including {@code void}) will remain unchanged.                
                <return>
                    a version of the original type with all reference types replaced                    
                </return>
            </javadoc>
            <method name="erase" type="MethodType" line="472"/>
            <javadoc line="476">
                Converts all types, both reference and primitive, to {@code Object}.
                  Convenience method for {@link #genericMethodType(int) genericMethodType}.
                  The expression {@code type.wrap().erase()} produces the same value
                  as {@code type.generic()}.                
                <return>
                    a version of the original type with all types replaced                    
                </return>
            </javadoc>
            <method name="generic" type="MethodType" line="483"/>
            <javadoc line="487">
                Converts all primitive types to their corresponding wrapper types.
                  Convenience method for {@link #methodType(java.lang.Class,java.lang.Class[]) methodType}.
                  All reference types (including wrapper types) will remain unchanged.
                  A {@code void} return type is changed to the type {@code java.lang.Void}.
                  The expression {@code type.wrap().erase()} produces the same value
                  as {@code type.generic()}.                
                <return>
                    a version of the original type with all primitive types replaced                    
                </return>
            </javadoc>
            <method name="wrap" type="MethodType" line="496"/>
            <javadoc line="500">
                Converts all wrapper types to their corresponding primitive types.
                  Convenience method for {@link #methodType(java.lang.Class,java.lang.Class[]) methodType}.
                  All primitive types (including {@code void}) will remain unchanged.
                  A return type of {@code java.lang.Void} is changed to {@code void}.                
                <return>
                    a version of the original type with all wrapper types replaced                    
                </return>
            </javadoc>
            <method name="unwrap" type="MethodType" line="507">
                <declaration name="noprims" type="MethodType" line="508"/>
            </method>
            <method name="wrapWithPrims" type="MethodType" line="512">
                <params>
                    <param name="pt" type="MethodType"/>
                </params>
                <comment line="517">
                    fill in lazily                    
                </comment>
                <declaration name="wt" type="MethodType" line="514"/>
                <scope line="515"/>
            </method>
            <method name="unwrapWithNoPrims" type="MethodType" line="524">
                <params>
                    <param name="wt" type="MethodType"/>
                </params>
                <comment line="529">
                    fill in lazily                    
                </comment>
                <comment line="532">
                    type has no wrappers or prims at all                    
                </comment>
                <declaration name="uwt" type="MethodType" line="526"/>
                <scope line="527"/>
            </method>
            <javadoc line="537">
                Returns the parameter type at the specified index, within this method type.                
                <param>
                    num the index (zero-based) of the desired parameter type                    
                </param>
                <return>
                    the selected parameter type                    
                </return>
                <throws>
                    IndexOutOfBoundsException if {@code num} is not a valid index into {@code parameterArray()}                    
                </throws>
            </javadoc>
            <method name="parameterType" type="Class<?>" line="543">
                <params>
                    <param name="num" type="int"/>
                </params>
            </method>
            <javadoc line="546">
                Returns the number of parameter types in this method type.                
                <return>
                    the number of parameter types                    
                </return>
            </javadoc>
            <method name="parameterCount" type="int" line="550"/>
            <javadoc line="553">
                Returns the return type of this method type.                
                <return>
                    the return type                    
                </return>
            </javadoc>
            <method name="returnType" type="Class<?>" line="557"/>
            <javadoc line="561">
                Presents the parameter types as a list (a convenience method).
                  The list will be immutable.                
                <return>
                    the parameter types (as an immutable list)                    
                </return>
            </javadoc>
            <method name="parameterList" type="List<Class<?>>" line="566"/>
            <javadoc line="570">
                Presents the parameter types as an array (a convenience method).
                  Changes to the array will not result in changes to the type.                
                <return>
                    the parameter types (as a fresh copy if necessary)                    
                </return>
            </javadoc>
            <method name="parameterArray" type="Class<?>[]" line="575"/>
            <javadoc line="579">
                Compares the specified object with this type for equality.
                  That is, it returns &lt;tt&gt;true&lt;/tt&gt; if and only if the specified object
                  is also a method type with exactly the same parameters and return type.                
                <param>
                    x object to compare                    
                </param>
                <see>
                    Object#equals(Object)                    
                </see>
            </javadoc>
            <method name="equals" type="boolean" line="587">
                <params>
                    <param name="x" type="Object"/>
                </params>
            </method>
            <method name="equals" type="boolean" line="591">
                <params>
                    <param name="that" type="MethodType"/>
                </params>
            </method>
            <javadoc line="596">
                Returns the hash code value for this method type.
                  It is defined to be the same as the hashcode of a List
                  whose elements are the return type followed by the
                  parameter types.                
                <return>
                    the hash code value for this method type                    
                </return>
                <see>
                    Object#hashCode()                    
                </see>
                <see>
                    #equals(Object)                    
                </see>
                <see>
                    List#hashCode()                    
                </see>
            </javadoc>
            <method name="hashCode" type="int" line="607">
                <declaration name="hashCode" type="int" line="608"/>
            </method>
            <javadoc line="614">
                Returns a string representation of the method type,
                  of the form {@code &quot;(PT0,PT1...)RT&quot;}.
                  The string representation of a method type is a
                  parenthesis enclosed, comma separated list of type names,
                  followed immediately by the return type.
                  &lt;p&gt;
                  Each type is represented by its{@link java.lang.Class#getSimpleName simple name}.                
            </javadoc>
            <method name="toString" type="String" line="625">
                <declaration name="sb" type="StringBuilder" line="626"/>
                <scope line="628"/>
            </method>
            <method name="isConvertibleTo" type="boolean" line="639">
                <params>
                    <param name="newType" type="MethodType"/>
                </params>
                <declaration name="argc" type="int" line="642"/>
                <scope line="645"/>
            </method>
            <method name="canConvert" type="boolean" line="652">
                <params>
                    <param name="src" type="Class<?>"/>
                    <param name="dst" type="Class<?>"/>
                </params>
                <comment line="654">
                    short-circuit a few cases:                    
                </comment>
                <comment line="656">
                    the remainder of this logic is documented in MethodHandle.asType                    
                </comment>
                <comment line="658">
                    can force void to an explicit null, a la reflect.Method.invoke
                     can also force void to a primitive zero, by analogy                    
                </comment>
                <comment line="660">
                    or !dst.isPrimitive()?                    
                </comment>
                <comment line="663">
                    P-&gt;P must widen                    
                </comment>
                <comment line="666">
                    P-&gt;R must box and widen                    
                </comment>
                <comment line="670">
                    any value can be dropped                    
                </comment>
                <comment line="673">
                    R-&gt;P must be able to unbox (from a dynamically chosen type) and widen
                     For example:
                       Byte/Number/Comparable/Object -&gt; dw:Byte -&gt; byte.
                       Character/Comparable/Object -&gt; dw:Character -&gt; char
                       Boolean/Comparable/Object -&gt; dw:Boolean -&gt; boolean
                     This means that dw must be cast-compatible with src.                    
                </comment>
                <comment line="682">
                    The above does not work if the source reference is strongly typed
                     to a wrapper whose primitive must be widened.  For example:
                       Byte -&gt; unbox:byte -&gt; short/int/long/float/double
                       Character -&gt; unbox:char -&gt; int/long/float/double                    
                </comment>
                <comment line="688">
                    can unbox from src and then widen to dst                    
                </comment>
                <comment line="691">
                    We have already covered cases which arise due to runtime unboxing
                     of a reference type which covers several wrapper types:
                       Object -&gt; cast:Integer -&gt; unbox:int -&gt; long/float/double
                       Serializable -&gt; cast:Byte -&gt; unbox:byte -&gt; byte/short/int/long/float/double
                     An marginal case is Number -&gt; dw:Character -&gt; char, which would be OK if there were a
                     subclass of Number which wraps a value that can convert to char.
                     Since there is none, we don&apos;t need an extra check here to cover char or boolean.                    
                </comment>
                <comment line="700">
                    R-&gt;R always works, since null is always valid dynamically                    
                </comment>
                <scope line="656">
                    <declaration name="sw" type="Wrapper" line="660"/>
                    <scope line="661"/>
                    <scope line="664"/>
                </scope>
                <scope line="668">
                    <declaration name="dw" type="Wrapper" line="671"/>
                    <scope line="678"/>
                    <scope line="686"/>
                </scope>
                <scope line="698"/>
            </method>
            <javadoc line="706">
                Reports the number of JVM stack slots required to invoke a method
                  of this type.  Note that (for historical reasons) the JVM requires
                  a second stack slot to pass long and double arguments.
                  So this method returns {@link #parameterCount() parameterCount} plus the
                  number of long and double parameters (if any).
                  &lt;p&gt;
                  This method is included for the benfit of applications that must
                  generate bytecodes that process method handles and invokedynamic.                
                <return>
                    the number of JVM stack slots for this type&apos;s parameters                    
                </return>
            </javadoc>
            <method name="parameterSlotCount" type="int" line="716">
                <comment line="717">
                                        
                </comment>
            </method>
            <method name="invokers" type="Invokers" line="720">
                <declaration name="inv" type="Invokers" line="721"/>
            </method>
            <javadoc line="727">
                Reports the number of JVM stack slots which carry all parameters including and after
                  the given position, which must be in the range of 0 to{@code parameterCount} inclusive.  Successive parameters are
                  more shallowly stacked, and parameters are indexed in the bytecodes
                  according to their trailing edge.  Thus, to obtain the depth
                  in the outgoing call stack of parameter {@code N}, obtain
                  the {@code parameterSlotDepth} of its trailing edge
                  at position {@code N+1}.
                  &lt;p&gt;
                  Parameters of type {@code long} and {@code double} occupy
                  two stack slots (for historical reasons) and all others occupy one.
                  Therefore, the number returned is the number of arguments
                  &lt;em&gt;including&lt;/em&gt; and &lt;em&gt;after&lt;/em&gt; the given parameter,
                  &lt;em&gt;plus&lt;/em&gt; the number of long or double arguments
                  at or after after the argument for the given parameter.
                  &lt;p&gt;
                  This method is included for the benfit of applications that must
                  generate bytecodes that process method handles and invokedynamic.                
                <param>
                    num an index (zero-based, inclusive) within the parameter types                    
                </param>
                <return>
                    the index of the (shallowest) JVM stack slot transmitting the
                      given parameter                    
                </return>
                <throws>
                    IllegalArgumentException if {@code num} is negative or greater than {@code parameterCount()}                    
                </throws>
            </javadoc>
            <method name="parameterSlotDepth" type="int" line="750">
                <params>
                    <param name="num" type="int"/>
                </params>
                <comment line="751">
                                        
                </comment>
                <comment line="753">
                    force a range check                    
                </comment>
            </method>
            <javadoc line="756">
                Reports the number of JVM stack slots required to receive a return value
                  from a method of this type.
                  If the {@link #returnType() return type} is void, it will be zero,
                  else if the return type is long or double, it will be two, else one.
                  &lt;p&gt;
                  This method is included for the benfit of applications that must
                  generate bytecodes that process method handles and invokedynamic.                
                <return>
                    the number of JVM stack slots (0, 1, or 2) for this type&apos;s return value
                      Will be removed for PFD.                    
                </return>
            </javadoc>
            <method name="returnSlotCount" type="int" line="766">
                <comment line="767">
                                        
                </comment>
            </method>
            <javadoc line="770">
                Finds or creates an instance of a method type, given the spelling of its bytecode descriptor.
                  Convenience method for {@link #methodType(java.lang.Class,java.lang.Class[]) methodType}.
                  Any class or interface name embedded in the descriptor string
                  will be resolved by calling {@link ClassLoader#loadClass(java.lang.String)}on the given loader (or if it is null, on the system class loader).
                  &lt;p&gt;
                  Note that it is possible to encounter method types which cannot be
                  constructed by this method, because their component types are
                  not all reachable from a common class loader.
                  &lt;p&gt;
                  This method is included for the benfit of applications that must
                  generate bytecodes that process method handles and {@code invokedynamic}.                
                <param>
                    descriptor a bytecode-level type descriptor string &quot;(T...)T&quot;                    
                </param>
                <param>
                    loader the class loader in which to look up the types                    
                </param>
                <return>
                    a method type matching the bytecode-level type descriptor                    
                </return>
                <throws>
                    NullPointerException if the string is null                    
                </throws>
                <throws>
                    IllegalArgumentException if the string is not well-formed                    
                </throws>
                <throws>
                    TypeNotPresentException if a named type cannot be found                    
                </throws>
            </javadoc>
            <method name="fromMethodDescriptorString" type="MethodType" line="792">
                <params>
                    <param name="descriptor" type="String"/>
                    <param name="loader" type="ClassLoader"/>
                </params>
                <comment line="794">
                    also generates NPE if needed                    
                </comment>
                <declaration name="types" type="List&lt;Class&lt;?&gt;&gt;" line="797"/>
                <declaration name="rtype" type="Class&lt;?&gt;" line="798"/>
                <declaration name="ptypes" type="Class&lt;?&gt;[]" line="800"/>
            </method>
            <javadoc line="804">
                Produces a bytecode descriptor representation of the method type.
                  &lt;p&gt;
                  Note that this is not a strict inverse of {@link #fromMethodDescriptorString fromMethodDescriptorString}.
                  Two distinct classes which share a common name but have different class loaders
                  will appear identical when viewed within descriptor strings.
                  &lt;p&gt;
                  This method is included for the benfit of applications that must
                  generate bytecodes that process method handles and {@code invokedynamic}.{@link #fromMethodDescriptorString(java.lang.String,java.lang.ClassLoader) fromMethodDescriptorString},
                  because the latter requires a suitable class loader argument.                
                <return>
                    the bytecode type descriptor representation                    
                </return>
            </javadoc>
            <method name="toMethodDescriptorString" type="String" line="817"/>
            <declaration name="serialPersistentFields" type="java.io.ObjectStreamField[]" line="823"/>
            <javadoc line="823">
                There are no serializable fields for {@code MethodType}.                
            </javadoc>
            <javadoc line="828">
                Save the {@code MethodType} instance to a stream.                
                <serialData>
                    For portability, the serialized format does not refer to named fields.
                      Instead, the return type and parameter type arrays are written directly
                      from the {@code writeObject} method, using two calls to {@code s.writeObject}as follows:
                      &lt;blockquote&gt;&lt;pre&gt;
                      s.writeObject(this.returnType());
                      s.writeObject(this.parameterArray());
                      &lt;/pre&gt;&lt;/blockquote&gt;
                      &lt;p&gt;
                      The deserialized field values are checked as if they were
                      provided to the factory method {@link #methodType(Class,Class[]) methodType}.
                      For example, null values, or {@code void} parameter types,
                      will lead to exceptions during deserialization.                    
                </serialData>
                <param>
                    the stream to write the object to                    
                </param>
            </javadoc>
            <method name="writeObject" type="void" line="847">
                <params>
                    <param name="s" type="java.io.ObjectOutputStream"/>
                </params>
                <comment line="849">
                    requires serialPersistentFields to be an empty array                    
                </comment>
            </method>
            <javadoc line="853">
                Reconstitute the {@code MethodType} instance from a stream (that is,
                  deserialize it).
                  This instance is a scratch object with bogus final fields.
                  It provides the parameters to the factory method called by{@link #readResolve readResolve}.
                  After that call it is discarded.                
                <param>
                    the stream to read the object from                    
                </param>
                <see>
                    #MethodType()                    
                </see>
                <see>
                    #readResolve                    
                </see>
                <see>
                    #writeObject                    
                </see>
            </javadoc>
            <method name="readObject" type="void" line="865">
                <params>
                    <param name="s" type="java.io.ObjectInputStream"/>
                </params>
                <comment line="867">
                    requires serialPersistentFields to be an empty array                    
                </comment>
                <comment line="872">
                    Probably this object will never escape, but let&apos;s check
                     the field values now, just to be sure.                    
                </comment>
                <comment line="877">
                    make sure it is unshared                    
                </comment>
                <declaration name="returnType" type="Class&lt;?&gt;" line="868"/>
                <declaration name="parameterArray" type="Class&lt;?&gt;[]" line="869"/>
            </method>
            <javadoc line="880">
                For serialization only.
                  Sets the final fields to null, pending {@code Unsafe.putObject}.                
            </javadoc>
            <method name="MethodType" type="constructor" line="884"/>
            <method name="MethodType_init" type="void" line="888">
                <params>
                    <param name="rtype" type="Class<?>"/>
                    <param name="ptypes" type="Class<?>[]"/>
                </params>
                <comment line="890">
                    In order to communicate these values to readResolve, we must
                     store them into the implementation-specific final fields.                    
                </comment>
            </method>
            <declaration name="unsafe" type="sun.misc.Unsafe" line="898"/>
            <declaration name="rtypeOffset" type="long" line="899"/>
            <scope line="900">
                <scope line="901"/>
                <scope line="906"/>
            </scope>
            <javadoc line="911">
                Resolves and initializes a {@code MethodType} object
                  after serialization.                
                <return>
                    the fully initialized {@code MethodType} object                    
                </return>
            </javadoc>
            <method name="readResolve" type="Object" line="916">
                <comment line="918">
                    Do not use a trusted path for deserialization:
                    return makeImpl(rtype, ptypes, true);
                     Verify all operands, and make sure ptypes is unshared:                    
                </comment>
            </method>
        </class>
    </source>