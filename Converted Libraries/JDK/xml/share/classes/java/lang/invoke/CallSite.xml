<?xml version="1.0" encoding="UTF-8"?>
    <source package="java.lang.invoke">
        <import package="sun.invoke.empty.Empty"/>
        <import package="sun.misc.Unsafe"/>
        <import package="java.lang.invoke.MethodHandleStatics"/>
        <import package="java.lang.invoke.MethodHandles.Lookup.IMPL_LOOKUP"/>
        <class name="CallSite" line="33">
            <comment line="91">
                Fields used only by the JVM.  Do not use or change.                
            </comment>
            <comment line="92">
                supplied by the JVM (ref. to calling method)                
            </comment>
            <comment line="93">
                supplied by the JVM (BCI within calling method)                
            </comment>
            <comment line="95">
                The actual payload of this call site:                
            </comment>
            <comment line="96">
                                
            </comment>
            <comment line="237">
                                
            </comment>
            <comment line="259">
                unsafe stuff:                
            </comment>
            <comment line="269">
                                
            </comment>
            <comment line="273">
                                
            </comment>
            <comment line="277">
                                
            </comment>
            <comment line="282">
                this implements the upcall from the JVM, MethodHandleNatives.makeDynamicCallSite:                
            </comment>
            <javadoc line="33">
                A {@code CallSite} is a holder for a variable {@link MethodHandle},
                  which is called its {@code target}.
                  An {@code invokedynamic} instruction linked to a {@code CallSite} delegates
                  all calls to the site&apos;s current target.
                  A {@code CallSite} may be associated with several {@code invokedynamic}instructions, or it may be &quot;free floating&quot;, associated with none.
                  In any case, it may be invoked through an associated method handle
                  called its {@linkplain #dynamicInvoker dynamic invoker}.
                  &lt;p&gt;{@code CallSite} is an abstract class which does not allow
                  direct subclassing by users.  It has three immediate,
                  concrete subclasses that may be either instantiated or subclassed.
                  &lt;ul&gt;
                  &lt;li&gt;If a mutable target is not required, an {@code invokedynamic} instruction
                  may be permanently bound by means of a {@linkplain ConstantCallSite constant call site}.
                  &lt;li&gt;If a mutable target is required which has volatile variable semantics,
                  because updates to the target must be immediately and reliably witnessed by other threads,
                  a {@linkplain VolatileCallSite volatile call site} may be used.
                  &lt;li&gt;Otherwise, if a mutable target is required,
                  a {@linkplain MutableCallSite mutable call site} may be used.
                  &lt;/ul&gt;
                  &lt;p&gt;
                  A non-constant call site may be &lt;em&gt;relinked&lt;/em&gt; by changing its target.
                  The new target must have the same {@linkplain MethodHandle#type() type}as the previous target.
                  Thus, though a call site can be relinked to a series of
                  successive targets, it cannot change its type.
                  &lt;p&gt;
                  Here is a sample use of call sites and bootstrap methods which links every
                  dynamic call site to print its arguments:
                  &lt;blockquote&gt;&lt;pre&gt;&lt;!-- see indy-demo/src/PrintArgsDemo.java --&gt;
                  static void test() throws Throwable {
                  // THE FOLLOWING LINE IS PSEUDOCODE FOR A JVM INSTRUCTION
                  InvokeDynamic[#bootstrapDynamic].baz(&quot;baz arg&quot;, 2, 3.14);
                  }
                  private static void printArgs(Object... args) {
                  System.out.println(java.util.Arrays.deepToString(args));
                  }
                  private static final MethodHandle printArgs;
                  static {
                  MethodHandles.Lookup lookup = MethodHandles.lookup();
                  Class thisClass = lookup.lookupClass();  // (who am I?)
                  printArgs = lookup.findStatic(thisClass,
                  &quot;printArgs&quot;, MethodType.methodType(void.class, Object[].class));
                  }
                  private static CallSite bootstrapDynamic(MethodHandles.Lookup caller, String name, MethodType type) {
                  // ignore caller and name, but match the type:
                  return new ConstantCallSite(printArgs.asType(type));
                  }
                  &lt;/pre&gt;&lt;/blockquote&gt;                
                <author>
                    John Rose, JSR 292 EG                    
                </author>
            </javadoc>
            <scope line="88"/>
            <declaration name="vmmethod" type="MemberName" line="91"/>
            <declaration name="vmindex" type="int" line="92"/>
            <declaration name="target" type="MethodHandle" line="96"/>
            <javadoc line="98">
                Make a blank call site object with the given method type.
                  An initial target method is supplied which will throw
                  an {@link IllegalStateException} if called.
                  &lt;p&gt;
                  Before this {@code CallSite} object is returned from a bootstrap method,
                  it is usually provided with a more useful target method,
                  via a call to {@link CallSite#setTarget(MethodHandle) setTarget}.                
                <throws>
                    NullPointerException if the proposed type is null                    
                </throws>
            </javadoc>
            <method name="CallSite" type="constructor" line="109">
                <params>
                    <param name="type" type="MethodType"/>
                </params>
                <comment line="109">
                                        
                </comment>
            </method>
            <javadoc line="113">
                Make a call site object equipped with an initial target method handle.                
                <param>
                    target the method handle which will be the initial target of the call site                    
                </param>
                <throws>
                    NullPointerException if the proposed target is null                    
                </throws>
            </javadoc>
            <method name="CallSite" type="constructor" line="119">
                <params>
                    <param name="target" type="MethodHandle"/>
                </params>
                <comment line="119">
                                        
                </comment>
                <comment line="121">
                    null check                    
                </comment>
            </method>
            <javadoc line="124">
                Make a call site object equipped with an initial target method handle.                
                <param>
                    targetType the desired type of the call site                    
                </param>
                <param>
                    createTargetHook a hook which will bind the call site to the target method handle                    
                </param>
                <throws>
                    WrongMethodTypeException if the hook cannot be invoked on the required arguments,
                      or if the target returned by the hook is not of the given {@code targetType}                    
                </throws>
                <throws>
                    NullPointerException if the hook returns a null value                    
                </throws>
                <throws>
                    ClassCastException if the hook returns something other than a {@code MethodHandle}                    
                </throws>
                <throws>
                    Throwable anything else thrown by the the hook function                    
                </throws>
            </javadoc>
            <method name="CallSite" type="constructor" line="135">
                <params>
                    <param name="targetType" type="MethodType"/>
                    <param name="createTargetHook" type="MethodHandle"/>
                </params>
                <comment line="135">
                                        
                </comment>
                <declaration name="selfCCS" type="ConstantCallSite" line="137"/>
                <declaration name="boundTarget" type="MethodHandle" line="138"/>
            </method>
            <javadoc line="143">
                Returns the type of this call site&apos;s target.
                  Although targets may change, any call site&apos;s type is permanent, and can never change to an unequal type.
                  The {@code setTarget} method enforces this invariant by refusing any new target that does
                  not have the previous target&apos;s type.                
                <return>
                    the type of the current target, which is also the type of any future target                    
                </return>
            </javadoc>
            <method name="type" type="MethodType" line="150">
                <comment line="152">
                    warning:  do not call getTarget here, because CCS.getTarget can throw IllegalStateException                    
                </comment>
            </method>
            <javadoc line="155">
                Called from JVM (or low-level Java code) after the BSM returns the newly created CallSite.
                  The parameters are JVM-specific.                
            </javadoc>
            <method name="initializeFromJVM" type="void" line="161">
                <params>
                    <param name="name" type="String"/>
                    <param name="type" type="MethodType"/>
                    <param name="callerMethod" type="MemberName"/>
                    <param name="callerBCI" type="int"/>
                </params>
                <comment line="164">
                    FIXME                    
                </comment>
                <scope line="162"/>
                <scope line="166"/>
            </method>
            <method name="getTarget" type="MethodHandle" line="173"/>
            <javadoc line="173">
                Returns the target method of the call site, according to the
                  behavior defined by this call site&apos;s specific class.
                  The immediate subclasses of {@code CallSite} document the
                  class-specific behaviors of this method.                
                <return>
                    the current linkage state of the call site, its target method handle                    
                </return>
                <see>
                    ConstantCallSite                    
                </see>
                <see>
                    VolatileCallSite                    
                </see>
                <see>
                    #setTarget                    
                </see>
                <see>
                    ConstantCallSite#getTarget                    
                </see>
                <see>
                    MutableCallSite#getTarget                    
                </see>
                <see>
                    VolatileCallSite#getTarget                    
                </see>
            </javadoc>
            <method name="setTarget" type="void" line="189"/>
            <javadoc line="189">
                Updates the target method of this call site, according to the
                  behavior defined by this call site&apos;s specific class.
                  The immediate subclasses of {@code CallSite} document the
                  class-specific behaviors of this method.
                  &lt;p&gt;
                  The type of the new target must be {@linkplain MethodType#equals equal to}the type of the old target.                
                <param>
                    newTarget the new target                    
                </param>
                <throws>
                    NullPointerException if the proposed new target is null                    
                </throws>
                <throws>
                    WrongMethodTypeException if the proposed new target
                      has a method type that differs from the previous target                    
                </throws>
                <see>
                    CallSite#getTarget                    
                </see>
                <see>
                    ConstantCallSite#setTarget                    
                </see>
                <see>
                    MutableCallSite#setTarget                    
                </see>
                <see>
                    VolatileCallSite#setTarget                    
                </see>
            </javadoc>
            <method name="checkTargetChange" type="void" line="209">
                <params>
                    <param name="oldTarget" type="MethodHandle"/>
                    <param name="newTarget" type="MethodHandle"/>
                </params>
                <comment line="212">
                    null check!                    
                </comment>
                <declaration name="oldType" type="MethodType" line="210"/>
                <declaration name="newType" type="MethodType" line="211"/>
            </method>
            <method name="wrongTargetType" type="WrongMethodTypeException" line="216">
                <params>
                    <param name="target" type="MethodHandle"/>
                    <param name="type" type="MethodType"/>
                </params>
            </method>
            <method name="dynamicInvoker" type="MethodHandle" line="220"/>
            <javadoc line="220">
                Produces a method handle equivalent to an invokedynamic instruction
                  which has been linked to this call site.
                  &lt;p&gt;
                  This method is equivalent to the following code:
                  &lt;blockquote&gt;&lt;pre&gt;
                  MethodHandle getTarget, invoker, result;
                  getTarget = MethodHandles.publicLookup().bind(this, &quot;getTarget&quot;, MethodType.methodType(MethodHandle.class));
                  invoker = MethodHandles.exactInvoker(this.type());
                  result = MethodHandles.foldArguments(invoker, getTarget)
                  &lt;/pre&gt;&lt;/blockquote&gt;                
                <return>
                    a method handle which always invokes this call site&apos;s current target                    
                </return>
            </javadoc>
            <method name="makeDynamicInvoker" type="MethodHandle" line="236">
                <declaration name="getTarget" type="MethodHandle" line="237"/>
                <declaration name="invoker" type="MethodHandle" line="238"/>
            </method>
            <declaration name="GET_TARGET" type="MethodHandle" line="242"/>
            <scope line="243">
                <scope line="244"/>
                <scope line="247"/>
            </scope>
            <javadoc line="252">
                This guy is rolled into the default target if a MethodType is supplied to the constructor.                
            </javadoc>
            <method name="uninitializedCallSite" type="Empty" line="254">
                <comment line="254">
                                        
                </comment>
            </method>
            <declaration name="unsafe" type="Unsafe" line="259"/>
            <declaration name="TARGET_OFFSET" type="long" line="260"/>
            <scope line="262">
                <scope line="263"/>
                <scope line="265"/>
            </scope>
            <method name="setTargetNormal" type="void" line="269">
                <params>
                    <param name="newTarget" type="MethodHandle"/>
                </params>
            </method>
            <method name="getTargetVolatile" type="MethodHandle" line="273"/>
            <method name="setTargetVolatile" type="void" line="277">
                <params>
                    <param name="newTarget" type="MethodHandle"/>
                </params>
            </method>
            <method name="makeSite" type="CallSite" line="288">
                <params>
                    <param name="bootstrapMethod" type="MethodHandle"/>
                    <param name="name" type="String"/>
                    <param name="type" type="MethodType"/>
                    <param name="info" type="Object"/>
                    <param name="callerMethod" type="MemberName"/>
                    <param name="callerBCI" type="int"/>
                </params>
                <comment line="284">
                    Callee information:                    
                </comment>
                <comment line="286">
                    Extra arguments for BSM, if any:                    
                </comment>
                <comment line="288">
                    Caller information:                    
                </comment>
                <comment line="312">
                    System.out.println(&quot;BSM for &quot;+name+type+&quot; =&gt; &quot;+binding);                    
                </comment>
                <declaration name="callerClass" type="Class&lt;?&gt;" line="289"/>
                <declaration name="caller" type="Object" line="290"/>
                <declaration name="site" type="CallSite" line="291"/>
                <scope line="292">
                    <declaration name="binding" type="Object" line="293"/>
                    <scope line="295"/>
                    <scope line="297"/>
                    <scope line="299">
                        <declaration name="argv" type="Object[]" line="300"/>
                        <declaration name="bsmType" type="MethodType" line="304"/>
                    </scope>
                    <scope line="312"/>
                    <scope line="314"/>
                </scope>
                <scope line="319">
                    <declaration name="bex" type="BootstrapMethodError" line="320"/>
                </scope>
            </method>
            <method name="maybeReBox" type="Object" line="330">
                <params>
                    <param name="x" type="Object"/>
                </params>
                <comment line="335">
                    must rebox; see JLS 5.1.7                    
                </comment>
                <scope line="331">
                    <declaration name="xi" type="int" line="332"/>
                </scope>
            </method>
            <method name="maybeReBoxElements" type="void" line="338">
                <params>
                    <param name="xa" type="Object[]"/>
                </params>
                <scope line="339"/>
            </method>
        </class>
    </source>