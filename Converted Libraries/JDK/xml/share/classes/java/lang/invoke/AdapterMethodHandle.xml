<?xml version="1.0" encoding="UTF-8"?>
    <source package="java.lang.invoke">
        <import package="sun.invoke.util.VerifyType"/>
        <import package="sun.invoke.util.Wrapper"/>
        <import package="sun.invoke.util.ValueConversions"/>
        <import package="java.util.Arrays"/>
        <import package="java.util.ArrayList"/>
        <import package="java.util.Collections"/>
        <import package="java.lang.invoke.MethodHandleNatives.Constants"/>
        <import package="java.lang.invoke.MethodHandleStatics"/>
        <class name="AdapterMethodHandle" line="37">
            <extends class="BoundMethodHandle"/>
            <comment line="44">
                MethodHandle vmtarget;   // next AMH or BMH in chain or final DMH                
            </comment>
            <comment line="45">
                Object       argument;   // parameter to the conversion if needed                
            </comment>
            <comment line="46">
                int          vmargslot;  // which argument slot is affected                
            </comment>
            <comment line="47">
                the type of conversion: RETYPE_ONLY, etc.                
            </comment>
            <comment line="49">
                Constructors in this class *must* be package scoped or private.                
            </comment>
            <comment line="64">
                TO DO:  When adapting another MH with a null conversion, clone                
            </comment>
            <comment line="65">
                the target and change its type, instead of adding another layer.                
            </comment>
            <comment line="449">
                Return one plus the position of the first non-trivial difference
                 between the given types.  This is not a symmetric operation;
                 we are considering adapting the targetType to adapterType.
                 Trivial differences are those which could be ignored by the JVM
                 without subverting the verifier.  Otherwise, adaptable differences
                 are ones for which we could create an adapter to make the type change.
                 Return zero if there are no differences (other than trivial ones).
                 Return 1+N if N is the only adaptable argument difference.
                 Return the -2-N where N is the first of several adaptable
                 argument differences.
                 Return -1 if there there are differences which are not adaptable.                
            </comment>
            <javadoc line="37">
                This method handle performs simple conversion or checking of a single argument.                
                <author>
                    jrose                    
                </author>
            </javadoc>
            <declaration name="conversion" type="int" line="46"/>
            <method name="AdapterMethodHandle" type="constructor" line="50">
                <params>
                    <param name="target" type="MethodHandle"/>
                    <param name="newType" type="MethodType"/>
                    <param name="conv" type="long"/>
                    <param name="convArg" type="Object"/>
                </params>
                <comment line="53">
                    JVM might update VM-specific bits of conversion (ignore)                    
                </comment>
            </method>
            <method name="AdapterMethodHandle" type="constructor" line="57">
                <params>
                    <param name="target" type="MethodHandle"/>
                    <param name="newType" type="MethodType"/>
                    <param name="conv" type="long"/>
                </params>
            </method>
            <method name="getConversion" type="int" line="61"/>
            <javadoc line="66">
                Can a JVM-level adapter directly implement the proposed
                  argument conversions, as if by fixed-arity MethodHandle.asType?                
            </javadoc>
            <method name="canPairwiseConvert" type="boolean" line="69">
                <params>
                    <param name="newType" type="MethodType"/>
                    <param name="oldType" type="MethodType"/>
                    <param name="level" type="int"/>
                </params>
                <comment line="70">
                    same number of args, of course                    
                </comment>
                <comment line="75">
                    Check return type.                    
                </comment>
                <comment line="85">
                    Check args pairwise.                    
                </comment>
                <comment line="87">
                    source type                    
                </comment>
                <comment line="88">
                    destination type                    
                </comment>
                <declaration name="len" type="int" line="71"/>
                <declaration name="exp" type="Class&lt;?&gt;" line="76"/>
                <declaration name="ret" type="Class&lt;?&gt;" line="77"/>
                <scope line="78"/>
                <scope line="86">
                    <declaration name="src" type="Class&lt;?&gt;" line="87"/>
                    <declaration name="dst" type="Class&lt;?&gt;" line="88"/>
                </scope>
            </method>
            <javadoc line="96">
                Can a JVM-level adapter directly implement the proposed
                  argument conversion, as if by fixed-arity MethodHandle.asType?                
            </javadoc>
            <method name="canConvertArgument" type="boolean" line="99">
                <params>
                    <param name="src" type="Class<?>"/>
                    <param name="dst" type="Class<?>"/>
                    <param name="level" type="int"/>
                </params>
                <comment line="100">
                    ? Retool this logic to use RETYPE_ONLY, CHECK_CAST, etc., as opcodes,                    
                </comment>
                <comment line="101">
                    so we don&apos;t need to repeat so much decision making.                    
                </comment>
                <comment line="105">
                    If we can build filters, we can convert anything to anything.                    
                </comment>
                <comment line="116">
                    any two refs can be interconverted                    
                </comment>
                <scope line="102"/>
                <scope line="104"/>
                <scope line="107"/>
                <scope line="112"/>
            </method>
            <javadoc line="120">
                Create a JVM-level adapter method handle to conform the given method
                  handle to the similar newType, using only pairwise argument conversions.
                  For each argument, convert incoming argument to the exact type needed.
                  The argument conversions allowed are casting, boxing and unboxing,
                  integral widening or narrowing, and floating point widening or narrowing.                
                <param>
                    newType required call type                    
                </param>
                <param>
                    target original method handle                    
                </param>
                <param>
                    level which strength of conversion is allowed                    
                </param>
                <return>
                    an adapter to the original handle with the desired new type,
                      or the original target if the types are already identical
                      or null if the adaptation cannot be made                    
                </return>
            </javadoc>
            <method name="makePairwiseConvert" type="MethodHandle" line="133">
                <params>
                    <param name="newType" type="MethodType"/>
                    <param name="target" type="MethodHandle"/>
                    <param name="level" type="int"/>
                </params>
                <comment line="139">
                    (after this point, it is an assertion error to fail to convert)                    
                </comment>
                <comment line="141">
                    Find last non-trivial conversion (if any).                    
                </comment>
                <comment line="144">
                    source type                    
                </comment>
                <comment line="145">
                    destination type                    
                </comment>
                <comment line="157">
                    Now build a chain of one or more adapters.                    
                </comment>
                <comment line="161">
                    source type                    
                </comment>
                <comment line="162">
                    destination type                    
                </comment>
                <comment line="164">
                    do nothing: difference is trivial                    
                </comment>
                <comment line="167">
                    Work the current type backward toward the desired caller type:                    
                </comment>
                <comment line="170">
                    When doing the last (or only) real conversion,                    
                </comment>
                <comment line="171">
                    force all remaining null conversions to happen also.                    
                </comment>
                <comment line="178">
                    Tricky case analysis follows.                    
                </comment>
                <comment line="179">
                    It parallels canConvertArgument() above.                    
                </comment>
                <comment line="188">
                    Caller has boxed a primitive.  Unbox it for the target.                    
                </comment>
                <comment line="189">
                    The box type must correspond exactly to the primitive type.                    
                </comment>
                <comment line="190">
                    This is simpler than the powerful set of widening                    
                </comment>
                <comment line="191">
                    conversions supported by reflect.Method.invoke.                    
                </comment>
                <comment line="192">
                    Those conversions require a big nest of if/then/else logic,                    
                </comment>
                <comment line="193">
                    which we prefer to make a user responsibility.                    
                </comment>
                <comment line="196">
                    Simple reference conversion.                    
                </comment>
                <comment line="197">
                    Note:  Do not check for a class hierarchy relation                    
                </comment>
                <comment line="198">
                    between src and dst.  In all cases a &apos;null&apos; argument                    
                </comment>
                <comment line="199">
                    will pass the cast conversion.                    
                </comment>
                <comment line="213">
                    Only trivial conversions remain.                    
                </comment>
                <comment line="217">
                    Actually, that&apos;s because there were no non-trivial ones:                    
                </comment>
                <declaration name="oldType" type="MethodType" line="134"/>
                <declaration name="lastConv" type="int" line="142"/>
                <scope line="143">
                    <declaration name="src" type="Class&lt;?&gt;" line="144"/>
                    <declaration name="dst" type="Class&lt;?&gt;" line="145"/>
                    <scope line="146"/>
                    <scope line="148"/>
                </scope>
                <declaration name="needReturn" type="Class&lt;?&gt;" line="153"/>
                <declaration name="haveReturn" type="Class&lt;?&gt;" line="154"/>
                <declaration name="retConv" type="boolean" line="155"/>
                <declaration name="adapter" type="MethodHandle" line="158"/>
                <declaration name="midType" type="MethodType" line="159"/>
                <scope line="160">
                    <declaration name="src" type="Class&lt;?&gt;" line="161"/>
                    <declaration name="dst" type="Class&lt;?&gt;" line="162"/>
                    <scope line="163"/>
                    <scope line="169">
                        <declaration name="lastMidType" type="MethodType" line="172"/>
                    </scope>
                    <scope line="180">
                        <scope line="181"/>
                        <scope line="183"/>
                    </scope>
                    <scope line="186">
                        <scope line="187"/>
                        <scope line="195"/>
                    </scope>
                </scope>
                <scope line="207"/>
                <scope line="212"/>
            </method>
            <method name="isTrivialConversion" type="boolean" line="224">
                <params>
                    <param name="src" type="Class<?>"/>
                    <param name="dst" type="Class<?>"/>
                    <param name="level" type="int"/>
                </params>
                <comment line="227">
                    explicitCastArguments                    
                </comment>
                <comment line="232">
                    in addition to being a null conversion, forbid boolean-&gt;int etc.                    
                </comment>
                <declaration name="sp" type="boolean" line="228"/>
                <declaration name="dp" type="boolean" line="229"/>
                <scope line="231"/>
                <scope line="235"/>
            </method>
            <method name="makeReturnConversion" type="MethodHandle" line="240">
                <params>
                    <param name="target" type="MethodHandle"/>
                    <param name="haveReturn" type="Class<?>"/>
                    <param name="needReturn" type="Class<?>"/>
                </params>
                <comment line="243">
                    synthesize a zero value for the given void                    
                </comment>
                <comment line="251">
                    this code is deprecated                    
                </comment>
                <declaration name="adjustReturn" type="MethodHandle" line="241"/>
                <scope line="242">
                    <declaration name="zero" type="Object" line="244"/>
                </scope>
                <scope line="246">
                    <declaration name="needConversion" type="MethodType" line="247"/>
                </scope>
                <scope line="250"/>
            </method>
            <javadoc line="257">
                Create a JVM-level adapter method handle to permute the arguments
                  of the given method.                
                <param>
                    newType required call type                    
                </param>
                <param>
                    target original method handle                    
                </param>
                <param>
                    argumentMap for each target argument, position of its source in newType                    
                </param>
                <return>
                    an adapter to the original handle with the desired new type,
                      or the original target if the types are already identical
                      and the permutation is null                    
                </return>
                <throws>
                    IllegalArgumentException if the adaptation cannot be made
                      directly by a JVM-level adapter, without help from Java code                    
                </throws>
            </javadoc>
            <method name="makePermutation" type="MethodHandle" line="270">
                <params>
                    <param name="newType" type="MethodType"/>
                    <param name="target" type="MethodHandle"/>
                    <param name="argumentMap" type="int[]"/>
                </params>
                <comment line="285">
                    well, that was easy                    
                </comment>
                <comment line="291">
                    Check return type.  (Not much can be done with it.)                    
                </comment>
                <comment line="297">
                    See if the argument types match up.                    
                </comment>
                <comment line="306">
                    Now figure out a nice mix of SWAP, ROT, DUP, and DROP adapters.                    
                </comment>
                <comment line="307">
                    A workable greedy algorithm is as follows:                    
                </comment>
                <comment line="308">
                    Drop unused outgoing arguments (right to left: shallowest first).                    
                </comment>
                <comment line="309">
                    Duplicate doubly-used outgoing arguments (left to right: deepest first).                    
                </comment>
                <comment line="310">
                    Then the remaining problem is a true argument permutation.                    
                </comment>
                <comment line="311">
                    Marshal the outgoing arguments as required from left to right.                    
                </comment>
                <comment line="312">
                    That is, find the deepest outgoing stack position that does not yet                    
                </comment>
                <comment line="313">
                    have the correct argument value, and correct at least that position                    
                </comment>
                <comment line="314">
                    by swapping or rotating in the misplaced value (from a shallower place).                    
                </comment>
                <comment line="315">
                    If the misplaced value is followed by one or more consecutive values                    
                </comment>
                <comment line="316">
                    (also misplaced)  issue a rotation which brings as many as possible                    
                </comment>
                <comment line="317">
                    into position.  Otherwise make progress with either a swap or a                    
                </comment>
                <comment line="318">
                    rotation.  Prefer the swap as cheaper, but do not use it if it                    
                </comment>
                <comment line="319">
                    breaks a slot pair.  Prefer the rotation over the swap if it would                    
                </comment>
                <comment line="320">
                    preserve more consecutive values shallower than the target position.                    
                </comment>
                <comment line="321">
                    When more than one rotation will work (because the required value                    
                </comment>
                <comment line="322">
                    is already adjacent to the target position), then use a rotation                    
                </comment>
                <comment line="323">
                    which moves the old value in the target position adjacent to                    
                </comment>
                <comment line="324">
                    one of its consecutive values.  Also, prefer shorter rotation                    
                </comment>
                <comment line="325">
                    spans, since they use fewer memory cycles for shuffling.                    
                </comment>
                <declaration name="oldType" type="MethodType" line="271"/>
                <declaration name="nullPermutation" type="boolean" line="272"/>
                <scope line="273">
                    <declaration name="pos" type="int" line="274"/>
                    <scope line="277"/>
                </scope>
                <scope line="283">
                    <declaration name="res" type="MethodHandle" line="284"/>
                </scope>
                <declaration name="exp" type="Class&lt;?&gt;" line="292"/>
                <declaration name="ret" type="Class&lt;?&gt;" line="293"/>
                <scope line="298">
                    <declaration name="j" type="int" line="299"/>
                    <declaration name="src" type="Class&lt;?&gt;" line="300"/>
                    <declaration name="dst" type="Class&lt;?&gt;" line="301"/>
                </scope>
            </method>
            <method name="basicType" type="byte" line="330">
                <params>
                    <param name="type" type="Class<?>"/>
                </params>
                <comment line="344">
                    T_ILLEGAL or some such                    
                </comment>
            </method>
            <javadoc line="347">
                Number of stack slots for the given type.
                  Two for T_DOUBLE and T_FLOAT, one for the rest.                
            </javadoc>
            <method name="type2size" type="int" line="350">
                <params>
                    <param name="type" type="int"/>
                </params>
            </method>
            <method name="type2size" type="int" line="354">
                <params>
                    <param name="type" type="Class<?>"/>
                </params>
            </method>
            <javadoc line="358">
                The given stackMove is the number of slots pushed.
                  It might be negative.  Scale it (multiply) by the
                  VM&apos;s notion of how an address changes with a push,
                  to get the raw SP change for stackMove.
                  Then shift and mask it into the correct field.                
            </javadoc>
            <method name="insertStackMove" type="long" line="364">
                <params>
                    <param name="stackMove" type="int"/>
                </params>
                <comment line="365">
                    following variable must be long to avoid sign extension after &apos;&lt;&lt;&apos;                    
                </comment>
                <declaration name="spChange" type="long" line="366"/>
            </method>
            <method name="extractStackMove" type="int" line="370">
                <params>
                    <param name="convOp" type="int"/>
                </params>
                <declaration name="spChange" type="int" line="371"/>
            </method>
            <method name="extractStackMove" type="int" line="375">
                <params>
                    <param name="target" type="MethodHandle"/>
                </params>
                <scope line="376">
                    <declaration name="amh" type="AdapterMethodHandle" line="377"/>
                </scope>
                <scope line="379"/>
            </method>
            <javadoc line="384">
                Construct an adapter conversion descriptor for a single-argument conversion.                
            </javadoc>
            <method name="makeConv" type="long" line="385">
                <params>
                    <param name="convOp" type="int"/>
                    <param name="argnum" type="int"/>
                    <param name="src" type="int"/>
                    <param name="dest" type="int"/>
                </params>
                <declaration name="stackMove" type="int" line="389"/>
            </method>
            <method name="makeDupConv" type="long" line="397">
                <params>
                    <param name="convOp" type="int"/>
                    <param name="argnum" type="int"/>
                    <param name="stackMove" type="int"/>
                </params>
                <comment line="398">
                    simple argument motion, requiring one slot to specify                    
                </comment>
                <declaration name="src" type="byte" line="400"/>
            </method>
            <method name="makeSwapConv" type="long" line="408">
                <params>
                    <param name="convOp" type="int"/>
                    <param name="srcArg" type="int"/>
                    <param name="srcType" type="byte"/>
                    <param name="destSlot" type="int"/>
                    <param name="destType" type="byte"/>
                </params>
                <comment line="409">
                    more complex argument motion, requiring two slots to specify                    
                </comment>
            </method>
            <method name="makeSpreadConv" type="long" line="418">
                <params>
                    <param name="convOp" type="int"/>
                    <param name="argnum" type="int"/>
                    <param name="src" type="int"/>
                    <param name="dest" type="int"/>
                    <param name="stackMove" type="int"/>
                </params>
                <comment line="419">
                    spreading or collecting, at a particular slot location                    
                </comment>
                <comment line="421">
                    src  = spread ? T_OBJECT (for array)  : common type of collected args (else void)                    
                </comment>
                <comment line="422">
                    dest = spread ? element type of array : result type of collector (can be void)                    
                </comment>
            </method>
            <method name="makeConv" type="long" line="430">
                <params>
                    <param name="convOp" type="int"/>
                </params>
                <comment line="432">
                    stackMove, src, dst all zero                    
                </comment>
            </method>
            <method name="convCode" type="int" line="434">
                <params>
                    <param name="conv" type="long"/>
                </params>
            </method>
            <method name="convArgPos" type="int" line="437">
                <params>
                    <param name="conv" type="long"/>
                </params>
            </method>
            <method name="convOpSupported" type="boolean" line="440">
                <params>
                    <param name="convOp" type="int"/>
                </params>
            </method>
            <javadoc line="445">
                One of OP_RETYPE_ONLY, etc.                
            </javadoc>
            <method name="conversionOp" type="int" line="446"/>
            <method name="diffTypes" type="int" line="462">
                <params>
                    <param name="adapterType" type="MethodType"/>
                    <param name="targetType" type="MethodType"/>
                    <param name="raw" type="boolean"/>
                </params>
                <comment line="470">
                    System.out.println(&quot;diff &quot;+adapterType);                    
                </comment>
                <comment line="471">
                    System.out.println(&quot;  &quot;+diff+&quot; &quot;+targetType);                    
                </comment>
                <declaration name="diff" type="int" line="463"/>
                <declaration name="nargs" type="int" line="466"/>
            </method>
            <method name="diffReturnTypes" type="int" line="476">
                <params>
                    <param name="adapterType" type="MethodType"/>
                    <param name="targetType" type="MethodType"/>
                    <param name="raw" type="boolean"/>
                </params>
                <comment line="483">
                    no significant difference                    
                </comment>
                <comment line="485">
                    can force a reference return (very carefully!)                    
                </comment>
                <comment line="486">
                    if (false)  return 1;  // never adaptable!                    
                </comment>
                <comment line="487">
                    some significant difference                    
                </comment>
                <declaration name="src" type="Class&lt;?&gt;" line="477"/>
                <declaration name="dst" type="Class&lt;?&gt;" line="478"/>
            </method>
            <method name="diffParamTypes" type="int" line="491">
                <params>
                    <param name="adapterType" type="MethodType"/>
                    <param name="astart" type="int"/>
                    <param name="targetType" type="MethodType"/>
                    <param name="tstart" type="int"/>
                    <param name="nargs" type="int"/>
                    <param name="raw" type="boolean"/>
                </params>
                <comment line="501">
                    found a difference; is it the only one so far?                    
                </comment>
                <comment line="503">
                    return -2-i for prev. i                    
                </comment>
                <declaration name="res" type="int" line="493"/>
                <scope line="494">
                    <declaration name="src" type="Class&lt;?&gt;" line="495"/>
                    <declaration name="dest" type="Class&lt;?&gt;" line="496"/>
                    <scope line="500"/>
                </scope>
            </method>
            <javadoc line="510">
                Can a retyping adapter (alone) validly convert the target to newType?                
            </javadoc>
            <method name="canRetypeOnly" type="boolean" line="511">
                <params>
                    <param name="newType" type="MethodType"/>
                    <param name="targetType" type="MethodType"/>
                </params>
            </method>
            <javadoc line="514">
                Can a retyping adapter (alone) convert the target to newType?
                  It is allowed to widen subword types and void to int, to make bitwise
                  conversions between float/int and double/long, and to perform unchecked
                  reference conversions on return.  This last feature requires that the
                  caller be trusted, and perform explicit cast conversions on return values.                
            </javadoc>
            <method name="canRetypeRaw" type="boolean" line="520">
                <params>
                    <param name="newType" type="MethodType"/>
                    <param name="targetType" type="MethodType"/>
                </params>
            </method>
            <method name="canRetype" type="boolean" line="523">
                <params>
                    <param name="newType" type="MethodType"/>
                    <param name="targetType" type="MethodType"/>
                    <param name="raw" type="boolean"/>
                </params>
                <comment line="526">
                    %%% This assert is too strong.  Factor diff into VerifyType and reconcile.                    
                </comment>
                <declaration name="diff" type="int" line="525"/>
            </method>
            <javadoc line="531">
                Factory method:  Performs no conversions; simply retypes the adapter.
                  Allows unchecked argument conversions pairwise, if they are safe.
                  Returns null if not possible.                
            </javadoc>
            <method name="makeRetypeOnly" type="MethodHandle" line="535">
                <params>
                    <param name="newType" type="MethodType"/>
                    <param name="target" type="MethodHandle"/>
                </params>
            </method>
            <method name="makeRetypeRaw" type="MethodHandle" line="538">
                <params>
                    <param name="newType" type="MethodType"/>
                    <param name="target" type="MethodHandle"/>
                </params>
            </method>
            <method name="makeRetype" type="MethodHandle" line="541">
                <params>
                    <param name="newType" type="MethodType"/>
                    <param name="target" type="MethodHandle"/>
                    <param name="raw" type="boolean"/>
                </params>
                <comment line="546">
                    TO DO:  clone the target guy, whatever he is, with new type.                    
                </comment>
                <declaration name="oldType" type="MethodType" line="542"/>
            </method>
            <method name="makeVarargsCollector" type="MethodHandle" line="550">
                <params>
                    <param name="target" type="MethodHandle"/>
                    <param name="arrayType" type="Class<?>"/>
                </params>
                <comment line="555">
                    make sure this attribute is turned off                    
                </comment>
                <declaration name="type" type="MethodType" line="551"/>
                <declaration name="last" type="int" line="552"/>
            </method>
            <class name="AsVarargsCollector" line="559">
                <extends class="AdapterMethodHandle"/>
                <declaration name="target" type="MethodHandle" line="560"/>
                <declaration name="arrayType" type="Class&lt;?&gt;" line="561"/>
                <declaration name="cache" type="MethodHandle" line="562"/>
                <method name="AsVarargsCollector" type="constructor" line="564">
                    <params>
                        <param name="target" type="MethodHandle"/>
                        <param name="arrayType" type="Class<?>"/>
                    </params>
                </method>
                <method name="isVarargsCollector" type="boolean" line="572"/>
                <method name="asFixedArity" type="MethodHandle" line="577"/>
                <method name="asType" type="MethodHandle" line="582">
                    <params>
                        <param name="newType" type="MethodType"/>
                    </params>
                    <comment line="588">
                        if arity and trailing parameter are compatible, do normal thing                        
                    </comment>
                    <comment line="591">
                        check cache                        
                    </comment>
                    <comment line="594">
                        build and cache a collector                        
                    </comment>
                    <declaration name="type" type="MethodType" line="583"/>
                    <declaration name="collectArg" type="int" line="584"/>
                    <declaration name="newArity" type="int" line="585"/>
                    <scope line="587"/>
                    <declaration name="arrayLength" type="int" line="595"/>
                    <declaration name="collector" type="MethodHandle" line="596"/>
                    <scope line="597"/>
                    <scope line="599"/>
                </method>
            </class>
            <javadoc line="607">
                Can a checkcast adapter validly convert the target to newType?
                  The JVM supports all kind of reference casts, even silly ones.                
            </javadoc>
            <method name="canCheckCast" type="boolean" line="611">
                <params>
                    <param name="newType" type="MethodType"/>
                    <param name="targetType" type="MethodType"/>
                    <param name="arg" type="int"/>
                    <param name="castType" type="Class<?>"/>
                </params>
                <comment line="619">
                    arg is sole non-trivial diff                    
                </comment>
                <declaration name="src" type="Class&lt;?&gt;" line="613"/>
                <declaration name="dst" type="Class&lt;?&gt;" line="614"/>
                <declaration name="diff" type="int" line="618"/>
            </method>
            <javadoc line="621">
                Can an primitive conversion adapter validly convert src to dst?                
            </javadoc>
            <method name="canCheckCast" type="boolean" line="622">
                <params>
                    <param name="src" type="Class<?>"/>
                    <param name="dst" type="Class<?>"/>
                </params>
            </method>
            <javadoc line="626">
                Factory method:  Forces a cast at the given argument.
                  The castType is the target of the cast, and can be any type
                  with a null conversion to the corresponding target parameter.
                  Return null if this cannot be done.                
            </javadoc>
            <method name="makeCheckCast" type="MethodHandle" line="632">
                <params>
                    <param name="newType" type="MethodType"/>
                    <param name="target" type="MethodHandle"/>
                    <param name="arg" type="int"/>
                    <param name="castType" type="Class<?>"/>
                </params>
                <declaration name="conv" type="long" line="635"/>
            </method>
            <javadoc line="639">
                Can an primitive conversion adapter validly convert the target to newType?
                  The JVM currently supports all conversions except those between
                  floating and integral types.                
            </javadoc>
            <method name="canPrimCast" type="boolean" line="644">
                <params>
                    <param name="newType" type="MethodType"/>
                    <param name="targetType" type="MethodType"/>
                    <param name="arg" type="int"/>
                    <param name="convType" type="Class<?>"/>
                </params>
                <comment line="652">
                    arg is sole non-trivial diff                    
                </comment>
                <declaration name="src" type="Class&lt;?&gt;" line="646"/>
                <declaration name="dst" type="Class&lt;?&gt;" line="647"/>
                <declaration name="diff" type="int" line="651"/>
            </method>
            <javadoc line="654">
                Can an primitive conversion adapter validly convert src to dst?                
            </javadoc>
            <method name="canPrimCast" type="boolean" line="655">
                <params>
                    <param name="src" type="Class<?>"/>
                    <param name="dst" type="Class<?>"/>
                </params>
                <comment line="661">
                    no float support at present                    
                </comment>
                <scope line="656"/>
                <scope line="658">
                    <declaration name="sflt" type="boolean" line="659"/>
                    <declaration name="dflt" type="boolean" line="660"/>
                </scope>
            </method>
            <javadoc line="665">
                Factory method:  Truncate the given argument with zero or sign extension,
                  and/or convert between single and doubleword versions of integer or float.
                  The convType is the target of the conversion, and can be any type
                  with a null conversion to the corresponding target parameter.
                  Return null if this cannot be done.                
            </javadoc>
            <method name="makePrimCast" type="MethodHandle" line="672">
                <params>
                    <param name="newType" type="MethodType"/>
                    <param name="target" type="MethodHandle"/>
                    <param name="arg" type="int"/>
                    <param name="convType" type="Class<?>"/>
                </params>
                <declaration name="src" type="Class&lt;?&gt;" line="673"/>
                <declaration name="dst" type="Class&lt;?&gt;" line="676"/>
                <declaration name="sflt" type="boolean" line="677"/>
                <declaration name="dflt" type="boolean" line="678"/>
                <scope line="679">
                    <declaration name="convMethod" type="MethodHandle" line="680"/>
                    <declaration name="conv" type="long" line="689"/>
                </scope>
            </method>
            <method name="makePrimCastOnly" type="MethodHandle" line="695">
                <params>
                    <param name="newType" type="MethodType"/>
                    <param name="target" type="MethodHandle"/>
                    <param name="arg" type="int"/>
                    <param name="convType" type="Class<?>"/>
                </params>
                <declaration name="oldType" type="MethodType" line="696"/>
                <declaration name="src" type="Class&lt;?&gt;" line="699"/>
                <declaration name="conv" type="long" line="700"/>
            </method>
            <javadoc line="704">
                Can an unboxing conversion validly convert src to dst?
                  The JVM currently supports all kinds of casting and unboxing.
                  The convType is the unboxed type; it can be either a primitive or wrapper.                
            </javadoc>
            <method name="canUnboxArgument" type="boolean" line="709">
                <params>
                    <param name="newType" type="MethodType"/>
                    <param name="targetType" type="MethodType"/>
                    <param name="arg" type="int"/>
                    <param name="convType" type="Class<?>"/>
                    <param name="level" type="int"/>
                </params>
                <comment line="720">
                    arg is sole non-trivial diff                    
                </comment>
                <declaration name="src" type="Class&lt;?&gt;" line="711"/>
                <declaration name="dst" type="Class&lt;?&gt;" line="712"/>
                <declaration name="boxType" type="Class&lt;?&gt;" line="713"/>
                <declaration name="diff" type="int" line="719"/>
            </method>
            <javadoc line="722">
                Can an primitive unboxing adapter validly convert src to dst?                
            </javadoc>
            <method name="canUnboxArgument" type="boolean" line="723">
                <params>
                    <param name="src" type="Class<?>"/>
                    <param name="dst" type="Class<?>"/>
                    <param name="level" type="int"/>
                </params>
                <comment line="725">
                    if we have JVM support for boxing, we can also do complex unboxing                    
                </comment>
                <comment line="728">
                    Level 0 means cast and unbox.  This works on any reference.                    
                </comment>
                <comment line="731">
                    Levels 1 and 2 allow widening and/or narrowing conversions.                    
                </comment>
                <comment line="732">
                    These are not supported directly by the JVM.                    
                </comment>
                <comment line="733">
                    But if the input reference is monomorphic, we can do it.                    
                </comment>
                <declaration name="dw" type="Wrapper" line="727"/>
            </method>
            <javadoc line="737">
                Factory method:  Unbox the given argument.
                  Return null if this cannot be done.                
            </javadoc>
            <method name="makeUnboxArgument" type="MethodHandle" line="741">
                <params>
                    <param name="newType" type="MethodType"/>
                    <param name="target" type="MethodHandle"/>
                    <param name="arg" type="int"/>
                    <param name="convType" type="Class<?>"/>
                    <param name="level" type="int"/>
                </params>
                <comment line="751">
                    Examples:  Object-&gt;int, Number-&gt;int, Comparable-&gt;int; Byte-&gt;int, Character-&gt;int                    
                </comment>
                <comment line="753">
                    must include additional conversions                    
                </comment>
                <comment line="755">
                    src must be examined at runtime, to detect Byte, Character, etc.                    
                </comment>
                <comment line="762">
                    Example: Byte-&gt;int                    
                </comment>
                <comment line="763">
                    Do this by reformulating the problem to Byte-&gt;byte.                    
                </comment>
                <comment line="766">
                    makePairwiseConvert(midType, target, 0);                    
                </comment>
                <declaration name="oldType" type="MethodType" line="742"/>
                <declaration name="src" type="Class&lt;?&gt;" line="743"/>
                <declaration name="dst" type="Class&lt;?&gt;" line="744"/>
                <declaration name="boxType" type="Class&lt;?&gt;" line="745"/>
                <declaration name="primType" type="Class&lt;?&gt;" line="746"/>
                <declaration name="castDone" type="MethodType" line="749"/>
                <scope line="750">
                    <scope line="752">
                        <scope line="754">
                            <declaration name="unboxMethod" type="MethodHandle" line="756"/>
                            <declaration name="conv" type="long" line="759"/>
                        </scope>
                        <declaration name="srcPrim" type="Class&lt;?&gt;" line="764"/>
                        <declaration name="midType" type="MethodType" line="765"/>
                        <declaration name="fixPrim" type="MethodHandle" line="766"/>
                    </scope>
                </scope>
                <declaration name="conv" type="long" line="775"/>
                <declaration name="adapter" type="MethodHandle" line="776"/>
            </method>
            <javadoc line="782">
                Can a boxing conversion validly convert src to dst?                
            </javadoc>
            <method name="canBoxArgument" type="boolean" line="784">
                <params>
                    <param name="newType" type="MethodType"/>
                    <param name="targetType" type="MethodType"/>
                    <param name="arg" type="int"/>
                    <param name="convType" type="Class<?>"/>
                </params>
                <comment line="795">
                    arg is sole non-trivial diff                    
                </comment>
                <declaration name="src" type="Class&lt;?&gt;" line="786"/>
                <declaration name="dst" type="Class&lt;?&gt;" line="787"/>
                <declaration name="boxType" type="Class&lt;?&gt;" line="788"/>
                <declaration name="diff" type="int" line="794"/>
            </method>
            <javadoc line="798">
                Can an primitive boxing adapter validly convert src to dst?                
            </javadoc>
            <method name="canBoxArgument" type="boolean" line="799">
                <params>
                    <param name="src" type="Class<?>"/>
                    <param name="dst" type="Class<?>"/>
                </params>
            </method>
            <javadoc line="804">
                Factory method:  Box the given argument.
                  Return null if this cannot be done.                
            </javadoc>
            <method name="makeBoxArgument" type="MethodHandle" line="808">
                <params>
                    <param name="newType" type="MethodType"/>
                    <param name="target" type="MethodHandle"/>
                    <param name="arg" type="int"/>
                    <param name="convType" type="Class<?>"/>
                </params>
                <declaration name="oldType" type="MethodType" line="809"/>
                <declaration name="src" type="Class&lt;?&gt;" line="810"/>
                <declaration name="dst" type="Class&lt;?&gt;" line="811"/>
                <declaration name="boxType" type="Class&lt;?&gt;" line="812"/>
                <declaration name="primType" type="Class&lt;?&gt;" line="813"/>
                <scope line="814"/>
                <declaration name="boxerMethod" type="MethodHandle" line="819"/>
                <declaration name="conv" type="long" line="820"/>
            </method>
            <javadoc line="824">
                Can an adapter simply drop arguments to convert the target to newType?                
            </javadoc>
            <method name="canDropArguments" type="boolean" line="826">
                <params>
                    <param name="newType" type="MethodType"/>
                    <param name="targetType" type="MethodType"/>
                    <param name="dropArgPos" type="int"/>
                    <param name="dropArgCount" type="int"/>
                </params>
                <comment line="833">
                    parameter types must be the same up to the drop point                    
                </comment>
                <comment line="842">
                    parameter types after the drop point must also be the same                    
                </comment>
                <declaration name="nptypes" type="int" line="832"/>
                <declaration name="afterPos" type="int" line="836"/>
                <declaration name="afterCount" type="int" line="837"/>
            </method>
            <javadoc line="848">
                Factory method:  Drop selected arguments.
                  Allow unchecked retyping of remaining arguments, pairwise.
                  Return null if this is not possible.                
            </javadoc>
            <method name="makeDropArguments" type="MethodHandle" line="853">
                <params>
                    <param name="newType" type="MethodType"/>
                    <param name="target" type="MethodHandle"/>
                    <param name="dropArgPos" type="int"/>
                    <param name="dropArgCount" type="int"/>
                </params>
                <comment line="858">
                    in  arglist: [0: ...keep1 | dpos: drop... | dpos+dcount: keep2... ]                    
                </comment>
                <comment line="859">
                    out arglist: [0: ...keep1 |                        dpos: keep2... ]                    
                </comment>
                <declaration name="keep2InPos" type="int" line="860"/>
                <declaration name="dropSlot" type="int" line="861"/>
                <declaration name="keep1InSlot" type="int" line="862"/>
                <declaration name="slotCount" type="int" line="863"/>
                <declaration name="conv" type="long" line="866"/>
            </method>
            <javadoc line="870">
                Can an adapter duplicate an argument to convert the target to newType?                
            </javadoc>
            <method name="canDupArguments" type="boolean" line="872">
                <params>
                    <param name="newType" type="MethodType"/>
                    <param name="targetType" type="MethodType"/>
                    <param name="dupArgPos" type="int"/>
                    <param name="dupArgCount" type="int"/>
                </params>
                <comment line="881">
                    parameter types must be the same up to the duplicated arguments                    
                </comment>
                <comment line="884">
                    duplicated types must be, well, duplicates                    
                </comment>
                <declaration name="nptypes" type="int" line="876"/>
            </method>
            <javadoc line="890">
                Factory method:  Duplicate the selected argument.
                  Return null if this is not possible.                
            </javadoc>
            <method name="makeDupArguments" type="MethodHandle" line="894">
                <params>
                    <param name="newType" type="MethodType"/>
                    <param name="target" type="MethodHandle"/>
                    <param name="dupArgPos" type="int"/>
                    <param name="dupArgCount" type="int"/>
                </params>
                <comment line="899">
                    in  arglist: [0: ...keep1 | dpos: dup... | dpos+dcount: keep2... ]                    
                </comment>
                <comment line="900">
                    out arglist: [0: ...keep1 | dpos: dup... | dpos+dcount: keep2... | dup... ]                    
                </comment>
                <declaration name="keep2InPos" type="int" line="901"/>
                <declaration name="dupSlot" type="int" line="902"/>
                <declaration name="keep1InSlot" type="int" line="903"/>
                <declaration name="slotCount" type="int" line="904"/>
                <declaration name="conv" type="long" line="906"/>
            </method>
            <javadoc line="910">
                Can an adapter swap two arguments to convert the target to newType?                
            </javadoc>
            <method name="canSwapArguments" type="boolean" line="912">
                <params>
                    <param name="newType" type="MethodType"/>
                    <param name="targetType" type="MethodType"/>
                    <param name="swapArg1" type="int"/>
                    <param name="swapArg2" type="int"/>
                </params>
                <comment line="916">
                    caller resp                    
                </comment>
                <declaration name="nptypes" type="int" line="917"/>
            </method>
            <javadoc line="935">
                Factory method:  Swap the selected arguments.
                  Return null if this is not possible.                
            </javadoc>
            <method name="makeSwapArguments" type="MethodHandle" line="939">
                <params>
                    <param name="newType" type="MethodType"/>
                    <param name="target" type="MethodHandle"/>
                    <param name="swapArg1" type="int"/>
                    <param name="swapArg2" type="int"/>
                </params>
                <comment line="945">
                    turn a swap into a pair of rotates:                    
                </comment>
                <comment line="946">
                    [x a b c y] rot2(-1,argc=5) =&gt; [a b c y x] rot1(+1,argc=4) =&gt; target[y a b c x]                    
                </comment>
                <comment line="963">
                    in  arglist: [0: ...keep1 | pos1: a1 | pos1+1: keep2... | pos2: a2 | pos2+1: keep3... ]                    
                </comment>
                <comment line="964">
                    out arglist: [0: ...keep1 | pos1: a2 | pos1+1: keep2... | pos2: a1 | pos2+1: keep3... ]                    
                </comment>
                <scope line="942">
                    <declaration name="t" type="int" line="942"/>
                </scope>
                <scope line="944">
                    <declaration name="argc" type="int" line="947"/>
                    <declaration name="ROT" type="int" line="948"/>
                    <declaration name="rot1Params" type="ArrayList&lt;Class&lt;?&gt;&gt;" line="949"/>
                    <declaration name="rot1Type" type="MethodType" line="951"/>
                    <declaration name="rot1" type="MethodHandle" line="952"/>
                    <declaration name="rot2" type="MethodHandle" line="955"/>
                </scope>
                <declaration name="type1" type="Class&lt;?&gt;" line="961"/>
                <declaration name="type2" type="Class&lt;?&gt;" line="962"/>
                <declaration name="swapSlot2" type="int" line="965"/>
                <declaration name="conv" type="long" line="966"/>
            </method>
            <method name="positiveRotation" type="int" line="970">
                <params>
                    <param name="argCount" type="int"/>
                    <param name="rotateBy" type="int"/>
                </params>
                <scope line="972"/>
                <scope line="976"/>
                <scope line="978"/>
            </method>
            <declaration name="MAX_ARG_ROTATION" type="int" line="983"/>
            <javadoc line="985">
                Can an adapter rotate arguments to convert the target to newType?                
            </javadoc>
            <method name="canRotateArguments" type="boolean" line="987">
                <params>
                    <param name="newType" type="MethodType"/>
                    <param name="targetType" type="MethodType"/>
                    <param name="firstArg" type="int"/>
                    <param name="argCount" type="int"/>
                    <param name="rotateBy" type="int"/>
                </params>
                <comment line="990">
                    no rotation                    
                </comment>
                <comment line="992">
                    too many argument positions                    
                </comment>
                <comment line="993">
                    Rotate incoming args right N to the out args, N in 1..(argCouunt-1).                    
                </comment>
                <comment line="1005">
                    swap new chunk1 with target chunk2                    
                </comment>
                <comment line="1008">
                    swap new chunk2 with target chunk1                    
                </comment>
                <declaration name="nptypes" type="int" line="996"/>
                <declaration name="argLimit" type="int" line="1000"/>
                <declaration name="newChunk1" type="int" line="1004"/>
            </method>
            <javadoc line="1014">
                Factory method:  Rotate the selected argument range.
                  Return null if this is not possible.                
            </javadoc>
            <method name="makeRotateArguments" type="MethodHandle" line="1018">
                <params>
                    <param name="newType" type="MethodType"/>
                    <param name="target" type="MethodHandle"/>
                    <param name="firstArg" type="int"/>
                    <param name="argCount" type="int"/>
                    <param name="rotateBy" type="int"/>
                </params>
                <comment line="1022">
                    Decide whether it should be done as a right or left rotation,                    
                </comment>
                <comment line="1023">
                    on the JVM stack.  Return the number of stack slots to rotate by,                    
                </comment>
                <comment line="1024">
                    positive if right, negative if left.                    
                </comment>
                <comment line="1031">
                    From here on out, it assumes a single-argument shift.                    
                </comment>
                <comment line="1037">
                    Rotate right/down N (rotateBy = +N, N small, c2 small):                    
                </comment>
                <comment line="1038">
                    in  arglist: [0: ...keep1 | arg1: c1...  | limit-N: c2 | limit: keep2... ]                    
                </comment>
                <comment line="1039">
                    out arglist: [0: ...keep1 | arg1: c2 | arg1+N: c1...   | limit: keep2... ]                    
                </comment>
                <comment line="1042">
                    dstSlot = depth0 - chunk2Slots;  //chunk2Slots is not relevant                    
                </comment>
                <comment line="1046">
                    Rotate left/up N (rotateBy = -N, N small, c1 small):                    
                </comment>
                <comment line="1047">
                    in  arglist: [0: ...keep1 | arg1: c1 | arg1+N: c2...   | limit: keep2... ]                    
                </comment>
                <comment line="1048">
                    out arglist: [0: ...keep1 | arg1: c2 ... | limit-N: c1 | limit: keep2... ]                    
                </comment>
                <declaration name="limit" type="int" line="1025"/>
                <declaration name="depth0" type="int" line="1026"/>
                <declaration name="depth1" type="int" line="1027"/>
                <declaration name="depth2" type="int" line="1028"/>
                <declaration name="chunk1Slots" type="int" line="1029"/>
                <declaration name="chunk2Slots" type="int" line="1030"/>
                <declaration name="srcArg" type="int" line="1033"/>
                <declaration name="dstSlot" type="int" line="1034"/>
                <declaration name="moveChunk" type="int" line="1035"/>
                <scope line="1036"/>
                <scope line="1045"/>
                <declaration name="srcType" type="byte" line="1054"/>
                <declaration name="dstType" type="byte" line="1055"/>
                <declaration name="conv" type="long" line="1057"/>
            </method>
            <javadoc line="1061">
                Can an adapter spread an argument to convert the target to newType?                
            </javadoc>
            <method name="canSpreadArguments" type="boolean" line="1063">
                <params>
                    <param name="newType" type="MethodType"/>
                    <param name="targetType" type="MethodType"/>
                    <param name="spreadArgType" type="Class<?>"/>
                    <param name="spreadArgPos" type="int"/>
                    <param name="spreadArgCount" type="int"/>
                </params>
                <comment line="1068">
                    parameter types must be the same up to the spread point                    
                </comment>
                <comment line="1077">
                    parameter types after the spread point must also be the same                    
                </comment>
                <comment line="1080">
                    match the array element type to the spread arg types                    
                </comment>
                <declaration name="nptypes" type="int" line="1067"/>
                <declaration name="afterPos" type="int" line="1071"/>
                <declaration name="afterCount" type="int" line="1072"/>
                <declaration name="rawSpreadArgType" type="Class&lt;?&gt;" line="1081"/>
                <scope line="1084">
                    <declaration name="src" type="Class&lt;?&gt;" line="1085"/>
                    <declaration name="dst" type="Class&lt;?&gt;" line="1086"/>
                </scope>
            </method>
            <javadoc line="1094">
                Factory method:  Spread selected argument.                
            </javadoc>
            <method name="makeSpreadArguments" type="MethodHandle" line="1096">
                <params>
                    <param name="newType" type="MethodType"/>
                    <param name="target" type="MethodHandle"/>
                    <param name="spreadArgType" type="Class<?>"/>
                    <param name="spreadArgPos" type="int"/>
                    <param name="spreadArgCount" type="int"/>
                </params>
                <comment line="1097">
                    FIXME: Get rid of newType; derive new arguments from structure of spreadArgType                    
                </comment>
                <comment line="1102">
                    dest is not significant; remove?                    
                </comment>
                <comment line="1114">
                    always a reference                    
                </comment>
                <comment line="1115">
                    in  arglist: [0: ...keep1 | spos: spreadArg | spos+1:      keep2... ]                    
                </comment>
                <comment line="1116">
                    out arglist: [0: ...keep1 | spos: spread... | spos+scount: keep2... ]                    
                </comment>
                <comment line="1118">
                    leading edge of |spread...|                    
                </comment>
                <comment line="1119">
                    trailing edge of |spread...|                    
                </comment>
                <comment line="1121">
                    slots in |spread...|                    
                </comment>
                <comment line="1123">
                    pop array, push N slots                    
                </comment>
                <declaration name="targetType" type="MethodType" line="1098"/>
                <declaration name="dest" type="int" line="1103"/>
                <scope line="1104">
                    <declaration name="arg" type="Class&lt;?&gt;" line="1105"/>
                    <declaration name="dest2" type="int" line="1107"/>
                </scope>
                <declaration name="arrayArgSize" type="int" line="1114"/>
                <declaration name="keep2OutPos" type="int" line="1117"/>
                <declaration name="keep1OutSlot" type="int" line="1118"/>
                <declaration name="spreadSlot" type="int" line="1119"/>
                <declaration name="slotCount" type="int" line="1121"/>
                <declaration name="stackMove" type="int" line="1123"/>
                <declaration name="conv" type="long" line="1124"/>
                <declaration name="res" type="MethodHandle" line="1125"/>
            </method>
            <javadoc line="1130">
                Can an adapter collect a series of arguments, replacing them by zero or one results?                
            </javadoc>
            <method name="canCollectArguments" type="boolean" line="1132">
                <params>
                    <param name="targetType" type="MethodType"/>
                    <param name="collectorType" type="MethodType"/>
                    <param name="collectArgPos" type="int"/>
                    <param name="retainOriginalArgs" type="boolean"/>
                </params>
                <comment line="1137">
                    [(Object)Object[], (Object[])Object[], 0, 1]                    
                </comment>
                <declaration name="collectArgCount" type="int" line="1134"/>
                <declaration name="rtype" type="Class&lt;?&gt;" line="1135"/>
            </method>
            <javadoc line="1143">
                Factory method:  Collect or filter selected argument(s).                
            </javadoc>
            <method name="makeCollectArguments" type="MethodHandle" line="1145">
                <params>
                    <param name="target" type="MethodHandle"/>
                    <param name="collector" type="MethodHandle"/>
                    <param name="collectArgPos" type="int"/>
                    <param name="retainOriginalArgs" type="boolean"/>
                </params>
                <comment line="1159">
                    parameter types at the fold point must be the same                    
                </comment>
                <comment line="1163">
                    in  arglist: [0: ...keep1 | cpos: collect...  | cpos+cacount: keep2... ]                    
                </comment>
                <comment line="1164">
                    out arglist: [0: ...keep1 | cpos: collectVal? | cpos+cvcount: keep2... ]                    
                </comment>
                <comment line="1165">
                    out(retain): [0: ...keep1 | cpos: cV? coll... | cpos+cvc+cac: keep2... ]                    
                </comment>
                <comment line="1167">
                    leading edge of |collect...|                    
                </comment>
                <comment line="1168">
                    trailing edge of |collect...|                    
                </comment>
                <comment line="1169">
                    slots in |collect...|                    
                </comment>
                <comment line="1175">
                    src is not significant; remove?                    
                </comment>
                <comment line="1182">
                    push 0..2 results                    
                </comment>
                <comment line="1183">
                    pop N arguments                    
                </comment>
                <declaration name="targetType" type="MethodType" line="1147"/>
                <declaration name="collectorType" type="MethodType" line="1148"/>
                <declaration name="collectArgCount" type="int" line="1149"/>
                <declaration name="collectValType" type="Class&lt;?&gt;" line="1150"/>
                <declaration name="collectValCount" type="int" line="1151"/>
                <declaration name="collectValSlots" type="int" line="1152"/>
                <declaration name="newType" type="MethodType" line="1153"/>
                <scope line="1155"/>
                <scope line="1158"/>
                <declaration name="keep2InPos" type="int" line="1166"/>
                <declaration name="keep1InSlot" type="int" line="1167"/>
                <declaration name="collectSlot" type="int" line="1168"/>
                <declaration name="slotCount" type="int" line="1169"/>
                <declaration name="dest" type="int" line="1173"/>
                <declaration name="src" type="int" line="1174"/>
                <scope line="1176">
                    <declaration name="src2" type="int" line="1177"/>
                </scope>
                <declaration name="stackMove" type="int" line="1182"/>
                <declaration name="lastCollectArg" type="int" line="1184"/>
                <declaration name="conv" type="long" line="1185"/>
                <declaration name="res" type="MethodHandle" line="1187"/>
            </method>
            <method name="debugString" type="String" line="1194"/>
            <method name="nonAdapter" type="MethodHandle" line="1198">
                <params>
                    <param name="mh" type="MethodHandle"/>
                </params>
                <scope line="1199"/>
            </method>
        </class>
    </source>