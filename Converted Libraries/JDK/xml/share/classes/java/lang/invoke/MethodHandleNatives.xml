<?xml version="1.0" encoding="UTF-8"?>
    <source package="java.lang.invoke">
        <import package="java.lang.invoke.MethodHandles.Lookup"/>
        <import package="java.lang.reflect.AccessibleObject"/>
        <import package="java.lang.reflect.Field"/>
        <import package="java.lang.invoke.MethodHandleNatives.Constants"/>
        <import package="java.lang.invoke.MethodHandles.Lookup.IMPL_LOOKUP"/>
        <class name="MethodHandleNatives" line="7">
            <javadoc line="7">
                The JVM interface for the method handles package is all here.
                  This is an interface internal and private to an implemetantion of JSR 292.
                  &lt;em&gt;This class is not part of the JSR 292 standard.&lt;/em&gt;                
                <author>
                    jrose                    
                </author>
            </javadoc>
            <method name="MethodHandleNatives" type="constructor" line="14"/>
            <method name="init" type="void" line="16"/>
            <method name="expand" type="void" line="17"/>
            <method name="resolve" type="void" line="18"/>
            <method name="getMembers" type="int" line="19"/>
            <method name="init" type="void" line="20"/>
            <javadoc line="20">
                Initialize the method handle to adapt the call.                
            </javadoc>
            <method name="init" type="void" line="24"/>
            <javadoc line="24">
                Initialize the method handle to call the correct method, directly.                
            </javadoc>
            <method name="init" type="void" line="28"/>
            <javadoc line="28">
                Initialize the method handle to call as if by an invoke instruction.                
            </javadoc>
            <method name="init" type="void" line="32"/>
            <javadoc line="32">
                Initialize a method type, once per form.                
            </javadoc>
            <method name="registerBootstrap" type="void" line="36"/>
            <javadoc line="36">
                Tell the JVM about a class&apos;s bootstrap method.                
            </javadoc>
            <method name="getBootstrap" type="MethodHandle" line="40"/>
            <javadoc line="40">
                Ask the JVM about a class&apos;s bootstrap method.                
            </javadoc>
            <method name="setCallSiteTarget" type="void" line="44"/>
            <javadoc line="44">
                Tell the JVM that we need to change the target of an invokedynamic.                
            </javadoc>
            <method name="getTarget" type="Object" line="48"/>
            <javadoc line="48">
                Fetch the vmtarget field.
                  It will be sanitized as necessary to avoid exposing non-Java references.
                  This routine is for debugging and reflection.                
            </javadoc>
            <javadoc line="54">
                Fetch the name of the handled method, if available.
                  This routine is for debugging and reflection.                
            </javadoc>
            <method name="getMethodName" type="MemberName" line="58">
                <params>
                    <param name="self" type="MethodHandle"/>
                </params>
            </method>
            <javadoc line="61">
                Fetch the reflective version of the handled method, if available.                
            </javadoc>
            <method name="getTargetMethod" type="AccessibleObject" line="64">
                <params>
                    <param name="self" type="MethodHandle"/>
                </params>
            </method>
            <javadoc line="67">
                Fetch the target of this method handle.
                  If it directly targets a method, return a MemberName for the method.
                  If it is chained to another method handle, return that handle.                
            </javadoc>
            <method name="getTargetInfo" type="Object" line="72">
                <params>
                    <param name="self" type="MethodHandle"/>
                </params>
            </method>
            <method name="makeTarget" type="Object[]" line="75">
                <params>
                    <param name="defc" type="Class&lt;?&gt;"/>
                    <param name="name" type="String"/>
                    <param name="sig" type="String"/>
                    <param name="mods" type="int"/>
                    <param name="refc" type="Class&lt;?&gt;"/>
                </params>
            </method>
            <method name="getConstant" type="int" line="78"/>
            <javadoc line="78">
                Fetch MH-related JVM parameter.
                  which=0 retrieves MethodHandlePushLimit
                  which=1 retrieves stack slot push size (in address units)                
            </javadoc>
            <declaration name="JVM_PUSH_LIMIT" type="int" line="84"/>
            <javadoc line="84">
                Java copy of MethodHandlePushLimit in range 2..255.                
            </javadoc>
            <declaration name="JVM_STACK_MOVE_UNIT" type="int" line="88"/>
            <javadoc line="88">
                JVM stack motion (in words) after one slot is pushed, usually -1.                
            </javadoc>
            <declaration name="CONV_OP_IMPLEMENTED_MASK" type="int" line="92"/>
            <javadoc line="92">
                Which conv-ops are implemented by the JVM?                
            </javadoc>
            <declaration name="HAVE_RICOCHET_FRAMES" type="boolean" line="96"/>
            <javadoc line="96">
                Derived mode flag.  Only false on some old JVM implementations.                
            </javadoc>
            <declaration name="OP_ROT_ARGS_DOWN_LIMIT_BIAS" type="int" line="100"/>
            <method name="registerNatives" type="void" line="101"/>
            <scope line="102">
                <declaration name="k" type="int" line="104"/>
            </scope>
            <class name="Constants" line="113">
                <method name="Constants" type="constructor" line="114"/>
                <declaration name="GC_JVM_PUSH_LIMIT" type="int" line="116"/>
                <declaration name="ETF_HANDLE_OR_METHOD_NAME" type="int" line="117"/>
                <declaration name="MN_IS_METHOD" type="int" line="118"/>
                <declaration name="ARG_SLOT_PUSH_SHIFT" type="int" line="119"/>
                <javadoc line="119">
                    Constants for decoding the vmargslot field, which contains 2 values.                    
                </javadoc>
                <declaration name="OP_RETYPE_ONLY" type="int" line="123"/>
                <javadoc line="123">
                    Conversions recognized by the JVM.
                      They must align with the constants in java.lang.invoke.AdapterMethodHandle,
                      in the JVM file hotspot/src/share/vm/classfile/javaClasses.hpp.                    
                </javadoc>
                <declaration name="CONV_OP_MASK" type="int" line="129"/>
                <javadoc line="129">
                    Shift and mask values for decoding the AMH.conversion field.
                      These numbers are shared with the JVM for creating AMHs.                    
                </javadoc>
                <declaration name="DEFAULT_CONV_OP_IMPLEMENTED_MASK" type="int" line="134"/>
                <javadoc line="134">
                    Which conv-ops are implemented by the JVM?                    
                </javadoc>
                <declaration name="T_BOOLEAN" type="int" line="138"/>
                <javadoc line="138">
                    Basic types as encoded in the JVM.  These code values are not
                      intended for use outside this class.  They are used as part of
                      a private interface between the JVM and this class.                    
                </javadoc>
                <declaration name="REF_getField" type="int" line="144"/>
                <javadoc line="144">
                    Constant pool reference-kind codes, as used by CONSTANT_MethodHandle CP entries.                    
                </javadoc>
            </class>
            <method name="getNamedCon" type="int" line="149"/>
            <method name="verifyConstants" type="boolean" line="150">
                <declaration name="box" type="Object[]" line="151"/>
                <scope line="152">
                    <declaration name="vmval" type="int" line="154"/>
                    <declaration name="name" type="String" line="156"/>
                    <scope line="157">
                        <declaration name="con" type="Field" line="158"/>
                        <declaration name="jval" type="int" line="159"/>
                        <declaration name="err" type="String" line="161"/>
                        <scope line="162"/>
                    </scope>
                    <scope line="168">
                        <scope line="169">
                            <declaration name="err" type="String" line="170"/>
                            <scope line="171"/>
                        </scope>
                    </scope>
                </scope>
            </method>
            <scope line="181"/>
            <javadoc line="184">
                The JVM is linking an invokedynamic instruction.  Create a reified call site for it.                
            </javadoc>
            <method name="makeDynamicCallSite" type="CallSite" line="187">
                <params>
                    <param name="bootstrapMethod" type="MethodHandle"/>
                    <param name="name" type="String"/>
                    <param name="type" type="MethodType"/>
                    <param name="info" type="Object"/>
                    <param name="callerMethod" type="MemberName"/>
                    <param name="callerBCI" type="int"/>
                </params>
            </method>
            <javadoc line="190">
                Called by the JVM to check the length of a spread array.                
            </javadoc>
            <method name="checkSpreadArgument" type="void" line="193">
                <params>
                    <param name="av" type="Object"/>
                    <param name="n" type="int"/>
                </params>
            </method>
            <javadoc line="196">
                The JVM wants a pointer to a MethodType.  Oblige it by finding or creating one.                
            </javadoc>
            <method name="findMethodHandleType" type="MethodType" line="199">
                <params>
                    <param name="rtype" type="Class&lt;?&gt;"/>
                    <param name="ptypes" type="Class&lt;?&gt;[]"/>
                </params>
            </method>
            <javadoc line="202">
                The JVM wants to use a MethodType with inexact invoke.  Give the runtime fair warning.                
            </javadoc>
            <method name="notifyGenericMethodType" type="void" line="205">
                <params>
                    <param name="type" type="MethodType"/>
                </params>
            </method>
            <javadoc line="208">
                The JVM wants to raise an exception.  Here&apos;s the path.                
            </javadoc>
            <method name="raiseException" type="void" line="211">
                <params>
                    <param name="code" type="int"/>
                    <param name="actual" type="Object"/>
                    <param name="required" type="Object"/>
                </params>
                <declaration name="message" type="String" line="212"/>
                <scope line="215">
                    <declaration name="reqLength" type="String" line="216"/>
                    <scope line="217">
                        <declaration name="conv" type="int" line="218"/>
                        <declaration name="spChange" type="int" line="219"/>
                    </scope>
                    <declaration name="actualLength" type="int" line="222"/>
                </scope>
                <scope line="226"/>
                <scope line="232"/>
                <scope line="237"/>
            </method>
            <javadoc line="253">
                The JVM is resolving a CONSTANT_MethodHandle CP entry.  And it wants our help.
                  It will make an up-call to this method.  (Do not change the name or signature.)                
            </javadoc>
            <method name="linkMethodHandleConstant" type="MethodHandle" line="257">
                <params>
                    <param name="callerClass" type="Class&lt;?&gt;"/>
                    <param name="refKind" type="int"/>
                    <param name="defc" type="Class&lt;?&gt;"/>
                    <param name="name" type="String"/>
                    <param name="type" type="Object"/>
                </params>
                <scope line="258">
                    <declaration name="lookup" type="Lookup" line="259"/>
                </scope>
                <scope line="262">
                    <declaration name="err" type="Error" line="263"/>
                </scope>
            </method>
            <javadoc line="268">
                This assertion marks code which was written before ricochet frames were implemented.
                  Such code will go away when the ports catch up.                
            </javadoc>
            <method name="workaroundWithoutRicochetFrames" type="boolean" line="272"/>
        </class>
    </source>