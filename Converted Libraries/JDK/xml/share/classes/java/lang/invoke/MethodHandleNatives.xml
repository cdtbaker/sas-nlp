<?xml version="1.0" encoding="UTF-8"?>
    <source package="java.lang.invoke">
        <import package="java.lang.invoke.MethodHandles.Lookup"/>
        <import package="java.lang.reflect.AccessibleObject"/>
        <import package="java.lang.reflect.Field"/>
        <import package="java.lang.invoke.MethodHandleNatives.Constants"/>
        <import package="java.lang.invoke.MethodHandles.Lookup.IMPL_LOOKUP"/>
        <class name="MethodHandleNatives" line="34">
            <comment line="43">
                static only                
            </comment>
            <comment line="45">
                / MethodName support                
            </comment>
            <comment line="53">
                / MethodHandle support                
            </comment>
            <comment line="138">
                All compile-time constants go here.                
            </comment>
            <comment line="139">
                There is an opportunity to check them against the JVM&apos;s idea of them.                
            </comment>
            <comment line="296">
                Up-calls from the JVM.                
            </comment>
            <comment line="297">
                These must NOT be public.                
            </comment>
            <javadoc line="34">
                The JVM interface for the method handles package is all here.
                  This is an interface internal and private to an implemetantion of JSR 292.
                  &lt;em&gt;This class is not part of the JSR 292 standard.&lt;/em&gt;                
                <author>
                    jrose                    
                </author>
            </javadoc>
            <method name="MethodHandleNatives" type="constructor" line="42"/>
            <method name="init" type="void" line="46"/>
            <method name="expand" type="void" line="47"/>
            <method name="resolve" type="void" line="48"/>
            <method name="getMembers" type="int" line="49"/>
            <method name="init" type="void" line="54"/>
            <javadoc line="54">
                Initialize the method handle to adapt the call.                
            </javadoc>
            <method name="init" type="void" line="56"/>
            <javadoc line="56">
                Initialize the method handle to call the correct method, directly.                
            </javadoc>
            <method name="init" type="void" line="58"/>
            <javadoc line="58">
                Initialize the method handle to call as if by an invoke instruction.                
            </javadoc>
            <method name="init" type="void" line="61"/>
            <javadoc line="61">
                Initialize a method type, once per form.                
            </javadoc>
            <method name="registerBootstrap" type="void" line="64"/>
            <javadoc line="64">
                Tell the JVM about a class&apos;s bootstrap method.                
            </javadoc>
            <method name="getBootstrap" type="MethodHandle" line="67"/>
            <javadoc line="67">
                Ask the JVM about a class&apos;s bootstrap method.                
            </javadoc>
            <method name="setCallSiteTarget" type="void" line="70"/>
            <javadoc line="70">
                Tell the JVM that we need to change the target of an invokedynamic.                
            </javadoc>
            <method name="getTarget" type="Object" line="73"/>
            <javadoc line="73">
                Fetch the vmtarget field.
                  It will be sanitized as necessary to avoid exposing non-Java references.
                  This routine is for debugging and reflection.                
            </javadoc>
            <javadoc line="79">
                Fetch the name of the handled method, if available.
                  This routine is for debugging and reflection.                
            </javadoc>
            <method name="getMethodName" type="MemberName" line="82">
                <params>
                    <param name="self" type="MethodHandle"/>
                </params>
            </method>
            <javadoc line="86">
                Fetch the reflective version of the handled method, if available.                
            </javadoc>
            <method name="getTargetMethod" type="AccessibleObject" line="88">
                <params>
                    <param name="self" type="MethodHandle"/>
                </params>
            </method>
            <javadoc line="92">
                Fetch the target of this method handle.
                  If it directly targets a method, return a MemberName for the method.
                  If it is chained to another method handle, return that handle.                
            </javadoc>
            <method name="getTargetInfo" type="Object" line="96">
                <params>
                    <param name="self" type="MethodHandle"/>
                </params>
            </method>
            <method name="makeTarget" type="Object[]" line="100">
                <params>
                    <param name="defc" type="Class<?>"/>
                    <param name="name" type="String"/>
                    <param name="sig" type="String"/>
                    <param name="mods" type="int"/>
                    <param name="refc" type="Class<?>"/>
                </params>
            </method>
            <method name="getConstant" type="int" line="104"/>
            <javadoc line="104">
                Fetch MH-related JVM parameter.
                  which=0 retrieves MethodHandlePushLimit
                  which=1 retrieves stack slot push size (in address units)                
            </javadoc>
            <declaration name="JVM_PUSH_LIMIT" type="int" line="110"/>
            <javadoc line="110">
                Java copy of MethodHandlePushLimit in range 2..255.                
            </javadoc>
            <declaration name="JVM_STACK_MOVE_UNIT" type="int" line="112"/>
            <javadoc line="112">
                JVM stack motion (in words) after one slot is pushed, usually -1.                
            </javadoc>
            <declaration name="CONV_OP_IMPLEMENTED_MASK" type="int" line="116"/>
            <javadoc line="116">
                Which conv-ops are implemented by the JVM?                
            </javadoc>
            <declaration name="HAVE_RICOCHET_FRAMES" type="boolean" line="118"/>
            <javadoc line="118">
                Derived mode flag.  Only false on some old JVM implementations.                
            </javadoc>
            <declaration name="OP_ROT_ARGS_DOWN_LIMIT_BIAS" type="int" line="121"/>
            <method name="registerNatives" type="void" line="123"/>
            <scope line="124">
                <declaration name="k" type="int" line="126"/>
            </scope>
            <class name="Constants" line="139">
                <comment line="141">
                    static only                    
                </comment>
                <comment line="142">
                    MethodHandleImpl                    
                </comment>
                <comment line="152">
                    ultimate method as java.lang.reflect object (sans refClass)                    
                </comment>
                <comment line="154">
                    MemberName                    
                </comment>
                <comment line="155">
                    The JVM uses values of -2 and above for vtable indexes.                    
                </comment>
                <comment line="156">
                    Field values are simple positive offsets.                    
                </comment>
                <comment line="157">
                    Ref: src/share/vm/oops/methodOop.hpp                    
                </comment>
                <comment line="158">
                    This value is negative enough to avoid such numbers,                    
                </comment>
                <comment line="159">
                    but not too negative.                    
                </comment>
                <comment line="169">
                    BoundMethodHandle                    
                </comment>
                <comment line="175">
                    AdapterMethodHandle                    
                </comment>
                <comment line="195">
                    limit of CONV_OP enumeration                    
                </comment>
                <method name="Constants" type="constructor" line="140"/>
                <declaration name="GC_JVM_PUSH_LIMIT" type="int" line="142"/>
                <declaration name="ETF_HANDLE_OR_METHOD_NAME" type="int" line="147"/>
                <declaration name="MN_IS_METHOD" type="int" line="159"/>
                <declaration name="ARG_SLOT_PUSH_SHIFT" type="int" line="169"/>
                <javadoc line="169">
                    Constants for decoding the vmargslot field, which contains 2 values.                    
                </javadoc>
                <declaration name="OP_RETYPE_ONLY" type="int" line="175"/>
                <javadoc line="175">
                    Conversions recognized by the JVM.
                      They must align with the constants in java.lang.invoke.AdapterMethodHandle,
                      in the JVM file hotspot/src/share/vm/classfile/javaClasses.hpp.                    
                </javadoc>
                <declaration name="CONV_OP_MASK" type="int" line="195"/>
                <javadoc line="195">
                    Shift and mask values for decoding the AMH.conversion field.
                      These numbers are shared with the JVM for creating AMHs.                    
                </javadoc>
                <declaration name="DEFAULT_CONV_OP_IMPLEMENTED_MASK" type="int" line="209"/>
                <javadoc line="209">
                    Which conv-ops are implemented by the JVM?                    
                </javadoc>
                <declaration name="T_BOOLEAN" type="int" line="224"/>
                <javadoc line="224">
                    Basic types as encoded in the JVM.  These code values are not
                      intended for use outside this class.  They are used as part of
                      a private interface between the JVM and this class.                    
                </javadoc>
                <declaration name="REF_getField" type="int" line="244"/>
                <javadoc line="244">
                    Constant pool reference-kind codes, as used by CONSTANT_MethodHandle CP entries.                    
                </javadoc>
            </class>
            <method name="getNamedCon" type="int" line="259"/>
            <method name="verifyConstants" type="boolean" line="260">
                <comment line="280">
                    ignore exotic ops the JVM cares about; we just wont issue them                    
                </comment>
                <declaration name="box" type="Object[]" line="261"/>
                <scope line="262">
                    <declaration name="vmval" type="int" line="264"/>
                    <declaration name="name" type="String" line="266"/>
                    <scope line="267">
                        <declaration name="con" type="Field" line="268"/>
                        <declaration name="jval" type="int" line="269"/>
                        <declaration name="err" type="String" line="271"/>
                        <scope line="272"/>
                    </scope>
                    <scope line="277">
                        <scope line="278">
                            <declaration name="err" type="String" line="279"/>
                            <scope line="281"/>
                        </scope>
                    </scope>
                </scope>
            </method>
            <scope line="291"/>
            <javadoc line="298">
                The JVM is linking an invokedynamic instruction.  Create a reified call site for it.                
            </javadoc>
            <method name="makeDynamicCallSite" type="CallSite" line="304">
                <params>
                    <param name="bootstrapMethod" type="MethodHandle"/>
                    <param name="name" type="String"/>
                    <param name="type" type="MethodType"/>
                    <param name="info" type="Object"/>
                    <param name="callerMethod" type="MemberName"/>
                    <param name="callerBCI" type="int"/>
                </params>
            </method>
            <javadoc line="308">
                Called by the JVM to check the length of a spread array.                
            </javadoc>
            <method name="checkSpreadArgument" type="void" line="311">
                <params>
                    <param name="av" type="Object"/>
                    <param name="n" type="int"/>
                </params>
            </method>
            <javadoc line="315">
                The JVM wants a pointer to a MethodType.  Oblige it by finding or creating one.                
            </javadoc>
            <method name="findMethodHandleType" type="MethodType" line="318">
                <params>
                    <param name="rtype" type="Class<?>"/>
                    <param name="ptypes" type="Class<?>[]"/>
                </params>
            </method>
            <javadoc line="322">
                The JVM wants to use a MethodType with inexact invoke.  Give the runtime fair warning.                
            </javadoc>
            <method name="notifyGenericMethodType" type="void" line="325">
                <params>
                    <param name="type" type="MethodType"/>
                </params>
            </method>
            <javadoc line="329">
                The JVM wants to raise an exception.  Here&apos;s the path.                
            </javadoc>
            <method name="raiseException" type="void" line="332">
                <params>
                    <param name="code" type="int"/>
                    <param name="actual" type="Object"/>
                    <param name="required" type="Object"/>
                </params>
                <comment line="335">
                    arraylength                    
                </comment>
                <comment line="348">
                    should have been an array                    
                </comment>
                <comment line="349">
                    checkcast                    
                </comment>
                <comment line="351">
                    athrow                    
                </comment>
                <comment line="352">
                    JVM is asking us to wrap an exception which happened during resolving                    
                </comment>
                <comment line="358">
                    disregard the identity of the actual object, if it is not a class:                    
                </comment>
                <comment line="368">
                    arraylength                    
                </comment>
                <comment line="370">
                    _aaload                    
                </comment>
                <comment line="372">
                    checkcast                    
                </comment>
                <declaration name="message" type="String" line="333"/>
                <scope line="336">
                    <declaration name="reqLength" type="String" line="337"/>
                    <scope line="338">
                        <declaration name="conv" type="int" line="339"/>
                        <declaration name="spChange" type="int" line="340"/>
                    </scope>
                    <declaration name="actualLength" type="int" line="343"/>
                </scope>
                <scope line="346"/>
                <scope line="353"/>
                <scope line="359"/>
            </method>
            <javadoc line="379">
                The JVM is resolving a CONSTANT_MethodHandle CP entry.  And it wants our help.
                  It will make an up-call to this method.  (Do not change the name or signature.)                
            </javadoc>
            <method name="linkMethodHandleConstant" type="MethodHandle" line="384">
                <params>
                    <param name="callerClass" type="Class<?>"/>
                    <param name="refKind" type="int"/>
                    <param name="defc" type="Class<?>"/>
                    <param name="name" type="String"/>
                    <param name="type" type="Object"/>
                </params>
                <scope line="385">
                    <declaration name="lookup" type="Lookup" line="386"/>
                </scope>
                <scope line="388">
                    <declaration name="err" type="Error" line="389"/>
                </scope>
            </method>
            <javadoc line="395">
                This assertion marks code which was written before ricochet frames were implemented.
                  Such code will go away when the ports catch up.                
            </javadoc>
            <method name="workaroundWithoutRicochetFrames" type="boolean" line="399"/>
        </class>
    </source>