<?xml version="1.0" encoding="UTF-8"?>
    <source package="java.lang.invoke">
        <import package="java.lang.reflect"/>
        <import package="sun.invoke.WrapperInstance"/>
        <import package="sun.invoke.util.ValueConversions"/>
        <import package="sun.invoke.util.VerifyAccess"/>
        <import package="sun.invoke.util.Wrapper"/>
        <import package="java.util.List"/>
        <import package="java.util.ArrayList"/>
        <import package="java.util.Arrays"/>
        <import package="sun.reflect.Reflection"/>
        <import package="java.lang.invoke.MethodHandleStatics"/>
        <import package="java.lang.invoke.MethodHandleNatives.Constants"/>
        <class name="MethodHandles" line="40">
            <comment line="55">
                do not instantiate                
            </comment>
            <comment line="59">
                See IMPL_LOOKUP below.                
            </comment>
            <comment line="61">
                // Method handle creation from ordinary methods.                
            </comment>
            <comment line="1284">
                / method handle invocation (reflective style)                
            </comment>
            <comment line="1465">
                FIXME: Delete this.  It is used only for insertArguments &amp; bindTo.
                 Replace by a more standard check.                
            </comment>
            <comment line="1479">
                / method handle modification (creation from other method handles)                
            </comment>
            <comment line="1918">
                                
            </comment>
            <javadoc line="40">
                This class consists exclusively of static methods that operate on or return
                  method handles. They fall into several categories:
                  &lt;ul&gt;
                  &lt;li&gt;Lookup methods which help create method handles for methods and fields.
                  &lt;li&gt;Combinator methods, which combine or transform pre-existing method handles into new ones.
                  &lt;li&gt;Other factory methods to create method handles that emulate other common JVM operations or control flow patterns.
                  &lt;li&gt;Wrapper methods which can convert between method handles and interface types.
                  &lt;/ul&gt;
                  &lt;p&gt;                
                <author>
                    John Rose, JSR 292 EG                    
                </author>
            </javadoc>
            <method name="MethodHandles" type="constructor" line="54"/>
            <declaration name="IMPL_NAMES" type="MemberName.Factory" line="56"/>
            <scope line="57"/>
            <javadoc line="62">
                Returns a {@link Lookup lookup object} on the caller,
                  which has the capability to access any method handle that the caller has access to,
                  including direct method handles to private fields and methods.
                  This lookup object is a &lt;em&gt;capability&lt;/em&gt; which may be delegated to trusted agents.
                  Do not store it in place where untrusted code can access it.                
            </javadoc>
            <method name="lookup" type="Lookup" line="69"/>
            <javadoc line="73">
                Returns a {@link Lookup lookup object} which is trusted minimally.
                  It can only be used to create method handles to
                  publicly accessible fields and methods.
                  &lt;p&gt;
                  As a matter of pure convention, the {@linkplain Lookup#lookupClass lookup class}of this lookup object will be {@link java.lang.Object}.
                  &lt;p&gt;
                  The lookup class can be changed to any other class {@code C} using an expression of the form{@linkplain Lookup#in &lt;code&gt;publicLookup().in(C.class)&lt;/code&gt;}.
                  Since all classes have equal access to public names,
                  such a change would confer no new access rights.                
            </javadoc>
            <method name="publicLookup" type="Lookup" line="86"/>
            <class name="Lookup" line="90">
                <comment line="376">
                    This is just for calling out to MethodHandleImpl.                    
                </comment>
                <comment line="475">
                    Make sure outer class is initialized first.                    
                </comment>
                <comment line="544">
                    call this from an entry point method in Lookup with extraFrames=0.                    
                </comment>
                <comment line="1055">
                    / Helper methods, all package-private.                    
                </comment>
                <comment line="1436">
                    FIXME: This is used in just one place.  Refactor away.                    
                </comment>
                <javadoc line="90">
                    A &lt;em&gt;lookup object&lt;/em&gt; is a factory for creating method handles,
                      when the creation requires access checking.
                      Method handles do not perform
                      access checks when they are called, but rather when they are created.
                      Therefore, method handle access
                      restrictions must be enforced when a method handle is created.
                      The caller class against which those restrictions are enforced
                      is known as the {@linkplain #lookupClass lookup class}.
                      &lt;p&gt;
                      A lookup class which needs to create method handles will call{@link MethodHandles#lookup MethodHandles.lookup} to create a factory for itself.
                      When the {@code Lookup} factory object is created, the identity of the lookup class is
                      determined, and securely stored in the {@code Lookup} object.
                      The lookup class (or its delegates) may then use factory methods
                      on the {@code Lookup} object to create method handles for access-checked members.
                      This includes all methods, constructors, and fields which are allowed to the lookup class,
                      even private ones.
                      &lt;p&gt;
                      The factory methods on a {@code Lookup} object correspond to all major
                      use cases for methods, constructors, and fields.
                      Here is a summary of the correspondence between these factory methods and
                      the behavior the resulting method handles:
                      &lt;code&gt;
                      &lt;table border=1 cellpadding=5 summary=&quot;lookup method behaviors&quot;&gt;
                      &lt;tr&gt;&lt;th&gt;lookup expression&lt;/th&gt;&lt;th&gt;member&lt;/th&gt;&lt;th&gt;behavior&lt;/th&gt;&lt;/tr&gt;
                      &lt;tr&gt;
                      &lt;td&gt;{@linkplain java.lang.invoke.MethodHandles.Lookup#findGetter lookup.findGetter(C.class,&quot;f&quot;,FT.class)}&lt;/td&gt;
                      &lt;td&gt;FT f;&lt;/td&gt;&lt;td&gt;(T) this.f;&lt;/td&gt;
                      &lt;/tr&gt;
                      &lt;tr&gt;
                      &lt;td&gt;{@linkplain java.lang.invoke.MethodHandles.Lookup#findStaticGetter lookup.findStaticGetter(C.class,&quot;f&quot;,FT.class)}&lt;/td&gt;
                      &lt;td&gt;static&lt;br&gt;FT f;&lt;/td&gt;&lt;td&gt;(T) C.f;&lt;/td&gt;
                      &lt;/tr&gt;
                      &lt;tr&gt;
                      &lt;td&gt;{@linkplain java.lang.invoke.MethodHandles.Lookup#findSetter lookup.findSetter(C.class,&quot;f&quot;,FT.class)}&lt;/td&gt;
                      &lt;td&gt;FT f;&lt;/td&gt;&lt;td&gt;this.f = x;&lt;/td&gt;
                      &lt;/tr&gt;
                      &lt;tr&gt;
                      &lt;td&gt;{@linkplain java.lang.invoke.MethodHandles.Lookup#findStaticSetter lookup.findStaticSetter(C.class,&quot;f&quot;,FT.class)}&lt;/td&gt;
                      &lt;td&gt;static&lt;br&gt;FT f;&lt;/td&gt;&lt;td&gt;C.f = arg;&lt;/td&gt;
                      &lt;/tr&gt;
                      &lt;tr&gt;
                      &lt;td&gt;{@linkplain java.lang.invoke.MethodHandles.Lookup#findVirtual lookup.findVirtual(C.class,&quot;m&quot;,MT)}&lt;/td&gt;
                      &lt;td&gt;T m(A);&lt;/td&gt;&lt;td&gt;(T) this.m(arg);&lt;/td&gt;
                      &lt;/tr&gt;
                      &lt;tr&gt;
                      &lt;td&gt;{@linkplain java.lang.invoke.MethodHandles.Lookup#findStatic lookup.findStatic(C.class,&quot;m&quot;,MT)}&lt;/td&gt;
                      &lt;td&gt;static&lt;br&gt;T m(A);&lt;/td&gt;&lt;td&gt;(T) C.m(arg);&lt;/td&gt;
                      &lt;/tr&gt;
                      &lt;tr&gt;
                      &lt;td&gt;{@linkplain java.lang.invoke.MethodHandles.Lookup#findSpecial lookup.findSpecial(C.class,&quot;m&quot;,MT,this.class)}&lt;/td&gt;
                      &lt;td&gt;T m(A);&lt;/td&gt;&lt;td&gt;(T) super.m(arg);&lt;/td&gt;
                      &lt;/tr&gt;
                      &lt;tr&gt;
                      &lt;td&gt;{@linkplain java.lang.invoke.MethodHandles.Lookup#findConstructor lookup.findConstructor(C.class,MT)}&lt;/td&gt;
                      &lt;td&gt;C(A);&lt;/td&gt;&lt;td&gt;(T) new C(arg);&lt;/td&gt;
                      &lt;/tr&gt;
                      &lt;tr&gt;
                      &lt;td&gt;{@linkplain java.lang.invoke.MethodHandles.Lookup#unreflectGetter lookup.unreflectGetter(aField)}&lt;/td&gt;
                      &lt;td&gt;(static)?&lt;br&gt;FT f;&lt;/td&gt;&lt;td&gt;(FT) aField.get(thisOrNull);&lt;/td&gt;
                      &lt;/tr&gt;
                      &lt;tr&gt;
                      &lt;td&gt;{@linkplain java.lang.invoke.MethodHandles.Lookup#unreflectSetter lookup.unreflectSetter(aField)}&lt;/td&gt;
                      &lt;td&gt;(static)?&lt;br&gt;FT f;&lt;/td&gt;&lt;td&gt;aField.set(thisOrNull, arg);&lt;/td&gt;
                      &lt;/tr&gt;
                      &lt;tr&gt;
                      &lt;td&gt;{@linkplain java.lang.invoke.MethodHandles.Lookup#unreflect lookup.unreflect(aMethod)}&lt;/td&gt;
                      &lt;td&gt;(static)?&lt;br&gt;T m(A);&lt;/td&gt;&lt;td&gt;(T) aMethod.invoke(thisOrNull, arg);&lt;/td&gt;
                      &lt;/tr&gt;
                      &lt;tr&gt;
                      &lt;td&gt;{@linkplain java.lang.invoke.MethodHandles.Lookup#unreflectConstructor lookup.unreflectConstructor(aConstructor)}&lt;/td&gt;
                      &lt;td&gt;C(A);&lt;/td&gt;&lt;td&gt;(C) aConstructor.newInstance(arg);&lt;/td&gt;
                      &lt;/tr&gt;
                      &lt;tr&gt;
                      &lt;td&gt;{@linkplain java.lang.invoke.MethodHandles.Lookup#unreflect lookup.unreflect(aMethod)}&lt;/td&gt;
                      &lt;td&gt;(static)?&lt;br&gt;T m(A);&lt;/td&gt;&lt;td&gt;(T) aMethod.invoke(thisOrNull, arg);&lt;/td&gt;
                      &lt;/tr&gt;
                      &lt;/table&gt;
                      &lt;/code&gt;
                      Here, the type {@code C} is the class or interface being searched for a member,
                      documented as a parameter named {@code refc} in the lookup methods.
                      The method or constructor type {@code MT} is composed from the return type {@code T}and the sequence of argument types {@code A}.
                      Both {@code MT} and the field type {@code FT} are documented as a parameter named {@code type}.
                      The formal parameter {@code this} stands for the self-reference of type {@code C};
                      if it is present, it is always the leading argument to the method handle invocation.
                      The name {@code arg} stands for all the other method handle arguments.
                      In the code examples for the Core Reflection API, the name {@code thisOrNull}stands for a null reference if the accessed method or field is static,
                      and {@code this} otherwise.
                      The names {@code aMethod}, {@code aField}, and {@code aConstructor} stand
                      for reflective objects corresponding to the given members.
                      &lt;p&gt;
                      In cases where the given member is of variable arity (i.e., a method or constructor)
                      the returned method handle will also be of {@linkplain MethodHandle#asVarargsCollector variable arity}.
                      In all other cases, the returned method handle will be of fixed arity.
                      &lt;p&gt;
                      The equivalence between looked-up method handles and underlying
                      class members can break down in a few ways:
                      &lt;ul&gt;
                      &lt;li&gt;If {@code C} is not symbolically accessible from the lookup class&apos;s loader,
                      the lookup can still succeed, even when there is no equivalent
                      Java expression or bytecoded constant.
                      &lt;li&gt;Likewise, if {@code T} or {@code MT}is not symbolically accessible from the lookup class&apos;s loader,
                      the lookup can still succeed.
                      For example, lookups for {@code MethodHandle.invokeExact} and{@code MethodHandle.invoke} will always succeed, regardless of requested type.
                      &lt;li&gt;If there is a security manager installed, it can forbid the lookup
                      on various grounds (&lt;a href=&quot;#secmgr&quot;&gt;see below&lt;/a&gt;).
                      By contrast, the {@code ldc} instruction is not subject to
                      security manager checks.
                      &lt;/ul&gt;
                      &lt;h3&gt;&lt;a name=&quot;access&quot;&gt;&lt;/a&gt;Access checking&lt;/h3&gt;
                      Access checks are applied in the factory methods of {@code Lookup},
                      when a method handle is created.
                      This is a key difference from the Core Reflection API, since{@link java.lang.reflect.Method#invoke java.lang.reflect.Method.invoke}performs access checking against every caller, on every call.
                      &lt;p&gt;
                      All access checks start from a {@code Lookup} object, which
                      compares its recorded lookup class against all requests to
                      create method handles.
                      A single {@code Lookup} object can be used to create any number
                      of access-checked method handles, all checked against a single
                      lookup class.
                      &lt;p&gt;
                      A {@code Lookup} object can be shared with other trusted code,
                      such as a metaobject protocol.
                      A shared {@code Lookup} object delegates the capability
                      to create method handles on private members of the lookup class.
                      Even if privileged code uses the {@code Lookup} object,
                      the access checking is confined to the privileges of the
                      original lookup class.
                      &lt;p&gt;
                      A lookup can fail, because
                      the containing class is not accessible to the lookup class, or
                      because the desired class member is missing, or because the
                      desired class member is not accessible to the lookup class.
                      In any of these cases, a {@code ReflectiveOperationException} will be
                      thrown from the attempted lookup.  The exact class will be one of
                      the following:
                      &lt;ul&gt;
                      &lt;li&gt;NoSuchMethodException &amp;mdash; if a method is requested but does not exist
                      &lt;li&gt;NoSuchFieldException &amp;mdash; if a field is requested but does not exist
                      &lt;li&gt;IllegalAccessException &amp;mdash; if the member exists but an access check fails
                      &lt;/ul&gt;
                      &lt;p&gt;
                      In general, the conditions under which a method handle may be
                      looked up for a method {@code M} are exactly equivalent to the conditions
                      under which the lookup class could have compiled and resolved a call to {@code M}.
                      And the effect of invoking the method handle resulting from the lookup
                      is exactly equivalent to executing the compiled and resolved call to {@code M}.
                      The same point is true of fields and constructors.
                      &lt;p&gt;
                      In some cases, access between nested classes is obtained by the Java compiler by creating
                      an wrapper method to access a private method of another class
                      in the same top-level declaration.
                      For example, a nested class {@code C.D}can access private members within other related classes such as{@code C}, {@code C.D.E}, or {@code C.B},
                      but the Java compiler may need to generate wrapper methods in
                      those related classes.  In such cases, a {@code Lookup} object on{@code C.E} would be unable to those private members.
                      A workaround for this limitation is the {@link Lookup#in Lookup.in} method,
                      which can transform a lookup on {@code C.E} into one on any of those other
                      classes, without special elevation of privilege.
                      &lt;p&gt;
                      Although bytecode instructions can only refer to classes in
                      a related class loader, this API can search for methods in any
                      class, as long as a reference to its {@code Class} object is
                      available.  Such cross-loader references are also possible with the
                      Core Reflection API, and are impossible to bytecode instructions
                      such as {@code invokestatic} or {@code getfield}.
                      There is a {@linkplain java.lang.SecurityManager security manager API}to allow applications to check such cross-loader references.
                      These checks apply to both the {@code MethodHandles.Lookup} API
                      and the Core Reflection API
                      (as found on {@link java.lang.Class Class}).
                      &lt;p&gt;
                      Access checks only apply to named and reflected methods,
                      constructors, and fields.
                      Other method handle creation methods, such as{@link MethodHandle#asType MethodHandle.asType},
                      do not require any access checks, and are done
                      with static methods of {@link MethodHandles},
                      independently of any {@code Lookup} object.
                      &lt;h3&gt;Security manager interactions&lt;/h3&gt;
                      &lt;a name=&quot;secmgr&quot;&gt;&lt;/a&gt;
                      If a security manager is present, member lookups are subject to
                      additional checks.
                      From one to four calls are made to the security manager.
                      Any of these calls can refuse access by throwing a{@link java.lang.SecurityException SecurityException}.
                      Define {@code smgr} as the security manager,{@code refc} as the containing class in which the member
                      is being sought, and {@code defc} as the class in which the
                      member is actually defined.
                      The calls are made according to the following rules:
                      &lt;ul&gt;
                      &lt;li&gt;In all cases, {@link SecurityManager#checkMemberAccesssmgr.checkMemberAccess(refc, Member.PUBLIC)} is called.
                      &lt;li&gt;If the class loader of the lookup class is not
                      the same as or an ancestor of the class loader of {@code refc},
                      then {@link SecurityManager#checkPackageAccesssmgr.checkPackageAccess(refcPkg)} is called,
                      where {@code refcPkg} is the package of {@code refc}.
                      &lt;li&gt;If the retrieved member is not public,{@link SecurityManager#checkMemberAccesssmgr.checkMemberAccess(defc, Member.DECLARED)} is called.
                      (Note that {@code defc} might be the same as {@code refc}.)
                      The default implementation of this security manager method
                      inspects the stack to determine the original caller of
                      the reflective request (such as {@code findStatic}),
                      and performs additional permission checks if the
                      class loader of {@code defc} differs from the class
                      loader of the class from which the reflective request came.
                      &lt;li&gt;If the retrieved member is not public,
                      and if {@code defc} and {@code refc} are in different class loaders,
                      and if the class loader of the lookup class is not
                      the same as or an ancestor of the class loader of {@code defc},
                      then {@link SecurityManager#checkPackageAccesssmgr.checkPackageAccess(defcPkg)} is called,
                      where {@code defcPkg} is the package of {@code defc}.
                      &lt;/ul&gt;                    
                </javadoc>
                <declaration name="lookupClass" type="Class&lt;?&gt;" line="321"/>
                <javadoc line="321">
                    The class on behalf of whom the lookup is being performed.                    
                </javadoc>
                <declaration name="allowedModes" type="int" line="324"/>
                <javadoc line="324">
                    The allowed sorts of members which may be looked up (PUBLIC, etc.).                    
                </javadoc>
                <declaration name="PUBLIC" type="int" line="327"/>
                <javadoc line="327">
                    A single-bit mask representing {@code public} access,
                      which may contribute to the result of {@link #lookupModes lookupModes}.
                      The value, {@code 0x01}, happens to be the same as the value of the{@code public} {@linkplain java.lang.reflect.Modifier#PUBLIC modifier bit}.                    
                </javadoc>
                <declaration name="PRIVATE" type="int" line="334"/>
                <javadoc line="334">
                    A single-bit mask representing {@code private} access,
                      which may contribute to the result of {@link #lookupModes lookupModes}.
                      The value, {@code 0x02}, happens to be the same as the value of the{@code private} {@linkplain java.lang.reflect.Modifier#PRIVATE modifier bit}.                    
                </javadoc>
                <declaration name="PROTECTED" type="int" line="341"/>
                <javadoc line="341">
                    A single-bit mask representing {@code protected} access,
                      which may contribute to the result of {@link #lookupModes lookupModes}.
                      The value, {@code 0x04}, happens to be the same as the value of the{@code protected} {@linkplain java.lang.reflect.Modifier#PROTECTED modifier bit}.                    
                </javadoc>
                <declaration name="PACKAGE" type="int" line="348"/>
                <javadoc line="348">
                    A single-bit mask representing {@code package} access (default access),
                      which may contribute to the result of {@link #lookupModes lookupModes}.
                      The value is {@code 0x08}, which does not correspond meaningfully to
                      any particular {@linkplain java.lang.reflect.Modifier modifier bit}.                    
                </javadoc>
                <declaration name="ALL_MODES" type="int" line="355"/>
                <declaration name="TRUSTED" type="int" line="356"/>
                <method name="fixmods" type="int" line="358">
                    <params>
                        <param name="mods" type="int"/>
                    </params>
                </method>
                <javadoc line="363">
                    Tells which class is performing the lookup.  It is this class against
                      which checks are performed for visibility and access permissions.
                      &lt;p&gt;
                      The class implies a maximum level of access permission,
                      but the permissions may be additionally limited by the bitmask{@link #lookupModes lookupModes}, which controls whether non-public members
                      can be accessed.                    
                </javadoc>
                <method name="lookupClass" type="Class<?>" line="371"/>
                <method name="lookupClassOrNull" type="Class<?>" line="376"/>
                <javadoc line="380">
                    Tells which access-protection classes of members this lookup object can produce.
                      The result is a bit-mask of the bits{@linkplain #PUBLIC PUBLIC (0x01)},{@linkplain #PRIVATE PRIVATE (0x02)},{@linkplain #PROTECTED PROTECTED (0x04)},
                      and {@linkplain #PACKAGE PACKAGE (0x08)}.
                      &lt;p&gt;
                      A freshly-created lookup object
                      on the {@linkplain java.lang.invoke.MethodHandles#lookup() caller&apos;s class}has all possible bits set, since the caller class can access all its own members.
                      A lookup object on a new lookup class{@linkplain java.lang.invoke.MethodHandles.Lookup#in created from a previous lookup object}may have some mode bits set to zero.
                      The purpose of this is to restrict access via the new lookup object,
                      so that it can access only names which can be reached by the original
                      lookup object, and also by the new lookup class.                    
                </javadoc>
                <method name="lookupModes" type="int" line="397"/>
                <javadoc line="401">
                    Embody the current class (the lookupClass) as a lookup class
                      for method handle creation.
                      Must be called by from a method in this package,
                      which in turn is called by a method not in this package.
                      &lt;p&gt;
                      Also, don&apos;t make it private, lest javac interpose
                      an access$N method.                    
                </javadoc>
                <method name="Lookup" type="constructor" line="409">
                    <comment line="412">
                        make sure we haven&apos;t accidentally picked up a privileged class:                        
                    </comment>
                </method>
                <method name="Lookup" type="constructor" line="415">
                    <params>
                        <param name="lookupClass" type="Class<?>"/>
                    </params>
                </method>
                <method name="Lookup" type="constructor" line="419">
                    <params>
                        <param name="lookupClass" type="Class<?>"/>
                        <param name="allowedModes" type="int"/>
                    </params>
                </method>
                <javadoc line="424">
                    Creates a lookup on the specified new lookup class.
                      The resulting object will report the specified
                      class as its own {@link #lookupClass lookupClass}.
                      &lt;p&gt;
                      However, the resulting {@code Lookup} object is guaranteed
                      to have no more access capabilities than the original.
                      In particular, access capabilities can be lost as follows:&lt;ul&gt;
                      &lt;li&gt;If the new lookup class differs from the old one,
                      protected members will not be accessible by virtue of inheritance.
                      (Protected members may continue to be accessible because of package sharing.)
                      &lt;li&gt;If the new lookup class is in a different package
                      than the old one, protected and default (package) members will not be accessible.
                      &lt;li&gt;If the new lookup class is not within the same package member
                      as the old one, private members will not be accessible.
                      &lt;li&gt;If the new lookup class is not accessible to the old lookup class,
                      then no members, not even public members, will be accessible.
                      (In all other cases, public members will continue to be accessible.)
                      &lt;/ul&gt;                    
                    <param>
                        requestedLookupClass the desired lookup class for the new lookup object                        
                    </param>
                    <return>
                        a lookup object which reports the desired lookup class                        
                    </return>
                    <throws>
                        NullPointerException if the argument is null                        
                    </throws>
                </javadoc>
                <method name="in" type="Lookup" line="448">
                    <params>
                        <param name="requestedLookupClass" type="Class<?>"/>
                    </params>
                    <comment line="450">
                        null check                        
                    </comment>
                    <comment line="451">
                        IMPL_LOOKUP can make any lookup at all                        
                    </comment>
                    <comment line="454">
                        keep same capabilities                        
                    </comment>
                    <comment line="460">
                        Allow nestmate lookups to be created without special privilege:                        
                    </comment>
                    <comment line="467">
                        The requested class it not accessible from the lookup class.
                         No permissions.                        
                    </comment>
                    <declaration name="newModes" type="int" line="454"/>
                    <scope line="456"/>
                    <scope line="461"/>
                    <scope line="465"/>
                </method>
                <scope line="475"/>
                <declaration name="PUBLIC_LOOKUP" type="Lookup" line="477"/>
                <javadoc line="477">
                    Version of lookup which is trusted minimally.
                      It can only be used to create method handles to
                      publicly accessible members.                    
                </javadoc>
                <declaration name="IMPL_LOOKUP" type="Lookup" line="483"/>
                <javadoc line="483">
                    Package-private version of lookup which is trusted.                    
                </javadoc>
                <method name="checkUnprivilegedlookupClass" type="void" line="486">
                    <params>
                        <param name="lookupClass" type="Class<?>"/>
                    </params>
                    <declaration name="name" type="String" line="487"/>
                </method>
                <javadoc line="492">
                    Displays the name of the class from which lookups are to be made.
                      (The name is the one reported by {@link java.lang.Class#getName() Class.getName}.)
                      If there are restrictions on the access permitted to this lookup,
                      this is indicated by adding a suffix to the class name, consisting
                      of a slash and a keyword.  The keyword represents the strongest
                      allowed access, and is chosen as follows:
                      &lt;ul&gt;
                      &lt;li&gt;If no access is allowed, the suffix is &quot;/noaccess&quot;.
                      &lt;li&gt;If only public access is allowed, the suffix is &quot;/public&quot;.
                      &lt;li&gt;If only public and package access are allowed, the suffix is &quot;/package&quot;.
                      &lt;li&gt;If only public, package, and private access are allowed, the suffix is &quot;/private&quot;.
                      &lt;/ul&gt;
                      If none of the above cases apply, it is the case that full
                      access (public, package, private, and protected) is allowed.
                      In this case, no suffix is added.
                      This is true only of an object obtained originally from{@link java.lang.invoke.MethodHandles#lookup MethodHandles.lookup}.
                      Objects created by {@link java.lang.invoke.MethodHandles.Lookup#in Lookup.in}always have restricted access, and will display a suffix.
                      &lt;p&gt;
                      (It may seem strange that protected access should be
                      stronger than private access.  Viewed independently from
                      package access, protected access is the first to be lost,
                      because it requires a direct subclass relationship between
                      caller and callee.)                    
                    <see>
                        #in                        
                    </see>
                </javadoc>
                <method name="toString" type="String" line="521">
                    <comment line="525">
                        no privileges                        
                    </comment>
                    <comment line="536">
                        internal only; not exported                        
                    </comment>
                    <comment line="537">
                        Should not happen, but it&apos;s a bitfield...                        
                    </comment>
                    <declaration name="cname" type="String" line="522"/>
                </method>
                <method name="getCallerClassAtEntryPoint" type="Class<?>" line="544">
                    <comment line="547">
                        0: Reflection.getCC, 1: getCallerClassAtEntryPoint,
                         2: Lookup.&lt;init&gt;, 3: MethodHandles.*, 4: caller
                         Note:  This should be the only use of getCallerClass in this file.                        
                    </comment>
                    <declaration name="CALLER_DEPTH" type="int" line="545"/>
                </method>
                <javadoc line="553">
                    Produces a method handle for a static method.
                      The type of the method handle will be that of the method.
                      (Since static methods do not take receivers, there is no
                      additional receiver argument inserted into the method handle type,
                      as there would be with {@link #findVirtual findVirtual} or {@link #findSpecial findSpecial}.)
                      The method and all its argument types must be accessible to the lookup class.
                      If the method&apos;s class has not yet been initialized, that is done
                      immediately, before the method handle is returned.
                      &lt;p&gt;
                      The returned method handle will have{@linkplain MethodHandle#asVarargsCollector variable arity} if and only if
                      the method&apos;s variable arity modifier bit ({@code 0x0080}) is set.                    
                    <param>
                        refc the class from which the method is accessed                        
                    </param>
                    <param>
                        name the name of the method                        
                    </param>
                    <param>
                        type the type of the method                        
                    </param>
                    <return>
                        the desired method handle                        
                    </return>
                    <throws>
                        NoSuchMethodException if the method does not exist                        
                    </throws>
                    <throws>
                        IllegalAccessException if access checking fails,
                          or if the method is not {@code static},
                          or if the method&apos;s variable arity modifier bit
                          is set and {@code asVarargsCollector} fails                        
                    </throws>
                    <exception>
                        SecurityException if a security manager is present and it
                          &lt;a href=&quot;MethodHandles.Lookup.html#secmgr&quot;&gt;refuses access&lt;/a&gt;                        
                    </exception>
                    <throws>
                        NullPointerException if any argument is null                        
                    </throws>
                </javadoc>
                <method name="findStatic" type="MethodHandle" line="580">
                    <params>
                        <param name="refc" type="Class<?>"/>
                        <param name="name" type="String"/>
                        <param name="type" type="MethodType"/>
                    </params>
                    <comment line="583">
                        stack walk magic: do not refactor                        
                    </comment>
                    <declaration name="method" type="MemberName" line="581"/>
                </method>
                <method name="accessStatic" type="MethodHandle" line="586">
                    <params>
                        <param name="refc" type="Class<?>"/>
                        <param name="method" type="MemberName"/>
                    </params>
                </method>
                <method name="resolveStatic" type="MethodHandle" line="591">
                    <params>
                        <param name="refc" type="Class<?>"/>
                        <param name="name" type="String"/>
                        <param name="type" type="MethodType"/>
                    </params>
                    <declaration name="method" type="MemberName" line="592"/>
                </method>
                <javadoc line="596">
                    Produces a method handle for a virtual method.
                      The type of the method handle will be that of the method,
                      with the receiver type (usually {@code refc}) prepended.
                      The method and all its argument types must be accessible to the lookup class.
                      &lt;p&gt;
                      When called, the handle will treat the first argument as a receiver
                      and dispatch on the receiver&apos;s type to determine which method
                      implementation to enter.
                      (The dispatching action is identical with that performed by an{@code invokevirtual} or {@code invokeinterface} instruction.)
                      &lt;p&gt;
                      The returned method handle will have{@linkplain MethodHandle#asVarargsCollector variable arity} if and only if
                      the method&apos;s variable arity modifier bit ({@code 0x0080}) is set.
                      &lt;p&gt;
                      Because of the general equivalence between {@code invokevirtual}instructions and method handles produced by {@code findVirtual},
                      if the class is {@code MethodHandle} and the name string is{@code invokeExact} or {@code invoke}, the resulting
                      method handle is equivalent to one produced by{@link java.lang.invoke.MethodHandles#exactInvoker MethodHandles.exactInvoker} or{@link java.lang.invoke.MethodHandles#invoker MethodHandles.invoker}with the same {@code type} argument.                    
                    <param>
                        refc the class or interface from which the method is accessed                        
                    </param>
                    <param>
                        name the name of the method                        
                    </param>
                    <param>
                        type the type of the method, with the receiver argument omitted                        
                    </param>
                    <return>
                        the desired method handle                        
                    </return>
                    <throws>
                        NoSuchMethodException if the method does not exist                        
                    </throws>
                    <throws>
                        IllegalAccessException if access checking fails,
                          or if the method is {@code static}or if the method&apos;s variable arity modifier bit
                          is set and {@code asVarargsCollector} fails                        
                    </throws>
                    <exception>
                        SecurityException if a security manager is present and it
                          &lt;a href=&quot;MethodHandles.Lookup.html#secmgr&quot;&gt;refuses access&lt;/a&gt;                        
                    </exception>
                    <throws>
                        NullPointerException if any argument is null                        
                    </throws>
                </javadoc>
                <method name="findVirtual" type="MethodHandle" line="634">
                    <params>
                        <param name="refc" type="Class<?>"/>
                        <param name="name" type="String"/>
                        <param name="type" type="MethodType"/>
                    </params>
                    <comment line="637">
                        stack walk magic: do not refactor                        
                    </comment>
                    <declaration name="method" type="MemberName" line="635"/>
                </method>
                <method name="resolveVirtual" type="MethodHandle" line="639">
                    <params>
                        <param name="refc" type="Class<?>"/>
                        <param name="name" type="String"/>
                        <param name="type" type="MethodType"/>
                    </params>
                    <declaration name="method" type="MemberName" line="640"/>
                </method>
                <method name="accessVirtual" type="MethodHandle" line="643">
                    <params>
                        <param name="refc" type="Class<?>"/>
                        <param name="method" type="MemberName"/>
                    </params>
                    <declaration name="mh" type="MethodHandle" line="645"/>
                </method>
                <javadoc line="649">
                    Produces a method handle which creates an object and initializes it, using
                      the constructor of the specified type.
                      The parameter types of the method handle will be those of the constructor,
                      while the return type will be a reference to the constructor&apos;s class.
                      The constructor and all its argument types must be accessible to the lookup class.
                      If the constructor&apos;s class has not yet been initialized, that is done
                      immediately, before the method handle is returned.
                      &lt;p&gt;
                      Note:  The requested type must have a return type of {@code void}.
                      This is consistent with the JVM&apos;s treatment of constructor type descriptors.
                      &lt;p&gt;
                      The returned method handle will have{@linkplain MethodHandle#asVarargsCollector variable arity} if and only if
                      the constructor&apos;s variable arity modifier bit ({@code 0x0080}) is set.                    
                    <param>
                        refc the class or interface from which the method is accessed                        
                    </param>
                    <param>
                        type the type of the method, with the receiver argument omitted, and a void return type                        
                    </param>
                    <return>
                        the desired method handle                        
                    </return>
                    <throws>
                        NoSuchMethodException if the constructor does not exist                        
                    </throws>
                    <throws>
                        IllegalAccessException if access checking fails
                          or if the method&apos;s variable arity modifier bit
                          is set and {@code asVarargsCollector} fails                        
                    </throws>
                    <exception>
                        SecurityException if a security manager is present and it
                          &lt;a href=&quot;MethodHandles.Lookup.html#secmgr&quot;&gt;refuses access&lt;/a&gt;                        
                    </exception>
                    <throws>
                        NullPointerException if any argument is null                        
                    </throws>
                </javadoc>
                <method name="findConstructor" type="MethodHandle" line="675">
                    <params>
                        <param name="refc" type="Class<?>"/>
                        <param name="type" type="MethodType"/>
                    </params>
                    <comment line="679">
                        stack walk magic: do not refactor                        
                    </comment>
                    <declaration name="name" type="String" line="676"/>
                    <declaration name="ctor" type="MemberName" line="677"/>
                </method>
                <method name="accessConstructor" type="MethodHandle" line="681">
                    <params>
                        <param name="refc" type="Class<?>"/>
                        <param name="ctor" type="MemberName"/>
                    </params>
                    <declaration name="rawMH" type="MethodHandle" line="684"/>
                    <declaration name="allocMH" type="MethodHandle" line="685"/>
                </method>
                <method name="resolveConstructor" type="MethodHandle" line="688">
                    <params>
                        <param name="refc" type="Class<?>"/>
                        <param name="type" type="MethodType"/>
                    </params>
                    <declaration name="name" type="String" line="689"/>
                    <declaration name="ctor" type="MemberName" line="690"/>
                </method>
                <javadoc line="694">
                    Return a version of MH which matches matchMH w.r.t. isVarargsCollector.                    
                </javadoc>
                <method name="fixVarargs" type="MethodHandle" line="695">
                    <params>
                        <param name="mh" type="MethodHandle"/>
                        <param name="matchMH" type="MethodHandle"/>
                    </params>
                    <declaration name="va1" type="boolean" line="696"/>
                    <declaration name="va2" type="boolean" line="697"/>
                    <scope line="698"/>
                    <scope line="700">
                        <declaration name="type" type="MethodType" line="701"/>
                        <declaration name="arity" type="int" line="702"/>
                    </scope>
                    <scope line="704"/>
                </method>
                <javadoc line="709">
                    Produces an early-bound method handle for a virtual method,
                      as if called from an {@code invokespecial}instruction from {@code caller}.
                      The type of the method handle will be that of the method,
                      with a suitably restricted receiver type (such as {@code caller}) prepended.
                      The method and all its argument types must be accessible
                      to the caller.
                      &lt;p&gt;
                      When called, the handle will treat the first argument as a receiver,
                      but will not dispatch on the receiver&apos;s type.
                      (This direct invocation action is identical with that performed by an{@code invokespecial} instruction.)
                      &lt;p&gt;
                      If the explicitly specified caller class is not identical with the
                      lookup class, or if this lookup object does not have private access
                      privileges, the access fails.
                      &lt;p&gt;
                      The returned method handle will have{@linkplain MethodHandle#asVarargsCollector variable arity} if and only if
                      the method&apos;s variable arity modifier bit ({@code 0x0080}) is set.                    
                    <param>
                        refc the class or interface from which the method is accessed                        
                    </param>
                    <param>
                        name the name of the method (which must not be &quot;&amp;lt;init&amp;gt;&quot;)                        
                    </param>
                    <param>
                        type the type of the method, with the receiver argument omitted                        
                    </param>
                    <param>
                        specialCaller the proposed calling class to perform the {@code invokespecial}                        
                    </param>
                    <return>
                        the desired method handle                        
                    </return>
                    <throws>
                        NoSuchMethodException if the method does not exist                        
                    </throws>
                    <throws>
                        IllegalAccessException if access checking fails
                          or if the method&apos;s variable arity modifier bit
                          is set and {@code asVarargsCollector} fails                        
                    </throws>
                    <exception>
                        SecurityException if a security manager is present and it
                          &lt;a href=&quot;MethodHandles.Lookup.html#secmgr&quot;&gt;refuses access&lt;/a&gt;                        
                    </exception>
                    <throws>
                        NullPointerException if any argument is null                        
                    </throws>
                </javadoc>
                <method name="findSpecial" type="MethodHandle" line="744">
                    <params>
                        <param name="refc" type="Class<?>"/>
                        <param name="name" type="String"/>
                        <param name="type" type="MethodType"/>
                        <param name="specialCaller" type="Class<?>"/>
                    </params>
                    <comment line="748">
                        stack walk magic: do not refactor                        
                    </comment>
                    <declaration name="method" type="MemberName" line="746"/>
                </method>
                <method name="accessSpecial" type="MethodHandle" line="751">
                    <params>
                        <param name="refc" type="Class<?>"/>
                        <param name="method" type="MemberName"/>
                        <param name="specialCaller" type="Class<?>"/>
                    </params>
                    <declaration name="mh" type="MethodHandle" line="753"/>
                </method>
                <method name="resolveSpecial" type="MethodHandle" line="756">
                    <params>
                        <param name="refc" type="Class<?>"/>
                        <param name="name" type="String"/>
                        <param name="type" type="MethodType"/>
                    </params>
                    <declaration name="specialCaller" type="Class&lt;?&gt;" line="757"/>
                    <declaration name="method" type="MemberName" line="759"/>
                </method>
                <javadoc line="763">
                    Produces a method handle giving read access to a non-static field.
                      The type of the method handle will have a return type of the field&apos;s
                      value type.
                      The method handle&apos;s single argument will be the instance containing
                      the field.
                      Access checking is performed immediately on behalf of the lookup class.                    
                    <param>
                        refc the class or interface from which the method is accessed                        
                    </param>
                    <param>
                        name the field&apos;s name                        
                    </param>
                    <param>
                        type the field&apos;s type                        
                    </param>
                    <return>
                        a method handle which can load values from the field                        
                    </return>
                    <throws>
                        NoSuchFieldException if the field does not exist                        
                    </throws>
                    <throws>
                        IllegalAccessException if access checking fails, or if the field is {@code static}                        
                    </throws>
                    <exception>
                        SecurityException if a security manager is present and it
                          &lt;a href=&quot;MethodHandles.Lookup.html#secmgr&quot;&gt;refuses access&lt;/a&gt;                        
                    </exception>
                    <throws>
                        NullPointerException if any argument is null                        
                    </throws>
                </javadoc>
                <method name="findGetter" type="MethodHandle" line="780">
                    <params>
                        <param name="refc" type="Class<?>"/>
                        <param name="name" type="String"/>
                        <param name="type" type="Class<?>"/>
                    </params>
                    <comment line="783">
                        stack walk magic: do not refactor                        
                    </comment>
                    <declaration name="field" type="MemberName" line="781"/>
                </method>
                <method name="resolveGetter" type="MethodHandle" line="785">
                    <params>
                        <param name="refc" type="Class<?>"/>
                        <param name="name" type="String"/>
                        <param name="type" type="Class<?>"/>
                    </params>
                    <declaration name="field" type="MemberName" line="786"/>
                </method>
                <javadoc line="790">
                    Produces a method handle giving write access to a non-static field.
                      The type of the method handle will have a void return type.
                      The method handle will take two arguments, the instance containing
                      the field, and the value to be stored.
                      The second argument will be of the field&apos;s value type.
                      Access checking is performed immediately on behalf of the lookup class.                    
                    <param>
                        refc the class or interface from which the method is accessed                        
                    </param>
                    <param>
                        name the field&apos;s name                        
                    </param>
                    <param>
                        type the field&apos;s type                        
                    </param>
                    <return>
                        a method handle which can store values into the field                        
                    </return>
                    <throws>
                        NoSuchFieldException if the field does not exist                        
                    </throws>
                    <throws>
                        IllegalAccessException if access checking fails, or if the field is {@code static}                        
                    </throws>
                    <exception>
                        SecurityException if a security manager is present and it
                          &lt;a href=&quot;MethodHandles.Lookup.html#secmgr&quot;&gt;refuses access&lt;/a&gt;                        
                    </exception>
                    <throws>
                        NullPointerException if any argument is null                        
                    </throws>
                </javadoc>
                <method name="findSetter" type="MethodHandle" line="807">
                    <params>
                        <param name="refc" type="Class<?>"/>
                        <param name="name" type="String"/>
                        <param name="type" type="Class<?>"/>
                    </params>
                    <comment line="810">
                        stack walk magic: do not refactor                        
                    </comment>
                    <declaration name="field" type="MemberName" line="808"/>
                </method>
                <method name="resolveSetter" type="MethodHandle" line="812">
                    <params>
                        <param name="refc" type="Class<?>"/>
                        <param name="name" type="String"/>
                        <param name="type" type="Class<?>"/>
                    </params>
                    <declaration name="field" type="MemberName" line="813"/>
                </method>
                <javadoc line="817">
                    Produces a method handle giving read access to a static field.
                      The type of the method handle will have a return type of the field&apos;s
                      value type.
                      The method handle will take no arguments.
                      Access checking is performed immediately on behalf of the lookup class.                    
                    <param>
                        refc the class or interface from which the method is accessed                        
                    </param>
                    <param>
                        name the field&apos;s name                        
                    </param>
                    <param>
                        type the field&apos;s type                        
                    </param>
                    <return>
                        a method handle which can load values from the field                        
                    </return>
                    <throws>
                        NoSuchFieldException if the field does not exist                        
                    </throws>
                    <throws>
                        IllegalAccessException if access checking fails, or if the field is not {@code static}                        
                    </throws>
                    <exception>
                        SecurityException if a security manager is present and it
                          &lt;a href=&quot;MethodHandles.Lookup.html#secmgr&quot;&gt;refuses access&lt;/a&gt;                        
                    </exception>
                    <throws>
                        NullPointerException if any argument is null                        
                    </throws>
                </javadoc>
                <method name="findStaticGetter" type="MethodHandle" line="833">
                    <params>
                        <param name="refc" type="Class<?>"/>
                        <param name="name" type="String"/>
                        <param name="type" type="Class<?>"/>
                    </params>
                    <comment line="836">
                        stack walk magic: do not refactor                        
                    </comment>
                    <declaration name="field" type="MemberName" line="834"/>
                </method>
                <method name="resolveStaticGetter" type="MethodHandle" line="838">
                    <params>
                        <param name="refc" type="Class<?>"/>
                        <param name="name" type="String"/>
                        <param name="type" type="Class<?>"/>
                    </params>
                    <declaration name="field" type="MemberName" line="839"/>
                </method>
                <javadoc line="843">
                    Produces a method handle giving write access to a static field.
                      The type of the method handle will have a void return type.
                      The method handle will take a single
                      argument, of the field&apos;s value type, the value to be stored.
                      Access checking is performed immediately on behalf of the lookup class.                    
                    <param>
                        refc the class or interface from which the method is accessed                        
                    </param>
                    <param>
                        name the field&apos;s name                        
                    </param>
                    <param>
                        type the field&apos;s type                        
                    </param>
                    <return>
                        a method handle which can store values into the field                        
                    </return>
                    <throws>
                        NoSuchFieldException if the field does not exist                        
                    </throws>
                    <throws>
                        IllegalAccessException if access checking fails, or if the field is not {@code static}                        
                    </throws>
                    <exception>
                        SecurityException if a security manager is present and it
                          &lt;a href=&quot;MethodHandles.Lookup.html#secmgr&quot;&gt;refuses access&lt;/a&gt;                        
                    </exception>
                    <throws>
                        NullPointerException if any argument is null                        
                    </throws>
                </javadoc>
                <method name="findStaticSetter" type="MethodHandle" line="859">
                    <params>
                        <param name="refc" type="Class<?>"/>
                        <param name="name" type="String"/>
                        <param name="type" type="Class<?>"/>
                    </params>
                    <comment line="862">
                        stack walk magic: do not refactor                        
                    </comment>
                    <declaration name="field" type="MemberName" line="860"/>
                </method>
                <method name="resolveStaticSetter" type="MethodHandle" line="864">
                    <params>
                        <param name="refc" type="Class<?>"/>
                        <param name="name" type="String"/>
                        <param name="type" type="Class<?>"/>
                    </params>
                    <declaration name="field" type="MemberName" line="865"/>
                </method>
                <javadoc line="869">
                    Produces an early-bound method handle for a non-static method.
                      The receiver must have a supertype {@code defc} in which a method
                      of the given name and type is accessible to the lookup class.
                      The method and all its argument types must be accessible to the lookup class.
                      The type of the method handle will be that of the method,
                      without any insertion of an additional receiver parameter.
                      The given receiver will be bound into the method handle,
                      so that every call to the method handle will invoke the
                      requested method on the given receiver.
                      &lt;p&gt;
                      The returned method handle will have{@linkplain MethodHandle#asVarargsCollector variable arity} if and only if
                      the method&apos;s variable arity modifier bit ({@code 0x0080}) is set
                      &lt;em&gt;and&lt;/em&gt; the trailing array argument is not the only argument.
                      (If the trailing array argument is the only argument,
                      the given receiver value will be bound to it.)
                      &lt;p&gt;
                      This is equivalent to the following code:
                      &lt;blockquote&gt;&lt;pre&gt;
                      import static java.lang.invoke.MethodHandles.;
                      import static java.lang.invoke.MethodType.;
                      ...
                      MethodHandle mh0 = lookup().{@link #findVirtual findVirtual}(defc, name, type);
                      MethodHandle mh1 = mh0.{@link MethodHandle#bindTo bindTo}(receiver);
                      MethodType mt1 = mh1.type();
                      if (mh0.isVarargsCollector())
                      mh1 = mh1.asVarargsCollector(mt1.parameterType(mt1.parameterCount()-1));
                      return mh1;
                      &lt;/pre&gt;&lt;/blockquote&gt;
                      where {@code defc} is either {@code receiver.getClass()} or a super
                      type of that class, in which the requested method is accessible
                      to the lookup class.
                      (Note that {@code bindTo} does not preserve variable arity.)                    
                    <param>
                        receiver the object from which the method is accessed                        
                    </param>
                    <param>
                        name the name of the method                        
                    </param>
                    <param>
                        type the type of the method, with the receiver argument omitted                        
                    </param>
                    <return>
                        the desired method handle                        
                    </return>
                    <throws>
                        NoSuchMethodException if the method does not exist                        
                    </throws>
                    <throws>
                        IllegalAccessException if access checking fails
                          or if the method&apos;s variable arity modifier bit
                          is set and {@code asVarargsCollector} fails                        
                    </throws>
                    <exception>
                        SecurityException if a security manager is present and it
                          &lt;a href=&quot;MethodHandles.Lookup.html#secmgr&quot;&gt;refuses access&lt;/a&gt;                        
                    </exception>
                    <throws>
                        NullPointerException if any argument is null                        
                    </throws>
                </javadoc>
                <method name="bind" type="MethodHandle" line="915">
                    <params>
                        <param name="receiver" type="Object"/>
                        <param name="name" type="String"/>
                        <param name="type" type="MethodType"/>
                    </params>
                    <comment line="917">
                        may get NPE                        
                    </comment>
                    <comment line="919">
                        stack walk magic: do not refactor                        
                    </comment>
                    <declaration name="refc" type="Class&lt;? extends Object&gt;" line="916"/>
                    <declaration name="method" type="MemberName" line="917"/>
                    <declaration name="dmh" type="MethodHandle" line="920"/>
                    <declaration name="bmh" type="MethodHandle" line="921"/>
                </method>
                <javadoc line="927">
                    Makes a direct method handle to &lt;i&gt;m&lt;/i&gt;, if the lookup class has permission.
                      If &lt;i&gt;m&lt;/i&gt; is non-static, the receiver argument is treated as an initial argument.
                      If &lt;i&gt;m&lt;/i&gt; is virtual, overriding is respected on every call.
                      Unlike the Core Reflection API, exceptions are &lt;em&gt;not&lt;/em&gt; wrapped.
                      The type of the method handle will be that of the method,
                      with the receiver type prepended (but only if it is non-static).
                      If the method&apos;s {@code accessible} flag is not set,
                      access checking is performed immediately on behalf of the lookup class.
                      If &lt;i&gt;m&lt;/i&gt; is not public, do not share the resulting handle with untrusted parties.
                      &lt;p&gt;
                      The returned method handle will have{@linkplain MethodHandle#asVarargsCollector variable arity} if and only if
                      the method&apos;s variable arity modifier bit ({@code 0x0080}) is set.                    
                    <param>
                        m the reflected method                        
                    </param>
                    <return>
                        a method handle which can invoke the reflected method                        
                    </return>
                    <throws>
                        IllegalAccessException if access checking fails
                          or if the method&apos;s variable arity modifier bit
                          is set and {@code asVarargsCollector} fails                        
                    </throws>
                    <throws>
                        NullPointerException if the argument is null                        
                    </throws>
                </javadoc>
                <method name="unreflect" type="MethodHandle" line="948">
                    <params>
                        <param name="m" type="Method"/>
                    </params>
                    <declaration name="method" type="MemberName" line="949"/>
                    <declaration name="mh" type="MethodHandle" line="952"/>
                </method>
                <javadoc line="957">
                    Produces a method handle for a reflected method.
                      It will bypass checks for overriding methods on the receiver,
                      as if by a {@code invokespecial} instruction from within the {@code specialCaller}.
                      The type of the method handle will be that of the method,
                      with the special caller type prepended (and &lt;em&gt;not&lt;/em&gt; the receiver of the method).
                      If the method&apos;s {@code accessible} flag is not set,
                      access checking is performed immediately on behalf of the lookup class,
                      as if {@code invokespecial} instruction were being linked.
                      &lt;p&gt;
                      The returned method handle will have{@linkplain MethodHandle#asVarargsCollector variable arity} if and only if
                      the method&apos;s variable arity modifier bit ({@code 0x0080}) is set.                    
                    <param>
                        m the reflected method                        
                    </param>
                    <param>
                        specialCaller the class nominally calling the method                        
                    </param>
                    <return>
                        a method handle which can invoke the reflected method                        
                    </return>
                    <throws>
                        IllegalAccessException if access checking fails
                          or if the method&apos;s variable arity modifier bit
                          is set and {@code asVarargsCollector} fails                        
                    </throws>
                    <throws>
                        NullPointerException if any argument is null                        
                    </throws>
                </javadoc>
                <method name="unreflectSpecial" type="MethodHandle" line="978">
                    <params>
                        <param name="m" type="Method"/>
                        <param name="specialCaller" type="Class<?>"/>
                    </params>
                    <comment line="983">
                        ignore m.isAccessible:  this is a new kind of access                        
                    </comment>
                    <declaration name="method" type="MemberName" line="980"/>
                    <declaration name="mh" type="MethodHandle" line="984"/>
                </method>
                <javadoc line="988">
                    Produces a method handle for a reflected constructor.
                      The type of the method handle will be that of the constructor,
                      with the return type changed to the declaring class.
                      The method handle will perform a {@code newInstance} operation,
                      creating a new instance of the constructor&apos;s class on the
                      arguments passed to the method handle.
                      &lt;p&gt;
                      If the constructor&apos;s {@code accessible} flag is not set,
                      access checking is performed immediately on behalf of the lookup class.
                      &lt;p&gt;
                      The returned method handle will have{@linkplain MethodHandle#asVarargsCollector variable arity} if and only if
                      the constructor&apos;s variable arity modifier bit ({@code 0x0080}) is set.                    
                    <param>
                        c the reflected constructor                        
                    </param>
                    <return>
                        a method handle which can invoke the reflected constructor                        
                    </return>
                    <throws>
                        IllegalAccessException if access checking fails
                          or if the method&apos;s variable arity modifier bit
                          is set and {@code asVarargsCollector} fails                        
                    </throws>
                    <throws>
                        NullPointerException if the argument is null                        
                    </throws>
                </javadoc>
                <method name="unreflectConstructor" type="MethodHandle" line="1009">
                    <params>
                        <param name="c" type="Constructor"/>
                    </params>
                    <declaration name="ctor" type="MemberName" line="1010"/>
                    <declaration name="rawCtor" type="MethodHandle" line="1013"/>
                    <declaration name="allocator" type="MethodHandle" line="1014"/>
                </method>
                <javadoc line="1018">
                    Produces a method handle giving read access to a reflected field.
                      The type of the method handle will have a return type of the field&apos;s
                      value type.
                      If the field is static, the method handle will take no arguments.
                      Otherwise, its single argument will be the instance containing
                      the field.
                      If the field&apos;s {@code accessible} flag is not set,
                      access checking is performed immediately on behalf of the lookup class.                    
                    <param>
                        f the reflected field                        
                    </param>
                    <return>
                        a method handle which can load values from the reflected field                        
                    </return>
                    <throws>
                        IllegalAccessException if access checking fails                        
                    </throws>
                    <throws>
                        NullPointerException if the argument is null                        
                    </throws>
                </javadoc>
                <method name="unreflectGetter" type="MethodHandle" line="1032">
                    <params>
                        <param name="f" type="Field"/>
                    </params>
                </method>
                <javadoc line="1036">
                    Produces a method handle giving write access to a reflected field.
                      The type of the method handle will have a void return type.
                      If the field is static, the method handle will take a single
                      argument, of the field&apos;s value type, the value to be stored.
                      Otherwise, the two arguments will be the instance containing
                      the field, and the value to be stored.
                      If the field&apos;s {@code accessible} flag is not set,
                      access checking is performed immediately on behalf of the lookup class.                    
                    <param>
                        f the reflected field                        
                    </param>
                    <return>
                        a method handle which can store values into the reflected field                        
                    </return>
                    <throws>
                        IllegalAccessException if access checking fails                        
                    </throws>
                    <throws>
                        NullPointerException if the argument is null                        
                    </throws>
                </javadoc>
                <method name="unreflectSetter" type="MethodHandle" line="1050">
                    <params>
                        <param name="f" type="Field"/>
                    </params>
                </method>
                <method name="resolveOrFail" type="MemberName" line="1056">
                    <params>
                        <param name="refc" type="Class<?>"/>
                        <param name="name" type="String"/>
                        <param name="type" type="Class<?>"/>
                        <param name="isStatic" type="boolean"/>
                    </params>
                    <comment line="1058">
                        do this before attempting to resolve                        
                    </comment>
                    <comment line="1059">
                        NPE                        
                    </comment>
                    <declaration name="mods" type="int" line="1059"/>
                </method>
                <method name="resolveOrFail" type="MemberName" line="1064">
                    <params>
                        <param name="refc" type="Class<?>"/>
                        <param name="name" type="String"/>
                        <param name="type" type="MethodType"/>
                        <param name="isStatic" type="boolean"/>
                    </params>
                    <comment line="1066">
                        do this before attempting to resolve                        
                    </comment>
                    <comment line="1067">
                        NPE                        
                    </comment>
                    <declaration name="mods" type="int" line="1067"/>
                </method>
                <method name="resolveOrFail" type="MemberName" line="1073">
                    <params>
                        <param name="refc" type="Class<?>"/>
                        <param name="name" type="String"/>
                        <param name="type" type="MethodType"/>
                        <param name="isStatic" type="boolean"/>
                        <param name="searchSupers" type="boolean"/>
                        <param name="specialCaller" type="Class<?>"/>
                    </params>
                    <comment line="1075">
                        do this before attempting to resolve                        
                    </comment>
                    <comment line="1076">
                        NPE                        
                    </comment>
                    <declaration name="mods" type="int" line="1076"/>
                </method>
                <method name="checkSymbolicClass" type="void" line="1081">
                    <params>
                        <param name="refc" type="Class<?>"/>
                    </params>
                    <declaration name="caller" type="Class&lt;?&gt;" line="1082"/>
                </method>
                <javadoc line="1087">
                    Perform necessary &lt;a href=&quot;MethodHandles.Lookup.html#secmgr&quot;&gt;access checks&lt;/a&gt;.
                      This function performs stack walk magic: do not refactor it.                    
                </javadoc>
                <method name="checkSecurityManager" type="void" line="1091">
                    <params>
                        <param name="refc" type="Class<?>"/>
                        <param name="m" type="MemberName"/>
                    </params>
                    <comment line="1096">
                        Step 1:                        
                    </comment>
                    <comment line="1098">
                        Step 2:                        
                    </comment>
                    <comment line="1101">
                        Step 3:                        
                    </comment>
                    <comment line="1104">
                        STACK WALK HERE                        
                    </comment>
                    <comment line="1105">
                        Step 4:                        
                    </comment>
                    <comment line="1109">
                        Comment from SM.checkMemberAccess, where which=DECLARED:                        
                    </comment>
                    <comment line="1110">
                        stack depth of 4 should be the caller of one of the
                         methods in java.lang.Class that invoke checkMember
                         access. The stack should look like:
                        
                         someCaller                        [3]
                         java.lang.Class.someReflectionAPI [2]
                         java.lang.Class.checkMemberAccess [1]
                         SecurityManager.checkMemberAccess [0]                        
                    </comment>
                    <comment line="1121">
                        For us it is this stack:
                         someCaller                        [3]
                         Lookup.findSomeMember             [2]
                         Lookup.checkSecurityManager       [1]
                         SecurityManager.checkMemberAccess [0]                        
                    </comment>
                    <declaration name="smgr" type="SecurityManager" line="1092"/>
                    <declaration name="defc" type="Class&lt;?&gt;" line="1102"/>
                </method>
                <method name="checkMethod" type="void" line="1127">
                    <params>
                        <param name="refc" type="Class<?>"/>
                        <param name="m" type="MemberName"/>
                        <param name="wantStatic" type="boolean"/>
                    </params>
                    <declaration name="message" type="String" line="1128"/>
                    <scope line="1136"/>
                </method>
                <method name="checkAccess" type="void" line="1140">
                    <params>
                        <param name="refc" type="Class<?>"/>
                        <param name="m" type="MemberName"/>
                    </params>
                    <comment line="1146">
                        common case                        
                    </comment>
                    <comment line="1147">
                        adjust 0 =&gt; PACKAGE                        
                    </comment>
                    <comment line="1154">
                        Protected members can also be checked as if they were package-private.                        
                    </comment>
                    <declaration name="allowedModes" type="int" line="1141"/>
                    <declaration name="mods" type="int" line="1143"/>
                    <declaration name="requestedModes" type="int" line="1146"/>
                </method>
                <method name="accessFailedMessage" type="String" line="1158">
                    <params>
                        <param name="refc" type="Class<?>"/>
                        <param name="m" type="MemberName"/>
                    </params>
                    <comment line="1162">
                        check the class first:                        
                    </comment>
                    <comment line="1174">
                        (how?)                        
                    </comment>
                    <declaration name="defc" type="Class&lt;?&gt;" line="1159"/>
                    <declaration name="mods" type="int" line="1160"/>
                    <declaration name="classOK" type="boolean" line="1162"/>
                    <scope line="1165"/>
                </method>
                <declaration name="ALLOW_NESTMATE_ACCESS" type="boolean" line="1181"/>
                <method name="checkSpecialCaller" type="void" line="1183">
                    <params>
                        <param name="specialCaller" type="Class<?>"/>
                    </params>
                </method>
                <method name="restrictProtectedReceiver" type="MethodHandle" line="1193">
                    <params>
                        <param name="method" type="MemberName"/>
                        <param name="mh" type="MethodHandle"/>
                    </params>
                    <comment line="1195">
                        The accessing class only has the right to use a protected member
                         on itself or a subclass.  Enforce that restriction, from JVMS 5.4.4, etc.                        
                    </comment>
                </method>
                <method name="restrictReceiver" type="MethodHandle" line="1206">
                    <params>
                        <param name="method" type="MemberName"/>
                        <param name="mh" type="MethodHandle"/>
                        <param name="caller" type="Class<?>"/>
                    </params>
                    <comment line="1209">
                        receiver type of mh is too wide                        
                    </comment>
                    <declaration name="defc" type="Class&lt;?&gt;" line="1208"/>
                    <scope line="1209"/>
                    <declaration name="rawType" type="MethodType" line="1212"/>
                    <declaration name="narrowType" type="MethodType" line="1214"/>
                    <declaration name="narrowMH" type="MethodHandle" line="1215"/>
                </method>
                <method name="makeAccessor" type="MethodHandle" line="1221">
                    <params>
                        <param name="refc" type="Class<?>"/>
                        <param name="field" type="MemberName"/>
                        <param name="trusted" type="boolean"/>
                        <param name="isSetter" type="boolean"/>
                        <param name="checkStatic" type="int"/>
                    </params>
                    <declaration name="mh" type="MethodHandle" line="1230"/>
                </method>
                <javadoc line="1234">
                    Hook called from the JVM (via MethodHandleNatives) to link MH constants:                    
                </javadoc>
                <method name="linkMethodHandleConstant" type="MethodHandle" line="1237">
                    <params>
                        <param name="refKind" type="int"/>
                        <param name="defc" type="Class<?>"/>
                        <param name="name" type="String"/>
                        <param name="type" type="Object"/>
                    </params>
                    <comment line="1237">
                                                
                    </comment>
                    <comment line="1250">
                        oops                        
                    </comment>
                </method>
            </class>
            <javadoc line="1254">
                Produces a method handle giving read access to elements of an array.
                  The type of the method handle will have a return type of the array&apos;s
                  element type.  Its first argument will be the array type,
                  and the second will be {@code int}.                
                <param>
                    arrayClass an array type                    
                </param>
                <return>
                    a method handle which can load values from the given array type                    
                </return>
                <throws>
                    NullPointerException if the argument is null                    
                </throws>
                <throws>
                    IllegalArgumentException if arrayClass is not an array type                    
                </throws>
            </javadoc>
            <method name="arrayElementGetter" type="MethodHandle" line="1265">
                <params>
                    <param name="arrayClass" type="Class<?>"/>
                </params>
            </method>
            <javadoc line="1269">
                Produces a method handle giving write access to elements of an array.
                  The type of the method handle will have a void return type.
                  Its last argument will be the array&apos;s element type.
                  The first and second arguments will be the array type and int.                
                <return>
                    a method handle which can store values into the array type                    
                </return>
                <throws>
                    NullPointerException if the argument is null                    
                </throws>
                <throws>
                    IllegalArgumentException if arrayClass is not an array type                    
                </throws>
            </javadoc>
            <method name="arrayElementSetter" type="MethodHandle" line="1279">
                <params>
                    <param name="arrayClass" type="Class<?>"/>
                </params>
            </method>
            <javadoc line="1285">
                Produces a method handle which will invoke any method handle of the
                  given {@code type}, with a given number of trailing arguments replaced by
                  a single trailing {@code Object[]} array.
                  The resulting invoker will be a method handle with the following
                  arguments:
                  &lt;ul&gt;
                  &lt;li&gt;a single {@code MethodHandle} target
                  &lt;li&gt;zero or more leading values (counted by {@code leadingArgCount})
                  &lt;li&gt;an {@code Object[]} array containing trailing arguments
                  &lt;/ul&gt;
                  &lt;p&gt;
                  The invoker will invoke its target like a call to {@link MethodHandle#invoke invoke} with
                  the indicated {@code type}.
                  That is, if the target is exactly of the given {@code type}, it will behave
                  like {@code invokeExact}; otherwise it behave as if {@link MethodHandle#asType asType}is used to convert the target to the required {@code type}.
                  &lt;p&gt;
                  The type of the returned invoker will not be the given {@code type}, but rather
                  will have all parameters except the first {@code leadingArgCount}replaced by a single array of type {@code Object[]}, which will be
                  the final parameter.
                  &lt;p&gt;
                  Before invoking its target, the invoker will spread the final array, apply
                  reference casts as necessary, and unbox and widen primitive arguments.
                  &lt;p&gt;
                  This method is equivalent to the following code (though it may be more efficient):
                  &lt;p&gt;&lt;blockquote&gt;&lt;pre&gt;
                  MethodHandle invoker = MethodHandles.invoker(type);
                  int spreadArgCount = type.parameterCount() - leadingArgCount;
                  invoker = invoker.asSpreader(Object[].class, spreadArgCount);
                  return invoker;
                  &lt;/pre&gt;&lt;/blockquote&gt;
                  &lt;p&gt;
                  This method throws no reflective or security exceptions.                
                <param>
                    type the desired target type                    
                </param>
                <param>
                    leadingArgCount number of fixed arguments, to be passed unchanged to the target                    
                </param>
                <return>
                    a method handle suitable for invoking any method handle of the given type                    
                </return>
                <throws>
                    NullPointerException if {@code type} is null                    
                </throws>
                <throws>
                    IllegalArgumentException if {@code leadingArgCount} is not in
                      the range from 0 to {@code type.parameterCount()} inclusive                    
                </throws>
            </javadoc>
            <method name="spreadInvoker" type="MethodHandle" line="1328">
                <params>
                    <param name="type" type="MethodType"/>
                    <param name="leadingArgCount" type="int"/>
                </params>
            </method>
            <javadoc line="1334">
                Produces a special &lt;em&gt;invoker method handle&lt;/em&gt; which can be used to
                  invoke any method handle of the given type, as if by {@link MethodHandle#invokeExact invokeExact}.
                  The resulting invoker will have a type which is
                  exactly equal to the desired type, except that it will accept
                  an additional leading argument of type {@code MethodHandle}.
                  &lt;p&gt;
                  This method is equivalent to the following code (though it may be more efficient):
                  &lt;p&gt;&lt;blockquote&gt;&lt;pre&gt;
                  publicLookup().findVirtual(MethodHandle.class, &quot;invokeExact&quot;, type)
                  &lt;/pre&gt;&lt;/blockquote&gt;
                  &lt;p style=&quot;font-size:smaller;&quot;&gt;
                  &lt;em&gt;Discussion:&lt;/em&gt;
                  Invoker method handles can be useful when working with variable method handles
                  of unknown types.
                  For example, to emulate an {@code invokeExact} call to a variable method
                  handle {@code M}, extract its type {@code T},
                  look up the invoker method {@code X} for {@code T},
                  and call the invoker method, as {@code X.invoke(T, A...)}.
                  (It would not work to call {@code X.invokeExact}, since the type {@code T}is unknown.)
                  If spreading, collecting, or other argument transformations are required,
                  they can be applied once to the invoker {@code X} and reused on many {@code M}method handle values, as long as they are compatible with the type of {@code X}.
                  &lt;p&gt;
                  &lt;em&gt;(Note:  The invoker method is not available via the Core Reflection API.
                  An attempt to call {@linkplain java.lang.reflect.Method#invoke java.lang.reflect.Method.invoke}on the declared {@code invokeExact} or {@code invoke} method will raise an{@link java.lang.UnsupportedOperationException UnsupportedOperationException}.)&lt;/em&gt;
                  &lt;p&gt;
                  This method throws no reflective or security exceptions.                
                <param>
                    type the desired target type                    
                </param>
                <return>
                    a method handle suitable for invoking any method handle of the given type                    
                </return>
            </javadoc>
            <method name="exactInvoker" type="MethodHandle" line="1370">
                <params>
                    <param name="type" type="MethodType"/>
                </params>
            </method>
            <javadoc line="1374">
                Produces a special &lt;em&gt;invoker method handle&lt;/em&gt; which can be used to
                  invoke any method handle compatible with the given type, as if by {@link MethodHandle#invoke invoke}.
                  The resulting invoker will have a type which is
                  exactly equal to the desired type, except that it will accept
                  an additional leading argument of type {@code MethodHandle}.
                  &lt;p&gt;
                  Before invoking its target, if the target differs from the expected type,
                  the invoker will apply reference casts as
                  necessary and box, unbox, or widen primitive values, as if by {@link MethodHandle#asType asType}.
                  Similarly, the return value will be converted as necessary.
                  If the target is a {@linkplain MethodHandle#asVarargsCollector variable arity method handle},
                  the required arity conversion will be made, again as if by {@link MethodHandle#asType asType}.
                  &lt;p&gt;
                  A {@linkplain MethodType#genericMethodType general method type},
                  mentions only {@code Object} arguments and return values.
                  An invoker for such a type is capable of calling any method handle
                  of the same arity as the general type.
                  &lt;p&gt;
                  This method is equivalent to the following code (though it may be more efficient):
                  &lt;p&gt;&lt;blockquote&gt;&lt;pre&gt;
                  publicLookup().findVirtual(MethodHandle.class, &quot;invoke&quot;, type)
                  &lt;/pre&gt;&lt;/blockquote&gt;
                  &lt;p&gt;
                  This method throws no reflective or security exceptions.                
                <param>
                    type the desired target type                    
                </param>
                <return>
                    a method handle suitable for invoking any method handle convertible to the given type                    
                </return>
            </javadoc>
            <method name="invoker" type="MethodHandle" line="1403">
                <params>
                    <param name="type" type="MethodType"/>
                </params>
            </method>
            <javadoc line="1407">
                Perform value checking, exactly as if for an adapted method handle.
                  It is assumed that the given value is either null, of type T0,
                  or (if T0 is primitive) of the wrapper class corresponding to T0.
                  The following checks and conversions are made:
                  &lt;ul&gt;
                  &lt;li&gt;If T0 and T1 are references, then a cast to T1 is applied.
                  (The types do not need to be related in any particular way.)
                  &lt;li&gt;If T0 and T1 are primitives, then a widening or narrowing
                  conversion is applied, if one exists.
                  &lt;li&gt;If T0 is a primitive and T1 a reference, and
                  T0 has a wrapper class TW, a boxing conversion to TW is applied,
                  possibly followed by a reference conversion.
                  T1 must be TW or a supertype.
                  &lt;li&gt;If T0 is a reference and T1 a primitive, and
                  T1 has a wrapper class TW, an unboxing conversion is applied,
                  possibly preceded by a reference conversion.
                  T0 must be TW or a supertype.
                  &lt;li&gt;If T1 is void, the return value is discarded
                  &lt;li&gt;If T0 is void and T1 a reference, a null value is introduced.
                  &lt;li&gt;If T0 is void and T1 a primitive, a zero value is introduced.
                  &lt;/ul&gt;
                  If the value is discarded, null will be returned.                
                <param>
                    valueType                    
                </param>
                <param>
                    value                    
                </param>
                <return>
                    the value, converted if necessary                    
                </return>
                <throws>
                    java.lang.ClassCastException if a cast fails                    
                </throws>
            </javadoc>
            <method name="checkValue" type="T1" line="1439">
                <params>
                    <param name="t0" type="Class<T0>"/>
                    <param name="t1" type="Class<T1>"/>
                    <param name="value" type="Object"/>
                </params>
                <comment line="1436">
                    FIXME: This is used in just one place.  Refactor away.                    
                </comment>
                <comment line="1442">
                    no conversion needed; just reassert the same type                    
                </comment>
                <comment line="1450">
                    check contract with caller                    
                </comment>
                <comment line="1455">
                    convert reference to primitive by unboxing                    
                </comment>
                <comment line="1459">
                    check contract with caller:                    
                </comment>
                <scope line="1440"/>
                <declaration name="prim0" type="boolean" line="1447"/>
                <scope line="1448">
                    <scope line="1451"/>
                    <declaration name="w1" type="Wrapper" line="1455"/>
                </scope>
                <declaration name="w1" type="Wrapper" line="1460"/>
            </method>
            <method name="checkValue" type="Object" line="1469">
                <params>
                    <param name="T1" type="Class<?>"/>
                    <param name="value" type="Object"/>
                </params>
                <declaration name="T0" type="Class&lt;?&gt;" line="1470"/>
            </method>
            <javadoc line="1480">
                Produces a method handle which adapts the type of the
                  given method handle to a new type by pairwise argument and return type conversion.
                  The original type and new type must have the same number of arguments.
                  The resulting method handle is guaranteed to report a type
                  which is equal to the desired new type.
                  &lt;p&gt;
                  If the original type and new type are equal, returns target.
                  &lt;p&gt;
                  The same conversions are allowed as for {@link MethodHandle#asType MethodHandle.asType},
                  and some additional conversions are also applied if those conversions fail.
                  Given types &lt;em&gt;T0&lt;/em&gt;, &lt;em&gt;T1&lt;/em&gt;, one of the following conversions is applied
                  if possible, before or instead of any conversions done by {@code asType}:
                  &lt;ul&gt;
                  &lt;li&gt;If &lt;em&gt;T0&lt;/em&gt; and &lt;em&gt;T1&lt;/em&gt; are references, and &lt;em&gt;T1&lt;/em&gt; is an interface type,
                  then the value of type &lt;em&gt;T0&lt;/em&gt; is passed as a &lt;em&gt;T1&lt;/em&gt; without a cast.
                  (This treatment of interfaces follows the usage of the bytecode verifier.)
                  &lt;li&gt;If &lt;em&gt;T0&lt;/em&gt; is boolean and &lt;em&gt;T1&lt;/em&gt; is another primitive,
                  the boolean is converted to a byte value, 1 for true, 0 for false.
                  (This treatment follows the usage of the bytecode verifier.)
                  &lt;li&gt;If &lt;em&gt;T1&lt;/em&gt; is boolean and &lt;em&gt;T0&lt;/em&gt; is another primitive,
                  &lt;em&gt;T0&lt;/em&gt; is converted to byte via Java casting conversion (JLS 5.5),
                  and the low order bit of the result is tested, as if by {@code (x &amp; 1) != 0}.
                  &lt;li&gt;If &lt;em&gt;T0&lt;/em&gt; and &lt;em&gt;T1&lt;/em&gt; are primitives other than boolean,
                  then a Java casting conversion (JLS 5.5) is applied.
                  (Specifically, &lt;em&gt;T0&lt;/em&gt; will convert to &lt;em&gt;T1&lt;/em&gt; by
                  widening and/or narrowing.)
                  &lt;li&gt;If &lt;em&gt;T0&lt;/em&gt; is a reference and &lt;em&gt;T1&lt;/em&gt; a primitive, an unboxing
                  conversion will be applied at runtime, possibly followed
                  by a Java casting conversion (JLS 5.5) on the primitive value,
                  possibly followed by a conversion from byte to boolean by testing
                  the low-order bit.
                  &lt;li&gt;If &lt;em&gt;T0&lt;/em&gt; is a reference and &lt;em&gt;T1&lt;/em&gt; a primitive,
                  and if the reference is null at runtime, a zero value is introduced.
                  &lt;/ul&gt;                
                <param>
                    target the method handle to invoke after arguments are retyped                    
                </param>
                <param>
                    newType the expected type of the new method handle                    
                </param>
                <return>
                    a method handle which delegates to the target after performing
                      any necessary argument conversions, and arranges for any
                      necessary return value conversions                    
                </return>
                <throws>
                    NullPointerException if either argument is null                    
                </throws>
                <throws>
                    WrongMethodTypeException if the conversion cannot be made                    
                </throws>
                <see>
                    MethodHandle#asType                    
                </see>
            </javadoc>
            <method name="explicitCastArguments" type="MethodHandle" line="1525">
                <params>
                    <param name="target" type="MethodHandle"/>
                    <param name="newType" type="MethodType"/>
                </params>
            </method>
            <javadoc line="1529">
                Produces a method handle which adapts the calling sequence of the
                  given method handle to a new type, by reordering the arguments.
                  The resulting method handle is guaranteed to report a type
                  which is equal to the desired new type.
                  &lt;p&gt;
                  The given array controls the reordering.
                  Call {@code #I} the number of incoming parameters (the value{@code newType.parameterCount()}, and call {@code #O} the number
                  of outgoing parameters (the value {@code target.type().parameterCount()}).
                  Then the length of the reordering array must be {@code #O},
                  and each element must be a non-negative number less than {@code #I}.
                  For every {@code N} less than {@code #O}, the {@code N}-th
                  outgoing argument will be taken from the {@code I}-th incoming
                  argument, where {@code I} is {@code reorder[N]}.
                  &lt;p&gt;
                  No argument or return value conversions are applied.
                  The type of each incoming argument, as determined by {@code newType},
                  must be identical to the type of the corresponding outgoing parameter
                  or parameters in the target method handle.
                  The return type of {@code newType} must be identical to the return
                  type of the original target.
                  &lt;p&gt;
                  The reordering array need not specify an actual permutation.
                  An incoming argument will be duplicated if its index appears
                  more than once in the array, and an incoming argument will be dropped
                  if its index does not appear in the array.
                  As in the case of {@link #dropArguments(MethodHandle,int,List) dropArguments},
                  incoming arguments which are not mentioned in the reordering array
                  are may be any type, as determined only by {@code newType}.
                  &lt;blockquote&gt;&lt;pre&gt;
                  import static java.lang.invoke.MethodHandles.;
                  import static java.lang.invoke.MethodType.;
                  ...
                  MethodType intfn1 = methodType(int.class, int.class);
                  MethodType intfn2 = methodType(int.class, int.class, int.class);
                  MethodHandle sub = ... {int x, int y =&gt; x-y} ...;
                  assert(sub.type().equals(intfn2));
                  MethodHandle sub1 = permuteArguments(sub, intfn2, 0, 1);
                  MethodHandle rsub = permuteArguments(sub, intfn2, 1, 0);
                  assert((int)rsub.invokeExact(1, 100) == 99);
                  MethodHandle add = ... {int x, int y =&gt; x+y} ...;
                  assert(add.type().equals(intfn2));
                  MethodHandle twice = permuteArguments(add, intfn1, 0, 0);
                  assert(twice.type().equals(intfn1));
                  assert((int)twice.invokeExact(21) == 42);
                  &lt;/pre&gt;&lt;/blockquote&gt;                
                <param>
                    target the method handle to invoke after arguments are reordered                    
                </param>
                <param>
                    newType the expected type of the new method handle                    
                </param>
                <param>
                    reorder an index array which controls the reordering                    
                </param>
                <return>
                    a method handle which delegates to the target after it
                      drops unused arguments and moves and/or duplicates the other arguments                    
                </return>
                <throws>
                    NullPointerException if any argument is null                    
                </throws>
                <throws>
                    IllegalArgumentException if the index array length is not equal to
                      the arity of the target, or if any index array element
                      not a valid index for a parameter of {@code newType},
                      or if two corresponding parameter types in{@code target.type()} and {@code newType} are not identical,                    
                </throws>
            </javadoc>
            <method name="permuteArguments" type="MethodHandle" line="1589">
                <params>
                    <param name="target" type="MethodHandle"/>
                    <param name="newType" type="MethodType"/>
                    <param name="reorder" type="int"/>
                </params>
                <declaration name="oldType" type="MethodType" line="1590"/>
            </method>
            <method name="checkReorder" type="void" line="1597">
                <params>
                    <param name="reorder" type="int[]"/>
                    <param name="newType" type="MethodType"/>
                    <param name="oldType" type="MethodType"/>
                </params>
                <scope line="1601">
                    <declaration name="limit" type="int" line="1602"/>
                    <declaration name="bad" type="boolean" line="1603"/>
                    <scope line="1604">
                        <declaration name="i" type="int" line="1605"/>
                        <scope line="1606"/>
                        <declaration name="src" type="Class&lt;?&gt;" line="1609"/>
                        <declaration name="dst" type="Class&lt;?&gt;" line="1610"/>
                    </scope>
                </scope>
            </method>
            <javadoc line="1620">
                Produces a method handle of the requested return type which returns the given
                  constant value every time it is invoked.
                  &lt;p&gt;
                  Before the method handle is returned, the passed-in value is converted to the requested type.
                  If the requested type is primitive, widening primitive conversions are attempted,
                  else reference conversions are attempted.
                  &lt;p&gt;The returned method handle is equivalent to {@code identity(type).bindTo(value)}.                
                <param>
                    type the return type of the desired method handle                    
                </param>
                <param>
                    value the value to return                    
                </param>
                <return>
                    a method handle of the given return type and no arguments, which always returns the given value                    
                </return>
                <throws>
                    NullPointerException if the {@code type} argument is null                    
                </throws>
                <throws>
                    ClassCastException if the value cannot be converted to the required return type                    
                </throws>
                <throws>
                    IllegalArgumentException if the given type is {@code void.class}                    
                </throws>
            </javadoc>
            <method name="constant" type="MethodHandle" line="1636">
                <params>
                    <param name="type" type="Class<?>"/>
                    <param name="value" type="Object"/>
                </params>
                <scope line="1637">
                    <declaration name="w" type="Wrapper" line="1640"/>
                </scope>
                <scope line="1642"/>
            </method>
            <javadoc line="1647">
                Produces a method handle which returns its sole argument when invoked.                
                <param>
                    type the type of the sole parameter and return value of the desired method handle                    
                </param>
                <return>
                    a unary method handle which accepts and returns the given type                    
                </return>
                <throws>
                    NullPointerException if the argument is null                    
                </throws>
                <throws>
                    IllegalArgumentException if the given type is {@code void.class}                    
                </throws>
            </javadoc>
            <method name="identity" type="MethodHandle" line="1655">
                <params>
                    <param name="type" type="Class<?>"/>
                </params>
            </method>
            <javadoc line="1667">
                Provides a target method handle with one or more &lt;em&gt;bound arguments&lt;/em&gt;
                  in advance of the method handle&apos;s invocation.
                  The formal parameters to the target corresponding to the bound
                  arguments are called &lt;em&gt;bound parameters&lt;/em&gt;.
                  Returns a new method handle which saves away the bound arguments.
                  When it is invoked, it receives arguments for any non-bound parameters,
                  binds the saved arguments to their corresponding parameters,
                  and calls the original target.
                  &lt;p&gt;
                  The type of the new method handle will drop the types for the bound
                  parameters from the original target type, since the new method handle
                  will no longer require those arguments to be supplied by its callers.
                  &lt;p&gt;
                  Each given argument object must match the corresponding bound parameter type.
                  If a bound parameter type is a primitive, the argument object
                  must be a wrapper, and will be unboxed to produce the primitive value.
                  &lt;p&gt;
                  The {@code pos} argument selects which parameters are to be bound.
                  It may range between zero and &lt;i&gt;N-L&lt;/i&gt; (inclusively),
                  where &lt;i&gt;N&lt;/i&gt; is the arity of the target method handle
                  and &lt;i&gt;L&lt;/i&gt; is the length of the values array.                
                <param>
                    target the method handle to invoke after the argument is inserted                    
                </param>
                <param>
                    pos where to insert the argument (zero for the first)                    
                </param>
                <param>
                    values the series of arguments to insert                    
                </param>
                <return>
                    a method handle which inserts an additional argument,
                      before calling the original method handle                    
                </return>
                <throws>
                    NullPointerException if the target or the {@code values} array is null                    
                </throws>
                <see>
                    MethodHandle#bindTo                    
                </see>
            </javadoc>
            <method name="insertArguments" type="MethodHandle" line="1698">
                <params>
                    <param name="target" type="MethodHandle"/>
                    <param name="pos" type="int"/>
                    <param name="values" type="Object"/>
                </params>
                <comment line="1714">
                    At least for now, make bound method handles a special case.                    
                </comment>
                <comment line="1720">
                    else fall through to general adapter machinery                    
                </comment>
                <declaration name="insCount" type="int" line="1699"/>
                <declaration name="oldType" type="MethodType" line="1700"/>
                <declaration name="outargs" type="int" line="1701"/>
                <declaration name="inargs" type="int" line="1702"/>
                <declaration name="result" type="MethodHandle" line="1707"/>
                <scope line="1708">
                    <declaration name="value" type="Object" line="1709"/>
                    <declaration name="valueType" type="Class&lt;?&gt;" line="1710"/>
                    <scope line="1712">
                        <declaration name="bmh" type="MethodHandle" line="1714"/>
                        <scope line="1715"/>
                    </scope>
                </scope>
            </method>
            <javadoc line="1726">
                Produces a method handle which will discard some dummy arguments
                  before calling some other specified &lt;i&gt;target&lt;/i&gt; method handle.
                  The type of the new method handle will be the same as the target&apos;s type,
                  except it will also include the dummy argument types,
                  at some given position.
                  &lt;p&gt;
                  The {@code pos} argument may range between zero and &lt;i&gt;N&lt;/i&gt;,
                  where &lt;i&gt;N&lt;/i&gt; is the arity of the target.
                  If {@code pos} is zero, the dummy arguments will precede
                  the target&apos;s real arguments; if {@code pos} is &lt;i&gt;N&lt;/i&gt;
                  they will come after.
                  &lt;p&gt;
                  &lt;b&gt;Example:&lt;/b&gt;
                  &lt;p&gt;&lt;blockquote&gt;&lt;pre&gt;
                  import static java.lang.invoke.MethodHandles.;
                  import static java.lang.invoke.MethodType.;
                  ...
                  MethodHandle cat = lookup().findVirtual(String.class,
                  &quot;concat&quot;, methodType(String.class, String.class));
                  assertEquals(&quot;xy&quot;, (String) cat.invokeExact(&quot;x&quot;, &quot;y&quot;));
                  MethodType bigType = cat.type().insertParameterTypes(0, int.class, String.class);
                  MethodHandle d0 = dropArguments(cat, 0, bigType.parameterList().subList(0,2));
                  assertEquals(bigType, d0.type());
                  assertEquals(&quot;yz&quot;, (String) d0.invokeExact(123, &quot;x&quot;, &quot;y&quot;, &quot;z&quot;));
                  &lt;/pre&gt;&lt;/blockquote&gt;
                  &lt;p&gt;
                  This method is also equivalent to the following code:
                  &lt;p&gt;&lt;blockquote&gt;&lt;pre&gt;{@link #dropArguments(MethodHandle,int,Class...) dropArguments}(target, pos, valueTypes.toArray(new Class[0]))
                  &lt;/pre&gt;&lt;/blockquote&gt;                
                <param>
                    target the method handle to invoke after the arguments are dropped                    
                </param>
                <param>
                    valueTypes the type(s) of the argument(s) to drop                    
                </param>
                <param>
                    pos position of first argument to drop (zero for the leftmost)                    
                </param>
                <return>
                    a method handle which drops arguments of the given types,
                      before calling the original method handle                    
                </return>
                <throws>
                    NullPointerException if the target is null,
                      or if the {@code valueTypes} list or any of its elements is null                    
                </throws>
                <throws>
                    IllegalArgumentException if any element of {@code valueTypes} is {@code void.class},
                      or if {@code pos} is negative or greater than the arity of the target,
                      or if the new method handle&apos;s type would have too many parameters                    
                </throws>
            </javadoc>
            <method name="dropArguments" type="MethodHandle" line="1769">
                <params>
                    <param name="target" type="MethodHandle"/>
                    <param name="pos" type="int"/>
                    <param name="valueTypes" type="List<Class<?>>"/>
                </params>
                <comment line="1771">
                    get NPE                    
                </comment>
                <declaration name="oldType" type="MethodType" line="1770"/>
                <declaration name="outargs" type="int" line="1772"/>
                <declaration name="inargs" type="int" line="1773"/>
                <declaration name="ptypes" type="ArrayList&lt;Class&lt;?&gt;&gt;" line="1776"/>
                <declaration name="newType" type="MethodType" line="1779"/>
            </method>
            <javadoc line="1783">
                Produces a method handle which will discard some dummy arguments
                  before calling some other specified &lt;i&gt;target&lt;/i&gt; method handle.
                  The type of the new method handle will be the same as the target&apos;s type,
                  except it will also include the dummy argument types,
                  at some given position.
                  &lt;p&gt;
                  The {@code pos} argument may range between zero and &lt;i&gt;N&lt;/i&gt;,
                  where &lt;i&gt;N&lt;/i&gt; is the arity of the target.
                  If {@code pos} is zero, the dummy arguments will precede
                  the target&apos;s real arguments; if {@code pos} is &lt;i&gt;N&lt;/i&gt;
                  they will come after.
                  &lt;p&gt;
                  &lt;b&gt;Example:&lt;/b&gt;
                  &lt;p&gt;&lt;blockquote&gt;&lt;pre&gt;
                  import static java.lang.invoke.MethodHandles.;
                  import static java.lang.invoke.MethodType.;
                  ...
                  MethodHandle cat = lookup().findVirtual(String.class,
                  &quot;concat&quot;, methodType(String.class, String.class));
                  assertEquals(&quot;xy&quot;, (String) cat.invokeExact(&quot;x&quot;, &quot;y&quot;));
                  MethodHandle d0 = dropArguments(cat, 0, String.class);
                  assertEquals(&quot;yz&quot;, (String) d0.invokeExact(&quot;x&quot;, &quot;y&quot;, &quot;z&quot;));
                  MethodHandle d1 = dropArguments(cat, 1, String.class);
                  assertEquals(&quot;xz&quot;, (String) d1.invokeExact(&quot;x&quot;, &quot;y&quot;, &quot;z&quot;));
                  MethodHandle d2 = dropArguments(cat, 2, String.class);
                  assertEquals(&quot;xy&quot;, (String) d2.invokeExact(&quot;x&quot;, &quot;y&quot;, &quot;z&quot;));
                  MethodHandle d12 = dropArguments(cat, 1, int.class, boolean.class);
                  assertEquals(&quot;xz&quot;, (String) d12.invokeExact(&quot;x&quot;, 12, true, &quot;z&quot;));
                  &lt;/pre&gt;&lt;/blockquote&gt;
                  &lt;p&gt;
                  This method is also equivalent to the following code:
                  &lt;p&gt;&lt;blockquote&gt;&lt;pre&gt;{@link #dropArguments(MethodHandle,int,List) dropArguments}(target, pos, Arrays.asList(valueTypes))
                  &lt;/pre&gt;&lt;/blockquote&gt;                
                <param>
                    target the method handle to invoke after the arguments are dropped                    
                </param>
                <param>
                    valueTypes the type(s) of the argument(s) to drop                    
                </param>
                <param>
                    pos position of first argument to drop (zero for the leftmost)                    
                </param>
                <return>
                    a method handle which drops arguments of the given types,
                      before calling the original method handle                    
                </return>
                <throws>
                    NullPointerException if the target is null,
                      or if the {@code valueTypes} array or any of its elements is null                    
                </throws>
                <throws>
                    IllegalArgumentException if any element of {@code valueTypes} is {@code void.class},
                      or if {@code pos} is negative or greater than the arity of the target,
                      or if the new method handle&apos;s type would have too many parameters                    
                </throws>
            </javadoc>
            <method name="dropArguments" type="MethodHandle" line="1830">
                <params>
                    <param name="target" type="MethodHandle"/>
                    <param name="pos" type="int"/>
                    <param name="valueTypes" type="Class<?>"/>
                </params>
            </method>
            <javadoc line="1834">
                Adapts a target method handle by pre-processing
                  one or more of its arguments, each with its own unary filter function,
                  and then calling the target with each pre-processed argument
                  replaced by the result of its corresponding filter function.
                  &lt;p&gt;
                  The pre-processing is performed by one or more method handles,
                  specified in the elements of the {@code filters} array.
                  The first element of the filter array corresponds to the {@code pos}argument of the target, and so on in sequence.
                  &lt;p&gt;
                  Null arguments in the array are treated as identity functions,
                  and the corresponding arguments left unchanged.
                  (If there are no non-null elements in the array, the original target is returned.)
                  Each filter is applied to the corresponding argument of the adapter.
                  &lt;p&gt;
                  If a filter {@code F} applies to the {@code N}th argument of
                  the target, then {@code F} must be a method handle which
                  takes exactly one argument.  The type of {@code F}&apos;s sole argument
                  replaces the corresponding argument type of the target
                  in the resulting adapted method handle.
                  The return type of {@code F} must be identical to the corresponding
                  parameter type of the target.
                  &lt;p&gt;
                  It is an error if there are elements of {@code filters}(null or not)
                  which do not correspond to argument positions in the target.
                  &lt;b&gt;Example:&lt;/b&gt;
                  &lt;p&gt;&lt;blockquote&gt;&lt;pre&gt;
                  import static java.lang.invoke.MethodHandles.;
                  import static java.lang.invoke.MethodType.;
                  ...
                  MethodHandle cat = lookup().findVirtual(String.class,
                  &quot;concat&quot;, methodType(String.class, String.class));
                  MethodHandle upcase = lookup().findVirtual(String.class,
                  &quot;toUpperCase&quot;, methodType(String.class));
                  assertEquals(&quot;xy&quot;, (String) cat.invokeExact(&quot;x&quot;, &quot;y&quot;));
                  MethodHandle f0 = filterArguments(cat, 0, upcase);
                  assertEquals(&quot;Xy&quot;, (String) f0.invokeExact(&quot;x&quot;, &quot;y&quot;)); // Xy
                  MethodHandle f1 = filterArguments(cat, 1, upcase);
                  assertEquals(&quot;xY&quot;, (String) f1.invokeExact(&quot;x&quot;, &quot;y&quot;)); // xY
                  MethodHandle f2 = filterArguments(cat, 0, upcase, upcase);
                  assertEquals(&quot;XY&quot;, (String) f2.invokeExact(&quot;x&quot;, &quot;y&quot;)); // XY
                  &lt;/pre&gt;&lt;/blockquote&gt;
                  &lt;p&gt; Here is pseudocode for the resulting adapter:
                  &lt;blockquote&gt;&lt;pre&gt;
                  V target(P... p, A[i]... a[i], B... b);
                  A[i] filter[i](V[i]);
                  T adapter(P... p, V[i]... v[i], B... b) {
                  return target(p..., f[i](v[i])..., b...);
                  }
                  &lt;/pre&gt;&lt;/blockquote&gt;                
                <param>
                    target the method handle to invoke after arguments are filtered                    
                </param>
                <param>
                    pos the position of the first argument to filter                    
                </param>
                <param>
                    filters method handles to call initially on filtered arguments                    
                </param>
                <return>
                    method handle which incorporates the specified argument filtering logic                    
                </return>
                <throws>
                    NullPointerException if the target is null
                      or if the {@code filters} array is null                    
                </throws>
                <throws>
                    IllegalArgumentException if a non-null element of {@code filters}does not match a corresponding argument type of target as described above,
                      or if the {@code pos+filters.length} is greater than {@code target.type().parameterCount()}                    
                </throws>
            </javadoc>
            <method name="filterArguments" type="MethodHandle" line="1898">
                <params>
                    <param name="target" type="MethodHandle"/>
                    <param name="pos" type="int"/>
                    <param name="filters" type="MethodHandle"/>
                </params>
                <comment line="1907">
                    pre-incremented                    
                </comment>
                <comment line="1910">
                    ignore null elements of filters                    
                </comment>
                <declaration name="targetType" type="MethodType" line="1899"/>
                <declaration name="adapter" type="MethodHandle" line="1900"/>
                <declaration name="adapterType" type="MethodType" line="1901"/>
                <declaration name="maxPos" type="int" line="1903"/>
                <declaration name="curPos" type="int" line="1906"/>
                <scope line="1907"/>
            </method>
            <method name="filterArgument" type="MethodHandle" line="1918">
                <params>
                    <param name="target" type="MethodHandle"/>
                    <param name="pos" type="int"/>
                    <param name="filter" type="MethodHandle"/>
                </params>
                <declaration name="targetType" type="MethodType" line="1919"/>
                <declaration name="filterType" type="MethodType" line="1920"/>
            </method>
            <javadoc line="1927">
                Adapts a target method handle by post-processing
                  its return value (if any) with a filter (another method handle).
                  The result of the filter is returned from the adapter.
                  &lt;p&gt;
                  If the target returns a value, the filter must accept that value as
                  its only argument.
                  If the target returns void, the filter must accept no arguments.
                  &lt;p&gt;
                  The return type of the filter
                  replaces the return type of the target
                  in the resulting adapted method handle.
                  The argument type of the filter (if any) must be identical to the
                  return type of the target.
                  &lt;b&gt;Example:&lt;/b&gt;
                  &lt;p&gt;&lt;blockquote&gt;&lt;pre&gt;
                  import static java.lang.invoke.MethodHandles.;
                  import static java.lang.invoke.MethodType.;
                  ...
                  MethodHandle cat = lookup().findVirtual(String.class,
                  &quot;concat&quot;, methodType(String.class, String.class));
                  MethodHandle length = lookup().findVirtual(String.class,
                  &quot;length&quot;, methodType(int.class));
                  System.out.println((String) cat.invokeExact(&quot;x&quot;, &quot;y&quot;)); // xy
                  MethodHandle f0 = filterReturnValue(cat, length);
                  System.out.println((int) f0.invokeExact(&quot;x&quot;, &quot;y&quot;)); // 2
                  &lt;/pre&gt;&lt;/blockquote&gt;
                  &lt;p&gt; Here is pseudocode for the resulting adapter:
                  &lt;blockquote&gt;&lt;pre&gt;
                  V target(A...);
                  T filter(V);
                  T adapter(A... a) {
                  V v = target(a...);
                  return filter(v);
                  }
                  // and if the target has a void return:
                  void target2(A...);
                  T filter2();
                  T adapter2(A... a) {
                  target2(a...);
                  return filter2();
                  }
                  // and if the filter has a void return:
                  V target3(A...);
                  void filter3(V);
                  void adapter3(A... a) {
                  V v = target3(a...);
                  filter3(v);
                  }
                  &lt;/pre&gt;&lt;/blockquote&gt;                
                <param>
                    target the method handle to invoke before filtering the return value                    
                </param>
                <param>
                    filter method handle to call on the return value                    
                </param>
                <return>
                    method handle which incorporates the specified return value filtering logic                    
                </return>
                <throws>
                    NullPointerException if either argument is null                    
                </throws>
                <throws>
                    IllegalArgumentException if the argument list of {@code filter}does not match the return type of target as described above                    
                </throws>
            </javadoc>
            <method name="filterReturnValue" type="MethodHandle" line="1985">
                <params>
                    <param name="target" type="MethodHandle"/>
                    <param name="filter" type="MethodHandle"/>
                </params>
                <comment line="1995">
                    result = fold( lambda(retval, arg...) { filter(retval) },
                                    lambda(        arg...) { target(arg...) } )                    
                </comment>
                <comment line="2003">
                    FIXME: Too many nodes here.                    
                </comment>
                <comment line="2004">
                    this class is deprecated                    
                </comment>
                <declaration name="targetType" type="MethodType" line="1986"/>
                <declaration name="filterType" type="MethodType" line="1987"/>
                <declaration name="rtype" type="Class&lt;?&gt;" line="1988"/>
                <declaration name="filterValues" type="int" line="1989"/>
                <declaration name="newType" type="MethodType" line="1996"/>
                <declaration name="result" type="MethodHandle" line="1997"/>
                <scope line="1998"/>
                <declaration name="returner" type="MethodHandle" line="2004"/>
            </method>
            <javadoc line="2010">
                Adapts a target method handle by pre-processing
                  some of its arguments, and then calling the target with
                  the result of the pre-processing, inserted into the original
                  sequence of arguments.
                  &lt;p&gt;
                  The pre-processing is performed by {@code combiner}, a second method handle.
                  Of the arguments passed to the adapter, the first {@code N} arguments
                  are copied to the combiner, which is then called.
                  (Here, {@code N} is defined as the parameter count of the combiner.)
                  After this, control passes to the target, with any result
                  from the combiner inserted before the original {@code N} incoming
                  arguments.
                  &lt;p&gt;
                  If the combiner returns a value, the first parameter type of the target
                  must be identical with the return type of the combiner, and the next{@code N} parameter types of the target must exactly match the parameters
                  of the combiner.
                  &lt;p&gt;
                  If the combiner has a void return, no result will be inserted,
                  and the first {@code N} parameter types of the target
                  must exactly match the parameters of the combiner.
                  &lt;p&gt;
                  The resulting adapter is the same type as the target, except that the
                  first parameter type is dropped,
                  if it corresponds to the result of the combiner.
                  &lt;p&gt;
                  (Note that {@link #dropArguments(MethodHandle,int,List) dropArguments} can be used to remove any arguments
                  that either the combiner or the target does not wish to receive.
                  If some of the incoming arguments are destined only for the combiner,
                  consider using {@link MethodHandle#asCollector asCollector} instead, since those
                  arguments will not need to be live on the stack on entry to the
                  target.)
                  &lt;b&gt;Example:&lt;/b&gt;
                  &lt;p&gt;&lt;blockquote&gt;&lt;pre&gt;
                  import static java.lang.invoke.MethodHandles.;
                  import static java.lang.invoke.MethodType.;
                  ...
                  MethodHandle trace = publicLookup().findVirtual(java.io.PrintStream.class,
                  &quot;println&quot;, methodType(void.class, String.class))
                  .bindTo(System.out);
                  MethodHandle cat = lookup().findVirtual(String.class,
                  &quot;concat&quot;, methodType(String.class, String.class));
                  assertEquals(&quot;boojum&quot;, (String) cat.invokeExact(&quot;boo&quot;, &quot;jum&quot;));
                  MethodHandle catTrace = foldArguments(cat, trace);
                  // also prints &quot;boo&quot;:
                  assertEquals(&quot;boojum&quot;, (String) catTrace.invokeExact(&quot;boo&quot;, &quot;jum&quot;));
                  &lt;/pre&gt;&lt;/blockquote&gt;
                  &lt;p&gt; Here is pseudocode for the resulting adapter:
                  &lt;blockquote&gt;&lt;pre&gt;
                  // there are N arguments in A...
                  T target(V, A[N]..., B...);
                  V combiner(A...);
                  T adapter(A... a, B... b) {
                  V v = combiner(a...);
                  return target(v, a..., b...);
                  }
                  // and if the combiner has a void return:
                  T target2(A[N]..., B...);
                  void combiner2(A...);
                  T adapter2(A... a, B... b) {
                  combiner2(a...);
                  return target2(a..., b...);
                  }
                  &lt;/pre&gt;&lt;/blockquote&gt;                
                <param>
                    target the method handle to invoke after arguments are combined                    
                </param>
                <param>
                    combiner method handle to call initially on the incoming arguments                    
                </param>
                <return>
                    method handle which incorporates the specified argument folding logic                    
                </return>
                <throws>
                    NullPointerException if either argument is null                    
                </throws>
                <throws>
                    IllegalArgumentException if {@code combiner}&apos;s return type
                      is non-void and not the same as the first argument type of
                      the target, or if the initial {@code N} argument types
                      of the target
                      (skipping one matching the {@code combiner}&apos;s return type)
                      are not identical with the argument types of {@code combiner}                    
                </throws>
            </javadoc>
            <method name="foldArguments" type="MethodHandle" line="2087">
                <params>
                    <param name="target" type="MethodHandle"/>
                    <param name="combiner" type="MethodHandle"/>
                </params>
                <declaration name="pos" type="int" line="2088"/>
                <declaration name="targetType" type="MethodType" line="2089"/>
                <declaration name="combinerType" type="MethodType" line="2090"/>
                <declaration name="foldPos" type="int" line="2091"/>
                <declaration name="foldArgs" type="int" line="2092"/>
                <declaration name="foldVals" type="int" line="2093"/>
                <declaration name="afterInsertPos" type="int" line="2094"/>
                <declaration name="ok" type="boolean" line="2095"/>
                <declaration name="newType" type="MethodType" line="2104"/>
                <declaration name="res" type="MethodHandle" line="2105"/>
            </method>
            <javadoc line="2110">
                Makes a method handle which adapts a target method handle,
                  by guarding it with a test, a boolean-valued method handle.
                  If the guard fails, a fallback handle is called instead.
                  All three method handles must have the same corresponding
                  argument and return types, except that the return type
                  of the test must be boolean, and the test is allowed
                  to have fewer arguments than the other two method handles.
                  &lt;p&gt; Here is pseudocode for the resulting adapter:
                  &lt;blockquote&gt;&lt;pre&gt;
                  boolean test(A...);
                  T target(A...,B...);
                  T fallback(A...,B...);
                  T adapter(A... a,B... b) {
                  if (test(a...))
                  return target(a..., b...);
                  else
                  return fallback(a..., b...);
                  }
                  &lt;/pre&gt;&lt;/blockquote&gt;
                  Note that the test arguments ({@code a...} in the pseudocode) cannot
                  be modified by execution of the test, and so are passed unchanged
                  from the caller to the target or fallback as appropriate.                
                <param>
                    test method handle used for test, must return boolean                    
                </param>
                <param>
                    target method handle to call if test passes                    
                </param>
                <param>
                    fallback method handle to call if test fails                    
                </param>
                <return>
                    method handle which incorporates the specified if/then/else logic                    
                </return>
                <throws>
                    NullPointerException if any argument is null                    
                </throws>
                <throws>
                    IllegalArgumentException if {@code test} does not return boolean,
                      or if all three method types do not match (with the return
                      type of {@code test} changed to match that of the target).                    
                </throws>
            </javadoc>
            <method name="guardWithTest" type="MethodHandle" line="2145">
                <params>
                    <param name="test" type="MethodHandle"/>
                    <param name="target" type="MethodHandle"/>
                    <param name="fallback" type="MethodHandle"/>
                </params>
                <declaration name="gtype" type="MethodType" line="2146"/>
                <declaration name="ttype" type="MethodType" line="2147"/>
                <declaration name="ftype" type="MethodType" line="2148"/>
                <declaration name="targs" type="List&lt;Class&lt;?&gt;&gt;" line="2153"/>
                <declaration name="gargs" type="List&lt;Class&lt;?&gt;&gt;" line="2154"/>
                <scope line="2155">
                    <declaration name="gpc" type="int" line="2156"/>
                </scope>
            </method>
            <method name="misMatchedTypes" type="RuntimeException" line="2165">
                <params>
                    <param name="what" type="String"/>
                    <param name="t1" type="MethodType"/>
                    <param name="t2" type="MethodType"/>
                </params>
            </method>
            <javadoc line="2169">
                Makes a method handle which adapts a target method handle,
                  by running it inside an exception handler.
                  If the target returns normally, the adapter returns that value.
                  If an exception matching the specified type is thrown, the fallback
                  handle is called instead on the exception, plus the original arguments.
                  &lt;p&gt;
                  The target and handler must have the same corresponding
                  argument and return types, except that handler may omit trailing arguments
                  (similarly to the predicate in {@link #guardWithTest guardWithTest}).
                  Also, the handler must have an extra leading parameter of {@code exType} or a supertype.
                  &lt;p&gt; Here is pseudocode for the resulting adapter:
                  &lt;blockquote&gt;&lt;pre&gt;
                  T target(A..., B...);
                  T handler(ExType, A...);
                  T adapter(A... a, B... b) {
                  try {
                  return target(a..., b...);
                  } catch (ExType ex) {
                  return handler(ex, a...);
                  }
                  }
                  &lt;/pre&gt;&lt;/blockquote&gt;
                  Note that the saved arguments ({@code a...} in the pseudocode) cannot
                  be modified by execution of the target, and so are passed unchanged
                  from the caller to the handler, if the handler is invoked.
                  &lt;p&gt;
                  The target and handler must return the same type, even if the handler
                  always throws.  (This might happen, for instance, because the handler
                  is simulating a {@code finally} clause).
                  To create such a throwing handler, compose the handler creation logic
                  with {@link #throwException throwException},
                  in order to create a method handle of the correct return type.                
                <param>
                    target method handle to call                    
                </param>
                <param>
                    exType the type of exception which the handler will catch                    
                </param>
                <param>
                    handler method handle to call if a matching exception is thrown                    
                </param>
                <return>
                    method handle which incorporates the specified try/catch logic                    
                </return>
                <throws>
                    NullPointerException if any argument is null                    
                </throws>
                <throws>
                    IllegalArgumentException if {@code handler} does not accept
                      the given exception type, or if the method handle types do
                      not match in their return types and their
                      corresponding parameters                    
                </throws>
            </javadoc>
            <method name="catchException" type="MethodHandle" line="2215">
                <params>
                    <param name="target" type="MethodHandle"/>
                    <param name="exType" type="Class<? extends Throwable>"/>
                    <param name="handler" type="MethodHandle"/>
                </params>
                <comment line="2226">
                    omit leading parameter from handler                    
                </comment>
                <declaration name="ttype" type="MethodType" line="2216"/>
                <declaration name="htype" type="MethodType" line="2217"/>
                <declaration name="targs" type="List&lt;Class&lt;?&gt;&gt;" line="2223"/>
                <declaration name="hargs" type="List&lt;Class&lt;?&gt;&gt;" line="2224"/>
                <scope line="2226">
                    <declaration name="hpc" type="int" line="2227"/>
                </scope>
            </method>
            <javadoc line="2236">
                Produces a method handle which will throw exceptions of the given {@code exType}.
                  The method handle will accept a single argument of {@code exType},
                  and immediately throw it as an exception.
                  The method type will nominally specify a return of {@code returnType}.
                  The return type may be anything convenient:  It doesn&apos;t matter to the
                  method handle&apos;s behavior, since it will never return normally.                
                <return>
                    method handle which can throw the given exceptions                    
                </return>
                <throws>
                    NullPointerException if either argument is null                    
                </throws>
            </javadoc>
            <method name="throwException" type="MethodHandle" line="2247">
                <params>
                    <param name="returnType" type="Class<?>"/>
                    <param name="exType" type="Class<? extends Throwable>"/>
                </params>
            </method>
        </class>
    </source>