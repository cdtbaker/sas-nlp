<?xml version="1.0" encoding="UTF-8"?>
    <source package="java.lang.invoke">
        <import package="sun.invoke.util.BytecodeDescriptor"/>
        <import package="java.lang.reflect.Constructor"/>
        <import package="java.lang.reflect.Field"/>
        <import package="java.lang.reflect.Method"/>
        <import package="java.lang.reflect.Member"/>
        <import package="java.lang.reflect.Modifier"/>
        <import package="java.util.ArrayList"/>
        <import package="java.util.Arrays"/>
        <import package="java.util.Collections"/>
        <import package="java.util.Iterator"/>
        <import package="java.util.List"/>
        <import package="java.lang.invoke.MethodHandleNatives.Constants"/>
        <import package="java.lang.invoke.MethodHandleStatics"/>
        <class name="MemberName" line="15">
            <implements interface="Member"/>
            <implements interface="Cloneable"/>
            <javadoc line="15">
                A {@code MemberName} is a compact symbolic datum which fully characterizes
                  a method or field reference.
                  A member name refers to a field, method, constructor, or member type.
                  Every member name has a simple name (a string) and a type (either a Class or MethodType).
                  A member name may also have a non-null declaring class, or it may be simply
                  a naked name/type pair.
                  A member name may also have non-zero modifier flags.
                  Finally, a member name may be either resolved or unresolved.
                  If it is resolved, the existence of the named
                  &lt;p&gt;
                  Whether resolved or not, a member name provides no access rights or
                  invocation capability to its possessor.  It is merely a compact
                  representation of all symbolic information necessary to link to
                  and properly use the named member.
                  &lt;p&gt;
                  When resolved, a member name&apos;s internal implementation may include references to JVM metadata.
                  This representation is stateless and only decriptive.
                  It provides no private information and no capability to use the member.
                  &lt;p&gt;
                  By contrast, a {@linkplain java.lang.reflect.Method} contains fuller information
                  about the internals of a method (except its bytecodes) and also
                  allows invocation.  A MemberName is much lighter than a Method,
                  since it contains about 7 fields to the 16 of Method (plus its sub-arrays),
                  and those seven fields omit much of the information in Method.                
                <author>
                    jrose                    
                </author>
            </javadoc>
            <declaration name="clazz" type="Class&lt;?&gt;" line="43"/>
            <declaration name="name" type="String" line="44"/>
            <declaration name="type" type="Object" line="45"/>
            <declaration name="flags" type="int" line="46"/>
            <declaration name="vmtarget" type="Object" line="47"/>
            <declaration name="vmindex" type="int" line="48"/>
            <scope line="49"/>
            <javadoc line="52">
                Return the declaring class of this member.
                  In the case of a bare name and type, the declaring class will be null.                
            </javadoc>
            <method name="getDeclaringClass" type="Class<?>" line="56">
                <scope line="57"/>
            </method>
            <javadoc line="62">
                Utility method producing the class loader of the declaring class.                
            </javadoc>
            <method name="getClassLoader" type="ClassLoader" line="65"/>
            <javadoc line="68">
                Return the simple name of this member.
                  For a type, it is the same as {@link Class#getSimpleName}.
                  For a method or field, it is the simple name of the member.
                  For a constructor, it is always {@code &quot;&amp;lt;init&amp;gt;&quot;}.                
            </javadoc>
            <method name="getName" type="String" line="74">
                <scope line="75"/>
            </method>
            <javadoc line="81">
                Return the declared type of this member, which
                  must be a method or constructor.                
            </javadoc>
            <method name="getMethodType" type="MethodType" line="85">
                <scope line="86"/>
                <scope line="91"/>
                <scope line="94">
                    <declaration name="sig" type="String" line="95"/>
                    <declaration name="res" type="MethodType" line="96"/>
                </scope>
                <scope line="100">
                    <declaration name="typeInfo" type="Object[]" line="101"/>
                    <declaration name="ptypes" type="Class&lt;?&gt;[]" line="102"/>
                    <declaration name="rtype" type="Class&lt;?&gt;" line="103"/>
                    <declaration name="res" type="MethodType" line="104"/>
                </scope>
            </method>
            <javadoc line="110">
                Return the actual type under which this method or constructor must be invoked.
                  For non-static methods or constructors, this is the type with a leading parameter,
                  a reference to declaring class.  For static methods, it is the same as the declared type.                
            </javadoc>
            <method name="getInvocationType" type="MethodType" line="115">
                <declaration name="itype" type="MethodType" line="116"/>
            </method>
            <javadoc line="120">
                Utility method producing the parameter types of the method type.                
            </javadoc>
            <method name="getParameterTypes" type="Class<?>[]" line="123"/>
            <javadoc line="126">
                Utility method producing the return type of the method type.                
            </javadoc>
            <method name="getReturnType" type="Class<?>" line="129"/>
            <javadoc line="132">
                Return the declared type of this member, which
                  must be a field or type.
                  If it is a type member, that type itself is returned.                
            </javadoc>
            <method name="getFieldType" type="Class<?>" line="137">
                <scope line="138"/>
                <scope line="143"/>
                <scope line="146">
                    <declaration name="sig" type="String" line="147"/>
                    <declaration name="mtype" type="MethodType" line="148"/>
                    <declaration name="res" type="Class&lt;?&gt;" line="149"/>
                </scope>
            </method>
            <javadoc line="155">
                Utility method to produce either the method type or field type of this member.                
            </javadoc>
            <method name="getType" type="Object" line="158"/>
            <javadoc line="161">
                Utility method to produce the signature of this member,
                  used within the class file format to describe its type.                
            </javadoc>
            <method name="getSignature" type="String" line="165">
                <scope line="166"/>
            </method>
            <javadoc line="174">
                Return the modifier flags of this member.                
                <see>
                    java.lang.reflect.Modifier                    
                </see>
            </javadoc>
            <method name="getModifiers" type="int" line="178"/>
            <method name="setFlags" type="void" line="181">
                <params>
                    <param name="flags" type="int"/>
                </params>
            </method>
            <method name="testFlags" type="boolean" line="185">
                <params>
                    <param name="mask" type="int"/>
                    <param name="value" type="int"/>
                </params>
            </method>
            <method name="testAllFlags" type="boolean" line="188">
                <params>
                    <param name="mask" type="int"/>
                </params>
            </method>
            <method name="testAnyFlags" type="boolean" line="191">
                <params>
                    <param name="mask" type="int"/>
                </params>
            </method>
            <javadoc line="194">
                Utility method to query the modifier flags of this member.                
            </javadoc>
            <method name="isStatic" type="boolean" line="197"/>
            <javadoc line="200">
                Utility method to query the modifier flags of this member.                
            </javadoc>
            <method name="isPublic" type="boolean" line="203"/>
            <javadoc line="206">
                Utility method to query the modifier flags of this member.                
            </javadoc>
            <method name="isPrivate" type="boolean" line="209"/>
            <javadoc line="212">
                Utility method to query the modifier flags of this member.                
            </javadoc>
            <method name="isProtected" type="boolean" line="215"/>
            <javadoc line="218">
                Utility method to query the modifier flags of this member.                
            </javadoc>
            <method name="isFinal" type="boolean" line="221"/>
            <javadoc line="224">
                Utility method to query the modifier flags of this member.                
            </javadoc>
            <method name="isAbstract" type="boolean" line="227"/>
            <declaration name="BRIDGE" type="int" line="230"/>
            <declaration name="VARARGS" type="int" line="231"/>
            <declaration name="SYNTHETIC" type="int" line="232"/>
            <declaration name="ANNOTATION" type="int" line="233"/>
            <declaration name="ENUM" type="int" line="234"/>
            <javadoc line="235">
                Utility method to query the modifier flags of this member; returns false if the member is not a method.                
            </javadoc>
            <method name="isBridge" type="boolean" line="238"/>
            <javadoc line="241">
                Utility method to query the modifier flags of this member; returns false if the member is not a method.                
            </javadoc>
            <method name="isVarargs" type="boolean" line="244"/>
            <javadoc line="247">
                Utility method to query the modifier flags of this member; returns false if the member is not a method.                
            </javadoc>
            <method name="isSynthetic" type="boolean" line="250"/>
            <declaration name="CONSTRUCTOR_NAME" type="String" line="253"/>
            <declaration name="RECOGNIZED_MODIFIERS" type="int" line="254"/>
            <declaration name="IS_METHOD" type="int" line="255"/>
            <declaration name="SEARCH_SUPERCLASSES" type="int" line="256"/>
            <declaration name="ALL_ACCESS" type="int" line="257"/>
            <declaration name="ALL_KINDS" type="int" line="258"/>
            <declaration name="IS_INVOCABLE" type="int" line="259"/>
            <declaration name="IS_FIELD_OR_METHOD" type="int" line="260"/>
            <declaration name="SEARCH_ALL_SUPERS" type="int" line="261"/>
            <javadoc line="262">
                Utility method to query whether this member is a method or constructor.                
            </javadoc>
            <method name="isInvocable" type="boolean" line="265"/>
            <javadoc line="268">
                Utility method to query whether this member is a method, constructor, or field.                
            </javadoc>
            <method name="isFieldOrMethod" type="boolean" line="271"/>
            <javadoc line="274">
                Query whether this member is a method.                
            </javadoc>
            <method name="isMethod" type="boolean" line="277"/>
            <javadoc line="280">
                Query whether this member is a constructor.                
            </javadoc>
            <method name="isConstructor" type="boolean" line="283"/>
            <javadoc line="286">
                Query whether this member is a field.                
            </javadoc>
            <method name="isField" type="boolean" line="289"/>
            <javadoc line="292">
                Query whether this member is a type.                
            </javadoc>
            <method name="isType" type="boolean" line="295"/>
            <javadoc line="298">
                Utility method to query whether this member is neither public, private, nor protected.                
            </javadoc>
            <method name="isPackage" type="boolean" line="301"/>
            <javadoc line="304">
                Initialize a query.   It is not resolved.                
            </javadoc>
            <method name="init" type="void" line="307">
                <params>
                    <param name="defClass" type="Class<?>"/>
                    <param name="name" type="String"/>
                    <param name="type" type="Object"/>
                    <param name="flags" type="int"/>
                </params>
            </method>
            <method name="expandFromVM" type="void" line="314"/>
            <method name="flagsMods" type="int" line="319">
                <params>
                    <param name="flags" type="int"/>
                    <param name="mods" type="int"/>
                </params>
            </method>
            <javadoc line="324">
                Create a name for the given reflected method.  The resulting name will be in a resolved state.                
            </javadoc>
            <method name="MemberName" type="constructor" line="327">
                <params>
                    <param name="m" type="Method"/>
                </params>
                <declaration name="typeInfo" type="Object[]" line="328"/>
            </method>
            <javadoc line="333">
                Create a name for the given reflected constructor.  The resulting name will be in a resolved state.                
            </javadoc>
            <method name="MemberName" type="constructor" line="336">
                <params>
                    <param name="ctor" type="Constructor"/>
                </params>
                <declaration name="typeInfo" type="Object[]" line="337"/>
            </method>
            <javadoc line="342">
                Create a name for the given reflected field.  The resulting name will be in a resolved state.                
            </javadoc>
            <method name="MemberName" type="constructor" line="345">
                <params>
                    <param name="fld" type="Field"/>
                </params>
            </method>
            <javadoc line="350">
                Create a name for the given class.  The resulting name will be in a resolved state.                
            </javadoc>
            <method name="MemberName" type="constructor" line="353">
                <params>
                    <param name="type" type="Class<?>"/>
                </params>
            </method>
            <method name="MemberName" type="constructor" line="358"/>
            <method name="clone" type="MemberName" line="360">
                <scope line="361"/>
                <scope line="364"/>
            </method>
            <javadoc line="368">
                Create a field or type name from the given components:  Declaring class, name, type, modifiers.
                  The declaring class may be supplied as null if this is to be a bare name and type.
                  The resulting name will in an unresolved state.                
            </javadoc>
            <method name="MemberName" type="constructor" line="373">
                <params>
                    <param name="defClass" type="Class<?>"/>
                    <param name="name" type="String"/>
                    <param name="type" type="Class<?>"/>
                    <param name="modifiers" type="int"/>
                </params>
            </method>
            <javadoc line="376">
                Create a field or type name from the given components:  Declaring class, name, type.
                  The declaring class may be supplied as null if this is to be a bare name and type.
                  The modifier flags default to zero.
                  The resulting name will in an unresolved state.                
            </javadoc>
            <method name="MemberName" type="constructor" line="382">
                <params>
                    <param name="defClass" type="Class<?>"/>
                    <param name="name" type="String"/>
                    <param name="type" type="Class<?>"/>
                </params>
            </method>
            <javadoc line="385">
                Create a method or constructor name from the given components:  Declaring class, name, type, modifiers.
                  It will be a constructor if and only if the name is {@code &quot;&amp;lt;init&amp;gt;&quot;}.
                  The declaring class may be supplied as null if this is to be a bare name and type.
                  The resulting name will in an unresolved state.                
            </javadoc>
            <method name="MemberName" type="constructor" line="391">
                <params>
                    <param name="defClass" type="Class<?>"/>
                    <param name="name" type="String"/>
                    <param name="type" type="MethodType"/>
                    <param name="modifiers" type="int"/>
                </params>
                <declaration name="flagBit" type="int" line="392"/>
            </method>
            <javadoc line="395">
                Create a method or constructor name from the given components:  Declaring class, name, type, modifiers.
                  It will be a constructor if and only if the name is {@code &quot;&amp;lt;init&amp;gt;&quot;}.
                  The declaring class may be supplied as null if this is to be a bare name and type.
                  The modifier flags default to zero.
                  The resulting name will in an unresolved state.                
            </javadoc>
            <method name="MemberName" type="constructor" line="402">
                <params>
                    <param name="defClass" type="Class<?>"/>
                    <param name="name" type="String"/>
                    <param name="type" type="MethodType"/>
                </params>
            </method>
            <javadoc line="405">
                Query whether this member name is resolved.
                  A resolved member name is one for which the JVM has found
                  a method, constructor, field, or type binding corresponding exactly to the name.
                  (Document?)                
            </javadoc>
            <method name="isResolved" type="boolean" line="411"/>
            <javadoc line="414">
                Query whether this member name is resolved to a non-static, non-final method.                
            </javadoc>
            <method name="hasReceiverTypeDispatch" type="boolean" line="417"/>
            <javadoc line="420">
                Produce a string form of this member name.
                  For types, it is simply the type&apos;s own string (as reported by {@code toString}).
                  For fields, it is {@code &quot;DeclaringClass.name/type&quot;}.
                  For methods and constructors, it is {@code &quot;DeclaringClass.name(ptype...)rtype&quot;}.
                  If the declaring class is null, the prefix {@code &quot;DeclaringClass.&quot;} is omitted.
                  If the member is unresolved, a prefix {@code &quot;.&quot;} is prepended.                
            </javadoc>
            <method name="toString" type="String" line="428">
                <declaration name="buf" type="StringBuilder" line="430"/>
                <scope line="431"/>
                <declaration name="name" type="String" line="435"/>
                <declaration name="type" type="Object" line="437"/>
                <scope line="438"/>
                <scope line="442"/>
            </method>
            <method name="getName" type="String" line="447">
                <params>
                    <param name="obj" type="Object"/>
                </params>
            </method>
            <javadoc line="451">
                Document?                
            </javadoc>
            <method name="getVMIndex" type="int" line="454"/>
            <method name="makeAccessException" type="IllegalAccessException" line="458">
                <params>
                    <param name="message" type="String"/>
                    <param name="from" type="Object"/>
                </params>
            </method>
            <method name="message" type="String" line="463"/>
            <method name="makeAccessException" type="ReflectiveOperationException" line="469">
                <declaration name="message" type="String" line="470"/>
            </method>
            <javadoc line="476">
                Actually making a query requires an access check.                
            </javadoc>
            <method name="getFactory" type="Factory" line="479"/>
            <class name="Factory" line="482">
                <javadoc line="482">
                    A factory type for resolving member names with the help of the VM.
                      TBD: Define access-safe public constructors for this factory.                    
                </javadoc>
                <method name="Factory" type="constructor" line="487"/>
                <declaration name="INSTANCE" type="Factory" line="489"/>
                <declaration name="ALLOWED_FLAGS" type="int" line="490"/>
                <method name="getMembers" type="List<MemberName>" line="491">
                    <params>
                        <param name="defc" type="Class<?>"/>
                        <param name="matchName" type="String"/>
                        <param name="matchType" type="Object"/>
                        <param name="matchFlags" type="int"/>
                        <param name="lookupClass" type="Class<?>"/>
                    </params>
                    <declaration name="matchSig" type="String" line="493"/>
                    <scope line="494"/>
                    <declaration name="BUF_MAX" type="int" line="499"/>
                    <declaration name="len1" type="int" line="500"/>
                    <declaration name="buf" type="MemberName[]" line="501"/>
                    <declaration name="totalCount" type="int" line="502"/>
                    <declaration name="bufs" type="ArrayList&lt;MemberName[]&gt;" line="503"/>
                    <declaration name="bufCount" type="int" line="504"/>
                    <scope line="505">
                        <scope line="507"/>
                        <declaration name="excess" type="int" line="513"/>
                        <declaration name="len2" type="int" line="516"/>
                    </scope>
                    <declaration name="result" type="ArrayList&lt;MemberName&gt;" line="521"/>
                    <scope line="522">
                        <scope line="523"/>
                    </scope>
                    <scope line="528">
                        <scope line="529">
                            <declaration name="m" type="MemberName" line="530"/>
                        </scope>
                    </scope>
                </method>
                <method name="resolveInPlace" type="boolean" line="536">
                    <params>
                        <param name="m" type="MemberName"/>
                        <param name="searchSupers" type="boolean"/>
                        <param name="lookupClass" type="Class<?>"/>
                    </params>
                    <scope line="537">
                        <declaration name="defc" type="Class&lt;?&gt;" line="538"/>
                        <declaration name="choices" type="List&lt;MemberName&gt;" line="539"/>
                    </scope>
                    <declaration name="matchFlags" type="int" line="549"/>
                    <declaration name="matchSig" type="String" line="550"/>
                    <declaration name="buf" type="MemberName[]" line="551"/>
                    <declaration name="n" type="int" line="552"/>
                </method>
                <javadoc line="556">
                    Produce a resolved version of the given member.
                      Super types are searched (for inherited members) if {@code searchSupers} is true.
                      Access checking is performed on behalf of the given {@code lookupClass}.
                      If lookup fails or access is not permitted, null is returned.
                      Otherwise a fresh copy of the given member is returned, with modifier bits filled in.                    
                </javadoc>
                <method name="resolveOrNull" type="MemberName" line="563">
                    <params>
                        <param name="m" type="MemberName"/>
                        <param name="searchSupers" type="boolean"/>
                        <param name="lookupClass" type="Class<?>"/>
                    </params>
                    <declaration name="result" type="MemberName" line="564"/>
                </method>
                <javadoc line="568">
                    Produce a resolved version of the given member.
                      Super types are searched (for inherited members) if {@code searchSupers} is true.
                      Access checking is performed on behalf of the given {@code lookupClass}.
                      If lookup fails or access is not permitted, a {@linkplain ReflectiveOperationException} is thrown.
                      Otherwise a fresh copy of the given member is returned, with modifier bits filled in.                    
                </javadoc>
                <method name="resolveOrFail" type="MemberName" line="575">
                    <params>
                        <param name="m" type="MemberName"/>
                        <param name="searchSupers" type="boolean"/>
                        <param name="lookupClass" type="Class<?>"/>
                        <param name="nsmClass" type="Class<NoSuchMemberException>"/>
                    </params>
                    <declaration name="result" type="MemberName" line="576"/>
                    <declaration name="ex" type="ReflectiveOperationException" line="578"/>
                </method>
                <javadoc line="582">
                    Return a list of all methods defined by the given class.
                      Super types are searched (for inherited members) if {@code searchSupers} is true.
                      Access checking is performed on behalf of the given {@code lookupClass}.
                      Inaccessible members are not added to the last.                    
                </javadoc>
                <method name="getMethods" type="List<MemberName>" line="588">
                    <params>
                        <param name="defc" type="Class<?>"/>
                        <param name="searchSupers" type="boolean"/>
                        <param name="lookupClass" type="Class<?>"/>
                    </params>
                </method>
                <javadoc line="591">
                    Return a list of matching methods defined by the given class.
                      Super types are searched (for inherited members) if {@code searchSupers} is true.
                      Returned methods will match the name (if not null) and the type (if not null).
                      Access checking is performed on behalf of the given {@code lookupClass}.
                      Inaccessible members are not added to the last.                    
                </javadoc>
                <method name="getMethods" type="List<MemberName>" line="598">
                    <params>
                        <param name="defc" type="Class<?>"/>
                        <param name="searchSupers" type="boolean"/>
                        <param name="name" type="String"/>
                        <param name="type" type="MethodType"/>
                        <param name="lookupClass" type="Class<?>"/>
                    </params>
                    <declaration name="matchFlags" type="int" line="599"/>
                </method>
                <javadoc line="602">
                    Return a list of all constructors defined by the given class.
                      Access checking is performed on behalf of the given {@code lookupClass}.
                      Inaccessible members are not added to the last.                    
                </javadoc>
                <method name="getConstructors" type="List<MemberName>" line="607">
                    <params>
                        <param name="defc" type="Class<?>"/>
                        <param name="lookupClass" type="Class<?>"/>
                    </params>
                </method>
                <javadoc line="610">
                    Return a list of all fields defined by the given class.
                      Super types are searched (for inherited members) if {@code searchSupers} is true.
                      Access checking is performed on behalf of the given {@code lookupClass}.
                      Inaccessible members are not added to the last.                    
                </javadoc>
                <method name="getFields" type="List<MemberName>" line="616">
                    <params>
                        <param name="defc" type="Class<?>"/>
                        <param name="searchSupers" type="boolean"/>
                        <param name="lookupClass" type="Class<?>"/>
                    </params>
                </method>
                <javadoc line="619">
                    Return a list of all fields defined by the given class.
                      Super types are searched (for inherited members) if {@code searchSupers} is true.
                      Returned fields will match the name (if not null) and the type (if not null).
                      Access checking is performed on behalf of the given {@code lookupClass}.
                      Inaccessible members are not added to the last.                    
                </javadoc>
                <method name="getFields" type="List<MemberName>" line="626">
                    <params>
                        <param name="defc" type="Class<?>"/>
                        <param name="searchSupers" type="boolean"/>
                        <param name="name" type="String"/>
                        <param name="type" type="Class<?>"/>
                        <param name="lookupClass" type="Class<?>"/>
                    </params>
                    <declaration name="matchFlags" type="int" line="627"/>
                </method>
                <javadoc line="630">
                    Return a list of all nested types defined by the given class.
                      Super types are searched (for inherited members) if {@code searchSupers} is true.
                      Access checking is performed on behalf of the given {@code lookupClass}.
                      Inaccessible members are not added to the last.                    
                </javadoc>
                <method name="getNestedTypes" type="List<MemberName>" line="636">
                    <params>
                        <param name="defc" type="Class<?>"/>
                        <param name="searchSupers" type="boolean"/>
                        <param name="lookupClass" type="Class<?>"/>
                    </params>
                    <declaration name="matchFlags" type="int" line="637"/>
                </method>
                <method name="newMemberBuffer" type="MemberName[]" line="640">
                    <params>
                        <param name="length" type="int"/>
                    </params>
                    <declaration name="buf" type="MemberName[]" line="641"/>
                </method>
            </class>
        </class>
    </source>