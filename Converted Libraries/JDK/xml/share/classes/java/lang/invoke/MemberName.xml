<?xml version="1.0" encoding="UTF-8"?>
    <source package="java.lang.invoke">
        <import package="sun.invoke.util.BytecodeDescriptor"/>
        <import package="java.lang.reflect.Constructor"/>
        <import package="java.lang.reflect.Field"/>
        <import package="java.lang.reflect.Method"/>
        <import package="java.lang.reflect.Member"/>
        <import package="java.lang.reflect.Modifier"/>
        <import package="java.util.ArrayList"/>
        <import package="java.util.Arrays"/>
        <import package="java.util.Collections"/>
        <import package="java.util.Iterator"/>
        <import package="java.util.List"/>
        <import package="java.lang.invoke.MethodHandleNatives.Constants"/>
        <import package="java.lang.invoke.MethodHandleStatics"/>
        <class name="MemberName" line="42">
            <comment line="70">
                                
            </comment>
            <comment line="71">
                class in which the method is defined                
            </comment>
            <comment line="72">
                may be null if not yet materialized                
            </comment>
            <comment line="73">
                may be null if not yet materialized                
            </comment>
            <comment line="74">
                modifier bits; see reflect.Modifier                
            </comment>
            <comment line="76">
                VM-specific target value                
            </comment>
            <comment line="77">
                method index within class or interface                
            </comment>
            <comment line="251">
                let the rest (native, volatile, transient, etc.) be tested via Modifier.isFoo                
            </comment>
            <comment line="253">
                unofficial modifier flags, used by HotSpot:                
            </comment>
            <comment line="272">
                the ever-popular                
            </comment>
            <comment line="274">
                modifiers exported by the JVM:                
            </comment>
            <comment line="277">
                private flags, not part of RECOGNIZED_MODIFIERS:                
            </comment>
            <comment line="282">
                nested type                
            </comment>
            <comment line="342">
                Capturing information from the Core Reflection API:                
            </comment>
            <comment line="378">
                bare-bones constructor; the JVM will fill it in                
            </comment>
            <comment line="381">
                locally useful cloner                
            </comment>
            <comment line="390">
                %%% define equals/hashcode?                
            </comment>
            <comment line="392">
                Construction from symbolic parts, for queries:                
            </comment>
            <comment line="492">
                Queries to the JVM:                
            </comment>
            <comment line="499">
                /*non-public*/ Object getVMTarget() {
                        if (!isResolved())
                            throw newIllegalStateException(&quot;not resolved&quot;, this);
                        return vmtarget;
                    }                
            </comment>
            <comment line="725">
                static {
                        System.out.println(&quot;Hello world!  My methods are:&quot;);
                        System.out.println(Factory.INSTANCE.getMethods(MemberName.class, true, null));
                    }                
            </comment>
            <implements interface="Member"/>
            <implements interface="Cloneable"/>
            <javadoc line="42">
                A {@code MemberName} is a compact symbolic datum which fully characterizes
                  a method or field reference.
                  A member name refers to a field, method, constructor, or member type.
                  Every member name has a simple name (a string) and a type (either a Class or MethodType).
                  A member name may also have a non-null declaring class, or it may be simply
                  a naked name/type pair.
                  A member name may also have non-zero modifier flags.
                  Finally, a member name may be either resolved or unresolved.
                  If it is resolved, the existence of the named
                  &lt;p&gt;
                  Whether resolved or not, a member name provides no access rights or
                  invocation capability to its possessor.  It is merely a compact
                  representation of all symbolic information necessary to link to
                  and properly use the named member.
                  &lt;p&gt;
                  When resolved, a member name&apos;s internal implementation may include references to JVM metadata.
                  This representation is stateless and only decriptive.
                  It provides no private information and no capability to use the member.
                  &lt;p&gt;
                  By contrast, a {@linkplain java.lang.reflect.Method} contains fuller information
                  about the internals of a method (except its bytecodes) and also
                  allows invocation.  A MemberName is much lighter than a Method,
                  since it contains about 7 fields to the 16 of Method (plus its sub-arrays),
                  and those seven fields omit much of the information in Method.                
                <author>
                    jrose                    
                </author>
            </javadoc>
            <declaration name="clazz" type="Class&lt;?&gt;" line="70"/>
            <declaration name="name" type="String" line="71"/>
            <declaration name="type" type="Object" line="72"/>
            <declaration name="flags" type="int" line="73"/>
            <declaration name="vmtarget" type="Object" line="75"/>
            <declaration name="vmindex" type="int" line="76"/>
            <scope line="78"/>
            <javadoc line="80">
                Return the declaring class of this member.
                  In the case of a bare name and type, the declaring class will be null.                
            </javadoc>
            <method name="getDeclaringClass" type="Class<?>" line="83">
                <scope line="84"/>
            </method>
            <javadoc line="90">
                Utility method producing the class loader of the declaring class.                
            </javadoc>
            <method name="getClassLoader" type="ClassLoader" line="91"/>
            <javadoc line="95">
                Return the simple name of this member.
                  For a type, it is the same as {@link Class#getSimpleName}.
                  For a method or field, it is the simple name of the member.
                  For a constructor, it is always {@code &quot;&amp;lt;init&amp;gt;&quot;}.                
            </javadoc>
            <method name="getName" type="String" line="100">
                <scope line="101"/>
            </method>
            <javadoc line="108">
                Return the declared type of this member, which
                  must be a method or constructor.                
            </javadoc>
            <method name="getMethodType" type="MethodType" line="111">
                <scope line="112"/>
                <scope line="118"/>
                <scope line="121">
                    <declaration name="sig" type="String" line="122"/>
                    <declaration name="res" type="MethodType" line="123"/>
                </scope>
                <scope line="127">
                    <declaration name="typeInfo" type="Object[]" line="128"/>
                    <declaration name="ptypes" type="Class&lt;?&gt;[]" line="129"/>
                    <declaration name="rtype" type="Class&lt;?&gt;" line="130"/>
                    <declaration name="res" type="MethodType" line="131"/>
                </scope>
            </method>
            <javadoc line="138">
                Return the actual type under which this method or constructor must be invoked.
                  For non-static methods or constructors, this is the type with a leading parameter,
                  a reference to declaring class.  For static methods, it is the same as the declared type.                
            </javadoc>
            <method name="getInvocationType" type="MethodType" line="142">
                <declaration name="itype" type="MethodType" line="143"/>
            </method>
            <javadoc line="149">
                Utility method producing the parameter types of the method type.                
            </javadoc>
            <method name="getParameterTypes" type="Class<?>[]" line="150"/>
            <javadoc line="154">
                Utility method producing the return type of the method type.                
            </javadoc>
            <method name="getReturnType" type="Class<?>" line="155"/>
            <javadoc line="159">
                Return the declared type of this member, which
                  must be a field or type.
                  If it is a type member, that type itself is returned.                
            </javadoc>
            <method name="getFieldType" type="Class<?>" line="163">
                <scope line="164"/>
                <scope line="170"/>
                <scope line="173">
                    <declaration name="sig" type="String" line="174"/>
                    <declaration name="mtype" type="MethodType" line="175"/>
                    <declaration name="res" type="Class&lt;?&gt;" line="176"/>
                </scope>
            </method>
            <javadoc line="183">
                Utility method to produce either the method type or field type of this member.                
            </javadoc>
            <method name="getType" type="Object" line="184"/>
            <javadoc line="188">
                Utility method to produce the signature of this member,
                  used within the class file format to describe its type.                
            </javadoc>
            <method name="getSignature" type="String" line="191">
                <scope line="192"/>
            </method>
            <javadoc line="204">
                Return the modifier flags of this member.                
                <see>
                    java.lang.reflect.Modifier                    
                </see>
            </javadoc>
            <method name="getModifiers" type="int" line="207"/>
            <method name="setFlags" type="void" line="211">
                <params>
                    <param name="flags" type="int"/>
                </params>
            </method>
            <method name="testFlags" type="boolean" line="216">
                <params>
                    <param name="mask" type="int"/>
                    <param name="value" type="int"/>
                </params>
            </method>
            <method name="testAllFlags" type="boolean" line="219">
                <params>
                    <param name="mask" type="int"/>
                </params>
            </method>
            <method name="testAnyFlags" type="boolean" line="222">
                <params>
                    <param name="mask" type="int"/>
                </params>
            </method>
            <javadoc line="226">
                Utility method to query the modifier flags of this member.                
            </javadoc>
            <method name="isStatic" type="boolean" line="227"/>
            <javadoc line="230">
                Utility method to query the modifier flags of this member.                
            </javadoc>
            <method name="isPublic" type="boolean" line="231"/>
            <javadoc line="234">
                Utility method to query the modifier flags of this member.                
            </javadoc>
            <method name="isPrivate" type="boolean" line="235"/>
            <javadoc line="238">
                Utility method to query the modifier flags of this member.                
            </javadoc>
            <method name="isProtected" type="boolean" line="239"/>
            <javadoc line="242">
                Utility method to query the modifier flags of this member.                
            </javadoc>
            <method name="isFinal" type="boolean" line="243"/>
            <javadoc line="246">
                Utility method to query the modifier flags of this member.                
            </javadoc>
            <method name="isAbstract" type="boolean" line="247"/>
            <declaration name="BRIDGE" type="int" line="253"/>
            <declaration name="VARARGS" type="int" line="254"/>
            <declaration name="SYNTHETIC" type="int" line="255"/>
            <declaration name="ANNOTATION" type="int" line="256"/>
            <declaration name="ENUM" type="int" line="257"/>
            <javadoc line="258">
                Utility method to query the modifier flags of this member; returns false if the member is not a method.                
            </javadoc>
            <method name="isBridge" type="boolean" line="259"/>
            <javadoc line="262">
                Utility method to query the modifier flags of this member; returns false if the member is not a method.                
            </javadoc>
            <method name="isVarargs" type="boolean" line="263"/>
            <javadoc line="266">
                Utility method to query the modifier flags of this member; returns false if the member is not a method.                
            </javadoc>
            <method name="isSynthetic" type="boolean" line="267"/>
            <declaration name="CONSTRUCTOR_NAME" type="String" line="271"/>
            <declaration name="RECOGNIZED_MODIFIERS" type="int" line="274"/>
            <declaration name="IS_METHOD" type="int" line="277"/>
            <declaration name="SEARCH_SUPERCLASSES" type="int" line="282"/>
            <declaration name="ALL_ACCESS" type="int" line="286"/>
            <declaration name="ALL_KINDS" type="int" line="287"/>
            <declaration name="IS_INVOCABLE" type="int" line="288"/>
            <declaration name="IS_FIELD_OR_METHOD" type="int" line="289"/>
            <declaration name="SEARCH_ALL_SUPERS" type="int" line="290"/>
            <javadoc line="292">
                Utility method to query whether this member is a method or constructor.                
            </javadoc>
            <method name="isInvocable" type="boolean" line="293"/>
            <javadoc line="296">
                Utility method to query whether this member is a method, constructor, or field.                
            </javadoc>
            <method name="isFieldOrMethod" type="boolean" line="297"/>
            <javadoc line="300">
                Query whether this member is a method.                
            </javadoc>
            <method name="isMethod" type="boolean" line="301"/>
            <javadoc line="304">
                Query whether this member is a constructor.                
            </javadoc>
            <method name="isConstructor" type="boolean" line="305"/>
            <javadoc line="308">
                Query whether this member is a field.                
            </javadoc>
            <method name="isField" type="boolean" line="309"/>
            <javadoc line="312">
                Query whether this member is a type.                
            </javadoc>
            <method name="isType" type="boolean" line="313"/>
            <javadoc line="316">
                Utility method to query whether this member is neither public, private, nor protected.                
            </javadoc>
            <method name="isPackage" type="boolean" line="317"/>
            <javadoc line="321">
                Initialize a query.   It is not resolved.                
            </javadoc>
            <method name="init" type="void" line="322">
                <params>
                    <param name="defClass" type="Class<?>"/>
                    <param name="name" type="String"/>
                    <param name="type" type="Object"/>
                    <param name="flags" type="int"/>
                </params>
                <comment line="324">
                    defining class is allowed to be null (for a naked name/type pair)
                    name.toString();   null check
                    type.equals(type);   null check
                     fill in fields:                    
                </comment>
            </method>
            <method name="expandFromVM" type="void" line="334">
                <comment line="338">
                    don&apos;t saddle JVM w/ typeInfo                    
                </comment>
            </method>
            <method name="flagsMods" type="int" line="342">
                <params>
                    <param name="flags" type="int"/>
                    <param name="mods" type="int"/>
                </params>
            </method>
            <javadoc line="347">
                Create a name for the given reflected method.  The resulting name will be in a resolved state.                
            </javadoc>
            <method name="MemberName" type="constructor" line="348">
                <params>
                    <param name="m" type="Method"/>
                </params>
                <comment line="352">
                    fill in vmtarget, vmindex while we have m in hand:                    
                </comment>
                <declaration name="typeInfo" type="Object[]" line="349"/>
            </method>
            <javadoc line="355">
                Create a name for the given reflected constructor.  The resulting name will be in a resolved state.                
            </javadoc>
            <method name="MemberName" type="constructor" line="356">
                <params>
                    <param name="ctor" type="Constructor"/>
                </params>
                <comment line="360">
                    fill in vmtarget, vmindex while we have ctor in hand:                    
                </comment>
                <declaration name="typeInfo" type="Object[]" line="357"/>
            </method>
            <javadoc line="363">
                Create a name for the given reflected field.  The resulting name will be in a resolved state.                
            </javadoc>
            <method name="MemberName" type="constructor" line="364">
                <params>
                    <param name="fld" type="Field"/>
                </params>
                <comment line="367">
                    fill in vmtarget, vmindex while we have fld in hand:                    
                </comment>
            </method>
            <javadoc line="370">
                Create a name for the given class.  The resulting name will be in a resolved state.                
            </javadoc>
            <method name="MemberName" type="constructor" line="371">
                <params>
                    <param name="type" type="Class<?>"/>
                </params>
                <comment line="374">
                    isResolved                    
                </comment>
            </method>
            <method name="MemberName" type="constructor" line="378"/>
            <method name="clone" type="MemberName" line="381">
                <scope line="382"/>
                <scope line="384"/>
            </method>
            <javadoc line="392">
                Create a field or type name from the given components:  Declaring class, name, type, modifiers.
                  The declaring class may be supplied as null if this is to be a bare name and type.
                  The resulting name will in an unresolved state.                
            </javadoc>
            <method name="MemberName" type="constructor" line="396">
                <params>
                    <param name="defClass" type="Class<?>"/>
                    <param name="name" type="String"/>
                    <param name="type" type="Class<?>"/>
                    <param name="modifiers" type="int"/>
                </params>
            </method>
            <javadoc line="399">
                Create a field or type name from the given components:  Declaring class, name, type.
                  The declaring class may be supplied as null if this is to be a bare name and type.
                  The modifier flags default to zero.
                  The resulting name will in an unresolved state.                
            </javadoc>
            <method name="MemberName" type="constructor" line="404">
                <params>
                    <param name="defClass" type="Class<?>"/>
                    <param name="name" type="String"/>
                    <param name="type" type="Class<?>"/>
                </params>
            </method>
            <javadoc line="407">
                Create a method or constructor name from the given components:  Declaring class, name, type, modifiers.
                  It will be a constructor if and only if the name is {@code &quot;&amp;lt;init&amp;gt;&quot;}.
                  The declaring class may be supplied as null if this is to be a bare name and type.
                  The resulting name will in an unresolved state.                
            </javadoc>
            <method name="MemberName" type="constructor" line="412">
                <params>
                    <param name="defClass" type="Class<?>"/>
                    <param name="name" type="String"/>
                    <param name="type" type="MethodType"/>
                    <param name="modifiers" type="int"/>
                </params>
                <declaration name="flagBit" type="int" line="413"/>
            </method>
            <javadoc line="416">
                Create a method or constructor name from the given components:  Declaring class, name, type, modifiers.
                  It will be a constructor if and only if the name is {@code &quot;&amp;lt;init&amp;gt;&quot;}.
                  The declaring class may be supplied as null if this is to be a bare name and type.
                  The modifier flags default to zero.
                  The resulting name will in an unresolved state.                
            </javadoc>
            <method name="MemberName" type="constructor" line="422">
                <params>
                    <param name="defClass" type="Class<?>"/>
                    <param name="name" type="String"/>
                    <param name="type" type="MethodType"/>
                </params>
            </method>
            <javadoc line="426">
                Query whether this member name is resolved.
                  A resolved member name is one for which the JVM has found
                  a method, constructor, field, or type binding corresponding exactly to the name.
                  (Document?)                
            </javadoc>
            <method name="isResolved" type="boolean" line="431"/>
            <javadoc line="435">
                Query whether this member name is resolved to a non-static, non-final method.                
            </javadoc>
            <method name="hasReceiverTypeDispatch" type="boolean" line="437"/>
            <javadoc line="441">
                Produce a string form of this member name.
                  For types, it is simply the type&apos;s own string (as reported by {@code toString}).
                  For fields, it is {@code &quot;DeclaringClass.name/type&quot;}.
                  For methods and constructors, it is {@code &quot;DeclaringClass.name(ptype...)rtype&quot;}.
                  If the declaring class is null, the prefix {@code &quot;DeclaringClass.&quot;} is omitted.
                  If the member is unresolved, a prefix {@code &quot;.&quot;} is prepended.                
            </javadoc>
            <method name="toString" type="String" line="449">
                <comment line="452">
                    class java.lang.String                    
                </comment>
                <comment line="453">
                    else it is a field, method, or constructor                    
                </comment>
                <comment line="468">
                    buf.append(&apos;&apos;);
                     key: Public, private, pRotected, sTatic, Final, sYnchronized,
                     transientVarargs, native, (interface), abstract, sTrict, sYnthetic,
                     (annotation), Enum, (unused)
                    final String FIELD_MOD_CHARS  = &quot;PprTF?vt????Y?E?&quot;;
                    final String METHOD_MOD_CHARS = &quot;PprTFybVn?atY???&quot;;
                    String modChars = (isInvocable() ? METHOD_MOD_CHARS : FIELD_MOD_CHARS);
                    for (int i = 0; i &lt; modChars.length(); i++) {
                    if ((flags &amp; (1 &lt;&lt; i)) != 0) {
                    char mc = modChars.charAt(i);
                    if (mc != &apos;?&apos;)
                    buf.append(mc);
                    }
                    }                    
                </comment>
                <declaration name="buf" type="StringBuilder" line="453"/>
                <scope line="454"/>
                <declaration name="name" type="String" line="458"/>
                <declaration name="type" type="Object" line="460"/>
                <scope line="461"/>
                <scope line="464"/>
            </method>
            <method name="getName" type="String" line="485">
                <params>
                    <param name="obj" type="Object"/>
                </params>
            </method>
            <javadoc line="492">
                Document?                
            </javadoc>
            <method name="getVMIndex" type="int" line="493">
                <comment line="494">
                                        
                </comment>
            </method>
            <method name="makeAccessException" type="IllegalAccessException" line="504">
                <params>
                    <param name="message" type="String"/>
                    <param name="from" type="Object"/>
                </params>
            </method>
            <method name="message" type="String" line="509"/>
            <method name="makeAccessException" type="ReflectiveOperationException" line="519">
                <declaration name="message" type="String" line="520"/>
            </method>
            <javadoc line="531">
                Actually making a query requires an access check.                
            </javadoc>
            <method name="getFactory" type="Factory" line="532">
                <comment line="533">
                                        
                </comment>
            </method>
            <class name="Factory" line="535">
                <comment line="279">
                    method (not constructor)                    
                </comment>
                <comment line="280">
                    constructor                    
                </comment>
                <comment line="281">
                    field                    
                </comment>
                <comment line="283">
                    for MethodHandleNatives.getMembers                    
                </comment>
                <comment line="494">
                                        
                </comment>
                <comment line="533">
                                        
                </comment>
                <comment line="539">
                                        
                </comment>
                <comment line="540">
                    singleton pattern                    
                </comment>
                <comment line="545">
                    / Queries                    
                </comment>
                <javadoc line="535">
                    A factory type for resolving member names with the help of the VM.
                      TBD: Define access-safe public constructors for this factory.                    
                </javadoc>
                <method name="Factory" type="constructor" line="539"/>
                <declaration name="INSTANCE" type="Factory" line="540"/>
                <declaration name="ALLOWED_FLAGS" type="int" line="542"/>
                <method name="getMembers" type="List<MemberName>" line="547">
                    <params>
                        <param name="defc" type="Class<?>"/>
                        <param name="matchName" type="String"/>
                        <param name="matchType" type="Object"/>
                        <param name="matchFlags" type="int"/>
                        <param name="lookupClass" type="Class<?>"/>
                    </params>
                    <comment line="574">
                        JVM returned to us with an intentional overflow!                        
                    </comment>
                    <comment line="591">
                        Signature matching is not the same as type matching, since
                         one signature might correspond to several types.
                         So if matchType is a Class or MethodType, refilter the results.                        
                    </comment>
                    <declaration name="matchSig" type="String" line="549"/>
                    <scope line="550"/>
                    <declaration name="BUF_MAX" type="int" line="557"/>
                    <declaration name="len1" type="int" line="558"/>
                    <declaration name="buf" type="MemberName[]" line="559"/>
                    <declaration name="totalCount" type="int" line="560"/>
                    <declaration name="bufs" type="ArrayList&lt;MemberName[]&gt;" line="561"/>
                    <declaration name="bufCount" type="int" line="562"/>
                    <scope line="563">
                        <scope line="568"/>
                        <declaration name="excess" type="int" line="575"/>
                        <declaration name="len2" type="int" line="578"/>
                    </scope>
                    <declaration name="result" type="ArrayList&lt;MemberName&gt;" line="583"/>
                    <scope line="584">
                        <scope line="585"/>
                    </scope>
                    <scope line="593">
                        <scope line="594">
                            <declaration name="m" type="MemberName" line="595"/>
                        </scope>
                    </scope>
                </method>
                <method name="resolveInPlace" type="boolean" line="602">
                    <params>
                        <param name="m" type="MemberName"/>
                        <param name="searchSupers" type="boolean"/>
                        <param name="lookupClass" type="Class<?>"/>
                    </params>
                    <comment line="604">
                        find unique non-overloaded name                        
                    </comment>
                    <comment line="613">
                        System.out.println(&quot;resolving &quot;+m+&quot; to &quot;+choices);                        
                    </comment>
                    <scope line="603">
                        <declaration name="defc" type="Class&lt;?&gt;" line="604"/>
                        <declaration name="choices" type="List&lt;MemberName&gt;" line="605"/>
                    </scope>
                    <declaration name="matchFlags" type="int" line="620"/>
                    <declaration name="matchSig" type="String" line="621"/>
                    <declaration name="buf" type="MemberName[]" line="622"/>
                    <declaration name="n" type="int" line="623"/>
                </method>
                <javadoc line="628">
                    Produce a resolved version of the given member.
                      Super types are searched (for inherited members) if {@code searchSupers} is true.
                      Access checking is performed on behalf of the given {@code lookupClass}.
                      If lookup fails or access is not permitted, null is returned.
                      Otherwise a fresh copy of the given member is returned, with modifier bits filled in.                    
                </javadoc>
                <method name="resolveOrNull" type="MemberName" line="634">
                    <params>
                        <param name="m" type="MemberName"/>
                        <param name="searchSupers" type="boolean"/>
                        <param name="lookupClass" type="Class<?>"/>
                    </params>
                    <declaration name="result" type="MemberName" line="635"/>
                </method>
                <javadoc line="640">
                    Produce a resolved version of the given member.
                      Super types are searched (for inherited members) if {@code searchSupers} is true.
                      Access checking is performed on behalf of the given {@code lookupClass}.
                      If lookup fails or access is not permitted, a {@linkplain ReflectiveOperationException} is thrown.
                      Otherwise a fresh copy of the given member is returned, with modifier bits filled in.                    
                </javadoc>
                <method name="resolveOrFail" type="MemberName" line="650">
                    <params>
                        <param name="m" type="MemberName"/>
                        <param name="searchSupers" type="boolean"/>
                        <param name="lookupClass" type="Class<?>"/>
                        <param name="nsmClass" type="Class<NoSuchMemberException>"/>
                    </params>
                    <declaration name="result" type="MemberName" line="651"/>
                    <declaration name="ex" type="ReflectiveOperationException" line="654"/>
                </method>
                <javadoc line="658">
                    Return a list of all methods defined by the given class.
                      Super types are searched (for inherited members) if {@code searchSupers} is true.
                      Access checking is performed on behalf of the given {@code lookupClass}.
                      Inaccessible members are not added to the last.                    
                </javadoc>
                <method name="getMethods" type="List<MemberName>" line="664">
                    <params>
                        <param name="defc" type="Class<?>"/>
                        <param name="searchSupers" type="boolean"/>
                        <param name="lookupClass" type="Class<?>"/>
                    </params>
                </method>
                <javadoc line="667">
                    Return a list of matching methods defined by the given class.
                      Super types are searched (for inherited members) if {@code searchSupers} is true.
                      Returned methods will match the name (if not null) and the type (if not null).
                      Access checking is performed on behalf of the given {@code lookupClass}.
                      Inaccessible members are not added to the last.                    
                </javadoc>
                <method name="getMethods" type="List<MemberName>" line="674">
                    <params>
                        <param name="defc" type="Class<?>"/>
                        <param name="searchSupers" type="boolean"/>
                        <param name="name" type="String"/>
                        <param name="type" type="MethodType"/>
                        <param name="lookupClass" type="Class<?>"/>
                    </params>
                    <declaration name="matchFlags" type="int" line="675"/>
                </method>
                <javadoc line="678">
                    Return a list of all constructors defined by the given class.
                      Access checking is performed on behalf of the given {@code lookupClass}.
                      Inaccessible members are not added to the last.                    
                </javadoc>
                <method name="getConstructors" type="List<MemberName>" line="682">
                    <params>
                        <param name="defc" type="Class<?>"/>
                        <param name="lookupClass" type="Class<?>"/>
                    </params>
                </method>
                <javadoc line="685">
                    Return a list of all fields defined by the given class.
                      Super types are searched (for inherited members) if {@code searchSupers} is true.
                      Access checking is performed on behalf of the given {@code lookupClass}.
                      Inaccessible members are not added to the last.                    
                </javadoc>
                <method name="getFields" type="List<MemberName>" line="691">
                    <params>
                        <param name="defc" type="Class<?>"/>
                        <param name="searchSupers" type="boolean"/>
                        <param name="lookupClass" type="Class<?>"/>
                    </params>
                </method>
                <javadoc line="694">
                    Return a list of all fields defined by the given class.
                      Super types are searched (for inherited members) if {@code searchSupers} is true.
                      Returned fields will match the name (if not null) and the type (if not null).
                      Access checking is performed on behalf of the given {@code lookupClass}.
                      Inaccessible members are not added to the last.                    
                </javadoc>
                <method name="getFields" type="List<MemberName>" line="701">
                    <params>
                        <param name="defc" type="Class<?>"/>
                        <param name="searchSupers" type="boolean"/>
                        <param name="name" type="String"/>
                        <param name="type" type="Class<?>"/>
                        <param name="lookupClass" type="Class<?>"/>
                    </params>
                    <declaration name="matchFlags" type="int" line="702"/>
                </method>
                <javadoc line="705">
                    Return a list of all nested types defined by the given class.
                      Super types are searched (for inherited members) if {@code searchSupers} is true.
                      Access checking is performed on behalf of the given {@code lookupClass}.
                      Inaccessible members are not added to the last.                    
                </javadoc>
                <method name="getNestedTypes" type="List<MemberName>" line="711">
                    <params>
                        <param name="defc" type="Class<?>"/>
                        <param name="searchSupers" type="boolean"/>
                        <param name="lookupClass" type="Class<?>"/>
                    </params>
                    <declaration name="matchFlags" type="int" line="712"/>
                </method>
                <method name="newMemberBuffer" type="MemberName[]" line="715">
                    <params>
                        <param name="length" type="int"/>
                    </params>
                    <comment line="718">
                        fill the buffer with dummy structs for the JVM to fill in                        
                    </comment>
                    <declaration name="buf" type="MemberName[]" line="716"/>
                </method>
            </class>
        </class>
    </source>