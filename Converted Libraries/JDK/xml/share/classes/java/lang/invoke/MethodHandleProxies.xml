<?xml version="1.0" encoding="UTF-8"?>
    <source package="java.lang.invoke">
        <import package="java.lang.reflect"/>
        <import package="sun.invoke.WrapperInstance"/>
        <class name="MethodHandleProxies" line="31">
            <comment line="38">
                do not instantiate                
            </comment>
            <javadoc line="31">
                This class consists exclusively of static methods that help adapt
                  method handles to other JVM types, such as interfaces.                
            </javadoc>
            <method name="MethodHandleProxies" type="constructor" line="37"/>
            <javadoc line="39">
                Produces an instance of the given single-method interface which redirects
                  its calls to the given method handle.
                  &lt;p&gt;
                  A single-method interface is an interface which declares a uniquely named method.
                  When determining the uniquely named method of a single-method interface,
                  the public {@code Object} methods ({@code toString}, {@code equals}, {@code hashCode})
                  are disregarded.  For example, {@link java.util.Comparator} is a single-method interface,
                  even though it re-declares the {@code Object.equals} method.
                  &lt;p&gt;
                  The interface must be public.  No additional access checks are performed.
                  &lt;p&gt;
                  The resulting instance of the required type will respond to
                  invocation of the type&apos;s uniquely named method by calling
                  the given target on the incoming arguments,
                  and returning or throwing whatever the target
                  returns or throws.  The invocation will be as if by{@code target.invoke}.
                  The target&apos;s type will be checked before the
                  instance is created, as if by a call to {@code asType},
                  which may result in a {@code WrongMethodTypeException}.
                  &lt;p&gt;
                  The uniquely named method is allowed to be multiply declared,
                  with distinct type descriptors.  (E.g., it can be overloaded,
                  or can possess bridge methods.)  All such declarations are
                  connected directly to the target method handle.
                  Argument and return types are adjusted by {@code asType}for each individual declaration.
                  &lt;p&gt;
                  The wrapper instance will implement the requested interface
                  and its super-types, but no other single-method interfaces.
                  This means that the instance will not unexpectedly
                  pass an {@code instanceof} test for any unrequested type.
                  &lt;p style=&quot;font-size:smaller;&quot;&gt;
                  &lt;em&gt;Implementation Note:&lt;/em&gt;
                  Therefore, each instance must implement a unique single-method interface.
                  Implementations may not bundle together
                  multiple single-method interfaces onto single implementation classes
                  in the style of {@link java.awt.AWTEventMulticaster}.
                  &lt;p&gt;
                  The method handle may throw an &lt;em&gt;undeclared exception&lt;/em&gt;,
                  which means any checked exception (or other checked throwable)
                  not declared by the requested type&apos;s single abstract method.
                  If this happens, the throwable will be wrapped in an instance of{@link java.lang.reflect.UndeclaredThrowableException UndeclaredThrowableException}and thrown in that wrapped form.
                  &lt;p&gt;
                  Like {@link java.lang.Integer#valueOf Integer.valueOf},{@code asInterfaceInstance} is a factory method whose results are defined
                  by their behavior.
                  It is not guaranteed to return a new instance for every call.
                  &lt;p&gt;
                  Because of the possibility of {@linkplain java.lang.reflect.Method#isBridge bridge methods}and other corner cases, the interface may also have several abstract methods
                  with the same name but having distinct descriptors (types of returns and parameters).
                  In this case, all the methods are bound in common to the one given target.
                  The type check and effective {@code asType} conversion is applied to each
                  method type descriptor, and all abstract methods are bound to the target in common.
                  Beyond this type check, no further checks are made to determine that the
                  abstract methods are related in any way.
                  &lt;p&gt;
                  Future versions of this API may accept additional types,
                  such as abstract classes with single abstract methods.
                  Future versions of this API may also equip wrapper instances
                  with one or more additional public &quot;marker&quot; interfaces.                
                <param>
                    target the method handle to invoke from the wrapper                    
                </param>
                <param>
                    intfc the desired type of the wrapper, a single-method interface                    
                </param>
                <return>
                    a correctly-typed wrapper for the given target                    
                </return>
                <throws>
                    NullPointerException if either argument is null                    
                </throws>
                <throws>
                    IllegalArgumentException if the {@code intfc} is not a
                      valid argument to this method                    
                </throws>
                <throws>
                    WrongMethodTypeException if the target cannot
                      be converted to the type required by the requested interface                    
                </throws>
            </javadoc>
            <method name="asInterfaceInstance" type="T" line="136">
                <params>
                    <param name="intfc" type="Class<T>"/>
                    <param name="target" type="MethodHandle"/>
                </params>
                <comment line="115">
                    Other notes to implementors:
                     &lt;p&gt;
                     No stable mapping is promised between the single-method interface and
                     the implementation class C.  Over time, several implementation
                     classes might be used for the same type.
                     &lt;p&gt;
                     If the implementation is able
                     to prove that a wrapper of the required type
                     has already been created for a given
                     method handle, or for another method handle with the
                     same behavior, the implementation may return that wrapper in place of
                     a new wrapper.
                     &lt;p&gt;
                     This method is designed to apply to common use cases
                     where a single method handle must interoperate with
                     an interface that implements a function-like
                     API.  Additional variations, such as single-abstract-method classes with
                     private constructors, or interfaces with multiple but related
                     entry points, must be covered by hand-written or automatically
                     generated adapter classes.                    
                </comment>
                <comment line="138">
                    POC implementation only; violates the above contract several ways                    
                </comment>
                <comment line="143">
                    make throw WMT                    
                </comment>
                <declaration name="sm" type="Method" line="138"/>
                <declaration name="smMT" type="MethodType" line="141"/>
                <declaration name="checkTarget" type="MethodHandle" line="142"/>
                <declaration name="vaTarget" type="MethodHandle" line="144"/>
                <anonymous_class line="148">
                    <method name="getArg" type="Object" line="149">
                        <params>
                            <param name="name" type="String"/>
                        </params>
                    </method>
                    <method name="invoke" type="Object" line="154">
                        <params>
                            <param name="proxy" type="Object"/>
                            <param name="method" type="Method"/>
                            <param name="args" type="Object[]"/>
                        </params>
                    </method>
                </anonymous_class>
            </method>
            <javadoc line="166">
                Determines if the given object was produced by a call to {@link #asInterfaceInstance asInterfaceInstance}.                
                <param>
                    x any reference                    
                </param>
                <return>
                    true if the reference is not null and points to an object produced by {@code asInterfaceInstance}                    
                </return>
            </javadoc>
            <method name="isWrapperInstance" type="boolean" line="172">
                <params>
                    <param name="x" type="Object"/>
                </params>
            </method>
            <method name="asWrapperInstance" type="WrapperInstance" line="176">
                <params>
                    <param name="x" type="Object"/>
                </params>
                <scope line="177"/>
                <scope line="180"/>
            </method>
            <javadoc line="185">
                Produces or recovers a target method handle which is behaviorally
                  equivalent to the unique method of this wrapper instance.
                  The object {@code x} must have been produced by a call to {@link #asInterfaceInstance asInterfaceInstance}.
                  This requirement may be tested via {@link #isWrapperInstance isWrapperInstance}.                
                <param>
                    x any reference                    
                </param>
                <return>
                    a method handle implementing the unique method                    
                </return>
                <throws>
                    IllegalArgumentException if the reference x is not to a wrapper instance                    
                </throws>
            </javadoc>
            <method name="wrapperInstanceTarget" type="MethodHandle" line="195">
                <params>
                    <param name="x" type="Object"/>
                </params>
            </method>
            <javadoc line="199">
                Recovers the unique single-method interface type for which this wrapper instance was created.
                  The object {@code x} must have been produced by a call to {@link #asInterfaceInstance asInterfaceInstance}.
                  This requirement may be tested via {@link #isWrapperInstance isWrapperInstance}.                
                <param>
                    x any reference                    
                </param>
                <return>
                    the single-method interface type for which the wrapper was created                    
                </return>
                <throws>
                    IllegalArgumentException if the reference x is not to a wrapper instance                    
                </throws>
            </javadoc>
            <method name="wrapperInstanceType" type="Class<?>" line="208">
                <params>
                    <param name="x" type="Object"/>
                </params>
            </method>
            <method name="isObjectMethod" type="boolean" line="213">
                <params>
                    <param name="m" type="Method"/>
                </params>
            </method>
            <method name="callObjectMethod" type="Object" line="230">
                <params>
                    <param name="self" type="Object"/>
                    <param name="m" type="Method"/>
                    <param name="args" type="Object[]"/>
                </params>
            </method>
            <method name="getSingleMethod" type="Method" line="244">
                <params>
                    <param name="intfc" type="Class<?>"/>
                </params>
                <comment line="252">
                    too many abstract methods                    
                </comment>
                <declaration name="sm" type="Method" line="246"/>
                <scope line="247">
                    <declaration name="mod" type="int" line="248"/>
                    <scope line="249"/>
                </scope>
            </method>
        </class>
    </source>