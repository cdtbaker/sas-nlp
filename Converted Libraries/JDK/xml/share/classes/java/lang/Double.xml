<?xml version="1.0" encoding="UTF-8"?>
    <source package="java.lang">
        <import package="sun.misc.FloatingDecimal"/>
        <import package="sun.misc.FpUtils"/>
        <import package="sun.misc.DoubleConsts"/>
        <class name="Double" line="32">
            <extends class="Number"/>
            <comment line="80">
                1.7976931348623157e+308                
            </comment>
            <comment line="90">
                2.2250738585072014E-308                
            </comment>
            <comment line="99">
                4.9e-324                
            </comment>
            <implements interface="Comparable">
                <type_params>
                    <type_param name="Double"/>
                </type_params>
            </implements>
            <javadoc line="32">
                The {@code Double} class wraps a value of the primitive type{@code double} in an object. An object of type{@code Double} contains a single field whose type is{@code double}.
                  &lt;p&gt;In addition, this class provides several methods for converting a{@code double} to a {@code String} and a{@code String} to a {@code double}, as well as other
                  constants and methods useful when dealing with a{@code double}.                
                <author>
                    Lee Boynton                    
                </author>
                <author>
                    Arthur van Hoff                    
                </author>
                <author>
                    Joseph D. Darcy                    
                </author>
                <since>
                    JDK1.0                    
                </since>
            </javadoc>
            <declaration name="POSITIVE_INFINITY" type="double" line="50"/>
            <javadoc line="50">
                A constant holding the positive infinity of type{@code double}. It is equal to the value returned by{@code Double.longBitsToDouble(0x7ff0000000000000L)}.                
            </javadoc>
            <declaration name="NEGATIVE_INFINITY" type="double" line="57"/>
            <javadoc line="57">
                A constant holding the negative infinity of type{@code double}. It is equal to the value returned by{@code Double.longBitsToDouble(0xfff0000000000000L)}.                
            </javadoc>
            <declaration name="NaN" type="double" line="64"/>
            <javadoc line="64">
                A constant holding a Not-a-Number (NaN) value of type{@code double}. It is equivalent to the value returned by{@code Double.longBitsToDouble(0x7ff8000000000000L)}.                
            </javadoc>
            <declaration name="MAX_VALUE" type="double" line="71"/>
            <javadoc line="71">
                A constant holding the largest positive finite value of type{@code double},
                  (2-2&lt;sup&gt;-52&lt;/sup&gt;)&amp;middot;2&lt;sup&gt;1023&lt;/sup&gt;.  It is equal to
                  the hexadecimal floating-point literal{@code 0x1.fffffffffffffP+1023} and also equal to{@code Double.longBitsToDouble(0x7fefffffffffffffL)}.                
            </javadoc>
            <declaration name="MIN_NORMAL" type="double" line="81"/>
            <javadoc line="81">
                A constant holding the smallest positive normal value of type{@code double}, 2&lt;sup&gt;-1022&lt;/sup&gt;.  It is equal to the
                  hexadecimal floating-point literal {@code 0x1.0p-1022} and also
                  equal to {@code Double.longBitsToDouble(0x0010000000000000L)}.                
                <since>
                    1.6                    
                </since>
            </javadoc>
            <declaration name="MIN_VALUE" type="double" line="91"/>
            <javadoc line="91">
                A constant holding the smallest positive nonzero value of type{@code double}, 2&lt;sup&gt;-1074&lt;/sup&gt;. It is equal to the
                  hexadecimal floating-point literal{@code 0x0.0000000000001P-1022} and also equal to{@code Double.longBitsToDouble(0x1L)}.                
            </javadoc>
            <declaration name="MAX_EXPONENT" type="int" line="100"/>
            <javadoc line="100">
                Maximum exponent a finite {@code double} variable may have.
                  It is equal to the value returned by{@code Math.getExponent(Double.MAX_VALUE)}.                
                <since>
                    1.6                    
                </since>
            </javadoc>
            <declaration name="MIN_EXPONENT" type="int" line="109"/>
            <javadoc line="109">
                Minimum exponent a normalized {@code double} variable may
                  have.  It is equal to the value returned by{@code Math.getExponent(Double.MIN_NORMAL)}.                
                <since>
                    1.6                    
                </since>
            </javadoc>
            <declaration name="SIZE" type="int" line="118"/>
            <javadoc line="118">
                The number of bits used to represent a {@code double} value.                
                <since>
                    1.5                    
                </since>
            </javadoc>
            <declaration name="TYPE" type="Class&lt;Double&gt;" line="125"/>
            <javadoc line="125">
                The {@code Class} instance representing the primitive type{@code double}.                
                <since>
                    JDK1.1                    
                </since>
            </javadoc>
            <javadoc line="133">
                Returns a string representation of the {@code double}argument. All characters mentioned below are ASCII characters.
                  &lt;ul&gt;
                  &lt;li&gt;If the argument is NaN, the result is the string
                  &quot;{@code NaN}&quot;.
                  &lt;li&gt;Otherwise, the result is a string that represents the sign and
                  magnitude (absolute value) of the argument. If the sign is negative,
                  the first character of the result is &apos;{@code -}&apos;
                  (&lt;code&gt;&apos;&amp;#92;u002D&apos;&lt;/code&gt;); if the sign is positive, no sign character
                  appears in the result. As for the magnitude &lt;i&gt;m&lt;/i&gt;:
                  &lt;ul&gt;
                  &lt;li&gt;If &lt;i&gt;m&lt;/i&gt; is infinity, it is represented by the characters{@code &quot;Infinity&quot;}; thus, positive infinity produces the result{@code &quot;Infinity&quot;} and negative infinity produces the result{@code &quot;-Infinity&quot;}.
                  &lt;li&gt;If &lt;i&gt;m&lt;/i&gt; is zero, it is represented by the characters{@code &quot;0.0&quot;}; thus, negative zero produces the result{@code &quot;-0.0&quot;} and positive zero produces the result{@code &quot;0.0&quot;}.
                  &lt;li&gt;If &lt;i&gt;m&lt;/i&gt; is greater than or equal to 10&lt;sup&gt;-3&lt;/sup&gt; but less
                  than 10&lt;sup&gt;7&lt;/sup&gt;, then it is represented as the integer part of
                  &lt;i&gt;m&lt;/i&gt;, in decimal form with no leading zeroes, followed by
                  &apos;{@code .}&apos; (&lt;code&gt;&apos;&amp;#92;u002E&apos;&lt;/code&gt;), followed by one or
                  more decimal digits representing the fractional part of &lt;i&gt;m&lt;/i&gt;.
                  &lt;li&gt;If &lt;i&gt;m&lt;/i&gt; is less than 10&lt;sup&gt;-3&lt;/sup&gt; or greater than or
                  equal to 10&lt;sup&gt;7&lt;/sup&gt;, then it is represented in so-called
                  &quot;computerized scientific notation.&quot; Let &lt;i&gt;n&lt;/i&gt; be the unique
                  integer such that 10&lt;sup&gt;&lt;i&gt;n&lt;/i&gt;&lt;/sup&gt; &amp;le; &lt;i&gt;m&lt;/i&gt; {@literal &lt;}10&lt;sup&gt;&lt;i&gt;n&lt;/i&gt;+1&lt;/sup&gt;; then let &lt;i&gt;a&lt;/i&gt; be the
                  mathematically exact quotient of &lt;i&gt;m&lt;/i&gt; and
                  10&lt;sup&gt;&lt;i&gt;n&lt;/i&gt;&lt;/sup&gt; so that 1 &amp;le; &lt;i&gt;a&lt;/i&gt; {@literal &lt;} 10. The
                  magnitude is then represented as the integer part of &lt;i&gt;a&lt;/i&gt;,
                  as a single decimal digit, followed by &apos;{@code .}&apos;
                  (&lt;code&gt;&apos;&amp;#92;u002E&apos;&lt;/code&gt;), followed by decimal digits
                  representing the fractional part of &lt;i&gt;a&lt;/i&gt;, followed by the
                  letter &apos;{@code E}&apos; (&lt;code&gt;&apos;&amp;#92;u0045&apos;&lt;/code&gt;), followed
                  by a representation of &lt;i&gt;n&lt;/i&gt; as a decimal integer, as
                  produced by the method {@link Integer#toString(int)}.
                  &lt;/ul&gt;
                  &lt;/ul&gt;
                  How many digits must be printed for the fractional part of
                  &lt;i&gt;m&lt;/i&gt; or &lt;i&gt;a&lt;/i&gt;? There must be at least one digit to represent
                  the fractional part, and beyond that as many, but only as many, more
                  digits as are needed to uniquely distinguish the argument value from
                  adjacent values of type {@code double}. That is, suppose that
                  &lt;i&gt;x&lt;/i&gt; is the exact mathematical value represented by the decimal
                  representation produced by this method for a finite nonzero argument
                  &lt;i&gt;d&lt;/i&gt;. Then &lt;i&gt;d&lt;/i&gt; must be the {@code double} value nearest
                  to &lt;i&gt;x&lt;/i&gt;; or if two {@code double} values are equally close
                  to &lt;i&gt;x&lt;/i&gt;, then &lt;i&gt;d&lt;/i&gt; must be one of them and the least
                  significant bit of the significand of &lt;i&gt;d&lt;/i&gt; must be {@code 0}.
                  &lt;p&gt;To create localized string representations of a floating-point
                  value, use subclasses of {@link java.text.NumberFormat}.                
                <param>
                    d   the {@code double} to be converted.                    
                </param>
                <return>
                    a string representation of the argument.                    
                </return>
            </javadoc>
            <method name="toString" type="String" line="195">
                <params>
                    <param name="d" type="double"/>
                </params>
            </method>
            <javadoc line="199">
                Returns a hexadecimal string representation of the{@code double} argument. All characters mentioned below
                  are ASCII characters.
                  &lt;ul&gt;
                  &lt;li&gt;If the argument is NaN, the result is the string
                  &quot;{@code NaN}&quot;.
                  &lt;li&gt;Otherwise, the result is a string that represents the sign
                  and magnitude of the argument. If the sign is negative, the
                  first character of the result is &apos;{@code -}&apos;
                  (&lt;code&gt;&apos;&amp;#92;u002D&apos;&lt;/code&gt;); if the sign is positive, no sign
                  character appears in the result. As for the magnitude &lt;i&gt;m&lt;/i&gt;:
                  &lt;ul&gt;
                  &lt;li&gt;If &lt;i&gt;m&lt;/i&gt; is infinity, it is represented by the string{@code &quot;Infinity&quot;}; thus, positive infinity produces the
                  result {@code &quot;Infinity&quot;} and negative infinity produces
                  the result {@code &quot;-Infinity&quot;}.
                  &lt;li&gt;If &lt;i&gt;m&lt;/i&gt; is zero, it is represented by the string{@code &quot;0x0.0p0&quot;}; thus, negative zero produces the result{@code &quot;-0x0.0p0&quot;} and positive zero produces the result{@code &quot;0x0.0p0&quot;}.
                  &lt;li&gt;If &lt;i&gt;m&lt;/i&gt; is a {@code double} value with a
                  normalized representation, substrings are used to represent the
                  significand and exponent fields.  The significand is
                  represented by the characters {@code &quot;0x1.&quot;}followed by a lowercase hexadecimal representation of the rest
                  of the significand as a fraction.  Trailing zeros in the
                  hexadecimal representation are removed unless all the digits
                  are zero, in which case a single zero is used. Next, the
                  exponent is represented by {@code &quot;p&quot;} followed
                  by a decimal string of the unbiased exponent as if produced by
                  a call to {@link Integer#toString(int) Integer.toString} on the
                  exponent value.
                  &lt;li&gt;If &lt;i&gt;m&lt;/i&gt; is a {@code double} value with a subnormal
                  representation, the significand is represented by the
                  characters {@code &quot;0x0.&quot;} followed by a
                  hexadecimal representation of the rest of the significand as a
                  fraction.  Trailing zeros in the hexadecimal representation are
                  removed. Next, the exponent is represented by{@code &quot;p-1022&quot;}.  Note that there must be at
                  least one nonzero digit in a subnormal significand.
                  &lt;/ul&gt;
                  &lt;/ul&gt;
                  &lt;table border&gt;
                  &lt;caption&gt;&lt;h3&gt;Examples&lt;/h3&gt;&lt;/caption&gt;
                  &lt;tr&gt;&lt;th&gt;Floating-point Value&lt;/th&gt;&lt;th&gt;Hexadecimal String&lt;/th&gt;
                  &lt;tr&gt;&lt;td&gt;{@code 1.0}&lt;/td&gt; &lt;td&gt;{@code 0x1.0p0}&lt;/td&gt;
                  &lt;tr&gt;&lt;td&gt;{@code -1.0}&lt;/td&gt;        &lt;td&gt;{@code -0x1.0p0}&lt;/td&gt;
                  &lt;tr&gt;&lt;td&gt;{@code 2.0}&lt;/td&gt; &lt;td&gt;{@code 0x1.0p1}&lt;/td&gt;
                  &lt;tr&gt;&lt;td&gt;{@code 3.0}&lt;/td&gt; &lt;td&gt;{@code 0x1.8p1}&lt;/td&gt;
                  &lt;tr&gt;&lt;td&gt;{@code 0.5}&lt;/td&gt; &lt;td&gt;{@code 0x1.0p-1}&lt;/td&gt;
                  &lt;tr&gt;&lt;td&gt;{@code 0.25}&lt;/td&gt;        &lt;td&gt;{@code 0x1.0p-2}&lt;/td&gt;
                  &lt;tr&gt;&lt;td&gt;{@code Double.MAX_VALUE}&lt;/td&gt;
                  &lt;td&gt;{@code 0x1.fffffffffffffp1023}&lt;/td&gt;
                  &lt;tr&gt;&lt;td&gt;{@code Minimum Normal Value}&lt;/td&gt;
                  &lt;td&gt;{@code 0x1.0p-1022}&lt;/td&gt;
                  &lt;tr&gt;&lt;td&gt;{@code Maximum Subnormal Value}&lt;/td&gt;
                  &lt;td&gt;{@code 0x0.fffffffffffffp-1022}&lt;/td&gt;
                  &lt;tr&gt;&lt;td&gt;{@code Double.MIN_VALUE}&lt;/td&gt;
                  &lt;td&gt;{@code 0x0.0000000000001p-1022}&lt;/td&gt;
                  &lt;/table&gt;                
                <param>
                    d   the {@code double} to be converted.                    
                </param>
                <return>
                    a hex string representation of the argument.                    
                </return>
                <since>
                    1.5                    
                </since>
                <author>
                    Joseph D. Darcy                    
                </author>
            </javadoc>
            <method name="toHexString" type="String" line="273">
                <params>
                    <param name="d" type="double"/>
                </params>
                <comment line="275">
                    Modeled after the &quot;a&quot; conversion specifier in C99, section
                     7.19.6.1; however, the output of this method is more
                     tightly specified.                    
                </comment>
                <comment line="281">
                    For infinity and NaN, use the decimal output.                    
                </comment>
                <comment line="284">
                    Initialized to maximum size of output.                    
                </comment>
                <comment line="287">
                    value is negative,                    
                </comment>
                <comment line="288">
                    so append sign info                    
                </comment>
                <comment line="300">
                    Isolate significand bits and OR in a high-order bit
                     so that the string representation has a known
                     length.                    
                </comment>
                <comment line="307">
                    Subnormal values have a 0 implicit bit; normal
                     values have a 1 implicit bit.                    
                </comment>
                <comment line="311">
                    Isolate the low-order 13 digits of the hex
                     representation.  If all the digits are zero,
                     replace with a single 0; otherwise, remove all
                     trailing zeros.                    
                </comment>
                <comment line="316">
                    13 zeros                    
                </comment>
                <comment line="320">
                    If the value is subnormal, use the E_min exponent
                     value for double; otherwise, extract and report d&apos;s
                     exponent (the representation of a subnormal uses
                     E_min -1).                    
                </comment>
                <scope line="282">
                    <declaration name="answer" type="StringBuffer" line="284"/>
                    <scope line="293"/>
                    <scope line="296">
                        <declaration name="subnormal" type="boolean" line="297"/>
                        <declaration name="signifBits" type="long" line="302"/>
                        <declaration name="signif" type="String" line="314"/>
                    </scope>
                </scope>
            </method>
            <javadoc line="331">
                Returns a {@code Double} object holding the{@code double} value represented by the argument string{@code s}.
                  &lt;p&gt;If {@code s} is {@code null}, then a{@code NullPointerException} is thrown.
                  &lt;p&gt;Leading and trailing whitespace characters in {@code s}are ignored.  Whitespace is removed as if by the {@link String#trim} method; that is, both ASCII space and control
                  characters are removed. The rest of {@code s} should
                  constitute a &lt;i&gt;FloatValue&lt;/i&gt; as described by the lexical
                  syntax rules:
                  &lt;blockquote&gt;
                  &lt;dl&gt;
                  &lt;dt&gt;&lt;i&gt;FloatValue:&lt;/i&gt;
                  &lt;dd&gt;&lt;i&gt;Sign&lt;sub&gt;opt&lt;/sub&gt;&lt;/i&gt; {@code NaN}&lt;dd&gt;&lt;i&gt;Sign&lt;sub&gt;opt&lt;/sub&gt;&lt;/i&gt; {@code Infinity}&lt;dd&gt;&lt;i&gt;Sign&lt;sub&gt;opt&lt;/sub&gt; FloatingPointLiteral&lt;/i&gt;
                  &lt;dd&gt;&lt;i&gt;Sign&lt;sub&gt;opt&lt;/sub&gt; HexFloatingPointLiteral&lt;/i&gt;
                  &lt;dd&gt;&lt;i&gt;SignedInteger&lt;/i&gt;
                  &lt;/dl&gt;
                  &lt;p&gt;
                  &lt;dl&gt;
                  &lt;dt&gt;&lt;i&gt;HexFloatingPointLiteral&lt;/i&gt;:
                  &lt;dd&gt; &lt;i&gt;HexSignificand BinaryExponent FloatTypeSuffix&lt;sub&gt;opt&lt;/sub&gt;&lt;/i&gt;
                  &lt;/dl&gt;
                  &lt;p&gt;
                  &lt;dl&gt;
                  &lt;dt&gt;&lt;i&gt;HexSignificand:&lt;/i&gt;
                  &lt;dd&gt;&lt;i&gt;HexNumeral&lt;/i&gt;
                  &lt;dd&gt;&lt;i&gt;HexNumeral&lt;/i&gt; {@code .}&lt;dd&gt;{@code 0x} &lt;i&gt;HexDigits&lt;sub&gt;opt&lt;/sub&gt;
                  &lt;/i&gt;{@code .}&lt;i&gt; HexDigits&lt;/i&gt;
                  &lt;dd&gt;{@code 0X}&lt;i&gt; HexDigits&lt;sub&gt;opt&lt;/sub&gt;
                  &lt;/i&gt;{@code .} &lt;i&gt;HexDigits&lt;/i&gt;
                  &lt;/dl&gt;
                  &lt;p&gt;
                  &lt;dl&gt;
                  &lt;dt&gt;&lt;i&gt;BinaryExponent:&lt;/i&gt;
                  &lt;dd&gt;&lt;i&gt;BinaryExponentIndicator SignedInteger&lt;/i&gt;
                  &lt;/dl&gt;
                  &lt;p&gt;
                  &lt;dl&gt;
                  &lt;dt&gt;&lt;i&gt;BinaryExponentIndicator:&lt;/i&gt;
                  &lt;dd&gt;{@code p}&lt;dd&gt;{@code P}&lt;/dl&gt;
                  &lt;/blockquote&gt;
                  where &lt;i&gt;Sign&lt;/i&gt;, &lt;i&gt;FloatingPointLiteral&lt;/i&gt;,
                  &lt;i&gt;HexNumeral&lt;/i&gt;, &lt;i&gt;HexDigits&lt;/i&gt;, &lt;i&gt;SignedInteger&lt;/i&gt; and
                  &lt;i&gt;FloatTypeSuffix&lt;/i&gt; are as defined in the lexical structure
                  sections of
                  &lt;cite&gt;The Java&amp;trade; Language Specification&lt;/cite&gt;,
                  except that underscores are not accepted between digits.
                  If {@code s} does not have the form of
                  a &lt;i&gt;FloatValue&lt;/i&gt;, then a {@code NumberFormatException}is thrown. Otherwise, {@code s} is regarded as
                  representing an exact decimal value in the usual
                  &quot;computerized scientific notation&quot; or as an exact
                  hexadecimal value; this exact numerical value is then
                  conceptually converted to an &quot;infinitely precise&quot;
                  binary value that is then rounded to type {@code double}by the usual round-to-nearest rule of IEEE 754 floating-point
                  arithmetic, which includes preserving the sign of a zero
                  value.
                  Note that the round-to-nearest rule also implies overflow and
                  underflow behaviour; if the exact value of {@code s} is large
                  enough in magnitude (greater than or equal to ({@link #MAX_VALUE} + {@link Math#ulp(double) ulp(MAX_VALUE)}/2),
                  rounding to {@code double} will result in an infinity and if the
                  exact value of {@code s} is small enough in magnitude (less
                  than or equal to {@link #MIN_VALUE}/2), rounding to float will
                  result in a zero.
                  Finally, after rounding a {@code Double} object representing
                  this {@code double} value is returned.
                  &lt;p&gt; To interpret localized string representations of a
                  floating-point value, use subclasses of {@link java.text.NumberFormat}.
                  &lt;p&gt;Note that trailing format specifiers, specifiers that
                  determine the type of a floating-point literal
                  ({@code 1.0f} is a {@code float} value;{@code 1.0d} is a {@code double} value), do
                  &lt;em&gt;not&lt;/em&gt; influence the results of this method.  In other
                  words, the numerical value of the input string is converted
                  directly to the target floating-point type.  The two-step
                  sequence of conversions, string to {@code float} followed
                  by {@code float} to {@code double}, is &lt;em&gt;not&lt;/em&gt;
                  equivalent to converting a string directly to{@code double}. For example, the {@code float}literal {@code 0.1f} is equal to the {@code double}value {@code 0.10000000149011612}; the {@code float}literal {@code 0.1f} represents a different numerical
                  value than the {@code double} literal{@code 0.1}. (The numerical value 0.1 cannot be exactly
                  represented in a binary floating-point number.)
                  &lt;p&gt;To avoid calling this method on an invalid string and having
                  a {@code NumberFormatException} be thrown, the regular
                  expression below can be used to screen the input string:
                  &lt;code&gt;
                  &lt;pre&gt;
                  final String Digits     = &quot;(\\p{Digit}+)&quot;;
                  final String HexDigits  = &quot;(\\p{XDigit}+)&quot;;
                  // an exponent is &apos;e&apos; or &apos;E&apos; followed by an optionally
                  // signed decimal integer.
                  final String Exp        = &quot;[eE][+-]?&quot;+Digits;
                  final String fpRegex    =
                  (&quot;[\\x00-\\x20]&quot;+  // Optional leading &quot;whitespace&quot;
                  &quot;[+-]?(&quot; + // Optional sign character
                  &quot;NaN|&quot; +           // &quot;NaN&quot; string
                  &quot;Infinity|&quot; +      // &quot;Infinity&quot; string
                  // A decimal floating-point string representing a finite positive
                  // number without a leading sign has at most five basic pieces:
                  // Digits . Digits ExponentPart FloatTypeSuffix
                  //
                  // Since this method allows integer-only strings as input
                  // in addition to strings of floating-point literals, the
                  // two sub-patterns below are simplifications of the grammar
                  // productions from section 3.10.2 of
                  // &lt;cite&gt;The Java&amp;trade; Language Specification&lt;/cite&gt;.
                  // Digits ._opt Digits_opt ExponentPart_opt FloatTypeSuffix_opt
                  &quot;(((&quot;+Digits+&quot;(\\.)?(&quot;+Digits+&quot;?)(&quot;+Exp+&quot;)?)|&quot;+
                  // . Digits ExponentPart_opt FloatTypeSuffix_opt
                  &quot;(\\.(&quot;+Digits+&quot;)(&quot;+Exp+&quot;)?)|&quot;+
                  // Hexadecimal strings
                  &quot;((&quot; +
                  // 0[xX] HexDigits ._opt BinaryExponent FloatTypeSuffix_opt
                  &quot;(0[xX]&quot; + HexDigits + &quot;(\\.)?)|&quot; +
                  // 0[xX] HexDigits_opt . HexDigits BinaryExponent FloatTypeSuffix_opt
                  &quot;(0[xX]&quot; + HexDigits + &quot;?(\\.)&quot; + HexDigits + &quot;)&quot; +
                  &quot;)[pP][+-]?&quot; + Digits + &quot;))&quot; +
                  &quot;[fFdD]?))&quot; +
                  &quot;[\\x00-\\x20]&quot;);// Optional trailing &quot;whitespace&quot;
                  if (Pattern.matches(fpRegex, myString))
                  Double.valueOf(myString); // Will not throw NumberFormatException
                  else {
                  // Perform suitable alternative action
                  }
                  &lt;/pre&gt;
                  &lt;/code&gt;                
                <param>
                    s   the string to be parsed.                    
                </param>
                <return>
                    a {@code Double} object holding the value
                      represented by the {@code String} argument.                    
                </return>
                <throws>
                    NumberFormatException  if the string does not contain a
                      parsable number.                    
                </throws>
            </javadoc>
            <method name="valueOf" type="Double" line="503">
                <params>
                    <param name="s" type="String"/>
                </params>
            </method>
            <javadoc line="507">
                Returns a {@code Double} instance representing the specified{@code double} value.
                  If a new {@code Double} instance is not required, this method
                  should generally be used in preference to the constructor{@link #Double(double)}, as this method is likely to yield
                  significantly better space and time performance by caching
                  frequently requested values.                
                <param>
                    d a double value.                    
                </param>
                <return>
                    a {@code Double} instance representing {@code d}.                    
                </return>
                <since>
                    1.5                    
                </since>
            </javadoc>
            <method name="valueOf" type="Double" line="520">
                <params>
                    <param name="d" type="double"/>
                </params>
            </method>
            <javadoc line="524">
                Returns a new {@code double} initialized to the value
                  represented by the specified {@code String}, as performed
                  by the {@code valueOf} method of class{@code Double}.                
                <param>
                    s   the string to be parsed.                    
                </param>
                <return>
                    the {@code double} value represented by the string
                      argument.                    
                </return>
                <throws>
                    NullPointerException  if the string is null                    
                </throws>
                <throws>
                    NumberFormatException if the string does not contain
                      a parsable {@code double}.                    
                </throws>
                <see>
                    java.lang.Double#valueOf(String)                    
                </see>
                <since>
                    1.2                    
                </since>
            </javadoc>
            <method name="parseDouble" type="double" line="539">
                <params>
                    <param name="s" type="String"/>
                </params>
            </method>
            <javadoc line="543">
                Returns {@code true} if the specified number is a
                  Not-a-Number (NaN) value, {@code false} otherwise.                
                <param>
                    v   the value to be tested.                    
                </param>
                <return>
                    {@code true} if the value of the argument is NaN;{@code false} otherwise.                    
                </return>
            </javadoc>
            <method name="isNaN" type="boolean" line="551">
                <params>
                    <param name="v" type="double"/>
                </params>
            </method>
            <javadoc line="555">
                Returns {@code true} if the specified number is infinitely
                  large in magnitude, {@code false} otherwise.                
                <param>
                    v   the value to be tested.                    
                </param>
                <return>
                    {@code true} if the value of the argument is positive
                      infinity or negative infinity; {@code false} otherwise.                    
                </return>
            </javadoc>
            <method name="isInfinite" type="boolean" line="563">
                <params>
                    <param name="v" type="double"/>
                </params>
            </method>
            <declaration name="value" type="double" line="567"/>
            <javadoc line="567">
                The value of the Double.                
                <serial>
                                        
                </serial>
            </javadoc>
            <javadoc line="574">
                Constructs a newly allocated {@code Double} object that
                  represents the primitive {@code double} argument.                
                <param>
                    value   the value to be represented by the {@code Double}.                    
                </param>
            </javadoc>
            <method name="Double" type="constructor" line="580">
                <params>
                    <param name="value" type="double"/>
                </params>
            </method>
            <javadoc line="584">
                Constructs a newly allocated {@code Double} object that
                  represents the floating-point value of type {@code double}represented by the string. The string is converted to a{@code double} value as if by the {@code valueOf} method.                
                <param>
                    s  a string to be converted to a {@code Double}.                    
                </param>
                <throws>
                    NumberFormatException  if the string does not contain a
                      parsable number.                    
                </throws>
                <see>
                    java.lang.Double#valueOf(java.lang.String)                    
                </see>
            </javadoc>
            <method name="Double" type="constructor" line="595">
                <params>
                    <param name="s" type="String"/>
                </params>
                <comment line="597">
                    REMIND: this is inefficient                    
                </comment>
            </method>
            <javadoc line="600">
                Returns {@code true} if this {@code Double} value is
                  a Not-a-Number (NaN), {@code false} otherwise.                
                <return>
                    {@code true} if the value represented by this object is
                      NaN; {@code false} otherwise.                    
                </return>
            </javadoc>
            <method name="isNaN" type="boolean" line="607"/>
            <javadoc line="611">
                Returns {@code true} if this {@code Double} value is
                  infinitely large in magnitude, {@code false} otherwise.                
                <return>
                    {@code true} if the value represented by this object is
                      positive infinity or negative infinity;{@code false} otherwise.                    
                </return>
            </javadoc>
            <method name="isInfinite" type="boolean" line="619"/>
            <javadoc line="623">
                Returns a string representation of this {@code Double} object.
                  The primitive {@code double} value represented by this
                  object is converted to a string exactly as if by the method{@code toString} of one argument.                
                <return>
                    a {@code String} representation of this object.                    
                </return>
                <see>
                    java.lang.Double#toString(double)                    
                </see>
            </javadoc>
            <method name="toString" type="String" line="632"/>
            <javadoc line="636">
                Returns the value of this {@code Double} as a {@code byte} (by
                  casting to a {@code byte}).                
                <return>
                    the {@code double} value represented by this object
                      converted to type {@code byte}                    
                </return>
                <since>
                    JDK1.1                    
                </since>
            </javadoc>
            <method name="byteValue" type="byte" line="644"/>
            <javadoc line="648">
                Returns the value of this {@code Double} as a{@code short} (by casting to a {@code short}).                
                <return>
                    the {@code double} value represented by this object
                      converted to type {@code short}                    
                </return>
                <since>
                    JDK1.1                    
                </since>
            </javadoc>
            <method name="shortValue" type="short" line="656"/>
            <javadoc line="660">
                Returns the value of this {@code Double} as an{@code int} (by casting to type {@code int}).                
                <return>
                    the {@code double} value represented by this object
                      converted to type {@code int}                    
                </return>
            </javadoc>
            <method name="intValue" type="int" line="667"/>
            <javadoc line="671">
                Returns the value of this {@code Double} as a{@code long} (by casting to type {@code long}).                
                <return>
                    the {@code double} value represented by this object
                      converted to type {@code long}                    
                </return>
            </javadoc>
            <method name="longValue" type="long" line="678"/>
            <javadoc line="682">
                Returns the {@code float} value of this{@code Double} object.                
                <return>
                    the {@code double} value represented by this object
                      converted to type {@code float}                    
                </return>
                <since>
                    JDK1.0                    
                </since>
            </javadoc>
            <method name="floatValue" type="float" line="690"/>
            <javadoc line="694">
                Returns the {@code double} value of this{@code Double} object.                
                <return>
                    the {@code double} value represented by this object                    
                </return>
            </javadoc>
            <method name="doubleValue" type="double" line="700"/>
            <javadoc line="704">
                Returns a hash code for this {@code Double} object. The
                  result is the exclusive OR of the two halves of the{@code long} integer bit representation, exactly as
                  produced by the method {@link #doubleToLongBits(double)}, of
                  the primitive {@code double} value represented by this{@code Double} object. That is, the hash code is the value
                  of the expression:
                  &lt;blockquote&gt;{@code (int)(v^(v&gt;&gt;&gt;32))}&lt;/blockquote&gt;
                  where {@code v} is defined by:
                  &lt;blockquote&gt;{@code long v = Double.doubleToLongBits(this.doubleValue());}&lt;/blockquote&gt;                
                <return>
                    a {@code hash code} value for this object.                    
                </return>
            </javadoc>
            <method name="hashCode" type="int" line="725">
                <declaration name="bits" type="long" line="726"/>
            </method>
            <javadoc line="730">
                Compares this object against the specified object.  The result
                  is {@code true} if and only if the argument is not{@code null} and is a {@code Double} object that
                  represents a {@code double} that has the same value as the{@code double} represented by this object. For this
                  purpose, two {@code double} values are considered to be
                  the same if and only if the method {@link #doubleToLongBits(double)} returns the identical{@code long} value when applied to each.
                  &lt;p&gt;Note that in most cases, for two instances of class{@code Double}, {@code d1} and {@code d2}, the
                  value of {@code d1.equals(d2)} is {@code true} if and
                  only if
                  &lt;blockquote&gt;{@code d1.doubleValue() == d2.doubleValue()}&lt;/blockquote&gt;
                  &lt;p&gt;also has the value {@code true}. However, there are two
                  exceptions:
                  &lt;ul&gt;
                  &lt;li&gt;If {@code d1} and {@code d2} both represent{@code Double.NaN}, then the {@code equals} method
                  returns {@code true}, even though{@code Double.NaN==Double.NaN} has the value{@code false}.
                  &lt;li&gt;If {@code d1} represents {@code +0.0} while{@code d2} represents {@code -0.0}, or vice versa,
                  the {@code equal} test has the value {@code false},
                  even though {@code +0.0==-0.0} has the value {@code true}.
                  &lt;/ul&gt;
                  This definition allows hash tables to operate properly.                
                <param>
                    obj   the object to compare with.                    
                </param>
                <return>
                    {@code true} if the objects are the same;{@code false} otherwise.                    
                </return>
                <see>
                    java.lang.Double#doubleToLongBits(double)                    
                </see>
            </javadoc>
            <method name="equals" type="boolean" line="769">
                <params>
                    <param name="obj" type="Object"/>
                </params>
            </method>
            <javadoc line="775">
                Returns a representation of the specified floating-point value
                  according to the IEEE 754 floating-point &quot;double
                  format&quot; bit layout.
                  &lt;p&gt;Bit 63 (the bit that is selected by the mask{@code 0x8000000000000000L}) represents the sign of the
                  floating-point number. Bits
                  62-52 (the bits that are selected by the mask{@code 0x7ff0000000000000L}) represent the exponent. Bits 51-0
                  (the bits that are selected by the mask{@code 0x000fffffffffffffL}) represent the significand
                  (sometimes called the mantissa) of the floating-point number.
                  &lt;p&gt;If the argument is positive infinity, the result is{@code 0x7ff0000000000000L}.
                  &lt;p&gt;If the argument is negative infinity, the result is{@code 0xfff0000000000000L}.
                  &lt;p&gt;If the argument is NaN, the result is{@code 0x7ff8000000000000L}.
                  &lt;p&gt;In all cases, the result is a {@code long} integer that, when
                  given to the {@link #longBitsToDouble(long)} method, will produce a
                  floating-point value the same as the argument to{@code doubleToLongBits} (except all NaN values are
                  collapsed to a single &quot;canonical&quot; NaN value).                
                <param>
                    value   a {@code double} precision floating-point number.                    
                </param>
                <return>
                    the bits that represent the floating-point number.                    
                </return>
            </javadoc>
            <method name="doubleToLongBits" type="long" line="807">
                <params>
                    <param name="value" type="double"/>
                </params>
                <comment line="810">
                    Check for NaN based on values of bit fields, maximum
                     exponent and nonzero significand.                    
                </comment>
                <declaration name="result" type="long" line="808"/>
            </method>
            <method name="doubleToRawLongBits" type="long" line="818"/>
            <javadoc line="818">
                Returns a representation of the specified floating-point value
                  according to the IEEE 754 floating-point &quot;double
                  format&quot; bit layout, preserving Not-a-Number (NaN) values.
                  &lt;p&gt;Bit 63 (the bit that is selected by the mask{@code 0x8000000000000000L}) represents the sign of the
                  floating-point number. Bits
                  62-52 (the bits that are selected by the mask{@code 0x7ff0000000000000L}) represent the exponent. Bits 51-0
                  (the bits that are selected by the mask{@code 0x000fffffffffffffL}) represent the significand
                  (sometimes called the mantissa) of the floating-point number.
                  &lt;p&gt;If the argument is positive infinity, the result is{@code 0x7ff0000000000000L}.
                  &lt;p&gt;If the argument is negative infinity, the result is{@code 0xfff0000000000000L}.
                  &lt;p&gt;If the argument is NaN, the result is the {@code long}integer representing the actual NaN value.  Unlike the{@code doubleToLongBits} method,{@code doubleToRawLongBits} does not collapse all the bit
                  patterns encoding a NaN to a single &quot;canonical&quot; NaN
                  value.
                  &lt;p&gt;In all cases, the result is a {@code long} integer that,
                  when given to the {@link #longBitsToDouble(long)} method, will
                  produce a floating-point value the same as the argument to{@code doubleToRawLongBits}.                
                <param>
                    value   a {@code double} precision floating-point number.                    
                </param>
                <return>
                    the bits that represent the floating-point number.                    
                </return>
                <since>
                    1.3                    
                </since>
            </javadoc>
            <method name="longBitsToDouble" type="double" line="856"/>
            <javadoc line="856">
                Returns the {@code double} value corresponding to a given
                  bit representation.
                  The argument is considered to be a representation of a
                  floating-point value according to the IEEE 754 floating-point
                  &quot;double format&quot; bit layout.
                  &lt;p&gt;If the argument is {@code 0x7ff0000000000000L}, the result
                  is positive infinity.
                  &lt;p&gt;If the argument is {@code 0xfff0000000000000L}, the result
                  is negative infinity.
                  &lt;p&gt;If the argument is any value in the range{@code 0x7ff0000000000001L} through{@code 0x7fffffffffffffffL} or in the range{@code 0xfff0000000000001L} through{@code 0xffffffffffffffffL}, the result is a NaN.  No IEEE
                  754 floating-point operation provided by Java can distinguish
                  between two NaN values of the same type with different bit
                  patterns.  Distinct values of NaN are only distinguishable by
                  use of the {@code Double.doubleToRawLongBits} method.
                  &lt;p&gt;In all other cases, let &lt;i&gt;s&lt;/i&gt;, &lt;i&gt;e&lt;/i&gt;, and &lt;i&gt;m&lt;/i&gt; be three
                  values that can be computed from the argument:
                  &lt;blockquote&gt;&lt;pre&gt;
                  int s = ((bits &amp;gt;&amp;gt; 63) == 0) ? 1 : -1;
                  int e = (int)((bits &amp;gt;&amp;gt; 52) &amp; 0x7ffL);
                  long m = (e == 0) ?
                  (bits &amp; 0xfffffffffffffL) &amp;lt;&amp;lt; 1 :
                  (bits &amp; 0xfffffffffffffL) | 0x10000000000000L;
                  &lt;/pre&gt;&lt;/blockquote&gt;
                  Then the floating-point result equals the value of the mathematical
                  expression &lt;i&gt;s&lt;/i&gt;&amp;middot;&lt;i&gt;m&lt;/i&gt;&amp;middot;2&lt;sup&gt;&lt;i&gt;e&lt;/i&gt;-1075&lt;/sup&gt;.
                  &lt;p&gt;Note that this method may not be able to return a{@code double} NaN with exactly same bit pattern as the{@code long} argument.  IEEE 754 distinguishes between two
                  kinds of NaNs, quiet NaNs and &lt;i&gt;signaling NaNs&lt;/i&gt;.  The
                  differences between the two kinds of NaN are generally not
                  visible in Java.  Arithmetic operations on signaling NaNs turn
                  them into quiet NaNs with a different, but often similar, bit
                  pattern.  However, on some processors merely copying a
                  signaling NaN also performs that conversion.  In particular,
                  copying a signaling NaN to return it to the calling method
                  may perform this conversion.  So {@code longBitsToDouble}may not be able to return a {@code double} with a
                  signaling NaN bit pattern.  Consequently, for some{@code long} values,{@code doubleToRawLongBits(longBitsToDouble(start))} may
                  &lt;i&gt;not&lt;/i&gt; equal {@code start}.  Moreover, which
                  particular bit patterns represent signaling NaNs is platform
                  dependent; although all NaN bit patterns, quiet or signaling,
                  must be in the NaN range identified above.                
                <param>
                    bits   any {@code long} integer.                    
                </param>
                <return>
                    the {@code double} floating-point value with the same
                      bit pattern.                    
                </return>
            </javadoc>
            <javadoc line="919">
                Compares two {@code Double} objects numerically.  There
                  are two ways in which comparisons performed by this method
                  differ from those performed by the Java language numerical
                  comparison operators ({@code &lt;, &lt;=, ==, &gt;=, &gt;})
                  when applied to primitive {@code double} values:
                  &lt;ul&gt;&lt;li&gt;{@code Double.NaN} is considered by this method
                  to be equal to itself and greater than all other{@code double} values (including{@code Double.POSITIVE_INFINITY}).
                  &lt;li&gt;{@code 0.0d} is considered by this method to be greater
                  than {@code -0.0d}.
                  &lt;/ul&gt;
                  This ensures that the &lt;i&gt;natural ordering&lt;/i&gt; of{@code Double} objects imposed by this method is &lt;i&gt;consistent
                  with equals&lt;/i&gt;.                
                <param>
                    anotherDouble   the {@code Double} to be compared.                    
                </param>
                <return>
                    the value {@code 0} if {@code anotherDouble} is
                      numerically equal to this {@code Double}; a value
                      less than {@code 0} if this {@code Double}is numerically less than {@code anotherDouble};
                      and a value greater than {@code 0} if this{@code Double} is numerically greater than{@code anotherDouble}.                    
                </return>
                <since>
                    1.2                    
                </since>
            </javadoc>
            <method name="compareTo" type="int" line="949">
                <params>
                    <param name="anotherDouble" type="Double"/>
                </params>
            </method>
            <javadoc line="953">
                Compares the two specified {@code double} values. The sign
                  of the integer value returned is the same as that of the
                  integer that would be returned by the call:
                  &lt;pre&gt;
                  new Double(d1).compareTo(new Double(d2))
                  &lt;/pre&gt;                
                <param>
                    d1        the first {@code double} to compare                    
                </param>
                <param>
                    d2        the second {@code double} to compare                    
                </param>
                <return>
                    the value {@code 0} if {@code d1} is
                      numerically equal to {@code d2}; a value less than{@code 0} if {@code d1} is numerically less than{@code d2}; and a value greater than {@code 0}if {@code d1} is numerically greater than{@code d2}.                    
                </return>
                <since>
                    1.4                    
                </since>
            </javadoc>
            <method name="compare" type="int" line="971">
                <params>
                    <param name="d1" type="double"/>
                    <param name="d2" type="double"/>
                </params>
                <comment line="974">
                    Neither val is NaN, thisVal is smaller                    
                </comment>
                <comment line="976">
                    Neither val is NaN, thisVal is larger                    
                </comment>
                <comment line="978">
                    Cannot use doubleToRawLongBits because of possibility of NaNs.                    
                </comment>
                <comment line="982">
                    Values are equal                    
                </comment>
                <comment line="983">
                    (-0.0, 0.0) or (!NaN, NaN)                    
                </comment>
                <comment line="984">
                    (0.0, -0.0) or (NaN, !NaN)                    
                </comment>
                <declaration name="thisBits" type="long" line="978"/>
                <declaration name="anotherBits" type="long" line="979"/>
            </method>
            <declaration name="serialVersionUID" type="long" line="986"/>
            <javadoc line="986">
                use serialVersionUID from JDK 1.0.2 for interoperability                
            </javadoc>
        </class>
    </source>