<?xml version="1.0" encoding="UTF-8"?>
    <source package="java.lang">
        <import package="java.lang.ref"/>
        <import package="java.util.concurrent.atomic.AtomicInteger"/>
        <class name="ThreadLocal" line="4">
            <type_params>
                <type_param name="T"/>
            </type_params>
            <javadoc line="4">
                This class provides thread-local variables.  These variables differ from
                  their normal counterparts in that each thread that accesses one (via its
                  &lt;tt&gt;get&lt;/tt&gt; or &lt;tt&gt;set&lt;/tt&gt; method) has its own, independently initialized
                  copy of the variable.  &lt;tt&gt;ThreadLocal&lt;/tt&gt; instances are typically private
                  static fields in classes that wish to associate state with a thread (e.g.,
                  a user ID or Transaction ID).
                  &lt;p&gt;For example, the class below generates unique identifiers local to each
                  thread.
                  A thread&apos;s id is assigned the first time it invokes &lt;tt&gt;ThreadId.get()&lt;/tt&gt;
                  and remains unchanged on subsequent calls.
                  &lt;pre&gt;
                  import java.util.concurrent.atomic.AtomicInteger;
                  public class ThreadId {
                  // Atomic integer containing the next thread ID to be assigned
                  private static final AtomicInteger nextId = new AtomicInteger(0);
                  // Thread local variable containing each thread&apos;s ID
                  private static final ThreadLocal&amp;lt;Integer&gt; threadId =
                  new ThreadLocal&amp;lt;Integer&gt;() {
                  &amp;#64;Override protected Integer initialValue() {
                  return nextId.getAndIncrement();
                  }
                  };
                  // Returns the current thread&apos;s unique ID, assigning it if necessary
                  public static int get() {
                  return threadId.get();
                  }
                  }
                  &lt;/pre&gt;
                  &lt;p&gt;Each thread holds an implicit reference to its copy of a thread-local
                  variable as long as the thread is alive and the &lt;tt&gt;ThreadLocal&lt;/tt&gt;
                  instance is accessible; after a thread goes away, all of its copies of
                  thread-local instances are subject to garbage collection (unless other
                  references to these copies exist).                
                <author>
                    Josh Bloch and Doug Lea                    
                </author>
                <since>
                    1.2                    
                </since>
            </javadoc>
            <declaration name="threadLocalHashCode" type="int" line="42"/>
            <javadoc line="42">
                ThreadLocals rely on per-thread linear-probe hash maps attached
                  to each thread (Thread.threadLocals and
                  inheritableThreadLocals).  The ThreadLocal objects act as keys,
                  searched via threadLocalHashCode.  This is a custom hash code
                  (useful only within ThreadLocalMaps) that eliminates collisions
                  in the common case where consecutively constructed ThreadLocals
                  are used by the same threads, while remaining well-behaved in
                  less common cases.                
            </javadoc>
            <declaration name="nextHashCode" type="AtomicInteger" line="53"/>
            <javadoc line="53">
                The next hash code to be given out. Updated atomically. Starts at
                  zero.                
            </javadoc>
            <declaration name="HASH_INCREMENT" type="int" line="58"/>
            <javadoc line="58">
                The difference between successively generated hash codes - turns
                  implicit sequential thread-local IDs into near-optimally spread
                  multiplicative hash values for power-of-two-sized tables.                
            </javadoc>
            <javadoc line="64">
                Returns the next hash code.                
            </javadoc>
            <method name="nextHashCode" type="int" line="67"/>
            <javadoc line="70">
                Returns the current thread&apos;s &quot;initial value&quot; for this
                  thread-local variable.  This method will be invoked the first
                  time a thread accesses the variable with the {@link #get}method, unless the thread previously invoked the {@link #set}method, in which case the &lt;tt&gt;initialValue&lt;/tt&gt; method will not
                  be invoked for the thread.  Normally, this method is invoked at
                  most once per thread, but it may be invoked again in case of
                  subsequent invocations of {@link #remove} followed by {@link #get}.
                  &lt;p&gt;This implementation simply returns &lt;tt&gt;null&lt;/tt&gt;; if the
                  programmer desires thread-local variables to have an initial
                  value other than &lt;tt&gt;null&lt;/tt&gt;, &lt;tt&gt;ThreadLocal&lt;/tt&gt; must be
                  subclassed, and this method overridden.  Typically, an
                  anonymous inner class will be used.                
                <return>
                    the initial value for this thread-local                    
                </return>
            </javadoc>
            <method name="initialValue" type="T" line="84"/>
            <javadoc line="87">
                Creates a thread local variable.                
            </javadoc>
            <method name="ThreadLocal" type="constructor" line="90"/>
            <javadoc line="92">
                Returns the value in the current thread&apos;s copy of this
                  thread-local variable.  If the variable has no value for the
                  current thread, it is first initialized to the value returned
                  by an invocation of the {@link #initialValue} method.                
                <return>
                    the current thread's value of this thread-local                    
                </return>
            </javadoc>
            <method name="get" type="T" line="99">
                <declaration name="t" type="Thread" line="100"/>
                <declaration name="map" type="ThreadLocalMap" line="101"/>
                <scope line="102">
                    <declaration name="e" type="ThreadLocalMap.Entry" line="103"/>
                </scope>
            </method>
            <javadoc line="108">
                Variant of set() to establish initialValue. Used instead
                  of set() in case user has overridden the set() method.                
                <return>
                    the initial value                    
                </return>
            </javadoc>
            <method name="setInitialValue" type="T" line="113">
                <declaration name="value" type="T" line="114"/>
                <declaration name="t" type="Thread" line="115"/>
                <declaration name="map" type="ThreadLocalMap" line="116"/>
            </method>
            <javadoc line="121">
                Sets the current thread&apos;s copy of this thread-local variable
                  to the specified value.  Most subclasses will have no need to
                  override this method, relying solely on the {@link #initialValue}method to set the values of thread-locals.                
                <param>
                    value the value to be stored in the current thread's copy of
                      this thread-local.                    
                </param>
            </javadoc>
            <method name="set" type="void" line="128">
                <params>
                    <param name="value" type="T"/>
                </params>
                <declaration name="t" type="Thread" line="129"/>
                <declaration name="map" type="ThreadLocalMap" line="130"/>
            </method>
            <javadoc line="134">
                Removes the current thread&apos;s value for this thread-local
                  variable.  If this thread-local variable is subsequently{@linkplain #get read} by the current thread, its value will be
                  reinitialized by invoking its {@link #initialValue} method,
                  unless its value is {@linkplain #set set} by the current thread
                  in the interim.  This may result in multiple invocations of the
                  &lt;tt&gt;initialValue&lt;/tt&gt; method in the current thread.                
                <since>
                    1.5                    
                </since>
            </javadoc>
            <method name="remove" type="void" line="143">
                <declaration name="m" type="ThreadLocalMap" line="144"/>
            </method>
            <javadoc line="147">
                Get the map associated with a ThreadLocal. Overridden in
                  InheritableThreadLocal.                
                <param>
                    t the current thread                    
                </param>
                <return>
                    the map                    
                </return>
            </javadoc>
            <method name="getMap" type="ThreadLocalMap" line="153">
                <params>
                    <param name="t" type="Thread"/>
                </params>
            </method>
            <javadoc line="156">
                Create the map associated with a ThreadLocal. Overridden in
                  InheritableThreadLocal.                
                <param>
                    t the current thread                    
                </param>
                <param>
                    firstValue value for the initial entry of the map                    
                </param>
                <param>
                    map the map to store.                    
                </param>
            </javadoc>
            <method name="createMap" type="void" line="163">
                <params>
                    <param name="t" type="Thread"/>
                    <param name="firstValue" type="T"/>
                </params>
            </method>
            <javadoc line="166">
                Factory method to create map of inherited thread locals.
                  Designed to be called only from Thread constructor.                
                <param>
                    parentMap the map associated with parent thread                    
                </param>
                <return>
                    a map containing the parent's inheritable bindings                    
                </return>
            </javadoc>
            <method name="createInheritedMap" type="ThreadLocalMap" line="172">
                <params>
                    <param name="parentMap" type="ThreadLocalMap"/>
                </params>
            </method>
            <javadoc line="175">
                Method childValue is visibly defined in subclass
                  InheritableThreadLocal, but is internally defined here for the
                  sake of providing createInheritedMap factory method without
                  needing to subclass the map class in InheritableThreadLocal.
                  This technique is preferable to the alternative of embedding
                  instanceof tests in methods.                
            </javadoc>
            <method name="childValue" type="T" line="183">
                <params>
                    <param name="parentValue" type="T"/>
                </params>
            </method>
            <class name="ThreadLocalMap" line="186">
                <javadoc line="186">
                    ThreadLocalMap is a customized hash map suitable only for
                      maintaining thread local values. No operations are exported
                      outside of the ThreadLocal class. The class is package private to
                      allow declaration of fields in class Thread.  To help deal with
                      very large and long-lived usages, the hash table entries use
                      WeakReferences for keys. However, since reference queues are not
                      used, stale entries are guaranteed to be removed only when
                      the table starts running out of space.                    
                </javadoc>
                <class name="Entry" line="197">
                    <extends class="WeakReference">
                        <type_params>
                            <type_param name="ThreadLocal"/>
                        </type_params>
                    </extends>
                    <javadoc line="197">
                        The entries in this hash map extend WeakReference, using
                          its main ref field as the key (which is always a
                          ThreadLocal object).  Note that null keys (i.e. entry.get()
                          == null) mean that the key is no longer referenced, so the
                          entry can be expunged from table.  Such entries are referred to
                          as &quot;stale entries&quot; in the code that follows.                        
                    </javadoc>
                    <declaration name="value" type="Object" line="206"/>
                    <javadoc line="206">
                        The value associated with this ThreadLocal.                        
                    </javadoc>
                    <method name="Entry" type="constructor" line="210">
                        <params>
                            <param name="k" type="ThreadLocal"/>
                            <param name="v" type="Object"/>
                        </params>
                    </method>
                </class>
                <declaration name="INITIAL_CAPACITY" type="int" line="215"/>
                <javadoc line="215">
                    The initial capacity -- MUST be a power of two.                    
                </javadoc>
                <declaration name="table" type="Entry[]" line="219"/>
                <javadoc line="219">
                    The table, resized as necessary.
                      table.length MUST always be a power of two.                    
                </javadoc>
                <declaration name="size" type="int" line="224"/>
                <javadoc line="224">
                    The number of entries in the table.                    
                </javadoc>
                <declaration name="threshold" type="int" line="228"/>
                <javadoc line="228">
                    The next size value at which to resize.                    
                </javadoc>
                <javadoc line="232">
                    Set the resize threshold to maintain at worst a 2/3 load factor.                    
                </javadoc>
                <method name="setThreshold" type="void" line="235">
                    <params>
                        <param name="len" type="int"/>
                    </params>
                </method>
                <javadoc line="238">
                    Increment i modulo len.                    
                </javadoc>
                <method name="nextIndex" type="int" line="241">
                    <params>
                        <param name="i" type="int"/>
                        <param name="len" type="int"/>
                    </params>
                </method>
                <javadoc line="244">
                    Decrement i modulo len.                    
                </javadoc>
                <method name="prevIndex" type="int" line="247">
                    <params>
                        <param name="i" type="int"/>
                        <param name="len" type="int"/>
                    </params>
                </method>
                <javadoc line="250">
                    Construct a new map initially containing (firstKey, firstValue).
                      ThreadLocalMaps are constructed lazily, so we only create
                      one when we have at least one entry to put in it.                    
                </javadoc>
                <method name="ThreadLocalMap" type="constructor" line="255">
                    <params>
                        <param name="firstKey" type="ThreadLocal"/>
                        <param name="firstValue" type="Object"/>
                    </params>
                    <declaration name="i" type="int" line="257"/>
                </method>
                <javadoc line="262">
                    Construct a new map including all Inheritable ThreadLocals
                      from given parent map. Called only by createInheritedMap.                    
                    <param>
                        parentMap the map associated with parent thread.                        
                    </param>
                </javadoc>
                <method name="ThreadLocalMap" type="constructor" line="267">
                    <params>
                        <param name="parentMap" type="ThreadLocalMap"/>
                    </params>
                    <declaration name="parentTable" type="Entry[]" line="268"/>
                    <declaration name="len" type="int" line="269"/>
                    <scope line="272">
                        <declaration name="e" type="Entry" line="273"/>
                        <scope line="274">
                            <declaration name="key" type="ThreadLocal" line="275"/>
                            <scope line="276">
                                <declaration name="value" type="Object" line="277"/>
                                <declaration name="c" type="Entry" line="278"/>
                                <declaration name="h" type="int" line="279"/>
                            </scope>
                        </scope>
                    </scope>
                </method>
                <javadoc line="287">
                    Get the entry associated with key.  This method
                      itself handles only the fast path: a direct hit of existing
                      key. It otherwise relays to getEntryAfterMiss.  This is
                      designed to maximize performance for direct hits, in part
                      by making this method readily inlinable.                    
                    <param>
                        key the thread local object                        
                    </param>
                    <return>
                        the entry associated with key, or null if no such                        
                    </return>
                </javadoc>
                <method name="getEntry" type="Entry" line="296">
                    <params>
                        <param name="key" type="ThreadLocal"/>
                    </params>
                    <declaration name="i" type="int" line="297"/>
                    <declaration name="e" type="Entry" line="298"/>
                </method>
                <javadoc line="302">
                    Version of getEntry method for use when key is not found in
                      its direct hash slot.                    
                    <param>
                        key the thread local object                        
                    </param>
                    <param>
                        i the table index for key's hash code                        
                    </param>
                    <param>
                        e the entry at table[i]                        
                    </param>
                    <return>
                        the entry associated with key, or null if no such                        
                    </return>
                </javadoc>
                <method name="getEntryAfterMiss" type="Entry" line="310">
                    <params>
                        <param name="key" type="ThreadLocal"/>
                        <param name="i" type="int"/>
                        <param name="e" type="Entry"/>
                    </params>
                    <declaration name="tab" type="Entry[]" line="311"/>
                    <declaration name="len" type="int" line="312"/>
                    <scope line="313">
                        <declaration name="k" type="ThreadLocal" line="314"/>
                    </scope>
                </method>
                <javadoc line="322">
                    Set the value associated with key.                    
                    <param>
                        key the thread local object                        
                    </param>
                    <param>
                        value the value to be set                        
                    </param>
                </javadoc>
                <method name="set" type="void" line="327">
                    <params>
                        <param name="key" type="ThreadLocal"/>
                        <param name="value" type="Object"/>
                    </params>
                    <declaration name="tab" type="Entry[]" line="328"/>
                    <declaration name="len" type="int" line="329"/>
                    <declaration name="i" type="int" line="330"/>
                    <scope line="331">
                        <declaration name="k" type="ThreadLocal" line="332"/>
                        <scope line="333"/>
                        <scope line="337"/>
                    </scope>
                    <declaration name="sz" type="int" line="343"/>
                </method>
                <javadoc line="346">
                    Remove the entry for key.                    
                </javadoc>
                <method name="remove" type="void" line="349">
                    <params>
                        <param name="key" type="ThreadLocal"/>
                    </params>
                    <declaration name="tab" type="Entry[]" line="350"/>
                    <declaration name="len" type="int" line="351"/>
                    <declaration name="i" type="int" line="352"/>
                    <scope line="353">
                        <scope line="354"/>
                    </scope>
                </method>
                <javadoc line="361">
                    Replace a stale entry encountered during a set operation
                      with an entry for the specified key.  The value passed in
                      the value parameter is stored in the entry, whether or not
                      an entry already exists for the specified key.
                      As a side effect, this method expunges all stale entries in the
                      &quot;run&quot; containing the stale entry.  (A run is a sequence of entries
                      between two null slots.)                    
                    <param>
                        key the key                        
                    </param>
                    <param>
                        value the value to be associated with key                        
                    </param>
                    <param>
                        staleSlot index of the first stale entry encountered while
                          searching for key.                        
                    </param>
                </javadoc>
                <method name="replaceStaleEntry" type="void" line="374">
                    <params>
                        <param name="key" type="ThreadLocal"/>
                        <param name="value" type="Object"/>
                        <param name="staleSlot" type="int"/>
                    </params>
                    <declaration name="tab" type="Entry[]" line="375"/>
                    <declaration name="len" type="int" line="376"/>
                    <declaration name="e" type="Entry" line="377"/>
                    <declaration name="slotToExpunge" type="int" line="378"/>
                    <scope line="380">
                        <declaration name="k" type="ThreadLocal" line="381"/>
                        <scope line="382"/>
                    </scope>
                </method>
                <javadoc line="396">
                    Expunge a stale entry by rehashing any possibly colliding entries
                      lying between staleSlot and the next null slot.  This also expunges
                      any other stale entries encountered before the trailing null.  See
                      Knuth, Section 6.4                    
                    <param>
                        staleSlot index of slot known to have null key                        
                    </param>
                    <return>
                        the index of the next null slot after staleSlot
                          (all between staleSlot and this slot will have been checked
                          for expunging).                        
                    </return>
                </javadoc>
                <method name="expungeStaleEntry" type="int" line="406">
                    <params>
                        <param name="staleSlot" type="int"/>
                    </params>
                    <declaration name="tab" type="Entry[]" line="407"/>
                    <declaration name="len" type="int" line="408"/>
                    <declaration name="e" type="Entry" line="412"/>
                    <declaration name="i" type="int" line="413"/>
                    <scope line="414">
                        <declaration name="k" type="ThreadLocal" line="415"/>
                        <scope line="416"/>
                        <scope line="421">
                            <declaration name="h" type="int" line="422"/>
                            <scope line="423"/>
                        </scope>
                    </scope>
                </method>
                <javadoc line="432">
                    Heuristically scan some cells looking for stale entries.
                      This is invoked when either a new element is added, or
                      another stale one has been expunged. It performs a
                      logarithmic number of scans, as a balance between no
                      scanning (fast but retains garbage) and a number of scans
                      proportional to number of elements, that would find all
                      garbage but would cause some insertions to take O(n) time.                    
                    <param>
                        i a position known NOT to hold a stale entry. The
                          scan starts at the element after i.                        
                    </param>
                    <param>
                        n scan control: <tt>log2(n)</tt> cells are scanned,
                          unless a stale entry is found, in which case
                          <tt>log2(table.length)-1</tt> additional cells are scanned.
                          When called from insertions, this parameter is the number
                          of elements, but when from replaceStaleEntry, it is the
                          table length. (Note: all this could be changed to be either
                          more or less aggressive by weighting n instead of just
                          using straight log n. But this version is simple, fast, and
                          seems to work well.)                        
                    </param>
                    <return>
                        true if any stale entries have been removed.                        
                    </return>
                </javadoc>
                <method name="cleanSomeSlots" type="boolean" line="453">
                    <params>
                        <param name="i" type="int"/>
                        <param name="n" type="int"/>
                    </params>
                    <declaration name="removed" type="boolean" line="454"/>
                    <declaration name="tab" type="Entry[]" line="455"/>
                    <declaration name="len" type="int" line="456"/>
                    <scope line="457">
                        <declaration name="e" type="Entry" line="459"/>
                        <scope line="460"/>
                    </scope>
                </method>
                <javadoc line="469">
                    Re-pack and/or re-size the table. First scan the entire
                      table removing stale entries. If this doesn&apos;t sufficiently
                      shrink the size of the table, double the table size.                    
                </javadoc>
                <method name="rehash" type="void" line="474"/>
                <javadoc line="478">
                    Double the capacity of the table.                    
                </javadoc>
                <method name="resize" type="void" line="481">
                    <declaration name="oldTab" type="Entry[]" line="482"/>
                    <declaration name="oldLen" type="int" line="483"/>
                    <declaration name="newLen" type="int" line="484"/>
                    <declaration name="newTab" type="Entry[]" line="485"/>
                    <declaration name="count" type="int" line="486"/>
                    <scope line="487">
                        <declaration name="e" type="Entry" line="488"/>
                        <scope line="489">
                            <declaration name="k" type="ThreadLocal" line="490"/>
                            <scope line="491"/>
                            <scope line="494">
                                <declaration name="h" type="int" line="495"/>
                            </scope>
                        </scope>
                    </scope>
                </method>
                <javadoc line="506">
                    Expunge all stale entries in the table.                    
                </javadoc>
                <method name="expungeStaleEntries" type="void" line="509">
                    <declaration name="tab" type="Entry[]" line="510"/>
                    <declaration name="len" type="int" line="511"/>
                    <scope line="512">
                        <declaration name="e" type="Entry" line="513"/>
                    </scope>
                </method>
            </class>
        </class>
    </source>