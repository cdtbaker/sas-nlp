<?xml version="1.0" encoding="UTF-8"?>
    <source package="java.lang">
        <import package="java.lang.ref.Reference"/>
        <import package="java.lang.ref.ReferenceQueue"/>
        <import package="java.lang.ref.WeakReference"/>
        <import package="java.security.AccessController"/>
        <import package="java.security.AccessControlContext"/>
        <import package="java.security.PrivilegedAction"/>
        <import package="java.util.Map"/>
        <import package="java.util.HashMap"/>
        <import package="java.util.concurrent.ConcurrentHashMap"/>
        <import package="java.util.concurrent.ConcurrentMap"/>
        <import package="java.util.concurrent.locks.LockSupport"/>
        <import package="sun.nio.ch.Interruptible"/>
        <import package="sun.security.util.SecurityConstants"/>
        <class name="Thread" line="15">
            <implements interface="Runnable"/>
            <javadoc line="15">
                A &lt;i&gt;thread&lt;/i&gt; is a thread of execution in a program. The Java
                  Virtual Machine allows an application to have multiple threads of
                  execution running concurrently.
                  &lt;p&gt;
                  Every thread has a priority. Threads with higher priority are
                  executed in preference to threads with lower priority. Each thread
                  may or may not also be marked as a daemon. When code running in
                  some thread creates a new &lt;code&gt;Thread&lt;/code&gt; object, the new
                  thread has its priority initially set equal to the priority of the
                  creating thread, and is a daemon thread if and only if the
                  creating thread is a daemon.
                  &lt;p&gt;
                  When a Java Virtual Machine starts up, there is usually a single
                  non-daemon thread (which typically calls the method named
                  &lt;code&gt;main&lt;/code&gt; of some designated class). The Java Virtual
                  Machine continues to execute threads until either of the following
                  occurs:
                  &lt;ul&gt;
                  &lt;li&gt;The &lt;code&gt;exit&lt;/code&gt; method of class &lt;code&gt;Runtime&lt;/code&gt; has been
                  called and the security manager has permitted the exit operation
                  to take place.
                  &lt;li&gt;All threads that are not daemon threads have died, either by
                  returning from the call to the &lt;code&gt;run&lt;/code&gt; method or by
                  throwing an exception that propagates beyond the &lt;code&gt;run&lt;/code&gt;
                  method.
                  &lt;/ul&gt;
                  &lt;p&gt;
                  There are two ways to create a new thread of execution. One is to
                  declare a class to be a subclass of &lt;code&gt;Thread&lt;/code&gt;. This
                  subclass should override the &lt;code&gt;run&lt;/code&gt; method of class
                  &lt;code&gt;Thread&lt;/code&gt;. An instance of the subclass can then be
                  allocated and started. For example, a thread that computes primes
                  larger than a stated value could be written as follows:
                  &lt;p&gt;&lt;hr&gt;&lt;blockquote&gt;&lt;pre&gt;
                  class PrimeThread extends Thread {
                  long minPrime;
                  PrimeThread(long minPrime) {
                  this.minPrime = minPrime;
                  }
                  public void run() {
                  // compute primes larger than minPrime
                  &amp;nbsp;.&amp;nbsp;.&amp;nbsp;.
                  }
                  }
                  &lt;/pre&gt;&lt;/blockquote&gt;&lt;hr&gt;
                  &lt;p&gt;
                  The following code would then create a thread and start it running:
                  &lt;p&gt;&lt;blockquote&gt;&lt;pre&gt;
                  PrimeThread p = new PrimeThread(143);
                  p.start();
                  &lt;/pre&gt;&lt;/blockquote&gt;
                  &lt;p&gt;
                  The other way to create a thread is to declare a class that
                  implements the &lt;code&gt;Runnable&lt;/code&gt; interface. That class then
                  implements the &lt;code&gt;run&lt;/code&gt; method. An instance of the class can
                  then be allocated, passed as an argument when creating
                  &lt;code&gt;Thread&lt;/code&gt;, and started. The same example in this other
                  style looks like the following:
                  &lt;p&gt;&lt;hr&gt;&lt;blockquote&gt;&lt;pre&gt;
                  class PrimeRun implements Runnable {
                  long minPrime;
                  PrimeRun(long minPrime) {
                  this.minPrime = minPrime;
                  }
                  public void run() {
                  // compute primes larger than minPrime
                  &amp;nbsp;.&amp;nbsp;.&amp;nbsp;.
                  }
                  }
                  &lt;/pre&gt;&lt;/blockquote&gt;&lt;hr&gt;
                  &lt;p&gt;
                  The following code would then create a thread and start it running:
                  &lt;p&gt;&lt;blockquote&gt;&lt;pre&gt;
                  PrimeRun p = new PrimeRun(143);
                  new Thread(p).start();
                  &lt;/pre&gt;&lt;/blockquote&gt;
                  &lt;p&gt;
                  Every thread has a name for identification purposes. More than
                  one thread may have the same name. If a name is not specified when
                  a thread is created, a new name is generated for it.
                  &lt;p&gt;
                  Unless otherwise noted, passing a {@code null} argument to a constructor
                  or method in this class will cause a {@link NullPointerException} to be
                  thrown.                
                <author>
                    unascribed                    
                </author>
                <see>
                    Runnable                    
                </see>
                <see>
                    Runtime#exit(int)                    
                </see>
                <see>
                    #run()                    
                </see>
                <see>
                    #stop()                    
                </see>
                <since>
                    JDK1.0                    
                </since>
            </javadoc>
            <method name="registerNatives" type="void" line="108"/>
            <scope line="109"/>
            <declaration name="name" type="char" line="112"/>
            <declaration name="priority" type="int" line="113"/>
            <declaration name="threadQ" type="Thread" line="114"/>
            <declaration name="eetop" type="long" line="115"/>
            <declaration name="single_step" type="boolean" line="116"/>
            <declaration name="daemon" type="boolean" line="117"/>
            <declaration name="stillborn" type="boolean" line="118"/>
            <declaration name="target" type="Runnable" line="119"/>
            <declaration name="group" type="ThreadGroup" line="120"/>
            <declaration name="contextClassLoader" type="ClassLoader" line="121"/>
            <declaration name="inheritedAccessControlContext" type="AccessControlContext" line="122"/>
            <declaration name="threadInitNumber" type="int" line="123"/>
            <method name="nextThreadNum" type="int" line="124"/>
            <declaration name="threadLocals" type="ThreadLocal.ThreadLocalMap" line="127"/>
            <declaration name="inheritableThreadLocals" type="ThreadLocal.ThreadLocalMap" line="128"/>
            <declaration name="stackSize" type="long" line="129"/>
            <declaration name="nativeParkEventPointer" type="long" line="130"/>
            <declaration name="tid" type="long" line="131"/>
            <declaration name="threadSeqNumber" type="long" line="132"/>
            <declaration name="threadStatus" type="int" line="133"/>
            <method name="nextThreadID" type="long" line="134"/>
            <declaration name="parkBlocker" type="Object" line="137"/>
            <javadoc line="137">
                The argument supplied to the current call to
                  java.util.concurrent.locks.LockSupport.park.
                  Set by (private) java.util.concurrent.locks.LockSupport.setBlocker
                  Accessed using java.util.concurrent.locks.LockSupport.getBlocker                
            </javadoc>
            <declaration name="blocker" type="Interruptible" line="144"/>
            <declaration name="blockerLock" type="Object" line="145"/>
            <method name="blockedOn" type="void" line="146">
                <params>
                    <param name="b" type="Interruptible"/>
                </params>
                <scope line="147"/>
            </method>
            <declaration name="MIN_PRIORITY" type="int" line="151"/>
            <javadoc line="151">
                The minimum priority that a thread can have.                
            </javadoc>
            <declaration name="NORM_PRIORITY" type="int" line="155"/>
            <javadoc line="155">
                The default priority that is assigned to a thread.                
            </javadoc>
            <declaration name="MAX_PRIORITY" type="int" line="159"/>
            <javadoc line="159">
                The maximum priority that a thread can have.                
            </javadoc>
            <method name="currentThread" type="Thread" line="163"/>
            <javadoc line="163">
                Returns a reference to the currently executing thread object.                
                <return>
                    the currently executing thread.                    
                </return>
            </javadoc>
            <method name="yield" type="void" line="168"/>
            <javadoc line="168">
                A hint to the scheduler that the current thread is willing to yield
                  its current use of a processor. The scheduler is free to ignore this
                  hint.
                  &lt;p&gt; Yield is a heuristic attempt to improve relative progression
                  between threads that would otherwise over-utilise a CPU. Its use
                  should be combined with detailed profiling and benchmarking to
                  ensure that it actually has the desired effect.
                  &lt;p&gt; It is rarely appropriate to use this method. It may be useful
                  for debugging or testing purposes, where it may help to reproduce
                  bugs due to race conditions. It may also be useful when designing
                  concurrency control constructs such as the ones in the{@link java.util.concurrent.locks} package.                
            </javadoc>
            <method name="sleep" type="void" line="182"/>
            <javadoc line="182">
                Causes the currently executing thread to sleep (temporarily cease
                  execution) for the specified number of milliseconds, subject to
                  the precision and accuracy of system timers and schedulers. The thread
                  does not lose ownership of any monitors.                
                <param>
                    millisthe length of time to sleep in milliseconds                    
                </param>
                <throws>
                    IllegalArgumentExceptionif the value of {@code millis} is negative                    
                </throws>
                <throws>
                    InterruptedExceptionif any thread has interrupted the current thread. The
                      <i>interrupted status</i> of the current thread is
                      cleared when this exception is thrown.                    
                </throws>
            </javadoc>
            <javadoc line="194">
                Causes the currently executing thread to sleep (temporarily cease
                  execution) for the specified number of milliseconds plus the specified
                  number of nanoseconds, subject to the precision and accuracy of system
                  timers and schedulers. The thread does not lose ownership of any
                  monitors.                
                <param>
                    millisthe length of time to sleep in milliseconds                    
                </param>
                <param>
                    nanos {@code 0-999999} additional nanoseconds to sleep                    
                </param>
                <throws>
                    IllegalArgumentExceptionif the value of {@code millis} is negative, or the value of{@code nanos} is not in the range {@code 0-999999}                    
                </throws>
                <throws>
                    InterruptedExceptionif any thread has interrupted the current thread. The
                      <i>interrupted status</i> of the current thread is
                      cleared when this exception is thrown.                    
                </throws>
            </javadoc>
            <method name="sleep" type="void" line="207">
                <params>
                    <param name="millis" type="long"/>
                    <param name="nanos" type="int"/>
                </params>
                <scope line="208"/>
                <scope line="211"/>
                <scope line="214"/>
            </method>
            <javadoc line="219">
                Initializes a Thread.                
                <param>
                    g the Thread group                    
                </param>
                <param>
                    target the object whose run() method gets called                    
                </param>
                <param>
                    name the name of the new Thread                    
                </param>
                <param>
                    stackSize the desired stack size for the new thread, or
                      zero to indicate that this parameter is to be ignored.                    
                </param>
            </javadoc>
            <method name="init" type="void" line="227">
                <params>
                    <param name="g" type="ThreadGroup"/>
                    <param name="target" type="Runnable"/>
                    <param name="name" type="String"/>
                    <param name="stackSize" type="long"/>
                </params>
                <scope line="228"/>
                <declaration name="parent" type="Thread" line="231"/>
                <declaration name="security" type="SecurityManager" line="232"/>
                <scope line="233">
                    <scope line="234"/>
                    <scope line="237"/>
                </scope>
                <scope line="242">
                    <scope line="243"/>
                </scope>
            </method>
            <javadoc line="261">
                Throws CloneNotSupportedException as a Thread can not be meaningfully
                  cloned. Construct a new Thread instead.                
                <throws>
                    CloneNotSupportedExceptionalways                    
                </throws>
            </javadoc>
            <method name="clone" type="Object" line="266"/>
            <javadoc line="269">
                Allocates a new {@code Thread} object. This constructor has the same
                  effect as {@linkplain #Thread(ThreadGroup,Runnable,String) Thread}{@code (null, null, gname)}, where {@code gname} is a newly generated
                  name. Automatically generated names are of the form{@code &quot;Thread-&quot;+}&lt;i&gt;n&lt;/i&gt;, where &lt;i&gt;n&lt;/i&gt; is an integer.                
            </javadoc>
            <method name="Thread" type="constructor" line="274"/>
            <javadoc line="277">
                Allocates a new {@code Thread} object. This constructor has the same
                  effect as {@linkplain #Thread(ThreadGroup,Runnable,String) Thread}{@code (null, target, gname)}, where {@code gname} is a newly generated
                  name. Automatically generated names are of the form{@code &quot;Thread-&quot;+}&lt;i&gt;n&lt;/i&gt;, where &lt;i&gt;n&lt;/i&gt; is an integer.                
                <param>
                    targetthe object whose {@code run} method is invoked when this thread
                      is started. If {@code null}, this classes {@code run} method does
                      nothing.                    
                </param>
            </javadoc>
            <method name="Thread" type="constructor" line="285">
                <params>
                    <param name="target" type="Runnable"/>
                </params>
            </method>
            <javadoc line="288">
                Allocates a new {@code Thread} object. This constructor has the same
                  effect as {@linkplain #Thread(ThreadGroup,Runnable,String) Thread}{@code (group, target, gname)} ,where {@code gname} is a newly generated
                  name. Automatically generated names are of the form{@code &quot;Thread-&quot;+}&lt;i&gt;n&lt;/i&gt;, where &lt;i&gt;n&lt;/i&gt; is an integer.                
                <param>
                    groupthe thread group. If {@code null} and there is a security
                      manager, the group is determined by {@linkplain SecurityManager#getThreadGroup SecurityManager.getThreadGroup()}.
                      If there is not a security manager or 
                       returns {@code null}, the group
                      is set to the current thread's thread group.                    
                </param>
                <param>
                    targetthe object whose {@code run} method is invoked when this thread
                      is started. If {@code null}, this thread's run method is invoked.                    
                </param>
                <throws>
                    SecurityExceptionif the current thread cannot create a thread in the specified
                      thread group                    
                </throws>
            </javadoc>
            <method name="Thread" type="constructor" line="301">
                <params>
                    <param name="group" type="ThreadGroup"/>
                    <param name="target" type="Runnable"/>
                </params>
            </method>
            <javadoc line="304">
                Allocates a new {@code Thread} object. This constructor has the same
                  effect as {@linkplain #Thread(ThreadGroup,Runnable,String) Thread}{@code (null, null, name)}.                
                <param>
                    namethe name of the new thread                    
                </param>
            </javadoc>
            <method name="Thread" type="constructor" line="309">
                <params>
                    <param name="name" type="String"/>
                </params>
            </method>
            <javadoc line="312">
                Allocates a new {@code Thread} object. This constructor has the same
                  effect as {@linkplain #Thread(ThreadGroup,Runnable,String) Thread}{@code (group, null, name)}.                
                <param>
                    groupthe thread group. If {@code null} and there is a security
                      manager, the group is determined by {@linkplain SecurityManager#getThreadGroup SecurityManager.getThreadGroup()}.
                      If there is not a security manager or 
                       returns {@code null}, the group
                      is set to the current thread's thread group.                    
                </param>
                <param>
                    namethe name of the new thread                    
                </param>
                <throws>
                    SecurityExceptionif the current thread cannot create a thread in the specified
                      thread group                    
                </throws>
            </javadoc>
            <method name="Thread" type="constructor" line="323">
                <params>
                    <param name="group" type="ThreadGroup"/>
                    <param name="name" type="String"/>
                </params>
            </method>
            <javadoc line="326">
                Allocates a new {@code Thread} object. This constructor has the same
                  effect as {@linkplain #Thread(ThreadGroup,Runnable,String) Thread}{@code (null, target, name)}.                
                <param>
                    targetthe object whose {@code run} method is invoked when this thread
                      is started. If {@code null}, this thread's run method is invoked.                    
                </param>
                <param>
                    namethe name of the new thread                    
                </param>
            </javadoc>
            <method name="Thread" type="constructor" line="333">
                <params>
                    <param name="target" type="Runnable"/>
                    <param name="name" type="String"/>
                </params>
            </method>
            <javadoc line="336">
                Allocates a new {@code Thread} object so that it has {@code target}as its run object, has the specified {@code name} as its name,
                  and belongs to the thread group referred to by {@code group}.
                  &lt;p&gt;If there is a security manager, its{@link SecurityManager#checkAccess(ThreadGroup) checkAccess}method is invoked with the ThreadGroup as its argument.
                  &lt;p&gt;In addition, its {@code checkPermission} method is invoked with
                  the {@code RuntimePermission(&quot;enableContextClassLoaderOverride&quot;)}permission when invoked directly or indirectly by the constructor
                  of a subclass which overrides the {@code getContextClassLoader}or {@code setContextClassLoader} methods.
                  &lt;p&gt;The priority of the newly created thread is set equal to the
                  priority of the thread creating it, that is, the currently running
                  thread. The method {@linkplain #setPriority setPriority} may be
                  used to change the priority to a new value.
                  &lt;p&gt;The newly created thread is initially marked as being a daemon
                  thread if and only if the thread creating it is currently marked
                  as a daemon thread. The method {@linkplain #setDaemon setDaemon}may be used to change whether or not a thread is a daemon.                
                <param>
                    groupthe thread group. If {@code null} and there is a security
                      manager, the group is determined by {@linkplain SecurityManager#getThreadGroup SecurityManager.getThreadGroup()}.
                      If there is not a security manager or 
                       returns {@code null}, the group
                      is set to the current thread's thread group.                    
                </param>
                <param>
                    targetthe object whose {@code run} method is invoked when this thread
                      is started. If {@code null}, this thread's run method is invoked.                    
                </param>
                <param>
                    namethe name of the new thread                    
                </param>
                <throws>
                    SecurityExceptionif the current thread cannot create a thread in the specified
                      thread group or cannot override the context class loader methods.                    
                </throws>
            </javadoc>
            <method name="Thread" type="constructor" line="360">
                <params>
                    <param name="group" type="ThreadGroup"/>
                    <param name="target" type="Runnable"/>
                    <param name="name" type="String"/>
                </params>
            </method>
            <javadoc line="363">
                Allocates a new {@code Thread} object so that it has {@code target}as its run object, has the specified {@code name} as its name,
                  and belongs to the thread group referred to by {@code group}, and has
                  the specified &lt;i&gt;stack size&lt;/i&gt;.
                  &lt;p&gt;This constructor is identical to {@link #Thread(ThreadGroup,Runnable,String)} with the exception of the fact
                  that it allows the thread stack size to be specified.  The stack size
                  is the approximate number of bytes of address space that the virtual
                  machine is to allocate for this thread&apos;s stack.  &lt;b&gt;The effect of the{@code stackSize} parameter, if any, is highly platform dependent.&lt;/b&gt;
                  &lt;p&gt;On some platforms, specifying a higher value for the{@code stackSize} parameter may allow a thread to achieve greater
                  recursion depth before throwing a {@link StackOverflowError}.
                  Similarly, specifying a lower value may allow a greater number of
                  threads to exist concurrently without throwing an {@link OutOfMemoryError} (or other internal error).  The details of
                  the relationship between the value of the &lt;tt&gt;stackSize&lt;/tt&gt; parameter
                  and the maximum recursion depth and concurrency level are
                  platform-dependent.  &lt;b&gt;On some platforms, the value of the{@code stackSize} parameter may have no effect whatsoever.&lt;/b&gt;
                  &lt;p&gt;The virtual machine is free to treat the {@code stackSize}parameter as a suggestion.  If the specified value is unreasonably low
                  for the platform, the virtual machine may instead use some
                  platform-specific minimum value; if the specified value is unreasonably
                  high, the virtual machine may instead use some platform-specific
                  maximum.  Likewise, the virtual machine is free to round the specified
                  value up or down as it sees fit (or to ignore it completely).
                  &lt;p&gt;Specifying a value of zero for the {@code stackSize} parameter will
                  cause this constructor to behave exactly like the{@code Thread(ThreadGroup, Runnable, String)} constructor.
                  &lt;p&gt;&lt;i&gt;Due to the platform-dependent nature of the behavior of this
                  constructor, extreme care should be exercised in its use.
                  The thread stack size necessary to perform a given computation will
                  likely vary from one JRE implementation to another.  In light of this
                  variation, careful tuning of the stack size parameter may be required,
                  and the tuning may need to be repeated for each JRE implementation on
                  which an application is to run.&lt;/i&gt;
                  &lt;p&gt;Implementation note: Java platform implementers are encouraged to
                  document their implementation&apos;s behavior with respect to the{@code stackSize} parameter.                
                <param>
                    groupthe thread group. If {@code null} and there is a security
                      manager, the group is determined by {@linkplain SecurityManager#getThreadGroup SecurityManager.getThreadGroup()}.
                      If there is not a security manager or 
                       returns {@code null}, the group
                      is set to the current thread's thread group.                    
                </param>
                <param>
                    targetthe object whose {@code run} method is invoked when this thread
                      is started. If {@code null}, this thread's run method is invoked.                    
                </param>
                <param>
                    namethe name of the new thread                    
                </param>
                <param>
                    stackSizethe desired stack size for the new thread, or zero to indicate
                      that this parameter is to be ignored.                    
                </param>
                <throws>
                    SecurityExceptionif the current thread cannot create a thread in the specified
                      thread group                    
                </throws>
                <since>
                    1.4                    
                </since>
            </javadoc>
            <method name="Thread" type="constructor" line="408">
                <params>
                    <param name="group" type="ThreadGroup"/>
                    <param name="target" type="Runnable"/>
                    <param name="name" type="String"/>
                    <param name="stackSize" type="long"/>
                </params>
            </method>
            <javadoc line="411">
                Causes this thread to begin execution; the Java Virtual Machine
                  calls the &lt;code&gt;run&lt;/code&gt; method of this thread.
                  &lt;p&gt;
                  The result is that two threads are running concurrently: the
                  current thread (which returns from the call to the
                  &lt;code&gt;start&lt;/code&gt; method) and the other thread (which executes its
                  &lt;code&gt;run&lt;/code&gt; method).
                  &lt;p&gt;
                  It is never legal to start a thread more than once.
                  In particular, a thread may not be restarted once it has completed
                  execution.                
                <exception>
                    IllegalThreadStateException  if the thread was already
                      started.                    
                </exception>
                <see>
                    #run()                    
                </see>
                <see>
                    #stop()                    
                </see>
            </javadoc>
            <method name="start" type="void" line="428">
                <declaration name="started" type="boolean" line="431"/>
                <scope line="432"/>
                <scope line="436">
                    <scope line="437">
                        <scope line="438"/>
                    </scope>
                    <scope line="442"/>
                </scope>
            </method>
            <method name="start0" type="void" line="446"/>
            <javadoc line="447">
                If this thread was constructed using a separate
                  &lt;code&gt;Runnable&lt;/code&gt; run object, then that
                  &lt;code&gt;Runnable&lt;/code&gt; object&apos;s &lt;code&gt;run&lt;/code&gt; method is called;
                  otherwise, this method does nothing and returns.
                  &lt;p&gt;
                  Subclasses of &lt;code&gt;Thread&lt;/code&gt; should override this method.                
                <see>
                    #start()                    
                </see>
                <see>
                    #stop()                    
                </see>
                <see>
                    #Thread(ThreadGroup,Runnable,String)                    
                </see>
            </javadoc>
            <method name="run" type="void" line="458">
                <scope line="459"/>
            </method>
            <javadoc line="463">
                This method is called by the system to give a Thread
                  a chance to clean up before it actually exits.                
            </javadoc>
            <method name="exit" type="void" line="467">
                <scope line="468"/>
            </method>
            <javadoc line="479">
                Forces the thread to stop executing.
                  &lt;p&gt;
                  If there is a security manager installed, its &lt;code&gt;checkAccess&lt;/code&gt;
                  method is called with &lt;code&gt;this&lt;/code&gt;
                  as its argument. This may result in a
                  &lt;code&gt;SecurityException&lt;/code&gt; being raised (in the current thread).
                  &lt;p&gt;
                  If this thread is different from the current thread (that is, the current
                  thread is trying to stop a thread other than itself), the
                  security manager&apos;s &lt;code&gt;checkPermission&lt;/code&gt; method (with a
                  &lt;code&gt;RuntimePermission(&quot;stopThread&quot;)&lt;/code&gt; argument) is called in
                  addition.
                  Again, this may result in throwing a
                  &lt;code&gt;SecurityException&lt;/code&gt; (in the current thread).
                  &lt;p&gt;
                  The thread represented by this thread is forced to stop whatever
                  it is doing abnormally and to throw a newly created
                  &lt;code&gt;ThreadDeath&lt;/code&gt; object as an exception.
                  &lt;p&gt;
                  It is permitted to stop a thread that has not yet been started.
                  If the thread is eventually started, it immediately terminates.
                  &lt;p&gt;
                  An application should not normally try to catch
                  &lt;code&gt;ThreadDeath&lt;/code&gt; unless it must do some extraordinary
                  cleanup operation (note that the throwing of
                  &lt;code&gt;ThreadDeath&lt;/code&gt; causes &lt;code&gt;finally&lt;/code&gt; clauses of
                  &lt;code&gt;try&lt;/code&gt; statements to be executed before the thread
                  officially dies).  If a &lt;code&gt;catch&lt;/code&gt; clause catches a
                  &lt;code&gt;ThreadDeath&lt;/code&gt; object, it is important to rethrow the
                  object so that the thread actually dies.
                  &lt;p&gt;
                  The top-level error handler that reacts to otherwise uncaught
                  exceptions does not print out a message or otherwise notify the
                  application if the uncaught exception is an instance of
                  &lt;code&gt;ThreadDeath&lt;/code&gt;.                
                <exception>
                    SecurityException  if the current thread cannot
                      modify this thread.                    
                </exception>
                <see>
                    #interrupt()                    
                </see>
                <see>
                    #checkAccess()                    
                </see>
                <see>
                    #run()                    
                </see>
                <see>
                    #start()                    
                </see>
                <see>
                    ThreadDeath                    
                </see>
                <see>
                    ThreadGroup#uncaughtException(Thread,Throwable)                    
                </see>
                <see>
                    SecurityManager#checkAccess(Thread)                    
                </see>
                <see>
                    SecurityManager#checkPermission                    
                </see>
                <deprecated>
                    This method is inherently unsafe.  Stopping a thread with
                      Thread.stop causes it to unlock all of the monitors that it
                      has locked (as a natural consequence of the unchecked
                      <code>ThreadDeath</code> exception propagating up the stack).  If
                      any of the objects previously protected by these monitors were in
                      an inconsistent state, the damaged objects become visible to
                      other threads, potentially resulting in arbitrary behavior.  Many
                      uses of <code>stop</code> should be replaced by code that simply
                      modifies some variable to indicate that the target thread should
                      stop running.  The target thread should check this variable
                      regularly, and return from its run method in an orderly fashion
                      if the variable indicates that it is to stop running.  If the
                      target thread waits for long periods (on a condition variable,
                      for example), the <code>interrupt</code> method should be used to
                      interrupt the wait.
                      For more information, see
                      <a href="{@docRoot}/../technotes/guides/concurrency/threadPrimitiveDeprecation.html">Why
                      are Thread.stop, Thread.suspend and Thread.resume Deprecated?</a>.                    
                </deprecated>
            </javadoc>
            <method name="stop" type="void" line="544"/>
            <javadoc line="547">
                Forces the thread to stop executing.
                  &lt;p&gt;
                  If there is a security manager installed, the &lt;code&gt;checkAccess&lt;/code&gt;
                  method of this thread is called, which may result in a
                  &lt;code&gt;SecurityException&lt;/code&gt; being raised (in the current thread).
                  &lt;p&gt;
                  If this thread is different from the current thread (that is, the current
                  thread is trying to stop a thread other than itself) or
                  &lt;code&gt;obj&lt;/code&gt; is not an instance of &lt;code&gt;ThreadDeath&lt;/code&gt;, the
                  security manager&apos;s &lt;code&gt;checkPermission&lt;/code&gt; method (with the
                  &lt;code&gt;RuntimePermission(&quot;stopThread&quot;)&lt;/code&gt; argument) is called in
                  addition.
                  Again, this may result in throwing a
                  &lt;code&gt;SecurityException&lt;/code&gt; (in the current thread).
                  &lt;p&gt;
                  If the argument &lt;code&gt;obj&lt;/code&gt; is null, a
                  &lt;code&gt;NullPointerException&lt;/code&gt; is thrown (in the current thread).
                  &lt;p&gt;
                  The thread represented by this thread is forced to stop
                  whatever it is doing abnormally and to throw the
                  &lt;code&gt;Throwable&lt;/code&gt; object &lt;code&gt;obj&lt;/code&gt; as an exception. This
                  is an unusual action to take; normally, the &lt;code&gt;stop&lt;/code&gt; method
                  that takes no arguments should be used.
                  &lt;p&gt;
                  It is permitted to stop a thread that has not yet been started.
                  If the thread is eventually started, it immediately terminates.                
                <param>
                    obj   the Throwable object to be thrown.                    
                </param>
                <exception>
                    SecurityException  if the current thread cannot modify
                      this thread.                    
                </exception>
                <throws>
                    NullPointerException if obj is <tt>null</tt>.                    
                </throws>
                <see>
                    #interrupt()                    
                </see>
                <see>
                    #checkAccess()                    
                </see>
                <see>
                    #run()                    
                </see>
                <see>
                    #start()                    
                </see>
                <see>
                    #stop()                    
                </see>
                <see>
                    SecurityManager#checkAccess(Thread)                    
                </see>
                <see>
                    SecurityManager#checkPermission                    
                </see>
                <deprecated>
                    This method is inherently unsafe.  See {@link #stop()}for details.  An additional danger of this
                      method is that it may be used to generate exceptions that the
                      target thread is unprepared to handle (including checked
                      exceptions that the thread could not possibly throw, were it
                      not for this method).
                      For more information, see
                      <a href="{@docRoot}/../technotes/guides/concurrency/threadPrimitiveDeprecation.html">Why
                      are Thread.stop, Thread.suspend and Thread.resume Deprecated?</a>.                    
                </deprecated>
            </javadoc>
            <method name="stop" type="void" line="594">
                <params>
                    <param name="obj" type="Throwable"/>
                </params>
                <declaration name="security" type="SecurityManager" line="596"/>
                <scope line="597">
                    <scope line="599"/>
                </scope>
                <scope line="603"/>
            </method>
            <javadoc line="608">
                Interrupts this thread.
                  &lt;p&gt; Unless the current thread is interrupting itself, which is
                  always permitted, the {@link #checkAccess() checkAccess} method
                  of this thread is invoked, which may cause a {@link SecurityException} to be thrown.
                  &lt;p&gt; If this thread is blocked in an invocation of the {@link Object#wait() wait()}, {@link Object#wait(long) wait(long)}, or {@link Object#wait(long,int) wait(long, int)} methods of the {@link Object}class, or of the {@link #join()}, {@link #join(long)}, {@link #join(long,int)}, {@link #sleep(long)}, or {@link #sleep(long,int)},
                  methods of this class, then its interrupt status will be cleared and it
                  will receive an {@link InterruptedException}.
                  &lt;p&gt; If this thread is blocked in an I/O operation upon an {@link java.nio.channels.InterruptibleChannel &lt;/code&gt;interruptible
                  channel&lt;code&gt;} then the channel will be closed, the thread&apos;s interrupt
                  status will be set, and the thread will receive a {@link java.nio.channels.ClosedByInterruptException}.
                  &lt;p&gt; If this thread is blocked in a {@link java.nio.channels.Selector}then the thread&apos;s interrupt status will be set and it will return
                  immediately from the selection operation, possibly with a non-zero
                  value, just as if the selector&apos;s {@link java.nio.channels.Selector#wakeup wakeup} method were invoked.
                  &lt;p&gt; If none of the previous conditions hold then this thread&apos;s interrupt
                  status will be set. &lt;/p&gt;
                  &lt;p&gt; Interrupting a thread that is not alive need not have any effect.                
                <throws>
                    SecurityExceptionif the current thread cannot modify this thread                    
                </throws>
                <revised>
                    6.0                    
                </revised>
                <spec>
                    JSR-51                    
                </spec>
            </javadoc>
            <method name="interrupt" type="void" line="629">
                <scope line="631">
                    <declaration name="b" type="Interruptible" line="632"/>
                    <scope line="633"/>
                </scope>
            </method>
            <javadoc line="641">
                Tests whether the current thread has been interrupted.  The
                  &lt;i&gt;interrupted status&lt;/i&gt; of the thread is cleared by this method.  In
                  other words, if this method were to be called twice in succession, the
                  second call would return false (unless the current thread were
                  interrupted again, after the first call had cleared its interrupted
                  status and before the second call had examined it).
                  &lt;p&gt;A thread interruption ignored because a thread was not alive
                  at the time of the interrupt will be reflected by this method
                  returning false.                
                <return>
                    <code>true</code> if the current thread has been interrupted;
                      <code>false</code> otherwise.                    
                </return>
                <see>
                    #isInterrupted()                    
                </see>
                <revised>
                    6.0                    
                </revised>
            </javadoc>
            <method name="interrupted" type="boolean" line="656"/>
            <javadoc line="659">
                Tests whether this thread has been interrupted.  The &lt;i&gt;interrupted
                  status&lt;/i&gt; of the thread is unaffected by this method.
                  &lt;p&gt;A thread interruption ignored because a thread was not alive
                  at the time of the interrupt will be reflected by this method
                  returning false.                
                <return>
                    <code>true</code> if this thread has been interrupted;
                      <code>false</code> otherwise.                    
                </return>
                <see>
                    #interrupted()                    
                </see>
                <revised>
                    6.0                    
                </revised>
            </javadoc>
            <method name="isInterrupted" type="boolean" line="670"/>
            <method name="isInterrupted" type="boolean" line="673"/>
            <javadoc line="673">
                Tests if some Thread has been interrupted.  The interrupted state
                  is reset or not based on the value of ClearInterrupted that is
                  passed.                
            </javadoc>
            <javadoc line="679">
                Throws {@link NoSuchMethodError}.                
                <deprecated>
                    This method was originally designed to destroy this
                      thread without any cleanup. Any monitors it held would have
                      remained locked. However, the method was never implemented.
                      If if were to be implemented, it would be deadlock-prone in
                      much the manner of {@link #suspend}. If the target thread held
                      a lock protecting a critical system resource when it was
                      destroyed, no thread could ever access this resource again.
                      If another thread ever attempted to lock this resource, deadlock
                      would result. Such deadlocks typically manifest themselves as
                      "frozen" processes. For more information, see
                      <a href="{@docRoot}/../technotes/guides/concurrency/threadPrimitiveDeprecation.html">
                      Why are Thread.stop, Thread.suspend and Thread.resume Deprecated?</a>.                    
                </deprecated>
                <throws>
                    NoSuchMethodError always                    
                </throws>
            </javadoc>
            <method name="destroy" type="void" line="695"/>
            <method name="isAlive" type="boolean" line="698"/>
            <javadoc line="698">
                Tests if this thread is alive. A thread is alive if it has
                  been started and has not yet died.                
                <return>
                    <code>true</code> if this thread is alive;
                      <code>false</code> otherwise.                    
                </return>
            </javadoc>
            <javadoc line="705">
                Suspends this thread.
                  &lt;p&gt;
                  First, the &lt;code&gt;checkAccess&lt;/code&gt; method of this thread is called
                  with no arguments. This may result in throwing a
                  &lt;code&gt;SecurityException &lt;/code&gt;(in the current thread).
                  &lt;p&gt;
                  If the thread is alive, it is suspended and makes no further
                  progress unless and until it is resumed.                
                <exception>
                    SecurityException  if the current thread cannot modify
                      this thread.                    
                </exception>
                <see>
                    #checkAccess                    
                </see>
                <deprecated>
                    This method has been deprecated, as it is
                      inherently deadlock-prone.  If the target thread holds a lock on the
                      monitor protecting a critical system resource when it is suspended, no
                      thread can access this resource until the target thread is resumed. If
                      the thread that would resume the target thread attempts to lock this
                      monitor prior to calling <code>resume</code>, deadlock results.  Such
                      deadlocks typically manifest themselves as "frozen" processes.
                      For more information, see
                      <a href="{@docRoot}/../technotes/guides/concurrency/threadPrimitiveDeprecation.html">Why
                      are Thread.stop, Thread.suspend and Thread.resume Deprecated?</a>.                    
                </deprecated>
            </javadoc>
            <method name="suspend" type="void" line="728"/>
            <javadoc line="732">
                Resumes a suspended thread.
                  &lt;p&gt;
                  First, the &lt;code&gt;checkAccess&lt;/code&gt; method of this thread is called
                  with no arguments. This may result in throwing a
                  &lt;code&gt;SecurityException&lt;/code&gt; (in the current thread).
                  &lt;p&gt;
                  If the thread is alive but suspended, it is resumed and is
                  permitted to make progress in its execution.                
                <exception>
                    SecurityException  if the current thread cannot modify this
                      thread.                    
                </exception>
                <see>
                    #checkAccess                    
                </see>
                <see>
                    #suspend()                    
                </see>
                <deprecated>
                    This method exists solely for use with {@link #suspend},
                      which has been deprecated because it is deadlock-prone.
                      For more information, see
                      <a href="{@docRoot}/../technotes/guides/concurrency/threadPrimitiveDeprecation.html">Why
                      are Thread.stop, Thread.suspend and Thread.resume Deprecated?</a>.                    
                </deprecated>
            </javadoc>
            <method name="resume" type="void" line="751"/>
            <javadoc line="755">
                Changes the priority of this thread.
                  &lt;p&gt;
                  First the &lt;code&gt;checkAccess&lt;/code&gt; method of this thread is called
                  with no arguments. This may result in throwing a
                  &lt;code&gt;SecurityException&lt;/code&gt;.
                  &lt;p&gt;
                  Otherwise, the priority of this thread is set to the smaller of
                  the specified &lt;code&gt;newPriority&lt;/code&gt; and the maximum permitted
                  priority of the thread&apos;s thread group.                
                <param>
                    newPriority priority to set this thread to                    
                </param>
                <exception>
                    IllegalArgumentException  If the priority is not in the
                      range <code>MIN_PRIORITY</code> to
                      <code>MAX_PRIORITY</code>.                    
                </exception>
                <exception>
                    SecurityException  if the current thread cannot modify
                      this thread.                    
                </exception>
                <see>
                    #getPriority                    
                </see>
                <see>
                    #checkAccess()                    
                </see>
                <see>
                    #getThreadGroup()                    
                </see>
                <see>
                    #MAX_PRIORITY                    
                </see>
                <see>
                    #MIN_PRIORITY                    
                </see>
                <see>
                    ThreadGroup#getMaxPriority()                    
                </see>
            </javadoc>
            <method name="setPriority" type="void" line="778">
                <params>
                    <param name="newPriority" type="int"/>
                </params>
                <declaration name="g" type="ThreadGroup" line="779"/>
                <scope line="781"/>
                <scope line="784">
                    <scope line="785"/>
                </scope>
            </method>
            <javadoc line="791">
                Returns this thread&apos;s priority.                
                <return>
                    this thread's priority.                    
                </return>
                <see>
                    #setPriority                    
                </see>
            </javadoc>
            <method name="getPriority" type="int" line="796"/>
            <javadoc line="799">
                Changes the name of this thread to be equal to the argument
                  &lt;code&gt;name&lt;/code&gt;.
                  &lt;p&gt;
                  First the &lt;code&gt;checkAccess&lt;/code&gt; method of this thread is called
                  with no arguments. This may result in throwing a
                  &lt;code&gt;SecurityException&lt;/code&gt;.                
                <param>
                    name   the new name for this thread.                    
                </param>
                <exception>
                    SecurityException  if the current thread cannot modify this
                      thread.                    
                </exception>
                <see>
                    #getName                    
                </see>
                <see>
                    #checkAccess()                    
                </see>
            </javadoc>
            <method name="setName" type="void" line="812">
                <params>
                    <param name="name" type="String"/>
                </params>
            </method>
            <javadoc line="816">
                Returns this thread&apos;s name.                
                <return>
                    this thread's name.                    
                </return>
                <see>
                    #setName(String)                    
                </see>
            </javadoc>
            <method name="getName" type="String" line="821"/>
            <javadoc line="824">
                Returns the thread group to which this thread belongs.
                  This method returns null if this thread has died
                  (been stopped).                
                <return>
                    this thread's thread group.                    
                </return>
            </javadoc>
            <method name="getThreadGroup" type="ThreadGroup" line="830"/>
            <javadoc line="833">
                Returns an estimate of the number of active threads in the current
                  thread&apos;s {@linkplain java.lang.ThreadGroup thread group} and its
                  subgroups. Recursively iterates over all subgroups in the current
                  thread&apos;s thread group.
                  &lt;p&gt; The value returned is only an estimate because the number of
                  threads may change dynamically while this method traverses internal
                  data structures, and might be affected by the presence of certain
                  system threads. This method is intended primarily for debugging
                  and monitoring purposes.                
                <return>
                    an estimate of the number of active threads in the current
                      thread's thread group and in any other thread group that
                      has the current thread's thread group as an ancestor                    
                </return>
            </javadoc>
            <method name="activeCount" type="int" line="847"/>
            <javadoc line="850">
                Copies into the specified array every active thread in the current
                  thread&apos;s thread group and its subgroups. This method simply
                  invokes the {@link java.lang.ThreadGroup#enumerate(Thread[])}method of the current thread&apos;s thread group.
                  &lt;p&gt; An application might use the {@linkplain #activeCount activeCount}method to get an estimate of how big the array should be, however
                  &lt;i&gt;if the array is too short to hold all the threads, the extra threads
                  are silently ignored.&lt;/i&gt;  If it is critical to obtain every active
                  thread in the current thread&apos;s thread group and its subgroups, the
                  invoker should verify that the returned int value is strictly less
                  than the length of {@code tarray}.
                  &lt;p&gt; Due to the inherent race condition in this method, it is recommended
                  that the method only be used for debugging and monitoring purposes.                
                <param>
                    tarrayan array into which to put the list of threads                    
                </param>
                <return>
                    the number of threads put into the array                    
                </return>
                <throws>
                    SecurityExceptionif {@link java.lang.ThreadGroup#checkAccess} determines that
                      the current thread cannot access its thread group                    
                </throws>
            </javadoc>
            <method name="enumerate" type="int" line="867">
                <params>
                    <param name="tarray" type="Thread"/>
                </params>
            </method>
            <method name="countStackFrames" type="int" line="870"/>
            <javadoc line="870">
                Counts the number of stack frames in this thread. The thread must
                  be suspended.                
                <return>
                    the number of stack frames in this thread.                    
                </return>
                <exception>
                    IllegalThreadStateException  if this thread is not
                      suspended.                    
                </exception>
                <deprecated>
                    The definition of this call depends on {@link #suspend},
                      which is deprecated.  Further, the results of this call
                      were never well-defined.                    
                </deprecated>
            </javadoc>
            <javadoc line="881">
                Waits at most {@code millis} milliseconds for this thread to
                  die. A timeout of {@code 0} means to wait forever.
                  &lt;p&gt; This implementation uses a loop of {@code this.wait} calls
                  conditioned on {@code this.isAlive}. As a thread terminates the{@code this.notifyAll} method is invoked. It is recommended that
                  applications not use {@code wait}, {@code notify}, or{@code notifyAll} on {@code Thread} instances.                
                <param>
                    millisthe time to wait in milliseconds                    
                </param>
                <throws>
                    IllegalArgumentExceptionif the value of {@code millis} is negative                    
                </throws>
                <throws>
                    InterruptedExceptionif any thread has interrupted the current thread. The
                      <i>interrupted status</i> of the current thread is
                      cleared when this exception is thrown.                    
                </throws>
            </javadoc>
            <method name="join" type="void" line="893">
                <params>
                    <param name="millis" type="long"/>
                </params>
                <declaration name="base" type="long" line="894"/>
                <declaration name="now" type="long" line="895"/>
                <scope line="896"/>
                <scope line="899">
                    <scope line="900"/>
                </scope>
                <scope line="904">
                    <scope line="905">
                        <declaration name="delay" type="long" line="906"/>
                        <scope line="907"/>
                    </scope>
                </scope>
            </method>
            <javadoc line="915">
                Waits at most {@code millis} milliseconds plus{@code nanos} nanoseconds for this thread to die.
                  &lt;p&gt; This implementation uses a loop of {@code this.wait} calls
                  conditioned on {@code this.isAlive}. As a thread terminates the{@code this.notifyAll} method is invoked. It is recommended that
                  applications not use {@code wait}, {@code notify}, or{@code notifyAll} on {@code Thread} instances.                
                <param>
                    millisthe time to wait in milliseconds                    
                </param>
                <param>
                    nanos {@code 0-999999} additional nanoseconds to wait                    
                </param>
                <throws>
                    IllegalArgumentExceptionif the value of {@code millis} is negative, or the value
                      of {@code nanos} is not in the range {@code 0-999999}                    
                </throws>
                <throws>
                    InterruptedExceptionif any thread has interrupted the current thread. The
                      <i>interrupted status</i> of the current thread is
                      cleared when this exception is thrown.                    
                </throws>
            </javadoc>
            <method name="join" type="void" line="928">
                <params>
                    <param name="millis" type="long"/>
                    <param name="nanos" type="int"/>
                </params>
                <scope line="929"/>
                <scope line="932"/>
                <scope line="935"/>
            </method>
            <javadoc line="940">
                Waits for this thread to die.
                  &lt;p&gt; An invocation of this method behaves in exactly the same
                  way as the invocation
                  &lt;blockquote&gt;{@linkplain #join(long) join}{@code (0)}&lt;/blockquote&gt;                
                <throws>
                    InterruptedExceptionif any thread has interrupted the current thread. The
                      <i>interrupted status</i> of the current thread is
                      cleared when this exception is thrown.                    
                </throws>
            </javadoc>
            <method name="join" type="void" line="949"/>
            <javadoc line="952">
                Prints a stack trace of the current thread to the standard error stream.
                  This method is used only for debugging.                
                <see>
                    Throwable#printStackTrace()                    
                </see>
            </javadoc>
            <method name="dumpStack" type="void" line="957"/>
            <javadoc line="960">
                Marks this thread as either a {@linkplain #isDaemon daemon} thread
                  or a user thread. The Java Virtual Machine exits when the only
                  threads running are all daemon threads.
                  &lt;p&gt; This method must be invoked before the thread is started.                
                <param>
                    onif {@code true}, marks this thread as a daemon thread                    
                </param>
                <throws>
                    IllegalThreadStateExceptionif this thread is {@linkplain #isAlive alive}                    
                </throws>
                <throws>
                    SecurityExceptionif {@link #checkAccess} determines that the current
                      thread cannot modify this thread                    
                </throws>
            </javadoc>
            <method name="setDaemon" type="void" line="970">
                <params>
                    <param name="on" type="boolean"/>
                </params>
                <scope line="972"/>
            </method>
            <javadoc line="977">
                Tests if this thread is a daemon thread.                
                <return>
                    <code>true</code> if this thread is a daemon thread;
                      <code>false</code> otherwise.                    
                </return>
                <see>
                    #setDaemon(boolean)                    
                </see>
            </javadoc>
            <method name="isDaemon" type="boolean" line="983"/>
            <javadoc line="986">
                Determines if the currently running thread has permission to
                  modify this thread.
                  &lt;p&gt;
                  If there is a security manager, its &lt;code&gt;checkAccess&lt;/code&gt; method
                  is called with this thread as its argument. This may result in
                  throwing a &lt;code&gt;SecurityException&lt;/code&gt;.                
                <exception>
                    SecurityException  if the current thread is not allowed to
                      access this thread.                    
                </exception>
                <see>
                    SecurityManager#checkAccess(Thread)                    
                </see>
            </javadoc>
            <method name="checkAccess" type="void" line="997">
                <declaration name="security" type="SecurityManager" line="998"/>
                <scope line="999"/>
            </method>
            <javadoc line="1003">
                Returns a string representation of this thread, including the
                  thread&apos;s name, priority, and thread group.                
                <return>
                    a string representation of this thread.                    
                </return>
            </javadoc>
            <method name="toString" type="String" line="1008">
                <declaration name="group" type="ThreadGroup" line="1009"/>
                <scope line="1010"/>
                <scope line="1013"/>
            </method>
            <javadoc line="1017">
                Returns the context ClassLoader for this Thread. The context
                  ClassLoader is provided by the creator of the thread for use
                  by code running in this thread when loading classes and resources.
                  If not {@linkplain #setContextClassLoader set}, the default is the
                  ClassLoader context of the parent Thread. The context ClassLoader of the
                  primordial thread is typically set to the class loader used to load the
                  application.
                  &lt;p&gt;If a security manager is present, and the invoker&apos;s class loader is not{@code null} and is not the same as or an ancestor of the context class
                  loader, then this method invokes the security manager&apos;s {@link SecurityManager#checkPermission(java.security.Permission) checkPermission}method with a {@link RuntimePermission RuntimePermission
                  &quot;getClassLoader&quot;)} permission to verify that retrieval of the context
                  class loader is permitted.                
                <return>
                    the context ClassLoader for this Thread, or {@code null}indicating the system class loader (or, failing that, the
                      bootstrap class loader)                    
                </return>
                <throws>
                    SecurityExceptionif the current thread cannot get the context ClassLoader                    
                </throws>
                <since>
                    1.2                    
                </since>
            </javadoc>
            <method name="getContextClassLoader" type="ClassLoader" line="1033">
                <declaration name="sm" type="SecurityManager" line="1035"/>
                <scope line="1036">
                    <declaration name="ccl" type="ClassLoader" line="1037"/>
                    <scope line="1038"/>
                </scope>
            </method>
            <javadoc line="1044">
                Sets the context ClassLoader for this Thread. The context
                  ClassLoader can be set when a thread is created, and allows
                  the creator of the thread to provide the appropriate class loader,
                  through {@code getContextClassLoader}, to code running in the thread
                  when loading classes and resources.
                  &lt;p&gt;If a security manager is present, its {@link SecurityManager#checkPermission(java.security.Permission) checkPermission}method is invoked with a {@link RuntimePermission RuntimePermission
                  &quot;setContextClassLoader&quot;)} permission to see if setting the context
                  ClassLoader is permitted.                
                <param>
                    clthe context ClassLoader for this Thread, or null  indicating the
                      system class loader (or, failing that, the bootstrap class loader)                    
                </param>
                <throws>
                    SecurityExceptionif the current thread cannot set the context ClassLoader                    
                </throws>
                <since>
                    1.2                    
                </since>
            </javadoc>
            <method name="setContextClassLoader" type="void" line="1057">
                <params>
                    <param name="cl" type="ClassLoader"/>
                </params>
                <declaration name="sm" type="SecurityManager" line="1058"/>
                <scope line="1059"/>
            </method>
            <method name="holdsLock" type="boolean" line="1064"/>
            <javadoc line="1064">
                Returns &lt;tt&gt;true&lt;/tt&gt; if and only if the current thread holds the
                  monitor lock on the specified object.
                  &lt;p&gt;This method is designed to allow a program to assert that
                  the current thread already holds a specified lock:
                  &lt;pre&gt;
                  assert Thread.holdsLock(obj);
                  &lt;/pre&gt;                
                <param>
                    obj the object on which to test lock ownership                    
                </param>
                <throws>
                    NullPointerException if obj is <tt>null</tt>                    
                </throws>
                <return>
                    <tt>true</tt> if the current thread holds the monitor lock on
                      the specified object.                    
                </return>
                <since>
                    1.4                    
                </since>
            </javadoc>
            <declaration name="EMPTY_STACK_TRACE" type="StackTraceElement[]" line="1079"/>
            <javadoc line="1080">
                Returns an array of stack trace elements representing the stack dump
                  of this thread.  This method will return a zero-length array if
                  this thread has not started, has started but has not yet been
                  scheduled to run by the system, or has terminated.
                  If the returned array is of non-zero length then the first element of
                  the array represents the top of the stack, which is the most recent
                  method invocation in the sequence.  The last element of the array
                  represents the bottom of the stack, which is the least recent method
                  invocation in the sequence.
                  &lt;p&gt;If there is a security manager, and this thread is not
                  the current thread, then the security manager&apos;s
                  &lt;tt&gt;checkPermission&lt;/tt&gt; method is called with a
                  &lt;tt&gt;RuntimePermission(&quot;getStackTrace&quot;)&lt;/tt&gt; permission
                  to see if it&apos;s ok to get the stack trace.
                  &lt;p&gt;Some virtual machines may, under some circumstances, omit one
                  or more stack frames from the stack trace.  In the extreme case,
                  a virtual machine that has no stack trace information concerning
                  this thread is permitted to return a zero-length array from this
                  method.                
                <return>
                    an array of <tt>StackTraceElement</tt>,
                      each represents one stack frame.                    
                </return>
                <throws>
                    SecurityExceptionif a security manager exists and its
                      <tt>checkPermission</tt> method doesn't allow
                      getting the stack trace of thread.                    
                </throws>
                <see>
                    SecurityManager#checkPermission                    
                </see>
                <see>
                    RuntimePermission                    
                </see>
                <see>
                    Throwable#getStackTrace                    
                </see>
                <since>
                    1.5                    
                </since>
            </javadoc>
            <method name="getStackTrace" type="StackTraceElement[]" line="1110">
                <scope line="1111">
                    <declaration name="security" type="SecurityManager" line="1112"/>
                    <scope line="1113"/>
                    <scope line="1116"/>
                    <declaration name="stackTraceArray" type="StackTraceElement[][]" line="1119"/>
                    <declaration name="stackTrace" type="StackTraceElement[]" line="1120"/>
                    <scope line="1121"/>
                </scope>
                <scope line="1126"/>
            </method>
            <javadoc line="1130">
                Returns a map of stack traces for all live threads.
                  The map keys are threads and each map value is an array of
                  &lt;tt&gt;StackTraceElement&lt;/tt&gt; that represents the stack dump
                  of the corresponding &lt;tt&gt;Thread&lt;/tt&gt;.
                  The returned stack traces are in the format specified for
                  the {@link #getStackTrace getStackTrace} method.
                  &lt;p&gt;The threads may be executing while this method is called.
                  The stack trace of each thread only represents a snapshot and
                  each stack trace may be obtained at different time.  A zero-length
                  array will be returned in the map value if the virtual machine has
                  no stack trace information about a thread.
                  &lt;p&gt;If there is a security manager, then the security manager&apos;s
                  &lt;tt&gt;checkPermission&lt;/tt&gt; method is called with a
                  &lt;tt&gt;RuntimePermission(&quot;getStackTrace&quot;)&lt;/tt&gt; permission as well as
                  &lt;tt&gt;RuntimePermission(&quot;modifyThreadGroup&quot;)&lt;/tt&gt; permission
                  to see if it is ok to get the stack trace of all threads.                
                <return>
                    a <tt>Map</tt> from <tt>Thread</tt> to an array of
                      <tt>StackTraceElement</tt> that represents the stack trace of
                      the corresponding thread.                    
                </return>
                <throws>
                    SecurityExceptionif a security manager exists and its
                      <tt>checkPermission</tt> method doesn't allow
                      getting the stack trace of thread.                    
                </throws>
                <see>
                    #getStackTrace                    
                </see>
                <see>
                    SecurityManager#checkPermission                    
                </see>
                <see>
                    RuntimePermission                    
                </see>
                <see>
                    Throwable#getStackTrace                    
                </see>
                <since>
                    1.5                    
                </since>
            </javadoc>
            <method name="getAllStackTraces" type="Map<Thread,StackTraceElement[]>" line="1159">
                <declaration name="security" type="SecurityManager" line="1160"/>
                <scope line="1161"/>
                <declaration name="threads" type="Thread[]" line="1165"/>
                <declaration name="traces" type="StackTraceElement[][]" line="1166"/>
                <declaration name="m" type="Map&lt;Thread,StackTraceElement[]&gt;" line="1167"/>
                <scope line="1168">
                    <declaration name="stackTrace" type="StackTraceElement[]" line="1169"/>
                    <scope line="1170"/>
                </scope>
            </method>
            <declaration name="SUBCLASS_IMPLEMENTATION_PERMISSION" type="RuntimePermission" line="1176"/>
            <class name="Caches" line="1177">
                <javadoc line="1177">
                    cache of subclass security audit results                    
                </javadoc>
                <declaration name="subclassAudits" type="ConcurrentMap&lt;WeakClassKey,Boolean&gt;" line="1181"/>
                <javadoc line="1181">
                    cache of subclass security audit results                    
                </javadoc>
                <declaration name="subclassAuditsQueue" type="ReferenceQueue&lt;Class&lt;?&gt;&gt;" line="1185"/>
                <javadoc line="1185">
                    queue for WeakReferences to audited subclasses                    
                </javadoc>
            </class>
            <javadoc line="1190">
                Verifies that this (possibly subclass) instance can be constructed
                  without violating security constraints: the subclass must not override
                  security-sensitive non-final methods, or else the
                  &quot;enableContextClassLoaderOverride&quot; RuntimePermission is checked.                
            </javadoc>
            <method name="isCCLOverridden" type="boolean" line="1196">
                <params>
                    <param name="cl" type="Class"/>
                </params>
                <declaration name="key" type="WeakClassKey" line="1199"/>
                <declaration name="result" type="Boolean" line="1200"/>
                <scope line="1201"/>
            </method>
            <javadoc line="1207">
                Performs reflective checks on given subclass to verify that it doesn&apos;t
                  override security-sensitive non-final methods.  Returns true if the
                  subclass overrides any of the methods, false otherwise.                
            </javadoc>
            <method name="auditSubclass" type="boolean" line="1212">
                <params>
                    <param name="subcl" type="Class"/>
                </params>
                <anonymous_class line="1213">
                    <method name="run" type="Boolean" line="1214">
                        <scope line="1215">
                            <scope line="1216"/>
                            <scope line="1220"/>
                            <scope line="1222">
                                <declaration name="params" type="Class[]" line="1223"/>
                            </scope>
                            <scope line="1227"/>
                        </scope>
                    </method>
                </anonymous_class>
                <declaration name="result" type="Boolean" line="1213"/>
            </method>
            <method name="dumpThreads" type="StackTraceElement[][]" line="1236"/>
            <method name="getThreads" type="Thread[]" line="1237"/>
            <javadoc line="1238">
                Returns the identifier of this Thread.  The thread ID is a positive
                  &lt;tt&gt;long&lt;/tt&gt; number generated when this thread was created.
                  The thread ID is unique and remains unchanged during its lifetime.
                  When a thread is terminated, this thread ID may be reused.                
                <return>
                    this thread's ID.                    
                </return>
                <since>
                    1.5                    
                </since>
            </javadoc>
            <method name="getId" type="long" line="1246"/>
            <declaration name="State" type="enum" line="1249"/>
            <javadoc line="1249">
                A thread state.  A thread can be in one of the following states:
                  &lt;ul&gt;
                  &lt;li&gt;{@link #NEW}&lt;br&gt;
                  A thread that has not yet started is in this state.
                  &lt;/li&gt;
                  &lt;li&gt;{@link #RUNNABLE}&lt;br&gt;
                  A thread executing in the Java virtual machine is in this state.
                  &lt;/li&gt;
                  &lt;li&gt;{@link #BLOCKED}&lt;br&gt;
                  A thread that is blocked waiting for a monitor lock
                  is in this state.
                  &lt;/li&gt;
                  &lt;li&gt;{@link #WAITING}&lt;br&gt;
                  A thread that is waiting indefinitely for another thread to
                  perform a particular action is in this state.
                  &lt;/li&gt;
                  &lt;li&gt;{@link #TIMED_WAITING}&lt;br&gt;
                  A thread that is waiting for another thread to perform an action
                  for up to a specified waiting time is in this state.
                  &lt;/li&gt;
                  &lt;li&gt;{@link #TERMINATED}&lt;br&gt;
                  A thread that has exited is in this state.
                  &lt;/li&gt;
                  &lt;/ul&gt;
                  &lt;p&gt;
                  A thread can be in only one state at a given point in time.
                  These states are virtual machine states which do not reflect
                  any operating system thread states.                
                <since>
                    1.5                    
                </since>
                <see>
                    #getState                    
                </see>
            </javadoc>
            <scope line="1281"/>
            <javadoc line="1330">
                Returns the state of this thread.
                  This method is designed for use in monitoring of the system state,
                  not for synchronization control.                
                <return>
                    this thread's state.                    
                </return>
                <since>
                    1.5                    
                </since>
            </javadoc>
            <method name="getState" type="State" line="1337"/>
            <interface name="UncaughtExceptionHandler">
                <javadoc line="1340">
                    Interface for handlers invoked when a &lt;tt&gt;Thread&lt;/tt&gt; abruptly
                      terminates due to an uncaught exception.
                      &lt;p&gt;When a thread is about to terminate due to an uncaught exception
                      the Java Virtual Machine will query the thread for its
                      &lt;tt&gt;UncaughtExceptionHandler&lt;/tt&gt; using{@link #getUncaughtExceptionHandler} and will invoke the handler&apos;s
                      &lt;tt&gt;uncaughtException&lt;/tt&gt; method, passing the thread and the
                      exception as arguments.
                      If a thread has not had its &lt;tt&gt;UncaughtExceptionHandler&lt;/tt&gt;
                      explicitly set, then its &lt;tt&gt;ThreadGroup&lt;/tt&gt; object acts as its
                      &lt;tt&gt;UncaughtExceptionHandler&lt;/tt&gt;. If the &lt;tt&gt;ThreadGroup&lt;/tt&gt; object
                      has no
                      special requirements for dealing with the exception, it can forward
                      the invocation to the {@linkplain #getDefaultUncaughtExceptionHandlerdefault uncaught exception handler}.                    
                    <see>
                        #setDefaultUncaughtExceptionHandler                        
                    </see>
                    <see>
                        #setUncaughtExceptionHandler                        
                    </see>
                    <see>
                        ThreadGroup#uncaughtException                        
                    </see>
                    <since>
                        1.5                        
                    </since>
                </javadoc>
                <method name="uncaughtException" type="void" line="1360"/>
                <javadoc line="1360">
                    Method invoked when the given thread terminates due to the
                      given uncaught exception.
                      &lt;p&gt;Any exception thrown by this method will be ignored by the
                      Java Virtual Machine.                    
                    <param>
                        t the thread                        
                    </param>
                    <param>
                        e the exception                        
                    </param>
                </javadoc>
            </interface>
            <declaration name="uncaughtExceptionHandler" type="UncaughtExceptionHandler" line="1370"/>
            <declaration name="defaultUncaughtExceptionHandler" type="UncaughtExceptionHandler" line="1371"/>
            <javadoc line="1372">
                Set the default handler invoked when a thread abruptly terminates
                  due to an uncaught exception, and no other handler has been defined
                  for that thread.
                  &lt;p&gt;Uncaught exception handling is controlled first by the thread, then
                  by the thread&apos;s {@link ThreadGroup} object and finally by the default
                  uncaught exception handler. If the thread does not have an explicit
                  uncaught exception handler set, and the thread&apos;s thread group
                  (including parent thread groups)  does not specialize its
                  &lt;tt&gt;uncaughtException&lt;/tt&gt; method, then the default handler&apos;s
                  &lt;tt&gt;uncaughtException&lt;/tt&gt; method will be invoked.
                  &lt;p&gt;By setting the default uncaught exception handler, an application
                  can change the way in which uncaught exceptions are handled (such as
                  logging to a specific device, or file) for those threads that would
                  already accept whatever &amp;quot;default&amp;quot; behavior the system
                  provided.
                  &lt;p&gt;Note that the default uncaught exception handler should not usually
                  defer to the thread&apos;s &lt;tt&gt;ThreadGroup&lt;/tt&gt; object, as that could cause
                  infinite recursion.                
                <param>
                    eh the object to use as the default uncaught exception handler.
                      If <tt>null</tt> then there is no default handler.                    
                </param>
                <throws>
                    SecurityException if a security manager is present and it
                      denies <tt>{@link RuntimePermission}(&quot;setDefaultUncaughtExceptionHandler&quot;)</tt>                    
                </throws>
                <see>
                    #setUncaughtExceptionHandler                    
                </see>
                <see>
                    #getUncaughtExceptionHandler                    
                </see>
                <see>
                    ThreadGroup#uncaughtException                    
                </see>
                <since>
                    1.5                    
                </since>
            </javadoc>
            <method name="setDefaultUncaughtExceptionHandler" type="void" line="1400">
                <params>
                    <param name="eh" type="UncaughtExceptionHandler"/>
                </params>
                <declaration name="sm" type="SecurityManager" line="1401"/>
                <scope line="1402"/>
            </method>
            <javadoc line="1407">
                Returns the default handler invoked when a thread abruptly terminates
                  due to an uncaught exception. If the returned value is &lt;tt&gt;null&lt;/tt&gt;,
                  there is no default.                
                <since>
                    1.5                    
                </since>
                <see>
                    #setDefaultUncaughtExceptionHandler                    
                </see>
            </javadoc>
            <method name="getDefaultUncaughtExceptionHandler" type="UncaughtExceptionHandler" line="1414"/>
            <javadoc line="1417">
                Returns the handler invoked when this thread abruptly terminates
                  due to an uncaught exception. If this thread has not had an
                  uncaught exception handler explicitly set then this thread&apos;s
                  &lt;tt&gt;ThreadGroup&lt;/tt&gt; object is returned, unless this thread
                  has terminated, in which case &lt;tt&gt;null&lt;/tt&gt; is returned.                
                <since>
                    1.5                    
                </since>
            </javadoc>
            <method name="getUncaughtExceptionHandler" type="UncaughtExceptionHandler" line="1425"/>
            <javadoc line="1428">
                Set the handler invoked when this thread abruptly terminates
                  due to an uncaught exception.
                  &lt;p&gt;A thread can take full control of how it responds to uncaught
                  exceptions by having its uncaught exception handler explicitly set.
                  If no such handler is set then the thread&apos;s &lt;tt&gt;ThreadGroup&lt;/tt&gt;
                  object acts as its handler.                
                <param>
                    eh the object to use as this thread's uncaught exception
                      handler. If <tt>null</tt> then this thread has no explicit handler.                    
                </param>
                <throws>
                    SecurityException  if the current thread is not allowed to
                      modify this thread.                    
                </throws>
                <see>
                    #setDefaultUncaughtExceptionHandler                    
                </see>
                <see>
                    ThreadGroup#uncaughtException                    
                </see>
                <since>
                    1.5                    
                </since>
            </javadoc>
            <method name="setUncaughtExceptionHandler" type="void" line="1443">
                <params>
                    <param name="eh" type="UncaughtExceptionHandler"/>
                </params>
            </method>
            <javadoc line="1447">
                Dispatch an uncaught exception to the handler. This method is
                  intended to be called only by the JVM.                
            </javadoc>
            <method name="dispatchUncaughtException" type="void" line="1451">
                <params>
                    <param name="e" type="Throwable"/>
                </params>
            </method>
            <javadoc line="1454">
                Removes from the specified map any keys that have been enqueued
                  on the specified reference queue.                
            </javadoc>
            <method name="processQueue" type="void" line="1458">
                <params>
                    <param name="queue" type="ReferenceQueue<Class<?>>"/>
                    <param name="map" type="ConcurrentMap<? extends WeakReference<Class<?>>,?>"/>
                </params>
                <declaration name="ref" type="Reference&lt;? extends Class&lt;?&gt;&gt;" line="1459"/>
                <scope line="1460"/>
            </method>
            <class name="WeakClassKey" line="1464">
                <extends class="WeakReference">
                    <type_params>
                        <type_param name="Class<?>"/>
                    </type_params>
                </extends>
                <javadoc line="1464">
                    Weak key for Class objects.                    
                </javadoc>
                <declaration name="hash" type="int" line="1468"/>
                <javadoc line="1468">
                    saved value of the referent&apos;s identity hash code, to maintain
                      a consistent hash code after the referent has been cleared                    
                </javadoc>
                <javadoc line="1473">
                    Create a new WeakClassKey to the given object, registered
                      with a queue.                    
                </javadoc>
                <method name="WeakClassKey" type="constructor" line="1477">
                    <params>
                        <param name="cl" type="Class<?>"/>
                        <param name="refQueue" type="ReferenceQueue<Class<?>>"/>
                    </params>
                </method>
                <javadoc line="1481">
                    Returns the identity hash code of the original referent.                    
                </javadoc>
                <method name="hashCode" type="int" line="1484"/>
                <javadoc line="1487">
                    Returns true if the given object is this identical
                      WeakClassKey instance, or, if this object&apos;s referent has not
                      been cleared, if the given object is another WeakClassKey
                      instance with the identical non-null referent as this one.                    
                </javadoc>
                <method name="equals" type="boolean" line="1493">
                    <params>
                        <param name="obj" type="Object"/>
                    </params>
                    <scope line="1495">
                        <declaration name="referent" type="Object" line="1496"/>
                    </scope>
                    <scope line="1499"/>
                </method>
            </class>
            <method name="setPriority0" type="void" line="1504"/>
            <method name="stop0" type="void" line="1505"/>
            <method name="suspend0" type="void" line="1506"/>
            <method name="resume0" type="void" line="1507"/>
            <method name="interrupt0" type="void" line="1508"/>
        </class>
    </source>