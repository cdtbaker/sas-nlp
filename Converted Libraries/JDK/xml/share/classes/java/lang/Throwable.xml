<?xml version="1.0" encoding="UTF-8"?>
    <source package="java.lang">
        <import package="java.io"/>
        <import package="java.util"/>
        <class name="Throwable" line="30">
            <comment line="162">
                To allow Throwable objects to be made immutable and safely
                 reused by the JVM, such as OutOfMemoryErrors, fields of
                 Throwable that are writable in response to user actions, cause,
                 stackTrace, and suppressedExceptions obey the following
                 protocol:
                
                 1) The fields are initialized to a non-null sentinel value
                 which indicates the value has logically not been set.
                
                 2) Writing a null to the field indicates further writes
                 are forbidden
                
                 3) The sentinel value may be replaced with another non-null
                 value.
                
                 For example, implementations of the HotSpot JVM have
                 preallocated OutOfMemoryError objects to provide for better
                 diagnosability of that situation.  These objects are created
                 without calling the constructor for that class and the fields
                 in question are initialized to null.  To support this
                 capability, any new fields added to Throwable that require
                 being initialized to a non-null value require a coordinated JVM
                 change.                
            </comment>
            <comment line="213">
                Setting this static field introduces an acceptable
                 initialization dependency on a few java.util classes.                
            </comment>
            <implements interface="Serializable"/>
            <javadoc line="30">
                The {@code Throwable} class is the superclass of all errors and
                  exceptions in the Java language. Only objects that are instances of this
                  class (or one of its subclasses) are thrown by the Java Virtual Machine or
                  can be thrown by the Java {@code throw} statement. Similarly, only
                  this class or one of its subclasses can be the argument type in a{@code catch} clause.
                  For the purposes of compile-time checking of exceptions, {@codeThrowable} and any subclass of {@code Throwable} that is not also a
                  subclass of either {@link RuntimeException} or {@link Error} are
                  regarded as checked exceptions.
                  &lt;p&gt;Instances of two subclasses, {@link java.lang.Error} and{@link java.lang.Exception}, are conventionally used to indicate
                  that exceptional situations have occurred. Typically, these instances
                  are freshly created in the context of the exceptional situation so
                  as to include relevant information (such as stack trace data).
                  &lt;p&gt;A throwable contains a snapshot of the execution stack of its
                  thread at the time it was created. It can also contain a message
                  string that gives more information about the error. Over time, a
                  throwable can {@linkplain Throwable#addSuppressed suppress} other
                  throwables from being propagated.  Finally, the throwable can also
                  contain a &lt;i&gt;cause&lt;/i&gt;: another throwable that caused this
                  throwable to be constructed.  The recording of this causal information
                  is referred to as the &lt;i&gt;chained exception&lt;/i&gt; facility, as the
                  cause can, itself, have a cause, and so on, leading to a &quot;chain&quot; of
                  exceptions, each caused by another.
                  &lt;p&gt;One reason that a throwable may have a cause is that the class that
                  throws it is built atop a lower layered abstraction, and an operation on
                  the upper layer fails due to a failure in the lower layer.  It would be bad
                  design to let the throwable thrown by the lower layer propagate outward, as
                  it is generally unrelated to the abstraction provided by the upper layer.
                  Further, doing so would tie the API of the upper layer to the details of
                  its implementation, assuming the lower layer&apos;s exception was a checked
                  exception.  Throwing a &quot;wrapped exception&quot; (i.e., an exception containing a
                  cause) allows the upper layer to communicate the details of the failure to
                  its caller without incurring either of these shortcomings.  It preserves
                  the flexibility to change the implementation of the upper layer without
                  changing its API (in particular, the set of exceptions thrown by its
                  methods).
                  &lt;p&gt;A second reason that a throwable may have a cause is that the method
                  that throws it must conform to a general-purpose interface that does not
                  permit the method to throw the cause directly.  For example, suppose
                  a persistent collection conforms to the {@link java.util.CollectionCollection} interface, and that its persistence is implemented atop{@code java.io}.  Suppose the internals of the {@code add} method
                  can throw an {@link java.io.IOException IOException}.  The implementation
                  can communicate the details of the {@code IOException} to its caller
                  while conforming to the {@code Collection} interface by wrapping the{@code IOException} in an appropriate unchecked exception.  (The
                  specification for the persistent collection should indicate that it is
                  capable of throwing such exceptions.)
                  &lt;p&gt;A cause can be associated with a throwable in two ways: via a
                  constructor that takes the cause as an argument, or via the{@link #initCause(Throwable)} method.  New throwable classes that
                  wish to allow causes to be associated with them should provide constructors
                  that take a cause and delegate (perhaps indirectly) to one of the{@code Throwable} constructors that takes a cause.
                  Because the {@code initCause} method is public, it allows a cause to be
                  associated with any throwable, even a &quot;legacy throwable&quot; whose
                  implementation predates the addition of the exception chaining mechanism to{@code Throwable}.
                  &lt;p&gt;By convention, class {@code Throwable} and its subclasses have two
                  constructors, one that takes no arguments and one that takes a{@code String} argument that can be used to produce a detail message.
                  Further, those subclasses that might likely have a cause associated with
                  them should have two more constructors, one that takes a{@code Throwable} (the cause), and one that takes a{@code String} (the detail message) and a {@code Throwable} (the
                  cause).                
                <author>
                    unascribed                    
                </author>
                <author>
                    Josh Bloch (Added exception chaining and programmatic access to
                      stack trace in 1.4.)                    
                </author>
                <jls>
                    11.2 Compile-Time Checking of Exceptions                    
                </jls>
                <since>
                    JDK1.0                    
                </since>
            </javadoc>
            <declaration name="serialVersionUID" type="long" line="115"/>
            <javadoc line="115">
                use serialVersionUID from JDK 1.0.2 for interoperability                
            </javadoc>
            <declaration name="backtrace" type="Object" line="118"/>
            <javadoc line="118">
                Native code saves some indication of the stack backtrace in this slot.                
            </javadoc>
            <declaration name="detailMessage" type="String" line="123"/>
            <javadoc line="123">
                Specific details about the Throwable.  For example, for{@code FileNotFoundException}, this contains the name of
                  the file that could not be found.                
                <serial>
                                        
                </serial>
            </javadoc>
            <class name="SentinelHolder" line="133">
                <javadoc line="133">
                    Holder class to defer initializing sentinel objects only used
                      for serialization.                    
                </javadoc>
                <declaration name="STACK_TRACE_ELEMENT_SENTINEL" type="StackTraceElement" line="138"/>
                <javadoc line="138">
                    {@linkplain #setStackTrace(StackTraceElement[]) Setting the
                      stack trace} to a one-element array containing this sentinel
                      value indicates future attempts to set the stack trace will be
                      ignored.  The sentinal is equal to the result of calling:&lt;br&gt;{@code new StackTraceElement(&quot;&quot;, &quot;&quot;, null, Integer.MIN_VALUE)}                    
                </javadoc>
                <declaration name="STACK_TRACE_SENTINEL" type="StackTraceElement[]" line="148"/>
                <javadoc line="148">
                    Sentinel value used in the serial form to indicate an immutable
                      stack trace.                    
                </javadoc>
            </class>
            <declaration name="UNASSIGNED_STACK" type="StackTraceElement[]" line="156"/>
            <javadoc line="156">
                A shared value for an empty stack.                
            </javadoc>
            <declaration name="cause" type="Throwable" line="187"/>
            <javadoc line="187">
                The throwable that caused this throwable to get thrown, or null if this
                  throwable was not caused by another throwable, or if the causative
                  throwable is unknown.  If this field is equal to this throwable itself,
                  it indicates that the cause of this throwable has not yet been
                  initialized.                
                <serial>
                                        
                </serial>
                <since>
                    1.4                    
                </since>
            </javadoc>
            <declaration name="stackTrace" type="StackTraceElement[]" line="199"/>
            <javadoc line="199">
                The stack trace, as returned by {@link #getStackTrace()}.
                  The field is initialized to a zero-length array.  A {@codenull} value of this field indicates subsequent calls to {@link #setStackTrace(StackTraceElement[])} and {@link #fillInStackTrace()} will be be no-ops.                
                <serial>
                                        
                </serial>
                <since>
                    1.4                    
                </since>
            </javadoc>
            <declaration name="SUPPRESSED_SENTINEL" type="List&lt;Throwable&gt;" line="214"/>
            <declaration name="suppressedExceptions" type="List&lt;Throwable&gt;" line="217"/>
            <javadoc line="217">
                The list of suppressed exceptions, as returned by {@link #getSuppressed()}.  The list is initialized to a zero-element
                  unmodifiable sentinel list.  When a serialized Throwable is
                  read in, if the {@code suppressedExceptions} field points to a
                  zero-element list, the field is reset to the sentinel value.                
                <serial>
                                        
                </serial>
                <since>
                    1.7                    
                </since>
            </javadoc>
            <declaration name="NULL_CAUSE_MESSAGE" type="String" line="229"/>
            <javadoc line="229">
                Message for trying to suppress a null exception.                
            </javadoc>
            <declaration name="SELF_SUPPRESSION_MESSAGE" type="String" line="232"/>
            <javadoc line="232">
                Message for trying to suppress oneself.                
            </javadoc>
            <declaration name="CAUSE_CAPTION" type="String" line="235"/>
            <javadoc line="235">
                Caption  for labeling causative exception stack traces                
            </javadoc>
            <declaration name="SUPPRESSED_CAPTION" type="String" line="238"/>
            <javadoc line="238">
                Caption for labeling suppressed exception stack traces                
            </javadoc>
            <javadoc line="241">
                Constructs a new throwable with {@code null} as its detail message.
                  The cause is not initialized, and may subsequently be initialized by a
                  call to {@link #initCause}.
                  &lt;p&gt;The {@link #fillInStackTrace()} method is called to initialize
                  the stack trace data in the newly created throwable.                
            </javadoc>
            <method name="Throwable" type="constructor" line="249"/>
            <javadoc line="253">
                Constructs a new throwable with the specified detail message.  The
                  cause is not initialized, and may subsequently be initialized by
                  a call to {@link #initCause}.
                  &lt;p&gt;The {@link #fillInStackTrace()} method is called to initialize
                  the stack trace data in the newly created throwable.                
                <param>
                    message   the detail message. The detail message is saved for
                      later retrieval by the {@link #getMessage()} method.                    
                </param>
            </javadoc>
            <method name="Throwable" type="constructor" line="264">
                <params>
                    <param name="message" type="String"/>
                </params>
            </method>
            <javadoc line="269">
                Constructs a new throwable with the specified detail message and
                  cause.  &lt;p&gt;Note that the detail message associated with{@code cause} is &lt;i&gt;not&lt;/i&gt; automatically incorporated in
                  this throwable&apos;s detail message.
                  &lt;p&gt;The {@link #fillInStackTrace()} method is called to initialize
                  the stack trace data in the newly created throwable.                
                <param>
                    message the detail message (which is saved for later retrieval
                      by the {@link #getMessage()} method).                    
                </param>
                <param>
                    cause the cause (which is saved for later retrieval by the{@link #getCause()} method).  (A {@code null} value is
                      permitted, and indicates that the cause is nonexistent or
                      unknown.)                    
                </param>
                <since>
                    1.4                    
                </since>
            </javadoc>
            <method name="Throwable" type="constructor" line="286">
                <params>
                    <param name="message" type="String"/>
                    <param name="cause" type="Throwable"/>
                </params>
            </method>
            <javadoc line="292">
                Constructs a new throwable with the specified cause and a detail
                  message of {@code (cause==null ? null : cause.toString())} (which
                  typically contains the class and detail message of {@code cause}).
                  This constructor is useful for throwables that are little more than
                  wrappers for other throwables (for example, {@link java.security.PrivilegedActionException}).
                  &lt;p&gt;The {@link #fillInStackTrace()} method is called to initialize
                  the stack trace data in the newly created throwable.                
                <param>
                    cause the cause (which is saved for later retrieval by the{@link #getCause()} method).  (A {@code null} value is
                      permitted, and indicates that the cause is nonexistent or
                      unknown.)                    
                </param>
                <since>
                    1.4                    
                </since>
            </javadoc>
            <method name="Throwable" type="constructor" line="309">
                <params>
                    <param name="cause" type="Throwable"/>
                </params>
            </method>
            <javadoc line="315">
                Constructs a new throwable with the specified detail message,
                  cause, {@linkplain #addSuppressed suppression} enabled or
                  disabled, and writable stack trace enabled or disabled.  If
                  suppression is disabled, {@link #getSuppressed} for this object
                  will return a zero-length array and calls to {@link #addSuppressed} that would otherwise append an exception to the
                  suppressed list will have no effect.  If the writable stack
                  trace is false, this constructor will not call {@link #fillInStackTrace()}, a {@code null} will be written to the{@code stackTrace} field, and subsequent calls to {@codefillInStackTrace} and {@link #setStackTrace(StackTraceElement[])} will not set the stack
                  trace.  If the writable stack trace is false, {@link #getStackTrace} will return a zero length array.
                  &lt;p&gt;Note that the other constructors of {@code Throwable} treat
                  suppression as being enabled and the stack trace as being
                  writable.  Subclasses of {@code Throwable} should document any
                  conditions under which suppression is disabled and document
                  conditions under which the stack trace is not writable.
                  Disabling of suppression should only occur in exceptional
                  circumstances where special requirements exist, such as a
                  virtual machine reusing exception objects under low-memory
                  situations.  Circumstances where a given exception object is
                  repeatedly caught and rethrown, such as to implement control
                  flow between two sub-systems, is another situation where
                  immutable throwable objects would be appropriate.                
                <param>
                    message the detail message.                    
                </param>
                <param>
                    cause the cause.  (A {@code null} value is permitted,
                      and indicates that the cause is nonexistent or unknown.)                    
                </param>
                <param>
                    enableSuppression whether or not suppression is enabled or disabled                    
                </param>
                <param>
                    writableStackTrace whether or not the stack trace should be
                      writable                    
                </param>
                <see>
                    OutOfMemoryError                    
                </see>
                <see>
                    NullPointerException                    
                </see>
                <see>
                    ArithmeticException                    
                </see>
                <since>
                    1.7                    
                </since>
            </javadoc>
            <method name="Throwable" type="constructor" line="358">
                <params>
                    <param name="message" type="String"/>
                    <param name="cause" type="Throwable"/>
                    <param name="enableSuppression" type="boolean"/>
                    <param name="writableStackTrace" type="boolean"/>
                </params>
                <scope line="359"/>
                <scope line="361"/>
            </method>
            <javadoc line="370">
                Returns the detail message string of this throwable.                
                <return>
                    the detail message string of this {@code Throwable} instance
                      (which may be {@code null}).                    
                </return>
            </javadoc>
            <method name="getMessage" type="String" line="376"/>
            <javadoc line="380">
                Creates a localized description of this throwable.
                  Subclasses may override this method in order to produce a
                  locale-specific message.  For subclasses that do not override this
                  method, the default implementation returns the same result as{@code getMessage()}.                
                <return>
                    The localized description of this throwable.                    
                </return>
                <since>
                    JDK1.1                    
                </since>
            </javadoc>
            <method name="getLocalizedMessage" type="String" line="390"/>
            <javadoc line="394">
                Returns the cause of this throwable or {@code null} if the
                  cause is nonexistent or unknown.  (The cause is the throwable that
                  caused this throwable to get thrown.)
                  &lt;p&gt;This implementation returns the cause that was supplied via one of
                  the constructors requiring a {@code Throwable}, or that was set after
                  creation with the {@link #initCause(Throwable)} method.  While it is
                  typically unnecessary to override this method, a subclass can override
                  it to return a cause set by some other means.  This is appropriate for
                  a &quot;legacy chained throwable&quot; that predates the addition of chained
                  exceptions to {@code Throwable}.  Note that it is &lt;i&gt;not&lt;/i&gt;
                  necessary to override any of the {@code PrintStackTrace} methods,
                  all of which invoke the {@code getCause} method to determine the
                  cause of a throwable.                
                <return>
                    the cause of this throwable or {@code null} if the
                      cause is nonexistent or unknown.                    
                </return>
                <since>
                    1.4                    
                </since>
            </javadoc>
            <method name="getCause" type="Throwable" line="414"/>
            <javadoc line="418">
                Initializes the &lt;i&gt;cause&lt;/i&gt; of this throwable to the specified value.
                  (The cause is the throwable that caused this throwable to get thrown.)
                  &lt;p&gt;This method can be called at most once.  It is generally called from
                  within the constructor, or immediately after creating the
                  throwable.  If this throwable was created
                  with {@link #Throwable(Throwable)} or{@link #Throwable(String,Throwable)}, this method cannot be called
                  even once.
                  &lt;p&gt;An example of using this method on a legacy throwable type
                  without other support for setting the cause is:
                  &lt;pre&gt;
                  try {
                  lowLevelOp();
                  } catch (LowLevelException le) {
                  throw (HighLevelException)
                  new HighLevelException().initCause(le); // Legacy constructor
                  }
                  &lt;/pre&gt;                
                <param>
                    cause the cause (which is saved for later retrieval by the{@link #getCause()} method).  (A {@code null} value is
                      permitted, and indicates that the cause is nonexistent or
                      unknown.)                    
                </param>
                <return>
                    a reference to this {@code Throwable} instance.                    
                </return>
                <throws>
                    IllegalArgumentException if {@code cause} is this
                      throwable.  (A throwable cannot be its own cause.)                    
                </throws>
                <throws>
                    IllegalStateException if this throwable was
                      created with {@link #Throwable(Throwable)} or{@link #Throwable(String,Throwable)}, or this method has already
                      been called on this throwable.                    
                </throws>
                <since>
                    1.4                    
                </since>
            </javadoc>
            <method name="initCause" type="Throwable" line="454">
                <params>
                    <param name="cause" type="Throwable"/>
                </params>
            </method>
            <javadoc line="463">
                Returns a short description of this throwable.
                  The result is the concatenation of:
                  &lt;ul&gt;
                  &lt;li&gt; the {@linkplain Class#getName() name} of the class of this object
                  &lt;li&gt; &quot;: &quot; (a colon and a space)
                  &lt;li&gt; the result of invoking this object&apos;s {@link #getLocalizedMessage}method
                  &lt;/ul&gt;
                  If {@code getLocalizedMessage} returns {@code null}, then just
                  the class name is returned.                
                <return>
                    a string representation of this throwable.                    
                </return>
            </javadoc>
            <method name="toString" type="String" line="477">
                <declaration name="s" type="String" line="478"/>
                <declaration name="message" type="String" line="479"/>
            </method>
            <javadoc line="483">
                Prints this throwable and its backtrace to the
                  standard error stream. This method prints a stack trace for this{@code Throwable} object on the error output stream that is
                  the value of the field {@code System.err}. The first line of
                  output contains the result of the {@link #toString()} method for
                  this object.  Remaining lines represent data previously recorded by
                  the method {@link #fillInStackTrace()}. The format of this
                  information depends on the implementation, but the following
                  example may be regarded as typical:
                  &lt;blockquote&gt;&lt;pre&gt;
                  java.lang.NullPointerException
                  at MyClass.mash(MyClass.java:9)
                  at MyClass.crunch(MyClass.java:6)
                  at MyClass.main(MyClass.java:3)
                  &lt;/pre&gt;&lt;/blockquote&gt;
                  This example was produced by running the program:
                  &lt;pre&gt;
                  class MyClass {
                  public static void main(String[] args) {
                  crunch(null);
                  }
                  static void crunch(int[] a) {
                  mash(a);
                  }
                  static void mash(int[] b) {
                  System.out.println(b[0]);
                  }
                  }
                  &lt;/pre&gt;
                  The backtrace for a throwable with an initialized, non-null cause
                  should generally include the backtrace for the cause.  The format
                  of this information depends on the implementation, but the following
                  example may be regarded as typical:
                  &lt;pre&gt;
                  HighLevelException: MidLevelException: LowLevelException
                  at Junk.a(Junk.java:13)
                  at Junk.main(Junk.java:4)
                  Caused by: MidLevelException: LowLevelException
                  at Junk.c(Junk.java:23)
                  at Junk.b(Junk.java:17)
                  at Junk.a(Junk.java:11)
                  ... 1 more
                  Caused by: LowLevelException
                  at Junk.e(Junk.java:30)
                  at Junk.d(Junk.java:27)
                  at Junk.c(Junk.java:21)
                  ... 3 more
                  &lt;/pre&gt;
                  Note the presence of lines containing the characters {@code &quot;...&quot;}.
                  These lines indicate that the remainder of the stack trace for this
                  exception matches the indicated number of frames from the bottom of the
                  stack trace of the exception that was caused by this exception (the
                  &quot;enclosing&quot; exception).  This shorthand can greatly reduce the length
                  of the output in the common case where a wrapped exception is thrown
                  from same method as the &quot;causative exception&quot; is caught.  The above
                  example was produced by running the program:
                  &lt;pre&gt;
                  public class Junk {
                  public static void main(String args[]) {
                  try {
                  a();
                  } catch(HighLevelException e) {
                  e.printStackTrace();
                  }
                  }
                  static void a() throws HighLevelException {
                  try {
                  b();
                  } catch(MidLevelException e) {
                  throw new HighLevelException(e);
                  }
                  }
                  static void b() throws MidLevelException {
                  c();
                  }
                  static void c() throws MidLevelException {
                  try {
                  d();
                  } catch(LowLevelException e) {
                  throw new MidLevelException(e);
                  }
                  }
                  static void d() throws LowLevelException {
                  e();
                  }
                  static void e() throws LowLevelException {
                  throw new LowLevelException();
                  }
                  }
                  class HighLevelException extends Exception {
                  HighLevelException(Throwable cause) { super(cause); }
                  }
                  class MidLevelException extends Exception {
                  MidLevelException(Throwable cause)  { super(cause); }
                  }
                  class LowLevelException extends Exception {
                  }
                  &lt;/pre&gt;
                  As of release 7, the platform supports the notion of
                  &lt;i&gt;suppressed exceptions&lt;/i&gt; (in conjunction with the {@codetry}-with-resources statement). Any exceptions that were
                  suppressed in order to deliver an exception are printed out
                  beneath the stack trace.  The format of this information
                  depends on the implementation, but the following example may be
                  regarded as typical:
                  &lt;pre&gt;
                  Exception in thread &quot;main&quot; java.lang.Exception: Something happened
                  at Foo.bar(Foo.java:10)
                  at Foo.main(Foo.java:5)
                  Suppressed: Resource$CloseFailException: Resource ID = 0
                  at Resource.close(Resource.java:26)
                  at Foo.bar(Foo.java:9)
                  ... 1 more
                  &lt;/pre&gt;
                  Note that the &quot;... n more&quot; notation is used on suppressed exceptions
                  just at it is used on causes. Unlike causes, suppressed exceptions are
                  indented beyond their &quot;containing exceptions.&quot;
                  &lt;p&gt;An exception can have both a cause and one or more suppressed
                  exceptions:
                  &lt;pre&gt;
                  Exception in thread &quot;main&quot; java.lang.Exception: Main block
                  at Foo3.main(Foo3.java:7)
                  Suppressed: Resource$CloseFailException: Resource ID = 2
                  at Resource.close(Resource.java:26)
                  at Foo3.main(Foo3.java:5)
                  Suppressed: Resource$CloseFailException: Resource ID = 1
                  at Resource.close(Resource.java:26)
                  at Foo3.main(Foo3.java:5)
                  Caused by: java.lang.Exception: I did it
                  at Foo3.main(Foo3.java:8)
                  &lt;/pre&gt;
                  Likewise, a suppressed exception can have a cause:
                  &lt;pre&gt;
                  Exception in thread &quot;main&quot; java.lang.Exception: Main block
                  at Foo4.main(Foo4.java:6)
                  Suppressed: Resource2$CloseFailException: Resource ID = 1
                  at Resource2.close(Resource2.java:20)
                  at Foo4.main(Foo4.java:5)
                  Caused by: java.lang.Exception: Rats, you caught me
                  at Resource2$CloseFailException.&lt;init&gt;(Resource2.java:45)
                  ... 2 more
                  &lt;/pre&gt;                
            </javadoc>
            <method name="printStackTrace" type="void" line="632"/>
            <javadoc line="636">
                Prints this throwable and its backtrace to the specified print stream.                
                <param>
                    s {@code PrintStream} to use for output                    
                </param>
            </javadoc>
            <method name="printStackTrace" type="void" line="641">
                <params>
                    <param name="s" type="PrintStream"/>
                </params>
            </method>
            <method name="printStackTrace" type="void" line="645">
                <params>
                    <param name="s" type="PrintStreamOrWriter"/>
                </params>
                <comment line="647">
                    Guard against malicious overrides of Throwable.equals by
                     using a Set with identity equality semantics.                    
                </comment>
                <comment line="654">
                    Print our stack trace                    
                </comment>
                <comment line="660">
                    Print suppressed exceptions, if any                    
                </comment>
                <comment line="664">
                    Print cause, if any                    
                </comment>
                <declaration name="dejaVu" type="Set&lt;Throwable&gt;" line="648"/>
                <scope line="652">
                    <declaration name="trace" type="StackTraceElement[]" line="655"/>
                    <declaration name="ourCause" type="Throwable" line="664"/>
                </scope>
            </method>
            <javadoc line="670">
                Print our stack trace as an enclosed exception for the specified
                  stack trace.                
            </javadoc>
            <method name="printEnclosedStackTrace" type="void" line="678">
                <params>
                    <param name="s" type="PrintStreamOrWriter"/>
                    <param name="enclosingTrace" type="StackTraceElement[]"/>
                    <param name="caption" type="String"/>
                    <param name="prefix" type="String"/>
                    <param name="dejaVu" type="Set<Throwable>"/>
                </params>
                <comment line="685">
                    Compute number of frames in common between this and enclosing trace                    
                </comment>
                <comment line="694">
                    Print our stack trace                    
                </comment>
                <comment line="701">
                    Print suppressed exceptions, if any                    
                </comment>
                <comment line="706">
                    Print cause, if any                    
                </comment>
                <scope line="680"/>
                <scope line="682">
                    <declaration name="trace" type="StackTraceElement[]" line="685"/>
                    <declaration name="m" type="int" line="686"/>
                    <declaration name="n" type="int" line="687"/>
                    <scope line="688"/>
                    <declaration name="framesInCommon" type="int" line="691"/>
                    <declaration name="ourCause" type="Throwable" line="706"/>
                </scope>
            </method>
            <javadoc line="712">
                Prints this throwable and its backtrace to the specified
                  print writer.                
                <param>
                    s {@code PrintWriter} to use for output                    
                </param>
                <since>
                    JDK1.1                    
                </since>
            </javadoc>
            <method name="printStackTrace" type="void" line="719">
                <params>
                    <param name="s" type="PrintWriter"/>
                </params>
            </method>
            <class name="PrintStreamOrWriter" line="723">
                <javadoc line="723">
                    Wrapper class for PrintStream and PrintWriter to enable a single
                      implementation of printStackTrace.                    
                </javadoc>
                <method name="lock" type="Object" line="728"/>
                <javadoc line="728">
                    Returns the object to be locked when using this StreamOrWriter                    
                </javadoc>
                <method name="println" type="void" line="731"/>
                <javadoc line="731">
                    Prints the specified string as a line on this StreamOrWriter                    
                </javadoc>
            </class>
            <class name="WrappedPrintStream" line="735">
                <extends class="PrintStreamOrWriter"/>
                <declaration name="printStream" type="PrintStream" line="736"/>
                <method name="WrappedPrintStream" type="constructor" line="738">
                    <params>
                        <param name="printStream" type="PrintStream"/>
                    </params>
                </method>
                <method name="lock" type="Object" line="742"/>
                <method name="println" type="void" line="746">
                    <params>
                        <param name="o" type="Object"/>
                    </params>
                </method>
            </class>
            <class name="WrappedPrintWriter" line="751">
                <extends class="PrintStreamOrWriter"/>
                <declaration name="printWriter" type="PrintWriter" line="752"/>
                <method name="WrappedPrintWriter" type="constructor" line="754">
                    <params>
                        <param name="printWriter" type="PrintWriter"/>
                    </params>
                </method>
                <method name="lock" type="Object" line="758"/>
                <method name="println" type="void" line="762">
                    <params>
                        <param name="o" type="Object"/>
                    </params>
                </method>
            </class>
            <javadoc line="767">
                Fills in the execution stack trace. This method records within this{@code Throwable} object information about the current state of
                  the stack frames for the current thread.
                  &lt;p&gt;If the stack trace of this {@code Throwable} {@linkplain Throwable#Throwable(String,Throwable,boolean,boolean) is not
                  writable}, calling this method has no effect.                
                <return>
                    a reference to this {@code Throwable} instance.                    
                </return>
                <see>
                    java.lang.Throwable#printStackTrace()                    
                </see>
            </javadoc>
            <method name="fillInStackTrace" type="Throwable" line="779">
                <comment line="782">
                                        
                </comment>
                <scope line="781"/>
            </method>
            <method name="fillInStackTrace" type="Throwable" line="788"/>
            <javadoc line="790">
                Provides programmatic access to the stack trace information printed by{@link #printStackTrace()}.  Returns an array of stack trace elements,
                  each representing one stack frame.  The zeroth element of the array
                  (assuming the array&apos;s length is non-zero) represents the top of the
                  stack, which is the last method invocation in the sequence.  Typically,
                  this is the point at which this throwable was created and thrown.
                  The last element of the array (assuming the array&apos;s length is non-zero)
                  represents the bottom of the stack, which is the first method invocation
                  in the sequence.
                  &lt;p&gt;Some virtual machines may, under some circumstances, omit one
                  or more stack frames from the stack trace.  In the extreme case,
                  a virtual machine that has no stack trace information concerning
                  this throwable is permitted to return a zero-length array from this
                  method.  Generally speaking, the array returned by this method will
                  contain one element for every frame that would be printed by{@code printStackTrace}.  Writes to the returned array do not
                  affect future calls to this method.                
                <return>
                    an array of stack trace elements representing the stack trace
                      pertaining to this throwable.                    
                </return>
                <since>
                    1.4                    
                </since>
            </javadoc>
            <method name="getStackTrace" type="StackTraceElement[]" line="814"/>
            <method name="getOurStackTrace" type="StackTraceElement[]" line="818">
                <comment line="820">
                    Initialize stack trace field with information from
                     backtrace if this is the first call to this method                    
                </comment>
                <comment line="823">
                                        
                </comment>
                <scope line="822">
                    <declaration name="depth" type="int" line="823"/>
                </scope>
                <scope line="827"/>
            </method>
            <javadoc line="833">
                Sets the stack trace elements that will be returned by{@link #getStackTrace()} and printed by {@link #printStackTrace()}and related methods.
                  This method, which is designed for use by RPC frameworks and other
                  advanced systems, allows the client to override the default
                  stack trace that is either generated by {@link #fillInStackTrace()}when a throwable is constructed or deserialized when a throwable is
                  read from a serialization stream.
                  &lt;p&gt;If the stack trace of this {@code Throwable} {@linkplain Throwable#Throwable(String,Throwable,boolean,boolean) is not
                  writable}, calling this method has no effect other than
                  validating its argument.                
                <param>
                    stackTrace the stack trace elements to be associated with
                      this {@code Throwable}.  The specified array is copied by this
                      call; changes in the specified array after the method invocation
                      returns will have no affect on this {@code Throwable}'s stack
                      trace.                    
                </param>
                <throws>
                    NullPointerException if {@code stackTrace} is{@code null} or if any of the elements of{@code stackTrace} are {@code null}                    
                </throws>
                <since>
                    1.4                    
                </since>
            </javadoc>
            <method name="setStackTrace" type="void" line="861">
                <params>
                    <param name="stackTrace" type="StackTraceElement[]"/>
                </params>
                <comment line="863">
                    Validate argument                    
                </comment>
                <comment line="871">
                    Immutable stack                    
                </comment>
                <comment line="872">
                    Test for out of protocol state                    
                </comment>
                <declaration name="defensiveCopy" type="StackTraceElement[]" line="863"/>
                <scope line="864"/>
                <scope line="869"/>
            </method>
            <method name="getStackTraceDepth" type="int" line="877"/>
            <javadoc line="877">
                Returns the number of elements in the stack trace (or 0 if the stack
                  trace is unavailable).
                  package-protection for use by SharedSecrets.                
            </javadoc>
            <method name="getStackTraceElement" type="StackTraceElement" line="885"/>
            <javadoc line="885">
                Returns the specified element of the stack trace.
                  package-protection for use by SharedSecrets.                
                <param>
                    index index of the element to return.                    
                </param>
                <throws>
                    IndexOutOfBoundsException if {@code index < 0 ||
                      index >= getStackTraceDepth() }                    
                </throws>
            </javadoc>
            <javadoc line="896">
                Reads a {@code Throwable} from a stream, enforcing
                  well-formedness constraints on fields.  Null entries and
                  self-pointers are not allowed in the list of {@codesuppressedExceptions}.  Null entries are not allowed for stack
                  trace elements.  A null stack trace in the serial form results
                  in a zero-length stack element array. A single-element stack
                  trace whose entry is equal to {@code new StackTraceElement(&quot;&quot;,
                  &quot;&quot;, null, Integer.MIN_VALUE)} results in a {@code null} {@codestackTrace} field.
                  Note that there are no constraints on the value the {@codecause} field can hold; both {@code null} and {@code this} are
                  valid values for the field.                
            </javadoc>
            <method name="readObject" type="void" line="912">
                <params>
                    <param name="s" type="ObjectInputStream"/>
                </params>
                <comment line="914">
                    read in all fields                    
                </comment>
                <comment line="918">
                    Use the sentinel for a zero-length list                    
                </comment>
                <comment line="920">
                    Copy Throwables to new list                    
                </comment>
                <comment line="923">
                    Enforce constraints on suppressed exceptions in
                     case of corrupt or malicious stream.                    
                </comment>
                <comment line="933">
                    else a null suppressedExceptions field remains null                    
                </comment>
                <comment line="935">
                    For zero-length stack traces, use a clone of
                     UNASSIGNED_STACK rather than UNASSIGNED_STACK itself to
                     allow identity comparison against UNASSIGNED_STACK in
                     getOurStackTrace.  The identity of UNASSIGNED_STACK in
                     stackTrace indicates to the getOurStackTrace method that
                     the stackTrace needs to be constructed from the information
                     in backtrace.                    
                </comment>
                <comment line="948">
                    Check for the marker of an immutable stack trace                    
                </comment>
                <comment line="951">
                    Verify stack trace elements are non-null.                    
                </comment>
                <comment line="958">
                    A null stackTrace field in the serial form can result
                     from an exception serialized without that field in
                     older JDK releases; treat such exceptions as having
                     empty stack traces.                    
                </comment>
                <scope line="914">
                    <declaration name="suppressed" type="List&lt;Throwable&gt;" line="915"/>
                    <scope line="916"/>
                    <scope line="919">
                        <scope line="921"/>
                    </scope>
                </scope>
                <scope line="943">
                    <scope line="944"/>
                    <scope line="948"/>
                    <scope line="950">
                        <scope line="951"/>
                    </scope>
                </scope>
                <scope line="956"/>
            </method>
            <javadoc line="965">
                Write a {@code Throwable} object to a stream.
                  A {@code null} stack trace field is represented in the serial
                  form as a one-element array whose element is equal to {@codenew StackTraceElement(&quot;&quot;, &quot;&quot;, null, Integer.MIN_VALUE)}.                
            </javadoc>
            <method name="writeObject" type="void" line="973">
                <params>
                    <param name="s" type="ObjectOutputStream"/>
                </params>
                <comment line="975">
                    Ensure that the stackTrace field is initialized to a
                     non-null value, if appropriate.  As of JDK 7, a null stack
                     trace field is a valid value indicating the stack trace
                     should not be set.                    
                </comment>
                <declaration name="oldStackTrace" type="StackTraceElement[]" line="980"/>
                <scope line="981"/>
                <scope line="985"/>
            </method>
            <javadoc line="990">
                Appends the specified exception to the exceptions that were
                  suppressed in order to deliver this exception. This method is
                  thread-safe and typically called (automatically and implicitly)
                  by the {@code try}-with-resources statement.
                  &lt;p&gt;The suppression behavior is enabled &lt;em&gt;unless&lt;/em&gt; disabled{@linkplain #Throwable(String,Throwable,boolean,boolean) via
                  a constructor}.  When suppression is disabled, this method does
                  nothing other than to validate its argument.
                  &lt;p&gt;Note that when one exception {@linkplain #initCause(Throwable) causes} another exception, the first
                  exception is usually caught and then the second exception is
                  thrown in response.  In other words, there is a causal
                  connection between the two exceptions.
                  In contrast, there are situations where two independent
                  exceptions can be thrown in sibling code blocks, in particular
                  in the {@code try} block of a {@code try}-with-resources
                  statement and the compiler-generated {@code finally} block
                  which closes the resource.
                  In these situations, only one of the thrown exceptions can be
                  propagated.  In the {@code try}-with-resources statement, when
                  there are two such exceptions, the exception originating from
                  the {@code try} block is propagated and the exception from the{@code finally} block is added to the list of exceptions
                  suppressed by the exception from the {@code try} block.  As an
                  exception unwinds the stack, it can accumulate multiple
                  suppressed exceptions.
                  &lt;p&gt;An exception may have suppressed exceptions while also being
                  caused by another exception.  Whether or not an exception has a
                  cause is semantically known at the time of its creation, unlike
                  whether or not an exception will suppress other exceptions
                  which is typically only determined after an exception is
                  thrown.
                  &lt;p&gt;Note that programmer written code is also able to take
                  advantage of calling this method in situations where there are
                  multiple sibling exceptions and only one can be propagated.                
                <param>
                    exception the exception to be added to the list of
                      suppressed exceptions                    
                </param>
                <throws>
                    IllegalArgumentException if {@code exception} is this
                      throwable; a throwable cannot suppress itself.                    
                </throws>
                <throws>
                    NullPointerException if {@code exception} is {@code null}                    
                </throws>
                <since>
                    1.7                    
                </since>
            </javadoc>
            <method name="addSuppressed" type="void" line="1040">
                <params>
                    <param name="exception" type="Throwable"/>
                </params>
                <comment line="1048">
                    Suppressed exceptions not recorded                    
                </comment>
            </method>
            <declaration name="EMPTY_THROWABLE_ARRAY" type="Throwable[]" line="1056"/>
            <javadoc line="1058">
                Returns an array containing all of the exceptions that were
                  suppressed, typically by the {@code try}-with-resources
                  statement, in order to deliver this exception.
                  If no exceptions were suppressed or {@linkplain #Throwable(String,Throwable,boolean,boolean) suppression is
                  disabled}, an empty array is returned.  This method is
                  thread-safe.  Writes to the returned array do not affect future
                  calls to this method.                
                <return>
                    an array containing all of the exceptions that were
                      suppressed to deliver this exception.                    
                </return>
                <since>
                    1.7                    
                </since>
            </javadoc>
            <method name="getSuppressed" type="Throwable[]" line="1073"/>
        </class>
    </source>