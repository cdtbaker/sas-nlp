<?xml version="1.0" encoding="UTF-8"?>
    <source package="java.awt">
        <import package="java.awt.event"/>
        <import package="java.awt.geom.Path2D"/>
        <import package="java.awt.geom.Point2D"/>
        <import package="java.awt.im.InputContext"/>
        <import package="java.awt.image.BufferStrategy"/>
        <import package="java.awt.image.BufferedImage"/>
        <import package="java.awt.peer.ComponentPeer"/>
        <import package="java.awt.peer.WindowPeer"/>
        <import package="java.beans.PropertyChangeListener"/>
        <import package="java.io.IOException"/>
        <import package="java.io.ObjectInputStream"/>
        <import package="java.io.ObjectOutputStream"/>
        <import package="java.io.OptionalDataException"/>
        <import package="java.io.Serializable"/>
        <import package="java.lang.ref.WeakReference"/>
        <import package="java.lang.reflect.InvocationTargetException"/>
        <import package="java.security.AccessController"/>
        <import package="java.util.ArrayList"/>
        <import package="java.util.Arrays"/>
        <import package="java.util.EventListener"/>
        <import package="java.util.Locale"/>
        <import package="java.util.ResourceBundle"/>
        <import package="java.util.Set"/>
        <import package="java.util.Vector"/>
        <import package="java.util.concurrent.atomic.AtomicBoolean"/>
        <import package="javax.accessibility"/>
        <import package="sun.awt.AWTAccessor"/>
        <import package="sun.awt.AppContext"/>
        <import package="sun.awt.CausedFocusEvent"/>
        <import package="sun.awt.SunToolkit"/>
        <import package="sun.awt.util.IdentityArrayList"/>
        <import package="sun.java2d.Disposer"/>
        <import package="sun.java2d.pipe.Region"/>
        <import package="sun.security.action.GetPropertyAction"/>
        <import package="sun.security.util.SecurityConstants"/>
        <import package="sun.util.logging.PlatformLogger"/>
        <class name="Window" line="64">
            <extends class="Container"/>
            <comment line="269">
                We insert a weak reference into the Vector of all Windows in AppContext
                 instead of &apos;this&apos; so that garbage collection can still take place
                 correctly.                
            </comment>
            <comment line="334">
                Indicates that this window is being shown. This flag is set to true at
                 the beginning of show() and to false at the end of show().
                
                 @see #show()
                 @see Dialog#shouldBlock                
            </comment>
            <comment line="343">
                The opacity level of the window
                
                 @serial
                 @see #setOpacity(float)
                 @see #getOpacity()
                 @since 1.7                
            </comment>
            <comment line="353">
                The shape assigned to this window. This field is set to {@code null} if
                 no shape is set (rectangular window).
                
                 @serial
                 @see #getShape()
                 @see #setShape(Shape)
                 @since 1.7                
            </comment>
            <comment line="367">
                JDK 1.1 serialVersionUID                
            </comment>
            <comment line="1150">
                Fix for 4872170.
                 If dispose() is called on parent then its children have to be disposed as well
                 as reported in javadoc. So we need to implement this functionality even if a
                 child overrides dispose() in a wrong way without calling super.dispose().                
            </comment>
            <comment line="1221">
                Should only be called while holding the tree lock.
                 It&apos;s overridden here because parent == owner in Window,
                 and we shouldn&apos;t adjust counter on owner                
            </comment>
            <comment line="1229">
                Should only be called while holding tree lock                
            </comment>
            <comment line="1282">
                This functionality is implemented in a final package-private method                
            </comment>
            <comment line="1283">
                to insure that it cannot be overridden by client subclasses.                
            </comment>
            <comment line="1325">
                This functionality is implemented in a final package-private method                
            </comment>
            <comment line="1326">
                to insure that it cannot be overridden by client subclasses.                
            </comment>
            <comment line="1509">
                Returns a list of all displayable Windows, i. e. all the
                 Windows which peer is not null.
                
                 @see #addNotify
                 @see #removeNotify                
            </comment>
            <comment line="1949">
                REMIND: remove when filtering is handled at lower level                
            </comment>
            <comment line="2756">
                Support for tracking all windows owned by this window                
            </comment>
            <comment line="2928">
                                
            </comment>
            <comment line="2929">
                Part of deserialization procedure to be called before                
            </comment>
            <comment line="2930">
                user&apos;s code.                
            </comment>
            <comment line="2931">
                                
            </comment>
            <comment line="3063">
                --- Accessibility Support ---                
            </comment>
            <comment line="3124">
                inner class AccessibleAWTWindow                
            </comment>
            <comment line="3506">
                ******************** SHAPES &amp; TRANSPARENCY CODE ********************                
            </comment>
            <comment line="3902">
                ************************** MIXING CODE *******************************                
            </comment>
            <comment line="3904">
                A window has a parent, but it does NOT have a container                
            </comment>
            <comment line="3937">
                ****************** END OF MIXING CODE ********************************                
            </comment>
            <comment line="4068">
                static                
            </comment>
            <comment line="4070">
                a window doesn&apos;t need to be updated in the Z-order.                
            </comment>
            <comment line="4085">
                JDK 1.1 serialVersionUID                
            </comment>
            <implements interface="Accessible"/>
            <javadoc line="64">
                A &lt;code&gt;Window&lt;/code&gt; object is a top-level window with no borders and no
                  menubar.
                  The default layout for a window is &lt;code&gt;BorderLayout&lt;/code&gt;.
                  &lt;p&gt;
                  A window must have either a frame, dialog, or another window defined as its
                  owner when it&apos;s constructed.
                  &lt;p&gt;
                  In a multi-screen environment, you can create a &lt;code&gt;Window&lt;/code&gt;
                  on a different screen device by constructing the &lt;code&gt;Window&lt;/code&gt;
                  with {@link #Window(Window,GraphicsConfiguration)}.  The
                  &lt;code&gt;GraphicsConfiguration&lt;/code&gt; object is one of the
                  &lt;code&gt;GraphicsConfiguration&lt;/code&gt; objects of the target screen device.
                  &lt;p&gt;
                  In a virtual device multi-screen environment in which the desktop
                  area could span multiple physical screen devices, the bounds of all
                  configurations are relative to the virtual device coordinate system.
                  The origin of the virtual-coordinate system is at the upper left-hand
                  corner of the primary physical screen.  Depending on the location of
                  the primary screen in the virtual device, negative coordinates are
                  possible, as shown in the following figure.
                  &lt;p&gt;
                  &lt;img src=&quot;doc-files/MultiScreen.gif&quot;
                  alt=&quot;Diagram shows virtual device containing 4 physical screens. Primary physical screen shows coords (0,0), other screen shows (-80,-100).&quot;
                  ALIGN=center HSPACE=10 VSPACE=7&gt;
                  &lt;p&gt;
                  In such an environment, when calling &lt;code&gt;setLocation&lt;/code&gt;,
                  you must pass a virtual coordinate to this method.  Similarly,
                  calling &lt;code&gt;getLocationOnScreen&lt;/code&gt; on a &lt;code&gt;Window&lt;/code&gt; returns
                  virtual device coordinates.  Call the &lt;code&gt;getBounds&lt;/code&gt; method
                  of a &lt;code&gt;GraphicsConfiguration&lt;/code&gt; to find its origin in the virtual
                  coordinate system.
                  &lt;p&gt;
                  The following code sets the location of a &lt;code&gt;Window&lt;/code&gt;
                  at (10, 10) relative to the origin of the physical screen
                  of the corresponding &lt;code&gt;GraphicsConfiguration&lt;/code&gt;.  If the
                  bounds of the &lt;code&gt;GraphicsConfiguration&lt;/code&gt; is not taken
                  into account, the &lt;code&gt;Window&lt;/code&gt; location would be set
                  at (10, 10) relative to the virtual-coordinate system and would appear
                  on the primary physical screen, which might be different from the
                  physical screen of the specified &lt;code&gt;GraphicsConfiguration&lt;/code&gt;.
                  &lt;pre&gt;
                  Window w = new Window(Window owner, GraphicsConfiguration gc);
                  Rectangle bounds = gc.getBounds();
                  w.setLocation(10 + bounds.x, 10 + bounds.y);
                  &lt;/pre&gt;
                  &lt;p&gt;
                  Note: the location and size of top-level windows (including
                  &lt;code&gt;Window&lt;/code&gt;s, &lt;code&gt;Frame&lt;/code&gt;s, and &lt;code&gt;Dialog&lt;/code&gt;s)
                  are under the control of the desktop&apos;s window management system.
                  Calls to &lt;code&gt;setLocation&lt;/code&gt;, &lt;code&gt;setSize&lt;/code&gt;, and
                  &lt;code&gt;setBounds&lt;/code&gt; are requests (not directives) which are
                  forwarded to the window management system.  Every effort will be
                  made to honor such requests.  However, in some cases the window
                  management system may ignore such requests, or modify the requested
                  geometry in order to place and size the &lt;code&gt;Window&lt;/code&gt; in a way
                  that more closely matches the desktop settings.
                  &lt;p&gt;
                  Due to the asynchronous nature of native event handling, the results
                  returned by &lt;code&gt;getBounds&lt;/code&gt;, &lt;code&gt;getLocation&lt;/code&gt;,
                  &lt;code&gt;getLocationOnScreen&lt;/code&gt;, and &lt;code&gt;getSize&lt;/code&gt; might not
                  reflect the actual geometry of the Window on screen until the last
                  request has been processed.  During the processing of subsequent
                  requests these values might change accordingly while the window
                  management system fulfills the requests.
                  &lt;p&gt;
                  An application may set the size and location of an invisible{@code Window} arbitrarily, but the window management system may
                  subsequently change its size and/or location when the{@code Window} is made visible. One or more {@code ComponentEvent}s
                  will be generated to indicate the new geometry.
                  &lt;p&gt;
                  Windows are capable of generating the following WindowEvents:
                  WindowOpened, WindowClosed, WindowGainedFocus, WindowLostFocus.                
                <author>
                    Sami Shaio                    
                </author>
                <author>
                    Arthur van Hoff                    
                </author>
                <see>
                    WindowEvent                    
                </see>
                <see>
                    #addWindowListener                    
                </see>
                <see>
                    java.awt.BorderLayout                    
                </see>
                <since>
                    JDK1.0                    
                </since>
            </javadoc>
            <javadoc line="150">
                Enumeration of available &lt;i&gt;window types&lt;/i&gt;.
                  A window type defines the generic visual appearance and behavior of a
                  top-level window. For example, the type may affect the kind of
                  decorations of a decorated {@code Frame} or {@code Dialog} instance.
                  &lt;p&gt;
                  Some platforms may not fully support a certain window type. Depending on
                  the level of support, some properties of the window type may be
                  disobeyed.                
                <see>
                    #getType                    
                </see>
                <see>
                    #setType                    
                </see>
                <since>
                    1.7                    
                </since>
            </javadoc>
            <javadoc line="166">
                Represents a &lt;i&gt;normal&lt;/i&gt; window.
                  This is the default type for objects of the {@code Window} class or
                  its descendants. Use this type for regular top-level windows.                
            </javadoc>
            <javadoc line="174">
                Represents a &lt;i&gt;utility&lt;/i&gt; window.
                  A utility window is usually a small window such as a toolbar or a
                  palette. The native system may render the window with smaller
                  title-bar if the window is either a {@code Frame} or a {@codeDialog} object, and if it has its decorations enabled.                
            </javadoc>
            <javadoc line="184">
                Represents a &lt;i&gt;popup&lt;/i&gt; window.
                  A popup window is a temporary window such as a drop-down menu or a
                  tooltip. On some platforms, windows of that type may be forcibly
                  made undecorated even if they are instances of the {@code Frame} or{@code Dialog} class, and have decorations enabled.                
            </javadoc>
            <declaration name="warningString" type="String" line="195"/>
            <javadoc line="195">
                This represents the warning message that is
                  to be displayed in a non secure window. ie :
                  a window that has a security manager installed for
                  which calling SecurityManager.checkTopLevelWindow()
                  is false.  This message can be displayed anywhere in
                  the window.                
                <serial>
                                        
                </serial>
                <see>
                    #getWarningString                    
                </see>
            </javadoc>
            <declaration name="icons" type="java.util.List&lt;Image&gt;" line="208"/>
            <javadoc line="208">
                {@code icons} is the graphical way we can
                  represent the frames and dialogs.{@code Window} can&apos;t display icon but it&apos;s
                  being inherited by owned {@code Dialog}s.                
                <serial>
                                        
                </serial>
                <see>
                    #getIconImages                    
                </see>
                <see>
                    #setIconImages(List<? extends Image>)                    
                </see>
            </javadoc>
            <declaration name="temporaryLostComponent" type="Component" line="220"/>
            <javadoc line="220">
                Holds the reference to the component which last had focus in this window
                  before it lost focus.                
            </javadoc>
            <declaration name="systemSyncLWRequests" type="boolean" line="226"/>
            <declaration name="syncLWRequests" type="boolean" line="227"/>
            <declaration name="beforeFirstShow" type="boolean" line="228"/>
            <declaration name="OPENED" type="int" line="230"/>
            <declaration name="state" type="int" line="232"/>
            <javadoc line="232">
                An Integer value representing the Window State.                
                <serial>
                                        
                </serial>
                <since>
                    1.2                    
                </since>
                <see>
                    #show                    
                </see>
            </javadoc>
            <declaration name="alwaysOnTop" type="boolean" line="241"/>
            <javadoc line="241">
                A boolean value representing Window always-on-top state                
                <since>
                    1.5                    
                </since>
                <serial>
                                        
                </serial>
                <see>
                    #setAlwaysOnTop                    
                </see>
                <see>
                    #isAlwaysOnTop                    
                </see>
            </javadoc>
            <declaration name="allWindows" type="IdentityArrayList&lt;Window&gt;" line="250"/>
            <javadoc line="250">
                Contains all the windows that have a peer object associated,
                  i. e. between addNotify() and removeNotify() calls. The list
                  of all Window instances can be obtained from AppContext object.                
                <since>
                    1.6                    
                </since>
            </javadoc>
            <declaration name="ownedWindowList" type="Vector&lt;WeakReference&lt;Window&gt;&gt;" line="259"/>
            <javadoc line="259">
                A vector containing all the windows this
                  window currently owns.                
                <since>
                    1.2                    
                </since>
                <see>
                    #getOwnedWindows                    
                </see>
            </javadoc>
            <declaration name="weakThis" type="WeakReference&lt;Window&gt;" line="273"/>
            <declaration name="showWithParent" type="boolean" line="275"/>
            <declaration name="modalBlocker" type="Dialog" line="277"/>
            <javadoc line="277">
                Contains the modal dialog that blocks this window, or null
                  if the window is unblocked.                
                <since>
                    1.6                    
                </since>
            </javadoc>
            <declaration name="modalExclusionType" type="Dialog.ModalExclusionType" line="285"/>
            <javadoc line="285">
                @serial                
                <see>
                    java.awt.Dialog.ModalExclusionType                    
                </see>
                <see>
                    #getModalExclusionType                    
                </see>
                <see>
                    #setModalExclusionType                    
                </see>
                <since>
                    1.6                    
                </since>
            </javadoc>
            <declaration name="windowListener" type="WindowListener" line="296"/>
            <declaration name="windowStateListener" type="WindowStateListener" line="297"/>
            <declaration name="windowFocusListener" type="WindowFocusListener" line="298"/>
            <declaration name="inputContext" type="InputContext" line="300"/>
            <declaration name="inputContextLock" type="Object" line="301"/>
            <declaration name="focusMgr" type="FocusManager" line="303"/>
            <javadoc line="303">
                Unused. Maintained for serialization backward-compatibility.                
                <serial>
                                        
                </serial>
                <since>
                    1.2                    
                </since>
            </javadoc>
            <declaration name="focusableWindowState" type="boolean" line="311"/>
            <javadoc line="311">
                Indicates whether this Window can become the focused Window.                
                <serial>
                                        
                </serial>
                <see>
                    #getFocusableWindowState                    
                </see>
                <see>
                    #setFocusableWindowState                    
                </see>
                <since>
                    1.4                    
                </since>
            </javadoc>
            <declaration name="autoRequestFocus" type="boolean" line="321"/>
            <javadoc line="321">
                Indicates whether this window should receive focus on
                  subsequently being shown (with a call to {@code setVisible(true)}), or
                  being moved to the front (with a call to {@code toFront()}).                
                <serial>
                                        
                </serial>
                <see>
                    #setAutoRequestFocus                    
                </see>
                <see>
                    #isAutoRequestFocus                    
                </see>
                <since>
                    1.7                    
                </since>
            </javadoc>
            <declaration name="isInShow" type="boolean" line="340"/>
            <declaration name="opacity" type="float" line="350"/>
            <declaration name="shape" type="Shape" line="361"/>
            <declaration name="base" type="String" line="363"/>
            <declaration name="nameCounter" type="int" line="364"/>
            <declaration name="serialVersionUID" type="long" line="369"/>
            <declaration name="log" type="PlatformLogger" line="371"/>
            <declaration name="locationByPlatformProp" type="boolean" line="373"/>
            <declaration name="isTrayIconWindow" type="boolean" line="375"/>
            <declaration name="securityWarningWidth" type="int" line="377"/>
            <javadoc line="377">
                These fields are initialized in the native peer code
                  or via AWTAccessor&apos;s WindowAccessor.                
            </javadoc>
            <declaration name="securityWarningHeight" type="int" line="382"/>
            <declaration name="securityWarningPointX" type="double" line="384"/>
            <javadoc line="384">
                These fields represent the desired location for the security
                  warning if this window is untrusted.
                  See com.sun.awt.SecurityWarning for more details.                
            </javadoc>
            <declaration name="securityWarningPointY" type="double" line="390"/>
            <declaration name="securityWarningAlignmentX" type="float" line="391"/>
            <declaration name="securityWarningAlignmentY" type="float" line="392"/>
            <scope line="394">
                <scope line="397"/>
                <declaration name="s" type="String" line="401"/>
            </scope>
            <method name="initIDs" type="void" line="409"/>
            <javadoc line="409">
                Initialize JNI field and method IDs for fields that may be
                  accessed from C.                
            </javadoc>
            <javadoc line="415">
                Constructs a new, initially invisible window in default size with the
                  specified &lt;code&gt;GraphicsConfiguration&lt;/code&gt;.
                  &lt;p&gt;
                  If there is a security manager, this method first calls
                  the security manager&apos;s &lt;code&gt;checkTopLevelWindow&lt;/code&gt;
                  method with &lt;code&gt;this&lt;/code&gt;
                  as its argument to determine whether or not the window
                  must be displayed with a warning banner.                
                <param>
                    gc the <code>GraphicsConfiguration</code> of the target screen
                      device. If <code>gc</code> is <code>null</code>, the system default
                      <code>GraphicsConfiguration</code> is assumed                    
                </param>
                <exception>
                    IllegalArgumentException if <code>gc</code>
                      is not from a screen device                    
                </exception>
                <exception>
                    HeadlessException when
                      <code>GraphicsEnvironment.isHeadless()</code> returns <code>true</code>                    
                </exception>
                <see>
                    java.awt.GraphicsEnvironment#isHeadless                    
                </see>
                <see>
                    java.lang.SecurityManager#checkTopLevelWindow                    
                </see>
            </javadoc>
            <method name="Window" type="constructor" line="436">
                <params>
                    <param name="gc" type="GraphicsConfiguration"/>
                </params>
            </method>
            <declaration name="anchor" type="Object" line="440"/>
            <class name="WindowDisposerRecord" line="441">
                <comment line="3093">
                    JDK 1.3 serialVersionUID                    
                </comment>
                <implements interface="sun.java2d.DisposerRecord"/>
                <declaration name="owner" type="WeakReference&lt;Window&gt;" line="442"/>
                <declaration name="weakThis" type="WeakReference" line="443"/>
                <declaration name="context" type="WeakReference&lt;AppContext&gt;" line="444"/>
                <method name="WindowDisposerRecord" type="constructor" line="445">
                    <params>
                        <param name="context" type="AppContext"/>
                        <param name="victim" type="Window"/>
                    </params>
                </method>
                <method name="dispose" type="void" line="450">
                    <declaration name="parent" type="Window" line="451"/>
                    <scope line="452"/>
                    <declaration name="ac" type="AppContext" line="455"/>
                    <scope line="456"/>
                </method>
            </class>
            <method name="initGC" type="GraphicsConfiguration" line="462">
                <params>
                    <param name="gc" type="GraphicsConfiguration"/>
                </params>
                <scope line="465"/>
            </method>
            <method name="init" type="void" line="474">
                <params>
                    <param name="gc" type="GraphicsConfiguration"/>
                </params>
                <comment line="494">
                                        
                </comment>
                <comment line="495">
                                        
                </comment>
                <comment line="502">
                                        
                </comment>
                <scope line="489"/>
                <declaration name="screenBounds" type="Rectangle" line="496"/>
                <declaration name="screenInsets" type="Insets" line="497"/>
                <declaration name="x" type="int" line="498"/>
                <declaration name="y" type="int" line="499"/>
                <scope line="500"/>
            </method>
            <javadoc line="511">
                Constructs a new, initially invisible window in the default size.
                  &lt;p&gt;First, if there is a security manager, its
                  &lt;code&gt;checkTopLevelWindow&lt;/code&gt;
                  method is called with &lt;code&gt;this&lt;/code&gt;
                  as its argument
                  to see if it&apos;s ok to display the window without a warning banner.
                  If the default implementation of &lt;code&gt;checkTopLevelWindow&lt;/code&gt;
                  is used (that is, that method is not overriden), then this results in
                  a call to the security manager&apos;s &lt;code&gt;checkPermission&lt;/code&gt; method
                  with an &lt;code&gt;AWTPermission(&quot;showWindowWithoutWarningBanner&quot;)&lt;/code&gt;
                  permission. It that method raises a SecurityException,
                  &lt;code&gt;checkTopLevelWindow&lt;/code&gt; returns false, otherwise it
                  returns true. If it returns false, a warning banner is created.                
                <exception>
                    HeadlessException when
                      <code>GraphicsEnvironment.isHeadless()</code> returns <code>true</code>                    
                </exception>
                <see>
                    java.awt.GraphicsEnvironment#isHeadless                    
                </see>
                <see>
                    java.lang.SecurityManager#checkTopLevelWindow                    
                </see>
            </javadoc>
            <method name="Window" type="constructor" line="533"/>
            <javadoc line="538">
                Constructs a new, initially invisible window with the specified
                  &lt;code&gt;Frame&lt;/code&gt; as its owner. The window will not be focusable
                  unless its owner is showing on the screen.
                  &lt;p&gt;
                  If there is a security manager, this method first calls
                  the security manager&apos;s &lt;code&gt;checkTopLevelWindow&lt;/code&gt;
                  method with &lt;code&gt;this&lt;/code&gt;
                  as its argument to determine whether or not the window
                  must be displayed with a warning banner.                
                <param>
                    owner the <code>Frame</code> to act as owner or <code>null</code>
                      if this window has no owner                    
                </param>
                <exception>
                    IllegalArgumentException if the <code>owner</code>'s
                      <code>GraphicsConfiguration</code> is not from a screen device                    
                </exception>
                <exception>
                    HeadlessException when
                      <code>GraphicsEnvironment.isHeadless</code> returns <code>true</code>                    
                </exception>
                <see>
                    java.awt.GraphicsEnvironment#isHeadless                    
                </see>
                <see>
                    java.lang.SecurityManager#checkTopLevelWindow                    
                </see>
                <see>
                    #isShowing                    
                </see>
            </javadoc>
            <method name="Window" type="constructor" line="560">
                <params>
                    <param name="owner" type="Frame"/>
                </params>
            </method>
            <javadoc line="566">
                Constructs a new, initially invisible window with the specified
                  &lt;code&gt;Window&lt;/code&gt; as its owner. This window will not be focusable
                  unless its nearest owning &lt;code&gt;Frame&lt;/code&gt; or &lt;code&gt;Dialog&lt;/code&gt;
                  is showing on the screen.
                  &lt;p&gt;
                  If there is a security manager, this method first calls
                  the security manager&apos;s &lt;code&gt;checkTopLevelWindow&lt;/code&gt;
                  method with &lt;code&gt;this&lt;/code&gt;
                  as its argument to determine whether or not the window
                  must be displayed with a warning banner.                
                <param>
                    owner the <code>Window</code> to act as owner or
                      <code>null</code> if this window has no owner                    
                </param>
                <exception>
                    IllegalArgumentException if the <code>owner</code>'s
                      <code>GraphicsConfiguration</code> is not from a screen device                    
                </exception>
                <exception>
                    HeadlessException when
                      <code>GraphicsEnvironment.isHeadless()</code> returns
                      <code>true</code>                    
                </exception>
                <see>
                    java.awt.GraphicsEnvironment#isHeadless                    
                </see>
                <see>
                    java.lang.SecurityManager#checkTopLevelWindow                    
                </see>
                <see>
                    #isShowing                    
                </see>
                <since>
                    1.2                    
                </since>
            </javadoc>
            <method name="Window" type="constructor" line="592">
                <params>
                    <param name="owner" type="Window"/>
                </params>
            </method>
            <javadoc line="598">
                Constructs a new, initially invisible window with the specified owner
                  &lt;code&gt;Window&lt;/code&gt; and a &lt;code&gt;GraphicsConfiguration&lt;/code&gt;
                  of a screen device. The Window will not be focusable unless
                  its nearest owning &lt;code&gt;Frame&lt;/code&gt; or &lt;code&gt;Dialog&lt;/code&gt;
                  is showing on the screen.
                  &lt;p&gt;
                  If there is a security manager, this method first calls
                  the security manager&apos;s &lt;code&gt;checkTopLevelWindow&lt;/code&gt;
                  method with &lt;code&gt;this&lt;/code&gt;
                  as its argument to determine whether or not the window
                  must be displayed with a warning banner.                
                <param>
                    owner the window to act as owner or <code>null</code>
                      if this window has no owner                    
                </param>
                <param>
                    gc the <code>GraphicsConfiguration</code> of the target
                      screen device; if <code>gc</code> is <code>null</code>,
                      the system default <code>GraphicsConfiguration</code> is assumed                    
                </param>
                <exception>
                    IllegalArgumentException if <code>gc</code>
                      is not from a screen device                    
                </exception>
                <exception>
                    HeadlessException when
                      <code>GraphicsEnvironment.isHeadless()</code> returns
                      <code>true</code>                    
                </exception>
                <see>
                    java.awt.GraphicsEnvironment#isHeadless                    
                </see>
                <see>
                    java.lang.SecurityManager#checkTopLevelWindow                    
                </see>
                <see>
                    GraphicsConfiguration#getBounds                    
                </see>
                <see>
                    #isShowing                    
                </see>
                <since>
                    1.3                    
                </since>
            </javadoc>
            <method name="Window" type="constructor" line="628">
                <params>
                    <param name="owner" type="Window"/>
                    <param name="gc" type="GraphicsConfiguration"/>
                </params>
            </method>
            <method name="ownedInit" type="void" line="633">
                <params>
                    <param name="owner" type="Window"/>
                </params>
                <comment line="639">
                    Fix for 6758673: this call is moved here from init(gc), because                    
                </comment>
                <comment line="640">
                    WindowDisposerRecord requires a proper value of parent field.                    
                </comment>
                <scope line="635"/>
            </method>
            <javadoc line="644">
                Construct a name for this component.  Called by getName() when the
                  name is null.                
            </javadoc>
            <method name="constructComponentName" type="String" line="648">
                <scope line="649"/>
            </method>
            <javadoc line="654">
                Returns the sequence of images to be displayed as the icon for this window.
                  &lt;p&gt;
                  This method returns a copy of the internally stored list, so all operations
                  on the returned object will not affect the window&apos;s behavior.                
                <return>
                    the copy of icon images' list for this window, or
                      empty list if this window doesn't have icon images.                    
                </return>
                <see>
                    #setIconImages                    
                </see>
                <see>
                    #setIconImage(Image)                    
                </see>
                <since>
                    1.6                    
                </since>
            </javadoc>
            <method name="getIconImages" type="java.util.List<Image>" line="666">
                <declaration name="icons" type="java.util.List&lt;Image&gt;" line="667"/>
                <scope line="668"/>
            </method>
            <javadoc line="674">
                Sets the sequence of images to be displayed as the icon
                  for this window. Subsequent calls to {@code getIconImages} will
                  always return a copy of the {@code icons} list.
                  &lt;p&gt;
                  Depending on the platform capabilities one or several images
                  of different dimensions will be used as the window&apos;s icon.
                  &lt;p&gt;
                  The {@code icons} list is scanned for the images of most
                  appropriate dimensions from the beginning. If the list contains
                  several images of the same size, the first will be used.
                  &lt;p&gt;
                  Ownerless windows with no icon specified use platfrom-default icon.
                  The icon of an owned window may be inherited from the owner
                  unless explicitly overridden.
                  Setting the icon to {@code null} or empty list restores
                  the default behavior.
                  &lt;p&gt;
                  Note : Native windowing systems may use different images of differing
                  dimensions to represent a window, depending on the context (e.g.
                  window decoration, window list, taskbar, etc.). They could also use
                  just a single image for all contexts or no image at all.                
                <param>
                    icons the list of icon images to be displayed.                    
                </param>
                <see>
                    #getIconImages()                    
                </see>
                <see>
                    #setIconImage(Image)                    
                </see>
                <since>
                    1.6                    
                </since>
            </javadoc>
            <method name="setIconImages" type="void" line="702">
                <params>
                    <param name="icons" type="java.util.List<? extends Image>"/>
                </params>
                <comment line="709">
                    Always send a property change event                    
                </comment>
                <declaration name="peer" type="WindowPeer" line="705"/>
                <scope line="706"/>
            </method>
            <javadoc line="713">
                Sets the image to be displayed as the icon for this window.
                  &lt;p&gt;
                  This method can be used instead of {@link #setIconImages setIconImages()}to specify a single image as a window&apos;s icon.
                  &lt;p&gt;
                  The following statement:
                  &lt;pre&gt;
                  setIconImage(image);
                  &lt;/pre&gt;
                  is equivalent to:
                  &lt;pre&gt;
                  ArrayList&amp;lt;Image&amp;gt; imageList = new ArrayList&amp;lt;Image&amp;gt;();
                  imageList.add(image);
                  setIconImages(imageList);
                  &lt;/pre&gt;
                  &lt;p&gt;
                  Note : Native windowing systems may use different images of differing
                  dimensions to represent a window, depending on the context (e.g.
                  window decoration, window list, taskbar, etc.). They could also use
                  just a single image for all contexts or no image at all.                
                <param>
                    image the icon image to be displayed.                    
                </param>
                <see>
                    #setIconImages                    
                </see>
                <see>
                    #getIconImages()                    
                </see>
                <since>
                    1.6                    
                </since>
            </javadoc>
            <method name="setIconImage" type="void" line="740">
                <params>
                    <param name="image" type="Image"/>
                </params>
                <declaration name="imageList" type="ArrayList&lt;Image&gt;" line="741"/>
                <scope line="742"/>
            </method>
            <javadoc line="748">
                Makes this Window displayable by creating the connection to its
                  native screen resource.
                  This method is called internally by the toolkit and should
                  not be called directly by programs.                
                <see>
                    Component#isDisplayable                    
                </see>
                <see>
                    Container#removeNotify                    
                </see>
                <since>
                    JDK1.0                    
                </since>
            </javadoc>
            <method name="addNotify" type="void" line="757">
                <scope line="758">
                    <declaration name="parent" type="Container" line="759"/>
                    <scope line="760"/>
                    <scope line="763"/>
                    <scope line="766"/>
                </scope>
            </method>
            <javadoc line="773">
                {@inheritDoc}                
            </javadoc>
            <method name="removeNotify" type="void" line="776">
                <scope line="777">
                    <scope line="778"/>
                </scope>
            </method>
            <javadoc line="785">
                Causes this Window to be sized to fit the preferred size
                  and layouts of its subcomponents. The resulting width and
                  height of the window are automatically enlarged if either
                  of dimensions is less than the minimum size as specified
                  by the previous call to the {@code setMinimumSize} method.
                  &lt;p&gt;
                  If the window and/or its owner are not displayable yet,
                  both of them are made displayable before calculating
                  the preferred size. The Window is validated after its
                  size is being calculated.                
                <see>
                    Component#isDisplayable                    
                </see>
                <see>
                    #setMinimumSize                    
                </see>
            </javadoc>
            <method name="pack" type="void" line="800">
                <declaration name="parent" type="Container" line="801"/>
                <scope line="802"/>
                <scope line="805"/>
                <declaration name="newSize" type="Dimension" line="808"/>
                <scope line="809"/>
                <scope line="813"/>
            </method>
            <javadoc line="820">
                Sets the minimum size of this window to a constant
                  value.  Subsequent calls to {@code getMinimumSize}will always return this value. If current window&apos;s
                  size is less than {@code minimumSize} the size of the
                  window is automatically enlarged to honor the minimum size.
                  &lt;p&gt;
                  If the {@code setSize} or {@code setBounds} methods
                  are called afterwards with a width or height less than
                  that was specified by the {@code setMinimumSize} method
                  the window is automatically enlarged to meet
                  the {@code minimumSize} value. The {@code minimumSize}value also affects the behaviour of the {@code pack} method.
                  &lt;p&gt;
                  The default behavior is restored by setting the minimum size
                  parameter to the {@code null} value.
                  &lt;p&gt;
                  Resizing operation may be restricted if the user tries
                  to resize window below the {@code minimumSize} value.
                  This behaviour is platform-dependent.                
                <param>
                    minimumSize the new minimum size of this window                    
                </param>
                <see>
                    Component#setMinimumSize                    
                </see>
                <see>
                    #getMinimumSize                    
                </see>
                <see>
                    #isMinimumSizeSet                    
                </see>
                <see>
                    #setSize(Dimension)                    
                </see>
                <see>
                    #pack                    
                </see>
                <since>
                    1.6                    
                </since>
            </javadoc>
            <method name="setMinimumSize" type="void" line="849">
                <params>
                    <param name="minimumSize" type="Dimension"/>
                </params>
                <scope line="850">
                    <declaration name="size" type="Dimension" line="852"/>
                    <scope line="853">
                        <scope line="854">
                            <declaration name="nw" type="int" line="855"/>
                            <declaration name="nh" type="int" line="856"/>
                        </scope>
                    </scope>
                    <scope line="860"/>
                </scope>
            </method>
            <javadoc line="866">
                {@inheritDoc}&lt;p&gt;
                  The {@code d.width} and {@code d.height} values
                  are automatically enlarged if either is less than
                  the minimum size as specified by previous call to{@code setMinimumSize}.
                  &lt;p&gt;
                  The method changes the geometry-related data. Therefore,
                  the native windowing system may ignore such requests, or it may modify
                  the requested data, so that the {@code Window} object is placed and sized
                  in a way that corresponds closely to the desktop settings.                
                <see>
                    #getSize                    
                </see>
                <see>
                    #setBounds                    
                </see>
                <see>
                    #setMinimumSize                    
                </see>
                <since>
                    1.6                    
                </since>
            </javadoc>
            <method name="setSize" type="void" line="884">
                <params>
                    <param name="d" type="Dimension"/>
                </params>
            </method>
            <javadoc line="888">
                {@inheritDoc}&lt;p&gt;
                  The {@code width} and {@code height} values
                  are automatically enlarged if either is less than
                  the minimum size as specified by previous call to{@code setMinimumSize}.
                  &lt;p&gt;
                  The method changes the geometry-related data. Therefore,
                  the native windowing system may ignore such requests, or it may modify
                  the requested data, so that the {@code Window} object is placed and sized
                  in a way that corresponds closely to the desktop settings.                
                <see>
                    #getSize                    
                </see>
                <see>
                    #setBounds                    
                </see>
                <see>
                    #setMinimumSize                    
                </see>
                <since>
                    1.6                    
                </since>
            </javadoc>
            <method name="setSize" type="void" line="906">
                <params>
                    <param name="width" type="int"/>
                    <param name="height" type="int"/>
                </params>
            </method>
            <javadoc line="910">
                {@inheritDoc}&lt;p&gt;
                  The method changes the geometry-related data. Therefore,
                  the native windowing system may ignore such requests, or it may modify
                  the requested data, so that the {@code Window} object is placed and sized
                  in a way that corresponds closely to the desktop settings.                
            </javadoc>
            <method name="setLocation" type="void" line="919">
                <params>
                    <param name="x" type="int"/>
                    <param name="y" type="int"/>
                </params>
            </method>
            <javadoc line="923">
                {@inheritDoc}&lt;p&gt;
                  The method changes the geometry-related data. Therefore,
                  the native windowing system may ignore such requests, or it may modify
                  the requested data, so that the {@code Window} object is placed and sized
                  in a way that corresponds closely to the desktop settings.                
            </javadoc>
            <method name="setLocation" type="void" line="932">
                <params>
                    <param name="p" type="Point"/>
                </params>
            </method>
            <javadoc line="936">
                @deprecated As of JDK version 1.1,
                  replaced by &lt;code&gt;setBounds(int, int, int, int)&lt;/code&gt;.                
            </javadoc>
            <method name="reshape" type="void" line="941">
                <params>
                    <param name="x" type="int"/>
                    <param name="y" type="int"/>
                    <param name="width" type="int"/>
                    <param name="height" type="int"/>
                </params>
                <scope line="942">
                    <declaration name="minSize" type="Dimension" line="943"/>
                    <scope line="944"/>
                    <scope line="947"/>
                </scope>
            </method>
            <method name="setClientSize" type="void" line="954">
                <params>
                    <param name="w" type="int"/>
                    <param name="h" type="int"/>
                </params>
                <scope line="955"/>
            </method>
            <declaration name="beforeFirstWindowShown" type="AtomicBoolean" line="961"/>
            <method name="closeSplashScreen" type="void" line="964">
                <comment line="969">
                    We don&apos;t use SplashScreen.getSplashScreen() to avoid instantiating                    
                </comment>
                <comment line="970">
                    the object if it hasn&apos;t been requested by user code explicitly                    
                </comment>
                <scope line="965"/>
                <scope line="968"/>
            </method>
            <javadoc line="976">
                Shows or hides this {@code Window} depending on the value of parameter{@code b}.
                  &lt;p&gt;
                  If the method shows the window then the window is also made
                  focused under the following conditions:
                  &lt;ul&gt;
                  &lt;li&gt; The {@code Window} meets the requirements outlined in the{@link #isFocusableWindow} method.
                  &lt;li&gt; The {@code Window}&apos;s {@code autoRequestFocus} property is of the {@code true} value.
                  &lt;li&gt; Native windowing system allows the {@code Window} to get focused.
                  &lt;/ul&gt;
                  There is an exception for the second condition (the value of the{@code autoRequestFocus} property). The property is not taken into account if the
                  window is a modal dialog, which blocks the currently focused window.
                  &lt;p&gt;
                  Developers must never assume that the window is the focused or active window
                  until it receives a WINDOW_GAINED_FOCUS or WINDOW_ACTIVATED event.                
                <param>
                    b  if {@code true}, makes the {@code Window} visible,
                      otherwise hides the {@code Window}.
                      If the {@code Window} and/or its owner
                      are not yet displayable, both are made displayable.  The{@code Window} will be validated prior to being made visible.
                      If the {@code Window} is already visible, this will bring the{@code Window} to the front.<p>
                      If {@code false}, hides this {@code Window}, its subcomponents, and all
                      of its owned children.
                      The {@code Window} and its subcomponents can be made visible again
                      with a call to {@code #setVisible(true)}.                    
                </param>
                <see>
                    java.awt.Component#isDisplayable                    
                </see>
                <see>
                    java.awt.Component#setVisible                    
                </see>
                <see>
                    java.awt.Window#toFront                    
                </see>
                <see>
                    java.awt.Window#dispose                    
                </see>
                <see>
                    java.awt.Window#setAutoRequestFocus                    
                </see>
                <see>
                    java.awt.Window#isFocusableWindow                    
                </see>
            </javadoc>
            <method name="setVisible" type="void" line="1012">
                <params>
                    <param name="b" type="boolean"/>
                </params>
            </method>
            <javadoc line="1016">
                Makes the Window visible. If the Window and/or its owner
                  are not yet displayable, both are made displayable.  The
                  Window will be validated prior to being made visible.
                  If the Window is already visible, this will bring the Window
                  to the front.                
                <see>
                    Component#isDisplayable                    
                </see>
                <see>
                    #toFront                    
                </see>
                <deprecated>
                    As of JDK version 1.5, replaced by{@link #setVisible(boolean)}.                    
                </deprecated>
            </javadoc>
            <method name="show" type="void" line="1028">
                <comment line="1048">
                    endif                    
                </comment>
                <comment line="1049">
                    endfor                    
                </comment>
                <comment line="1053">
                    fix for 6532736: after this window is shown, its blocker                    
                </comment>
                <comment line="1054">
                    should be raised to front                    
                </comment>
                <comment line="1063">
                    If first time shown, generate WindowOpened event                    
                </comment>
                <scope line="1029"/>
                <scope line="1035"/>
                <scope line="1037">
                    <scope line="1043">
                        <declaration name="child" type="Window" line="1044"/>
                        <scope line="1045"/>
                    </scope>
                    <scope line="1050"/>
                    <scope line="1052"/>
                    <scope line="1057"/>
                </scope>
                <scope line="1064"/>
            </method>
            <method name="updateChildFocusableWindowState" type="void" line="1070">
                <params>
                    <param name="w" type="Window"/>
                </params>
                <scope line="1071"/>
                <scope line="1074">
                    <declaration name="child" type="Window" line="1075"/>
                    <scope line="1076"/>
                </scope>
            </method>
            <method name="postWindowEvent" type="void" line="1082">
                <params>
                    <param name="id" type="int"/>
                </params>
                <scope line="1085">
                    <declaration name="e" type="WindowEvent" line="1086"/>
                </scope>
            </method>
            <javadoc line="1091">
                Hide this Window, its subcomponents, and all of its owned children.
                  The Window and its subcomponents can be made visible again
                  with a call to {@code show}.
                  &lt;/p&gt;                
                <see>
                    #show                    
                </see>
                <see>
                    #dispose                    
                </see>
                <deprecated>
                    As of JDK version 1.5, replaced by{@link #setVisible(boolean)}.                    
                </deprecated>
            </javadoc>
            <method name="hide" type="void" line="1102">
                <scope line="1103">
                    <scope line="1104">
                        <declaration name="child" type="Window" line="1105"/>
                        <scope line="1106"/>
                    </scope>
                </scope>
                <scope line="1112"/>
            </method>
            <method name="clearMostRecentFocusOwnerOnHide" type="void" line="1118">
                <comment line="1119">
                                        
                </comment>
            </method>
            <javadoc line="1122">
                Releases all of the native screen resources used by this
                  &lt;code&gt;Window&lt;/code&gt;, its subcomponents, and all of its owned
                  children. That is, the resources for these &lt;code&gt;Component&lt;/code&gt;s
                  will be destroyed, any memory they consume will be returned to the
                  OS, and they will be marked as undisplayable.
                  &lt;p&gt;
                  The &lt;code&gt;Window&lt;/code&gt; and its subcomponents can be made displayable
                  again by rebuilding the native resources with a subsequent call to
                  &lt;code&gt;pack&lt;/code&gt; or &lt;code&gt;show&lt;/code&gt;. The states of the recreated
                  &lt;code&gt;Window&lt;/code&gt; and its subcomponents will be identical to the
                  states of these objects at the point where the &lt;code&gt;Window&lt;/code&gt;
                  was disposed (not accounting for additional modifications between
                  those actions).
                  &lt;p&gt;
                  &lt;b&gt;Note&lt;/b&gt;: When the last displayable window
                  within the Java virtual machine (VM) is disposed of, the VM may
                  terminate.  See &lt;a href=&quot;doc-files/AWTThreadIssues.html#Autoshutdown&quot;&gt;
                  AWT Threading Issues&lt;/a&gt; for more information.                
                <see>
                    Component#isDisplayable                    
                </see>
                <see>
                    #pack                    
                </see>
                <see>
                    #show                    
                </see>
            </javadoc>
            <method name="dispose" type="void" line="1145"/>
            <method name="disposeImpl" type="void" line="1155">
                <scope line="1157"/>
            </method>
            <method name="doDispose" type="void" line="1162">
                <comment line="1165">
                    Check if this window is the fullscreen window for the                    
                </comment>
                <comment line="1166">
                    device. Exit the fullscreen mode prior to disposing                    
                </comment>
                <comment line="1167">
                    of the window if that&apos;s the case.                    
                </comment>
                <comment line="1214">
                    Execute outside the Runnable because postWindowEvent is                    
                </comment>
                <comment line="1215">
                    synchronized on (this). We don&apos;t need to synchronize the call                    
                </comment>
                <comment line="1216">
                    on the EventQueue anyways.                    
                </comment>
                <class name="DisposeAction" line="1163">
                    <implements interface="Runnable"/>
                    <method name="run" type="void" line="1164">
                        <comment line="1165">
                            Check if this window is the fullscreen window for the                            
                        </comment>
                        <comment line="1166">
                            device. Exit the fullscreen mode prior to disposing                            
                        </comment>
                        <comment line="1167">
                            of the window if that&apos;s the case.                            
                        </comment>
                        <declaration name="gd" type="GraphicsDevice" line="1168"/>
                        <scope line="1169"/>
                        <declaration name="ownedWindowArray" type="Object[]" line="1173"/>
                        <scope line="1174"/>
                        <scope line="1178">
                            <declaration name="child" type="Window" line="1179"/>
                            <scope line="1181"/>
                        </scope>
                        <scope line="1188">
                            <scope line="1189"/>
                        </scope>
                    </method>
                </class>
                <declaration name="action" type="DisposeAction" line="1197"/>
                <scope line="1198"/>
                <scope line="1201">
                    <scope line="1202"/>
                    <scope line="1205"/>
                    <scope line="1209"/>
                </scope>
            </method>
            <method name="adjustListeningChildrenOnParent" type="void" line="1225">
                <params>
                    <param name="mask" type="long"/>
                    <param name="num" type="int"/>
                </params>
            </method>
            <method name="adjustDecendantsOnParent" type="void" line="1229">
                <params>
                    <param name="num" type="int"/>
                </params>
                <comment line="1230">
                    do nothing since parent == owner and we shouldn&apos;t                    
                </comment>
                <comment line="1231">
                    ajust counter on owner                    
                </comment>
            </method>
            <javadoc line="1234">
                If this Window is visible, brings this Window to the front and may make
                  it the focused Window.
                  &lt;p&gt;
                  Places this Window at the top of the stacking order and shows it in
                  front of any other Windows in this VM. No action will take place if this
                  Window is not visible. Some platforms do not allow Windows which own
                  other Windows to appear on top of those owned Windows. Some platforms
                  may not permit this VM to place its Windows above windows of native
                  applications, or Windows of other VMs. This permission may depend on
                  whether a Window in this VM is already focused. Every attempt will be
                  made to move this Window as high as possible in the stacking order;
                  however, developers should not assume that this method will move this
                  Window above all other windows in every situation.
                  &lt;p&gt;
                  Developers must never assume that this Window is the focused or active
                  Window until this Window receives a WINDOW_GAINED_FOCUS or WINDOW_ACTIVATED
                  event. On platforms where the top-most window is the focused window, this
                  method will &lt;b&gt;probably&lt;/b&gt; focus this Window (if it is not already focused)
                  under the following conditions:
                  &lt;ul&gt;
                  &lt;li&gt; The window meets the requirements outlined in the{@link #isFocusableWindow} method.
                  &lt;li&gt; The window&apos;s property {@code autoRequestFocus} is of the{@code true} value.
                  &lt;li&gt; Native windowing system allows the window to get focused.
                  &lt;/ul&gt;
                  On platforms where the stacking order does not typically affect the focused
                  window, this method will &lt;b&gt;probably&lt;/b&gt; leave the focused and active
                  Windows unchanged.
                  &lt;p&gt;
                  If this method causes this Window to be focused, and this Window is a
                  Frame or a Dialog, it will also become activated. If this Window is
                  focused, but it is not a Frame or a Dialog, then the first Frame or
                  Dialog that is an owner of this Window will be activated.
                  &lt;p&gt;
                  If this window is blocked by modal dialog, then the blocking dialog
                  is brought to the front and remains above the blocked window.                
                <see>
                    #toBack                    
                </see>
                <see>
                    #setAutoRequestFocus                    
                </see>
                <see>
                    #isFocusableWindow                    
                </see>
            </javadoc>
            <method name="toFront" type="void" line="1277"/>
            <method name="toFront_NoClientCode" type="void" line="1283">
                <scope line="1284">
                    <declaration name="peer" type="WindowPeer" line="1285"/>
                    <scope line="1286"/>
                    <scope line="1289"/>
                </scope>
            </method>
            <javadoc line="1295">
                If this Window is visible, sends this Window to the back and may cause
                  it to lose focus or activation if it is the focused or active Window.
                  &lt;p&gt;
                  Places this Window at the bottom of the stacking order and shows it
                  behind any other Windows in this VM. No action will take place is this
                  Window is not visible. Some platforms do not allow Windows which are
                  owned by other Windows to appear below their owners. Every attempt will
                  be made to move this Window as low as possible in the stacking order;
                  however, developers should not assume that this method will move this
                  Window below all other windows in every situation.
                  &lt;p&gt;
                  Because of variations in native windowing systems, no guarantees about
                  changes to the focused and active Windows can be made. Developers must
                  never assume that this Window is no longer the focused or active Window
                  until this Window receives a WINDOW_LOST_FOCUS or WINDOW_DEACTIVATED
                  event. On platforms where the top-most window is the focused window,
                  this method will &lt;b&gt;probably&lt;/b&gt; cause this Window to lose focus. In
                  that case, the next highest, focusable Window in this VM will receive
                  focus. On platforms where the stacking order does not typically affect
                  the focused window, this method will &lt;b&gt;probably&lt;/b&gt; leave the focused
                  and active Windows unchanged.                
                <see>
                    #toFront                    
                </see>
            </javadoc>
            <method name="toBack" type="void" line="1320"/>
            <method name="toBack_NoClientCode" type="void" line="1326">
                <scope line="1327">
                    <scope line="1328"/>
                    <scope line="1330"/>
                </scope>
                <scope line="1333">
                    <declaration name="peer" type="WindowPeer" line="1334"/>
                    <scope line="1335"/>
                </scope>
            </method>
            <javadoc line="1341">
                Returns the toolkit of this frame.                
                <return>
                    the toolkit of this window.                    
                </return>
                <see>
                    Toolkit                    
                </see>
                <see>
                    Toolkit#getDefaultToolkit                    
                </see>
                <see>
                    Component#getToolkit                    
                </see>
            </javadoc>
            <method name="getToolkit" type="Toolkit" line="1348"/>
            <javadoc line="1352">
                Gets the warning string that is displayed with this window.
                  If this window is insecure, the warning string is displayed
                  somewhere in the visible area of the window. A window is
                  insecure if there is a security manager, and the security
                  manager&apos;s &lt;code&gt;checkTopLevelWindow&lt;/code&gt; method returns
                  &lt;code&gt;false&lt;/code&gt; when this window is passed to it as an
                  argument.
                  &lt;p&gt;
                  If the window is secure, then &lt;code&gt;getWarningString&lt;/code&gt;
                  returns &lt;code&gt;null&lt;/code&gt;. If the window is insecure, this
                  method checks for the system property
                  &lt;code&gt;awt.appletWarning&lt;/code&gt;
                  and returns the string value of that property.                
                <return>
                    the warning string for this window.                    
                </return>
                <see>
                    java.lang.SecurityManager#checkTopLevelWindow(java.lang.Object)                    
                </see>
            </javadoc>
            <method name="getWarningString" type="String" line="1369"/>
            <method name="setWarningString" type="void" line="1373">
                <comment line="1378">
                    make sure the privileged action is only                    
                </comment>
                <comment line="1379">
                    for getting the property! We don&apos;t want the                    
                </comment>
                <comment line="1380">
                    above checkTopLevelWindow call to always succeed!                    
                </comment>
                <declaration name="sm" type="SecurityManager" line="1375"/>
                <scope line="1376">
                    <scope line="1377"/>
                </scope>
            </method>
            <javadoc line="1388">
                Gets the &lt;code&gt;Locale&lt;/code&gt; object that is associated
                  with this window, if the locale has been set.
                  If no locale has been set, then the default locale
                  is returned.                
                <return>
                    the locale that is set for this window.                    
                </return>
                <see>
                    java.util.Locale                    
                </see>
                <since>
                    JDK1.1                    
                </since>
            </javadoc>
            <method name="getLocale" type="Locale" line="1397">
                <scope line="1398"/>
            </method>
            <javadoc line="1404">
                Gets the input context for this window. A window always has an input context,
                  which is shared by subcomponents unless they create and set their own.                
                <see>
                    Component#getInputContext                    
                </see>
                <since>
                    1.2                    
                </since>
            </javadoc>
            <method name="getInputContext" type="InputContext" line="1410">
                <scope line="1411">
                    <scope line="1412"/>
                </scope>
            </method>
            <javadoc line="1419">
                Set the cursor image to a specified cursor.
                  &lt;p&gt;
                  The method may have no visual effect if the Java platform
                  implementation and/or the native system do not support
                  changing the mouse cursor shape.                
                <param>
                    cursor One of the constants defined
                      by the <code>Cursor</code> class. If this parameter is null
                      then the cursor for this window will be set to the type
                      Cursor.DEFAULT_CURSOR.                    
                </param>
                <see>
                    Component#getCursor                    
                </see>
                <see>
                    Cursor                    
                </see>
                <since>
                    JDK1.1                    
                </since>
            </javadoc>
            <method name="setCursor" type="void" line="1433">
                <params>
                    <param name="cursor" type="Cursor"/>
                </params>
                <scope line="1434"/>
            </method>
            <javadoc line="1440">
                Returns the owner of this window.                
                <since>
                    1.2                    
                </since>
            </javadoc>
            <method name="getOwner" type="Window" line="1444"/>
            <method name="getOwner_NoClientCode" type="Window" line="1447"/>
            <javadoc line="1451">
                Return an array containing all the windows this
                  window currently owns.                
                <since>
                    1.2                    
                </since>
            </javadoc>
            <method name="getOwnedWindows" type="Window[]" line="1456"/>
            <method name="getOwnedWindows_NoClientCode" type="Window[]" line="1459">
                <comment line="1463">
                    Recall that ownedWindowList is actually a Vector of                    
                </comment>
                <comment line="1464">
                    WeakReferences and calling get() on one of these references                    
                </comment>
                <comment line="1465">
                    may return null. Make two arrays-- one the size of the                    
                </comment>
                <comment line="1466">
                    Vector (fullCopy with size fullSize), and one the size of                    
                </comment>
                <comment line="1467">
                    all non-null get()s (realCopy with size realSize).                    
                </comment>
                <declaration name="realCopy" type="Window" line="1460"/>
                <scope line="1462">
                    <declaration name="fullSize" type="int" line="1468"/>
                    <declaration name="realSize" type="int" line="1469"/>
                    <declaration name="fullCopy" type="Window" line="1470"/>
                    <scope line="1472">
                        <scope line="1475"/>
                    </scope>
                    <scope line="1480"/>
                    <scope line="1482"/>
                </scope>
            </method>
            <method name="isModalBlocked" type="boolean" line="1490"/>
            <method name="setModalBlocked" type="void" line="1494">
                <params>
                    <param name="blocker" type="Dialog"/>
                    <param name="blocked" type="boolean"/>
                    <param name="peerCall" type="boolean"/>
                </params>
                <scope line="1496">
                    <declaration name="peer" type="WindowPeer" line="1497"/>
                    <scope line="1498"/>
                </scope>
            </method>
            <method name="getModalBlocker" type="Dialog" line="1504"/>
            <method name="getAllWindows" type="IdentityArrayList<Window>" line="1515">
                <scope line="1516">
                    <declaration name="v" type="IdentityArrayList&lt;Window&gt;" line="1517"/>
                </scope>
            </method>
            <method name="getAllUnblockedWindows" type="IdentityArrayList<Window>" line="1523">
                <scope line="1524">
                    <declaration name="unblocked" type="IdentityArrayList&lt;Window&gt;" line="1525"/>
                    <scope line="1526">
                        <declaration name="w" type="Window" line="1527"/>
                        <scope line="1528"/>
                    </scope>
                </scope>
            </method>
            <method name="getWindows" type="Window[]" line="1536">
                <params>
                    <param name="appContext" type="AppContext"/>
                </params>
                <scope line="1537">
                    <declaration name="realCopy" type="Window" line="1538"/>
                    <declaration name="windowList" type="Vector&lt;WeakReference&lt;Window&gt;&gt;" line="1539"/>
                    <scope line="1541">
                        <declaration name="fullSize" type="int" line="1542"/>
                        <declaration name="realSize" type="int" line="1543"/>
                        <declaration name="fullCopy" type="Window" line="1544"/>
                        <scope line="1545">
                            <declaration name="w" type="Window" line="1546"/>
                            <scope line="1547"/>
                        </scope>
                        <scope line="1551"/>
                        <scope line="1553"/>
                    </scope>
                    <scope line="1556"/>
                </scope>
            </method>
            <javadoc line="1563">
                Returns an array of all {@code Window}s, both owned and ownerless,
                  created by this application.
                  If called from an applet, the array includes only the {@code Window}s
                  accessible by that applet.
                  &lt;p&gt;
                  &lt;b&gt;Warning:&lt;/b&gt; this method may return system created windows, such
                  as a print dialog. Applications should not assume the existence of
                  these dialogs, nor should an application assume anything about these
                  dialogs such as component positions, &lt;code&gt;LayoutManager&lt;/code&gt;s
                  or serialization.                
                <see>
                    Frame#getFrames                    
                </see>
                <see>
                    Window#getOwnerlessWindows                    
                </see>
                <since>
                    1.6                    
                </since>
            </javadoc>
            <method name="getWindows" type="Window[]" line="1580"/>
            <javadoc line="1584">
                Returns an array of all {@code Window}s created by this application
                  that have no owner. They include {@code Frame}s and ownerless{@code Dialog}s and {@code Window}s.
                  If called from an applet, the array includes only the {@code Window}s
                  accessible by that applet.
                  &lt;p&gt;
                  &lt;b&gt;Warning:&lt;/b&gt; this method may return system created windows, such
                  as a print dialog. Applications should not assume the existence of
                  these dialogs, nor should an application assume anything about these
                  dialogs such as component positions, &lt;code&gt;LayoutManager&lt;/code&gt;s
                  or serialization.                
                <see>
                    Frame#getFrames                    
                </see>
                <see>
                    Window#getWindows()                    
                </see>
                <since>
                    1.6                    
                </since>
            </javadoc>
            <method name="getOwnerlessWindows" type="Window[]" line="1602">
                <declaration name="allWindows" type="Window[]" line="1603"/>
                <declaration name="ownerlessCount" type="int" line="1605"/>
                <scope line="1606">
                    <scope line="1607"/>
                </scope>
                <declaration name="ownerless" type="Window[]" line="1612"/>
                <declaration name="c" type="int" line="1613"/>
                <scope line="1614">
                    <scope line="1615"/>
                </scope>
            </method>
            <method name="getDocumentRoot" type="Window" line="1623">
                <scope line="1624">
                    <declaration name="w" type="Window" line="1625"/>
                    <scope line="1626"/>
                </scope>
            </method>
            <javadoc line="1633">
                Specifies the modal exclusion type for this window. If a window is modal
                  excluded, it is not blocked by some modal dialogs. See {@link java.awt.Dialog.ModalExclusionType Dialog.ModalExclusionType} for
                  possible modal exclusion types.
                  &lt;p&gt;
                  If the given type is not supported, &lt;code&gt;NO_EXCLUDE&lt;/code&gt; is used.
                  &lt;p&gt;
                  Note: changing the modal exclusion type for a visible window may have no
                  effect until it is hidden and then shown again.                
                <param>
                    exclusionType the modal exclusion type for this window; a <code>null</code>
                      value is equivivalent to {@link Dialog.ModalExclusionType#NO_EXCLUDENO_EXCLUDE}                    
                </param>
                <throws>
                    SecurityException if the calling thread does not have permission
                      to set the modal exclusion property to the window with the given
                      <code>exclusionType</code>                    
                </throws>
                <see>
                    java.awt.Dialog.ModalExclusionType                    
                </see>
                <see>
                    java.awt.Window#getModalExclusionType                    
                </see>
                <see>
                    java.awt.Toolkit#isModalExclusionTypeSupported                    
                </see>
                <since>
                    1.6                    
                </since>
            </javadoc>
            <method name="setModalExclusionType" type="void" line="1656">
                <params>
                    <param name="exclusionType" type="Dialog.ModalExclusionType"/>
                </params>
                <comment line="1674">
                    if we want on-fly changes, we need to uncomment the lines below                    
                </comment>
                <comment line="1675">
                    and override the method in Dialog to use modalShow() instead                    
                </comment>
                <comment line="1676">
                    of updateChildrenBlocking()                    
                </comment>
                <comment line="1677">
                    if (isModalBlocked()) {
                    modalBlocker.unblockWindow(this);
                    }
                    Dialog.checkShouldBeBlocked(this);
                    updateChildrenBlocking();                    
                </comment>
                <scope line="1657"/>
                <scope line="1660"/>
                <scope line="1663"/>
                <scope line="1666">
                    <declaration name="sm" type="SecurityManager" line="1667"/>
                    <scope line="1668"/>
                </scope>
            </method>
            <javadoc line="1686">
                Returns the modal exclusion type of this window.                
                <return>
                    the modal exclusion type of this window                    
                </return>
                <see>
                    java.awt.Dialog.ModalExclusionType                    
                </see>
                <see>
                    java.awt.Window#setModalExclusionType                    
                </see>
                <since>
                    1.6                    
                </since>
            </javadoc>
            <method name="getModalExclusionType" type="Dialog.ModalExclusionType" line="1696"/>
            <method name="isModalExcluded" type="boolean" line="1700">
                <params>
                    <param name="exclusionType" type="Dialog.ModalExclusionType"/>
                </params>
                <scope line="1703"/>
                <declaration name="owner" type="Window" line="1706"/>
            </method>
            <method name="updateChildrenBlocking" type="void" line="1710">
                <declaration name="childHierarchy" type="Vector&lt;Window&gt;" line="1711"/>
                <declaration name="ownedWindows" type="Window[]" line="1712"/>
                <scope line="1713"/>
                <declaration name="k" type="int" line="1716"/>
                <scope line="1717">
                    <declaration name="w" type="Window" line="1718"/>
                    <scope line="1719">
                        <scope line="1720">
                            <declaration name="blocker" type="Dialog" line="1721"/>
                        </scope>
                        <declaration name="wOwned" type="Window[]" line="1725"/>
                        <scope line="1726"/>
                    </scope>
                </scope>
            </method>
            <javadoc line="1734">
                Adds the specified window listener to receive window events from
                  this window.
                  If l is null, no exception is thrown and no action is performed.
                  &lt;p&gt;Refer to &lt;a href=&quot;doc-files/AWTThreadIssues.html#ListenersThreads&quot;
                  &gt;AWT Threading Issues&lt;/a&gt; for details on AWT&apos;s threading model.                
                <param>
                    l the window listener                    
                </param>
                <see>
                    #removeWindowListener                    
                </see>
                <see>
                    #getWindowListeners                    
                </see>
            </javadoc>
            <method name="addWindowListener" type="void" line="1745">
                <params>
                    <param name="l" type="WindowListener"/>
                </params>
                <scope line="1746"/>
            </method>
            <javadoc line="1753">
                Adds the specified window state listener to receive window
                  events from this window.  If &lt;code&gt;l&lt;/code&gt; is &lt;code&gt;null&lt;/code&gt;,
                  no exception is thrown and no action is performed.
                  &lt;p&gt;Refer to &lt;a href=&quot;doc-files/AWTThreadIssues.html#ListenersThreads&quot;
                  &gt;AWT Threading Issues&lt;/a&gt; for details on AWT&apos;s threading model.                
                <param>
                    l the window state listener                    
                </param>
                <see>
                    #removeWindowStateListener                    
                </see>
                <see>
                    #getWindowStateListeners                    
                </see>
                <since>
                    1.4                    
                </since>
            </javadoc>
            <method name="addWindowStateListener" type="void" line="1765">
                <params>
                    <param name="l" type="WindowStateListener"/>
                </params>
                <scope line="1766"/>
            </method>
            <javadoc line="1773">
                Adds the specified window focus listener to receive window events
                  from this window.
                  If l is null, no exception is thrown and no action is performed.
                  &lt;p&gt;Refer to &lt;a href=&quot;doc-files/AWTThreadIssues.html#ListenersThreads&quot;
                  &gt;AWT Threading Issues&lt;/a&gt; for details on AWT&apos;s threading model.                
                <param>
                    l the window focus listener                    
                </param>
                <see>
                    #removeWindowFocusListener                    
                </see>
                <see>
                    #getWindowFocusListeners                    
                </see>
                <since>
                    1.4                    
                </since>
            </javadoc>
            <method name="addWindowFocusListener" type="void" line="1785">
                <params>
                    <param name="l" type="WindowFocusListener"/>
                </params>
                <scope line="1786"/>
            </method>
            <javadoc line="1793">
                Removes the specified window listener so that it no longer
                  receives window events from this window.
                  If l is null, no exception is thrown and no action is performed.
                  &lt;p&gt;Refer to &lt;a href=&quot;doc-files/AWTThreadIssues.html#ListenersThreads&quot;
                  &gt;AWT Threading Issues&lt;/a&gt; for details on AWT&apos;s threading model.                
                <param>
                    l the window listener                    
                </param>
                <see>
                    #addWindowListener                    
                </see>
                <see>
                    #getWindowListeners                    
                </see>
            </javadoc>
            <method name="removeWindowListener" type="void" line="1804">
                <params>
                    <param name="l" type="WindowListener"/>
                </params>
                <scope line="1805"/>
            </method>
            <javadoc line="1811">
                Removes the specified window state listener so that it no
                  longer receives window events from this window.  If
                  &lt;code&gt;l&lt;/code&gt; is &lt;code&gt;null&lt;/code&gt;, no exception is thrown and
                  no action is performed.
                  &lt;p&gt;Refer to &lt;a href=&quot;doc-files/AWTThreadIssues.html#ListenersThreads&quot;
                  &gt;AWT Threading Issues&lt;/a&gt; for details on AWT&apos;s threading model.                
                <param>
                    l the window state listener                    
                </param>
                <see>
                    #addWindowStateListener                    
                </see>
                <see>
                    #getWindowStateListeners                    
                </see>
                <since>
                    1.4                    
                </since>
            </javadoc>
            <method name="removeWindowStateListener" type="void" line="1824">
                <params>
                    <param name="l" type="WindowStateListener"/>
                </params>
                <scope line="1825"/>
            </method>
            <javadoc line="1831">
                Removes the specified window focus listener so that it no longer
                  receives window events from this window.
                  If l is null, no exception is thrown and no action is performed.
                  &lt;p&gt;Refer to &lt;a href=&quot;doc-files/AWTThreadIssues.html#ListenersThreads&quot;
                  &gt;AWT Threading Issues&lt;/a&gt; for details on AWT&apos;s threading model.                
                <param>
                    l the window focus listener                    
                </param>
                <see>
                    #addWindowFocusListener                    
                </see>
                <see>
                    #getWindowFocusListeners                    
                </see>
                <since>
                    1.4                    
                </since>
            </javadoc>
            <method name="removeWindowFocusListener" type="void" line="1843">
                <params>
                    <param name="l" type="WindowFocusListener"/>
                </params>
                <scope line="1844"/>
            </method>
            <javadoc line="1850">
                Returns an array of all the window listeners
                  registered on this window.                
                <return>
                    all of this window's <code>WindowListener</code>s
                      or an empty array if no window
                      listeners are currently registered                    
                </return>
                <see>
                    #addWindowListener                    
                </see>
                <see>
                    #removeWindowListener                    
                </see>
                <since>
                    1.4                    
                </since>
            </javadoc>
            <method name="getWindowListeners" type="WindowListener[]" line="1862"/>
            <javadoc line="1866">
                Returns an array of all the window focus listeners
                  registered on this window.                
                <return>
                    all of this window's <code>WindowFocusListener</code>s
                      or an empty array if no window focus
                      listeners are currently registered                    
                </return>
                <see>
                    #addWindowFocusListener                    
                </see>
                <see>
                    #removeWindowFocusListener                    
                </see>
                <since>
                    1.4                    
                </since>
            </javadoc>
            <method name="getWindowFocusListeners" type="WindowFocusListener[]" line="1878"/>
            <javadoc line="1882">
                Returns an array of all the window state listeners
                  registered on this window.                
                <return>
                    all of this window's <code>WindowStateListener</code>s
                      or an empty array if no window state
                      listeners are currently registered                    
                </return>
                <see>
                    #addWindowStateListener                    
                </see>
                <see>
                    #removeWindowStateListener                    
                </see>
                <since>
                    1.4                    
                </since>
            </javadoc>
            <method name="getWindowStateListeners" type="WindowStateListener[]" line="1894"/>
            <javadoc line="1899">
                Returns an array of all the objects currently registered
                  as &lt;code&gt;&lt;em&gt;Foo&lt;/em&gt;Listener&lt;/code&gt;s
                  upon this &lt;code&gt;Window&lt;/code&gt;.
                  &lt;code&gt;&lt;em&gt;Foo&lt;/em&gt;Listener&lt;/code&gt;s are registered using the
                  &lt;code&gt;add&lt;em&gt;Foo&lt;/em&gt;Listener&lt;/code&gt; method.
                  &lt;p&gt;
                  You can specify the &lt;code&gt;listenerType&lt;/code&gt; argument
                  with a class literal, such as
                  &lt;code&gt;&lt;em&gt;Foo&lt;/em&gt;Listener.class&lt;/code&gt;.
                  For example, you can query a
                  &lt;code&gt;Window&lt;/code&gt; &lt;code&gt;w&lt;/code&gt;
                  for its window listeners with the following code:
                  &lt;pre&gt;WindowListener[] wls = (WindowListener[])(w.getListeners(WindowListener.class));&lt;/pre&gt;
                  If no such listeners exist, this method returns an empty array.                
                <param>
                    listenerType the type of listeners requested; this parameter
                      should specify an interface that descends from
                      <code>java.util.EventListener</code>                    
                </param>
                <return>
                    an array of all objects registered as
                      <code><em>Foo</em>Listener</code>s on this window,
                      or an empty array if no such
                      listeners have been added                    
                </return>
                <exception>
                    ClassCastException if <code>listenerType</code>
                      doesn't specify a class or interface that implements
                      <code>java.util.EventListener</code>                    
                </exception>
                <exception>
                    NullPointerException if {@code listenerType} is {@code null}                    
                </exception>
                <see>
                    #getWindowListeners                    
                </see>
                <since>
                    1.3                    
                </since>
            </javadoc>
            <method name="getListeners" type="T[]" line="1934">
                <params>
                    <param name="listenerType" type="Class<T>"/>
                </params>
                <declaration name="l" type="EventListener" line="1935"/>
                <scope line="1936"/>
                <scope line="1938"/>
                <scope line="1940"/>
                <scope line="1942"/>
            </method>
            <method name="eventEnabled" type="boolean" line="1949">
                <params>
                    <param name="e" type="AWTEvent"/>
                </params>
                <scope line="1959"/>
                <scope line="1966"/>
                <scope line="1972"/>
            </method>
            <javadoc line="1982">
                Processes events on this window. If the event is an
                  &lt;code&gt;WindowEvent&lt;/code&gt;, it invokes the
                  &lt;code&gt;processWindowEvent&lt;/code&gt; method, else it invokes its
                  superclass&apos;s &lt;code&gt;processEvent&lt;/code&gt;.
                  &lt;p&gt;Note that if the event parameter is &lt;code&gt;null&lt;/code&gt;
                  the behavior is unspecified and may result in an
                  exception.                
                <param>
                    e the event                    
                </param>
            </javadoc>
            <method name="processEvent" type="void" line="1993">
                <params>
                    <param name="e" type="AWTEvent"/>
                </params>
                <scope line="1994"/>
            </method>
            <javadoc line="2019">
                Processes window events occurring on this window by
                  dispatching them to any registered WindowListener objects.
                  NOTE: This method will not be called unless window events
                  are enabled for this component; this happens when one of the
                  following occurs:
                  &lt;ul&gt;
                  &lt;li&gt;A WindowListener object is registered via
                  &lt;code&gt;addWindowListener&lt;/code&gt;
                  &lt;li&gt;Window events are enabled via &lt;code&gt;enableEvents&lt;/code&gt;
                  &lt;/ul&gt;
                  &lt;p&gt;Note that if the event parameter is &lt;code&gt;null&lt;/code&gt;
                  the behavior is unspecified and may result in an
                  exception.                
                <param>
                    e the window event                    
                </param>
                <see>
                    Component#enableEvents                    
                </see>
            </javadoc>
            <method name="processWindowEvent" type="void" line="2037">
                <params>
                    <param name="e" type="WindowEvent"/>
                </params>
                <declaration name="listener" type="WindowListener" line="2038"/>
                <scope line="2039"/>
            </method>
            <javadoc line="2068">
                Processes window focus event occuring on this window by
                  dispatching them to any registered WindowFocusListener objects.
                  NOTE: this method will not be called unless window focus events
                  are enabled for this window. This happens when one of the
                  following occurs:
                  &lt;ul&gt;
                  &lt;li&gt;a WindowFocusListener is registered via
                  &lt;code&gt;addWindowFocusListener&lt;/code&gt;
                  &lt;li&gt;Window focus events are enabled via &lt;code&gt;enableEvents&lt;/code&gt;
                  &lt;/ul&gt;
                  &lt;p&gt;Note that if the event parameter is &lt;code&gt;null&lt;/code&gt;
                  the behavior is unspecified and may result in an
                  exception.                
                <param>
                    e the window focus event                    
                </param>
                <see>
                    Component#enableEvents                    
                </see>
                <since>
                    1.4                    
                </since>
            </javadoc>
            <method name="processWindowFocusEvent" type="void" line="2087">
                <params>
                    <param name="e" type="WindowEvent"/>
                </params>
                <declaration name="listener" type="WindowFocusListener" line="2088"/>
                <scope line="2089"/>
            </method>
            <javadoc line="2103">
                Processes window state event occuring on this window by
                  dispatching them to any registered &lt;code&gt;WindowStateListener&lt;/code&gt;
                  objects.
                  NOTE: this method will not be called unless window state events
                  are enabled for this window.  This happens when one of the
                  following occurs:
                  &lt;ul&gt;
                  &lt;li&gt;a &lt;code&gt;WindowStateListener&lt;/code&gt; is registered via
                  &lt;code&gt;addWindowStateListener&lt;/code&gt;
                  &lt;li&gt;window state events are enabled via &lt;code&gt;enableEvents&lt;/code&gt;
                  &lt;/ul&gt;
                  &lt;p&gt;Note that if the event parameter is &lt;code&gt;null&lt;/code&gt;
                  the behavior is unspecified and may result in an
                  exception.                
                <param>
                    e the window state event                    
                </param>
                <see>
                    java.awt.Component#enableEvents                    
                </see>
                <since>
                    1.4                    
                </since>
            </javadoc>
            <method name="processWindowStateEvent" type="void" line="2123">
                <params>
                    <param name="e" type="WindowEvent"/>
                </params>
                <declaration name="listener" type="WindowStateListener" line="2124"/>
                <scope line="2125"/>
            </method>
            <javadoc line="2136">
                Implements a debugging hook -- checks to see if
                  the user has typed &lt;i&gt;control-shift-F1&lt;/i&gt;.  If so,
                  the list of child windows is dumped to &lt;code&gt;System.out&lt;/code&gt;.                
                <param>
                    e  the keyboard event                    
                </param>
            </javadoc>
            <method name="preProcessKeyEvent" type="void" line="2142">
                <params>
                    <param name="e" type="KeyEvent"/>
                </params>
                <comment line="2143">
                    Dump the list of child windows to System.out.                    
                </comment>
                <scope line="2146"/>
            </method>
            <method name="postProcessKeyEvent" type="void" line="2151">
                <params>
                    <param name="e" type="KeyEvent"/>
                </params>
                <comment line="2152">
                    Do nothing                    
                </comment>
            </method>
            <javadoc line="2156">
                Sets whether this window should always be above other windows.  If
                  there are multiple always-on-top windows, their relative order is
                  unspecified and platform dependent.
                  &lt;p&gt;
                  If some other window is already always-on-top then the
                  relative order between these windows is unspecified (depends on
                  platform).  No window can be brought to be over the always-on-top
                  window except maybe another always-on-top window.
                  &lt;p&gt;
                  All windows owned by an always-on-top window inherit this state and
                  automatically become always-on-top.  If a window ceases to be
                  always-on-top, the windows that it owns will no longer be
                  always-on-top.  When an always-on-top window is sent {@link #toBacktoBack}, its always-on-top state is set to &lt;code&gt;false&lt;/code&gt;.
                  &lt;p&gt; When this method is called on a window with a value of
                  &lt;code&gt;true&lt;/code&gt;, and the window is visible and the platform
                  supports always-on-top for this window, the window is immediately
                  brought forward, &quot;sticking&quot; it in the top-most position. If the
                  window isn`t currently visible, this method sets the always-on-top
                  state to &lt;code&gt;true&lt;/code&gt; but does not bring the window forward.
                  When the window is later shown, it will be always-on-top.
                  &lt;p&gt; When this method is called on a window with a value of
                  &lt;code&gt;false&lt;/code&gt; the always-on-top state is set to normal. The
                  window remains in the top-most position but it`s z-order can be
                  changed as for any other window.  Calling this method with a value
                  of &lt;code&gt;false&lt;/code&gt; on a window that has a normal state has no
                  effect.  Setting the always-on-top state to false has no effect on
                  the relative z-order of the windows if there are no other
                  always-on-top windows.
                  &lt;p&gt;&lt;b&gt;Note&lt;/b&gt;: some platforms might not support always-on-top
                  windows.  To detect if always-on-top windows are supported by the
                  current platform, use {@link Toolkit#isAlwaysOnTopSupported()} and{@link Window#isAlwaysOnTopSupported()}.  If always-on-top mode
                  isn&apos;t supported by the toolkit or for this window, calling this
                  method has no effect.
                  &lt;p&gt;
                  If a SecurityManager is installed, the calling thread must be
                  granted the AWTPermission &quot;setWindowAlwaysOnTop&quot; in
                  order to set the value of this property. If this
                  permission is not granted, this method will throw a
                  SecurityException, and the current value of the property will
                  be left unchanged.                
                <param>
                    alwaysOnTop true if the window should always be above other
                      windows                    
                </param>
                <throws>
                    SecurityException if the calling thread does not have
                      permission to set the value of always-on-top property                    
                </throws>
                <see>
                    #isAlwaysOnTop                    
                </see>
                <see>
                    #toFront                    
                </see>
                <see>
                    #toBack                    
                </see>
                <see>
                    AWTPermission                    
                </see>
                <see>
                    #isAlwaysOnTopSupported                    
                </see>
                <see>
                    Toolkit#isAlwaysOnTopSupported                    
                </see>
                <since>
                    1.5                    
                </since>
            </javadoc>
            <method name="setAlwaysOnTop" type="void" line="2215">
                <params>
                    <param name="alwaysOnTop" type="boolean"/>
                </params>
                <declaration name="security" type="SecurityManager" line="2216"/>
                <scope line="2217"/>
                <declaration name="oldAlwaysOnTop" type="boolean" line="2221"/>
                <scope line="2222"/>
                <scope line="2226">
                    <scope line="2227">
                        <declaration name="peer" type="WindowPeer" line="2228"/>
                        <scope line="2229">
                            <scope line="2230"/>
                        </scope>
                    </scope>
                </scope>
            </method>
            <javadoc line="2239">
                Returns whether the always-on-top mode is supported for this
                  window. Some platforms may not support always-on-top windows, some
                  may support only some kinds of top-level windows; for example,
                  a platform may not support always-on-top modal dialogs.                
                <return>
                    <code>true</code>, if the always-on-top mode is
                      supported by the toolkit and for this window,
                      <code>false</code>, if always-on-top mode is not supported
                      for this window or toolkit doesn't support always-on-top windows.                    
                </return>
                <see>
                    #setAlwaysOnTop(boolean)                    
                </see>
                <see>
                    Toolkit#isAlwaysOnTopSupported                    
                </see>
                <since>
                    1.6                    
                </since>
            </javadoc>
            <method name="isAlwaysOnTopSupported" type="boolean" line="2252"/>
            <javadoc line="2257">
                Returns whether this window is an always-on-top window.                
                <return>
                    <code>true</code>, if the window is in always-on-top state,
                      <code>false</code> otherwise                    
                </return>
                <see>
                    #setAlwaysOnTop                    
                </see>
                <since>
                    1.5                    
                </since>
            </javadoc>
            <method name="isAlwaysOnTop" type="boolean" line="2264"/>
            <javadoc line="2269">
                Returns the child Component of this Window that has focus if this Window
                  is focused; returns null otherwise.                
                <return>
                    the child Component with focus, or null if this Window is not
                      focused                    
                </return>
                <see>
                    #getMostRecentFocusOwner                    
                </see>
                <see>
                    #isFocused                    
                </see>
            </javadoc>
            <method name="getFocusOwner" type="Component" line="2278"/>
            <javadoc line="2285">
                Returns the child Component of this Window that will receive the focus
                  when this Window is focused. If this Window is currently focused, this
                  method returns the same Component as &lt;code&gt;getFocusOwner()&lt;/code&gt;. If
                  this Window is not focused, then the child Component that most recently
                  requested focus will be returned. If no child Component has ever
                  requested focus, and this is a focusable Window, then this Window&apos;s
                  initial focusable Component is returned. If no child Component has ever
                  requested focus, and this is a non-focusable Window, null is returned.                
                <return>
                    the child Component that will receive focus when this Window is
                      focused                    
                </return>
                <see>
                    #getFocusOwner                    
                </see>
                <see>
                    #isFocused                    
                </see>
                <see>
                    #isFocusableWindow                    
                </see>
                <since>
                    1.4                    
                </since>
            </javadoc>
            <method name="getMostRecentFocusOwner" type="Component" line="2302">
                <scope line="2303"/>
                <scope line="2305">
                    <declaration name="mostRecent" type="Component" line="2306"/>
                    <scope line="2308"/>
                    <scope line="2310"/>
                </scope>
            </method>
            <javadoc line="2318">
                Returns whether this Window is active. Only a Frame or a Dialog may be
                  active. The native windowing system may denote the active Window or its
                  children with special decorations, such as a highlighted title bar. The
                  active Window is always either the focused Window, or the first Frame or
                  Dialog that is an owner of the focused Window.                
                <return>
                    whether this is the active Window.                    
                </return>
                <see>
                    #isFocused                    
                </see>
                <since>
                    1.4                    
                </since>
            </javadoc>
            <method name="isActive" type="boolean" line="2329"/>
            <javadoc line="2334">
                Returns whether this Window is focused. If there exists a focus owner,
                  the focused Window is the Window that is, or contains, that focus owner.
                  If there is no focus owner, then no Window is focused.
                  &lt;p&gt;
                  If the focused Window is a Frame or a Dialog it is also the active
                  Window. Otherwise, the active Window is the first Frame or Dialog that
                  is an owner of the focused Window.                
                <return>
                    whether this is the focused Window.                    
                </return>
                <see>
                    #isActive                    
                </see>
                <since>
                    1.4                    
                </since>
            </javadoc>
            <method name="isFocused" type="boolean" line="2347"/>
            <javadoc line="2352">
                Gets a focus traversal key for this Window. (See &lt;code&gt;
                  setFocusTraversalKeys&lt;/code&gt; for a full description of each key.)
                  &lt;p&gt;
                  If the traversal key has not been explicitly set for this Window,
                  then this Window&apos;s parent&apos;s traversal key is returned. If the
                  traversal key has not been explicitly set for any of this Window&apos;s
                  ancestors, then the current KeyboardFocusManager&apos;s default traversal key
                  is returned.                
                <param>
                    id one of KeyboardFocusManager.FORWARD_TRAVERSAL_KEYS,
                      KeyboardFocusManager.BACKWARD_TRAVERSAL_KEYS,
                      KeyboardFocusManager.UP_CYCLE_TRAVERSAL_KEYS, or
                      KeyboardFocusManager.DOWN_CYCLE_TRAVERSAL_KEYS                    
                </param>
                <return>
                    the AWTKeyStroke for the specified key                    
                </return>
                <see>
                    Container#setFocusTraversalKeys                    
                </see>
                <see>
                    KeyboardFocusManager#FORWARD_TRAVERSAL_KEYS                    
                </see>
                <see>
                    KeyboardFocusManager#BACKWARD_TRAVERSAL_KEYS                    
                </see>
                <see>
                    KeyboardFocusManager#UP_CYCLE_TRAVERSAL_KEYS                    
                </see>
                <see>
                    KeyboardFocusManager#DOWN_CYCLE_TRAVERSAL_KEYS                    
                </see>
                <throws>
                    IllegalArgumentException if id is not one of
                      KeyboardFocusManager.FORWARD_TRAVERSAL_KEYS,
                      KeyboardFocusManager.BACKWARD_TRAVERSAL_KEYS,
                      KeyboardFocusManager.UP_CYCLE_TRAVERSAL_KEYS, or
                      KeyboardFocusManager.DOWN_CYCLE_TRAVERSAL_KEYS                    
                </throws>
                <since>
                    1.4                    
                </since>
            </javadoc>
            <method name="getFocusTraversalKeys" type="Set<AWTKeyStroke>" line="2379">
                <params>
                    <param name="id" type="int"/>
                </params>
                <comment line="2384">
                    Okay to return Set directly because it is an unmodifiable view                    
                </comment>
                <scope line="2380"/>
                <declaration name="keystrokes" type="Set" line="2385"/>
                <scope line="2389"/>
                <scope line="2391"/>
            </method>
            <javadoc line="2397">
                Does nothing because Windows must always be roots of a focus traversal
                  cycle. The passed-in value is ignored.                
                <param>
                    focusCycleRoot this value is ignored                    
                </param>
                <see>
                    #isFocusCycleRoot                    
                </see>
                <see>
                    Container#setFocusTraversalPolicy                    
                </see>
                <see>
                    Container#getFocusTraversalPolicy                    
                </see>
                <since>
                    1.4                    
                </since>
            </javadoc>
            <method name="setFocusCycleRoot" type="void" line="2407">
                <params>
                    <param name="focusCycleRoot" type="boolean"/>
                </params>
            </method>
            <javadoc line="2410">
                Always returns &lt;code&gt;true&lt;/code&gt; because all Windows must be roots of a
                  focus traversal cycle.                
                <return>
                    <code>true</code>                    
                </return>
                <see>
                    #setFocusCycleRoot                    
                </see>
                <see>
                    Container#setFocusTraversalPolicy                    
                </see>
                <see>
                    Container#getFocusTraversalPolicy                    
                </see>
                <since>
                    1.4                    
                </since>
            </javadoc>
            <method name="isFocusCycleRoot" type="boolean" line="2420"/>
            <javadoc line="2424">
                Always returns &lt;code&gt;null&lt;/code&gt; because Windows have no ancestors; they
                  represent the top of the Component hierarchy.                
                <return>
                    <code>null</code>                    
                </return>
                <see>
                    Container#isFocusCycleRoot()                    
                </see>
                <since>
                    1.4                    
                </since>
            </javadoc>
            <method name="getFocusCycleRootAncestor" type="Container" line="2432"/>
            <javadoc line="2436">
                Returns whether this Window can become the focused Window, that is,
                  whether this Window or any of its subcomponents can become the focus
                  owner. For a Frame or Dialog to be focusable, its focusable Window state
                  must be set to &lt;code&gt;true&lt;/code&gt;. For a Window which is not a Frame or
                  Dialog to be focusable, its focusable Window state must be set to
                  &lt;code&gt;true&lt;/code&gt;, its nearest owning Frame or Dialog must be
                  showing on the screen, and it must contain at least one Component in
                  its focus traversal cycle. If any of these conditions is not met, then
                  neither this Window nor any of its subcomponents can become the focus
                  owner.                
                <return>
                    <code>true</code> if this Window can be the focused Window;
                      <code>false</code> otherwise                    
                </return>
                <see>
                    #getFocusableWindowState                    
                </see>
                <see>
                    #setFocusableWindowState                    
                </see>
                <see>
                    #isShowing                    
                </see>
                <see>
                    Component#isFocusable                    
                </see>
                <since>
                    1.4                    
                </since>
            </javadoc>
            <method name="isFocusableWindow" type="boolean" line="2456">
                <comment line="2457">
                    If a Window/Frame/Dialog was made non-focusable, then it is always                    
                </comment>
                <comment line="2458">
                    non-focusable.                    
                </comment>
                <comment line="2463">
                    All other tests apply only to Windows.                    
                </comment>
                <comment line="2468">
                    A Window must have at least one Component in its root focus                    
                </comment>
                <comment line="2469">
                    traversal cycle to be focusable.                    
                </comment>
                <comment line="2474">
                    A Window&apos;s nearest owning Frame or Dialog must be showing on the                    
                </comment>
                <comment line="2475">
                    screen.                    
                </comment>
                <scope line="2459"/>
                <scope line="2464"/>
                <scope line="2470"/>
                <scope line="2478">
                    <scope line="2479"/>
                </scope>
            </method>
            <javadoc line="2487">
                Returns whether this Window can become the focused Window if it meets
                  the other requirements outlined in &lt;code&gt;isFocusableWindow&lt;/code&gt;. If
                  this method returns &lt;code&gt;false&lt;/code&gt;, then
                  &lt;code&gt;isFocusableWindow&lt;/code&gt; will return &lt;code&gt;false&lt;/code&gt; as well.
                  If this method returns &lt;code&gt;true&lt;/code&gt;, then
                  &lt;code&gt;isFocusableWindow&lt;/code&gt; may return &lt;code&gt;true&lt;/code&gt; or
                  &lt;code&gt;false&lt;/code&gt; depending upon the other requirements which must be
                  met in order for a Window to be focusable.
                  &lt;p&gt;
                  By default, all Windows have a focusable Window state of
                  &lt;code&gt;true&lt;/code&gt;.                
                <return>
                    whether this Window can be the focused Window                    
                </return>
                <see>
                    #isFocusableWindow                    
                </see>
                <see>
                    #setFocusableWindowState                    
                </see>
                <see>
                    #isShowing                    
                </see>
                <see>
                    Component#setFocusable                    
                </see>
                <since>
                    1.4                    
                </since>
            </javadoc>
            <method name="getFocusableWindowState" type="boolean" line="2507"/>
            <javadoc line="2511">
                Sets whether this Window can become the focused Window if it meets
                  the other requirements outlined in &lt;code&gt;isFocusableWindow&lt;/code&gt;. If
                  this Window&apos;s focusable Window state is set to &lt;code&gt;false&lt;/code&gt;, then
                  &lt;code&gt;isFocusableWindow&lt;/code&gt; will return &lt;code&gt;false&lt;/code&gt;. If this
                  Window&apos;s focusable Window state is set to &lt;code&gt;true&lt;/code&gt;, then
                  &lt;code&gt;isFocusableWindow&lt;/code&gt; may return &lt;code&gt;true&lt;/code&gt; or
                  &lt;code&gt;false&lt;/code&gt; depending upon the other requirements which must be
                  met in order for a Window to be focusable.
                  &lt;p&gt;
                  Setting a Window&apos;s focusability state to &lt;code&gt;false&lt;/code&gt; is the
                  standard mechanism for an application to identify to the AWT a Window
                  which will be used as a floating palette or toolbar, and thus should be
                  a non-focusable Window.
                  Setting the focusability state on a visible &lt;code&gt;Window&lt;/code&gt;
                  can have a delayed effect on some platforms &amp;#151; the actual
                  change may happen only when the &lt;code&gt;Window&lt;/code&gt; becomes
                  hidden and then visible again.  To ensure consistent behavior
                  across platforms, set the &lt;code&gt;Window&lt;/code&gt;&apos;s focusable state
                  when the &lt;code&gt;Window&lt;/code&gt; is invisible and then show it.                
                <param>
                    focusableWindowState whether this Window can be the focused
                      Window                    
                </param>
                <see>
                    #isFocusableWindow                    
                </see>
                <see>
                    #getFocusableWindowState                    
                </see>
                <see>
                    #isShowing                    
                </see>
                <see>
                    Component#setFocusable                    
                </see>
                <since>
                    1.4                    
                </since>
            </javadoc>
            <method name="setFocusableWindowState" type="void" line="2541">
                <params>
                    <param name="focusableWindowState" type="boolean"/>
                </params>
                <declaration name="oldFocusableWindowState" type="boolean" line="2542"/>
                <scope line="2543"/>
                <declaration name="peer" type="WindowPeer" line="2547"/>
                <scope line="2548"/>
                <scope line="2553">
                    <scope line="2557">
                        <declaration name="toFocus" type="Component" line="2558"/>
                        <scope line="2560"/>
                    </scope>
                </scope>
            </method>
            <javadoc line="2569">
                Sets whether this window should receive focus on
                  subsequently being shown (with a call to {@link #setVisible setVisible(true)}),
                  or being moved to the front (with a call to {@link #toFront}).
                  &lt;p&gt;
                  Note that {@link #setVisible setVisible(true)} may be called indirectly
                  (e.g. when showing an owner of the window makes the window to be shown).{@link #toFront} may also be called indirectly (e.g. when{@link #setVisible setVisible(true)} is called on already visible window).
                  In all such cases this property takes effect as well.
                  &lt;p&gt;
                  The value of the property is not inherited by owned windows.                
                <param>
                    autoRequestFocus whether this window should be focused on
                      subsequently being shown or being moved to the front                    
                </param>
                <see>
                    #isAutoRequestFocus                    
                </see>
                <see>
                    #isFocusableWindow                    
                </see>
                <see>
                    #setVisible                    
                </see>
                <see>
                    #toFront                    
                </see>
                <since>
                    1.7                    
                </since>
            </javadoc>
            <method name="setAutoRequestFocus" type="void" line="2590">
                <params>
                    <param name="autoRequestFocus" type="boolean"/>
                </params>
            </method>
            <javadoc line="2594">
                Returns whether this window should receive focus on subsequently being shown
                  (with a call to {@link #setVisible setVisible(true)}), or being moved to the front
                  (with a call to {@link #toFront}).
                  &lt;p&gt;
                  By default, the window has {@code autoRequestFocus} value of {@code true}.                
                <return>
                    {@code autoRequestFocus} value                    
                </return>
                <see>
                    #setAutoRequestFocus                    
                </see>
                <since>
                    1.7                    
                </since>
            </javadoc>
            <method name="isAutoRequestFocus" type="boolean" line="2605"/>
            <javadoc line="2609">
                Adds a PropertyChangeListener to the listener list. The listener is
                  registered for all bound properties of this class, including the
                  following:
                  &lt;ul&gt;
                  &lt;li&gt;this Window&apos;s font (&quot;font&quot;)&lt;/li&gt;
                  &lt;li&gt;this Window&apos;s background color (&quot;background&quot;)&lt;/li&gt;
                  &lt;li&gt;this Window&apos;s foreground color (&quot;foreground&quot;)&lt;/li&gt;
                  &lt;li&gt;this Window&apos;s focusability (&quot;focusable&quot;)&lt;/li&gt;
                  &lt;li&gt;this Window&apos;s focus traversal keys enabled state
                  (&quot;focusTraversalKeysEnabled&quot;)&lt;/li&gt;
                  &lt;li&gt;this Window&apos;s Set of FORWARD_TRAVERSAL_KEYS
                  (&quot;forwardFocusTraversalKeys&quot;)&lt;/li&gt;
                  &lt;li&gt;this Window&apos;s Set of BACKWARD_TRAVERSAL_KEYS
                  (&quot;backwardFocusTraversalKeys&quot;)&lt;/li&gt;
                  &lt;li&gt;this Window&apos;s Set of UP_CYCLE_TRAVERSAL_KEYS
                  (&quot;upCycleFocusTraversalKeys&quot;)&lt;/li&gt;
                  &lt;li&gt;this Window&apos;s Set of DOWN_CYCLE_TRAVERSAL_KEYS
                  (&quot;downCycleFocusTraversalKeys&quot;)&lt;/li&gt;
                  &lt;li&gt;this Window&apos;s focus traversal policy (&quot;focusTraversalPolicy&quot;)
                  &lt;/li&gt;
                  &lt;li&gt;this Window&apos;s focusable Window state (&quot;focusableWindowState&quot;)
                  &lt;/li&gt;
                  &lt;li&gt;this Window&apos;s always-on-top state(&quot;alwaysOnTop&quot;)&lt;/li&gt;
                  &lt;/ul&gt;
                  Note that if this Window is inheriting a bound property, then no
                  event will be fired in response to a change in the inherited property.
                  &lt;p&gt;
                  If listener is null, no exception is thrown and no action is performed.                
                <param>
                    listener  the PropertyChangeListener to be added                    
                </param>
                <see>
                    Component#removePropertyChangeListener                    
                </see>
                <see>
                    #addPropertyChangeListener(java.lang.String,java.beans.PropertyChangeListener)                    
                </see>
            </javadoc>
            <method name="addPropertyChangeListener" type="void" line="2644">
                <params>
                    <param name="listener" type="PropertyChangeListener"/>
                </params>
            </method>
            <javadoc line="2648">
                Adds a PropertyChangeListener to the listener list for a specific
                  property. The specified property may be user-defined, or one of the
                  following:
                  &lt;ul&gt;
                  &lt;li&gt;this Window&apos;s font (&quot;font&quot;)&lt;/li&gt;
                  &lt;li&gt;this Window&apos;s background color (&quot;background&quot;)&lt;/li&gt;
                  &lt;li&gt;this Window&apos;s foreground color (&quot;foreground&quot;)&lt;/li&gt;
                  &lt;li&gt;this Window&apos;s focusability (&quot;focusable&quot;)&lt;/li&gt;
                  &lt;li&gt;this Window&apos;s focus traversal keys enabled state
                  (&quot;focusTraversalKeysEnabled&quot;)&lt;/li&gt;
                  &lt;li&gt;this Window&apos;s Set of FORWARD_TRAVERSAL_KEYS
                  (&quot;forwardFocusTraversalKeys&quot;)&lt;/li&gt;
                  &lt;li&gt;this Window&apos;s Set of BACKWARD_TRAVERSAL_KEYS
                  (&quot;backwardFocusTraversalKeys&quot;)&lt;/li&gt;
                  &lt;li&gt;this Window&apos;s Set of UP_CYCLE_TRAVERSAL_KEYS
                  (&quot;upCycleFocusTraversalKeys&quot;)&lt;/li&gt;
                  &lt;li&gt;this Window&apos;s Set of DOWN_CYCLE_TRAVERSAL_KEYS
                  (&quot;downCycleFocusTraversalKeys&quot;)&lt;/li&gt;
                  &lt;li&gt;this Window&apos;s focus traversal policy (&quot;focusTraversalPolicy&quot;)
                  &lt;/li&gt;
                  &lt;li&gt;this Window&apos;s focusable Window state (&quot;focusableWindowState&quot;)
                  &lt;/li&gt;
                  &lt;li&gt;this Window&apos;s always-on-top state(&quot;alwaysOnTop&quot;)&lt;/li&gt;
                  &lt;/ul&gt;
                  Note that if this Window is inheriting a bound property, then no
                  event will be fired in response to a change in the inherited property.
                  &lt;p&gt;
                  If listener is null, no exception is thrown and no action is performed.                
                <param>
                    propertyName one of the property names listed above                    
                </param>
                <param>
                    listener the PropertyChangeListener to be added                    
                </param>
                <see>
                    #addPropertyChangeListener(java.beans.PropertyChangeListener)                    
                </see>
                <see>
                    Component#removePropertyChangeListener                    
                </see>
            </javadoc>
            <method name="addPropertyChangeListener" type="void" line="2685">
                <params>
                    <param name="propertyName" type="String"/>
                    <param name="listener" type="PropertyChangeListener"/>
                </params>
            </method>
            <javadoc line="2689">
                Indicates if this container is a validate root.
                  &lt;p&gt;{@code Window} objects are the validate roots, and, therefore, they
                  override this method to return {@code true}.                
                <return>
                    {@code true}                    
                </return>
                <since>
                    1.7                    
                </since>
                <see>
                    java.awt.Container#isValidateRoot                    
                </see>
            </javadoc>
            <method name="isValidateRoot" type="boolean" line="2700"/>
            <javadoc line="2704">
                Dispatches an event to this window or one of its sub components.                
                <param>
                    e the event                    
                </param>
            </javadoc>
            <method name="dispatchEventImpl" type="void" line="2708">
                <params>
                    <param name="e" type="AWTEvent"/>
                </params>
                <scope line="2709"/>
            </method>
            <javadoc line="2716">
                @deprecated As of JDK version 1.1
                  replaced by &lt;code&gt;dispatchEvent(AWTEvent)&lt;/code&gt;.                
            </javadoc>
            <method name="postEvent" type="boolean" line="2721">
                <params>
                    <param name="e" type="Event"/>
                </params>
                <scope line="2722"/>
            </method>
            <javadoc line="2729">
                Checks if this Window is showing on screen.                
                <see>
                    Component#setVisible                    
                </see>
            </javadoc>
            <method name="isShowing" type="boolean" line="2733"/>
            <javadoc line="2737">
                @deprecated As of J2SE 1.4, replaced by{@link Component#applyComponentOrientation Component.applyComponentOrientation}.                
            </javadoc>
            <method name="applyResourceBundle" type="void" line="2742">
                <params>
                    <param name="rb" type="ResourceBundle"/>
                </params>
            </method>
            <javadoc line="2746">
                @deprecated As of J2SE 1.4, replaced by{@link Component#applyComponentOrientation Component.applyComponentOrientation}.                
            </javadoc>
            <method name="applyResourceBundle" type="void" line="2751">
                <params>
                    <param name="rbName" type="String"/>
                </params>
            </method>
            <method name="addOwnedWindow" type="void" line="2758">
                <params>
                    <param name="weakWindow" type="WeakReference"/>
                </params>
                <comment line="2761">
                    this if statement should really be an assert, but we don&apos;t                    
                </comment>
                <comment line="2762">
                    have asserts...                    
                </comment>
                <scope line="2759">
                    <scope line="2760">
                        <scope line="2763"/>
                    </scope>
                </scope>
            </method>
            <method name="removeOwnedWindow" type="void" line="2770">
                <params>
                    <param name="weakWindow" type="WeakReference"/>
                </params>
                <comment line="2772">
                    synchronized block not required since removeElement is                    
                </comment>
                <comment line="2773">
                    already synchronized                    
                </comment>
                <scope line="2771"/>
            </method>
            <method name="connectOwnedWindow" type="void" line="2778">
                <params>
                    <param name="child" type="Window"/>
                </params>
            </method>
            <method name="addToWindowList" type="void" line="2783">
                <scope line="2784">
                    <declaration name="windowList" type="Vector&lt;WeakReference&lt;Window&gt;&gt;" line="2785"/>
                    <scope line="2786"/>
                </scope>
            </method>
            <method name="removeFromWindowList" type="void" line="2794">
                <params>
                    <param name="context" type="AppContext"/>
                    <param name="weakThis" type="WeakReference"/>
                </params>
                <scope line="2795">
                    <declaration name="windowList" type="Vector&lt;WeakReference&lt;Window&gt;&gt;" line="2796"/>
                    <scope line="2797"/>
                </scope>
            </method>
            <method name="removeFromWindowList" type="void" line="2803"/>
            <declaration name="type" type="Type" line="2807"/>
            <javadoc line="2807">
                Window type.
                  Synchronization: ObjectLock                
            </javadoc>
            <javadoc line="2814">
                Sets the type of the window.
                  This method can only be called while the window is not displayable.                
                <throws>
                    IllegalComponentStateException if the window
                      is displayable.                    
                </throws>
                <throws>
                    IllegalArgumentException if the type is {@code null}                    
                </throws>
                <see>
                    Component#isDisplayable                    
                </see>
                <see>
                    #getType                    
                </see>
                <since>
                    1.7                    
                </since>
            </javadoc>
            <method name="setType" type="void" line="2826">
                <params>
                    <param name="type" type="Type"/>
                </params>
                <scope line="2827"/>
                <scope line="2830">
                    <scope line="2831"/>
                    <scope line="2835"/>
                </scope>
            </method>
            <javadoc line="2841">
                Returns the type of the window.                
                <see>
                    #setType                    
                </see>
                <since>
                    1.7                    
                </since>
            </javadoc>
            <method name="getType" type="Type" line="2847">
                <scope line="2848"/>
            </method>
            <declaration name="windowSerializedDataVersion" type="int" line="2853"/>
            <javadoc line="2853">
                The window serialized data version.                
                <serial>
                                        
                </serial>
            </javadoc>
            <javadoc line="2860">
                Writes default serializable fields to stream.  Writes
                  a list of serializable &lt;code&gt;WindowListener&lt;/code&gt;s and
                  &lt;code&gt;WindowFocusListener&lt;/code&gt;s as optional data.
                  Writes a list of child windows as optional data.
                  Writes a list of icon images as optional data                
                <param>
                    s the <code>ObjectOutputStream</code> to write                    
                </param>
                <serialData>
                    <code>null</code> terminated sequence of
                      0 or more pairs; the pair consists of a <code>String</code>
                      and and <code>Object</code>; the <code>String</code>
                      indicates the type of object and is one of the following:
                      <code>windowListenerK</code> indicating a
                      <code>WindowListener</code> object;
                      <code>windowFocusWindowK</code> indicating a
                      <code>WindowFocusListener</code> object;
                      <code>ownedWindowK</code> indicating a child
                      <code>Window</code> object                    
                </serialData>
                <see>
                    AWTEventMulticaster#save(java.io.ObjectOutputStream,java.lang.String,java.util.EventListener)                    
                </see>
                <see>
                    Component#windowListenerK                    
                </see>
                <see>
                    Component#windowFocusListenerK                    
                </see>
                <see>
                    Component#ownedWindowK                    
                </see>
                <see>
                    #readObject(ObjectInputStream)                    
                </see>
            </javadoc>
            <method name="writeObject" type="void" line="2885">
                <params>
                    <param name="s" type="ObjectOutputStream"/>
                </params>
                <comment line="2887">
                    Update old focusMgr fields so that our object stream can be read                    
                </comment>
                <comment line="2888">
                    by previous releases                    
                </comment>
                <comment line="2895">
                    Clear fields so that we don&apos;t keep extra references around                    
                </comment>
                <comment line="2916">
                    write icon array                    
                </comment>
                <scope line="2886"/>
                <scope line="2905">
                    <scope line="2906">
                        <declaration name="child" type="Window" line="2907"/>
                        <scope line="2908"/>
                    </scope>
                </scope>
                <scope line="2917">
                    <scope line="2918">
                        <scope line="2919"/>
                    </scope>
                </scope>
            </method>
            <method name="initDeserializedWindow" type="void" line="2931">
                <comment line="2935">
                    Deserialized Windows are not yet visible.                    
                </comment>
            </method>
            <method name="deserializeResources" type="void" line="2948">
                <params>
                    <param name="s" type="ObjectInputStream"/>
                </params>
                <comment line="2952">
                    Translate old-style focus tracking to new model. For 1.4 and                    
                </comment>
                <comment line="2953">
                    later releases, we&apos;ll rely on the Window&apos;s initial focusable                    
                </comment>
                <comment line="2954">
                    Component.                    
                </comment>
                <comment line="2962">
                    This field is non-transient and relies on default serialization.                    
                </comment>
                <comment line="2963">
                    However, the default value is insufficient, so we need to set                    
                </comment>
                <comment line="2964">
                    it explicitly for object data streams prior to 1.4.                    
                </comment>
                <comment line="2980">
                    skip value for unrecognized key                    
                </comment>
                <comment line="2991">
                    skip value for unrecognized key                    
                </comment>
                <comment line="2995">
                    read icons                    
                </comment>
                <comment line="2996">
                    Throws OptionalDataException                    
                </comment>
                <comment line="2997">
                    for pre1.6 objects.                    
                </comment>
                <comment line="2998">
                    Frame.readObject() assumes                    
                </comment>
                <comment line="2999">
                    pre1.6 version if icons is null.                    
                </comment>
                <comment line="3008">
                    1.1 serialized form                    
                </comment>
                <comment line="3009">
                    ownedWindowList will be updated by Frame.readObject                    
                </comment>
                <scope line="2951">
                    <scope line="2955">
                        <scope line="2956"/>
                    </scope>
                </scope>
                <declaration name="keyOrNull" type="Object" line="2970"/>
                <scope line="2971">
                    <declaration name="key" type="String" line="2972"/>
                    <scope line="2974"/>
                    <scope line="2976"/>
                    <scope line="2978"/>
                </scope>
                <scope line="2984">
                    <scope line="2985">
                        <declaration name="key" type="String" line="2986"/>
                    </scope>
                    <declaration name="obj" type="Object" line="2996"/>
                    <scope line="3000">
                        <scope line="3001"/>
                    </scope>
                </scope>
                <scope line="3007"/>
            </method>
            <javadoc line="3014">
                Reads the &lt;code&gt;ObjectInputStream&lt;/code&gt; and an optional
                  list of listeners to receive various events fired by
                  the component; also reads a list of
                  (possibly &lt;code&gt;null&lt;/code&gt;) child windows.
                  Unrecognized keys or values will be ignored.                
                <param>
                    s the <code>ObjectInputStream</code> to read                    
                </param>
                <exception>
                    HeadlessException if
                      <code>GraphicsEnvironment.isHeadless</code> returns
                      <code>true</code>                    
                </exception>
                <see>
                    java.awt.GraphicsEnvironment#isHeadless                    
                </see>
                <see>
                    #writeObject                    
                </see>
            </javadoc>
            <method name="readObject" type="void" line="3030">
                <params>
                    <param name="s" type="ObjectInputStream"/>
                </params>
                <comment line="3040">
                    Note: 1.4 (or later) doesn&apos;t use focusMgr                    
                </comment>
                <comment line="3044">
                    since 6.0                    
                </comment>
                <comment line="3047">
                    since 1.5; subject to permission check                    
                </comment>
                <declaration name="f" type="ObjectInputStream.GetField" line="3033"/>
                <declaration name="et" type="Dialog.ModalExclusionType" line="3042"/>
                <declaration name="aot" type="boolean" line="3045"/>
                <scope line="3046"/>
            </method>
            <javadoc line="3067">
                Gets the AccessibleContext associated with this Window.
                  For windows, the AccessibleContext takes the form of an
                  AccessibleAWTWindow.
                  A new AccessibleAWTWindow instance is created if necessary.                
                <return>
                    an AccessibleAWTWindow that serves as the
                      AccessibleContext of this Window                    
                </return>
                <since>
                    1.3                    
                </since>
            </javadoc>
            <method name="getAccessibleContext" type="AccessibleContext" line="3077">
                <scope line="3078"/>
            </method>
            <class name="AccessibleAWTWindow" line="3084">
                <extends class="AccessibleAWTContainer"/>
                <comment line="3093">
                    JDK 1.3 serialVersionUID                    
                </comment>
                <javadoc line="3084">
                    This class implements accessibility support for the
                      &lt;code&gt;Window&lt;/code&gt; class.  It provides an implementation of the
                      Java Accessibility API appropriate to window user-interface elements.                    
                    <since>
                        1.3                        
                    </since>
                </javadoc>
                <declaration name="serialVersionUID" type="long" line="3095"/>
                <javadoc line="3097">
                    Get the role of this object.                    
                    <return>
                        an instance of AccessibleRole describing the role of the
                          object                        
                    </return>
                    <see>
                        javax.accessibility.AccessibleRole                        
                    </see>
                </javadoc>
                <method name="getAccessibleRole" type="AccessibleRole" line="3104"/>
                <javadoc line="3108">
                    Get the state of this object.                    
                    <return>
                        an instance of AccessibleStateSet containing the current
                          state set of the object                        
                    </return>
                    <see>
                        javax.accessibility.AccessibleState                        
                    </see>
                </javadoc>
                <method name="getAccessibleStateSet" type="AccessibleStateSet" line="3115">
                    <declaration name="states" type="AccessibleStateSet" line="3116"/>
                    <scope line="3117"/>
                </method>
            </class>
            <method name="setGraphicsConfiguration" type="void" line="3126">
                <params>
                    <param name="gc" type="GraphicsConfiguration"/>
                </params>
                <scope line="3127"/>
                <scope line="3133">
                    <scope line="3135"/>
                </scope>
            </method>
            <javadoc line="3141">
                Sets the location of the window relative to the specified
                  component according to the following scenarios.
                  &lt;p&gt;
                  The target screen mentioned below is a screen to which
                  the window should be placed after the setLocationRelativeTo
                  method is called.
                  &lt;ul&gt;
                  &lt;li&gt;If the component is {@code null}, or the {@codeGraphicsConfiguration} associated with this component is{@code null}, the window is placed in the center of the
                  screen. The center point can be obtained with the {@link GraphicsEnvironment#getCenterPointGraphicsEnvironment.getCenterPoint} method.
                  &lt;li&gt;If the component is not {@code null}, but it is not
                  currently showing, the window is placed in the center of
                  the target screen defined by the {@codeGraphicsConfiguration} associated with this component.
                  &lt;li&gt;If the component is not {@code null} and is shown on
                  the screen, then the window is located in such a way that
                  the center of the window coincides with the center of the
                  component.
                  &lt;/ul&gt;
                  &lt;p&gt;
                  If the screens configuration does not allow the window to
                  be moved from one screen to another, then the window is
                  only placed at the location determined according to the
                  above conditions and its {@code GraphicsConfiguration} is
                  not changed.
                  &lt;p&gt;
                  &lt;b&gt;Note&lt;/b&gt;: If the lower edge of the window is out of the screen,
                  then the window is placed to the side of the &lt;code&gt;Component&lt;/code&gt;
                  that is closest to the center of the screen. So if the
                  component is on the right part of the screen, the window
                  is placed to its left, and vice versa.
                  &lt;p&gt;
                  If after the window location has been calculated, the upper,
                  left, or right edge of the window is out of the screen,
                  then the window is located in such a way that the upper,
                  left, or right edge of the window coincides with the
                  corresponding edge of the screen. If both left and right
                  edges of the window are out of the screen, the window is
                  placed at the left side of the screen. The similar placement
                  will occur if both top and bottom edges are out of the screen.
                  In that case, the window is placed at the top side of the screen.
                  &lt;p&gt;
                  The method changes the geometry-related data. Therefore,
                  the native windowing system may ignore such requests, or it may modify
                  the requested data, so that the {@code Window} object is placed and sized
                  in a way that corresponds closely to the desktop settings.                
                <param>
                    c  the component in relation to which the window's location
                      is determined                    
                </param>
                <see>
                    java.awt.GraphicsEnvironment#getCenterPoint                    
                </see>
                <since>
                    1.4                    
                </since>
            </javadoc>
            <method name="setLocationRelativeTo" type="void" line="3197">
                <params>
                    <param name="c" type="Component"/>
                </params>
                <comment line="3198">
                    target location                    
                </comment>
                <comment line="3200">
                    target GC                    
                </comment>
                <comment line="3206">
                    search a top-level of c                    
                </comment>
                <comment line="3228">
                    Adjust for bottom edge being offscreen                    
                </comment>
                <comment line="3239">
                    Avoid being placed off the edge of the screen:                    
                </comment>
                <comment line="3240">
                    bottom                    
                </comment>
                <comment line="3244">
                    top                    
                </comment>
                <comment line="3248">
                    right                    
                </comment>
                <comment line="3252">
                    left                    
                </comment>
                <declaration name="dx" type="int" line="3199"/>
                <declaration name="gc" type="GraphicsConfiguration" line="3201"/>
                <declaration name="gcBounds" type="Rectangle" line="3202"/>
                <declaration name="windowSize" type="Dimension" line="3204"/>
                <declaration name="componentWindow" type="Window" line="3207"/>
                <scope line="3208">
                    <declaration name="ge" type="GraphicsEnvironment" line="3209"/>
                    <declaration name="centerPoint" type="Point" line="3212"/>
                </scope>
                <scope line="3215"/>
                <scope line="3220">
                    <declaration name="compSize" type="Dimension" line="3223"/>
                    <declaration name="compLocation" type="Point" line="3224"/>
                    <scope line="3229">
                        <scope line="3231"/>
                        <scope line="3233"/>
                    </scope>
                </scope>
                <scope line="3241"/>
                <scope line="3245"/>
                <scope line="3249"/>
                <scope line="3253"/>
            </method>
            <javadoc line="3260">
                Overridden from Component.  Top-level Windows should not propagate a
                  MouseWheelEvent beyond themselves into their owning Windows.                
            </javadoc>
            <method name="deliverMouseWheelToAncestor" type="void" line="3264">
                <params>
                    <param name="e" type="MouseWheelEvent"/>
                </params>
            </method>
            <javadoc line="3266">
                Overridden from Component.  Top-level Windows don&apos;t dispatch to ancestors                
            </javadoc>
            <method name="dispatchMouseWheelToAncestor" type="boolean" line="3269">
                <params>
                    <param name="e" type="MouseWheelEvent"/>
                </params>
            </method>
            <javadoc line="3271">
                Creates a new strategy for multi-buffering on this component.
                  Multi-buffering is useful for rendering performance.  This method
                  attempts to create the best strategy available with the number of
                  buffers supplied.  It will always create a &lt;code&gt;BufferStrategy&lt;/code&gt;
                  with that number of buffers.
                  A page-flipping strategy is attempted first, then a blitting strategy
                  using accelerated buffers.  Finally, an unaccelerated blitting
                  strategy is used.
                  &lt;p&gt;
                  Each time this method is called,
                  the existing buffer strategy for this component is discarded.                
                <param>
                    numBuffers number of buffers to create                    
                </param>
                <exception>
                    IllegalArgumentException if numBuffers is less than 1.                    
                </exception>
                <exception>
                    IllegalStateException if the component is not displayable                    
                </exception>
                <see>
                    #isDisplayable                    
                </see>
                <see>
                    #getBufferStrategy                    
                </see>
                <since>
                    1.4                    
                </since>
            </javadoc>
            <method name="createBufferStrategy" type="void" line="3290">
                <params>
                    <param name="numBuffers" type="int"/>
                </params>
            </method>
            <javadoc line="3294">
                Creates a new strategy for multi-buffering on this component with the
                  required buffer capabilities.  This is useful, for example, if only
                  accelerated memory or page flipping is desired (as specified by the
                  buffer capabilities).
                  &lt;p&gt;
                  Each time this method
                  is called, the existing buffer strategy for this component is discarded.                
                <param>
                    numBuffers number of buffers to create, including the front buffer                    
                </param>
                <param>
                    caps the required capabilities for creating the buffer strategy;
                      cannot be <code>null</code>                    
                </param>
                <exception>
                    AWTException if the capabilities supplied could not be
                      supported or met; this may happen, for example, if there is not enough
                      accelerated memory currently available, or if page flipping is specified
                      but not possible.                    
                </exception>
                <exception>
                    IllegalArgumentException if numBuffers is less than 1, or if
                      caps is <code>null</code>                    
                </exception>
                <see>
                    #getBufferStrategy                    
                </see>
                <since>
                    1.4                    
                </since>
            </javadoc>
            <method name="createBufferStrategy" type="void" line="3315">
                <params>
                    <param name="numBuffers" type="int"/>
                    <param name="caps" type="BufferCapabilities"/>
                </params>
            </method>
            <javadoc line="3319">
                Returns the &lt;code&gt;BufferStrategy&lt;/code&gt; used by this component.  This
                  method will return null if a &lt;code&gt;BufferStrategy&lt;/code&gt; has not yet
                  been created or has been disposed.                
                <return>
                    the buffer strategy used by this component                    
                </return>
                <see>
                    #createBufferStrategy                    
                </see>
                <since>
                    1.4                    
                </since>
            </javadoc>
            <method name="getBufferStrategy" type="BufferStrategy" line="3328"/>
            <method name="getTemporaryLostComponent" type="Component" line="3332"/>
            <method name="setTemporaryLostComponent" type="Component" line="3335">
                <params>
                    <param name="component" type="Component"/>
                </params>
                <comment line="3337">
                    Check that &quot;component&quot; is an acceptable focus owner and don&apos;t store it otherwise                    
                </comment>
                <comment line="3338">
                    - or later we will have problems with opposite while handling  WINDOW_GAINED_FOCUS                    
                </comment>
                <declaration name="previousComp" type="Component" line="3336"/>
                <scope line="3339"/>
                <scope line="3341"/>
            </method>
            <javadoc line="3347">
                Checks whether this window can contain focus owner.
                  Verifies that it is focusable and as container it can container focus owner.                
                <since>
                    1.5                    
                </since>
            </javadoc>
            <method name="canContainFocusOwner" type="boolean" line="3352">
                <params>
                    <param name="focusOwnerCandidate" type="Component"/>
                </params>
            </method>
            <declaration name="locationByPlatform" type="boolean" line="3356"/>
            <javadoc line="3359">
                Sets whether this Window should appear at the default location for the
                  native windowing system or at the current location (returned by
                  &lt;code&gt;getLocation&lt;/code&gt;) the next time the Window is made visible.
                  This behavior resembles a native window shown without programmatically
                  setting its location.  Most windowing systems cascade windows if their
                  locations are not explicitly set. The actual location is determined once the
                  window is shown on the screen.
                  &lt;p&gt;
                  This behavior can also be enabled by setting the System Property
                  &quot;java.awt.Window.locationByPlatform&quot; to &quot;true&quot;, though calls to this method
                  take precedence.
                  &lt;p&gt;
                  Calls to &lt;code&gt;setVisible&lt;/code&gt;, &lt;code&gt;setLocation&lt;/code&gt; and
                  &lt;code&gt;setBounds&lt;/code&gt; after calling &lt;code&gt;setLocationByPlatform&lt;/code&gt; clear
                  this property of the Window.
                  &lt;p&gt;
                  For example, after the following code is executed:
                  &lt;pre&gt;&lt;blockquote&gt;
                  setLocationByPlatform(true);
                  setVisible(true);
                  boolean flag = isLocationByPlatform();
                  &lt;/blockquote&gt;&lt;/pre&gt;
                  The window will be shown at platform&apos;s default location and
                  &lt;code&gt;flag&lt;/code&gt; will be &lt;code&gt;false&lt;/code&gt;.
                  &lt;p&gt;
                  In the following sample:
                  &lt;pre&gt;&lt;blockquote&gt;
                  setLocationByPlatform(true);
                  setLocation(10, 10);
                  boolean flag = isLocationByPlatform();
                  setVisible(true);
                  &lt;/blockquote&gt;&lt;/pre&gt;
                  The window will be shown at (10, 10) and &lt;code&gt;flag&lt;/code&gt; will be
                  &lt;code&gt;false&lt;/code&gt;.                
                <param>
                    locationByPlatform <code>true</code> if this Window should appear
                      at the default location, <code>false</code> if at the current location                    
                </param>
                <throws>
                    <code>IllegalComponentStateException</code> if the window
                      is showing on screen and locationByPlatform is <code>true</code>.                    
                </throws>
                <see>
                    #setLocation                    
                </see>
                <see>
                    #isShowing                    
                </see>
                <see>
                    #setVisible                    
                </see>
                <see>
                    #isLocationByPlatform                    
                </see>
                <see>
                    java.lang.System#getProperty(String)                    
                </see>
                <since>
                    1.5                    
                </since>
            </javadoc>
            <method name="setLocationByPlatform" type="void" line="3406">
                <params>
                    <param name="locationByPlatform" type="boolean"/>
                </params>
                <scope line="3407">
                    <scope line="3408"/>
                </scope>
            </method>
            <javadoc line="3415">
                Returns &lt;code&gt;true&lt;/code&gt; if this Window will appear at the default location
                  for the native windowing system the next time this Window is made visible.
                  This method always returns &lt;code&gt;false&lt;/code&gt; if the Window is showing on the
                  screen.                
                <return>
                    whether this Window will appear at the default location                    
                </return>
                <see>
                    #setLocationByPlatform                    
                </see>
                <see>
                    #isShowing                    
                </see>
                <since>
                    1.5                    
                </since>
            </javadoc>
            <method name="isLocationByPlatform" type="boolean" line="3426">
                <scope line="3427"/>
            </method>
            <javadoc line="3432">
                {@inheritDoc}&lt;p&gt;
                  The {@code width} or {@code height} values
                  are automatically enlarged if either is less than
                  the minimum size as specified by previous call to{@code setMinimumSize}.
                  &lt;p&gt;
                  The method changes the geometry-related data. Therefore,
                  the native windowing system may ignore such requests, or it may modify
                  the requested data, so that the {@code Window} object is placed and sized
                  in a way that corresponds closely to the desktop settings.                
                <see>
                    #getBounds                    
                </see>
                <see>
                    #setLocation(int,int)                    
                </see>
                <see>
                    #setLocation(Point)                    
                </see>
                <see>
                    #setSize(int,int)                    
                </see>
                <see>
                    #setSize(Dimension)                    
                </see>
                <see>
                    #setMinimumSize                    
                </see>
                <see>
                    #setLocationByPlatform                    
                </see>
                <see>
                    #isLocationByPlatform                    
                </see>
                <since>
                    1.6                    
                </since>
            </javadoc>
            <method name="setBounds" type="void" line="3455">
                <params>
                    <param name="x" type="int"/>
                    <param name="y" type="int"/>
                    <param name="width" type="int"/>
                    <param name="height" type="int"/>
                </params>
                <scope line="3456">
                    <scope line="3459"/>
                </scope>
            </method>
            <javadoc line="3466">
                {@inheritDoc}&lt;p&gt;
                  The {@code r.width} or {@code r.height} values
                  will be automatically enlarged if either is less than
                  the minimum size as specified by previous call to{@code setMinimumSize}.
                  &lt;p&gt;
                  The method changes the geometry-related data. Therefore,
                  the native windowing system may ignore such requests, or it may modify
                  the requested data, so that the {@code Window} object is placed and sized
                  in a way that corresponds closely to the desktop settings.                
                <see>
                    #getBounds                    
                </see>
                <see>
                    #setLocation(int,int)                    
                </see>
                <see>
                    #setLocation(Point)                    
                </see>
                <see>
                    #setSize(int,int)                    
                </see>
                <see>
                    #setSize(Dimension)                    
                </see>
                <see>
                    #setMinimumSize                    
                </see>
                <see>
                    #setLocationByPlatform                    
                </see>
                <see>
                    #isLocationByPlatform                    
                </see>
                <since>
                    1.6                    
                </since>
            </javadoc>
            <method name="setBounds" type="void" line="3489">
                <params>
                    <param name="r" type="Rectangle"/>
                </params>
            </method>
            <javadoc line="3493">
                Determines whether this component will be displayed on the screen.                
                <return>
                    <code>true</code> if the component and all of its ancestors
                      until a toplevel window are visible, <code>false</code> otherwise                    
                </return>
            </javadoc>
            <method name="isRecursivelyVisible" type="boolean" line="3498">
                <comment line="3499">
                    5079694 fix: for a toplevel to be displayed, its parent doesn&apos;t have to be visible.                    
                </comment>
                <comment line="3500">
                    We&apos;re overriding isRecursivelyVisible to implement this policy.                    
                </comment>
            </method>
            <javadoc line="3507">
                Returns the opacity of the window.                
                <return>
                    the opacity of the window                    
                </return>
                <see>
                    Window#setOpacity(float)                    
                </see>
                <see>
                    GraphicsDevice.WindowTranslucency                    
                </see>
                <since>
                    1.7                    
                </since>
            </javadoc>
            <method name="getOpacity" type="float" line="3517">
                <scope line="3518"/>
            </method>
            <javadoc line="3523">
                Sets the opacity of the window.
                  &lt;p&gt;
                  The opacity value is in the range [0..1]. Note that setting the opacity
                  level of 0 may or may not disable the mouse event handling on this
                  window. This is a platform-dependent behavior.
                  &lt;p&gt;
                  The following conditions must be met in order to set the opacity value
                  less than {@code 1.0f}:
                  &lt;ul&gt;
                  &lt;li&gt;The {@link GraphicsDevice.WindowTranslucency#TRANSLUCENT TRANSLUCENT}translucency must be supported by the underlying system
                  &lt;li&gt;The window must be undecorated (see {@link Frame#setUndecorated}and {@link Dialog#setUndecorated})
                  &lt;li&gt;The window must not be in full-screen mode (see {@link GraphicsDevice#setFullScreenWindow(Window)})
                  &lt;/ul&gt;
                  &lt;p&gt;
                  If the requested opacity value is less than {@code 1.0f}, and any of the
                  above conditions are not met, the window opacity will not change,
                  and the {@code IllegalComponentStateException} will be thrown.
                  &lt;p&gt;
                  The translucency levels of individual pixels may also be effected by the
                  alpha component of their color (see {@link Window#setBackground(Color)}) and the
                  current shape of this window (see {@link #setShape(Shape)}).                
                <param>
                    opacity the opacity level to set to the window                    
                </param>
                <throws>
                    IllegalArgumentException if the opacity is out of the range
                      [0..1]                    
                </throws>
                <throws>
                    IllegalComponentStateException if the window is decorated and
                      the opacity is less than {@code 1.0f}                    
                </throws>
                <throws>
                    IllegalComponentStateException if the window is in full screen
                      mode, and the opacity is less than {@code 1.0f}                    
                </throws>
                <throws>
                    UnsupportedOperationException if the {@codeGraphicsDevice.WindowTranslucency#TRANSLUCENT TRANSLUCENT}translucency is not supported and the opacity is less than{@code 1.0f}                    
                </throws>
                <see>
                    Window#getOpacity                    
                </see>
                <see>
                    Window#setBackground(Color)                    
                </see>
                <see>
                    Window#setShape(Shape)                    
                </see>
                <see>
                    Frame#isUndecorated                    
                </see>
                <see>
                    Dialog#isUndecorated                    
                </see>
                <see>
                    GraphicsDevice.WindowTranslucency                    
                </see>
                <see>
                    GraphicsDevice#isWindowTranslucencySupported(GraphicsDevice.WindowTranslucency)                    
                </see>
                <since>
                    1.7                    
                </since>
            </javadoc>
            <method name="setOpacity" type="void" line="3572">
                <params>
                    <param name="opacity" type="float"/>
                </params>
                <scope line="3573">
                    <scope line="3574"/>
                    <scope line="3578">
                        <declaration name="gc" type="GraphicsConfiguration" line="3579"/>
                        <declaration name="gd" type="GraphicsDevice" line="3580"/>
                        <scope line="3581"/>
                        <scope line="3587"/>
                    </scope>
                    <declaration name="peer" type="WindowPeer" line="3593"/>
                    <scope line="3594"/>
                </scope>
            </method>
            <javadoc line="3600">
                Returns the shape of the window.
                  The value returned by this method may not be the same as
                  previously set with {@code setShape(shape)}, but it is guaranteed
                  to represent the same shape.                
                <return>
                    the shape of the window or {@code null} if no
                      shape is specified for the window                    
                </return>
                <see>
                    Window#setShape(Shape)                    
                </see>
                <see>
                    GraphicsDevice.WindowTranslucency                    
                </see>
                <since>
                    1.7                    
                </since>
            </javadoc>
            <method name="getShape" type="Shape" line="3615">
                <scope line="3616"/>
            </method>
            <javadoc line="3621">
                Sets the shape of the window.
                  &lt;p&gt;
                  Setting a shape cuts off some parts of the window. Only the parts that
                  belong to the given {@link Shape} remain visible and clickable. If
                  the shape argument is {@code null}, this method restores the default
                  shape, making the window rectangular on most platforms.
                  &lt;p&gt;
                  The following conditions must be met to set a non-null shape:
                  &lt;ul&gt;
                  &lt;li&gt;The {@link GraphicsDevice.WindowTranslucency#PERPIXEL_TRANSPARENTPERPIXEL_TRANSPARENT} translucency must be supported by the
                  underlying system
                  &lt;li&gt;The window must be undecorated (see {@link Frame#setUndecorated}and {@link Dialog#setUndecorated})
                  &lt;li&gt;The window must not be in full-screen mode (see {@link GraphicsDevice#setFullScreenWindow(Window)})
                  &lt;/ul&gt;
                  &lt;p&gt;
                  If the requested shape is not {@code null}, and any of the above
                  conditions are not met, the shape of this window will not change,
                  and either the {@code UnsupportedOperationException} or {@codeIllegalComponentStateException} will be thrown.
                  &lt;p&gt;
                  The tranlucency levels of individual pixels may also be effected by the
                  alpha component of their color (see {@link Window#setBackground(Color)}) and the
                  opacity value (see {@link #setOpacity(float)}). See {@link GraphicsDevice.WindowTranslucency} for more details.                
                <param>
                    shape the shape to set to the window                    
                </param>
                <throws>
                    IllegalComponentStateException if the shape is not {@codenull} and the window is decorated                    
                </throws>
                <throws>
                    IllegalComponentStateException if the shape is not {@codenull} and the window is in full-screen mode                    
                </throws>
                <throws>
                    UnsupportedOperationException if the shape is not {@codenull} and {@link GraphicsDevice.WindowTranslucency#PERPIXEL_TRANSPARENTPERPIXEL_TRANSPARENT} translucency is not supported                    
                </throws>
                <see>
                    Window#getShape()                    
                </see>
                <see>
                    Window#setBackground(Color)                    
                </see>
                <see>
                    Window#setOpacity(float)                    
                </see>
                <see>
                    Frame#isUndecorated                    
                </see>
                <see>
                    Dialog#isUndecorated                    
                </see>
                <see>
                    GraphicsDevice.WindowTranslucency                    
                </see>
                <see>
                    GraphicsDevice#isWindowTranslucencySupported(GraphicsDevice.WindowTranslucency)                    
                </see>
                <since>
                    1.7                    
                </since>
            </javadoc>
            <method name="setShape" type="void" line="3670">
                <params>
                    <param name="shape" type="Shape"/>
                </params>
                <scope line="3671">
                    <scope line="3672">
                        <declaration name="gc" type="GraphicsConfiguration" line="3673"/>
                        <declaration name="gd" type="GraphicsDevice" line="3674"/>
                        <scope line="3675"/>
                        <scope line="3681"/>
                    </scope>
                    <declaration name="peer" type="WindowPeer" line="3687"/>
                    <scope line="3688"/>
                </scope>
            </method>
            <javadoc line="3694">
                Gets the background color of this window.
                  &lt;p&gt;
                  Note that the alpha component of the returned color indicates whether
                  the window is in the non-opaque (per-pixel translucent) mode.                
                <return>
                    this component's background color                    
                </return>
                <see>
                    Window#setBackground(Color)                    
                </see>
                <see>
                    Window#isOpaque                    
                </see>
                <see>
                    GraphicsDevice.WindowTranslucency                    
                </see>
            </javadoc>
            <method name="getBackground" type="Color" line="3707"/>
            <javadoc line="3711">
                Sets the background color of this window.
                  &lt;p&gt;
                  If the windowing system supports the {@link GraphicsDevice.WindowTranslucency#PERPIXEL_TRANSLUCENT PERPIXEL_TRANSLUCENT}tranclucency, the alpha component of the given background color
                  may effect the mode of operation for this window: it indicates whether
                  this window must be opaque (alpha equals {@code 1.0f}) or per-pixel translucent
                  (alpha is less than {@code 1.0f}). If the given background color is{@code null}, the window is considered completely opaque.
                  &lt;p&gt;
                  All the following conditions must be met to enable the per-pixel
                  transparency mode for this window:
                  &lt;ul&gt;
                  &lt;li&gt;The {@link GraphicsDevice.WindowTranslucency#PERPIXEL_TRANSLUCENTPERPIXEL_TRANSLUCENT} translucency must be supported by the graphics
                  device where this window is located
                  &lt;li&gt;The window must be undecorated (see {@link Frame#setUndecorated}and {@link Dialog#setUndecorated})
                  &lt;li&gt;The window must not be in full-screen mode (see {@link GraphicsDevice#setFullScreenWindow(Window)})
                  &lt;/ul&gt;
                  &lt;p&gt;
                  If the alpha component of the requested background color is less than{@code 1.0f}, and any of the above conditions are not met, the background
                  color of this window will not change, the alpha component of the given
                  background color will not affect the mode of operation for this window,
                  and either the {@code UnsupportedOperationException} or {@codeIllegalComponentStateException} will be thrown.
                  &lt;p&gt;
                  When the window is per-pixel translucent, the drawing sub-system
                  respects the alpha value of each individual pixel. If a pixel gets
                  painted with the alpha color component equal to zero, it becomes
                  visually transparent. If the alpha of the pixel is equal to 1.0f, the
                  pixel is fully opaque. Interim values of the alpha color component make
                  the pixel semi-transparent. In this mode, the background of the window
                  gets painted with the alpha value of the given background color. If the
                  alpha value of the argument of this method is equal to {@code 0}, the
                  background is not painted at all.
                  &lt;p&gt;
                  The actual level of translucency of a given pixel also depends on window
                  opacity (see {@link #setOpacity(float)}), as well as the current shape of
                  this window (see {@link #setShape(Shape)}).
                  &lt;p&gt;
                  Note that painting a pixel with the alpha value of {@code 0} may or may
                  not disable the mouse event handling on this pixel. This is a
                  platform-dependent behavior. To make sure the mouse events do not get
                  dispatched to a particular pixel, the pixel must be excluded from the
                  shape of the window.
                  &lt;p&gt;
                  Enabling the per-pixel translucency mode may change the graphics
                  configuration of this window due to the native platform requirements.                
                <param>
                    bgColor the color to become this window's background color.                    
                </param>
                <throws>
                    IllegalComponentStateException if the alpha value of the given
                      background color is less than {@code 1.0f} and the window is decorated                    
                </throws>
                <throws>
                    IllegalComponentStateException if the alpha value of the given
                      background color is less than {@code 1.0f} and the window is in
                      full-screen mode                    
                </throws>
                <throws>
                    UnsupportedOperationException if the alpha value of the given
                      background color is less than {@code 1.0f} and {@link GraphicsDevice.WindowTranslucency#PERPIXEL_TRANSLUCENTPERPIXEL_TRANSLUCENT} translucency is not supported                    
                </throws>
                <see>
                    Window#getBackground                    
                </see>
                <see>
                    Window#isOpaque                    
                </see>
                <see>
                    Window#setOpacity(float)                    
                </see>
                <see>
                    Window#setShape(Shape)                    
                </see>
                <see>
                    Frame#isUndecorated                    
                </see>
                <see>
                    Dialog#isUndecorated                    
                </see>
                <see>
                    GraphicsDevice.WindowTranslucency                    
                </see>
                <see>
                    GraphicsDevice#isWindowTranslucencySupported(GraphicsDevice.WindowTranslucency)                    
                </see>
                <see>
                    GraphicsConfiguration#isTranslucencyCapable()                    
                </see>
            </javadoc>
            <method name="setBackground" type="void" line="3787">
                <params>
                    <param name="bgColor" type="Color"/>
                </params>
                <comment line="3795">
                    non-opaque window                    
                </comment>
                <declaration name="oldBg" type="Color" line="3788"/>
                <scope line="3790"/>
                <declaration name="oldAlpha" type="int" line="3793"/>
                <declaration name="alpha" type="int" line="3794"/>
                <scope line="3795">
                    <declaration name="gc" type="GraphicsConfiguration" line="3796"/>
                    <declaration name="gd" type="GraphicsDevice" line="3797"/>
                    <scope line="3798"/>
                    <scope line="3802">
                        <declaration name="capableGC" type="GraphicsConfiguration" line="3803"/>
                        <scope line="3804"/>
                    </scope>
                </scope>
                <scope line="3811"/>
                <declaration name="peer" type="WindowPeer" line="3814"/>
                <scope line="3815"/>
            </method>
            <javadoc line="3820">
                Indicates if the window is currently opaque.
                  &lt;p&gt;
                  The method returns {@code false} if the background color of the window
                  is not {@code null} and the alpha component of the color is less than{@code 1.0f}. The method returns {@code true} otherwise.                
                <return>
                    {@code true} if the window is opaque, {@code false} otherwise                    
                </return>
                <see>
                    Window#getBackground                    
                </see>
                <see>
                    Window#setBackground(Color)                    
                </see>
                <since>
                    1.7                    
                </since>
            </javadoc>
            <method name="isOpaque" type="boolean" line="3834">
                <declaration name="bg" type="Color" line="3835"/>
            </method>
            <method name="updateWindow" type="void" line="3839">
                <scope line="3840">
                    <declaration name="peer" type="WindowPeer" line="3841"/>
                    <scope line="3842"/>
                </scope>
            </method>
            <javadoc line="3848">
                {@inheritDoc}                
                <since>
                    1.7                    
                </since>
            </javadoc>
            <method name="paint" type="void" line="3854">
                <params>
                    <param name="g" type="Graphics"/>
                </params>
                <scope line="3855">
                    <declaration name="gg" type="Graphics" line="3856"/>
                    <scope line="3857">
                        <scope line="3858"/>
                    </scope>
                    <scope line="3863"/>
                </scope>
            </method>
            <method name="setLayersOpaque" type="void" line="3870">
                <params>
                    <param name="component" type="Component"/>
                    <param name="isOpaque" type="boolean"/>
                </params>
                <comment line="3871">
                    Shouldn&apos;t use instanceof to avoid loading Swing classes                    
                </comment>
                <comment line="3872">
                    if it&apos;s a pure AWT application.                    
                </comment>
                <comment line="3885">
                    Iterate down one level to see whether we have a JApplet                    
                </comment>
                <comment line="3886">
                    (which is also a RootPaneContainer) which requires processing                    
                </comment>
                <comment line="3890">
                    It&apos;s OK to use instanceof here because we&apos;ve                    
                </comment>
                <comment line="3891">
                    already loaded the RootPaneContainer class by now                    
                </comment>
                <scope line="3873">
                    <declaration name="rpc" type="javax.swing.RootPaneContainer" line="3874"/>
                    <declaration name="root" type="javax.swing.JRootPane" line="3875"/>
                    <declaration name="lp" type="javax.swing.JLayeredPane" line="3876"/>
                    <declaration name="c" type="Container" line="3877"/>
                    <declaration name="content" type="javax.swing.JComponent" line="3878"/>
                    <scope line="3882">
                        <declaration name="numChildren" type="int" line="3887"/>
                        <scope line="3888">
                            <declaration name="child" type="Component" line="3889"/>
                            <scope line="3892"/>
                        </scope>
                    </scope>
                </scope>
            </method>
            <method name="getContainer" type="Container" line="3905"/>
            <javadoc line="3909">
                Applies the shape to the component                
                <param>
                    shape Shape to be applied to the component                    
                </param>
            </javadoc>
            <method name="applyCompoundShape" type="void" line="3914">
                <params>
                    <param name="shape" type="Region"/>
                </params>
                <comment line="3915">
                    The shape calculated by mixing code is not intended to be applied                    
                </comment>
                <comment line="3916">
                    to windows or frames                    
                </comment>
            </method>
            <method name="applyCurrentShape" type="void" line="3920">
                <comment line="3921">
                    The shape calculated by mixing code is not intended to be applied                    
                </comment>
                <comment line="3922">
                    to windows or frames                    
                </comment>
            </method>
            <method name="mixOnReshaping" type="void" line="3926">
                <comment line="3927">
                    The shape calculated by mixing code is not intended to be applied                    
                </comment>
                <comment line="3928">
                    to windows or frames                    
                </comment>
            </method>
            <method name="getLocationOnWindow" type="Point" line="3932"/>
            <javadoc line="3938">
                Limit the given double value with the given range.                
            </javadoc>
            <method name="limit" type="double" line="3941">
                <params>
                    <param name="value" type="double"/>
                    <param name="min" type="double"/>
                    <param name="max" type="double"/>
                </params>
            </method>
            <javadoc line="3947">
                Calculate the position of the security warning.
                  This method gets the window location/size as reported by the native
                  system since the locally cached values may represent outdated data.
                  The method is used from the native code, or via AWTAccessor.
                  NOTE: this method is invoked on the toolkit thread, and therefore is not
                  supposed to become public/user-overridable.                
            </javadoc>
            <method name="calculateSecurityWarningPosition" type="Point2D" line="3960">
                <params>
                    <param name="x" type="double"/>
                    <param name="y" type="double"/>
                    <param name="w" type="double"/>
                    <param name="h" type="double"/>
                </params>
                <comment line="3961">
                    The position according to the spec of SecurityWarning.setPosition()                    
                </comment>
                <comment line="3965">
                    First, make sure the warning is not too far from the window bounds                    
                </comment>
                <comment line="3973">
                    Now make sure the warning window is visible on the screen                    
                </comment>
                <declaration name="wx" type="double" line="3962"/>
                <declaration name="wy" type="double" line="3963"/>
                <declaration name="graphicsConfig" type="GraphicsConfiguration" line="3974"/>
                <declaration name="screenBounds" type="Rectangle" line="3976"/>
                <declaration name="screenInsets" type="Insets" line="3977"/>
            </method>
            <scope line="3992">
                <anonymous_class line="3993">
                    <method name="getOpacity" type="float" line="3994">
                        <params>
                            <param name="window" type="Window"/>
                        </params>
                    </method>
                    <method name="setOpacity" type="void" line="3997">
                        <params>
                            <param name="window" type="Window"/>
                            <param name="opacity" type="float"/>
                        </params>
                    </method>
                    <method name="getShape" type="Shape" line="4000">
                        <params>
                            <param name="window" type="Window"/>
                        </params>
                    </method>
                    <method name="setShape" type="void" line="4003">
                        <params>
                            <param name="window" type="Window"/>
                            <param name="shape" type="Shape"/>
                        </params>
                    </method>
                    <method name="setOpaque" type="void" line="4006">
                        <params>
                            <param name="window" type="Window"/>
                            <param name="opaque" type="boolean"/>
                        </params>
                        <declaration name="bg" type="Color" line="4007"/>
                        <scope line="4008"/>
                    </method>
                    <method name="updateWindow" type="void" line="4014">
                        <params>
                            <param name="window" type="Window"/>
                        </params>
                    </method>
                    <method name="getSecurityWarningSize" type="Dimension" line="4018">
                        <params>
                            <param name="window" type="Window"/>
                        </params>
                    </method>
                    <method name="setSecurityWarningSize" type="void" line="4024">
                        <params>
                            <param name="window" type="Window"/>
                            <param name="width" type="int"/>
                            <param name="height" type="int"/>
                        </params>
                    </method>
                    <method name="setSecurityWarningPosition" type="void" line="4031">
                        <params>
                            <param name="window" type="Window"/>
                            <param name="point" type="Point2D"/>
                            <param name="alignmentX" type="float"/>
                            <param name="alignmentY" type="float"/>
                        </params>
                        <scope line="4037">
                            <declaration name="peer" type="WindowPeer" line="4038"/>
                            <scope line="4039"/>
                        </scope>
                    </method>
                    <method name="calculateSecurityWarningPosition" type="Point2D" line="4047">
                        <params>
                            <param name="window" type="Window"/>
                            <param name="x" type="double"/>
                            <param name="y" type="double"/>
                            <param name="w" type="double"/>
                            <param name="h" type="double"/>
                        </params>
                    </method>
                    <method name="setLWRequestStatus" type="void" line="4051">
                        <params>
                            <param name="changed" type="Window"/>
                            <param name="status" type="boolean"/>
                        </params>
                    </method>
                    <method name="isAutoRequestFocus" type="boolean" line="4055">
                        <params>
                            <param name="w" type="Window"/>
                        </params>
                    </method>
                    <method name="isTrayIconWindow" type="boolean" line="4059">
                        <params>
                            <param name="w" type="Window"/>
                        </params>
                    </method>
                    <method name="setTrayIconWindow" type="void" line="4063">
                        <params>
                            <param name="w" type="Window"/>
                            <param name="isTrayIconWindow" type="boolean"/>
                        </params>
                    </method>
                </anonymous_class>
            </scope>
            <method name="updateZOrder" type="void" line="4071"/>
        </class>
        <class name="FocusManager" line="4076">
            <comment line="269">
                We insert a weak reference into the Vector of all Windows in AppContext
                 instead of &apos;this&apos; so that garbage collection can still take place
                 correctly.                
            </comment>
            <comment line="334">
                Indicates that this window is being shown. This flag is set to true at
                 the beginning of show() and to false at the end of show().
                
                 @see #show()
                 @see Dialog#shouldBlock                
            </comment>
            <comment line="343">
                The opacity level of the window
                
                 @serial
                 @see #setOpacity(float)
                 @see #getOpacity()
                 @since 1.7                
            </comment>
            <comment line="353">
                The shape assigned to this window. This field is set to {@code null} if
                 no shape is set (rectangular window).
                
                 @serial
                 @see #getShape()
                 @see #setShape(Shape)
                 @since 1.7                
            </comment>
            <comment line="367">
                JDK 1.1 serialVersionUID                
            </comment>
            <comment line="1150">
                Fix for 4872170.
                 If dispose() is called on parent then its children have to be disposed as well
                 as reported in javadoc. So we need to implement this functionality even if a
                 child overrides dispose() in a wrong way without calling super.dispose().                
            </comment>
            <comment line="1221">
                Should only be called while holding the tree lock.
                 It&apos;s overridden here because parent == owner in Window,
                 and we shouldn&apos;t adjust counter on owner                
            </comment>
            <comment line="1229">
                Should only be called while holding tree lock                
            </comment>
            <comment line="1282">
                This functionality is implemented in a final package-private method                
            </comment>
            <comment line="1283">
                to insure that it cannot be overridden by client subclasses.                
            </comment>
            <comment line="1325">
                This functionality is implemented in a final package-private method                
            </comment>
            <comment line="1326">
                to insure that it cannot be overridden by client subclasses.                
            </comment>
            <comment line="1509">
                Returns a list of all displayable Windows, i. e. all the
                 Windows which peer is not null.
                
                 @see #addNotify
                 @see #removeNotify                
            </comment>
            <comment line="1949">
                REMIND: remove when filtering is handled at lower level                
            </comment>
            <comment line="2756">
                Support for tracking all windows owned by this window                
            </comment>
            <comment line="2928">
                                
            </comment>
            <comment line="2929">
                Part of deserialization procedure to be called before                
            </comment>
            <comment line="2930">
                user&apos;s code.                
            </comment>
            <comment line="2931">
                                
            </comment>
            <comment line="3063">
                --- Accessibility Support ---                
            </comment>
            <comment line="3124">
                inner class AccessibleAWTWindow                
            </comment>
            <comment line="3506">
                ******************** SHAPES &amp; TRANSPARENCY CODE ********************                
            </comment>
            <comment line="3902">
                ************************** MIXING CODE *******************************                
            </comment>
            <comment line="3904">
                A window has a parent, but it does NOT have a container                
            </comment>
            <comment line="3937">
                ****************** END OF MIXING CODE ********************************                
            </comment>
            <comment line="4068">
                static                
            </comment>
            <comment line="4070">
                a window doesn&apos;t need to be updated in the Z-order.                
            </comment>
            <comment line="4085">
                JDK 1.1 serialVersionUID                
            </comment>
            <implements interface="java.io.Serializable"/>
            <javadoc line="4076">
                This class is no longer used, but is maintained for Serialization
                  backward-compatibility.                
            </javadoc>
            <declaration name="focusRoot" type="Container" line="4081"/>
            <declaration name="focusOwner" type="Component" line="4082"/>
            <declaration name="serialVersionUID" type="long" line="4087"/>
        </class>
    </source>