<?xml version="1.0" encoding="UTF-8"?>
    <source package="java.awt">
        <import package="java.util.LinkedList"/>
        <import package="sun.awt.AppContext"/>
        <import package="sun.awt.SunToolkit"/>
        <class name="SequencedEvent" line="32">
            <extends class="AWTEvent"/>
            <comment line="45">
                serialVersionUID                
            </comment>
            <comment line="155">
                Disposes all events from disposed AppContext
                 return first valid event                
            </comment>
            <implements interface="ActiveEvent"/>
            <javadoc line="32">
                A mechanism for ensuring that a series of AWTEvents are executed in a
                  precise order, even across multiple AppContexts. The nested events will be
                  dispatched in the order in which their wrapping SequencedEvents were
                  constructed. The only exception to this rule is if the peer of the target of
                  the nested event was destroyed (with a call to Component.removeNotify)
                  before the wrapping SequencedEvent was able to be dispatched. In this case,
                  the nested event is never dispatched.                
                <author>
                    David Mendenhall                    
                </author>
            </javadoc>
            <declaration name="serialVersionUID" type="long" line="47"/>
            <declaration name="ID" type="int" line="49"/>
            <declaration name="list" type="LinkedList" line="51"/>
            <declaration name="nested" type="AWTEvent" line="53"/>
            <declaration name="appContext" type="AppContext" line="54"/>
            <declaration name="disposed" type="boolean" line="55"/>
            <javadoc line="57">
                Constructs a new SequencedEvent which will dispatch the specified
                  nested event.                
                <param>
                    nested the AWTEvent which this SequencedEvent's dispatch()
                      method will dispatch                    
                </param>
            </javadoc>
            <method name="SequencedEvent" type="constructor" line="64">
                <params>
                    <param name="nested" type="AWTEvent"/>
                </params>
                <comment line="67">
                    All AWTEvents that are wrapped in SequencedEvents are (at                    
                </comment>
                <comment line="68">
                    least currently) implicitly generated by the system                    
                </comment>
                <scope line="70"/>
            </method>
            <javadoc line="75">
                Dispatches the nested event after all previous nested events have been
                  dispatched or disposed. If this method is invoked before all previous nested events
                  have been dispatched, then this method blocks until such a point is
                  reached.
                  While waiting disposes nested events to disposed AppContext
                  NOTE: Locking protocol.  Since dispose() can get EventQueue lock,
                  dispatch() shall never call dispose() while holding the lock on the list,
                  as EventQueue lock is held during dispatching.  The locks should be acquired
                  in the same order.                
            </javadoc>
            <method name="dispatch" type="void" line="87">
                <scope line="88">
                    <scope line="91">
                        <scope line="92">
                            <declaration name="edt" type="EventDispatchThread" line="93"/>
                            <anonymous_class line="95">
                                <method name="evaluate" type="boolean" line="96"/>
                            </anonymous_class>
                        </scope>
                        <scope line="100">
                            <scope line="101">
                                <scope line="102">
                                    <scope line="103"/>
                                    <scope line="105"/>
                                </scope>
                            </scope>
                        </scope>
                    </scope>
                    <scope line="113"/>
                </scope>
                <scope line="118"/>
            </method>
            <javadoc line="123">
                true only if event exists and nested source appContext is disposed.                
            </javadoc>
            <method name="isOwnerAppContextDisposed" type="boolean" line="126">
                <params>
                    <param name="se" type="SequencedEvent"/>
                </params>
                <scope line="127">
                    <declaration name="target" type="Object" line="128"/>
                    <scope line="129"/>
                </scope>
            </method>
            <javadoc line="136">
                Sequenced events are dispatched in order, so we cannot dispatch
                  until we are the first sequenced event in the queue (i.e. it&apos;s our
                  turn).  But while we wait for our turn to dispatch, the event
                  could have been disposed for a number of reasons.                
            </javadoc>
            <method name="isFirstOrDisposed" type="boolean" line="142">
                <comment line="146">
                    getFirstWithContext can dispose this                    
                </comment>
                <scope line="143"/>
            </method>
            <method name="getFirst" type="SequencedEvent" line="150"/>
            <method name="getFirstWithContext" type="SequencedEvent" line="157">
                <declaration name="first" type="SequencedEvent" line="158"/>
                <scope line="159"/>
            </method>
            <javadoc line="166">
                Disposes of this instance. This method is invoked once the nested event
                  has been dispatched and handled, or when the peer of the target of the
                  nested event has been disposed with a call to Component.removeNotify.
                  NOTE: Locking protocol.  Since SunToolkit.postEvent can get EventQueue lock,
                  it shall never be called while holding the lock on the list,
                  as EventQueue lock is held during dispatching and dispatch() will get
                  lock on the list. The locks should be acquired in the same order.                
            </javadoc>
            <method name="dispose" type="void" line="176">
                <comment line="188">
                    Wake myself up                    
                </comment>
                <comment line="208">
                    Wake up waiting threads                    
                </comment>
                <scope line="177">
                    <scope line="178"/>
                    <scope line="182"/>
                </scope>
                <scope line="189"/>
                <declaration name="next" type="SequencedEvent" line="193"/>
                <scope line="195">
                    <scope line="198">
                        <scope line="201"/>
                    </scope>
                    <scope line="204"/>
                </scope>
                <scope line="209"/>
            </method>
        </class>
    </source>