<?xml version="1.0" encoding="UTF-8"?>
    <source package="java.awt">
        <import package="java.beans.PropertyChangeEvent"/>
        <import package="java.util.MissingResourceException"/>
        <import package="java.util.Properties"/>
        <import package="java.util.ResourceBundle"/>
        <import package="java.util.StringTokenizer"/>
        <import package="java.awt.event"/>
        <import package="java.awt.peer"/>
        <import package="java.awt.im.InputMethodHighlight"/>
        <import package="java.awt.image.ImageObserver"/>
        <import package="java.awt.image.ImageProducer"/>
        <import package="java.awt.image.ColorModel"/>
        <import package="java.awt.datatransfer.Clipboard"/>
        <import package="java.awt.dnd.DragSource"/>
        <import package="java.awt.dnd.DragGestureRecognizer"/>
        <import package="java.awt.dnd.DragGestureEvent"/>
        <import package="java.awt.dnd.DragGestureListener"/>
        <import package="java.awt.dnd.InvalidDnDOperationException"/>
        <import package="java.awt.dnd.peer.DragSourceContextPeer"/>
        <import package="java.net.URL"/>
        <import package="java.io.File"/>
        <import package="java.io.FileInputStream"/>
        <import package="java.util"/>
        <import package="sun.util.logging.PlatformLogger"/>
        <import package="java.beans.PropertyChangeListener"/>
        <import package="java.beans.PropertyChangeSupport"/>
        <import package="sun.awt.AppContext"/>
        <import package="sun.awt.HeadlessToolkit"/>
        <import package="sun.awt.NullComponentPeer"/>
        <import package="sun.awt.PeerEvent"/>
        <import package="sun.awt.SunToolkit"/>
        <import package="sun.security.util.SecurityConstants"/>
        <import package="sun.util.CoreResourceBundleControl"/>
        <class name="Toolkit" line="65">
            <comment line="455">
                The following method is called by the private method                
            </comment>
            <comment line="456">
                &lt;code&gt;updateSystemColors&lt;/code&gt; in &lt;code&gt;SystemColor&lt;/code&gt;.                
            </comment>
            <comment line="1731">
                                
            </comment>
            <comment line="1990">
                Extracts a &quot;pure&quot; AWTEventListener from a AWTEventListenerProxy,
                 if the listener is proxied.                
            </comment>
            <comment line="2262">
                This method notifies any AWTEventListeners that an event
                 is about to be dispatched.
                
                 @param theEvent the event which will be dispatched.                
            </comment>
            <javadoc line="65">
                This class is the abstract superclass of all actual
                  implementations of the Abstract Window Toolkit. Subclasses of
                  the &lt;code&gt;Toolkit&lt;/code&gt; class are used to bind the various components
                  to particular native toolkit implementations.
                  &lt;p&gt;
                  Many GUI events may be delivered to user
                  asynchronously, if the opposite is not specified explicitly.
                  As well as
                  many GUI operations may be performed asynchronously.
                  This fact means that if the state of a component is set, and then
                  the state immediately queried, the returned value may not yet
                  reflect the requested change.  This behavior includes, but is not
                  limited to:
                  &lt;ul&gt;
                  &lt;li&gt;Scrolling to a specified position.
                  &lt;br&gt;For example, calling &lt;code&gt;ScrollPane.setScrollPosition&lt;/code&gt;
                  and then &lt;code&gt;getScrollPosition&lt;/code&gt; may return an incorrect
                  value if the original request has not yet been processed.
                  &lt;p&gt;
                  &lt;li&gt;Moving the focus from one component to another.
                  &lt;br&gt;For more information, see
                  &lt;a href=&quot;http://java.sun.com/docs/books/tutorial/uiswing/misc/focus.html#transferTiming&quot;&gt;Timing
                  Focus Transfers&lt;/a&gt;, a section in
                  &lt;a href=&quot;http://java.sun.com/docs/books/tutorial/uiswing/&quot;&gt;The Swing
                  Tutorial&lt;/a&gt;.
                  &lt;p&gt;
                  &lt;li&gt;Making a top-level container visible.
                  &lt;br&gt;Calling &lt;code&gt;setVisible(true)&lt;/code&gt; on a &lt;code&gt;Window&lt;/code&gt;,
                  &lt;code&gt;Frame&lt;/code&gt; or &lt;code&gt;Dialog&lt;/code&gt; may occur
                  asynchronously.
                  &lt;p&gt;
                  &lt;li&gt;Setting the size or location of a top-level container.
                  &lt;br&gt;Calls to &lt;code&gt;setSize&lt;/code&gt;, &lt;code&gt;setBounds&lt;/code&gt; or
                  &lt;code&gt;setLocation&lt;/code&gt; on a &lt;code&gt;Window&lt;/code&gt;,
                  &lt;code&gt;Frame&lt;/code&gt; or &lt;code&gt;Dialog&lt;/code&gt; are forwarded
                  to the underlying window management system and may be
                  ignored or modified.  See {@link java.awt.Window} for
                  more information.
                  &lt;/ul&gt;
                  &lt;p&gt;
                  Most applications should not call any of the methods in this
                  class directly. The methods defined by &lt;code&gt;Toolkit&lt;/code&gt; are
                  the &quot;glue&quot; that joins the platform-independent classes in the
                  &lt;code&gt;java.awt&lt;/code&gt; package with their counterparts in
                  &lt;code&gt;java.awt.peer&lt;/code&gt;. Some methods defined by
                  &lt;code&gt;Toolkit&lt;/code&gt; query the native operating system directly.                
                <author>
                    Sami Shaio                    
                </author>
                <author>
                    Arthur van Hoff                    
                </author>
                <author>
                    Fred Ecks                    
                </author>
                <since>
                    JDK1.0                    
                </since>
            </javadoc>
            <method name="createDesktopPeer" type="DesktopPeer" line="120"/>
            <javadoc line="120">
                Creates this toolkit&apos;s implementation of the &lt;code&gt;Desktop&lt;/code&gt;
                  using the specified peer interface.                
                <param>
                    target the desktop to be implemented                    
                </param>
                <return>
                    this toolkit's implementation of the <code>Desktop</code>                    
                </return>
                <exception>
                    HeadlessException if GraphicsEnvironment.isHeadless()
                      returns true                    
                </exception>
                <see>
                    java.awt.GraphicsEnvironment#isHeadless                    
                </see>
                <see>
                    java.awt.Desktop                    
                </see>
                <see>
                    java.awt.peer.DesktopPeer                    
                </see>
                <since>
                    1.6                    
                </since>
            </javadoc>
            <method name="createButton" type="ButtonPeer" line="136"/>
            <javadoc line="136">
                Creates this toolkit&apos;s implementation of &lt;code&gt;Button&lt;/code&gt; using
                  the specified peer interface.                
                <param>
                    target the button to be implemented.                    
                </param>
                <return>
                    this toolkit's implementation of <code>Button</code>.                    
                </return>
                <exception>
                    HeadlessException if GraphicsEnvironment.isHeadless()
                      returns true                    
                </exception>
                <see>
                    java.awt.GraphicsEnvironment#isHeadless                    
                </see>
                <see>
                    java.awt.Button                    
                </see>
                <see>
                    java.awt.peer.ButtonPeer                    
                </see>
            </javadoc>
            <method name="createTextField" type="TextFieldPeer" line="150"/>
            <javadoc line="150">
                Creates this toolkit&apos;s implementation of &lt;code&gt;TextField&lt;/code&gt; using
                  the specified peer interface.                
                <param>
                    target the text field to be implemented.                    
                </param>
                <return>
                    this toolkit's implementation of <code>TextField</code>.                    
                </return>
                <exception>
                    HeadlessException if GraphicsEnvironment.isHeadless()
                      returns true                    
                </exception>
                <see>
                    java.awt.GraphicsEnvironment#isHeadless                    
                </see>
                <see>
                    java.awt.TextField                    
                </see>
                <see>
                    java.awt.peer.TextFieldPeer                    
                </see>
            </javadoc>
            <method name="createLabel" type="LabelPeer" line="164"/>
            <javadoc line="164">
                Creates this toolkit&apos;s implementation of &lt;code&gt;Label&lt;/code&gt; using
                  the specified peer interface.                
                <param>
                    target the label to be implemented.                    
                </param>
                <return>
                    this toolkit's implementation of <code>Label</code>.                    
                </return>
                <exception>
                    HeadlessException if GraphicsEnvironment.isHeadless()
                      returns true                    
                </exception>
                <see>
                    java.awt.GraphicsEnvironment#isHeadless                    
                </see>
                <see>
                    java.awt.Label                    
                </see>
                <see>
                    java.awt.peer.LabelPeer                    
                </see>
            </javadoc>
            <method name="createList" type="ListPeer" line="178"/>
            <javadoc line="178">
                Creates this toolkit&apos;s implementation of &lt;code&gt;List&lt;/code&gt; using
                  the specified peer interface.                
                <param>
                    target the list to be implemented.                    
                </param>
                <return>
                    this toolkit's implementation of <code>List</code>.                    
                </return>
                <exception>
                    HeadlessException if GraphicsEnvironment.isHeadless()
                      returns true                    
                </exception>
                <see>
                    java.awt.GraphicsEnvironment#isHeadless                    
                </see>
                <see>
                    java.awt.List                    
                </see>
                <see>
                    java.awt.peer.ListPeer                    
                </see>
            </javadoc>
            <method name="createCheckbox" type="CheckboxPeer" line="192"/>
            <javadoc line="192">
                Creates this toolkit&apos;s implementation of &lt;code&gt;Checkbox&lt;/code&gt; using
                  the specified peer interface.                
                <param>
                    target the check box to be implemented.                    
                </param>
                <return>
                    this toolkit's implementation of <code>Checkbox</code>.                    
                </return>
                <exception>
                    HeadlessException if GraphicsEnvironment.isHeadless()
                      returns true                    
                </exception>
                <see>
                    java.awt.GraphicsEnvironment#isHeadless                    
                </see>
                <see>
                    java.awt.Checkbox                    
                </see>
                <see>
                    java.awt.peer.CheckboxPeer                    
                </see>
            </javadoc>
            <method name="createScrollbar" type="ScrollbarPeer" line="206"/>
            <javadoc line="206">
                Creates this toolkit&apos;s implementation of &lt;code&gt;Scrollbar&lt;/code&gt; using
                  the specified peer interface.                
                <param>
                    target the scroll bar to be implemented.                    
                </param>
                <return>
                    this toolkit's implementation of <code>Scrollbar</code>.                    
                </return>
                <exception>
                    HeadlessException if GraphicsEnvironment.isHeadless()
                      returns true                    
                </exception>
                <see>
                    java.awt.GraphicsEnvironment#isHeadless                    
                </see>
                <see>
                    java.awt.Scrollbar                    
                </see>
                <see>
                    java.awt.peer.ScrollbarPeer                    
                </see>
            </javadoc>
            <method name="createScrollPane" type="ScrollPanePeer" line="220"/>
            <javadoc line="220">
                Creates this toolkit&apos;s implementation of &lt;code&gt;ScrollPane&lt;/code&gt; using
                  the specified peer interface.                
                <param>
                    target the scroll pane to be implemented.                    
                </param>
                <return>
                    this toolkit's implementation of <code>ScrollPane</code>.                    
                </return>
                <exception>
                    HeadlessException if GraphicsEnvironment.isHeadless()
                      returns true                    
                </exception>
                <see>
                    java.awt.GraphicsEnvironment#isHeadless                    
                </see>
                <see>
                    java.awt.ScrollPane                    
                </see>
                <see>
                    java.awt.peer.ScrollPanePeer                    
                </see>
                <since>
                    JDK1.1                    
                </since>
            </javadoc>
            <method name="createTextArea" type="TextAreaPeer" line="235"/>
            <javadoc line="235">
                Creates this toolkit&apos;s implementation of &lt;code&gt;TextArea&lt;/code&gt; using
                  the specified peer interface.                
                <param>
                    target the text area to be implemented.                    
                </param>
                <return>
                    this toolkit's implementation of <code>TextArea</code>.                    
                </return>
                <exception>
                    HeadlessException if GraphicsEnvironment.isHeadless()
                      returns true                    
                </exception>
                <see>
                    java.awt.GraphicsEnvironment#isHeadless                    
                </see>
                <see>
                    java.awt.TextArea                    
                </see>
                <see>
                    java.awt.peer.TextAreaPeer                    
                </see>
            </javadoc>
            <method name="createChoice" type="ChoicePeer" line="249"/>
            <javadoc line="249">
                Creates this toolkit&apos;s implementation of &lt;code&gt;Choice&lt;/code&gt; using
                  the specified peer interface.                
                <param>
                    target the choice to be implemented.                    
                </param>
                <return>
                    this toolkit's implementation of <code>Choice</code>.                    
                </return>
                <exception>
                    HeadlessException if GraphicsEnvironment.isHeadless()
                      returns true                    
                </exception>
                <see>
                    java.awt.GraphicsEnvironment#isHeadless                    
                </see>
                <see>
                    java.awt.Choice                    
                </see>
                <see>
                    java.awt.peer.ChoicePeer                    
                </see>
            </javadoc>
            <method name="createFrame" type="FramePeer" line="263"/>
            <javadoc line="263">
                Creates this toolkit&apos;s implementation of &lt;code&gt;Frame&lt;/code&gt; using
                  the specified peer interface.                
                <param>
                    target the frame to be implemented.                    
                </param>
                <return>
                    this toolkit's implementation of <code>Frame</code>.                    
                </return>
                <exception>
                    HeadlessException if GraphicsEnvironment.isHeadless()
                      returns true                    
                </exception>
                <see>
                    java.awt.GraphicsEnvironment#isHeadless                    
                </see>
                <see>
                    java.awt.Frame                    
                </see>
                <see>
                    java.awt.peer.FramePeer                    
                </see>
            </javadoc>
            <method name="createCanvas" type="CanvasPeer" line="277"/>
            <javadoc line="277">
                Creates this toolkit&apos;s implementation of &lt;code&gt;Canvas&lt;/code&gt; using
                  the specified peer interface.                
                <param>
                    target the canvas to be implemented.                    
                </param>
                <return>
                    this toolkit's implementation of <code>Canvas</code>.                    
                </return>
                <see>
                    java.awt.Canvas                    
                </see>
                <see>
                    java.awt.peer.CanvasPeer                    
                </see>
            </javadoc>
            <method name="createPanel" type="PanelPeer" line="287"/>
            <javadoc line="287">
                Creates this toolkit&apos;s implementation of &lt;code&gt;Panel&lt;/code&gt; using
                  the specified peer interface.                
                <param>
                    target the panel to be implemented.                    
                </param>
                <return>
                    this toolkit's implementation of <code>Panel</code>.                    
                </return>
                <see>
                    java.awt.Panel                    
                </see>
                <see>
                    java.awt.peer.PanelPeer                    
                </see>
            </javadoc>
            <method name="createWindow" type="WindowPeer" line="297"/>
            <javadoc line="297">
                Creates this toolkit&apos;s implementation of &lt;code&gt;Window&lt;/code&gt; using
                  the specified peer interface.                
                <param>
                    target the window to be implemented.                    
                </param>
                <return>
                    this toolkit's implementation of <code>Window</code>.                    
                </return>
                <exception>
                    HeadlessException if GraphicsEnvironment.isHeadless()
                      returns true                    
                </exception>
                <see>
                    java.awt.GraphicsEnvironment#isHeadless                    
                </see>
                <see>
                    java.awt.Window                    
                </see>
                <see>
                    java.awt.peer.WindowPeer                    
                </see>
            </javadoc>
            <method name="createDialog" type="DialogPeer" line="311"/>
            <javadoc line="311">
                Creates this toolkit&apos;s implementation of &lt;code&gt;Dialog&lt;/code&gt; using
                  the specified peer interface.                
                <param>
                    target the dialog to be implemented.                    
                </param>
                <return>
                    this toolkit's implementation of <code>Dialog</code>.                    
                </return>
                <exception>
                    HeadlessException if GraphicsEnvironment.isHeadless()
                      returns true                    
                </exception>
                <see>
                    java.awt.GraphicsEnvironment#isHeadless                    
                </see>
                <see>
                    java.awt.Dialog                    
                </see>
                <see>
                    java.awt.peer.DialogPeer                    
                </see>
            </javadoc>
            <method name="createMenuBar" type="MenuBarPeer" line="325"/>
            <javadoc line="325">
                Creates this toolkit&apos;s implementation of &lt;code&gt;MenuBar&lt;/code&gt; using
                  the specified peer interface.                
                <param>
                    target the menu bar to be implemented.                    
                </param>
                <return>
                    this toolkit's implementation of <code>MenuBar</code>.                    
                </return>
                <exception>
                    HeadlessException if GraphicsEnvironment.isHeadless()
                      returns true                    
                </exception>
                <see>
                    java.awt.GraphicsEnvironment#isHeadless                    
                </see>
                <see>
                    java.awt.MenuBar                    
                </see>
                <see>
                    java.awt.peer.MenuBarPeer                    
                </see>
            </javadoc>
            <method name="createMenu" type="MenuPeer" line="339"/>
            <javadoc line="339">
                Creates this toolkit&apos;s implementation of &lt;code&gt;Menu&lt;/code&gt; using
                  the specified peer interface.                
                <param>
                    target the menu to be implemented.                    
                </param>
                <return>
                    this toolkit's implementation of <code>Menu</code>.                    
                </return>
                <exception>
                    HeadlessException if GraphicsEnvironment.isHeadless()
                      returns true                    
                </exception>
                <see>
                    java.awt.GraphicsEnvironment#isHeadless                    
                </see>
                <see>
                    java.awt.Menu                    
                </see>
                <see>
                    java.awt.peer.MenuPeer                    
                </see>
            </javadoc>
            <method name="createPopupMenu" type="PopupMenuPeer" line="353"/>
            <javadoc line="353">
                Creates this toolkit&apos;s implementation of &lt;code&gt;PopupMenu&lt;/code&gt; using
                  the specified peer interface.                
                <param>
                    target the popup menu to be implemented.                    
                </param>
                <return>
                    this toolkit's implementation of <code>PopupMenu</code>.                    
                </return>
                <exception>
                    HeadlessException if GraphicsEnvironment.isHeadless()
                      returns true                    
                </exception>
                <see>
                    java.awt.GraphicsEnvironment#isHeadless                    
                </see>
                <see>
                    java.awt.PopupMenu                    
                </see>
                <see>
                    java.awt.peer.PopupMenuPeer                    
                </see>
                <since>
                    JDK1.1                    
                </since>
            </javadoc>
            <method name="createMenuItem" type="MenuItemPeer" line="368"/>
            <javadoc line="368">
                Creates this toolkit&apos;s implementation of &lt;code&gt;MenuItem&lt;/code&gt; using
                  the specified peer interface.                
                <param>
                    target the menu item to be implemented.                    
                </param>
                <return>
                    this toolkit's implementation of <code>MenuItem</code>.                    
                </return>
                <exception>
                    HeadlessException if GraphicsEnvironment.isHeadless()
                      returns true                    
                </exception>
                <see>
                    java.awt.GraphicsEnvironment#isHeadless                    
                </see>
                <see>
                    java.awt.MenuItem                    
                </see>
                <see>
                    java.awt.peer.MenuItemPeer                    
                </see>
            </javadoc>
            <method name="createFileDialog" type="FileDialogPeer" line="382"/>
            <javadoc line="382">
                Creates this toolkit&apos;s implementation of &lt;code&gt;FileDialog&lt;/code&gt; using
                  the specified peer interface.                
                <param>
                    target the file dialog to be implemented.                    
                </param>
                <return>
                    this toolkit's implementation of <code>FileDialog</code>.                    
                </return>
                <exception>
                    HeadlessException if GraphicsEnvironment.isHeadless()
                      returns true                    
                </exception>
                <see>
                    java.awt.GraphicsEnvironment#isHeadless                    
                </see>
                <see>
                    java.awt.FileDialog                    
                </see>
                <see>
                    java.awt.peer.FileDialogPeer                    
                </see>
            </javadoc>
            <method name="createCheckboxMenuItem" type="CheckboxMenuItemPeer" line="396"/>
            <javadoc line="396">
                Creates this toolkit&apos;s implementation of &lt;code&gt;CheckboxMenuItem&lt;/code&gt; using
                  the specified peer interface.                
                <param>
                    target the checkbox menu item to be implemented.                    
                </param>
                <return>
                    this toolkit's implementation of <code>CheckboxMenuItem</code>.                    
                </return>
                <exception>
                    HeadlessException if GraphicsEnvironment.isHeadless()
                      returns true                    
                </exception>
                <see>
                    java.awt.GraphicsEnvironment#isHeadless                    
                </see>
                <see>
                    java.awt.CheckboxMenuItem                    
                </see>
                <see>
                    java.awt.peer.CheckboxMenuItemPeer                    
                </see>
            </javadoc>
            <javadoc line="410">
                Obtains this toolkit&apos;s implementation of helper class for
                  &lt;code&gt;MouseInfo&lt;/code&gt; operations.                
                <return>
                    this toolkit's implementation of  helper for <code>MouseInfo</code>                    
                </return>
                <throws>
                    UnsupportedOperationException if this operation is not implemented                    
                </throws>
                <see>
                    java.awt.peer.MouseInfoPeer                    
                </see>
                <see>
                    java.awt.MouseInfo                    
                </see>
                <since>
                    1.5                    
                </since>
            </javadoc>
            <method name="getMouseInfoPeer" type="MouseInfoPeer" line="419"/>
            <declaration name="lightweightMarker" type="LightweightPeer" line="423"/>
            <javadoc line="425">
                Creates a peer for a component or container.  This peer is windowless
                  and allows the Component and Container classes to be extended directly
                  to create windowless components that are defined entirely in java.                
                <param>
                    target The Component to be created.                    
                </param>
            </javadoc>
            <method name="createComponent" type="LightweightPeer" line="432">
                <params>
                    <param name="target" type="Component"/>
                </params>
                <scope line="433"/>
            </method>
            <method name="getFontPeer" type="FontPeer" line="439"/>
            <javadoc line="439">
                Creates this toolkit&apos;s implementation of &lt;code&gt;Font&lt;/code&gt; using
                  the specified peer interface.                
                <param>
                    name the font to be implemented                    
                </param>
                <param>
                    style the style of the font, such as <code>PLAIN</code>,
                      <code>BOLD</code>, <code>ITALIC</code>, or a combination                    
                </param>
                <return>
                    this toolkit's implementation of <code>Font</code>                    
                </return>
                <see>
                    java.awt.Font                    
                </see>
                <see>
                    java.awt.peer.FontPeer                    
                </see>
                <see>
                    java.awt.GraphicsEnvironment#getAllFonts                    
                </see>
                <deprecated>
                    see java.awt.GraphicsEnvironment#getAllFonts                    
                </deprecated>
            </javadoc>
            <javadoc line="457">
                Fills in the integer array that is supplied as an argument
                  with the current system color values.                
                <param>
                    systemColors an integer array.                    
                </param>
                <exception>
                    HeadlessException if GraphicsEnvironment.isHeadless()
                      returns true                    
                </exception>
                <see>
                    java.awt.GraphicsEnvironment#isHeadless                    
                </see>
                <since>
                    JDK1.1                    
                </since>
            </javadoc>
            <method name="loadSystemColors" type="void" line="468">
                <params>
                    <param name="systemColors" type="int[]"/>
                </params>
            </method>
            <javadoc line="472">
                Controls whether the layout of Containers is validated dynamically
                  during resizing, or statically, after resizing is complete.
                  Use {@code isDynamicLayoutActive()} to detect if this feature enabled
                  in this program and is supported by this operating system
                  and/or window manager.
                  Note that this feature is supported not on all platforms, and
                  conversely, that this feature cannot be turned off on some platforms.
                  On these platforms where dynamic layout during resizing is not supported
                  (or is always supported), setting this property has no effect.
                  Note that this feature can be set or unset as a property of the
                  operating system or window manager on some platforms.  On such
                  platforms, the dynamic resize property must be set at the operating
                  system or window manager level before this method can take effect.
                  This method does not change support or settings of the underlying
                  operating system or
                  window manager.  The OS/WM support can be
                  queried using getDesktopProperty(&quot;awt.dynamicLayoutSupported&quot;) method.                
                <param>
                    dynamic  If true, Containers should re-layout their
                      components as the Container is being resized.  If false,
                      the layout will be validated after resizing is completed.                    
                </param>
                <exception>
                    HeadlessException if GraphicsEnvironment.isHeadless()
                      returns true                    
                </exception>
                <see>
                    #isDynamicLayoutSet()                    
                </see>
                <see>
                    #isDynamicLayoutActive()                    
                </see>
                <see>
                    #getDesktopProperty(String propertyName)                    
                </see>
                <see>
                    java.awt.GraphicsEnvironment#isHeadless                    
                </see>
                <since>
                    1.4                    
                </since>
            </javadoc>
            <method name="setDynamicLayout" type="void" line="503">
                <params>
                    <param name="dynamic" type="boolean"/>
                </params>
            </method>
            <javadoc line="507">
                Returns whether the layout of Containers is validated dynamically
                  during resizing, or statically, after resizing is complete.
                  Note: this method returns the value that was set programmatically;
                  it does not reflect support at the level of the operating system
                  or window manager for dynamic layout on resizing, or the current
                  operating system or window manager settings.  The OS/WM support can
                  be queried using getDesktopProperty(&quot;awt.dynamicLayoutSupported&quot;).                
                <return>
                    true if validation of Containers is done dynamically,
                      false if validation is done after resizing is finished.                    
                </return>
                <exception>
                    HeadlessException if GraphicsEnvironment.isHeadless()
                      returns true                    
                </exception>
                <see>
                    #setDynamicLayout(boolean dynamic)                    
                </see>
                <see>
                    #isDynamicLayoutActive()                    
                </see>
                <see>
                    #getDesktopProperty(String propertyName)                    
                </see>
                <see>
                    java.awt.GraphicsEnvironment#isHeadless                    
                </see>
                <since>
                    1.4                    
                </since>
            </javadoc>
            <method name="isDynamicLayoutSet" type="boolean" line="527">
                <scope line="530"/>
                <scope line="532"/>
            </method>
            <javadoc line="537">
                Returns whether dynamic layout of Containers on resize is
                  currently active (both set in program
                  ( {@code isDynamicLayoutSet()} )
                  , and supported
                  by the underlying operating system and/or window manager).
                  If dynamic layout is currently inactive then Containers
                  re-layout their components when resizing is completed. As a result
                  the {@code Component.validate()} method will be invoked only
                  once per resize.
                  If dynamic layout is currently active then Containers
                  re-layout their components on every native resize event and
                  the {@code validate()} method will be invoked each time.
                  The OS/WM support can be queried using
                  the getDesktopProperty(&quot;awt.dynamicLayoutSupported&quot;) method.                
                <return>
                    true if dynamic layout of Containers on resize is
                      currently active, false otherwise.                    
                </return>
                <exception>
                    HeadlessException if the GraphicsEnvironment.isHeadless()
                      method returns true                    
                </exception>
                <see>
                    #setDynamicLayout(boolean dynamic)                    
                </see>
                <see>
                    #isDynamicLayoutSet()                    
                </see>
                <see>
                    #getDesktopProperty(String propertyName)                    
                </see>
                <see>
                    java.awt.GraphicsEnvironment#isHeadless                    
                </see>
                <since>
                    1.4                    
                </since>
            </javadoc>
            <method name="isDynamicLayoutActive" type="boolean" line="564">
                <scope line="567"/>
                <scope line="569"/>
            </method>
            <method name="getScreenSize" type="Dimension" line="574"/>
            <javadoc line="574">
                Gets the size of the screen.  On systems with multiple displays, the
                  primary display is used.  Multi-screen aware display dimensions are
                  available from &lt;code&gt;GraphicsConfiguration&lt;/code&gt; and
                  &lt;code&gt;GraphicsDevice&lt;/code&gt;.                
                <return>
                    the size of this toolkit's screen, in pixels.                    
                </return>
                <exception>
                    HeadlessException if GraphicsEnvironment.isHeadless()
                      returns true                    
                </exception>
                <see>
                    java.awt.GraphicsConfiguration#getBounds                    
                </see>
                <see>
                    java.awt.GraphicsDevice#getDisplayMode                    
                </see>
                <see>
                    java.awt.GraphicsEnvironment#isHeadless                    
                </see>
            </javadoc>
            <method name="getScreenResolution" type="int" line="589"/>
            <javadoc line="589">
                Returns the screen resolution in dots-per-inch.                
                <return>
                    this toolkit's screen resolution, in dots-per-inch.                    
                </return>
                <exception>
                    HeadlessException if GraphicsEnvironment.isHeadless()
                      returns true                    
                </exception>
                <see>
                    java.awt.GraphicsEnvironment#isHeadless                    
                </see>
            </javadoc>
            <javadoc line="599">
                Gets the insets of the screen.                
                <param>
                    gc a <code>GraphicsConfiguration</code>                    
                </param>
                <return>
                    the insets of this toolkit's screen, in pixels.                    
                </return>
                <exception>
                    HeadlessException if GraphicsEnvironment.isHeadless()
                      returns true                    
                </exception>
                <see>
                    java.awt.GraphicsEnvironment#isHeadless                    
                </see>
                <since>
                    1.4                    
                </since>
            </javadoc>
            <method name="getScreenInsets" type="Insets" line="609">
                <params>
                    <param name="gc" type="GraphicsConfiguration"/>
                </params>
                <scope line="611"/>
                <scope line="613"/>
            </method>
            <method name="getColorModel" type="ColorModel" line="618"/>
            <javadoc line="618">
                Determines the color model of this toolkit&apos;s screen.
                  &lt;p&gt;
                  &lt;code&gt;ColorModel&lt;/code&gt; is an abstract class that
                  encapsulates the ability to translate between the
                  pixel values of an image and its red, green, blue,
                  and alpha components.
                  &lt;p&gt;
                  This toolkit method is called by the
                  &lt;code&gt;getColorModel&lt;/code&gt; method
                  of the &lt;code&gt;Component&lt;/code&gt; class.                
                <return>
                    the color model of this toolkit's screen.                    
                </return>
                <exception>
                    HeadlessException if GraphicsEnvironment.isHeadless()
                      returns true                    
                </exception>
                <see>
                    java.awt.GraphicsEnvironment#isHeadless                    
                </see>
                <see>
                    java.awt.image.ColorModel                    
                </see>
                <see>
                    java.awt.Component#getColorModel                    
                </see>
            </javadoc>
            <method name="getFontList" type="String[]" line="639"/>
            <javadoc line="639">
                Returns the names of the available fonts in this toolkit.&lt;p&gt;
                  For 1.1, the following font names are deprecated (the replacement
                  name follows):
                  &lt;ul&gt;
                  &lt;li&gt;TimesRoman (use Serif)
                  &lt;li&gt;Helvetica (use SansSerif)
                  &lt;li&gt;Courier (use Monospaced)
                  &lt;/ul&gt;&lt;p&gt;
                  The ZapfDingbats fontname is also deprecated in 1.1 but the characters
                  are defined in Unicode starting at 0x2700, and as of 1.1 Java supports
                  those characters.                
                <return>
                    the names of the available fonts in this toolkit.                    
                </return>
                <deprecated>
                    see {@link java.awt.GraphicsEnvironment#getAvailableFontFamilyNames()}                    
                </deprecated>
                <see>
                    java.awt.GraphicsEnvironment#getAvailableFontFamilyNames()                    
                </see>
            </javadoc>
            <method name="getFontMetrics" type="FontMetrics" line="658"/>
            <javadoc line="658">
                Gets the screen device metrics for rendering of the font.                
                <param>
                    font   a font                    
                </param>
                <return>
                    the screen metrics of the specified font in this toolkit                    
                </return>
                <deprecated>
                    As of JDK version 1.2, replaced by the <code>Font</code>
                      method <code>getLineMetrics</code>.                    
                </deprecated>
                <see>
                    java.awt.font.LineMetrics                    
                </see>
                <see>
                    java.awt.Font#getLineMetrics                    
                </see>
                <see>
                    java.awt.GraphicsEnvironment#getScreenDevices                    
                </see>
            </javadoc>
            <method name="sync" type="void" line="671"/>
            <javadoc line="671">
                Synchronizes this toolkit&apos;s graphics state. Some window systems
                  may do buffering of graphics events.
                  &lt;p&gt;
                  This method ensures that the display is up-to-date. It is useful
                  for animation.                
            </javadoc>
            <declaration name="toolkit" type="Toolkit" line="680"/>
            <javadoc line="680">
                The default toolkit.                
            </javadoc>
            <declaration name="atNames" type="String" line="685"/>
            <javadoc line="685">
                Used internally by the assistive technologies functions; set at
                  init time and used at load time                
            </javadoc>
            <javadoc line="691">
                Initializes properties related to assistive technologies.
                  These properties are used both in the loadAssistiveProperties()
                  function below, as well as other classes in the jdk that depend
                  on the properties (such as the use of the screen_magnifier_present
                  property in Java2D hardware acceleration initialization).  The
                  initialization of the properties must be done before the platform-
                  specific Toolkit class is instantiated so that all necessary
                  properties are set up properly before any classes dependent upon them
                  are initialized.                
            </javadoc>
            <method name="initAssistiveTechnologies" type="void" line="702">
                <comment line="704">
                    Get accessibility properties                    
                </comment>
                <comment line="713">
                    Try loading the per-user accessibility properties file.                    
                </comment>
                <comment line="721">
                    Inputstream has been buffered in Properties class                    
                </comment>
                <comment line="725">
                    Per-user accessibility properties file does not exist                    
                </comment>
                <comment line="728">
                    Try loading the system-wide accessibility properties                    
                </comment>
                <comment line="729">
                    file only if a per-user accessibility properties                    
                </comment>
                <comment line="730">
                    file does not exist or is empty.                    
                </comment>
                <comment line="739">
                    Inputstream has been buffered in Properties class                    
                </comment>
                <comment line="743">
                    System-wide accessibility properties file does                    
                </comment>
                <comment line="744">
                    not exist;                    
                </comment>
                <comment line="748">
                    Get whether a screen magnifier is present.  First check                    
                </comment>
                <comment line="749">
                    the system property and then check the properties file.                    
                </comment>
                <comment line="758">
                    Get the names of any assistive technolgies to load.  First                    
                </comment>
                <comment line="759">
                    check the system property and then check the properties                    
                </comment>
                <comment line="760">
                    file.                    
                </comment>
                <declaration name="sep" type="String" line="705"/>
                <declaration name="properties" type="Properties" line="706"/>
                <anonymous_class line="710">
                    <method name="run" type="Object" line="711">
                        <comment line="713">
                            Try loading the per-user accessibility properties file.                            
                        </comment>
                        <comment line="721">
                            Inputstream has been buffered in Properties class                            
                        </comment>
                        <comment line="725">
                            Per-user accessibility properties file does not exist                            
                        </comment>
                        <comment line="728">
                            Try loading the system-wide accessibility properties                            
                        </comment>
                        <comment line="729">
                            file only if a per-user accessibility properties                            
                        </comment>
                        <comment line="730">
                            file does not exist or is empty.                            
                        </comment>
                        <comment line="739">
                            Inputstream has been buffered in Properties class                            
                        </comment>
                        <comment line="743">
                            System-wide accessibility properties file does                            
                        </comment>
                        <comment line="744">
                            not exist;                            
                        </comment>
                        <comment line="748">
                            Get whether a screen magnifier is present.  First check                            
                        </comment>
                        <comment line="749">
                            the system property and then check the properties file.                            
                        </comment>
                        <comment line="758">
                            Get the names of any assistive technolgies to load.  First                            
                        </comment>
                        <comment line="759">
                            check the system property and then check the properties                            
                        </comment>
                        <comment line="760">
                            file.                            
                        </comment>
                        <scope line="714">
                            <declaration name="propsFile" type="File" line="715"/>
                            <declaration name="in" type="FileInputStream" line="718"/>
                        </scope>
                        <scope line="724"/>
                        <scope line="731">
                            <scope line="732">
                                <declaration name="propsFile" type="File" line="733"/>
                                <declaration name="in" type="FileInputStream" line="736"/>
                            </scope>
                            <scope line="742"/>
                        </scope>
                        <declaration name="magPresent" type="String" line="750"/>
                        <scope line="751">
                            <scope line="753"/>
                        </scope>
                        <declaration name="classNames" type="String" line="761"/>
                        <scope line="762">
                            <scope line="764"/>
                        </scope>
                    </method>
                </anonymous_class>
            </method>
            <javadoc line="773">
                Loads additional classes into the VM, using the property
                  &apos;assistive_technologies&apos; specified in the Sun reference
                  implementation by a line in the &apos;accessibility.properties&apos;
                  file.  The form is &quot;assistive_technologies=...&quot; where
                  the &quot;...&quot; is a comma-separated list of assistive technology
                  classes to load.  Each class is loaded in the order given
                  and a single instance of each is created using
                  Class.forName(class).newInstance().  All errors are handled
                  via an AWTError exception.
                  &lt;p&gt;The assumption is made that assistive technology classes are supplied
                  as part of INSTALLED (as opposed to: BUNDLED) extensions or specified
                  on the class path
                  (and therefore can be loaded using the class loader returned by
                  a call to &lt;code&gt;ClassLoader.getSystemClassLoader&lt;/code&gt;, whose
                  delegation parent is the extension class loader for installed
                  extensions).                
            </javadoc>
            <method name="loadAssistiveTechnologies" type="void" line="792">
                <comment line="793">
                    Load any assistive technologies                    
                </comment>
                <scope line="794">
                    <declaration name="cl" type="ClassLoader" line="795"/>
                    <declaration name="parser" type="StringTokenizer" line="796"/>
                    <declaration name="atName" type="String" line="797"/>
                    <scope line="798">
                        <scope line="800">
                            <declaration name="clazz" type="Class" line="801"/>
                            <scope line="802"/>
                            <scope line="804"/>
                        </scope>
                        <scope line="808"/>
                        <scope line="811"/>
                        <scope line="814"/>
                        <scope line="817"/>
                    </scope>
                </scope>
            </method>
            <javadoc line="825">
                Gets the default toolkit.
                  &lt;p&gt;
                  If a system property named &lt;code&gt;&quot;java.awt.headless&quot;&lt;/code&gt; is set
                  to &lt;code&gt;true&lt;/code&gt; then the headless implementation
                  of &lt;code&gt;Toolkit&lt;/code&gt; is used.
                  &lt;p&gt;
                  If there is no &lt;code&gt;&quot;java.awt.headless&quot;&lt;/code&gt; or it is set to
                  &lt;code&gt;false&lt;/code&gt; and there is a system property named
                  &lt;code&gt;&quot;awt.toolkit&quot;&lt;/code&gt;,
                  that property is treated as the name of a class that is a subclass
                  of &lt;code&gt;Toolkit&lt;/code&gt;;
                  otherwise the default platform-specific implementation of
                  &lt;code&gt;Toolkit&lt;/code&gt; is used.
                  &lt;p&gt;
                  Also loads additional classes into the VM, using the property
                  &apos;assistive_technologies&apos; specified in the Sun reference
                  implementation by a line in the &apos;accessibility.properties&apos;
                  file.  The form is &quot;assistive_technologies=...&quot; where
                  the &quot;...&quot; is a comma-separated list of assistive technology
                  classes to load.  Each class is loaded in the order given
                  and a single instance of each is created using
                  Class.forName(class).newInstance().  This is done just after
                  the AWT toolkit is created.  All errors are handled via an
                  AWTError exception.                
                <return>
                    the default toolkit.                    
                </return>
                <exception>
                    AWTError  if a toolkit could not be found, or
                      if one could not be accessed or instantiated.                    
                </exception>
            </javadoc>
            <method name="getDefaultToolkit" type="Toolkit" line="854">
                <comment line="857">
                    We disable the JIT during toolkit initialization.  This                    
                </comment>
                <comment line="858">
                    tends to touch lots of classes that aren&apos;t needed again                    
                </comment>
                <comment line="859">
                    later and therefore JITing is counter-productiive.                    
                </comment>
                <comment line="897">
                    Make sure to always re-enable the JIT.                    
                </comment>
                <scope line="855">
                    <scope line="856">
                        <anonymous_class line="863">
                            <method name="run" type="Object" line="864">
                                <declaration name="nm" type="String" line="865"/>
                                <declaration name="cls" type="Class" line="866"/>
                                <scope line="867">
                                    <scope line="869"/>
                                    <scope line="871">
                                        <declaration name="cl" type="ClassLoader" line="872"/>
                                        <scope line="873">
                                            <scope line="874"/>
                                            <scope line="876"/>
                                        </scope>
                                    </scope>
                                    <scope line="881">
                                        <scope line="883"/>
                                    </scope>
                                </scope>
                                <scope line="887"/>
                                <scope line="889"/>
                            </method>
                        </anonymous_class>
                    </scope>
                    <scope line="896"/>
                </scope>
            </method>
            <method name="getImage" type="Image" line="904"/>
            <javadoc line="904">
                Returns an image which gets pixel data from the specified file,
                  whose format can be either GIF, JPEG or PNG.
                  The underlying toolkit attempts to resolve multiple requests
                  with the same filename to the same returned Image.
                  &lt;p&gt;
                  Since the mechanism required to facilitate this sharing of
                  &lt;code&gt;Image&lt;/code&gt; objects may continue to hold onto images
                  that are no longer in use for an indefinite period of time,
                  developers are encouraged to implement their own caching of
                  images by using the {@link #createImage(java.lang.String) createImage}variant wherever available.
                  If the image data contained in the specified file changes,
                  the &lt;code&gt;Image&lt;/code&gt; object returned from this method may
                  still contain stale information which was loaded from the
                  file after a prior call.
                  Previously loaded image data can be manually discarded by
                  calling the {@link Image#flush flush} method on the
                  returned &lt;code&gt;Image&lt;/code&gt;.
                  &lt;p&gt;
                  This method first checks if there is a security manager installed.
                  If so, the method calls the security manager&apos;s
                  &lt;code&gt;checkRead&lt;/code&gt; method with the file specified to ensure
                  that the access to the image is allowed.                
                <param>
                    filename   the name of a file containing pixel data
                      in a recognized file format.                    
                </param>
                <return>
                    an image which gets its pixel data from
                      the specified file.                    
                </return>
                <throws>
                    SecurityException  if a security manager exists and its
                      checkRead method doesn't allow the operation.                    
                </throws>
                <see>
                    #createImage(java.lang.String)                    
                </see>
            </javadoc>
            <method name="getImage" type="Image" line="938"/>
            <javadoc line="938">
                Returns an image which gets pixel data from the specified URL.
                  The pixel data referenced by the specified URL must be in one
                  of the following formats: GIF, JPEG or PNG.
                  The underlying toolkit attempts to resolve multiple requests
                  with the same URL to the same returned Image.
                  &lt;p&gt;
                  Since the mechanism required to facilitate this sharing of
                  &lt;code&gt;Image&lt;/code&gt; objects may continue to hold onto images
                  that are no longer in use for an indefinite period of time,
                  developers are encouraged to implement their own caching of
                  images by using the {@link #createImage(java.net.URL) createImage}variant wherever available.
                  If the image data stored at the specified URL changes,
                  the &lt;code&gt;Image&lt;/code&gt; object returned from this method may
                  still contain stale information which was fetched from the
                  URL after a prior call.
                  Previously loaded image data can be manually discarded by
                  calling the {@link Image#flush flush} method on the
                  returned &lt;code&gt;Image&lt;/code&gt;.
                  &lt;p&gt;
                  This method first checks if there is a security manager installed.
                  If so, the method calls the security manager&apos;s
                  &lt;code&gt;checkPermission&lt;/code&gt; method with the
                  url.openConnection().getPermission() permission to ensure
                  that the access to the image is allowed. For compatibility
                  with pre-1.2 security managers, if the access is denied with
                  &lt;code&gt;FilePermission&lt;/code&gt; or &lt;code&gt;SocketPermission&lt;/code&gt;,
                  the method throws the &lt;code&gt;SecurityException&lt;/code&gt;
                  if the corresponding 1.1-style SecurityManager.checkXXX method
                  also denies permission.                
                <param>
                    url   the URL to use in fetching the pixel data.                    
                </param>
                <return>
                    an image which gets its pixel data from
                      the specified URL.                    
                </return>
                <throws>
                    SecurityException  if a security manager exists and its
                      checkPermission method doesn't allow
                      the operation.                    
                </throws>
                <see>
                    #createImage(java.net.URL)                    
                </see>
            </javadoc>
            <method name="createImage" type="Image" line="979"/>
            <javadoc line="979">
                Returns an image which gets pixel data from the specified file.
                  The returned Image is a new object which will not be shared
                  with any other caller of this method or its getImage variant.
                  &lt;p&gt;
                  This method first checks if there is a security manager installed.
                  If so, the method calls the security manager&apos;s
                  &lt;code&gt;checkRead&lt;/code&gt; method with the specified file to ensure
                  that the image creation is allowed.                
                <param>
                    filename   the name of a file containing pixel data
                      in a recognized file format.                    
                </param>
                <return>
                    an image which gets its pixel data from
                      the specified file.                    
                </return>
                <throws>
                    SecurityException  if a security manager exists and its
                      checkRead method doesn't allow the operation.                    
                </throws>
                <see>
                    #getImage(java.lang.String)                    
                </see>
            </javadoc>
            <method name="createImage" type="Image" line="998"/>
            <javadoc line="998">
                Returns an image which gets pixel data from the specified URL.
                  The returned Image is a new object which will not be shared
                  with any other caller of this method or its getImage variant.
                  &lt;p&gt;
                  This method first checks if there is a security manager installed.
                  If so, the method calls the security manager&apos;s
                  &lt;code&gt;checkPermission&lt;/code&gt; method with the
                  url.openConnection().getPermission() permission to ensure
                  that the image creation is allowed. For compatibility
                  with pre-1.2 security managers, if the access is denied with
                  &lt;code&gt;FilePermission&lt;/code&gt; or &lt;code&gt;SocketPermission&lt;/code&gt;,
                  the method throws &lt;code&gt;SecurityException&lt;/code&gt;
                  if the corresponding 1.1-style SecurityManager.checkXXX method
                  also denies permission.                
                <param>
                    url   the URL to use in fetching the pixel data.                    
                </param>
                <return>
                    an image which gets its pixel data from
                      the specified URL.                    
                </return>
                <throws>
                    SecurityException  if a security manager exists and its
                      checkPermission method doesn't allow
                      the operation.                    
                </throws>
                <see>
                    #getImage(java.net.URL)                    
                </see>
            </javadoc>
            <method name="prepareImage" type="boolean" line="1023"/>
            <javadoc line="1023">
                Prepares an image for rendering.
                  &lt;p&gt;
                  If the values of the width and height arguments are both
                  &lt;code&gt;-1&lt;/code&gt;, this method prepares the image for rendering
                  on the default screen; otherwise, this method prepares an image
                  for rendering on the default screen at the specified width and height.
                  &lt;p&gt;
                  The image data is downloaded asynchronously in another thread,
                  and an appropriately scaled screen representation of the image is
                  generated.
                  &lt;p&gt;
                  This method is called by components &lt;code&gt;prepareImage&lt;/code&gt;
                  methods.
                  &lt;p&gt;
                  Information on the flags returned by this method can be found
                  with the definition of the &lt;code&gt;ImageObserver&lt;/code&gt; interface.                
                <param>
                    image      the image for which to prepare a
                      screen representation.                    
                </param>
                <param>
                    width      the width of the desired screen
                      representation, or <code>-1</code>.                    
                </param>
                <param>
                    height     the height of the desired screen
                      representation, or <code>-1</code>.                    
                </param>
                <param>
                    observer   the <code>ImageObserver</code>
                      object to be notified as the
                      image is being prepared.                    
                </param>
                <return>
                    <code>true</code> if the image has already been
                      fully prepared; <code>false</code> otherwise.                    
                </return>
                <see>
                    java.awt.Component#prepareImage(java.awt.Image,java.awt.image.ImageObserver)                    
                </see>
                <see>
                    java.awt.Component#prepareImage(java.awt.Image,int,int,java.awt.image.ImageObserver)                    
                </see>
                <see>
                    java.awt.image.ImageObserver                    
                </see>
            </javadoc>
            <method name="checkImage" type="int" line="1061"/>
            <javadoc line="1061">
                Indicates the construction status of a specified image that is
                  being prepared for display.
                  &lt;p&gt;
                  If the values of the width and height arguments are both
                  &lt;code&gt;-1&lt;/code&gt;, this method returns the construction status of
                  a screen representation of the specified image in this toolkit.
                  Otherwise, this method returns the construction status of a
                  scaled representation of the image at the specified width
                  and height.
                  &lt;p&gt;
                  This method does not cause the image to begin loading.
                  An application must call &lt;code&gt;prepareImage&lt;/code&gt; to force
                  the loading of an image.
                  &lt;p&gt;
                  This method is called by the component&apos;s &lt;code&gt;checkImage&lt;/code&gt;
                  methods.
                  &lt;p&gt;
                  Information on the flags returned by this method can be found
                  with the definition of the &lt;code&gt;ImageObserver&lt;/code&gt; interface.                
                <param>
                    image   the image whose status is being checked.                    
                </param>
                <param>
                    width   the width of the scaled version whose status is
                      being checked, or <code>-1</code>.                    
                </param>
                <param>
                    height  the height of the scaled version whose status
                      is being checked, or <code>-1</code>.                    
                </param>
                <param>
                    observer   the <code>ImageObserver</code> object to be
                      notified as the image is being prepared.                    
                </param>
                <return>
                    the bitwise inclusive <strong>OR</strong> of the
                      <code>ImageObserver</code> flags for the
                      image data that is currently available.                    
                </return>
                <see>
                    java.awt.Toolkit#prepareImage(java.awt.Image,int,int,java.awt.image.ImageObserver)                    
                </see>
                <see>
                    java.awt.Component#checkImage(java.awt.Image,java.awt.image.ImageObserver)                    
                </see>
                <see>
                    java.awt.Component#checkImage(java.awt.Image,int,int,java.awt.image.ImageObserver)                    
                </see>
                <see>
                    java.awt.image.ImageObserver                    
                </see>
            </javadoc>
            <method name="createImage" type="Image" line="1102"/>
            <javadoc line="1102">
                Creates an image with the specified image producer.                
                <param>
                    producer the image producer to be used.                    
                </param>
                <return>
                    an image with the specified image producer.                    
                </return>
                <see>
                    java.awt.Image                    
                </see>
                <see>
                    java.awt.image.ImageProducer                    
                </see>
                <see>
                    java.awt.Component#createImage(java.awt.image.ImageProducer)                    
                </see>
            </javadoc>
            <javadoc line="1112">
                Creates an image which decodes the image stored in the specified
                  byte array.
                  &lt;p&gt;
                  The data must be in some image format, such as GIF or JPEG,
                  that is supported by this toolkit.                
                <param>
                    imagedata   an array of bytes, representing
                      image data in a supported image format.                    
                </param>
                <return>
                    an image.                    
                </return>
                <since>
                    JDK1.1                    
                </since>
            </javadoc>
            <method name="createImage" type="Image" line="1123">
                <params>
                    <param name="imagedata" type="byte[]"/>
                </params>
            </method>
            <method name="createImage" type="Image" line="1127"/>
            <javadoc line="1127">
                Creates an image which decodes the image stored in the specified
                  byte array, and at the specified offset and length.
                  The data must be in some image format, such as GIF or JPEG,
                  that is supported by this toolkit.                
                <param>
                    imagedata   an array of bytes, representing
                      image data in a supported image format.                    
                </param>
                <param>
                    imageoffset  the offset of the beginning
                      of the data in the array.                    
                </param>
                <param>
                    imagelength  the length of the data in the array.                    
                </param>
                <return>
                    an image.                    
                </return>
                <since>
                    JDK1.1                    
                </since>
            </javadoc>
            <method name="getPrintJob" type="PrintJob" line="1144"/>
            <javadoc line="1144">
                Gets a &lt;code&gt;PrintJob&lt;/code&gt; object which is the result of initiating
                  a print operation on the toolkit&apos;s platform.
                  &lt;p&gt;
                  Each actual implementation of this method should first check if there
                  is a security manager installed. If there is, the method should call
                  the security manager&apos;s &lt;code&gt;checkPrintJobAccess&lt;/code&gt; method to
                  ensure initiation of a print operation is allowed. If the default
                  implementation of &lt;code&gt;checkPrintJobAccess&lt;/code&gt; is used (that is,
                  that method is not overriden), then this results in a call to the
                  security manager&apos;s &lt;code&gt;checkPermission&lt;/code&gt; method with a &lt;code&gt;
                  RuntimePermission(&quot;queuePrintJob&quot;)&lt;/code&gt; permission.                
                <param>
                    frame the parent of the print dialog. May not be null.                    
                </param>
                <param>
                    jobtitle the title of the PrintJob. A null title is equivalent
                      to "".                    
                </param>
                <param>
                    props a Properties object containing zero or more properties.
                      Properties are not standardized and are not consistent across
                      implementations. Because of this, PrintJobs which require job
                      and page control should use the version of this function which
                      takes JobAttributes and PageAttributes objects. This object
                      may be updated to reflect the user's job choices on exit. May
                      be null.                    
                </param>
                <return>
                    a <code>PrintJob</code> object, or <code>null</code> if the
                      user cancelled the print job.                    
                </return>
                <throws>
                    NullPointerException if frame is null                    
                </throws>
                <throws>
                    SecurityException if this thread is not allowed to initiate a
                      print job request                    
                </throws>
                <see>
                    java.awt.GraphicsEnvironment#isHeadless                    
                </see>
                <see>
                    java.awt.PrintJob                    
                </see>
                <see>
                    java.lang.RuntimePermission                    
                </see>
                <since>
                    JDK1.1                    
                </since>
            </javadoc>
            <javadoc line="1180">
                Gets a &lt;code&gt;PrintJob&lt;/code&gt; object which is the result of initiating
                  a print operation on the toolkit&apos;s platform.
                  &lt;p&gt;
                  Each actual implementation of this method should first check if there
                  is a security manager installed. If there is, the method should call
                  the security manager&apos;s &lt;code&gt;checkPrintJobAccess&lt;/code&gt; method to
                  ensure initiation of a print operation is allowed. If the default
                  implementation of &lt;code&gt;checkPrintJobAccess&lt;/code&gt; is used (that is,
                  that method is not overriden), then this results in a call to the
                  security manager&apos;s &lt;code&gt;checkPermission&lt;/code&gt; method with a &lt;code&gt;
                  RuntimePermission(&quot;queuePrintJob&quot;)&lt;/code&gt; permission.                
                <param>
                    frame the parent of the print dialog. May not be null.                    
                </param>
                <param>
                    jobtitle the title of the PrintJob. A null title is equivalent
                      to "".                    
                </param>
                <param>
                    jobAttributes a set of job attributes which will control the
                      PrintJob. The attributes will be updated to reflect the user's
                      choices as outlined in the JobAttributes documentation. May be
                      null.                    
                </param>
                <param>
                    pageAttributes a set of page attributes which will control the
                      PrintJob. The attributes will be applied to every page in the
                      job. The attributes will be updated to reflect the user's
                      choices as outlined in the PageAttributes documentation. May be
                      null.                    
                </param>
                <return>
                    a <code>PrintJob</code> object, or <code>null</code> if the
                      user cancelled the print job.                    
                </return>
                <throws>
                    NullPointerException if frame is null                    
                </throws>
                <throws>
                    IllegalArgumentException if pageAttributes specifies differing
                      cross feed and feed resolutions. Also if this thread has
                      access to the file system and jobAttributes specifies
                      print to file, and the specified destination file exists but
                      is a directory rather than a regular file, does not exist but
                      cannot be created, or cannot be opened for any other reason.
                      However in the case of print to file, if a dialog is also
                      requested to be displayed then the user will be given an
                      opportunity to select a file and proceed with printing.
                      The dialog will ensure that the selected output file
                      is valid before returning from this method.                    
                </throws>
                <throws>
                    SecurityException if this thread is not allowed to initiate a
                      print job request, or if jobAttributes specifies print to file,
                      and this thread is not allowed to access the file system                    
                </throws>
                <see>
                    java.awt.PrintJob                    
                </see>
                <see>
                    java.awt.GraphicsEnvironment#isHeadless                    
                </see>
                <see>
                    java.lang.RuntimePermission                    
                </see>
                <see>
                    java.awt.JobAttributes                    
                </see>
                <see>
                    java.awt.PageAttributes                    
                </see>
                <since>
                    1.3                    
                </since>
            </javadoc>
            <method name="getPrintJob" type="PrintJob" line="1231">
                <params>
                    <param name="frame" type="Frame"/>
                    <param name="jobtitle" type="String"/>
                    <param name="jobAttributes" type="JobAttributes"/>
                    <param name="pageAttributes" type="PageAttributes"/>
                </params>
                <comment line="1232">
                    Override to add printing support with new job/page control classes                    
                </comment>
                <scope line="1234"/>
                <scope line="1238"/>
            </method>
            <method name="beep" type="void" line="1243"/>
            <javadoc line="1243">
                Emits an audio beep.                
                <since>
                    JDK1.1                    
                </since>
            </javadoc>
            <method name="getSystemClipboard" type="Clipboard" line="1249"/>
            <javadoc line="1249">
                Gets the singleton instance of the system Clipboard which interfaces
                  with clipboard facilities provided by the native platform. This
                  clipboard enables data transfer between Java programs and native
                  applications which use native clipboard facilities.
                  &lt;p&gt;
                  In addition to any and all formats specified in the flavormap.properties
                  file, or other file specified by the &lt;code&gt;AWT.DnD.flavorMapFileURL
                  &lt;/code&gt; Toolkit property, text returned by the system Clipboard&apos;s &lt;code&gt;
                  getTransferData()&lt;/code&gt; method is available in the following flavors:
                  &lt;ul&gt;
                  &lt;li&gt;DataFlavor.stringFlavor&lt;/li&gt;
                  &lt;li&gt;DataFlavor.plainTextFlavor (&lt;b&gt;deprecated&lt;/b&gt;)&lt;/li&gt;
                  &lt;/ul&gt;
                  As with &lt;code&gt;java.awt.datatransfer.StringSelection&lt;/code&gt;, if the
                  requested flavor is &lt;code&gt;DataFlavor.plainTextFlavor&lt;/code&gt;, or an
                  equivalent flavor, a Reader is returned. &lt;b&gt;Note:&lt;/b&gt; The behavior of
                  the system Clipboard&apos;s &lt;code&gt;getTransferData()&lt;/code&gt; method for &lt;code&gt;
                  DataFlavor.plainTextFlavor&lt;/code&gt;, and equivalent DataFlavors, is
                  inconsistent with the definition of &lt;code&gt;DataFlavor.plainTextFlavor
                  &lt;/code&gt;. Because of this, support for &lt;code&gt;
                  DataFlavor.plainTextFlavor&lt;/code&gt;, and equivalent flavors, is
                  &lt;b&gt;deprecated&lt;/b&gt;.
                  &lt;p&gt;
                  Each actual implementation of this method should first check if there
                  is a security manager installed. If there is, the method should call
                  the security manager&apos;s &lt;code&gt;checkSystemClipboardAccess&lt;/code&gt; method
                  to ensure it&apos;s ok to to access the system clipboard. If the default
                  implementation of &lt;code&gt;checkSystemClipboardAccess&lt;/code&gt; is used (that
                  is, that method is not overriden), then this results in a call to the
                  security manager&apos;s &lt;code&gt;checkPermission&lt;/code&gt; method with an &lt;code&gt;
                  AWTPermission(&quot;accessClipboard&quot;)&lt;/code&gt; permission.                
                <return>
                    the system Clipboard                    
                </return>
                <exception>
                    HeadlessException if GraphicsEnvironment.isHeadless()
                      returns true                    
                </exception>
                <see>
                    java.awt.GraphicsEnvironment#isHeadless                    
                </see>
                <see>
                    java.awt.datatransfer.Clipboard                    
                </see>
                <see>
                    java.awt.datatransfer.StringSelection                    
                </see>
                <see>
                    java.awt.datatransfer.DataFlavor#stringFlavor                    
                </see>
                <see>
                    java.awt.datatransfer.DataFlavor#plainTextFlavor                    
                </see>
                <see>
                    java.io.Reader                    
                </see>
                <see>
                    java.awt.AWTPermission                    
                </see>
                <since>
                    JDK1.1                    
                </since>
            </javadoc>
            <javadoc line="1297">
                Gets the singleton instance of the system selection as a
                  &lt;code&gt;Clipboard&lt;/code&gt; object. This allows an application to read and
                  modify the current, system-wide selection.
                  &lt;p&gt;
                  An application is responsible for updating the system selection whenever
                  the user selects text, using either the mouse or the keyboard.
                  Typically, this is implemented by installing a
                  &lt;code&gt;FocusListener&lt;/code&gt; on all &lt;code&gt;Component&lt;/code&gt;s which support
                  text selection, and, between &lt;code&gt;FOCUS_GAINED&lt;/code&gt; and
                  &lt;code&gt;FOCUS_LOST&lt;/code&gt; events delivered to that &lt;code&gt;Component&lt;/code&gt;,
                  updating the system selection &lt;code&gt;Clipboard&lt;/code&gt; when the selection
                  changes inside the &lt;code&gt;Component&lt;/code&gt;. Properly updating the system
                  selection ensures that a Java application will interact correctly with
                  native applications and other Java applications running simultaneously
                  on the system. Note that &lt;code&gt;java.awt.TextComponent&lt;/code&gt; and
                  &lt;code&gt;javax.swing.text.JTextComponent&lt;/code&gt; already adhere to this
                  policy. When using these classes, and their subclasses, developers need
                  not write any additional code.
                  &lt;p&gt;
                  Some platforms do not support a system selection &lt;code&gt;Clipboard&lt;/code&gt;.
                  On those platforms, this method will return &lt;code&gt;null&lt;/code&gt;. In such a
                  case, an application is absolved from its responsibility to update the
                  system selection &lt;code&gt;Clipboard&lt;/code&gt; as described above.
                  &lt;p&gt;
                  Each actual implementation of this method should first check if there
                  is a &lt;code&gt;SecurityManager&lt;/code&gt; installed. If there is, the method
                  should call the &lt;code&gt;SecurityManager&lt;/code&gt;&apos;s
                  &lt;code&gt;checkSystemClipboardAccess&lt;/code&gt; method to ensure that client
                  code has access the system selection. If the default implementation of
                  &lt;code&gt;checkSystemClipboardAccess&lt;/code&gt; is used (that is, if the method
                  is not overridden), then this results in a call to the
                  &lt;code&gt;SecurityManager&lt;/code&gt;&apos;s &lt;code&gt;checkPermission&lt;/code&gt; method with
                  an &lt;code&gt;AWTPermission(&quot;accessClipboard&quot;)&lt;/code&gt; permission.                
                <return>
                    the system selection as a <code>Clipboard</code>, or
                      <code>null</code> if the native platform does not support a
                      system selection <code>Clipboard</code>                    
                </return>
                <exception>
                    HeadlessException if GraphicsEnvironment.isHeadless()
                      returns true                    
                </exception>
                <see>
                    java.awt.datatransfer.Clipboard                    
                </see>
                <see>
                    java.awt.event.FocusListener                    
                </see>
                <see>
                    java.awt.event.FocusEvent#FOCUS_GAINED                    
                </see>
                <see>
                    java.awt.event.FocusEvent#FOCUS_LOST                    
                </see>
                <see>
                    TextComponent                    
                </see>
                <see>
                    javax.swing.text.JTextComponent                    
                </see>
                <see>
                    AWTPermission                    
                </see>
                <see>
                    GraphicsEnvironment#isHeadless                    
                </see>
                <since>
                    1.4                    
                </since>
            </javadoc>
            <method name="getSystemSelection" type="Clipboard" line="1348">
                <scope line="1351"/>
                <scope line="1353"/>
            </method>
            <javadoc line="1359">
                Determines which modifier key is the appropriate accelerator
                  key for menu shortcuts.
                  &lt;p&gt;
                  Menu shortcuts, which are embodied in the
                  &lt;code&gt;MenuShortcut&lt;/code&gt; class, are handled by the
                  &lt;code&gt;MenuBar&lt;/code&gt; class.
                  &lt;p&gt;
                  By default, this method returns &lt;code&gt;Event.CTRL_MASK&lt;/code&gt;.
                  Toolkit implementations should override this method if the
                  &lt;b&gt;Control&lt;/b&gt; key isn&apos;t the correct key for accelerators.                
                <return>
                    the modifier mask on the <code>Event</code> class
                      that is used for menu shortcuts on this toolkit.                    
                </return>
                <exception>
                    HeadlessException if GraphicsEnvironment.isHeadless()
                      returns true                    
                </exception>
                <see>
                    java.awt.GraphicsEnvironment#isHeadless                    
                </see>
                <see>
                    java.awt.MenuBar                    
                </see>
                <see>
                    java.awt.MenuShortcut                    
                </see>
                <since>
                    JDK1.1                    
                </since>
            </javadoc>
            <method name="getMenuShortcutKeyMask" type="int" line="1379"/>
            <javadoc line="1385">
                Returns whether the given locking key on the keyboard is currently in
                  its &quot;on&quot; state.
                  Valid key codes are{@link java.awt.event.KeyEvent#VK_CAPS_LOCK VK_CAPS_LOCK},{@link java.awt.event.KeyEvent#VK_NUM_LOCK VK_NUM_LOCK},{@link java.awt.event.KeyEvent#VK_SCROLL_LOCK VK_SCROLL_LOCK}, and{@link java.awt.event.KeyEvent#VK_KANA_LOCK VK_KANA_LOCK}.                
                <exception>
                    java.lang.IllegalArgumentException if <code>keyCode</code>
                      is not one of the valid key codes                    
                </exception>
                <exception>
                    java.lang.UnsupportedOperationException if the host system doesn't
                      allow getting the state of this key programmatically, or if the keyboard
                      doesn't have this key                    
                </exception>
                <exception>
                    HeadlessException if GraphicsEnvironment.isHeadless()
                      returns true                    
                </exception>
                <see>
                    java.awt.GraphicsEnvironment#isHeadless                    
                </see>
                <since>
                    1.3                    
                </since>
            </javadoc>
            <method name="getLockingKeyState" type="boolean" line="1406">
                <params>
                    <param name="keyCode" type="int"/>
                </params>
                <scope line="1410"/>
            </method>
            <javadoc line="1416">
                Sets the state of the given locking key on the keyboard.
                  Valid key codes are{@link java.awt.event.KeyEvent#VK_CAPS_LOCK VK_CAPS_LOCK},{@link java.awt.event.KeyEvent#VK_NUM_LOCK VK_NUM_LOCK},{@link java.awt.event.KeyEvent#VK_SCROLL_LOCK VK_SCROLL_LOCK}, and{@link java.awt.event.KeyEvent#VK_KANA_LOCK VK_KANA_LOCK}.
                  &lt;p&gt;
                  Depending on the platform, setting the state of a locking key may
                  involve event processing and therefore may not be immediately
                  observable through getLockingKeyState.                
                <exception>
                    java.lang.IllegalArgumentException if <code>keyCode</code>
                      is not one of the valid key codes                    
                </exception>
                <exception>
                    java.lang.UnsupportedOperationException if the host system doesn't
                      allow setting the state of this key programmatically, or if the keyboard
                      doesn't have this key                    
                </exception>
                <exception>
                    HeadlessException if GraphicsEnvironment.isHeadless()
                      returns true                    
                </exception>
                <see>
                    java.awt.GraphicsEnvironment#isHeadless                    
                </see>
                <since>
                    1.3                    
                </since>
            </javadoc>
            <method name="setLockingKeyState" type="void" line="1440">
                <params>
                    <param name="keyCode" type="int"/>
                    <param name="on" type="boolean"/>
                </params>
                <scope line="1444"/>
            </method>
            <javadoc line="1450">
                Give native peers the ability to query the native container
                  given a native component (eg the direct parent may be lightweight).                
            </javadoc>
            <method name="getNativeContainer" type="Container" line="1454">
                <params>
                    <param name="c" type="Component"/>
                </params>
            </method>
            <javadoc line="1458">
                Creates a new custom cursor object.
                  If the image to display is invalid, the cursor will be hidden (made
                  completely transparent), and the hotspot will be set to (0, 0).
                  &lt;p&gt;Note that multi-frame images are invalid and may cause this
                  method to hang.                
                <param>
                    cursor the image to display when the cursor is actived                    
                </param>
                <param>
                    hotSpot the X and Y of the large cursor's hot spot; the
                      hotSpot values must be less than the Dimension returned by
                      <code>getBestCursorSize</code>                    
                </param>
                <param>
                    name a localized description of the cursor, for Java Accessibility use                    
                </param>
                <exception>
                    IndexOutOfBoundsException if the hotSpot values are outside
                      the bounds of the cursor                    
                </exception>
                <exception>
                    HeadlessException if GraphicsEnvironment.isHeadless()
                      returns true                    
                </exception>
                <see>
                    java.awt.GraphicsEnvironment#isHeadless                    
                </see>
                <since>
                    1.2                    
                </since>
            </javadoc>
            <method name="createCustomCursor" type="Cursor" line="1480">
                <params>
                    <param name="cursor" type="Image"/>
                    <param name="hotSpot" type="Point"/>
                    <param name="name" type="String"/>
                </params>
                <comment line="1481">
                    Override to implement custom cursor support.                    
                </comment>
                <scope line="1482"/>
                <scope line="1485"/>
            </method>
            <javadoc line="1490">
                Returns the supported cursor dimension which is closest to the desired
                  sizes.  Systems which only support a single cursor size will return that
                  size regardless of the desired sizes.  Systems which don&apos;t support custom
                  cursors will return a dimension of 0, 0. &lt;p&gt;
                  Note:  if an image is used whose dimensions don&apos;t match a supported size
                  (as returned by this method), the Toolkit implementation will attempt to
                  resize the image to a supported size.
                  Since converting low-resolution images is difficult,
                  no guarantees are made as to the quality of a cursor image which isn&apos;t a
                  supported size.  It is therefore recommended that this method
                  be called and an appropriate image used so no image conversion is made.                
                <param>
                    preferredWidth the preferred cursor width the component would like
                      to use.                    
                </param>
                <param>
                    preferredHeight the preferred cursor height the component would like
                      to use.                    
                </param>
                <return>
                    the closest matching supported cursor size, or a dimension of 0,0 if
                      the Toolkit implementation doesn't support custom cursors.                    
                </return>
                <exception>
                    HeadlessException if GraphicsEnvironment.isHeadless()
                      returns true                    
                </exception>
                <see>
                    java.awt.GraphicsEnvironment#isHeadless                    
                </see>
                <since>
                    1.2                    
                </since>
            </javadoc>
            <method name="getBestCursorSize" type="Dimension" line="1515">
                <params>
                    <param name="preferredWidth" type="int"/>
                    <param name="preferredHeight" type="int"/>
                </params>
                <comment line="1518">
                    Override to implement custom cursor support.                    
                </comment>
                <scope line="1519"/>
                <scope line="1522"/>
            </method>
            <javadoc line="1527">
                Returns the maximum number of colors the Toolkit supports in a custom cursor
                  palette.&lt;p&gt;
                  Note: if an image is used which has more colors in its palette than
                  the supported maximum, the Toolkit implementation will attempt to flatten the
                  palette to the maximum.  Since converting low-resolution images is difficult,
                  no guarantees are made as to the quality of a cursor image which has more
                  colors than the system supports.  It is therefore recommended that this method
                  be called and an appropriate image used so no image conversion is made.                
                <return>
                    the maximum number of colors, or zero if custom cursors are not
                      supported by this Toolkit implementation.                    
                </return>
                <exception>
                    HeadlessException if GraphicsEnvironment.isHeadless()
                      returns true                    
                </exception>
                <see>
                    java.awt.GraphicsEnvironment#isHeadless                    
                </see>
                <since>
                    1.2                    
                </since>
            </javadoc>
            <method name="getMaximumCursorColors" type="int" line="1544">
                <comment line="1547">
                    Override to implement custom cursor support.                    
                </comment>
                <scope line="1548"/>
                <scope line="1550"/>
            </method>
            <javadoc line="1555">
                Returns whether Toolkit supports this state for
                  &lt;code&gt;Frame&lt;/code&gt;s.  This method tells whether the &lt;em&gt;UI
                  concept&lt;/em&gt; of, say, maximization or iconification is
                  supported.  It will always return false for &quot;compound&quot; states
                  like &lt;code&gt;Frame.ICONIFIED|Frame.MAXIMIZED_VERT&lt;/code&gt;.
                  In other words, the rule of thumb is that only queries with a
                  single frame state constant as an argument are meaningful.
                  &lt;p&gt;Note that supporting a given concept is a platform-
                  dependent feature. Due to native limitations the Toolkit
                  object may report a particular state as supported, however at
                  the same time the Toolkit object will be unable to apply the
                  state to a given frame.  This circumstance has two following
                  consequences:
                  &lt;ul&gt;
                  &lt;li&gt;Only the return value of {@code false} for the present
                  method actually indicates that the given state is not
                  supported. If the method returns {@code true} the given state
                  may still be unsupported and/or unavailable for a particular
                  frame.
                  &lt;li&gt;The developer should consider examining the value of the{@link java.awt.event.WindowEvent#getNewState} method of the{@code WindowEvent} received through the {@link java.awt.event.WindowStateListener}, rather than assuming
                  that the state given to the {@code setExtendedState()} method
                  will be definitely applied. For more information see the
                  documentation for the {@link Frame#setExtendedState} method.
                  &lt;/ul&gt;                
                <param>
                    state one of named frame state constants.                    
                </param>
                <return>
                    <code>true</code> is this frame state is supported by
                      this Toolkit implementation, <code>false</code> otherwise.                    
                </return>
                <exception>
                    HeadlessExceptionif <code>GraphicsEnvironment.isHeadless()</code>
                      returns <code>true</code>.                    
                </exception>
                <see>
                    java.awt.Window#addWindowStateListener                    
                </see>
                <since>
                    1.4                    
                </since>
            </javadoc>
            <method name="isFrameStateSupported" type="boolean" line="1595">
                <params>
                    <param name="state" type="int"/>
                </params>
                <comment line="1602">
                    others are not guaranteed                    
                </comment>
                <scope line="1598"/>
                <scope line="1601"/>
            </method>
            <declaration name="resources" type="ResourceBundle" line="1606"/>
            <javadoc line="1606">
                Support for I18N: any visible strings should be stored in
                  sun.awt.resources.awt.properties.  The ResourceBundle is stored
                  here, so that only one copy is maintained.                
            </javadoc>
            <method name="initIDs" type="void" line="1613"/>
            <javadoc line="1613">
                Initialize JNI field and method ids                
            </javadoc>
            <declaration name="loaded" type="boolean" line="1618"/>
            <javadoc line="1618">
                WARNING: This is a temporary workaround for a problem in the
                  way the AWT loads native libraries. A number of classes in the
                  AWT package have a native method, initIDs(), which initializes
                  the JNI field and method ids used in the native portion of
                  their implementation.
                  Since the use and storage of these ids is done by the
                  implementation libraries, the implementation of these method is
                  provided by the particular AWT implementations (for example,
                  &quot;Toolkit&quot;s/Peer), such as Motif, Microsoft Windows, or Tiny. The
                  problem is that this means that the native libraries must be
                  loaded by the java. classes, which do not necessarily know the
                  names of the libraries to load. A better way of doing this
                  would be to provide a separate library which defines java.awt.
                  initIDs, and exports the relevant symbols out to the
                  implementation libraries.
                  For now, we know it&apos;s done by the implementation, and we assume
                  that the name of the library is &quot;awt&quot;.  -br.
                  If you change loadLibraries(), please add the change to
                  java.awt.image.ColorModel.loadLibraries(). Unfortunately,
                  classes can be loaded in java.awt.image that depend on
                  libawt and there is no way to call Toolkit.loadLibraries()
                  directly.  -hung                
            </javadoc>
            <method name="loadLibraries" type="void" line="1646">
                <scope line="1647"/>
            </method>
            <scope line="1654">
                <anonymous_class line="1656">
                    <method name="run" type="Object" line="1657">
                        <comment line="1663">
                            No resource file; defaults will be used.                            
                        </comment>
                        <scope line="1658"/>
                        <scope line="1662"/>
                    </method>
                </anonymous_class>
                <scope line="1672"/>
            </scope>
            <javadoc line="1677">
                Gets a property with the specified key and default.
                  This method returns defaultValue if the property is not found.                
            </javadoc>
            <method name="getProperty" type="String" line="1681">
                <params>
                    <param name="key" type="String"/>
                    <param name="defaultValue" type="String"/>
                </params>
                <scope line="1682">
                    <scope line="1683"/>
                    <scope line="1686"/>
                </scope>
            </method>
            <javadoc line="1692">
                Get the application&apos;s or applet&apos;s EventQueue instance.
                  Depending on the Toolkit implementation, different EventQueues
                  may be returned for different applets.  Applets should
                  therefore not assume that the EventQueue instance returned
                  by this method will be shared by other applets or the system.
                  &lt;p&gt;First, if there is a security manager, its
                  &lt;code&gt;checkAwtEventQueueAccess&lt;/code&gt;
                  method is called.
                  If  the default implementation of &lt;code&gt;checkAwtEventQueueAccess&lt;/code&gt;
                  is used (that is, that method is not overriden), then this results in
                  a call to the security manager&apos;s &lt;code&gt;checkPermission&lt;/code&gt; method
                  with an &lt;code&gt;AWTPermission(&quot;accessEventQueue&quot;)&lt;/code&gt; permission.                
                <return>
                    the <code>EventQueue</code> object                    
                </return>
                <throws>
                    SecurityExceptionif a security manager exists and its <code>{@link java.lang.SecurityManager#checkAwtEventQueueAccess}</code>
                      method denies access to the <code>EventQueue</code>                    
                </throws>
                <see>
                    java.awt.AWTPermission                    
                </see>
            </javadoc>
            <method name="getSystemEventQueue" type="EventQueue" line="1714">
                <declaration name="security" type="SecurityManager" line="1715"/>
                <scope line="1716"/>
            </method>
            <method name="getSystemEventQueueImpl" type="EventQueue" line="1722"/>
            <javadoc line="1722">
                Gets the application&apos;s or applet&apos;s &lt;code&gt;EventQueue&lt;/code&gt;
                  instance, without checking access.  For security reasons,
                  this can only be called from a &lt;code&gt;Toolkit&lt;/code&gt; subclass.                
                <return>
                    the <code>EventQueue</code> object                    
                </return>
            </javadoc>
            <method name="getEventQueue" type="EventQueue" line="1731"/>
            <method name="createDragSourceContextPeer" type="DragSourceContextPeer" line="1735"/>
            <javadoc line="1735">
                Creates the peer for a DragSourceContext.
                  Always throws InvalidDndOperationException if
                  GraphicsEnvironment.isHeadless() returns true.                
                <see>
                    java.awt.GraphicsEnvironment#isHeadless                    
                </see>
            </javadoc>
            <javadoc line="1743">
                Creates a concrete, platform dependent, subclass of the abstract
                  DragGestureRecognizer class requested, and associates it with the
                  DragSource, Component and DragGestureListener specified.
                  subclasses should override this to provide their own implementation                
                <param>
                    abstractRecognizerClass The abstract class of the required recognizer                    
                </param>
                <param>
                    ds                      The DragSource                    
                </param>
                <param>
                    c                       The Component target for the DragGestureRecognizer                    
                </param>
                <param>
                    srcActions              The actions permitted for the gesture                    
                </param>
                <param>
                    dgl                     The DragGestureListener                    
                </param>
                <return>
                    the new object or null.  Always returns null if
                      GraphicsEnvironment.isHeadless() returns true.                    
                </return>
                <see>
                    java.awt.GraphicsEnvironment#isHeadless                    
                </see>
            </javadoc>
            <method name="createDragGestureRecognizer" type="T" line="1764">
                <params>
                    <param name="abstractRecognizerClass" type="Class<T>"/>
                    <param name="ds" type="DragSource"/>
                    <param name="c" type="Component"/>
                    <param name="srcActions" type="int"/>
                    <param name="dgl" type="DragGestureListener"/>
                </params>
            </method>
            <javadoc line="1768">
                Obtains a value for the specified desktop property.
                  A desktop property is a uniquely named value for a resource that
                  is Toolkit global in nature. Usually it also is an abstract
                  representation for an underlying platform dependent desktop setting.
                  For more information on desktop properties supported by the AWT see
                  &lt;a href=&quot;doc-files/DesktopProperties.html&quot;&gt;AWT Desktop Properties&lt;/a&gt;.                
            </javadoc>
            <method name="getDesktopProperty" type="Object" line="1777">
                <params>
                    <param name="propertyName" type="String"/>
                </params>
                <comment line="1778">
                    This is a workaround for headless toolkits.  It would be                    
                </comment>
                <comment line="1779">
                    better to override this method but it is declared final.                    
                </comment>
                <comment line="1780">
                    &quot;this instanceof&quot; syntax defeats polymorphism.                    
                </comment>
                <comment line="1781">
                    --mm, 03/03/00                    
                </comment>
                <comment line="1793">
                    This property should never be cached                    
                </comment>
                <comment line="1809">
                                        
                </comment>
                <scope line="1782"/>
                <scope line="1787"/>
                <declaration name="value" type="Object" line="1791"/>
                <scope line="1794"/>
                <scope line="1801">
                    <scope line="1804"/>
                </scope>
                <scope line="1810"/>
            </method>
            <javadoc line="1817">
                Sets the named desktop property to the specified value and fires a
                  property change event to notify any listeners that the value has changed.                
            </javadoc>
            <method name="setDesktopProperty" type="void" line="1821">
                <params>
                    <param name="name" type="String"/>
                    <param name="newValue" type="Object"/>
                </params>
                <comment line="1822">
                    This is a workaround for headless toolkits.  It would be                    
                </comment>
                <comment line="1823">
                    better to override this method but it is declared final.                    
                </comment>
                <comment line="1824">
                    &quot;this instanceof&quot; syntax defeats polymorphism.                    
                </comment>
                <comment line="1825">
                    --mm, 03/03/00                    
                </comment>
                <comment line="1838">
                    Don&apos;t fire change event if old and new values are null.                    
                </comment>
                <comment line="1839">
                    It helps to avoid recursive resending of WM_THEMECHANGED                    
                </comment>
                <scope line="1826"/>
                <declaration name="oldValue" type="Object" line="1831"/>
                <scope line="1833"/>
                <scope line="1840"/>
            </method>
            <javadoc line="1845">
                an opportunity to lazily evaluate desktop property values.                
            </javadoc>
            <method name="lazilyLoadDesktopProperty" type="Object" line="1848">
                <params>
                    <param name="name" type="String"/>
                </params>
            </method>
            <javadoc line="1852">
                initializeDesktopProperties                
            </javadoc>
            <method name="initializeDesktopProperties" type="void" line="1855"/>
            <javadoc line="1858">
                Adds the specified property change listener for the named desktop
                  property. When a {@link java.beans.PropertyChangeListenerProxy} object is added,
                  its property name is ignored, and the wrapped listener is added.
                  If {@code name} is {@code null} or {@code pcl} is {@code null},
                  no exception is thrown and no action is performed.                
                <param>
                    name The name of the property to listen for                    
                </param>
                <param>
                    pcl The property change listener                    
                </param>
                <see>
                    PropertyChangeSupport#addPropertyChangeListener(String,PropertyChangeListener)                    
                </see>
                <since>
                    1.2                    
                </since>
            </javadoc>
            <method name="addPropertyChangeListener" type="void" line="1871">
                <params>
                    <param name="name" type="String"/>
                    <param name="pcl" type="PropertyChangeListener"/>
                </params>
            </method>
            <javadoc line="1875">
                Removes the specified property change listener for the named
                  desktop property. When a {@link java.beans.PropertyChangeListenerProxy} object
                  is removed, its property name is ignored, and
                  the wrapped listener is removed.
                  If {@code name} is {@code null} or {@code pcl} is {@code null},
                  no exception is thrown and no action is performed.                
                <param>
                    name The name of the property to remove                    
                </param>
                <param>
                    pcl The property change listener                    
                </param>
                <see>
                    PropertyChangeSupport#removePropertyChangeListener(String,PropertyChangeListener)                    
                </see>
                <since>
                    1.2                    
                </since>
            </javadoc>
            <method name="removePropertyChangeListener" type="void" line="1889">
                <params>
                    <param name="name" type="String"/>
                    <param name="pcl" type="PropertyChangeListener"/>
                </params>
            </method>
            <javadoc line="1893">
                Returns an array of all the property change listeners
                  registered on this toolkit. The returned array
                  contains {@link java.beans.PropertyChangeListenerProxy} objects
                  that associate listeners with the names of desktop properties.                
                <return>
                    all of this toolkit's {@link PropertyChangeListener}objects wrapped in {@code java.beans.PropertyChangeListenerProxy} objects
                      or an empty array  if no listeners are added                    
                </return>
                <see>
                    PropertyChangeSupport#getPropertyChangeListeners()                    
                </see>
                <since>
                    1.4                    
                </since>
            </javadoc>
            <method name="getPropertyChangeListeners" type="PropertyChangeListener[]" line="1906"/>
            <javadoc line="1910">
                Returns an array of all property change listeners
                  associated with the specified name of a desktop property.                
                <param>
                    propertyName the named property                    
                </param>
                <return>
                    all of the {@code PropertyChangeListener} objects
                      associated with the specified name of a desktop property
                      or an empty array if no such listeners are added                    
                </return>
                <see>
                    PropertyChangeSupport#getPropertyChangeListeners(String)                    
                </see>
                <since>
                    1.4                    
                </since>
            </javadoc>
            <method name="getPropertyChangeListeners" type="PropertyChangeListener[]" line="1922">
                <params>
                    <param name="propertyName" type="String"/>
                </params>
            </method>
            <declaration name="desktopProperties" type="Map&lt;String,Object&gt;" line="1926"/>
            <declaration name="desktopPropsSupport" type="PropertyChangeSupport" line="1928"/>
            <javadoc line="1931">
                Returns whether the always-on-top mode is supported by this toolkit.
                  To detect whether the always-on-top mode is supported for a
                  particular Window, use {@link Window#isAlwaysOnTopSupported}.                
                <return>
                    <code>true</code>, if current toolkit supports the always-on-top mode,
                      otherwise returns <code>false</code>                    
                </return>
                <see>
                    Window#isAlwaysOnTopSupported                    
                </see>
                <see>
                    Window#setAlwaysOnTop(boolean)                    
                </see>
                <since>
                    1.6                    
                </since>
            </javadoc>
            <method name="isAlwaysOnTopSupported" type="boolean" line="1941"/>
            <method name="isModalityTypeSupported" type="boolean" line="1945"/>
            <javadoc line="1945">
                Returns whether the given modality type is supported by this toolkit. If
                  a dialog with unsupported modality type is created, then
                  &lt;code&gt;Dialog.ModalityType.MODELESS&lt;/code&gt; is used instead.                
                <param>
                    modalityType modality type to be checked for support by this toolkit                    
                </param>
                <return>
                    <code>true</code>, if current toolkit supports given modality
                      type, <code>false</code> otherwise                    
                </return>
                <see>
                    java.awt.Dialog.ModalityType                    
                </see>
                <see>
                    java.awt.Dialog#getModalityType                    
                </see>
                <see>
                    java.awt.Dialog#setModalityType                    
                </see>
                <since>
                    1.6                    
                </since>
            </javadoc>
            <method name="isModalExclusionTypeSupported" type="boolean" line="1963"/>
            <javadoc line="1963">
                Returns whether the given modal exclusion type is supported by this
                  toolkit. If an unsupported modal exclusion type property is set on a window,
                  then &lt;code&gt;Dialog.ModalExclusionType.NO_EXCLUDE&lt;/code&gt; is used instead.                
                <param>
                    modalExclusionType modal exclusion type to be checked for support by this toolkit                    
                </param>
                <return>
                    <code>true</code>, if current toolkit supports given modal exclusion
                      type, <code>false</code> otherwise                    
                </return>
                <see>
                    java.awt.Dialog.ModalExclusionType                    
                </see>
                <see>
                    java.awt.Window#getModalExclusionType                    
                </see>
                <see>
                    java.awt.Window#setModalExclusionType                    
                </see>
                <since>
                    1.6                    
                </since>
            </javadoc>
            <declaration name="log" type="PlatformLogger" line="1981"/>
            <declaration name="LONG_BITS" type="int" line="1983"/>
            <declaration name="calls" type="int[]" line="1984"/>
            <declaration name="enabledOnToolkitMask" type="long" line="1985"/>
            <declaration name="eventListener" type="AWTEventListener" line="1986"/>
            <declaration name="listener2SelectiveListener" type="WeakHashMap" line="1987"/>
            <method name="deProxyAWTEventListener" type="AWTEventListener" line="1994">
                <params>
                    <param name="l" type="AWTEventListener"/>
                </params>
                <comment line="2000">
                    if user passed in a AWTEventListenerProxy object, extract                    
                </comment>
                <comment line="2001">
                    the listener                    
                </comment>
                <declaration name="localL" type="AWTEventListener" line="1995"/>
                <scope line="1997"/>
                <scope line="2002"/>
            </method>
            <javadoc line="2008">
                Adds an AWTEventListener to receive all AWTEvents dispatched
                  system-wide that conform to the given &lt;code&gt;eventMask&lt;/code&gt;.
                  &lt;p&gt;
                  First, if there is a security manager, its &lt;code&gt;checkPermission&lt;/code&gt;
                  method is called with an
                  &lt;code&gt;AWTPermission(&quot;listenToAllAWTEvents&quot;)&lt;/code&gt; permission.
                  This may result in a SecurityException.
                  &lt;p&gt;
                  &lt;code&gt;eventMask&lt;/code&gt; is a bitmask of event types to receive.
                  It is constructed by bitwise OR-ing together the event masks
                  defined in &lt;code&gt;AWTEvent&lt;/code&gt;.
                  &lt;p&gt;
                  Note:  event listener use is not recommended for normal
                  application use, but are intended solely to support special
                  purpose facilities including support for accessibility,
                  event record/playback, and diagnostic tracing.
                  If listener is null, no exception is thrown and no action is performed.                
                <param>
                    listener   the event listener.                    
                </param>
                <param>
                    eventMask  the bitmask of event types to receive                    
                </param>
                <throws>
                    SecurityExceptionif a security manager exists and its
                      <code>checkPermission</code> method doesn't allow the operation.                    
                </throws>
                <see>
                    #removeAWTEventListener                    
                </see>
                <see>
                    #getAWTEventListeners                    
                </see>
                <see>
                    SecurityManager#checkPermission                    
                </see>
                <see>
                    java.awt.AWTEvent                    
                </see>
                <see>
                    java.awt.AWTPermission                    
                </see>
                <see>
                    java.awt.event.AWTEventListener                    
                </see>
                <see>
                    java.awt.event.AWTEventListenerProxy                    
                </see>
                <since>
                    1.2                    
                </since>
            </javadoc>
            <method name="addAWTEventListener" type="void" line="2042">
                <params>
                    <param name="listener" type="AWTEventListener"/>
                    <param name="eventMask" type="long"/>
                </params>
                <comment line="2057">
                    Create a new selectiveListener.                    
                </comment>
                <comment line="2064">
                    OR the eventMask into the selectiveListener&apos;s event mask.                    
                </comment>
                <comment line="2071">
                    If no bits are set, break out of loop.                    
                </comment>
                <comment line="2075">
                    Always test bit 0.                    
                </comment>
                <comment line="2078">
                    Right shift, fill with zeros on left.                    
                </comment>
                <declaration name="localL" type="AWTEventListener" line="2043"/>
                <scope line="2045"/>
                <declaration name="security" type="SecurityManager" line="2048"/>
                <scope line="2049"/>
                <scope line="2052">
                    <declaration name="selectiveListener" type="SelectiveAWTEventListener" line="2053"/>
                    <scope line="2056"/>
                    <declaration name="mask" type="long" line="2069"/>
                    <scope line="2070">
                        <scope line="2072"/>
                        <scope line="2075"/>
                    </scope>
                </scope>
            </method>
            <javadoc line="2083">
                Removes an AWTEventListener from receiving dispatched AWTEvents.
                  &lt;p&gt;
                  First, if there is a security manager, its &lt;code&gt;checkPermission&lt;/code&gt;
                  method is called with an
                  &lt;code&gt;AWTPermission(&quot;listenToAllAWTEvents&quot;)&lt;/code&gt; permission.
                  This may result in a SecurityException.
                  &lt;p&gt;
                  Note:  event listener use is not recommended for normal
                  application use, but are intended solely to support special
                  purpose facilities including support for accessibility,
                  event record/playback, and diagnostic tracing.
                  If listener is null, no exception is thrown and no action is performed.                
                <param>
                    listener   the event listener.                    
                </param>
                <throws>
                    SecurityExceptionif a security manager exists and its
                      <code>checkPermission</code> method doesn't allow the operation.                    
                </throws>
                <see>
                    #addAWTEventListener                    
                </see>
                <see>
                    #getAWTEventListeners                    
                </see>
                <see>
                    SecurityManager#checkPermission                    
                </see>
                <see>
                    java.awt.AWTEvent                    
                </see>
                <see>
                    java.awt.AWTPermission                    
                </see>
                <see>
                    java.awt.event.AWTEventListener                    
                </see>
                <see>
                    java.awt.event.AWTEventListenerProxy                    
                </see>
                <since>
                    1.2                    
                </since>
            </javadoc>
            <method name="removeAWTEventListener" type="void" line="2111">
                <params>
                    <param name="listener" type="AWTEventListener"/>
                </params>
                <declaration name="localL" type="AWTEventListener" line="2112"/>
                <scope line="2114"/>
                <declaration name="security" type="SecurityManager" line="2117"/>
                <scope line="2118"/>
                <scope line="2122">
                    <declaration name="selectiveListener" type="SelectiveAWTEventListener" line="2123"/>
                    <scope line="2126">
                        <declaration name="listenerCalls" type="int[]" line="2128"/>
                        <scope line="2129">
                            <scope line="2133"/>
                        </scope>
                    </scope>
                </scope>
            </method>
            <method name="enabledOnToolkit" type="boolean" line="2143">
                <params>
                    <param name="eventMask" type="long"/>
                </params>
            </method>
            <method name="countAWTEventListeners" type="int" line="2147">
                <params>
                    <param name="eventMask" type="long"/>
                </params>
                <scope line="2148">
                    <scope line="2149"/>
                </scope>
                <declaration name="ci" type="int" line="2154"/>
                <scope line="2155"/>
            </method>
            <javadoc line="2160">
                Returns an array of all the &lt;code&gt;AWTEventListener&lt;/code&gt;s
                  registered on this toolkit.
                  If there is a security manager, its {@code checkPermission}method is called with an{@code AWTPermission(&quot;listenToAllAWTEvents&quot;)} permission.
                  This may result in a SecurityException.
                  Listeners can be returned
                  within &lt;code&gt;AWTEventListenerProxy&lt;/code&gt; objects, which also contain
                  the event mask for the given listener.
                  Note that listener objects
                  added multiple times appear only once in the returned array.                
                <return>
                    all of the <code>AWTEventListener</code>s or an empty
                      array if no listeners are currently registered                    
                </return>
                <throws>
                    SecurityExceptionif a security manager exists and its
                      <code>checkPermission</code> method doesn't allow the operation.                    
                </throws>
                <see>
                    #addAWTEventListener                    
                </see>
                <see>
                    #removeAWTEventListener                    
                </see>
                <see>
                    SecurityManager#checkPermission                    
                </see>
                <see>
                    java.awt.AWTEvent                    
                </see>
                <see>
                    java.awt.AWTPermission                    
                </see>
                <see>
                    java.awt.event.AWTEventListener                    
                </see>
                <see>
                    java.awt.event.AWTEventListenerProxy                    
                </see>
                <since>
                    1.4                    
                </since>
            </javadoc>
            <method name="getAWTEventListeners" type="AWTEventListener[]" line="2187">
                <comment line="2199">
                    assert tempL is not an AWTEventListenerProxy - we should                    
                </comment>
                <comment line="2200">
                    have weeded them all out                    
                </comment>
                <comment line="2201">
                    don&apos;t want to wrap a proxy inside a proxy                    
                </comment>
                <declaration name="security" type="SecurityManager" line="2188"/>
                <scope line="2189"/>
                <scope line="2192">
                    <declaration name="la" type="EventListener[]" line="2193"/>
                    <declaration name="ret" type="AWTEventListener[]" line="2195"/>
                    <scope line="2196">
                        <declaration name="sael" type="SelectiveAWTEventListener" line="2197"/>
                        <declaration name="tempL" type="AWTEventListener" line="2198"/>
                    </scope>
                </scope>
            </method>
            <javadoc line="2208">
                Returns an array of all the &lt;code&gt;AWTEventListener&lt;/code&gt;s
                  registered on this toolkit which listen to all of the event
                  types specified in the {@code eventMask} argument.
                  If there is a security manager, its {@code checkPermission}method is called with an{@code AWTPermission(&quot;listenToAllAWTEvents&quot;)} permission.
                  This may result in a SecurityException.
                  Listeners can be returned
                  within &lt;code&gt;AWTEventListenerProxy&lt;/code&gt; objects, which also contain
                  the event mask for the given listener.
                  Note that listener objects
                  added multiple times appear only once in the returned array.                
                <param>
                    eventMask the bitmask of event types to listen for                    
                </param>
                <return>
                    all of the <code>AWTEventListener</code>s registered
                      on this toolkit for the specified
                      event types, or an empty array if no such listeners
                      are currently registered                    
                </return>
                <throws>
                    SecurityExceptionif a security manager exists and its
                      <code>checkPermission</code> method doesn't allow the operation.                    
                </throws>
                <see>
                    #addAWTEventListener                    
                </see>
                <see>
                    #removeAWTEventListener                    
                </see>
                <see>
                    SecurityManager#checkPermission                    
                </see>
                <see>
                    java.awt.AWTEvent                    
                </see>
                <see>
                    java.awt.AWTPermission                    
                </see>
                <see>
                    java.awt.event.AWTEventListener                    
                </see>
                <see>
                    java.awt.event.AWTEventListenerProxy                    
                </see>
                <since>
                    1.4                    
                </since>
            </javadoc>
            <method name="getAWTEventListeners" type="AWTEventListener[]" line="2239">
                <params>
                    <param name="eventMask" type="long"/>
                </params>
                <comment line="2252">
                    AWTEventListener tempL = sael.getListener();                    
                </comment>
                <declaration name="security" type="SecurityManager" line="2240"/>
                <scope line="2241"/>
                <scope line="2244">
                    <declaration name="la" type="EventListener[]" line="2245"/>
                    <declaration name="list" type="java.util.List" line="2247"/>
                    <scope line="2249">
                        <declaration name="sael" type="SelectiveAWTEventListener" line="2250"/>
                        <scope line="2251"/>
                    </scope>
                </scope>
            </method>
            <method name="notifyAWTEventListeners" type="void" line="2267">
                <params>
                    <param name="theEvent" type="AWTEvent"/>
                </params>
                <comment line="2268">
                    This is a workaround for headless toolkits.  It would be                    
                </comment>
                <comment line="2269">
                    better to override this method but it is declared package private.                    
                </comment>
                <comment line="2270">
                    &quot;this instanceof&quot; syntax defeats polymorphism.                    
                </comment>
                <comment line="2271">
                    --mm, 03/03/00                    
                </comment>
                <scope line="2272"/>
                <declaration name="eventListener" type="AWTEventListener" line="2278"/>
                <scope line="2279"/>
            </method>
            <class name="ToolkitEventMulticaster" line="2284">
                <extends class="AWTEventMulticaster"/>
                <comment line="2287">
                    Implementation cloned from AWTEventMulticaster.                    
                </comment>
                <comment line="2305">
                    #4178589: must overload remove(EventListener) to call our add()                    
                </comment>
                <comment line="2306">
                    instead of the static addInternal() so we allocate a                    
                </comment>
                <comment line="2307">
                    ToolkitEventMulticaster instead of an AWTEventMulticaster.                    
                </comment>
                <comment line="2308">
                    Note: this method is called by AWTEventListener.removeInternal(),                    
                </comment>
                <comment line="2309">
                    so its method signature must match AWTEventListener.remove().                    
                </comment>
                <comment line="2330">
                    This array contains the number of times to call the eventlistener                    
                </comment>
                <comment line="2331">
                    for each event type.                    
                </comment>
                <comment line="2541">
                    we do expect that all other fireXXX() methods of java.beans.PropertyChangeSupport
                     use this method.  If this will be changed we will need to change this class.                    
                </comment>
                <implements interface="AWTEventListener"/>
                <method name="ToolkitEventMulticaster" type="constructor" line="2288">
                    <params>
                        <param name="a" type="AWTEventListener"/>
                        <param name="b" type="AWTEventListener"/>
                    </params>
                </method>
                <method name="add" type="AWTEventListener" line="2293">
                    <params>
                        <param name="a" type="AWTEventListener"/>
                        <param name="b" type="AWTEventListener"/>
                    </params>
                </method>
                <method name="remove" type="AWTEventListener" line="2300">
                    <params>
                        <param name="l" type="AWTEventListener"/>
                        <param name="oldl" type="AWTEventListener"/>
                    </params>
                </method>
                <method name="remove" type="EventListener" line="2309">
                    <params>
                        <param name="oldl" type="EventListener"/>
                    </params>
                    <comment line="2315">
                        it&apos;s not here                        
                    </comment>
                    <declaration name="a2" type="AWTEventListener" line="2312"/>
                    <declaration name="b2" type="AWTEventListener" line="2313"/>
                    <scope line="2314"/>
                </method>
                <method name="eventDispatched" type="void" line="2320">
                    <params>
                        <param name="event" type="AWTEvent"/>
                    </params>
                </method>
            </class>
            <class name="SelectiveAWTEventListener" line="2326">
                <comment line="2287">
                    Implementation cloned from AWTEventMulticaster.                    
                </comment>
                <comment line="2305">
                    #4178589: must overload remove(EventListener) to call our add()                    
                </comment>
                <comment line="2306">
                    instead of the static addInternal() so we allocate a                    
                </comment>
                <comment line="2307">
                    ToolkitEventMulticaster instead of an AWTEventMulticaster.                    
                </comment>
                <comment line="2308">
                    Note: this method is called by AWTEventListener.removeInternal(),                    
                </comment>
                <comment line="2309">
                    so its method signature must match AWTEventListener.remove().                    
                </comment>
                <comment line="2330">
                    This array contains the number of times to call the eventlistener                    
                </comment>
                <comment line="2331">
                    for each event type.                    
                </comment>
                <comment line="2541">
                    we do expect that all other fireXXX() methods of java.beans.PropertyChangeSupport
                     use this method.  If this will be changed we will need to change this class.                    
                </comment>
                <implements interface="AWTEventListener"/>
                <declaration name="listener" type="AWTEventListener" line="2327"/>
                <declaration name="eventMask" type="long" line="2328"/>
                <declaration name="calls" type="int[]" line="2331"/>
                <method name="getListener" type="AWTEventListener" line="2333"/>
                <method name="getEventMask" type="long" line="2334"/>
                <method name="getCalls" type="int[]" line="2335"/>
                <method name="orEventMasks" type="void" line="2337">
                    <params>
                        <param name="mask" type="long"/>
                    </params>
                    <comment line="2339">
                        For each event bit set in mask, increment its call count.                        
                    </comment>
                    <comment line="2341">
                        If no bits are set, break out of loop.                        
                    </comment>
                    <comment line="2345">
                        Always test bit 0.                        
                    </comment>
                    <comment line="2348">
                        Right shift, fill with zeros on left.                        
                    </comment>
                    <scope line="2340">
                        <scope line="2342"/>
                        <scope line="2345"/>
                    </scope>
                </method>
                <method name="SelectiveAWTEventListener" type="constructor" line="2352">
                    <params>
                        <param name="l" type="AWTEventListener"/>
                        <param name="mask" type="long"/>
                    </params>
                </method>
                <method name="eventDispatched" type="void" line="2357">
                    <params>
                        <param name="event" type="AWTEvent"/>
                    </params>
                    <comment line="2358">
                        Used to save the bit of the event type.                        
                    </comment>
                    <comment line="2418">
                        Get the index of the call count for this event type.                        
                    </comment>
                    <comment line="2419">
                        Instead of using Math.log(...) we will calculate it with                        
                    </comment>
                    <comment line="2420">
                        bit shifts. That&apos;s what previous implementation looked like:                        
                    </comment>
                    <comment line="2421">
                                                
                    </comment>
                    <comment line="2422">
                        int ci = (int) (Math.log(eventBit)/Math.log(2));                        
                    </comment>
                    <comment line="2427">
                        Call the listener as many times as it was added for this                        
                    </comment>
                    <comment line="2428">
                        event type.                        
                    </comment>
                    <declaration name="eventBit" type="long" line="2358"/>
                    <scope line="2417">
                        <declaration name="ci" type="int" line="2423"/>
                        <scope line="2424"/>
                        <scope line="2429"/>
                    </scope>
                </method>
            </class>
            <method name="mapInputMethodHighlight" type="Map<java.awt.font.TextAttribute,?>" line="2436"/>
            <javadoc line="2436">
                Returns a map of visual attributes for the abstract level description
                  of the given input method highlight, or null if no mapping is found.
                  The style field of the input method highlight is ignored. The map
                  returned is unmodifiable.                
                <param>
                    highlight input method highlight                    
                </param>
                <return>
                    style attribute map, or <code>null</code>                    
                </return>
                <exception>
                    HeadlessException if
                      <code>GraphicsEnvironment.isHeadless</code> returns true                    
                </exception>
                <see>
                    java.awt.GraphicsEnvironment#isHeadless                    
                </see>
                <since>
                    1.3                    
                </since>
            </javadoc>
            <method name="createPropertyChangeSupport" type="PropertyChangeSupport" line="2452">
                <params>
                    <param name="toolkit" type="Toolkit"/>
                </params>
                <scope line="2453"/>
                <scope line="2455"/>
            </method>
            <class name="DesktopPropertyChangeSupport" line="2460">
                <extends class="PropertyChangeSupport"/>
                <comment line="2287">
                    Implementation cloned from AWTEventMulticaster.                    
                </comment>
                <comment line="2305">
                    #4178589: must overload remove(EventListener) to call our add()                    
                </comment>
                <comment line="2306">
                    instead of the static addInternal() so we allocate a                    
                </comment>
                <comment line="2307">
                    ToolkitEventMulticaster instead of an AWTEventMulticaster.                    
                </comment>
                <comment line="2308">
                    Note: this method is called by AWTEventListener.removeInternal(),                    
                </comment>
                <comment line="2309">
                    so its method signature must match AWTEventListener.remove().                    
                </comment>
                <comment line="2330">
                    This array contains the number of times to call the eventlistener                    
                </comment>
                <comment line="2331">
                    for each event type.                    
                </comment>
                <comment line="2541">
                    we do expect that all other fireXXX() methods of java.beans.PropertyChangeSupport
                     use this method.  If this will be changed we will need to change this class.                    
                </comment>
                <declaration name="PROP_CHANGE_SUPPORT_KEY" type="StringBuilder" line="2461"/>
                <declaration name="source" type="Object" line="2463"/>
                <method name="DesktopPropertyChangeSupport" type="constructor" line="2465">
                    <params>
                        <param name="sourceBean" type="Object"/>
                    </params>
                </method>
                <method name="addPropertyChangeListener" type="void" line="2474">
                    <params>
                        <param name="propertyName" type="String"/>
                        <param name="listener" type="PropertyChangeListener"/>
                    </params>
                    <declaration name="pcs" type="PropertyChangeSupport" line="2475"/>
                    <scope line="2477"/>
                </method>
                <method name="removePropertyChangeListener" type="void" line="2488">
                    <params>
                        <param name="propertyName" type="String"/>
                        <param name="listener" type="PropertyChangeListener"/>
                    </params>
                    <declaration name="pcs" type="PropertyChangeSupport" line="2489"/>
                    <scope line="2491"/>
                </method>
                <method name="getPropertyChangeListeners" type="PropertyChangeListener[]" line="2498">
                    <declaration name="pcs" type="PropertyChangeSupport" line="2499"/>
                    <scope line="2501"/>
                    <scope line="2503"/>
                </method>
                <method name="getPropertyChangeListeners" type="PropertyChangeListener[]" line="2510">
                    <params>
                        <param name="propertyName" type="String"/>
                    </params>
                    <declaration name="pcs" type="PropertyChangeSupport" line="2511"/>
                    <scope line="2513"/>
                    <scope line="2515"/>
                </method>
                <method name="addPropertyChangeListener" type="void" line="2521">
                    <params>
                        <param name="listener" type="PropertyChangeListener"/>
                    </params>
                    <declaration name="pcs" type="PropertyChangeSupport" line="2522"/>
                    <scope line="2524"/>
                </method>
                <method name="removePropertyChangeListener" type="void" line="2532">
                    <params>
                        <param name="listener" type="PropertyChangeListener"/>
                    </params>
                    <declaration name="pcs" type="PropertyChangeSupport" line="2533"/>
                    <scope line="2535"/>
                </method>
                <method name="firePropertyChange" type="void" line="2545">
                    <params>
                        <param name="evt" type="PropertyChangeEvent"/>
                    </params>
                    <declaration name="oldValue" type="Object" line="2546"/>
                    <declaration name="newValue" type="Object" line="2547"/>
                    <declaration name="propertyName" type="String" line="2548"/>
                    <scope line="2549"/>
                    <anonymous_class line="2552">
                        <method name="run" type="void" line="2553">
                            <declaration name="pcs" type="PropertyChangeSupport" line="2554"/>
                            <scope line="2556"/>
                        </method>
                    </anonymous_class>
                    <declaration name="updater" type="Runnable" line="2552"/>
                    <declaration name="currentAppContext" type="AppContext" line="2561"/>
                    <scope line="2562">
                        <scope line="2563"/>
                        <scope line="2566"/>
                        <scope line="2568">
                            <declaration name="e" type="PeerEvent" line="2569"/>
                        </scope>
                    </scope>
                </method>
            </class>
            <javadoc line="2576">
                Reports whether events from extra mouse buttons are allowed to be processed and posted into{@code EventQueue}.
                  &lt;br&gt;
                  To change the returned value it is necessary to set the {@code sun.awt.enableExtraMouseButtons}property before the {@code Toolkit} class initialization. This setting could be done on the application
                  startup by the following command:
                  &lt;pre&gt;
                  java -Dsun.awt.enableExtraMouseButtons=false Application
                  &lt;/pre&gt;
                  Alternatively, the property could be set in the application by using the following code:
                  &lt;pre&gt;
                  System.setProperty(&quot;sun.awt.enableExtraMouseButtons&quot;, &quot;true&quot;);
                  &lt;/pre&gt;
                  before the {@code Toolkit} class initialization.
                  If not set by the time of the {@code Toolkit} class initialization, this property will be
                  initialized with {@code true}.
                  Changing this value after the {@code Toolkit} class initialization will have no effect.
                  &lt;p&gt;                
                <exception>
                    HeadlessException if GraphicsEnvironment.isHeadless() returns true                    
                </exception>
                <return>
                    {@code true} if events from extra mouse buttons are allowed to be processed and posted;{@code false} otherwise                    
                </return>
                <see>
                    System#getProperty(String propertyName)                    
                </see>
                <see>
                    System#setProperty(String propertyName,String value)                    
                </see>
                <see>
                    java.awt.EventQueue                    
                </see>
                <since>
                    1.7                    
                </since>
            </javadoc>
            <method name="areExtraMouseButtonsEnabled" type="boolean" line="2603"/>
        </class>
    </source>