<?xml version="1.0" encoding="UTF-8"?>
    <source package="java.awt">
        <import package="java.awt.MultipleGradientPaint.CycleMethod"/>
        <import package="java.awt.MultipleGradientPaint.ColorSpaceType"/>
        <import package="java.awt.color.ColorSpace"/>
        <import package="java.awt.geom.AffineTransform"/>
        <import package="java.awt.geom.NoninvertibleTransformException"/>
        <import package="java.awt.geom.Rectangle2D"/>
        <import package="java.awt.image.ColorModel"/>
        <import package="java.awt.image.DataBuffer"/>
        <import package="java.awt.image.DataBufferInt"/>
        <import package="java.awt.image.DirectColorModel"/>
        <import package="java.awt.image.Raster"/>
        <import package="java.awt.image.SinglePixelPackedSampleModel"/>
        <import package="java.awt.image.WritableRaster"/>
        <import package="java.lang.ref.SoftReference"/>
        <import package="java.lang.ref.WeakReference"/>
        <import package="java.util.Arrays"/>
        <class name="MultipleGradientPaintContext" line="45">
            <implements interface="PaintContext"/>
            <javadoc line="45">
                This is the superclass for all PaintContexts which use a multiple color
                  gradient to fill in their raster.  It provides the actual color
                  interpolation functionality.  Subclasses only have to deal with using
                  the gradient to fill pixels in a raster.                
                <author>
                    Nicholas Talian, Vincent Hardy, Jim Graham, Jerry Evans                    
                </author>
            </javadoc>
            <declaration name="model" type="ColorModel" line="55"/>
            <javadoc line="55">
                The PaintContext&apos;s ColorModel.  This is ARGB if colors are not all
                  opaque, otherwise it is RGB.                
            </javadoc>
            <declaration name="xrgbmodel" type="ColorModel" line="61"/>
            <javadoc line="61">
                Color model used if gradient colors are all opaque.                
            </javadoc>
            <declaration name="cachedModel" type="ColorModel" line="65"/>
            <javadoc line="65">
                The cached ColorModel.                
            </javadoc>
            <declaration name="cached" type="WeakReference&lt;Raster&gt;" line="68"/>
            <javadoc line="68">
                The cached raster, which is reusable among instances.                
            </javadoc>
            <declaration name="saved" type="Raster" line="71"/>
            <javadoc line="71">
                Raster is reused whenever possible.                
            </javadoc>
            <declaration name="cycleMethod" type="CycleMethod" line="74"/>
            <javadoc line="74">
                The method to use when painting out of the gradient bounds.                
            </javadoc>
            <declaration name="colorSpace" type="ColorSpaceType" line="77"/>
            <javadoc line="77">
                The ColorSpace in which to perform the interpolation                
            </javadoc>
            <declaration name="a00" type="float" line="80"/>
            <javadoc line="80">
                Elements of the inverse transform matrix.                
            </javadoc>
            <declaration name="isSimpleLookup" type="boolean" line="83"/>
            <javadoc line="83">
                This boolean specifies wether we are in simple lookup mode, where an
                  input value between 0 and 1 may be used to directly index into a single
                  array of gradient colors.  If this boolean value is false, then we have
                  to use a 2-step process where we have to determine which gradient array
                  we fall into, then determine the index into that array.                
            </javadoc>
            <declaration name="fastGradientArraySize" type="int" line="92"/>
            <javadoc line="92">
                Size of gradients array for scaling the 0-1 index when looking up
                  colors the fast way.                
            </javadoc>
            <declaration name="gradient" type="int[]" line="98"/>
            <javadoc line="98">
                Array which contains the interpolated color values for each interval,
                  used by calculateSingleArrayGradient().  It is protected for possible
                  direct access by subclasses.                
            </javadoc>
            <declaration name="gradients" type="int[][]" line="105"/>
            <javadoc line="105">
                Array of gradient arrays, one array for each interval.  Used by
                  calculateMultipleArrayGradient().                
            </javadoc>
            <declaration name="normalizedIntervals" type="float[]" line="111"/>
            <javadoc line="111">
                Normalized intervals array.                
            </javadoc>
            <declaration name="fractions" type="float[]" line="114"/>
            <javadoc line="114">
                Fractions array.                
            </javadoc>
            <declaration name="transparencyTest" type="int" line="117"/>
            <javadoc line="117">
                Used to determine if gradient colors are all opaque.                
            </javadoc>
            <declaration name="SRGBtoLinearRGB" type="int" line="120"/>
            <javadoc line="120">
                Color space conversion lookup tables.                
            </javadoc>
            <declaration name="LinearRGBtoSRGB" type="int" line="122"/>
            <scope line="124">
                <scope line="126"/>
            </scope>
            <declaration name="GRADIENT_SIZE" type="int" line="132"/>
            <javadoc line="132">
                Constant number of max colors between any 2 arbitrary colors.
                  Used for creating and indexing gradients arrays.                
            </javadoc>
            <declaration name="GRADIENT_SIZE_INDEX" type="int" line="137"/>
            <declaration name="MAX_GRADIENT_ARRAY_SIZE" type="int" line="139"/>
            <javadoc line="139">
                Maximum length of the fast single-array.  If the estimated array size
                  is greater than this, switch over to the slow lookup method.
                  No particular reason for choosing this number, but it seems to provide
                  satisfactory performance for the common case (fast lookup).                
            </javadoc>
            <javadoc line="147">
                Constructor for MultipleGradientPaintContext superclass.                
            </javadoc>
            <method name="MultipleGradientPaintContext" type="constructor" line="160">
                <params>
                    <param name="mgp" type="MultipleGradientPaint"/>
                    <param name="cm" type="ColorModel"/>
                    <param name="deviceBounds" type="Rectangle"/>
                    <param name="userBounds" type="Rectangle2D"/>
                    <param name="t" type="AffineTransform"/>
                    <param name="hints" type="RenderingHints"/>
                    <param name="fractions" type="float[]"/>
                    <param name="colors" type="Color[]"/>
                    <param name="cycleMethod" type="CycleMethod"/>
                    <param name="colorSpace" type="ColorSpaceType"/>
                </params>
                <comment line="178">
                    The inverse transform is needed to go from device to user space.
                     Get all the components of the inverse transform matrix.                    
                </comment>
                <comment line="182">
                    the following assumes that the caller has copied the incoming
                     transform and is not concerned about it being modified                    
                </comment>
                <comment line="187">
                    just use identity transform in this case; better to show
                     (incorrect) results than to throw an exception and/or no-op                    
                </comment>
                <comment line="200">
                    copy some flags                    
                </comment>
                <comment line="204">
                    we can avoid copying this array since we do not modify its values                    
                </comment>
                <comment line="207">
                    note that only one of these values can ever be non-null (we either
                     store the fast gradient array or the slow one, but never both
                     at the same time)                    
                </comment>
                <comment line="216">
                    we need to (re)create the appropriate values                    
                </comment>
                <comment line="219">
                    now cache the calculated values in the
                     MultipleGradientPaint instance for future use                    
                </comment>
                <comment line="225">
                    only cache the fast array                    
                </comment>
                <comment line="229">
                    only cache the slow array                    
                </comment>
                <comment line="233">
                    use the values cached in the MultipleGradientPaint instance                    
                </comment>
                <scope line="161"/>
                <scope line="165"/>
                <scope line="169"/>
                <scope line="173"/>
                <declaration name="tInv" type="AffineTransform" line="179"/>
                <scope line="180"/>
                <scope line="185"/>
                <declaration name="m" type="double" line="190"/>
                <declaration name="gradient" type="int[]" line="209"/>
                <declaration name="gradients" type="int[][]" line="211"/>
                <scope line="214">
                    <scope line="223"/>
                    <scope line="227"/>
                </scope>
                <scope line="231"/>
            </method>
            <javadoc line="242">
                This function is the meat of this class.  It calculates an array of
                  gradient colors based on an array of fractions and color values at
                  those fractions.                
            </javadoc>
            <method name="calculateLookupData" type="void" line="247">
                <params>
                    <param name="colors" type="Color[]"/>
                </params>
                <comment line="251">
                    create a new colors array                    
                </comment>
                <comment line="253">
                    convert the colors using the lookup table                    
                </comment>
                <comment line="263">
                    we can just use this array by reference since we do not
                     modify its values in the case of SRGB                    
                </comment>
                <comment line="268">
                    this will store the intervals (distances) between gradient stops                    
                </comment>
                <comment line="271">
                    convert from fractions into intervals                    
                </comment>
                <comment line="273">
                    interval distance is equal to the difference in positions                    
                </comment>
                <comment line="277">
                    initialize to be fully opaque for ANDing with colors                    
                </comment>
                <comment line="280">
                    array of interpolation arrays                    
                </comment>
                <comment line="283">
                    find smallest interval                    
                </comment>
                <comment line="290">
                    Estimate the size of the entire gradients array.
                     This is to prevent a tiny interval from causing the size of array
                     to explode.  If the estimated size is too large, break to using
                     separate arrays for each interval, and using an indexing scheme at
                     look-up time.                    
                </comment>
                <comment line="301">
                    slow method                    
                </comment>
                <comment line="304">
                    fast method                    
                </comment>
                <comment line="308">
                    use the most &quot;economical&quot; model                    
                </comment>
                <declaration name="normalizedColors" type="Color[]" line="248"/>
                <scope line="249">
                    <scope line="253">
                        <declaration name="argb" type="int" line="254"/>
                        <declaration name="a" type="int" line="255"/>
                        <declaration name="r" type="int" line="256"/>
                        <declaration name="g" type="int" line="257"/>
                        <declaration name="b" type="int" line="258"/>
                    </scope>
                </scope>
                <scope line="261"/>
                <scope line="271"/>
                <declaration name="Imin" type="float" line="283"/>
                <scope line="284"/>
                <declaration name="estimatedSize" type="int" line="294"/>
                <scope line="295"/>
                <scope line="299"/>
                <scope line="302"/>
                <scope line="308"/>
                <scope line="310"/>
            </method>
            <javadoc line="315">
                FAST LOOKUP METHOD
                  This method calculates the gradient color values and places them in a
                  single int array, gradient[].  It does this by allocating space for
                  each interval based on its size relative to the smallest interval in
                  the array.  The smallest interval is allocated 255 interpolated values
                  (the maximum number of unique in-between colors in a 24 bit color
                  system), and all other intervals are allocated
                  size = (255  the ratio of their size to the smallest interval).
                  This scheme expedites a speedy retrieval because the colors are
                  distributed along the array according to their user-specified
                  distribution.  All that is needed is a relative index from 0 to 1.
                  The only problem with this method is that the possibility exists for
                  the array size to balloon in the case where there is a
                  disproportionately small gradient interval.  In this case the other
                  intervals will be allocated huge space, but much of that data is
                  redundant.  We thus need to use the space conserving scheme below.                
                <param>
                    Imin the size of the smallest interval                    
                </param>
            </javadoc>
            <method name="calculateSingleArrayGradient" type="void" line="338">
                <params>
                    <param name="colors" type="Color[]"/>
                    <param name="Imin" type="float"/>
                </params>
                <comment line="340">
                    set the flag so we know later it is a simple (fast) lookup                    
                </comment>
                <comment line="343">
                    2 colors to interpolate                    
                </comment>
                <comment line="346">
                    the eventual size of the single array                    
                </comment>
                <comment line="349">
                    for every interval (transition between 2 colors)                    
                </comment>
                <comment line="351">
                    create an array whose size is based on the ratio to the
                     smallest interval                    
                </comment>
                <comment line="357">
                    the 2 colors (keyframes) to interpolate between                    
                </comment>
                <comment line="361">
                    fill this array with the colors in between rgb1 and rgb2                    
                </comment>
                <comment line="364">
                    if the colors are opaque, transparency should still
                     be 0xff000000                    
                </comment>
                <comment line="370">
                    put all gradients in a single array                    
                </comment>
                <comment line="380">
                    if interpolation occurred in Linear RGB space, convert the
                     gradients back to sRGB using the lookup table                    
                </comment>
                <declaration name="rgb1" type="int" line="343"/>
                <declaration name="gradientsTot" type="int" line="346"/>
                <scope line="349">
                    <declaration name="nGradients" type="int" line="352"/>
                </scope>
                <declaration name="curOffset" type="int" line="371"/>
                <scope line="372"/>
                <scope line="381">
                    <scope line="382"/>
                </scope>
            </method>
            <javadoc line="390">
                SLOW LOOKUP METHOD
                  This method calculates the gradient color values for each interval and
                  places each into its own 255 size array.  The arrays are stored in
                  gradients[][].  (255 is used because this is the maximum number of
                  unique colors between 2 arbitrary colors in a 24 bit color system.)
                  This method uses the minimum amount of space (only 255  number of
                  intervals), but it aggravates the lookup procedure, because now we
                  have to find out which interval to select, then calculate the index
                  within that interval.  This causes a significant performance hit,
                  because it requires this calculation be done for every point in
                  the rendering loop.
                  For those of you who are interested, this is a classic example of the
                  time-space tradeoff.                
            </javadoc>
            <method name="calculateMultipleArrayGradient" type="void" line="408">
                <params>
                    <param name="colors" type="Color[]"/>
                </params>
                <comment line="410">
                    set the flag so we know later it is a non-simple lookup                    
                </comment>
                <comment line="413">
                    2 colors to interpolate                    
                </comment>
                <comment line="416">
                    for every interval (transition between 2 colors)                    
                </comment>
                <comment line="418">
                    create an array of the maximum theoretical size for
                     each interval                    
                </comment>
                <comment line="422">
                    get the the 2 colors                    
                </comment>
                <comment line="426">
                    fill this array with the colors in between rgb1 and rgb2                    
                </comment>
                <comment line="429">
                    if the colors are opaque, transparency should still
                     be 0xff000000                    
                </comment>
                <comment line="435">
                    if interpolation occurred in Linear RGB space, convert the
                     gradients back to SRGB using the lookup table                    
                </comment>
                <declaration name="rgb1" type="int" line="413"/>
                <scope line="416"/>
                <scope line="436">
                    <scope line="437">
                        <scope line="438"/>
                    </scope>
                </scope>
            </method>
            <javadoc line="446">
                Yet another helper function.  This one linearly interpolates between
                  2 colors, filling up the output array.                
                <param>
                    rgb1 the start color                    
                </param>
                <param>
                    rgb2 the end color                    
                </param>
                <param>
                    output the output array of colors; must not be null                    
                </param>
            </javadoc>
            <method name="interpolate" type="void" line="454">
                <params>
                    <param name="rgb1" type="int"/>
                    <param name="rgb2" type="int"/>
                    <param name="output" type="int[]"/>
                </params>
                <comment line="456">
                    color components                    
                </comment>
                <comment line="459">
                    step between interpolated values                    
                </comment>
                <comment line="462">
                    extract color components from packed integer                    
                </comment>
                <comment line="468">
                    calculate the total change in alpha, red, green, blue                    
                </comment>
                <comment line="474">
                    for each step in the interval calculate the in-between color by
                     multiplying the normalized current position by the total color
                     change (0.5 is added to prevent truncation round-off error)                    
                </comment>
                <declaration name="a1" type="int" line="456"/>
                <declaration name="stepSize" type="float" line="459"/>
                <scope line="476"/>
            </method>
            <javadoc line="485">
                Yet another helper function.  This one extracts the color components
                  of an integer RGB triple, converts them from LinearRGB to SRGB, then
                  recompacts them into an int.                
            </javadoc>
            <method name="convertEntireColorLinearRGBtoSRGB" type="int" line="490">
                <params>
                    <param name="rgb" type="int"/>
                </params>
                <comment line="492">
                    color components                    
                </comment>
                <comment line="495">
                    extract red, green, blue components                    
                </comment>
                <comment line="501">
                    use the lookup table                    
                </comment>
                <comment line="506">
                    re-compact the components                    
                </comment>
                <declaration name="a1" type="int" line="492"/>
            </method>
            <javadoc line="512">
                Helper function to index into the gradients array.  This is necessary
                  because each interval has an array of colors with uniform size 255.
                  However, the color intervals are not necessarily of uniform length, so
                  a conversion is required.                
                <param>
                    position the unmanipulated position, which will be mapped
                      into the range 0 to 1                    
                </param>
                <returns>
                    integer color to display                    
                </returns>
            </javadoc>
            <method name="indexIntoGradientsArrays" type="int" line="522">
                <params>
                    <param name="position" type="float"/>
                </params>
                <comment line="524">
                    first, manipulate position value depending on the cycle method                    
                </comment>
                <comment line="527">
                    upper bound is 1                    
                </comment>
                <comment line="530">
                    lower bound is 0                    
                </comment>
                <comment line="534">
                    get the fractional part
                     (modulo behavior discards integer component)                    
                </comment>
                <comment line="538">
                    position should now be between -1 and 1                    
                </comment>
                <comment line="540">
                    force it to be in the range 0-1                    
                </comment>
                <comment line="543">
                    cycleMethod == CycleMethod.REFLECT                    
                </comment>
                <comment line="545">
                    take absolute value                    
                </comment>
                <comment line="549">
                    get the integer part                    
                </comment>
                <comment line="552">
                    get the fractional part                    
                </comment>
                <comment line="556">
                    integer part is odd, get reflected color instead                    
                </comment>
                <comment line="561">
                    now, get the color based on this 0-1 position...                    
                </comment>
                <comment line="564">
                    easy to compute: just scale index by array size                    
                </comment>
                <comment line="567">
                    more complicated computation, to save space                    
                </comment>
                <comment line="569">
                    for all the gradient interval arrays                    
                </comment>
                <comment line="572">
                    this is the array we want                    
                </comment>
                <comment line="575">
                    this is the interval we want                    
                </comment>
                <scope line="524">
                    <scope line="525"/>
                    <scope line="528"/>
                </scope>
                <scope line="532">
                    <scope line="538"/>
                </scope>
                <scope line="542">
                    <scope line="543"/>
                    <declaration name="part" type="int" line="549"/>
                    <scope line="554"/>
                </scope>
                <scope line="562"/>
                <scope line="565">
                    <scope line="569">
                        <scope line="570">
                            <declaration name="delta" type="float" line="572"/>
                            <declaration name="index" type="int" line="575"/>
                        </scope>
                    </scope>
                </scope>
            </method>
            <javadoc line="586">
                Helper function to convert a color component in sRGB space to linear
                  RGB space.  Used to build a static lookup table.                
            </javadoc>
            <method name="convertSRGBtoLinearRGB" type="int" line="590">
                <params>
                    <param name="color" type="int"/>
                </params>
                <declaration name="input" type="float" line="591"/>
                <scope line="594"/>
                <scope line="596"/>
            </method>
            <javadoc line="603">
                Helper function to convert a color component in linear RGB space to
                  SRGB space.  Used to build a static lookup table.                
            </javadoc>
            <method name="convertLinearRGBtoSRGB" type="int" line="607">
                <params>
                    <param name="color" type="int"/>
                </params>
                <declaration name="input" type="float" line="608"/>
                <scope line="611"/>
                <scope line="613"/>
            </method>
            <javadoc line="621">
                {@inheritDoc}                
            </javadoc>
            <method name="getRaster" type="Raster" line="624">
                <params>
                    <param name="x" type="int"/>
                    <param name="y" type="int"/>
                    <param name="w" type="int"/>
                    <param name="h" type="int"/>
                </params>
                <comment line="626">
                    If working raster is big enough, reuse it. Otherwise,
                     build a large enough new one.                    
                </comment>
                <comment line="636">
                    Access raster internal int array. Because we use a DirectColorModel,
                     we know the DataBuffer is of type DataBufferInt and the SampleModel
                     is SinglePixelPackedSampleModel.
                     Adjust for initial offset in DataBuffer and also for the scanline
                     stride.
                     These calls make the DataBuffer non-acceleratable, but the
                     Raster is never Stable long enough to accelerate anyway...                    
                </comment>
                <comment line="650">
                    delegate to subclass                    
                </comment>
                <declaration name="raster" type="Raster" line="627"/>
                <scope line="630"/>
                <declaration name="rasterDB" type="DataBufferInt" line="642"/>
                <declaration name="pixels" type="int[]" line="643"/>
                <declaration name="off" type="int" line="644"/>
                <declaration name="scanlineStride" type="int" line="645"/>
                <declaration name="adjust" type="int" line="647"/>
            </method>
            <method name="fillRaster" type="void" line="654"/>
            <javadoc line="658">
                Took this cacheRaster code from GradientPaint. It appears to recycle
                  rasters for use by any other instance, as long as they are sufficiently
                  large.                
            </javadoc>
            <method name="getCachedRaster" type="Raster" line="665">
                <params>
                    <param name="cm" type="ColorModel"/>
                    <param name="w" type="int"/>
                    <param name="h" type="int"/>
                </params>
                <scope line="666">
                    <scope line="667">
                        <declaration name="ras" type="Raster" line="668"/>
                        <scope line="672"/>
                    </scope>
                </scope>
            </method>
            <javadoc line="681">
                Took this cacheRaster code from GradientPaint. It appears to recycle
                  rasters for use by any other instance, as long as they are sufficiently
                  large.                
            </javadoc>
            <method name="putCachedRaster" type="void" line="688">
                <params>
                    <param name="cm" type="ColorModel"/>
                    <param name="ras" type="Raster"/>
                </params>
                <scope line="689">
                    <declaration name="cras" type="Raster" line="690"/>
                    <scope line="691">
                        <declaration name="cw" type="int" line="692"/>
                        <declaration name="ch" type="int" line="693"/>
                        <declaration name="iw" type="int" line="694"/>
                        <declaration name="ih" type="int" line="695"/>
                        <scope line="696"/>
                        <scope line="699"/>
                    </scope>
                </scope>
            </method>
            <javadoc line="708">
                {@inheritDoc}                
            </javadoc>
            <method name="dispose" type="void" line="711">
                <scope line="712"/>
            </method>
            <javadoc line="718">
                {@inheritDoc}                
            </javadoc>
            <method name="getColorModel" type="ColorModel" line="721"/>
        </class>
    </source>