<?xml version="1.0" encoding="UTF-8"?>
    <source package="java.awt">
        <import package="java.awt.MultipleGradientPaint.CycleMethod"/>
        <import package="java.awt.MultipleGradientPaint.ColorSpaceType"/>
        <import package="java.awt.color.ColorSpace"/>
        <import package="java.awt.geom.AffineTransform"/>
        <import package="java.awt.geom.NoninvertibleTransformException"/>
        <import package="java.awt.geom.Rectangle2D"/>
        <import package="java.awt.image.ColorModel"/>
        <import package="java.awt.image.DataBuffer"/>
        <import package="java.awt.image.DataBufferInt"/>
        <import package="java.awt.image.DirectColorModel"/>
        <import package="java.awt.image.Raster"/>
        <import package="java.awt.image.SinglePixelPackedSampleModel"/>
        <import package="java.awt.image.WritableRaster"/>
        <import package="java.lang.ref.SoftReference"/>
        <import package="java.lang.ref.WeakReference"/>
        <import package="java.util.Arrays"/>
        <class name="MultipleGradientPaintContext" line="18">
            <implements interface="PaintContext"/>
            <javadoc line="18">
                This is the superclass for all PaintContexts which use a multiple color
                  gradient to fill in their raster.  It provides the actual color
                  interpolation functionality.  Subclasses only have to deal with using
                  the gradient to fill pixels in a raster.                
                <author>
                    Nicholas Talian, Vincent Hardy, Jim Graham, Jerry Evans                    
                </author>
            </javadoc>
            <declaration name="model" type="ColorModel" line="26"/>
            <javadoc line="26">
                The PaintContext&apos;s ColorModel.  This is ARGB if colors are not all
                  opaque, otherwise it is RGB.                
            </javadoc>
            <declaration name="xrgbmodel" type="ColorModel" line="31"/>
            <javadoc line="31">
                Color model used if gradient colors are all opaque.                
            </javadoc>
            <declaration name="cachedModel" type="ColorModel" line="35"/>
            <javadoc line="35">
                The cached ColorModel.                
            </javadoc>
            <declaration name="cached" type="WeakReference&amp;lt;Raster&amp;gt;" line="39"/>
            <javadoc line="39">
                The cached raster, which is reusable among instances.                
            </javadoc>
            <declaration name="saved" type="Raster" line="43"/>
            <javadoc line="43">
                Raster is reused whenever possible.                
            </javadoc>
            <declaration name="cycleMethod" type="CycleMethod" line="47"/>
            <javadoc line="47">
                The method to use when painting out of the gradient bounds.                
            </javadoc>
            <declaration name="colorSpace" type="ColorSpaceType" line="51"/>
            <javadoc line="51">
                The ColorSpace in which to perform the interpolation                
            </javadoc>
            <declaration name="a00" type="float" line="55"/>
            <javadoc line="55">
                Elements of the inverse transform matrix.                
            </javadoc>
            <declaration name="isSimpleLookup" type="boolean" line="59"/>
            <javadoc line="59">
                This boolean specifies wether we are in simple lookup mode, where an
                  input value between 0 and 1 may be used to directly index into a single
                  array of gradient colors.  If this boolean value is false, then we have
                  to use a 2-step process where we have to determine which gradient array
                  we fall into, then determine the index into that array.                
            </javadoc>
            <declaration name="fastGradientArraySize" type="int" line="67"/>
            <javadoc line="67">
                Size of gradients array for scaling the 0-1 index when looking up
                  colors the fast way.                
            </javadoc>
            <declaration name="gradient" type="int[]" line="72"/>
            <javadoc line="72">
                Array which contains the interpolated color values for each interval,
                  used by calculateSingleArrayGradient().  It is protected for possible
                  direct access by subclasses.                
            </javadoc>
            <declaration name="gradients" type="int[][]" line="78"/>
            <javadoc line="78">
                Array of gradient arrays, one array for each interval.  Used by
                  calculateMultipleArrayGradient().                
            </javadoc>
            <declaration name="normalizedIntervals" type="float[]" line="83"/>
            <javadoc line="83">
                Normalized intervals array.                
            </javadoc>
            <declaration name="fractions" type="float[]" line="87"/>
            <javadoc line="87">
                Fractions array.                
            </javadoc>
            <declaration name="transparencyTest" type="int" line="91"/>
            <javadoc line="91">
                Used to determine if gradient colors are all opaque.                
            </javadoc>
            <declaration name="SRGBtoLinearRGB" type="int" line="95"/>
            <javadoc line="95">
                Color space conversion lookup tables.                
            </javadoc>
            <declaration name="LinearRGBtoSRGB" type="int" line="99"/>
            <scope line="100">
                <scope line="101"/>
            </scope>
            <declaration name="GRADIENT_SIZE" type="int" line="106"/>
            <javadoc line="106">
                Constant number of max colors between any 2 arbitrary colors.
                  Used for creating and indexing gradients arrays.                
            </javadoc>
            <declaration name="GRADIENT_SIZE_INDEX" type="int" line="111"/>
            <declaration name="MAX_GRADIENT_ARRAY_SIZE" type="int" line="112"/>
            <javadoc line="112">
                Maximum length of the fast single-array.  If the estimated array size
                  is greater than this, switch over to the slow lookup method.
                  No particular reason for choosing this number, but it seems to provide
                  satisfactory performance for the common case (fast lookup).                
            </javadoc>
            <javadoc line="119">
                Constructor for MultipleGradientPaintContext superclass.                
            </javadoc>
            <method name="MultipleGradientPaintContext" type="constructor" line="122">
                <params>
                    <param name="mgp" type="MultipleGradientPaint"/>
                    <param name="cm" type="ColorModel"/>
                    <param name="deviceBounds" type="Rectangle"/>
                    <param name="userBounds" type="Rectangle2D"/>
                    <param name="t" type="AffineTransform"/>
                    <param name="hints" type="RenderingHints"/>
                    <param name="fractions" type="float[]"/>
                    <param name="colors" type="Color[]"/>
                    <param name="cycleMethod" type="CycleMethod"/>
                    <param name="colorSpace" type="ColorSpaceType"/>
                </params>
                <scope line="123"/>
                <scope line="126"/>
                <scope line="129"/>
                <scope line="132"/>
                <declaration name="tInv" type="AffineTransform" line="135"/>
                <scope line="136"/>
                <scope line="140"/>
                <declaration name="m" type="double" line="143"/>
                <declaration name="gradient" type="int[]" line="154"/>
                <declaration name="gradients" type="int[][]" line="155"/>
                <scope line="156">
                    <scope line="161"/>
                    <scope line="165"/>
                </scope>
                <scope line="169"/>
            </method>
            <javadoc line="178">
                This function is the meat of this class.  It calculates an array of
                  gradient colors based on an array of fractions and color values at
                  those fractions.                
            </javadoc>
            <method name="calculateLookupData" type="void" line="183">
                <params>
                    <param name="colors" type="Color[]"/>
                </params>
                <declaration name="normalizedColors" type="Color[]" line="184"/>
                <scope line="185">
                    <scope line="187">
                        <declaration name="argb" type="int" line="188"/>
                        <declaration name="a" type="int" line="189"/>
                        <declaration name="r" type="int" line="190"/>
                        <declaration name="g" type="int" line="191"/>
                        <declaration name="b" type="int" line="192"/>
                    </scope>
                </scope>
                <scope line="196"/>
                <scope line="200"/>
                <declaration name="Imin" type="float" line="205"/>
                <scope line="206"/>
                <declaration name="estimatedSize" type="int" line="209"/>
                <scope line="210"/>
                <scope line="213"/>
                <scope line="216"/>
                <scope line="219"/>
                <scope line="222"/>
            </method>
            <javadoc line="226">
                FAST LOOKUP METHOD
                  This method calculates the gradient color values and places them in a
                  single int array, gradient[].  It does this by allocating space for
                  each interval based on its size relative to the smallest interval in
                  the array.  The smallest interval is allocated 255 interpolated values
                  (the maximum number of unique in-between colors in a 24 bit color
                  system), and all other intervals are allocated
                  size = (255  the ratio of their size to the smallest interval).
                  This scheme expedites a speedy retrieval because the colors are
                  distributed along the array according to their user-specified
                  distribution.  All that is needed is a relative index from 0 to 1.
                  The only problem with this method is that the possibility exists for
                  the array size to balloon in the case where there is a
                  disproportionately small gradient interval.  In this case the other
                  intervals will be allocated huge space, but much of that data is
                  redundant.  We thus need to use the space conserving scheme below.                
                <param>
                    Imin the size of the smallest interval                    
                </param>
            </javadoc>
            <method name="calculateSingleArrayGradient" type="void" line="245">
                <params>
                    <param name="colors" type="Color[]"/>
                    <param name="Imin" type="float"/>
                </params>
                <declaration name="rgb1" type="int" line="247"/>
                <declaration name="gradientsTot" type="int" line="248"/>
                <scope line="249">
                    <declaration name="nGradients" type="int" line="250"/>
                </scope>
                <declaration name="curOffset" type="int" line="260"/>
                <scope line="261"/>
                <scope line="266">
                    <scope line="267"/>
                </scope>
            </method>
            <javadoc line="273">
                SLOW LOOKUP METHOD
                  This method calculates the gradient color values for each interval and
                  places each into its own 255 size array.  The arrays are stored in
                  gradients[][].  (255 is used because this is the maximum number of
                  unique colors between 2 arbitrary colors in a 24 bit color system.)
                  This method uses the minimum amount of space (only 255  number of
                  intervals), but it aggravates the lookup procedure, because now we
                  have to find out which interval to select, then calculate the index
                  within that interval.  This causes a significant performance hit,
                  because it requires this calculation be done for every point in
                  the rendering loop.
                  For those of you who are interested, this is a classic example of the
                  time-space tradeoff.                
            </javadoc>
            <method name="calculateMultipleArrayGradient" type="void" line="288">
                <params>
                    <param name="colors" type="Color[]"/>
                </params>
                <declaration name="rgb1" type="int" line="290"/>
                <scope line="291"/>
                <scope line="299">
                    <scope line="300">
                        <scope line="301"/>
                    </scope>
                </scope>
            </method>
            <javadoc line="307">
                Yet another helper function.  This one linearly interpolates between
                  2 colors, filling up the output array.                
                <param>
                    rgb1 the start color                    
                </param>
                <param>
                    rgb2 the end color                    
                </param>
                <param>
                    output the output array of colors; must not be null                    
                </param>
            </javadoc>
            <method name="interpolate" type="void" line="314">
                <params>
                    <param name="rgb1" type="int"/>
                    <param name="rgb2" type="int"/>
                    <param name="output" type="int[]"/>
                </params>
                <declaration name="a1" type="int" line="315"/>
                <declaration name="stepSize" type="float" line="316"/>
                <scope line="325"/>
            </method>
            <javadoc line="329">
                Yet another helper function.  This one extracts the color components
                  of an integer RGB triple, converts them from LinearRGB to SRGB, then
                  recompacts them into an int.                
            </javadoc>
            <method name="convertEntireColorLinearRGBtoSRGB" type="int" line="334">
                <params>
                    <param name="rgb" type="int"/>
                </params>
                <declaration name="a1" type="int" line="335"/>
            </method>
            <javadoc line="345">
                Helper function to index into the gradients array.  This is necessary
                  because each interval has an array of colors with uniform size 255.
                  However, the color intervals are not necessarily of uniform length, so
                  a conversion is required.                
                <param>
                    position the unmanipulated position, which will be mapped
                      into the range 0 to 1                    
                </param>
                <returns>
                    integer color to display                    
                </returns>
            </javadoc>
            <method name="indexIntoGradientsArrays" type="int" line="354">
                <params>
                    <param name="position" type="float"/>
                </params>
                <scope line="355">
                    <scope line="356"/>
                    <scope line="359"/>
                </scope>
                <scope line="363">
                    <scope line="365"/>
                </scope>
                <scope line="369">
                    <scope line="370"/>
                    <declaration name="part" type="int" line="373"/>
                    <scope line="375"/>
                </scope>
                <scope line="379"/>
                <scope line="382">
                    <scope line="383">
                        <scope line="384">
                            <declaration name="delta" type="float" line="385"/>
                            <declaration name="index" type="int" line="386"/>
                        </scope>
                    </scope>
                </scope>
            </method>
            <javadoc line="393">
                Helper function to convert a color component in sRGB space to linear
                  RGB space.  Used to build a static lookup table.                
            </javadoc>
            <method name="convertSRGBtoLinearRGB" type="int" line="397">
                <params>
                    <param name="color" type="int"/>
                </params>
                <declaration name="input" type="float" line="398"/>
                <scope line="400"/>
                <scope line="403"/>
            </method>
            <javadoc line="408">
                Helper function to convert a color component in linear RGB space to
                  SRGB space.  Used to build a static lookup table.                
            </javadoc>
            <method name="convertLinearRGBtoSRGB" type="int" line="412">
                <params>
                    <param name="color" type="int"/>
                </params>
                <declaration name="input" type="float" line="413"/>
                <scope line="415"/>
                <scope line="418"/>
            </method>
            <javadoc line="423">
                {@inheritDoc}                
            </javadoc>
            <method name="getRaster" type="Raster" line="426">
                <params>
                    <param name="x" type="int"/>
                    <param name="y" type="int"/>
                    <param name="w" type="int"/>
                    <param name="h" type="int"/>
                </params>
                <declaration name="raster" type="Raster" line="427"/>
                <scope line="428"/>
                <declaration name="rasterDB" type="DataBufferInt" line="432"/>
                <declaration name="pixels" type="int[]" line="433"/>
                <declaration name="off" type="int" line="434"/>
                <declaration name="scanlineStride" type="int" line="435"/>
                <declaration name="adjust" type="int" line="436"/>
            </method>
            <method name="fillRaster" type="void" line="440"/>
            <javadoc line="441">
                Took this cacheRaster code from GradientPaint. It appears to recycle
                  rasters for use by any other instance, as long as they are sufficiently
                  large.                
            </javadoc>
            <method name="getCachedRaster" type="Raster" line="446">
                <params>
                    <param name="cm" type="ColorModel"/>
                    <param name="w" type="int"/>
                    <param name="h" type="int"/>
                </params>
                <scope line="447">
                    <scope line="448">
                        <declaration name="ras" type="Raster" line="449"/>
                        <scope line="450"/>
                    </scope>
                </scope>
            </method>
            <javadoc line="458">
                Took this cacheRaster code from GradientPaint. It appears to recycle
                  rasters for use by any other instance, as long as they are sufficiently
                  large.                
            </javadoc>
            <method name="putCachedRaster" type="void" line="463">
                <params>
                    <param name="cm" type="ColorModel"/>
                    <param name="ras" type="Raster"/>
                </params>
                <scope line="464">
                    <declaration name="cras" type="Raster" line="465"/>
                    <scope line="466">
                        <declaration name="cw" type="int" line="467"/>
                        <declaration name="ch" type="int" line="468"/>
                        <declaration name="iw" type="int" line="469"/>
                        <declaration name="ih" type="int" line="470"/>
                        <scope line="471"/>
                        <scope line="474"/>
                    </scope>
                </scope>
            </method>
            <javadoc line="482">
                {@inheritDoc}                
            </javadoc>
            <method name="dispose" type="void" line="485">
                <scope line="486"/>
            </method>
            <javadoc line="491">
                {@inheritDoc}                
            </javadoc>
            <method name="getColorModel" type="ColorModel" line="494"/>
        </class>
    </source>